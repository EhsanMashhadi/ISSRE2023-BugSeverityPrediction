{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-369_f4a4464b", "label": 3, "code": "/**\n * {@inheritDoc}\n */\npublic double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException {\n    return solve(min, max);\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "public double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException {\n    return solve(min, max);\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.9360112755461594, "fo": -0.4166666666666667, "r": 1.9736842105263157, "e": -0.16279340490885932}
{"project_name": "Closure", "project_version": 56, "label": 2, "code": "/**\n * Gets the source line for the indicated line number.\n *\n * @param lineNumber the line number, 1 being the first line of the file.\n * @return The line indicated. Does not include the newline at the end\n *     of the file. Returns {@code null} if it does not exist,\n *     or if there was an IO exception.\n */\npublic String getLine(int lineNumber) {\n    String js = \"\";\n    try {\n        // NOTE(nicksantos): Right now, this is optimized for few warnings.\n        // This is probably the right trade-off, but will be slow if there\n        // are lots of warnings in one file.\n        js = getCode();\n    } catch (IOException e) {\n        return null;\n    }\n    int pos = 0;\n    int startLine = 1;\n    // one we're searching for, then start at that point.\n    if (lineNumber >= lastLine) {\n        pos = lastOffset;\n        startLine = lastLine;\n    }\n    for (int n = startLine; n < lineNumber; n++) {\n        int nextpos = js.indexOf('\\n', pos);\n        if (nextpos == -1) {\n            return null;\n        }\n        pos = nextpos + 1;\n    }\n    // Remember this offset for the next search we do.\n    lastOffset = pos;\n    lastLine = lineNumber;\n    if (js.indexOf('\\n', pos) == -1) {\n        // 2. otherwise, return the contents between pos and the end of file.\n        return null;\n    } else {\n        return js.substring(pos, js.indexOf('\\n', pos));\n    }\n}", "code_comment": "/**\n * Gets the source line for the indicated line number.\n *\n * @param lineNumber the line number, 1 being the first line of the file.\n * @return The line indicated. Does not include the newline at the end\n *     of the file. Returns {@code null} if it does not exist,\n *     or if there was an IO exception.\n */\n", "code_no_comment": "public String getLine(int lineNumber) {\n    String js = \"\";\n    try {\n                                js = getCode();\n    } catch (IOException e) {\n        return null;\n    }\n    int pos = 0;\n    int startLine = 1;\n        if (lineNumber >= lastLine) {\n        pos = lastOffset;\n        startLine = lastLine;\n    }\n    for (int n = startLine; n < lineNumber; n++) {\n        int nextpos = js.indexOf('\\n', pos);\n        if (nextpos == -1) {\n            return null;\n        }\n        pos = nextpos + 1;\n    }\n        lastOffset = pos;\n    lastLine = lineNumber;\n    if (js.indexOf('\\n', pos) == -1) {\n                return null;\n    } else {\n        return js.substring(pos, js.indexOf('\\n', pos));\n    }\n}", "lc": 0.6363636363636364, "pi": -0.1578947368421053, "ma": 0.4, "nbd": 0.0, "ml": 0.4166666666666667, "d": 1.1944444444444444, "mi": -0.44411557434813226, "fo": -0.08333333333333333, "r": -0.02631578947368421, "e": 1.1258565146983395}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4138_7c89598a", "label": 1, "code": "@Override\npublic boolean shouldPreserveClientUrl() {\n    return errorAttributes != null && !Strings.isEmpty(errorAttributes.getRequestUri());\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean shouldPreserveClientUrl() {\n    return errorAttributes != null && !Strings.isEmpty(errorAttributes.getRequestUri());\n}", "lc": -0.45454545454545453, "pi": -0.6028708133971293, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.14285714285714285, "mi": 0.791966173361522, "fo": -0.3333333333333333, "r": 1.4210526315789473, "e": -0.14126311785757506}
{"project_name": "Closure", "project_version": 39, "label": 2, "code": "@Override\nString toStringHelper(boolean forAnnotations) {\n    if (hasReferenceName()) {\n        return getReferenceName();\n    } else if (prettyPrint) {\n        // Don't pretty print recursively.\n        prettyPrint = false;\n        // Use a tree set so that the properties are sorted.\n        Set<String> propertyNames = Sets.newTreeSet();\n        for (ObjectType current = this; current != null && !current.isNativeObjectType() && propertyNames.size() <= MAX_PRETTY_PRINTED_PROPERTIES; current = current.getImplicitPrototype()) {\n            propertyNames.addAll(current.getOwnPropertyNames());\n        }\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"{\");\n        int i = 0;\n        for (String property : propertyNames) {\n            if (i > 0) {\n                sb.append(\", \");\n            }\n            sb.append(property);\n            sb.append(\": \");\n            sb.append(getPropertyType(property).toString());\n            ++i;\n            if (i == MAX_PRETTY_PRINTED_PROPERTIES) {\n                sb.append(\", ...\");\n                break;\n            }\n        }\n        sb.append(\"}\");\n        prettyPrint = true;\n        return sb.toString();\n    } else {\n        return \"{...}\";\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\nString toStringHelper(boolean forAnnotations) {\n    if (hasReferenceName()) {\n        return getReferenceName();\n    } else if (prettyPrint) {\n                prettyPrint = false;\n                Set<String> propertyNames = Sets.newTreeSet();\n        for (ObjectType current = this; current != null && !current.isNativeObjectType() && propertyNames.size() <= MAX_PRETTY_PRINTED_PROPERTIES; current = current.getImplicitPrototype()) {\n            propertyNames.addAll(current.getOwnPropertyNames());\n        }\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"{\");\n        int i = 0;\n        for (String property : propertyNames) {\n            if (i > 0) {\n                sb.append(\", \");\n            }\n            sb.append(property);\n            sb.append(\": \");\n            sb.append(getPropertyType(property).toString());\n            ++i;\n            if (i == MAX_PRETTY_PRINTED_PROPERTIES) {\n                sb.append(\", ...\");\n                break;\n            }\n        }\n        sb.append(\"}\");\n        prettyPrint = true;\n        return sb.toString();\n    } else {\n        return \"{...}\";\n    }\n}", "lc": 0.8636363636363636, "pi": 0.5741626794258374, "ma": 0.8, "nbd": 1.0, "ml": 0.6666666666666666, "d": 1.1785714285714286, "mi": -0.5751937984496123, "fo": 1.0, "r": -0.02631578947368421, "e": 1.551801202146113}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-621_00b4b8a0", "label": 1, "code": "@Override\npublic Iterable<Tree> getChildren() {\n    root.checkLive();\n    Iterable<String> childNames;\n    if (hasOrderableChildren()) {\n        childNames = getOrderedChildNames();\n    } else {\n        childNames = getNodeBuilder().getChildNodeNames();\n    }\n    return Iterables.filter(Iterables.transform(childNames, new Function<String, Tree>() {\n\n        @Override\n        public Tree apply(String input) {\n            return new TreeImpl(root, TreeImpl.this, input);\n        }\n    }), new Predicate<Tree>() {\n\n        @Override\n        public boolean apply(Tree tree) {\n            return tree != null && canRead(tree);\n        }\n    });\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic Iterable<Tree> getChildren() {\n    root.checkLive();\n    Iterable<String> childNames;\n    if (hasOrderableChildren()) {\n        childNames = getOrderedChildNames();\n    } else {\n        childNames = getNodeBuilder().getChildNodeNames();\n    }\n    return Iterables.filter(Iterables.transform(childNames, new Function<String, Tree>() {\n\n        @Override\n        public Tree apply(String input) {\n            return new TreeImpl(root, TreeImpl.this, input);\n        }\n    }), new Predicate<Tree>() {\n\n        @Override\n        public boolean apply(Tree tree) {\n            return tree != null && canRead(tree);\n        }\n    });\n}", "lc": 0.3181818181818182, "pi": 0.1961722488038276, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": -0.009920634920634929, "mi": -0.21860465116279051, "fo": 0.16666666666666666, "r": 0.0, "e": 0.021804602271744935}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-3498_b4606700", "label": 1, "code": "@SuppressWarnings(\"unchecked\")\nprivate Iterable<ProcessorExchangePair> createProcessorExchangePairsIterable(final Exchange exchange, final Object value) {\n    final Iterator iterator = ObjectHelper.createIterator(value);\n    return new Iterable() {\n\n        public Iterator iterator() {\n            return new Iterator() {\n\n                private int index;\n\n                private boolean closed;\n\n                public boolean hasNext() {\n                    if (closed) {\n                        return false;\n                    }\n                    boolean answer = iterator.hasNext();\n                    if (!answer) {\n                        // we are now closed\n                        closed = true;\n                        // nothing more so we need to close the expression value in case it needs to be\n                        if (value instanceof Closeable) {\n                            IOHelper.close((Closeable) value, value.getClass().getName(), LOG);\n                        } else if (value instanceof Scanner) {\n                            // special for Scanner as it does not implement Closeable\n                            ((Scanner) value).close();\n                        }\n                    }\n                    return answer;\n                }\n\n                public Object next() {\n                    Object part = iterator.next();\n                    Exchange newExchange = ExchangeHelper.createCopy(exchange, true);\n                    if (part instanceof Message) {\n                        newExchange.setIn((Message) part);\n                    } else {\n                        Message in = newExchange.getIn();\n                        in.setBody(part);\n                    }\n                    return createProcessorExchangePair(index++, getProcessors().iterator().next(), newExchange);\n                }\n\n                public void remove() {\n                    throw new UnsupportedOperationException(\"Remove is not supported by this iterator\");\n                }\n            };\n        }\n    };\n}", "code_comment": NaN, "code_no_comment": "@SuppressWarnings(\"unchecked\")\nprivate Iterable<ProcessorExchangePair> createProcessorExchangePairsIterable(final Exchange exchange, final Object value) {\n    final Iterator iterator = ObjectHelper.createIterator(value);\n    return new Iterable() {\n\n        public Iterator iterator() {\n            return new Iterator() {\n\n                private int index;\n\n                private boolean closed;\n\n                public boolean hasNext() {\n                    if (closed) {\n                        return false;\n                    }\n                    boolean answer = iterator.hasNext();\n                    if (!answer) {\n                                                closed = true;\n                                                if (value instanceof Closeable) {\n                            IOHelper.close((Closeable) value, value.getClass().getName(), LOG);\n                        } else if (value instanceof Scanner) {\n                                                        ((Scanner) value).close();\n                        }\n                    }\n                    return answer;\n                }\n\n                public Object next() {\n                    Object part = iterator.next();\n                    Exchange newExchange = ExchangeHelper.createCopy(exchange, true);\n                    if (part instanceof Message) {\n                        newExchange.setIn((Message) part);\n                    } else {\n                        Message in = newExchange.getIn();\n                        in.setBody(part);\n                    }\n                    return createProcessorExchangePair(index++, getProcessors().iterator().next(), newExchange);\n                }\n\n                public void remove() {\n                    throw new UnsupportedOperationException(\"Remove is not supported by this iterator\");\n                }\n            };\n        }\n    };\n}", "lc": 1.2272727272727273, "pi": 2.186602870813397, "ma": 0.6, "nbd": 1.5, "ml": 0.3333333333333333, "d": 0.011904761904761871, "mi": -0.669626497533474, "fo": 0.75, "r": -0.02631578947368421, "e": 0.2616068186926228}
{"project_name": "Closure", "project_version": 46, "label": 2, "code": "@Override\npublic JSType getLeastSupertype(JSType that) {\n    if (!that.isRecordType()) {\n        return super.getLeastSupertype(that);\n    }\n    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n    for (String property : properties.keySet()) {\n        if (that.toMaybeRecordType().hasProperty(property) && that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(getPropertyType(property))) {\n            builder.addProperty(property, getPropertyType(property), getPropertyNode(property));\n        }\n    }\n    return builder.build();\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic JSType getLeastSupertype(JSType that) {\n    if (!that.isRecordType()) {\n        return super.getLeastSupertype(that);\n    }\n    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n    for (String property : properties.keySet()) {\n        if (that.toMaybeRecordType().hasProperty(property) && that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(getPropertyType(property))) {\n            builder.addProperty(property, getPropertyType(property), getPropertyNode(property));\n        }\n    }\n    return builder.build();\n}", "lc": -0.045454545454545456, "pi": 0.22009569377990432, "ma": 0.0, "nbd": 0.0, "ml": 0.25, "d": 0.011904761904761871, "mi": 0.014799154334038212, "fo": 0.5833333333333334, "r": -0.02631578947368421, "e": -0.000329639298536808}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1822_016df669", "label": 1, "code": "/**\n * Creates a MongoDB update object from the given UpdateOp.\n *\n * @param updateOp the update op.\n * @return the DBObject.\n */\n@Nonnull\nprivate static DBObject createUpdate(UpdateOp updateOp) {\n    BasicDBObject setUpdates = new BasicDBObject();\n    BasicDBObject incUpdates = new BasicDBObject();\n    BasicDBObject unsetUpdates = new BasicDBObject();\n    // always increment modCount\n    updateOp.increment(Document.MOD_COUNT, 1);\n    // other updates\n    for (Entry<Key, Operation> entry : updateOp.getChanges().entrySet()) {\n        Key k = entry.getKey();\n        if (k.getName().equals(Document.ID)) {\n            // avoid exception \"Mod on _id not allowed\"\n            continue;\n        }\n        Operation op = entry.getValue();\n        switch(op.type) {\n            case SET:\n                {\n                    setUpdates.append(k.toString(), op.value);\n                    break;\n                }\n            case INCREMENT:\n                {\n                    incUpdates.append(k.toString(), op.value);\n                    break;\n                }\n            case SET_MAP_ENTRY:\n                {\n                    setUpdates.append(k.toString(), op.value);\n                    break;\n                }\n            case REMOVE_MAP_ENTRY:\n                {\n                    unsetUpdates.append(k.toString(), \"1\");\n                    break;\n                }\n        }\n    }\n    BasicDBObject update = new BasicDBObject();\n    if (!setUpdates.isEmpty()) {\n        update.append(\"$set\", setUpdates);\n    }\n    if (!incUpdates.isEmpty()) {\n        update.append(\"$inc\", incUpdates);\n    }\n    if (!unsetUpdates.isEmpty()) {\n        update.append(\"$unset\", unsetUpdates);\n    }\n    return update;\n}", "code_comment": "/**\n * Creates a MongoDB update object from the given UpdateOp.\n *\n * @param updateOp the update op.\n * @return the DBObject.\n */\n", "code_no_comment": "@Nonnull\nprivate static DBObject createUpdate(UpdateOp updateOp) {\n    BasicDBObject setUpdates = new BasicDBObject();\n    BasicDBObject incUpdates = new BasicDBObject();\n    BasicDBObject unsetUpdates = new BasicDBObject();\n        updateOp.increment(Document.MOD_COUNT, 1);\n        for (Entry<Key, Operation> entry : updateOp.getChanges().entrySet()) {\n        Key k = entry.getKey();\n        if (k.getName().equals(Document.ID)) {\n                        continue;\n        }\n        Operation op = entry.getValue();\n        switch(op.type) {\n            case SET:\n                {\n                    setUpdates.append(k.toString(), op.value);\n                    break;\n                }\n            case INCREMENT:\n                {\n                    incUpdates.append(k.toString(), op.value);\n                    break;\n                }\n            case SET_MAP_ENTRY:\n                {\n                    setUpdates.append(k.toString(), op.value);\n                    break;\n                }\n            case REMOVE_MAP_ENTRY:\n                {\n                    unsetUpdates.append(k.toString(), \"1\");\n                    break;\n                }\n        }\n    }\n    BasicDBObject update = new BasicDBObject();\n    if (!setUpdates.isEmpty()) {\n        update.append(\"$set\", setUpdates);\n    }\n    if (!incUpdates.isEmpty()) {\n        update.append(\"$inc\", incUpdates);\n    }\n    if (!unsetUpdates.isEmpty()) {\n        update.append(\"$unset\", unsetUpdates);\n    }\n    return update;\n}", "lc": 1.5, "pi": 1.6507177033492826, "ma": 2.2, "nbd": 0.5, "ml": 0.6666666666666666, "d": 0.0853174603174603, "mi": -0.799859055673009, "fo": 1.25, "r": -0.02631578947368421, "e": 0.4027800349233242}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1731_024e5d37", "label": 1, "code": "private void copyPropertyDefinition(QPropertyDefinition def, NodeBuilder builder) throws NamespaceException {\n    builder.setProperty(JCR_PRIMARYTYPE, NT_PROPERTYDEFINITION, NAME);\n    copyItemDefinition(def, builder);\n    // - jcr:requiredType (STRING) protected mandatory\n    // < 'STRING', 'URI', 'BINARY', 'LONG', 'DOUBLE',\n    // 'DECIMAL', 'BOOLEAN', 'DATE', 'NAME', 'PATH',\n    // 'REFERENCE', 'WEAKREFERENCE', 'UNDEFINED'\n    builder.setProperty(JCR_REQUIREDTYPE, Type.fromTag(def.getRequiredType(), false).toString());\n    // - jcr:valueConstraints (STRING) protected multiple\n    QValueConstraint[] constraints = def.getValueConstraints();\n    if (constraints != null && constraints.length > 0) {\n        List<String> strings = newArrayListWithCapacity(constraints.length);\n        for (QValueConstraint constraint : constraints) {\n            strings.add(constraint.getString());\n        }\n        builder.setProperty(JCR_VALUECONSTRAINTS, strings, STRINGS);\n    }\n    // - jcr:defaultValues (UNDEFINED) protected multiple\n    QValue[] values = def.getDefaultValues();\n    if (values != null) {\n    // TODO\n    }\n    // - jcr:multiple (BOOLEAN) protected mandatory\n    builder.setProperty(JCR_MULTIPLE, def.isMultiple());\n    // - jcr:availableQueryOperators (NAME) protected mandatory multiple\n    List<String> operators = asList(def.getAvailableQueryOperators());\n    builder.setProperty(JCR_AVAILABLE_QUERY_OPERATORS, operators, NAMES);\n    // - jcr:isFullTextSearchable (BOOLEAN) protected mandatory\n    builder.setProperty(JCR_IS_FULLTEXT_SEARCHABLE, def.isFullTextSearchable());\n    // - jcr:isQueryOrderable (BOOLEAN) protected mandatory\n    builder.setProperty(JCR_IS_QUERY_ORDERABLE, def.isQueryOrderable());\n}", "code_comment": NaN, "code_no_comment": "private void copyPropertyDefinition(QPropertyDefinition def, NodeBuilder builder) throws NamespaceException {\n    builder.setProperty(JCR_PRIMARYTYPE, NT_PROPERTYDEFINITION, NAME);\n    copyItemDefinition(def, builder);\n                    builder.setProperty(JCR_REQUIREDTYPE, Type.fromTag(def.getRequiredType(), false).toString());\n        QValueConstraint[] constraints = def.getValueConstraints();\n    if (constraints != null && constraints.length > 0) {\n        List<String> strings = newArrayListWithCapacity(constraints.length);\n        for (QValueConstraint constraint : constraints) {\n            strings.add(constraint.getString());\n        }\n        builder.setProperty(JCR_VALUECONSTRAINTS, strings, STRINGS);\n    }\n        QValue[] values = def.getDefaultValues();\n    if (values != null) {\n        }\n        builder.setProperty(JCR_MULTIPLE, def.isMultiple());\n        List<String> operators = asList(def.getAvailableQueryOperators());\n    builder.setProperty(JCR_AVAILABLE_QUERY_OPERATORS, operators, NAMES);\n        builder.setProperty(JCR_IS_FULLTEXT_SEARCHABLE, def.isFullTextSearchable());\n        builder.setProperty(JCR_IS_QUERY_ORDERABLE, def.isQueryOrderable());\n}", "lc": 0.3181818181818182, "pi": -0.16267942583732073, "ma": 0.0, "nbd": 0.0, "ml": 0.08333333333333333, "d": 0.33531746031746024, "mi": -0.3541930937279773, "fo": 1.25, "r": -0.02631578947368421, "e": 0.6777360926217273}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3517_24f7f60a", "label": 1, "code": "@Nonnull\n@Override\npublic Node perform() throws RepositoryException {\n    String oakName = PathUtils.getName(oakPath);\n    String parentPath = PathUtils.getParentPath(oakPath);\n    NodeDelegate parent = dlg.getChild(parentPath);\n    if (parent == null) {\n        // is it a property?\n        String grandParentPath = PathUtils.getParentPath(parentPath);\n        NodeDelegate grandParent = dlg.getChild(grandParentPath);\n        if (grandParent != null) {\n            String propName = PathUtils.getName(parentPath);\n            if (grandParent.getPropertyOrNull(propName) != null) {\n                throw new ConstraintViolationException(\"Can't add new node to property.\");\n            }\n        }\n        throw new PathNotFoundException(relPath);\n    }\n    if (parent.getChild(oakName) != null) {\n        throw new ItemExistsException(relPath);\n    }\n    // modification of that property in the PermissionValidator\n    if (oakTypeName != null) {\n        PropertyState prop = PropertyStates.createProperty(JCR_PRIMARYTYPE, oakTypeName, NAME);\n        sessionContext.getAccessManager().checkPermissions(dlg.getTree(), prop, Permissions.NODE_TYPE_MANAGEMENT);\n    }\n    NodeDelegate added = parent.addChild(oakName, oakTypeName);\n    if (added == null) {\n        throw new ItemExistsException();\n    }\n    return createNode(added, sessionContext);\n}", "code_comment": NaN, "code_no_comment": "@Nonnull\n@Override\npublic Node perform() throws RepositoryException {\n    String oakName = PathUtils.getName(oakPath);\n    String parentPath = PathUtils.getParentPath(oakPath);\n    NodeDelegate parent = dlg.getChild(parentPath);\n    if (parent == null) {\n                String grandParentPath = PathUtils.getParentPath(parentPath);\n        NodeDelegate grandParent = dlg.getChild(grandParentPath);\n        if (grandParent != null) {\n            String propName = PathUtils.getName(parentPath);\n            if (grandParent.getPropertyOrNull(propName) != null) {\n                throw new ConstraintViolationException(\"Can't add new node to property.\");\n            }\n        }\n        throw new PathNotFoundException(relPath);\n    }\n    if (parent.getChild(oakName) != null) {\n        throw new ItemExistsException(relPath);\n    }\n        if (oakTypeName != null) {\n        PropertyState prop = PropertyStates.createProperty(JCR_PRIMARYTYPE, oakTypeName, NAME);\n        sessionContext.getAccessManager().checkPermissions(dlg.getTree(), prop, Permissions.NODE_TYPE_MANAGEMENT);\n    }\n    NodeDelegate added = parent.addChild(oakName, oakTypeName);\n    if (added == null) {\n        throw new ItemExistsException();\n    }\n    return createNode(added, sessionContext);\n}", "lc": 0.7272727272727273, "pi": 0.40191387559808606, "ma": 1.4, "nbd": 0.5, "ml": 0.75, "d": 0.01785714285714283, "mi": -0.5678646934460886, "fo": 0.6666666666666666, "r": -0.02631578947368421, "e": 0.3140033309705341}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1732_941e3cb1", "label": 3, "code": "/**\n * Gets the splits of the tables that have been set on the job.\n *\n * @param context\n *          the configuration of the job\n * @return the splits from the tables based on the ranges.\n * @throws java.io.IOException\n *           if a table set on the job doesn't exist or an error occurs initializing the tablet locator\n */\npublic List<InputSplit> getSplits(JobContext context) throws IOException {\n    log.setLevel(getLogLevel(context));\n    validateOptions(context);\n    LinkedList<InputSplit> splits = new LinkedList<InputSplit>();\n    Map<String, BatchScanConfig> tableConfigs = getBatchScanConfigs(context);\n    for (Map.Entry<String, BatchScanConfig> tableConfigEntry : tableConfigs.entrySet()) {\n        String tableName = tableConfigEntry.getKey();\n        BatchScanConfig tableConfig = tableConfigEntry.getValue();\n        boolean autoAdjust = tableConfig.shouldAutoAdjustRanges();\n        String tableId = null;\n        List<Range> ranges = autoAdjust ? Range.mergeOverlapping(tableConfig.getRanges()) : tableConfig.getRanges();\n        if (ranges.isEmpty()) {\n            ranges = new ArrayList<Range>(1);\n            ranges.add(new Range());\n        }\n        // get the metadata information for these ranges\n        Map<String, Map<KeyExtent, List<Range>>> binnedRanges = new HashMap<String, Map<KeyExtent, List<Range>>>();\n        TabletLocator tl;\n        try {\n            // resolve table name to id once, and use id from this point forward\n            tableId = Tables.getTableId(getInstance(context), tableName);\n            if (tableConfig.isOfflineScan()) {\n                binnedRanges = binOfflineTable(context, tableId, ranges);\n                while (binnedRanges == null) {\n                    // Some tablets were still online, try again\n                    // sleep randomly between 100 and 200 ms\n                    UtilWaitThread.sleep(100 + (int) (Math.random() * 100));\n                    binnedRanges = binOfflineTable(context, tableId, ranges);\n                }\n            } else {\n                Instance instance = getInstance(context);\n                tl = getTabletLocator(context, tableId);\n                // its possible that the cache could contain complete, but old information about a tables tablets... so clear it\n                tl.invalidateCache();\n                Credentials creds = new Credentials(getPrincipal(context), getAuthenticationToken(context));\n                while (!tl.binRanges(creds, ranges, binnedRanges).isEmpty()) {\n                    if (!(instance instanceof MockInstance)) {\n                        if (!Tables.exists(instance, tableId))\n                            throw new TableDeletedException(tableId);\n                        if (Tables.getTableState(instance, tableId) == TableState.OFFLINE)\n                            throw new TableOfflineException(instance, tableId);\n                    }\n                    binnedRanges.clear();\n                    log.warn(\"Unable to locate bins for specified ranges. Retrying.\");\n                    // sleep randomly between 100 and 200 ms\n                    UtilWaitThread.sleep(100 + (int) (Math.random() * 100));\n                    tl.invalidateCache();\n                }\n            }\n        } catch (Exception e) {\n            throw new IOException(e);\n        }\n        HashMap<Range, ArrayList<String>> splitsToAdd = null;\n        if (!autoAdjust)\n            splitsToAdd = new HashMap<Range, ArrayList<String>>();\n        HashMap<String, String> hostNameCache = new HashMap<String, String>();\n        for (Map.Entry<String, Map<KeyExtent, List<Range>>> tserverBin : binnedRanges.entrySet()) {\n            String ip = tserverBin.getKey().split(\":\", 2)[0];\n            String location = hostNameCache.get(ip);\n            if (location == null) {\n                InetAddress inetAddress = InetAddress.getByName(ip);\n                location = inetAddress.getHostName();\n                hostNameCache.put(ip, location);\n            }\n            for (Map.Entry<KeyExtent, List<Range>> extentRanges : tserverBin.getValue().entrySet()) {\n                Range ke = extentRanges.getKey().toDataRange();\n                for (Range r : extentRanges.getValue()) {\n                    if (autoAdjust) {\n                        // divide ranges into smaller ranges, based on the tablets\n                        splits.add(new RangeInputSplit(tableName, tableId, ke.clip(r), new String[] { location }));\n                    } else {\n                        // don't divide ranges\n                        ArrayList<String> locations = splitsToAdd.get(r);\n                        if (locations == null)\n                            locations = new ArrayList<String>(1);\n                        locations.add(location);\n                        splitsToAdd.put(r, locations);\n                    }\n                }\n            }\n        }\n        if (!autoAdjust)\n            for (Map.Entry<Range, ArrayList<String>> entry : splitsToAdd.entrySet()) splits.add(new RangeInputSplit(tableName, tableId, entry.getKey(), entry.getValue().toArray(new String[0])));\n    }\n    return splits;\n}", "code_comment": "/**\n * Gets the splits of the tables that have been set on the job.\n *\n * @param context\n *          the configuration of the job\n * @return the splits from the tables based on the ranges.\n * @throws java.io.IOException\n *           if a table set on the job doesn't exist or an error occurs initializing the tablet locator\n */\n", "code_no_comment": "public List<InputSplit> getSplits(JobContext context) throws IOException {\n    log.setLevel(getLogLevel(context));\n    validateOptions(context);\n    LinkedList<InputSplit> splits = new LinkedList<InputSplit>();\n    Map<String, BatchScanConfig> tableConfigs = getBatchScanConfigs(context);\n    for (Map.Entry<String, BatchScanConfig> tableConfigEntry : tableConfigs.entrySet()) {\n        String tableName = tableConfigEntry.getKey();\n        BatchScanConfig tableConfig = tableConfigEntry.getValue();\n        boolean autoAdjust = tableConfig.shouldAutoAdjustRanges();\n        String tableId = null;\n        List<Range> ranges = autoAdjust ? Range.mergeOverlapping(tableConfig.getRanges()) : tableConfig.getRanges();\n        if (ranges.isEmpty()) {\n            ranges = new ArrayList<Range>(1);\n            ranges.add(new Range());\n        }\n                Map<String, Map<KeyExtent, List<Range>>> binnedRanges = new HashMap<String, Map<KeyExtent, List<Range>>>();\n        TabletLocator tl;\n        try {\n                        tableId = Tables.getTableId(getInstance(context), tableName);\n            if (tableConfig.isOfflineScan()) {\n                binnedRanges = binOfflineTable(context, tableId, ranges);\n                while (binnedRanges == null) {\n                                                            UtilWaitThread.sleep(100 + (int) (Math.random() * 100));\n                    binnedRanges = binOfflineTable(context, tableId, ranges);\n                }\n            } else {\n                Instance instance = getInstance(context);\n                tl = getTabletLocator(context, tableId);\n                                tl.invalidateCache();\n                Credentials creds = new Credentials(getPrincipal(context), getAuthenticationToken(context));\n                while (!tl.binRanges(creds, ranges, binnedRanges).isEmpty()) {\n                    if (!(instance instanceof MockInstance)) {\n                        if (!Tables.exists(instance, tableId))\n                            throw new TableDeletedException(tableId);\n                        if (Tables.getTableState(instance, tableId) == TableState.OFFLINE)\n                            throw new TableOfflineException(instance, tableId);\n                    }\n                    binnedRanges.clear();\n                    log.warn(\"Unable to locate bins for specified ranges. Retrying.\");\n                                        UtilWaitThread.sleep(100 + (int) (Math.random() * 100));\n                    tl.invalidateCache();\n                }\n            }\n        } catch (Exception e) {\n            throw new IOException(e);\n        }\n        HashMap<Range, ArrayList<String>> splitsToAdd = null;\n        if (!autoAdjust)\n            splitsToAdd = new HashMap<Range, ArrayList<String>>();\n        HashMap<String, String> hostNameCache = new HashMap<String, String>();\n        for (Map.Entry<String, Map<KeyExtent, List<Range>>> tserverBin : binnedRanges.entrySet()) {\n            String ip = tserverBin.getKey().split(\":\", 2)[0];\n            String location = hostNameCache.get(ip);\n            if (location == null) {\n                InetAddress inetAddress = InetAddress.getByName(ip);\n                location = inetAddress.getHostName();\n                hostNameCache.put(ip, location);\n            }\n            for (Map.Entry<KeyExtent, List<Range>> extentRanges : tserverBin.getValue().entrySet()) {\n                Range ke = extentRanges.getKey().toDataRange();\n                for (Range r : extentRanges.getValue()) {\n                    if (autoAdjust) {\n                                                splits.add(new RangeInputSplit(tableName, tableId, ke.clip(r), new String[] { location }));\n                    } else {\n                                                ArrayList<String> locations = splitsToAdd.get(r);\n                        if (locations == null)\n                            locations = new ArrayList<String>(1);\n                        locations.add(location);\n                        splitsToAdd.put(r, locations);\n                    }\n                }\n            }\n        }\n        if (!autoAdjust)\n            for (Map.Entry<Range, ArrayList<String>> entry : splitsToAdd.entrySet()) splits.add(new RangeInputSplit(tableName, tableId, entry.getKey(), entry.getValue().toArray(new String[0])));\n    }\n    return splits;\n}", "lc": 2.909090909090909, "pi": 1.7894736842105265, "ma": 3.8, "nbd": 1.5, "ml": 1.5833333333333333, "d": 0.8134920634920636, "mi": -1.2875264270613105, "fo": 4.166666666666667, "r": -0.02631578947368421, "e": 5.792248866144544}
{"project_name": "Closure", "project_version": 169, "label": 2, "code": "/**\n * Determines if typeA is a subtype of typeB\n */\nstatic boolean isSubtype(ObjectType typeA, RecordType typeB) {\n    // to the property of z would not violate any restrictions on it.\n    for (String property : typeB.properties.keySet()) {\n        if (!typeA.hasProperty(property)) {\n            return false;\n        }\n        JSType propA = typeA.getPropertyType(property);\n        JSType propB = typeB.getPropertyType(property);\n        if (!propA.isUnknownType() && !propB.isUnknownType()) {\n            if (typeA.isPropertyTypeDeclared(property)) {\n                // then the whole record isn't covariant.\n                if (!propA.isInvariant(propB)) {\n                    return false;\n                }\n            } else {\n                // then the whole record isn't covariant.\n                if (!propA.isSubtype(propB)) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}", "code_comment": "/**\n * Determines if typeA is a subtype of typeB\n */\n", "code_no_comment": "static boolean isSubtype(ObjectType typeA, RecordType typeB) {\n        for (String property : typeB.properties.keySet()) {\n        if (!typeA.hasProperty(property)) {\n            return false;\n        }\n        JSType propA = typeA.getPropertyType(property);\n        JSType propB = typeB.getPropertyType(property);\n        if (!propA.isUnknownType() && !propB.isUnknownType()) {\n            if (typeA.isPropertyTypeDeclared(property)) {\n                                if (!propA.isInvariant(propB)) {\n                    return false;\n                }\n            } else {\n                                if (!propA.isSubtype(propB)) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}", "lc": 0.3181818181818182, "pi": 1.3157894736842106, "ma": 0.6, "nbd": 1.0, "ml": 0.75, "d": 0.041666666666666616, "mi": -0.24989429175475666, "fo": 0.25, "r": 0.10526315789473684, "e": 0.04669582706615259}
{"project_name": "Closure", "project_version": 84, "label": 2, "code": "@Override\nNode processAssignment(Assignment assignmentNode) {\n    Node assign = processInfixExpression(assignmentNode);\n    return assign;\n}", "code_comment": NaN, "code_no_comment": "@Override\nNode processAssignment(Assignment assignmentNode) {\n    Node assign = processInfixExpression(assignmentNode);\n    return assign;\n}", "lc": -0.4090909090909091, "pi": -0.49282296650717716, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.702889358703312, "fo": -0.4166666666666667, "r": 2.131578947368421, "e": -0.16279340490885932}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1051_25cf3ccd", "label": 3, "code": "@Override\npublic int hashCode() {\n    int result = 0;\n    for (ByteSequence b : auths) result += b.hashCode();\n    return result;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic int hashCode() {\n    int result = 0;\n    for (ByteSequence b : auths) result += b.hashCode();\n    return result;\n}", "lc": -0.36363636363636365, "pi": -0.47368421052631593, "ma": -0.4, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.06746031746031747, "mi": 0.5836504580690626, "fo": -0.4166666666666667, "r": 1.2894736842105263, "e": -0.13063167418728353}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-1089_e91d0f05", "label": 1, "code": "/**\n * Rounds the given value to the specified number of decimal places.\n * The value is rounded using the given method which is any method defined\n * in {@link BigDecimal}.\n * If {@code x} is infinite or {@code NaN}, then the value of {@code x} is\n * returned unchanged, regardless of the other parameters.\n *\n * @param x Value to round.\n * @param scale Number of digits to the right of the decimal point.\n * @param roundingMethod Rounding method as defined in {@link BigDecimal}.\n * @return the rounded value.\n * @throws ArithmeticException if {@code roundingMethod == ROUND_UNNECESSARY}\n * and the specified scaling operation would require rounding.\n * @throws IllegalArgumentException if {@code roundingMethod} does not\n * represent a valid rounding mode.\n * @since 1.1 (previously in {@code MathUtils}, moved as of version 3.0)\n */\npublic static double round(double x, int scale, int roundingMethod) {\n    try {\n        return (new BigDecimal(Double.toString(x)).setScale(scale, roundingMethod)).doubleValue();\n    } catch (NumberFormatException ex) {\n        if (Double.isInfinite(x)) {\n            return x;\n        } else {\n            return Double.NaN;\n        }\n    }\n}", "code_comment": "/**\n * Rounds the given value to the specified number of decimal places.\n * The value is rounded using the given method which is any method defined\n * in {@link BigDecimal}.\n * If {@code x} is infinite or {@code NaN}, then the value of {@code x} is\n * returned unchanged, regardless of the other parameters.\n *\n * @param x Value to round.\n * @param scale Number of digits to the right of the decimal point.\n * @param roundingMethod Rounding method as defined in {@link BigDecimal}.\n * @return the rounded value.\n * @throws ArithmeticException if {@code roundingMethod == ROUND_UNNECESSARY}\n * and the specified scaling operation would require rounding.\n * @throws IllegalArgumentException if {@code roundingMethod} does not\n * represent a valid rounding mode.\n * @since 1.1 (previously in {@code MathUtils}, moved as of version 3.0)\n */\n", "code_no_comment": "public static double round(double x, int scale, int roundingMethod) {\n    try {\n        return (new BigDecimal(Double.toString(x)).setScale(scale, roundingMethod)).doubleValue();\n    } catch (NumberFormatException ex) {\n        if (Double.isInfinite(x)) {\n            return x;\n        } else {\n            return Double.NaN;\n        }\n    }\n}", "lc": -0.13636363636363635, "pi": 0.45933014354066987, "ma": -0.2, "nbd": 0.0, "ml": -0.16666666666666666, "d": -0.3650793650793651, "mi": 0.22085976039464428, "fo": -0.16666666666666666, "r": 0.0, "e": -0.16279340490885932}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1655_01a8b283", "label": 1, "code": "@Nullable\n@Override\npublic String apply(@Nullable DataIdentifier input) {\n    return input.toString();\n}", "code_comment": NaN, "code_no_comment": "@Nullable\n@Override\npublic String apply(@Nullable DataIdentifier input) {\n    return input.toString();\n}", "lc": -0.4090909090909091, "pi": -0.6650717703349284, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.7375616631430585, "fo": -0.4166666666666667, "r": 1.894736842105263, "e": -0.16279340490885932}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3630_fcd64766", "label": 3, "code": "@Override\npublic Aggregate getAggregate(NodeState matchedNodeState) {\n    return aggMapper.getAggregate(ConfigUtil.getPrimaryTypeName(matchedNodeState));\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic Aggregate getAggregate(NodeState matchedNodeState) {\n    return aggMapper.getAggregate(ConfigUtil.getPrimaryTypeName(matchedNodeState));\n}", "lc": -0.45454545454545453, "pi": -0.6028708133971293, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.8173361522198731, "fo": -0.3333333333333333, "r": 1.0526315789473684, "e": -0.16279340490885932}
{"project_name": "Compress", "project_version": 4, "label": 1, "code": "/**\n * Closes this output stream and releases any system resources\n * associated with the stream.\n *\n * @exception  IOException  if an I/O error occurs.\n */\npublic void close() throws IOException {\n    finish();\n    if (raf != null) {\n        raf.close();\n    }\n    if (out != null) {\n        out.close();\n    }\n}", "code_comment": "/**\n * Closes this output stream and releases any system resources\n * associated with the stream.\n *\n * @exception  IOException  if an I/O error occurs.\n */\n", "code_no_comment": "public void close() throws IOException {\n    finish();\n    if (raf != null) {\n        raf.close();\n    }\n    if (out != null) {\n        out.close();\n    }\n}", "lc": -0.22727272727272727, "pi": -0.15311004784689008, "ma": -0.2, "nbd": -0.5, "ml": -0.08333333333333333, "d": -0.3650793650793651, "mi": 0.4069062720225511, "fo": -0.25, "r": 2.552631578947368, "e": -0.16279340490885932}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-2487_f2920c26", "label": 0, "code": "/**\n * @return the current size of the buffer.\n */\npublic int getSize() {\n    if (this.value == null) {\n        throw new IllegalStateException(\"Uninitialized. Null constructor \" + \"called w/o accompanying readFields invocation\");\n    }\n    return this.value.length;\n}", "code_comment": "/**\n * @return the current size of the buffer.\n */\n", "code_no_comment": "public int getSize() {\n    if (this.value == null) {\n        throw new IllegalStateException(\"Uninitialized. Null constructor \" + \"called w/o accompanying readFields invocation\");\n    }\n    return this.value.length;\n}", "lc": -0.36363636363636365, "pi": -0.11483253588516758, "ma": -0.2, "nbd": -0.5, "ml": -0.25, "d": -0.14285714285714285, "mi": 0.6124031007751934, "fo": -0.5, "r": 2.5, "e": -0.14384029782795363}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1429_c2f5ca6c", "label": 1, "code": "private void diffFewChildren(JsopWriter w, DocumentNodeState.Children fromChildren, Revision fromRev, DocumentNodeState.Children toChildren, Revision toRev) {\n    Set<String> childrenSet = Sets.newHashSet(toChildren.children);\n    for (String n : fromChildren.children) {\n        if (!childrenSet.contains(n)) {\n            w.tag('-').value(n).newline();\n        } else {\n            DocumentNodeState n1 = getNode(n, fromRev);\n            DocumentNodeState n2 = getNode(n, toRev);\n            // this is not fully correct:\n            // a change is detected if the node changed recently,\n            // even if the revisions are well in the past\n            // if this is a problem it would need to be changed\n            checkNotNull(n1, \"Node at [%s] not found for fromRev [%s]\", n, fromRev);\n            checkNotNull(n2, \"Node at [%s] not found for toRev [%s]\", n, toRev);\n            if (!n1.getId().equals(n2.getId())) {\n                w.tag('^').key(n).object().endObject().newline();\n            }\n        }\n    }\n    childrenSet = Sets.newHashSet(fromChildren.children);\n    for (String n : toChildren.children) {\n        if (!childrenSet.contains(n)) {\n            w.tag('+').key(n).object().endObject().newline();\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "private void diffFewChildren(JsopWriter w, DocumentNodeState.Children fromChildren, Revision fromRev, DocumentNodeState.Children toChildren, Revision toRev) {\n    Set<String> childrenSet = Sets.newHashSet(toChildren.children);\n    for (String n : fromChildren.children) {\n        if (!childrenSet.contains(n)) {\n            w.tag('-').value(n).newline();\n        } else {\n            DocumentNodeState n1 = getNode(n, fromRev);\n            DocumentNodeState n2 = getNode(n, toRev);\n                                                            checkNotNull(n1, \"Node at [%s] not found for fromRev [%s]\", n, fromRev);\n            checkNotNull(n2, \"Node at [%s] not found for toRev [%s]\", n, toRev);\n            if (!n1.getId().equals(n2.getId())) {\n                w.tag('^').key(n).object().endObject().newline();\n            }\n        }\n    }\n    childrenSet = Sets.newHashSet(fromChildren.children);\n    for (String n : toChildren.children) {\n        if (!childrenSet.contains(n)) {\n            w.tag('+').key(n).object().endObject().newline();\n        }\n    }\n}", "lc": 0.36363636363636365, "pi": 0.650717703349282, "ma": 0.4, "nbd": 0.5, "ml": 0.16666666666666666, "d": 0.11507936507936505, "mi": -0.3818181818181818, "fo": 1.5, "r": -0.02631578947368421, "e": 0.38682825907804724}
{"project_name": "Lang", "project_version": 10, "label": 1, "code": "// Support for strategies\n// -----------------------------------------------------------------------\n/**\n * Escape constant fields into regular expression\n * @param regex The destination regex\n * @param value The source field\n * @param unquote If true, replace two success quotes ('') with single quote (')\n * @return The <code>StringBuilder</code>\n */\nprivate static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n    boolean wasWhite = false;\n    for (int i = 0; i < value.length(); ++i) {\n        char c = value.charAt(i);\n        if (Character.isWhitespace(c)) {\n            if (!wasWhite) {\n                wasWhite = true;\n                regex.append(\"\\\\s*+\");\n            }\n            continue;\n        }\n        wasWhite = false;\n        switch(c) {\n            case '\\'':\n                if (unquote) {\n                    if (++i == value.length()) {\n                        return regex;\n                    }\n                    c = value.charAt(i);\n                }\n                break;\n            case '?':\n            case '[':\n            case ']':\n            case '(':\n            case ')':\n            case '{':\n            case '}':\n            case '\\\\':\n            case '|':\n            case '*':\n            case '+':\n            case '^':\n            case '$':\n            case '.':\n                regex.append('\\\\');\n        }\n        regex.append(c);\n    }\n    return regex;\n}", "code_comment": "/**\n * Escape constant fields into regular expression\n * @param regex The destination regex\n * @param value The source field\n * @param unquote If true, replace two success quotes ('') with single quote (')\n * @return The <code>StringBuilder</code>\n */\n", "code_no_comment": "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n    boolean wasWhite = false;\n    for (int i = 0; i < value.length(); ++i) {\n        char c = value.charAt(i);\n        if (Character.isWhitespace(c)) {\n            if (!wasWhite) {\n                wasWhite = true;\n                regex.append(\"\\\\s*+\");\n            }\n            continue;\n        }\n        wasWhite = false;\n        switch(c) {\n            case '\\'':\n                if (unquote) {\n                    if (++i == value.length()) {\n                        return regex;\n                    }\n                    c = value.charAt(i);\n                }\n                break;\n            case '?':\n            case '[':\n            case ']':\n            case '(':\n            case ')':\n            case '{':\n            case '}':\n            case '\\\\':\n            case '|':\n            case '*':\n            case '+':\n            case '^':\n            case '$':\n            case '.':\n                regex.append('\\\\');\n        }\n        regex.append(c);\n    }\n    return regex;\n}", "lc": 1.2272727272727273, "pi": 1.0191387559808613, "ma": 3.8, "nbd": 1.5, "ml": 1.75, "d": 0.371031746031746, "mi": -0.7423537702607467, "fo": 0.16666666666666666, "r": -0.02631578947368421, "e": 0.5054476928130565}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-3740_f2f5bd5b", "label": 1, "code": "@Override\npublic void merge(W mergeResult, Collection<W> mergedWindows, W stateWindowResult, Collection<W> mergedStateWindows) throws Exception {\n    context.window = mergeResult;\n    // store for later use\n    mergeTriggerResult.f0 = context.onMerge(mergedWindows);\n    for (W m : mergedWindows) {\n        context.window = m;\n        context.clear();\n    }\n    // merge the merged state windows into the newly resulting state window\n    getStateBackend().mergePartitionedStates(stateWindowResult, mergedStateWindows, windowSerializer, (StateDescriptor<? extends MergingState<?, ?>, ?>) windowStateDescriptor);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void merge(W mergeResult, Collection<W> mergedWindows, W stateWindowResult, Collection<W> mergedStateWindows) throws Exception {\n    context.window = mergeResult;\n        mergeTriggerResult.f0 = context.onMerge(mergedWindows);\n    for (W m : mergedWindows) {\n        context.window = m;\n        context.clear();\n    }\n        getStateBackend().mergePartitionedStates(stateWindowResult, mergedStateWindows, windowSerializer, (StateDescriptor<? extends MergingState<?, ?>, ?>) windowStateDescriptor);\n}", "lc": -0.18181818181818182, "pi": -0.0909090909090911, "ma": -0.4, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.14559548978153644, "fo": -0.16666666666666666, "r": -0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-2802_88a97768", "label": 0, "code": "// ------------------------------------------------------------------------\n@Override\nprotected void run() throws Exception {\n    final String iterationId = configuration.getIterationId();\n    if (iterationId == null || iterationId.length() == 0) {\n        throw new Exception(\"Missing iteration ID in the task configuration\");\n    }\n    final String brokerID = createBrokerIdString(getEnvironment().getJobID(), iterationId, getEnvironment().getIndexInSubtaskGroup());\n    final long iterationWaitTime = configuration.getIterationWaitTime();\n    final boolean shouldWait = iterationWaitTime > 0;\n    final BlockingQueue<StreamRecord<OUT>> dataChannel = new ArrayBlockingQueue<StreamRecord<OUT>>(1);\n    // offer the queue for the tail\n    BlockingQueueBroker.INSTANCE.handIn(brokerID, dataChannel);\n    LOG.info(\"Iteration head {} added feedback queue under {}\", getName(), brokerID);\n    // do the work\n    try {\n        @SuppressWarnings(\"unchecked\")\n        Collection<RecordWriterOutput<OUT>> outputs = (Collection<RecordWriterOutput<OUT>>) (Collection<?>) outputHandler.getOutputs();\n        while (running) {\n            StreamRecord<OUT> nextRecord = shouldWait ? dataChannel.poll(iterationWaitTime, TimeUnit.MILLISECONDS) : dataChannel.take();\n            if (nextRecord != null) {\n                for (RecordWriterOutput<OUT> output : outputs) {\n                    output.collect(nextRecord);\n                }\n            } else {\n                // done\n                break;\n            }\n        }\n    } finally {\n        // make sure that we remove the queue from the broker, to prevent a resource leak\n        BlockingQueueBroker.INSTANCE.remove(brokerID);\n        LOG.info(\"Iteration head {} removed feedback queue under {}\", getName(), brokerID);\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\nprotected void run() throws Exception {\n    final String iterationId = configuration.getIterationId();\n    if (iterationId == null || iterationId.length() == 0) {\n        throw new Exception(\"Missing iteration ID in the task configuration\");\n    }\n    final String brokerID = createBrokerIdString(getEnvironment().getJobID(), iterationId, getEnvironment().getIndexInSubtaskGroup());\n    final long iterationWaitTime = configuration.getIterationWaitTime();\n    final boolean shouldWait = iterationWaitTime > 0;\n    final BlockingQueue<StreamRecord<OUT>> dataChannel = new ArrayBlockingQueue<StreamRecord<OUT>>(1);\n        BlockingQueueBroker.INSTANCE.handIn(brokerID, dataChannel);\n    LOG.info(\"Iteration head {} added feedback queue under {}\", getName(), brokerID);\n        try {\n        @SuppressWarnings(\"unchecked\")\n        Collection<RecordWriterOutput<OUT>> outputs = (Collection<RecordWriterOutput<OUT>>) (Collection<?>) outputHandler.getOutputs();\n        while (running) {\n            StreamRecord<OUT> nextRecord = shouldWait ? dataChannel.poll(iterationWaitTime, TimeUnit.MILLISECONDS) : dataChannel.take();\n            if (nextRecord != null) {\n                for (RecordWriterOutput<OUT> output : outputs) {\n                    output.collect(nextRecord);\n                }\n            } else {\n                                break;\n            }\n        }\n    } finally {\n                BlockingQueueBroker.INSTANCE.remove(brokerID);\n        LOG.info(\"Iteration head {} removed feedback queue under {}\", getName(), brokerID);\n    }\n}", "lc": 0.7272727272727273, "pi": 0.9952153110047848, "ma": 0.8, "nbd": 1.0, "ml": 0.4166666666666667, "d": 0.3412698412698413, "mi": -0.5610993657505284, "fo": 1.0, "r": -0.02631578947368421, "e": 0.7955809892636709}
{"project_name": "Closure", "project_version": 91, "label": 2, "code": "/**\n * Since this pass reports errors only when a global {@code this} keyword\n * is encountered, there is no reason to traverse non global contexts.\n */\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() == Token.FUNCTION) {\n        // Don't traverse functions that are constructors or have the @this\n        // or @override annotation.\n        JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.isInterface() || jsDoc.hasThisType() || jsDoc.isOverride())) {\n            return false;\n        }\n        // Don't traverse functions unless they would normally\n        // be able to have a @this annotation associated with them. e.g.,\n        // var a = function() { }; // or\n        // function a() {} // or\n        // a.x = function() {}; // or\n        // var a = {x: function() {}};\n        int pType = parent.getType();\n        if (!(pType == Token.BLOCK || pType == Token.SCRIPT || pType == Token.NAME || pType == Token.ASSIGN || // object literal keys\n        pType == Token.STRING || pType == Token.NUMBER)) {\n            return false;\n        }\n    // Don't traverse functions that are getting lent to a prototype.\n    }\n    if (parent != null && parent.getType() == Token.ASSIGN) {\n        Node lhs = parent.getFirstChild();\n        Node rhs = lhs.getNext();\n        if (n == lhs) {\n            // assignLhsChild should not be overridden.\n            if (assignLhsChild == null) {\n                assignLhsChild = lhs;\n            }\n        } else {\n            // property or subproperty.\n            if (NodeUtil.isGet(lhs)) {\n                if (lhs.getType() == Token.GETPROP && lhs.getLastChild().getString().equals(\"prototype\")) {\n                    return false;\n                }\n                Node llhs = lhs.getFirstChild();\n                if (llhs.getType() == Token.GETPROP && llhs.getLastChild().getString().equals(\"prototype\")) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}", "code_comment": "/**\n * Since this pass reports errors only when a global {@code this} keyword\n * is encountered, there is no reason to traverse non global contexts.\n */\n", "code_no_comment": "public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() == Token.FUNCTION) {\n                        JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.isInterface() || jsDoc.hasThisType() || jsDoc.isOverride())) {\n            return false;\n        }\n                                                        int pType = parent.getType();\n        if (!(pType == Token.BLOCK || pType == Token.SCRIPT || pType == Token.NAME || pType == Token.ASSIGN ||         pType == Token.STRING || pType == Token.NUMBER)) {\n            return false;\n        }\n        }\n    if (parent != null && parent.getType() == Token.ASSIGN) {\n        Node lhs = parent.getFirstChild();\n        Node rhs = lhs.getNext();\n        if (n == lhs) {\n                        if (assignLhsChild == null) {\n                assignLhsChild = lhs;\n            }\n        } else {\n                        if (NodeUtil.isGet(lhs)) {\n                if (lhs.getType() == Token.GETPROP && lhs.getLastChild().getString().equals(\"prototype\")) {\n                    return false;\n                }\n                Node llhs = lhs.getFirstChild();\n                if (llhs.getType() == Token.GETPROP && llhs.getLastChild().getString().equals(\"prototype\")) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}", "lc": 0.8636363636363636, "pi": 1.0239234449760766, "ma": 1.2, "nbd": 1.0, "ml": 2.75, "d": 1.0773809523809523, "mi": -0.6456659619450316, "fo": 1.1666666666666667, "r": -0.02631578947368421, "e": 2.2085533329875573}
{"project_name": "Lang", "project_version": 14, "label": 1, "code": "// Equals\n// -----------------------------------------------------------------------\n/**\n * <p>Compares two CharSequences, returning {@code true} if they represent\n * equal sequences of characters.</p>\n *\n * <p>{@code null}s are handled without exceptions. Two {@code null}\n * references are considered to be equal. The comparison is case sensitive.</p>\n *\n * <pre>\n * StringUtils.equals(null, null)   = true\n * StringUtils.equals(null, \"abc\")  = false\n * StringUtils.equals(\"abc\", null)  = false\n * StringUtils.equals(\"abc\", \"abc\") = true\n * StringUtils.equals(\"abc\", \"ABC\") = false\n * </pre>\n *\n * @see java.lang.CharSequence#equals(Object)\n * @param cs1  the first CharSequence, may be {@code null}\n * @param cs2  the second CharSequence, may be {@code null}\n * @return {@code true} if the CharSequences are equal (case-sensitive), or both {@code null}\n * @since 3.0 Changed signature from equals(String, String) to equals(CharSequence, CharSequence)\n */\npublic static boolean equals(CharSequence cs1, CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    return cs1.equals(cs2);\n}", "code_comment": "/**\n * <p>Compares two CharSequences, returning {@code true} if they represent\n * equal sequences of characters.</p>\n *\n * <p>{@code null}s are handled without exceptions. Two {@code null}\n * references are considered to be equal. The comparison is case sensitive.</p>\n *\n * <pre>\n * StringUtils.equals(null, null)   = true\n * StringUtils.equals(null, \"abc\")  = false\n * StringUtils.equals(\"abc\", null)  = false\n * StringUtils.equals(\"abc\", \"abc\") = true\n * StringUtils.equals(\"abc\", \"ABC\") = false\n * </pre>\n *\n * @see java.lang.CharSequence#equals(Object)\n * @param cs1  the first CharSequence, may be {@code null}\n * @param cs2  the second CharSequence, may be {@code null}\n * @return {@code true} if the CharSequences are equal (case-sensitive), or both {@code null}\n * @since 3.0 Changed signature from equals(String, String) to equals(CharSequence, CharSequence)\n */\n", "code_no_comment": "public static boolean equals(CharSequence cs1, CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    return cs1.equals(cs2);\n}", "lc": -0.22727272727272727, "pi": -0.15311004784689008, "ma": -0.2, "nbd": -0.5, "ml": 0.0, "d": 0.05555555555555556, "mi": 0.3324876673713883, "fo": -0.4166666666666667, "r": 0.02631578947368421, "e": -0.09444972712551072}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4066_4d3d1f85", "label": 1, "code": "public IRequestHandler mapRequest(Request request) {\n    InterceptData data = InterceptData.get();\n    if (data != null) {\n        if (data.originalUrl.equals(request.getOriginalUrl())) {\n            if (data.postParameters.isEmpty() == false && request.getPostParameters() instanceof IWritableRequestParameters) {\n                IWritableRequestParameters parameters = (IWritableRequestParameters) request.getPostParameters();\n                parameters.reset();\n                for (String s : data.postParameters.keySet()) {\n                    parameters.setParameterValues(s, data.postParameters.get(s));\n                }\n            }\n            InterceptData.clear();\n        }\n    }\n    return null;\n}", "code_comment": NaN, "code_no_comment": "public IRequestHandler mapRequest(Request request) {\n    InterceptData data = InterceptData.get();\n    if (data != null) {\n        if (data.originalUrl.equals(request.getOriginalUrl())) {\n            if (data.postParameters.isEmpty() == false && request.getPostParameters() instanceof IWritableRequestParameters) {\n                IWritableRequestParameters parameters = (IWritableRequestParameters) request.getPostParameters();\n                parameters.reset();\n                for (String s : data.postParameters.keySet()) {\n                    parameters.setParameterValues(s, data.postParameters.get(s));\n                }\n            }\n            InterceptData.clear();\n        }\n    }\n    return null;\n}", "lc": 0.09090909090909091, "pi": 1.5071770334928227, "ma": 0.2, "nbd": 1.0, "ml": 0.3333333333333333, "d": 0.37896825396825395, "mi": -0.12445384073291024, "fo": 0.4166666666666667, "r": -0.02631578947368421, "e": 0.2527734075598047}
{"project_name": "Closure", "project_version": 5, "label": 1, "code": "/**\n * Counts the number of direct (full) references to an object.\n * Specifically, we check for references of the following type:\n * <pre>\n *   x;\n *   x.fn();\n * </pre>\n */\nprivate boolean isInlinableObject(List<Reference> refs) {\n    boolean ret = false;\n    Set<String> validProperties = Sets.newHashSet();\n    for (Reference ref : refs) {\n        Node name = ref.getNode();\n        Node parent = ref.getParent();\n        Node gramps = ref.getGrandparent();\n        // \n        if (parent.isGetProp()) {\n            Preconditions.checkState(parent.getFirstChild() == name);\n            // A call target may be using the object as a 'this' value.\n            if (gramps.isCall() && gramps.getFirstChild() == parent) {\n                return false;\n            }\n            // Deleting a property has different semantics from deleting\n            // a variable, so deleted properties should not be inlined.\n            // NOTE(nicksantos): This pass's object-splitting algorithm has\n            // a blind spot. It assumes that if a property isn't defined on an\n            // object, then the value is undefined. This is not true, because\n            // Object.prototype can have arbitrary properties on it.\n            // \n            // We short-circuit this problem by bailing out if we see a reference\n            // to a property that isn't defined on the object literal. This\n            // isn't a perfect algorithm, but it should catch most cases.\n            String propName = parent.getLastChild().getString();\n            if (!validProperties.contains(propName)) {\n                if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {\n                    validProperties.add(propName);\n                } else {\n                    return false;\n                }\n            }\n            continue;\n        }\n        // Only rewrite VAR declarations or simple assignment statements\n        if (!isVarOrAssignExprLhs(name)) {\n            return false;\n        }\n        Node val = ref.getAssignedValue();\n        if (val == null) {\n            // A var with no assignment.\n            continue;\n        }\n        // We're looking for object literal assignments only.\n        if (!val.isObjectLit()) {\n            return false;\n        }\n        // Also, ES5 getters/setters aren't handled by this pass.\n        for (Node child = val.getFirstChild(); child != null; child = child.getNext()) {\n            if (child.isGetterDef() || child.isSetterDef()) {\n                // ES5 get/set not supported.\n                return false;\n            }\n            validProperties.add(child.getString());\n            Node childVal = child.getFirstChild();\n            // will happen.\n            for (Reference t : refs) {\n                Node refNode = t.getParent();\n                while (!NodeUtil.isStatementBlock(refNode)) {\n                    if (refNode == childVal) {\n                        // There's a self-referential assignment\n                        return false;\n                    }\n                    refNode = refNode.getParent();\n                }\n            }\n        }\n        // We have found an acceptable object literal assignment. As\n        // long as there are no other assignments that mess things up,\n        // we can inline.\n        ret = true;\n    }\n    return ret;\n}", "code_comment": "/**\n * Counts the number of direct (full) references to an object.\n * Specifically, we check for references of the following type:\n * <pre>\n *   x;\n *   x.fn();\n * </pre>\n */\n", "code_no_comment": "private boolean isInlinableObject(List<Reference> refs) {\n    boolean ret = false;\n    Set<String> validProperties = Sets.newHashSet();\n    for (Reference ref : refs) {\n        Node name = ref.getNode();\n        Node parent = ref.getParent();\n        Node gramps = ref.getGrandparent();\n                if (parent.isGetProp()) {\n            Preconditions.checkState(parent.getFirstChild() == name);\n                        if (gramps.isCall() && gramps.getFirstChild() == parent) {\n                return false;\n            }\n                                                                                                                                    String propName = parent.getLastChild().getString();\n            if (!validProperties.contains(propName)) {\n                if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {\n                    validProperties.add(propName);\n                } else {\n                    return false;\n                }\n            }\n            continue;\n        }\n                if (!isVarOrAssignExprLhs(name)) {\n            return false;\n        }\n        Node val = ref.getAssignedValue();\n        if (val == null) {\n                        continue;\n        }\n                if (!val.isObjectLit()) {\n            return false;\n        }\n                for (Node child = val.getFirstChild(); child != null; child = child.getNext()) {\n            if (child.isGetterDef() || child.isSetterDef()) {\n                                return false;\n            }\n            validProperties.add(child.getString());\n            Node childVal = child.getFirstChild();\n                        for (Reference t : refs) {\n                Node refNode = t.getParent();\n                while (!NodeUtil.isStatementBlock(refNode)) {\n                    if (refNode == childVal) {\n                                                return false;\n                    }\n                    refNode = refNode.getParent();\n                }\n            }\n        }\n                                ret = true;\n    }\n    return ret;\n}", "lc": 1.7272727272727273, "pi": 1.062200956937799, "ma": 2.4, "nbd": 1.5, "ml": 2.1666666666666665, "d": 1.0456349206349207, "mi": -0.9024665257223394, "fo": 1.75, "r": -0.02631578947368421, "e": 2.321958472363894}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3089_ba38c380", "label": 3, "code": "/**\n * Set the maximum memory this cache should use. This will not\n * immediately cause entries to get removed however; it will only change\n * the limit. To resize the internal array, call the clear method.\n *\n * @param maxMemory the maximum size (1 or larger)\n */\npublic void setMaxMemory(long maxMemory) {\n    if (maxMemory <= 0) {\n        throw new IllegalArgumentException(\"Max memory must be larger than 0\");\n    }\n    this.maxMemory = maxMemory;\n    if (segments != null) {\n        long max = 1 + maxMemory / segments.length;\n        for (Segment<K, V> s : segments) {\n            s.setMaxMemory(max);\n        }\n    }\n}", "code_comment": "/**\n * Set the maximum memory this cache should use. This will not\n * immediately cause entries to get removed however; it will only change\n * the limit. To resize the internal array, call the clear method.\n *\n * @param maxMemory the maximum size (1 or larger)\n */\n", "code_no_comment": "public void setMaxMemory(long maxMemory) {\n    if (maxMemory <= 0) {\n        throw new IllegalArgumentException(\"Max memory must be larger than 0\");\n    }\n    this.maxMemory = maxMemory;\n    if (segments != null) {\n        long max = 1 + maxMemory / segments.length;\n        for (Segment<K, V> s : segments) {\n            s.setMaxMemory(max);\n        }\n    }\n}", "lc": -0.09090909090909091, "pi": 0.1961722488038276, "ma": 0.2, "nbd": 0.0, "ml": -0.08333333333333333, "d": 0.2698412698412699, "mi": 0.09739252995066941, "fo": -0.4166666666666667, "r": 0.5526315789473684, "e": 0.028494205379114006}
{"project_name": "maven", "project_version": "remotes/origin/bugs-dot-jar_MNG-5212_c53d95ce", "label": 1, "code": "protected static PluginDescriptor clone(PluginDescriptor original) {\n    PluginDescriptor clone = null;\n    if (original != null) {\n        clone = new PluginDescriptor();\n        clone.setGroupId(original.getGroupId());\n        clone.setArtifactId(original.getArtifactId());\n        clone.setVersion(original.getVersion());\n        clone.setGoalPrefix(original.getGoalPrefix());\n        clone.setInheritedByDefault(original.isInheritedByDefault());\n        clone.setName(original.getName());\n        clone.setDescription(original.getDescription());\n        clone.setRequiredMavenVersion(original.getRequiredMavenVersion());\n        clone.setPluginArtifact(ArtifactUtils.copyArtifactSafe(original.getPluginArtifact()));\n        clone.setComponents(clone(original.getMojos(), clone));\n        clone.setId(original.getId());\n        clone.setIsolatedRealm(original.isIsolatedRealm());\n        clone.setSource(original.getSource());\n    }\n    return clone;\n}", "code_comment": NaN, "code_no_comment": "protected static PluginDescriptor clone(PluginDescriptor original) {\n    PluginDescriptor clone = null;\n    if (original != null) {\n        clone = new PluginDescriptor();\n        clone.setGroupId(original.getGroupId());\n        clone.setArtifactId(original.getArtifactId());\n        clone.setVersion(original.getVersion());\n        clone.setGoalPrefix(original.getGoalPrefix());\n        clone.setInheritedByDefault(original.isInheritedByDefault());\n        clone.setName(original.getName());\n        clone.setDescription(original.getDescription());\n        clone.setRequiredMavenVersion(original.getRequiredMavenVersion());\n        clone.setPluginArtifact(ArtifactUtils.copyArtifactSafe(original.getPluginArtifact()));\n        clone.setComponents(clone(original.getMojos(), clone));\n        clone.setId(original.getId());\n        clone.setIsolatedRealm(original.isIsolatedRealm());\n        clone.setSource(original.getSource());\n    }\n    return clone;\n}", "lc": 0.2727272727272727, "pi": -0.16267942583732073, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": 0.04960317460317456, "mi": -0.269908386187456, "fo": 1.8333333333333333, "r": -0.02631578947368421, "e": 0.19321242717103784}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-757_76b7413d", "label": 1, "code": "/**\n * Returns a hash code consistent with equals.\n *\n * @return the hash code representing this {@code ResizableDoubleArray}.\n * @since 2.0\n */\n@Override\npublic synchronized int hashCode() {\n    final int[] hashData = new int[6];\n    hashData[0] = Double.valueOf(expansionFactor).hashCode();\n    hashData[1] = Double.valueOf(contractionCriterion).hashCode();\n    hashData[2] = expansionMode.hashCode();\n    hashData[3] = Arrays.hashCode(internalArray);\n    hashData[4] = numElements;\n    hashData[5] = startIndex;\n    return Arrays.hashCode(hashData);\n}", "code_comment": "/**\n * Returns a hash code consistent with equals.\n *\n * @return the hash code representing this {@code ResizableDoubleArray}.\n * @since 2.0\n */\n", "code_no_comment": "@Override\npublic synchronized int hashCode() {\n    final int[] hashData = new int[6];\n    hashData[0] = Double.valueOf(expansionFactor).hashCode();\n    hashData[1] = Double.valueOf(contractionCriterion).hashCode();\n    hashData[2] = expansionMode.hashCode();\n    hashData[3] = Arrays.hashCode(internalArray);\n    hashData[4] = numElements;\n    hashData[5] = startIndex;\n    return Arrays.hashCode(hashData);\n}", "lc": -0.13636363636363635, "pi": -0.5789473684210528, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.11120507399577186, "fo": 0.08333333333333333, "r": 0.2631578947368421, "e": -0.16279340490885932}
{"project_name": "Closure", "project_version": 45, "label": 1, "code": "/**\n * Look at all the property assigns to all variables.\n * These may or may not count as references. For example,\n *\n * <code>\n * var x = {};\n * x.foo = 3; // not a reference.\n * var y = foo();\n * y.foo = 3; // is a reference.\n * </code>\n *\n * Interpreting assignments could mark a variable as referenced that\n * wasn't referenced before, in order to keep it alive. Because we find\n * references by lazily traversing subtrees, marking a variable as\n * referenced could trigger new traversals of new subtrees, which could\n * find new references.\n *\n * Therefore, this interpretation needs to be run to a fixed point.\n */\nprivate void interpretAssigns() {\n    boolean changes = false;\n    do {\n        changes = false;\n        // we traverse it.\n        for (int current = 0; current < maybeUnreferenced.size(); current++) {\n            Var var = maybeUnreferenced.get(current);\n            if (referenced.contains(var)) {\n                maybeUnreferenced.remove(current);\n                current--;\n            } else {\n                boolean assignedToUnknownValue = false;\n                boolean hasPropertyAssign = false;\n                if (var.getParentNode().isVar() && !NodeUtil.isForIn(var.getParentNode().getParent())) {\n                    Node value = var.getInitialValue();\n                    assignedToUnknownValue = value != null && !NodeUtil.isLiteralValue(value, true);\n                } else {\n                    // This was initialized to a function arg or a catch param\n                    // or a for...in variable.\n                    assignedToUnknownValue = true;\n                }\n                for (Assign assign : assignsByVar.get(var)) {\n                    if (assign.isPropertyAssign) {\n                        hasPropertyAssign = true;\n                    } else if (!NodeUtil.isLiteralValue(assign.assignNode.getLastChild(), true)) {\n                        assignedToUnknownValue = true;\n                    }\n                }\n                if (assignedToUnknownValue && hasPropertyAssign) {\n                    changes = markReferencedVar(var) || changes;\n                    maybeUnreferenced.remove(current);\n                    current--;\n                }\n            }\n        }\n    } while (changes);\n}", "code_comment": "/**\n * Look at all the property assigns to all variables.\n * These may or may not count as references. For example,\n *\n * <code>\n * var x = {};\n * x.foo = 3; // not a reference.\n * var y = foo();\n * y.foo = 3; // is a reference.\n * </code>\n *\n * Interpreting assignments could mark a variable as referenced that\n * wasn't referenced before, in order to keep it alive. Because we find\n * references by lazily traversing subtrees, marking a variable as\n * referenced could trigger new traversals of new subtrees, which could\n * find new references.\n *\n * Therefore, this interpretation needs to be run to a fixed point.\n */\n", "code_no_comment": "private void interpretAssigns() {\n    boolean changes = false;\n    do {\n        changes = false;\n                for (int current = 0; current < maybeUnreferenced.size(); current++) {\n            Var var = maybeUnreferenced.get(current);\n            if (referenced.contains(var)) {\n                maybeUnreferenced.remove(current);\n                current--;\n            } else {\n                boolean assignedToUnknownValue = false;\n                boolean hasPropertyAssign = false;\n                if (var.getParentNode().isVar() && !NodeUtil.isForIn(var.getParentNode().getParent())) {\n                    Node value = var.getInitialValue();\n                    assignedToUnknownValue = value != null && !NodeUtil.isLiteralValue(value, true);\n                } else {\n                                                            assignedToUnknownValue = true;\n                }\n                for (Assign assign : assignsByVar.get(var)) {\n                    if (assign.isPropertyAssign) {\n                        hasPropertyAssign = true;\n                    } else if (!NodeUtil.isLiteralValue(assign.assignNode.getLastChild(), true)) {\n                        assignedToUnknownValue = true;\n                    }\n                }\n                if (assignedToUnknownValue && hasPropertyAssign) {\n                    changes = markReferencedVar(var) || changes;\n                    maybeUnreferenced.remove(current);\n                    current--;\n                }\n            }\n        }\n    } while (changes);\n}", "lc": 0.9090909090909091, "pi": 1.6172248803827751, "ma": 1.0, "nbd": 2.0, "ml": 1.4166666666666667, "d": 1.4325396825396826, "mi": -0.6146582100070469, "fo": 0.8333333333333334, "r": -0.02631578947368421, "e": 2.1117869100926097}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1270_70564c7c", "label": 1, "code": "@Override\npublic boolean visit(FullTextOr or) {\n    BooleanQuery q = new BooleanQuery();\n    for (FullTextExpression e : or.list) {\n        Query x = getFullTextQuery(e, analyzer);\n        q.add(x, SHOULD);\n    }\n    result.set(q);\n    return true;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean visit(FullTextOr or) {\n    BooleanQuery q = new BooleanQuery();\n    for (FullTextExpression e : or.list) {\n        Query x = getFullTextQuery(e, analyzer);\n        q.add(x, SHOULD);\n    }\n    result.set(q);\n    return true;\n}", "lc": -0.18181818181818182, "pi": -0.0909090909090911, "ma": -0.4, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.2155038759689921, "fo": -0.25, "r": 0.6842105263157895, "e": -0.16279340490885932}
{"project_name": "Lang", "project_version": 49, "label": 1, "code": "// Calculations\n// -------------------------------------------------------------------\n/**\n * <p>Reduce the fraction to the smallest values for the numerator and\n * denominator, returning the result.</p>\n *\n * <p>For example, if this fraction represents 2/4, then the result\n * will be 1/2.</p>\n *\n * @return a new reduced fraction instance, or this if no simplification possible\n */\npublic Fraction reduce() {\n    int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);\n    if (gcd == 1) {\n        return this;\n    }\n    return Fraction.getFraction(numerator / gcd, denominator / gcd);\n}", "code_comment": "/**\n * <p>Reduce the fraction to the smallest values for the numerator and\n * denominator, returning the result.</p>\n *\n * <p>For example, if this fraction represents 2/4, then the result\n * will be 1/2.</p>\n *\n * @return a new reduced fraction instance, or this if no simplification possible\n */\n", "code_no_comment": "public Fraction reduce() {\n    int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);\n    if (gcd == 1) {\n        return this;\n    }\n    return Fraction.getFraction(numerator / gcd, denominator / gcd);\n}", "lc": -0.3181818181818182, "pi": -0.20574162679425848, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": -0.05753968253968254, "mi": 0.4336856941508105, "fo": -0.25, "r": 1.9473684210526316, "e": -0.10582343550999003}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-6667_1fc7bd7a", "label": 1, "code": "protected boolean process(final Exchange exchange, final AsyncCallback callback, final AtomicInteger index, final AtomicInteger count) {\n    // set current index as property\n    LOG.debug(\"LoopProcessor: iteration #{}\", index.get());\n    exchange.setProperty(Exchange.LOOP_INDEX, index.get());\n    boolean sync = processor.process(exchange, new AsyncCallback() {\n\n        public void done(boolean doneSync) {\n            // we only have to handle async completion of the routing slip\n            if (doneSync) {\n                return;\n            }\n            Exchange target = exchange;\n            // increment index as we have just processed once\n            index.getAndIncrement();\n            // continue looping asynchronously\n            while (index.get() < count.get()) {\n                // and prepare for next iteration\n                target = prepareExchange(exchange, index.get());\n                // process again\n                boolean sync = process(target, callback, index, count);\n                if (!sync) {\n                    LOG.trace(\"Processing exchangeId: {} is continued being processed asynchronously\", target.getExchangeId());\n                    // so we break out now, then the callback will be invoked which then continue routing from where we left here\n                    return;\n                }\n                // increment counter before next loop\n                index.getAndIncrement();\n            }\n            // we are done so prepare the result\n            ExchangeHelper.copyResults(exchange, target);\n            LOG.trace(\"Processing complete for exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\n            callback.done(false);\n        }\n    });\n    return sync;\n}", "code_comment": NaN, "code_no_comment": "protected boolean process(final Exchange exchange, final AsyncCallback callback, final AtomicInteger index, final AtomicInteger count) {\n        LOG.debug(\"LoopProcessor: iteration #{}\", index.get());\n    exchange.setProperty(Exchange.LOOP_INDEX, index.get());\n    boolean sync = processor.process(exchange, new AsyncCallback() {\n\n        public void done(boolean doneSync) {\n                        if (doneSync) {\n                return;\n            }\n            Exchange target = exchange;\n                        index.getAndIncrement();\n                        while (index.get() < count.get()) {\n                                target = prepareExchange(exchange, index.get());\n                                boolean sync = process(target, callback, index, count);\n                if (!sync) {\n                    LOG.trace(\"Processing exchangeId: {} is continued being processed asynchronously\", target.getExchangeId());\n                                        return;\n                }\n                                index.getAndIncrement();\n            }\n                        ExchangeHelper.copyResults(exchange, target);\n            LOG.trace(\"Processing complete for exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\n            callback.done(false);\n        }\n    });\n    return sync;\n}", "lc": 0.5454545454545454, "pi": 1.263157894736842, "ma": 0.0, "nbd": 0.5, "ml": 0.16666666666666666, "d": 0.12103174603174605, "mi": -0.4088794926004226, "fo": 1.0, "r": -0.02631578947368421, "e": 0.2717726180391072}
{"project_name": "maven", "project_version": "remotes/origin/bugs-dot-jar_MNG-2221_cc859f5c", "label": 0, "code": "public static void mergePluginLists(PluginContainer childContainer, PluginContainer parentContainer, boolean handleAsInheritance) {\n    if (childContainer == null || parentContainer == null) {\n        // nothing to do.\n        return;\n    }\n    List mergedPlugins = new ArrayList();\n    List parentPlugins = parentContainer.getPlugins();\n    if (parentPlugins != null && !parentPlugins.isEmpty()) {\n        Map assembledPlugins = new TreeMap();\n        Map childPlugins = childContainer.getPluginsAsMap();\n        for (Iterator it = parentPlugins.iterator(); it.hasNext(); ) {\n            Plugin parentPlugin = (Plugin) it.next();\n            String parentInherited = parentPlugin.getInherited();\n            if (!handleAsInheritance || parentInherited == null || Boolean.valueOf(parentInherited).booleanValue()) {\n                Plugin assembledPlugin = parentPlugin;\n                Plugin childPlugin = (Plugin) childPlugins.get(parentPlugin.getKey());\n                if (childPlugin != null) {\n                    assembledPlugin = childPlugin;\n                    mergePluginDefinitions(childPlugin, parentPlugin, handleAsInheritance);\n                }\n                if (handleAsInheritance && parentInherited == null) {\n                    assembledPlugin.unsetInheritanceApplied();\n                }\n                mergedPlugins.add(assembledPlugin);\n            }\n        }\n        // since assembledPlugins is never updated and remains empty.\n        for (Iterator it = childPlugins.values().iterator(); it.hasNext(); ) {\n            Plugin childPlugin = (Plugin) it.next();\n            if (!assembledPlugins.containsKey(childPlugin.getKey())) {\n                mergedPlugins.add(childPlugin);\n            }\n        }\n        childContainer.setPlugins(mergedPlugins);\n        childContainer.flushPluginMap();\n    }\n}", "code_comment": NaN, "code_no_comment": "public static void mergePluginLists(PluginContainer childContainer, PluginContainer parentContainer, boolean handleAsInheritance) {\n    if (childContainer == null || parentContainer == null) {\n                return;\n    }\n    List mergedPlugins = new ArrayList();\n    List parentPlugins = parentContainer.getPlugins();\n    if (parentPlugins != null && !parentPlugins.isEmpty()) {\n        Map assembledPlugins = new TreeMap();\n        Map childPlugins = childContainer.getPluginsAsMap();\n        for (Iterator it = parentPlugins.iterator(); it.hasNext(); ) {\n            Plugin parentPlugin = (Plugin) it.next();\n            String parentInherited = parentPlugin.getInherited();\n            if (!handleAsInheritance || parentInherited == null || Boolean.valueOf(parentInherited).booleanValue()) {\n                Plugin assembledPlugin = parentPlugin;\n                Plugin childPlugin = (Plugin) childPlugins.get(parentPlugin.getKey());\n                if (childPlugin != null) {\n                    assembledPlugin = childPlugin;\n                    mergePluginDefinitions(childPlugin, parentPlugin, handleAsInheritance);\n                }\n                if (handleAsInheritance && parentInherited == null) {\n                    assembledPlugin.unsetInheritanceApplied();\n                }\n                mergedPlugins.add(assembledPlugin);\n            }\n        }\n                for (Iterator it = childPlugins.values().iterator(); it.hasNext(); ) {\n            Plugin childPlugin = (Plugin) it.next();\n            if (!assembledPlugins.containsKey(childPlugin.getKey())) {\n                mergedPlugins.add(childPlugin);\n            }\n        }\n        childContainer.setPlugins(mergedPlugins);\n        childContainer.flushPluginMap();\n    }\n}", "lc": 0.9545454545454546, "pi": 1.200956937799043, "ma": 1.0, "nbd": 1.0, "ml": 1.5833333333333333, "d": 1.0654761904761905, "mi": -0.6665257223396756, "fo": 1.4166666666666667, "r": -0.02631578947368421, "e": 2.1963267117327385}
{"project_name": "Closure", "project_version": 132, "label": 2, "code": "/**\n * Try turning IF nodes into smaller HOOKs\n *\n * Returns the replacement for n or the original if no replacement was\n * necessary.\n */\nprivate Node tryMinimizeIf(Node n) {\n    Node parent = n.getParent();\n    Node cond = n.getFirstChild();\n    /* If the condition is a literal, we'll let other\n     * optimizations try to remove useless code.\n     */\n    if (NodeUtil.isLiteralValue(cond, true)) {\n        return n;\n    }\n    Node thenBranch = cond.getNext();\n    Node elseBranch = thenBranch.getNext();\n    if (elseBranch == null) {\n        if (isFoldableExpressBlock(thenBranch)) {\n            Node expr = getBlockExpression(thenBranch);\n            if (!late && isPropertyAssignmentInExpression(expr)) {\n                // until CollapseProperties has been run.\n                return n;\n            }\n            if (cond.isNot()) {\n                // if(!x)bar(); -> x||bar();\n                if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), OR_PRECEDENCE)) {\n                    // It's not okay to add two sets of parentheses.\n                    return n;\n                }\n                Node or = IR.or(cond.removeFirstChild(), expr.removeFirstChild()).srcref(n);\n                Node newExpr = NodeUtil.newExpr(or);\n                parent.replaceChild(n, newExpr);\n                reportCodeChange();\n                return newExpr;\n            }\n            // if(x)foo(); -> x&&foo();\n            if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), AND_PRECEDENCE)) {\n                // we can further optimize its parent.\n                return n;\n            }\n            n.removeChild(cond);\n            Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n            Node newExpr = NodeUtil.newExpr(and);\n            parent.replaceChild(n, newExpr);\n            reportCodeChange();\n            return newExpr;\n        } else {\n            // Try to combine two IF-ELSE\n            if (NodeUtil.isStatementBlock(thenBranch) && thenBranch.hasOneChild()) {\n                Node innerIf = thenBranch.getFirstChild();\n                if (innerIf.isIf()) {\n                    Node innerCond = innerIf.getFirstChild();\n                    Node innerThenBranch = innerCond.getNext();\n                    Node innerElseBranch = innerThenBranch.getNext();\n                    if (innerElseBranch == null && !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n                        n.detachChildren();\n                        n.addChildToBack(IR.and(cond, innerCond.detachFromParent()).srcref(cond));\n                        n.addChildrenToBack(innerThenBranch.detachFromParent());\n                        reportCodeChange();\n                        // the inner IF-ELSE wasn't able to be folded into && anyways.\n                        return n;\n                    }\n                }\n            }\n        }\n        return n;\n    }\n    /* TODO(dcc) This modifies the siblings of n, which is undesirable for a\n     * peephole optimization. This should probably get moved to another pass.\n     */\n    tryRemoveRepeatedStatements(n);\n    // An additional set of curly braces isn't worth it.\n    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n        n.replaceChild(cond, cond.removeFirstChild());\n        n.removeChild(thenBranch);\n        n.addChildToBack(thenBranch);\n        reportCodeChange();\n        return n;\n    }\n    // if(x)return 1;else return 2; -> return x?1:2;\n    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n        Node thenExpr = getBlockReturnExpression(thenBranch);\n        Node elseExpr = getBlockReturnExpression(elseBranch);\n        n.removeChild(cond);\n        thenExpr.detachFromParent();\n        elseExpr.detachFromParent();\n        // note - we ignore any cases with \"return;\", technically this\n        // can be converted to \"return undefined;\" or some variant, but\n        // that does not help code size.\n        Node returnNode = IR.returnNode(IR.hook(cond, thenExpr, elseExpr).srcref(n));\n        parent.replaceChild(n, returnNode);\n        reportCodeChange();\n        return returnNode;\n    }\n    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n        Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n        Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n        if (thenOp.getType() == elseOp.getType()) {\n            // if(x)a=1;else a=2; -> a=x?1:2;\n            if (NodeUtil.isAssignmentOp(thenOp)) {\n                Node lhs = thenOp.getFirstChild();\n                if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && // proceed even if there are side effects...\n                !mayEffectMutableState(lhs)) {\n                    n.removeChild(cond);\n                    Node assignName = thenOp.removeFirstChild();\n                    Node thenExpr = thenOp.removeFirstChild();\n                    Node elseExpr = elseOp.getLastChild();\n                    elseOp.removeChild(elseExpr);\n                    Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n                    Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp);\n                    Node expr = NodeUtil.newExpr(assign);\n                    parent.replaceChild(n, expr);\n                    reportCodeChange();\n                    return expr;\n                }\n            }\n        }\n        // if(x)foo();else bar(); -> x?foo():bar()\n        n.removeChild(cond);\n        thenOp.detachFromParent();\n        elseOp.detachFromParent();\n        Node expr = IR.exprResult(IR.hook(cond, thenOp, elseOp).srcref(n));\n        parent.replaceChild(n, expr);\n        reportCodeChange();\n        return expr;\n    }\n    boolean thenBranchIsVar = isVarBlock(thenBranch);\n    boolean elseBranchIsVar = isVarBlock(elseBranch);\n    // if(x)var y=1;else y=2  ->  var y=x?1:2\n    if (thenBranchIsVar && elseBranchIsExpressionBlock && getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n        Node var = getBlockVar(thenBranch);\n        Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n        Node name1 = var.getFirstChild();\n        Node maybeName2 = elseAssign.getFirstChild();\n        if (name1.hasChildren() && maybeName2.isName() && name1.getString().equals(maybeName2.getString())) {\n            Node thenExpr = name1.removeChildren();\n            Node elseExpr = elseAssign.getLastChild().detachFromParent();\n            cond.detachFromParent();\n            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n            var.detachFromParent();\n            name1.addChildrenToBack(hookNode);\n            parent.replaceChild(n, var);\n            reportCodeChange();\n            return var;\n        }\n    // if(x)y=1;else var y=2  ->  var y=x?1:2\n    } else if (elseBranchIsVar && thenBranchIsExpressionBlock && getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n        Node var = getBlockVar(elseBranch);\n        Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n        Node maybeName1 = thenAssign.getFirstChild();\n        Node name2 = var.getFirstChild();\n        if (name2.hasChildren() && maybeName1.isName() && maybeName1.getString().equals(name2.getString())) {\n            Node thenExpr = thenAssign.getLastChild().detachFromParent();\n            Node elseExpr = name2.removeChildren();\n            cond.detachFromParent();\n            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n            var.detachFromParent();\n            name2.addChildrenToBack(hookNode);\n            parent.replaceChild(n, var);\n            reportCodeChange();\n            return var;\n        }\n    }\n    return n;\n}", "code_comment": "/**\n * Try turning IF nodes into smaller HOOKs\n *\n * Returns the replacement for n or the original if no replacement was\n * necessary.\n */\n", "code_no_comment": "private Node tryMinimizeIf(Node n) {\n    Node parent = n.getParent();\n    Node cond = n.getFirstChild();\n        if (NodeUtil.isLiteralValue(cond, true)) {\n        return n;\n    }\n    Node thenBranch = cond.getNext();\n    Node elseBranch = thenBranch.getNext();\n    if (elseBranch == null) {\n        if (isFoldableExpressBlock(thenBranch)) {\n            Node expr = getBlockExpression(thenBranch);\n            if (!late && isPropertyAssignmentInExpression(expr)) {\n                                return n;\n            }\n            if (cond.isNot()) {\n                                if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), OR_PRECEDENCE)) {\n                                        return n;\n                }\n                Node or = IR.or(cond.removeFirstChild(), expr.removeFirstChild()).srcref(n);\n                Node newExpr = NodeUtil.newExpr(or);\n                parent.replaceChild(n, newExpr);\n                reportCodeChange();\n                return newExpr;\n            }\n                        if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), AND_PRECEDENCE)) {\n                                return n;\n            }\n            n.removeChild(cond);\n            Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n            Node newExpr = NodeUtil.newExpr(and);\n            parent.replaceChild(n, newExpr);\n            reportCodeChange();\n            return newExpr;\n        } else {\n                        if (NodeUtil.isStatementBlock(thenBranch) && thenBranch.hasOneChild()) {\n                Node innerIf = thenBranch.getFirstChild();\n                if (innerIf.isIf()) {\n                    Node innerCond = innerIf.getFirstChild();\n                    Node innerThenBranch = innerCond.getNext();\n                    Node innerElseBranch = innerThenBranch.getNext();\n                    if (innerElseBranch == null && !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n                        n.detachChildren();\n                        n.addChildToBack(IR.and(cond, innerCond.detachFromParent()).srcref(cond));\n                        n.addChildrenToBack(innerThenBranch.detachFromParent());\n                        reportCodeChange();\n                                                return n;\n                    }\n                }\n            }\n        }\n        return n;\n    }\n        tryRemoveRepeatedStatements(n);\n        if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n        n.replaceChild(cond, cond.removeFirstChild());\n        n.removeChild(thenBranch);\n        n.addChildToBack(thenBranch);\n        reportCodeChange();\n        return n;\n    }\n        if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n        Node thenExpr = getBlockReturnExpression(thenBranch);\n        Node elseExpr = getBlockReturnExpression(elseBranch);\n        n.removeChild(cond);\n        thenExpr.detachFromParent();\n        elseExpr.detachFromParent();\n                                Node returnNode = IR.returnNode(IR.hook(cond, thenExpr, elseExpr).srcref(n));\n        parent.replaceChild(n, returnNode);\n        reportCodeChange();\n        return returnNode;\n    }\n    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n        Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n        Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n        if (thenOp.getType() == elseOp.getType()) {\n                        if (NodeUtil.isAssignmentOp(thenOp)) {\n                Node lhs = thenOp.getFirstChild();\n                if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&                 !mayEffectMutableState(lhs)) {\n                    n.removeChild(cond);\n                    Node assignName = thenOp.removeFirstChild();\n                    Node thenExpr = thenOp.removeFirstChild();\n                    Node elseExpr = elseOp.getLastChild();\n                    elseOp.removeChild(elseExpr);\n                    Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n                    Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp);\n                    Node expr = NodeUtil.newExpr(assign);\n                    parent.replaceChild(n, expr);\n                    reportCodeChange();\n                    return expr;\n                }\n            }\n        }\n                n.removeChild(cond);\n        thenOp.detachFromParent();\n        elseOp.detachFromParent();\n        Node expr = IR.exprResult(IR.hook(cond, thenOp, elseOp).srcref(n));\n        parent.replaceChild(n, expr);\n        reportCodeChange();\n        return expr;\n    }\n    boolean thenBranchIsVar = isVarBlock(thenBranch);\n    boolean elseBranchIsVar = isVarBlock(elseBranch);\n        if (thenBranchIsVar && elseBranchIsExpressionBlock && getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n        Node var = getBlockVar(thenBranch);\n        Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n        Node name1 = var.getFirstChild();\n        Node maybeName2 = elseAssign.getFirstChild();\n        if (name1.hasChildren() && maybeName2.isName() && name1.getString().equals(maybeName2.getString())) {\n            Node thenExpr = name1.removeChildren();\n            Node elseExpr = elseAssign.getLastChild().detachFromParent();\n            cond.detachFromParent();\n            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n            var.detachFromParent();\n            name1.addChildrenToBack(hookNode);\n            parent.replaceChild(n, var);\n            reportCodeChange();\n            return var;\n        }\n        } else if (elseBranchIsVar && thenBranchIsExpressionBlock && getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n        Node var = getBlockVar(elseBranch);\n        Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n        Node maybeName1 = thenAssign.getFirstChild();\n        Node name2 = var.getFirstChild();\n        if (name2.hasChildren() && maybeName1.isName() && maybeName1.getString().equals(name2.getString())) {\n            Node thenExpr = thenAssign.getLastChild().detachFromParent();\n            Node elseExpr = name2.removeChildren();\n            cond.detachFromParent();\n            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n            var.detachFromParent();\n            name2.addChildrenToBack(hookNode);\n            parent.replaceChild(n, var);\n            reportCodeChange();\n            return var;\n        }\n    }\n    return n;\n}", "lc": 5.7272727272727275, "pi": 1.2535885167464116, "ma": 3.4, "nbd": 1.5, "ml": 6.5, "d": 1.751984126984127, "mi": -1.6015503875968988, "fo": 11.75, "r": -0.02631578947368421, "e": 15.945019392241946}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3563_c62b66c1", "label": 1, "code": "/**\n *  Processes components added to the target. This involves attaching components, rendering\n *  markup into a client side xml envelope, and detaching them\n *\n *  @param response\n */\nprivate void respondComponents(Response response) {\n    // process component markup\n    for (Map.Entry<String, Component> stringComponentEntry : markupIdToComponent.entrySet()) {\n        final Component component = stringComponentEntry.getValue();\n        if (!containsAncestorFor(component)) {\n            respondComponent(response, getAjaxRegionMarkupId(component), component);\n        }\n    }\n    if (header != null) {\n        // some header responses buffer all calls to render*** until close is called.\n        // when they are closed, they do something (i.e. aggregate all JS resource urls to a\n        // single url), and then \"flush\" (by writing to the real response) before closing.\n        // to support this, we need to allow header contributions to be written in the close\n        // tag, which we do here:\n        headerRendering = true;\n        // save old response, set new\n        Response oldResponse = RequestCycle.get().setResponse(encodingHeaderResponse);\n        encodingHeaderResponse.reset();\n        // now, close the response (which may render things)\n        header.getHeaderResponse().close();\n        // revert to old response\n        RequestCycle.get().setResponse(oldResponse);\n        // write the XML tags and we're done\n        writeHeaderContribution(response);\n        headerRendering = false;\n    }\n}", "code_comment": "/**\n *  Processes components added to the target. This involves attaching components, rendering\n *  markup into a client side xml envelope, and detaching them\n *\n *  @param response\n */\n", "code_no_comment": "private void respondComponents(Response response) {\n        for (Map.Entry<String, Component> stringComponentEntry : markupIdToComponent.entrySet()) {\n        final Component component = stringComponentEntry.getValue();\n        if (!containsAncestorFor(component)) {\n            respondComponent(response, getAjaxRegionMarkupId(component), component);\n        }\n    }\n    if (header != null) {\n                                                headerRendering = true;\n                Response oldResponse = RequestCycle.get().setResponse(encodingHeaderResponse);\n        encodingHeaderResponse.reset();\n                header.getHeaderResponse().close();\n                RequestCycle.get().setResponse(oldResponse);\n                writeHeaderContribution(response);\n        headerRendering = false;\n    }\n}", "lc": 0.13636363636363635, "pi": 0.04784688995215294, "ma": 0.0, "nbd": 0.0, "ml": 0.0, "d": -0.06746031746031747, "mi": -0.1557434813248768, "fo": 0.5833333333333334, "r": -0.02631578947368421, "e": 0.015119609504215557}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-2874_17e7b423", "label": 3, "code": "/**\n *  Checks if the given field is a valid pojo field:\n *  - it is public\n *  OR\n *   - there are getter and setter methods for the field.\n *\n *  @param f field to check\n *  @param clazz class of field\n *  @param typeHierarchy type hierarchy for materializing generic types\n */\nprivate boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy) {\n    if (Modifier.isPublic(f.getModifiers())) {\n        return true;\n    } else {\n        boolean hasGetter = false, hasSetter = false;\n        final String fieldNameLow = f.getName().toLowerCase();\n        Type fieldType = f.getGenericType();\n        TypeVariable<?> fieldTypeGeneric = null;\n        if (fieldType instanceof TypeVariable) {\n            fieldTypeGeneric = (TypeVariable<?>) fieldType;\n            fieldType = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) fieldType);\n        }\n        for (Method m : clazz.getMethods()) {\n            // check for getter\n            if (// The name should be \"get<FieldName>\" or \"<fieldName>\" (for scala) or \"is<fieldName>\" for boolean fields.\n            (m.getName().toLowerCase().equals(\"get\" + fieldNameLow) || m.getName().toLowerCase().equals(\"is\" + fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow)) && // no arguments for the getter\n            m.getParameterTypes().length == 0 && // return type is same as field type (or the generic variant of it)\n            (m.getGenericReturnType().equals(fieldType) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)))) {\n                if (hasGetter) {\n                    throw new IllegalStateException(\"Detected more than one getter\");\n                }\n                hasGetter = true;\n            }\n            // check for setters (<FieldName>_$eq for scala)\n            if ((m.getName().toLowerCase().equals(\"set\" + fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow + \"_$eq\")) && // one parameter of the field's type\n            m.getParameterTypes().length == 1 && (m.getGenericParameterTypes()[0].equals(fieldType) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric))) && // return type is void.\n            m.getReturnType().equals(Void.TYPE)) {\n                if (hasSetter) {\n                    throw new IllegalStateException(\"Detected more than one setter\");\n                }\n                hasSetter = true;\n            }\n        }\n        if (hasGetter && hasSetter) {\n            return true;\n        } else {\n            if (!hasGetter) {\n                LOG.debug(clazz + \" does not contain a getter for field \" + f.getName());\n            }\n            if (!hasSetter) {\n                LOG.debug(clazz + \" does not contain a setter for field \" + f.getName());\n            }\n            return false;\n        }\n    }\n}", "code_comment": "/**\n *  Checks if the given field is a valid pojo field:\n *  - it is public\n *  OR\n *   - there are getter and setter methods for the field.\n *\n *  @param f field to check\n *  @param clazz class of field\n *  @param typeHierarchy type hierarchy for materializing generic types\n */\n", "code_no_comment": "private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy) {\n    if (Modifier.isPublic(f.getModifiers())) {\n        return true;\n    } else {\n        boolean hasGetter = false, hasSetter = false;\n        final String fieldNameLow = f.getName().toLowerCase();\n        Type fieldType = f.getGenericType();\n        TypeVariable<?> fieldTypeGeneric = null;\n        if (fieldType instanceof TypeVariable) {\n            fieldTypeGeneric = (TypeVariable<?>) fieldType;\n            fieldType = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) fieldType);\n        }\n        for (Method m : clazz.getMethods()) {\n                        if (            (m.getName().toLowerCase().equals(\"get\" + fieldNameLow) || m.getName().toLowerCase().equals(\"is\" + fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow)) &&             m.getParameterTypes().length == 0 &&             (m.getGenericReturnType().equals(fieldType) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)))) {\n                if (hasGetter) {\n                    throw new IllegalStateException(\"Detected more than one getter\");\n                }\n                hasGetter = true;\n            }\n                        if ((m.getName().toLowerCase().equals(\"set\" + fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow + \"_$eq\")) &&             m.getParameterTypes().length == 1 && (m.getGenericParameterTypes()[0].equals(fieldType) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric))) &&             m.getReturnType().equals(Void.TYPE)) {\n                if (hasSetter) {\n                    throw new IllegalStateException(\"Detected more than one setter\");\n                }\n                hasSetter = true;\n            }\n        }\n        if (hasGetter && hasSetter) {\n            return true;\n        } else {\n            if (!hasGetter) {\n                LOG.debug(clazz + \" does not contain a getter for field \" + f.getName());\n            }\n            if (!hasSetter) {\n                LOG.debug(clazz + \" does not contain a setter for field \" + f.getName());\n            }\n            return false;\n        }\n    }\n}", "lc": 1.3636363636363635, "pi": 0.7033492822966506, "ma": 1.8, "nbd": 1.0, "ml": 2.9166666666666665, "d": 1.253968253968254, "mi": -0.845243128964059, "fo": 2.6666666666666665, "r": -0.02631578947368421, "e": 3.5456671449894244}
{"project_name": "Collections", "project_version": 25, "label": 1, "code": "/**\n * Gets an iterator that provides an ordered iteration over the elements\n * contained in a collection of {@link Iterator}s.\n * <p>\n * Given two ordered {@link Iterator}s <code>A</code> and <code>B</code>,\n * the {@link Iterator#next()} method will return the lesser of\n * <code>A.next()</code> and <code>B.next()</code> and so on.\n * <p>\n * The comparator is optional. If null is specified then natural order is used.\n *\n * @param <E>  the element type\n * @param comparator  the comparator to use, may be null for natural order\n * @param iterators  the iterators to use, not null or empty or contain nulls\n * @return a combination iterator over the iterators\n * @throws NullPointerException if iterators collection is null or contains a null\n * @throws ClassCastException if the iterators collection contains the wrong object type\n */\npublic static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator, final Collection<Iterator<? extends E>> iterators) {\n    return new CollatingIterator<E>(comparator, iterators);\n}", "code_comment": "/**\n * Gets an iterator that provides an ordered iteration over the elements\n * contained in a collection of {@link Iterator}s.\n * <p>\n * Given two ordered {@link Iterator}s <code>A</code> and <code>B</code>,\n * the {@link Iterator#next()} method will return the lesser of\n * <code>A.next()</code> and <code>B.next()</code> and so on.\n * <p>\n * The comparator is optional. If null is specified then natural order is used.\n *\n * @param <E>  the element type\n * @param comparator  the comparator to use, may be null for natural order\n * @param iterators  the iterators to use, not null or empty or contain nulls\n * @return a combination iterator over the iterators\n * @throws NullPointerException if iterators collection is null or contains a null\n * @throws ClassCastException if the iterators collection contains the wrong object type\n */\n", "code_no_comment": "public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator, final Collection<Iterator<? extends E>> iterators) {\n    return new CollatingIterator<E>(comparator, iterators);\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.8940098661028892, "fo": -0.5, "r": 0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "Closure", "project_version": 116, "label": 2, "code": "/**\n * Determines whether a function can be inlined at a particular call site.\n * There are several criteria that the function and reference must hold in\n * order for the functions to be inlined:\n * 1) If a call's arguments have side effects,\n * the corresponding argument in the function must only be referenced once.\n * For instance, this will not be inlined:\n * <pre>\n *     function foo(a) { return a + a }\n *     x = foo(i++);\n * </pre>\n */\nprivate CanInlineResult canInlineReferenceDirectly(Node callNode, Node fnNode) {\n    if (!isDirectCallNodeReplacementPossible(fnNode)) {\n        return CanInlineResult.NO;\n    }\n    Node block = fnNode.getLastChild();\n    // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n    Node cArg = callNode.getFirstChild().getNext();\n    // parameter list.\n    if (!callNode.getFirstChild().isName()) {\n        if (NodeUtil.isFunctionObjectCall(callNode)) {\n            // TODO(johnlenz): Support replace this with a value.\n            if (cArg == null || !cArg.isThis()) {\n                return CanInlineResult.NO;\n            }\n            cArg = cArg.getNext();\n        } else {\n            // \".apply\" call should be filtered before this.\n            Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n        }\n    }\n    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]\n    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n    while (cArg != null || fnParam != null) {\n        // For each named parameter check if a mutable argument use more than one.\n        if (fnParam != null) {\n            if (cArg != null) {\n                // parameter reference will be in a loop.\n                if (NodeUtil.mayEffectMutableState(cArg, compiler) && NodeUtil.getNameReferenceCount(block, fnParam.getString()) > 1) {\n                    return CanInlineResult.NO;\n                }\n            }\n            // Move to the next name.\n            fnParam = fnParam.getNext();\n        }\n        // isn't a named parameter to match.\n        if (cArg != null) {\n            if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n                return CanInlineResult.NO;\n            }\n            cArg = cArg.getNext();\n        }\n    }\n    return CanInlineResult.YES;\n}", "code_comment": "/**\n * Determines whether a function can be inlined at a particular call site.\n * There are several criteria that the function and reference must hold in\n * order for the functions to be inlined:\n * 1) If a call's arguments have side effects,\n * the corresponding argument in the function must only be referenced once.\n * For instance, this will not be inlined:\n * <pre>\n *     function foo(a) { return a + a }\n *     x = foo(i++);\n * </pre>\n */\n", "code_no_comment": "private CanInlineResult canInlineReferenceDirectly(Node callNode, Node fnNode) {\n    if (!isDirectCallNodeReplacementPossible(fnNode)) {\n        return CanInlineResult.NO;\n    }\n    Node block = fnNode.getLastChild();\n        Node cArg = callNode.getFirstChild().getNext();\n        if (!callNode.getFirstChild().isName()) {\n        if (NodeUtil.isFunctionObjectCall(callNode)) {\n                        if (cArg == null || !cArg.isThis()) {\n                return CanInlineResult.NO;\n            }\n            cArg = cArg.getNext();\n        } else {\n                        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n        }\n    }\n        Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n    while (cArg != null || fnParam != null) {\n                if (fnParam != null) {\n            if (cArg != null) {\n                                if (NodeUtil.mayEffectMutableState(cArg, compiler) && NodeUtil.getNameReferenceCount(block, fnParam.getString()) > 1) {\n                    return CanInlineResult.NO;\n                }\n            }\n                        fnParam = fnParam.getNext();\n        }\n                if (cArg != null) {\n            if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n                return CanInlineResult.NO;\n            }\n            cArg = cArg.getNext();\n        }\n    }\n    return CanInlineResult.YES;\n}", "lc": 0.9545454545454546, "pi": 0.8947368421052633, "ma": 1.4, "nbd": 1.0, "ml": 1.8333333333333333, "d": 1.2619047619047619, "mi": -0.6372093023255814, "fo": 1.0833333333333333, "r": -0.02631578947368421, "e": 1.8460192596946798}
{"project_name": "Compress", "project_version": 43, "label": 3, "code": "private void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {\n    final boolean encodable = zipEncoding.canEncode(ze.getName());\n    final ByteBuffer name = getName(ze);\n    if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n        addUnicodeExtraFields(ze, encodable, name);\n    }\n    final long localHeaderStart = streamCompressor.getTotalBytesWritten();\n    final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n    metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\n    // At crc offset\n    entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET;\n    writeCounted(localHeader);\n    entry.dataStart = streamCompressor.getTotalBytesWritten();\n}", "code_comment": NaN, "code_no_comment": "private void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {\n    final boolean encodable = zipEncoding.canEncode(ze.getName());\n    final ByteBuffer name = getName(ze);\n    if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n        addUnicodeExtraFields(ze, encodable, name);\n    }\n    final long localHeaderStart = streamCompressor.getTotalBytesWritten();\n    final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n    metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\n        entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET;\n    writeCounted(localHeader);\n    entry.dataStart = streamCompressor.getTotalBytesWritten();\n}", "lc": -0.045454545454545456, "pi": -0.5215311004784691, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": -0.04563492063492063, "mi": -0.04045102184637074, "fo": 0.4166666666666667, "r": -0.02631578947368421, "e": 0.056621888740973805}
{"project_name": "Closure", "project_version": 153, "label": 2, "code": "private void scanRoot(Node n, Scope parent) {\n    if (n.getType() == Token.FUNCTION) {\n        sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n        final Node fnNameNode = n.getFirstChild();\n        final Node args = fnNameNode.getNext();\n        final Node body = args.getNext();\n        // Bleed the function name into the scope, if it hasn't\n        // been declared in the outer scope.\n        String fnName = fnNameNode.getString();\n        if (!fnName.isEmpty() && NodeUtil.isFunctionExpression(n)) {\n            declareVar(fnName, fnNameNode, n, null, null, n);\n        }\n        // Args: Declare function variables\n        Preconditions.checkState(args.getType() == Token.LP);\n        for (Node a = args.getFirstChild(); a != null; a = a.getNext()) {\n            Preconditions.checkState(a.getType() == Token.NAME);\n            declareVar(a.getString(), a, args, n, null, n);\n        }\n        // Body\n        scanVars(body, n);\n    } else {\n        // It's the global block\n        Preconditions.checkState(scope.getParent() == null);\n        scanVars(n, null);\n    }\n}", "code_comment": NaN, "code_no_comment": "private void scanRoot(Node n, Scope parent) {\n    if (n.getType() == Token.FUNCTION) {\n        sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n        final Node fnNameNode = n.getFirstChild();\n        final Node args = fnNameNode.getNext();\n        final Node body = args.getNext();\n                        String fnName = fnNameNode.getString();\n        if (!fnName.isEmpty() && NodeUtil.isFunctionExpression(n)) {\n            declareVar(fnName, fnNameNode, n, null, null, n);\n        }\n                Preconditions.checkState(args.getType() == Token.LP);\n        for (Node a = args.getFirstChild(); a != null; a = a.getNext()) {\n            Preconditions.checkState(a.getType() == Token.NAME);\n            declareVar(a.getString(), a, args, n, null, n);\n        }\n                scanVars(body, n);\n    } else {\n                Preconditions.checkState(scope.getParent() == null);\n        scanVars(n, null);\n    }\n}", "lc": 0.3181818181818182, "pi": 0.09090909090909088, "ma": 0.0, "nbd": 0.0, "ml": 0.3333333333333333, "d": 0.6448412698412699, "mi": -0.35362931642001405, "fo": 1.25, "r": -0.02631578947368421, "e": 1.0443042132743208}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5476_813d8bee", "label": 3, "code": "/**\n *  @see Component#onComponentTag(ComponentTag)\n *  @param tag\n *             the abstraction representing html tag of this component\n */\n@Override\nprotected void onComponentTag(final ComponentTag tag) {\n    // Default handling for component tag\n    super.onComponentTag(tag);\n    // must be attached to <input type=\"checkbox\" .../> tag\n    checkComponentTag(tag, \"input\");\n    checkComponentTagAttribute(tag, \"type\", \"checkbox\");\n    CheckGroup<?> group = getGroup();\n    final String uuid = getValue();\n    // assign name and value\n    tag.put(\"name\", group.getInputName());\n    tag.put(\"value\", uuid);\n    // check if the model collection of the group contains the model object.\n    // if it does check the check box.\n    Collection<?> collection = (Collection<?>) group.getDefaultModelObject();\n    // check for npe in group's model object\n    if (collection == null) {\n        throw new WicketRuntimeException(\"CheckGroup [\" + group.getPath() + \"] contains a null model object, must be an object of type java.util.Collection\");\n    }\n    if (group.hasRawInput()) {\n        final String raw = group.getRawInput();\n        if (!Strings.isEmpty(raw)) {\n            final String[] values = raw.split(FormComponent.VALUE_SEPARATOR);\n            for (String value : values) {\n                if (uuid.equals(value)) {\n                    tag.put(\"checked\", \"checked\");\n                }\n            }\n        }\n    } else if (collection.contains(getDefaultModelObject())) {\n        tag.put(\"checked\", \"checked\");\n    }\n    if (group.wantOnSelectionChangedNotifications()) {\n        // url that points to this components IOnChangeListener method\n        CharSequence url = group.urlFor(IOnChangeListener.INTERFACE, new PageParameters());\n        Form<?> form = group.findParent(Form.class);\n        if (form != null) {\n            tag.put(\"onclick\", form.getJsForInterfaceUrl(url));\n        } else {\n            // NOTE: do not encode the url as that would give invalid JavaScript\n            tag.put(\"onclick\", \"window.location.href='\" + url + (url.toString().indexOf('?') > -1 ? \"&\" : \"?\") + group.getInputName() + \"=' + this.value;\");\n        }\n    }\n    if (!isActionAuthorized(ENABLE) || !isEnabledInHierarchy() || !group.isEnabledInHierarchy()) {\n        tag.put(ATTR_DISABLED, ATTR_DISABLED);\n    }\n    // put group id into the class so we can easily identify all radios belonging to the group\n    final String marker = \"wicket-\" + getGroup().getMarkupId();\n    String clazz = tag.getAttribute(\"class\");\n    if (Strings.isEmpty(clazz)) {\n        clazz = marker;\n    } else {\n        clazz = clazz + \" \" + marker;\n    }\n    tag.put(\"class\", clazz);\n}", "code_comment": "/**\n *  @see Component#onComponentTag(ComponentTag)\n *  @param tag\n *             the abstraction representing html tag of this component\n */\n", "code_no_comment": "@Override\nprotected void onComponentTag(final ComponentTag tag) {\n        super.onComponentTag(tag);\n        checkComponentTag(tag, \"input\");\n    checkComponentTagAttribute(tag, \"type\", \"checkbox\");\n    CheckGroup<?> group = getGroup();\n    final String uuid = getValue();\n        tag.put(\"name\", group.getInputName());\n    tag.put(\"value\", uuid);\n            Collection<?> collection = (Collection<?>) group.getDefaultModelObject();\n        if (collection == null) {\n        throw new WicketRuntimeException(\"CheckGroup [\" + group.getPath() + \"] contains a null model object, must be an object of type java.util.Collection\");\n    }\n    if (group.hasRawInput()) {\n        final String raw = group.getRawInput();\n        if (!Strings.isEmpty(raw)) {\n            final String[] values = raw.split(FormComponent.VALUE_SEPARATOR);\n            for (String value : values) {\n                if (uuid.equals(value)) {\n                    tag.put(\"checked\", \"checked\");\n                }\n            }\n        }\n    } else if (collection.contains(getDefaultModelObject())) {\n        tag.put(\"checked\", \"checked\");\n    }\n    if (group.wantOnSelectionChangedNotifications()) {\n                CharSequence url = group.urlFor(IOnChangeListener.INTERFACE, new PageParameters());\n        Form<?> form = group.findParent(Form.class);\n        if (form != null) {\n            tag.put(\"onclick\", form.getJsForInterfaceUrl(url));\n        } else {\n                        tag.put(\"onclick\", \"window.location.href='\" + url + (url.toString().indexOf('?') > -1 ? \"&\" : \"?\") + group.getInputName() + \"=' + this.value;\");\n        }\n    }\n    if (!isActionAuthorized(ENABLE) || !isEnabledInHierarchy() || !group.isEnabledInHierarchy()) {\n        tag.put(ATTR_DISABLED, ATTR_DISABLED);\n    }\n        final String marker = \"wicket-\" + getGroup().getMarkupId();\n    String clazz = tag.getAttribute(\"class\");\n    if (Strings.isEmpty(clazz)) {\n        clazz = marker;\n    } else {\n        clazz = clazz + \" \" + marker;\n    }\n    tag.put(\"class\", clazz);\n}", "lc": 1.5, "pi": 0.5598086124401914, "ma": 1.8, "nbd": 1.0, "ml": 1.9166666666666667, "d": 1.2440476190476188, "mi": -0.8835799859055671, "fo": 2.5833333333333335, "r": -0.02631578947368421, "e": 3.740440172196193}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4658_ef3adb12", "label": 3, "code": "@Override\npublic boolean isVisible() {\n    return getTabs().get(tabIndex).isVisible();\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean isVisible() {\n    return getTabs().get(tabIndex).isVisible();\n}", "lc": -0.45454545454545453, "pi": -0.6028708133971293, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.9134601832276249, "fo": -0.25, "r": 1.3947368421052633, "e": -0.16279340490885932}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-428_4a6a573b", "label": 3, "code": "/**\n *  @see java.util.Map#keySet()\n */\npublic Set keySet() {\n    return new AbstractSet() {\n\n        public Iterator iterator() {\n            return new Iterator() {\n\n                public boolean hasNext() {\n                    return i < size;\n                }\n\n                public Object next() {\n                    // Find next key\n                    i = nextKey(nextIndex(i));\n                    // Just in case... (WICKET-428)\n                    if (!hasNext()) {\n                        throw new NoSuchElementException();\n                    }\n                    // Get key\n                    return keys[i];\n                }\n\n                public void remove() {\n                    keys[i] = null;\n                    values[i] = null;\n                    size--;\n                }\n\n                int i = -1;\n            };\n        }\n\n        public int size() {\n            return size;\n        }\n    };\n}", "code_comment": "/**\n *  @see java.util.Map#keySet()\n */\n", "code_no_comment": "public Set keySet() {\n    return new AbstractSet() {\n\n        public Iterator iterator() {\n            return new Iterator() {\n\n                public boolean hasNext() {\n                    return i < size;\n                }\n\n                public Object next() {\n                                        i = nextKey(nextIndex(i));\n                                        if (!hasNext()) {\n                        throw new NoSuchElementException();\n                    }\n                                        return keys[i];\n                }\n\n                public void remove() {\n                    keys[i] = null;\n                    values[i] = null;\n                    size--;\n                }\n\n                int i = -1;\n            };\n        }\n\n        public int size() {\n            return size;\n        }\n    };\n}", "lc": 0.5909090909090909, "pi": 1.708133971291866, "ma": -0.2, "nbd": 0.5, "ml": -0.25, "d": 0.30357142857142855, "mi": -0.31078224101479923, "fo": -0.25, "r": 1.9210526315789473, "e": 0.12201494902693011}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2359_b3071839", "label": 0, "code": "/**\n * Get the earliest (oldest) revision where the node was alive at or before\n * the provided revision, if the node was alive at the given revision.\n *\n * @param context the revision context\n * @param maxRev the maximum revision to return\n * @param validRevisions the map of revisions to commit value already\n *                       checked against maxRev and considered valid.\n * @param lastRevs to keep track of the last modification.\n * @return the earliest revision, or null if the node is deleted at the\n *         given revision\n */\n@CheckForNull\npublic Revision getLiveRevision(RevisionContext context, Revision maxRev, Map<Revision, String> validRevisions, LastRevs lastRevs) {\n    // check local deleted map first\n    Value value = getLatestValue(context, getLocalDeleted(), null, maxRev, validRevisions, lastRevs);\n    if (value == null && !getPreviousRanges().isEmpty()) {\n        // need to check complete map\n        value = getLatestValue(context, getDeleted(), null, maxRev, validRevisions, lastRevs);\n    }\n    return value != null && \"false\".equals(value.value) ? value.revision : null;\n}", "code_comment": "/**\n * Get the earliest (oldest) revision where the node was alive at or before\n * the provided revision, if the node was alive at the given revision.\n *\n * @param context the revision context\n * @param maxRev the maximum revision to return\n * @param validRevisions the map of revisions to commit value already\n *                       checked against maxRev and considered valid.\n * @param lastRevs to keep track of the last modification.\n * @return the earliest revision, or null if the node is deleted at the\n *         given revision\n */\n", "code_no_comment": "@CheckForNull\npublic Revision getLiveRevision(RevisionContext context, Revision maxRev, Map<Revision, String> validRevisions, LastRevs lastRevs) {\n        Value value = getLatestValue(context, getLocalDeleted(), null, maxRev, validRevisions, lastRevs);\n    if (value == null && !getPreviousRanges().isEmpty()) {\n                value = getLatestValue(context, getDeleted(), null, maxRev, validRevisions, lastRevs);\n    }\n    return value != null && \"false\".equals(value.value) ? value.revision : null;\n}", "lc": -0.2727272727272727, "pi": -0.16267942583732073, "ma": -0.2, "nbd": -0.5, "ml": 0.25, "d": 0.3948412698412698, "mi": 0.20197322057787187, "fo": 0.08333333333333333, "r": -0.02631578947368421, "e": 0.26968413409173414}
{"project_name": "Lang", "project_version": 3, "label": 3, "code": "// -----------------------------------------------------------------------\n// must handle Long, Float, Integer, Float, Short,\n// BigDecimal, BigInteger and Byte\n// useful methods:\n// Byte.decode(String)\n// Byte.valueOf(String,int radix)\n// Byte.valueOf(String)\n// Double.valueOf(String)\n// Float.valueOf(String)\n// Float.valueOf(String)\n// Integer.valueOf(String,int radix)\n// Integer.valueOf(String)\n// Integer.decode(String)\n// Integer.getInteger(String)\n// Integer.getInteger(String,int val)\n// Integer.getInteger(String,Integer val)\n// Integer.valueOf(String)\n// Double.valueOf(String)\n// new Byte(String)\n// Long.valueOf(String)\n// Long.getLong(String)\n// Long.getLong(String,int)\n// Long.getLong(String,Integer)\n// Long.valueOf(String,int)\n// Long.valueOf(String)\n// Short.valueOf(String)\n// Short.decode(String)\n// Short.valueOf(String,int)\n// Short.valueOf(String)\n// new BigDecimal(String)\n// new BigInteger(String)\n// new BigInteger(String,int radix)\n// Possible inputs:\n// 45 45.5 45E7 4.5E7 Hex Oct Binary xxxF xxxD xxxf xxxd\n// plus minus everything. Prolly more. A lot are not separable.\n/**\n * <p>Turns a string value into a java.lang.Number.</p>\n *\n * <p>If the string starts with {@code 0x} or {@code -0x} (lower or upper case) or {@code #} or {@code -#}, it\n * will be interpreted as a hexadecimal Integer - or Long, if the number of digits after the\n * prefix is more than 8 - or BigInteger if there are more than 16 digits.\n * </p>\n * <p>Then, the value is examined for a type qualifier on the end, i.e. one of\n * <code>'f','F','d','D','l','L'</code>.  If it is found, it starts\n * trying to create successively larger types from the type specified\n * until one is found that can represent the value.</p>\n *\n * <p>If a type specifier is not found, it will check for a decimal point\n * and then try successively larger types from <code>Integer</code> to\n * <code>BigInteger</code> and from <code>Float</code> to\n * <code>BigDecimal</code>.</p>\n *\n * <p>\n * Integral values with a leading {@code 0} will be interpreted as octal; the returned number will\n * be Integer, Long or BigDecimal as appropriate.\n * </p>\n *\n * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n *\n * <p>This method does not trim the input string, i.e., strings with leading\n * or trailing spaces will generate NumberFormatExceptions.</p>\n *\n * @param str  String containing a number, may be null\n * @return Number created from the string (or null if the input is null)\n * @throws NumberFormatException if the value cannot be converted\n */\npublic static Number createNumber(final String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    // Need to deal with all possible hex prefixes here\n    final String[] hex_prefixes = { \"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\" };\n    int pfxLen = 0;\n    for (final String pfx : hex_prefixes) {\n        if (str.startsWith(pfx)) {\n            pfxLen += pfx.length();\n            break;\n        }\n    }\n    if (pfxLen > 0) {\n        // we have a hex number\n        final int hexDigits = str.length() - pfxLen;\n        if (hexDigits > 16) {\n            // too many for Long\n            return createBigInteger(str);\n        }\n        if (hexDigits > 8) {\n            // too many for an int\n            return createLong(str);\n        }\n        return createInteger(str);\n    }\n    final char lastChar = str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    final int decPos = str.indexOf('.');\n    // assumes both not present\n    final int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n    // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n    // and the parsing which will detect if e or E appear in a number due to using the wrong offset\n    // Check required precision (LANG-693)\n    int numDecimals = 0;\n    if (decPos > -1) {\n        if (expPos > -1) {\n            // there is an exponent\n            if (expPos < decPos || expPos > str.length()) {\n                // prevents double exponent causing IOOBE\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec = str.substring(decPos + 1, expPos);\n        } else {\n            dec = str.substring(decPos + 1);\n        }\n        mant = str.substring(0, decPos);\n        // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.\n        numDecimals = dec.length();\n    } else {\n        if (expPos > -1) {\n            if (expPos > str.length()) {\n                // prevents double exponent causing IOOBE\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            mant = str.substring(0, expPos);\n        } else {\n            mant = str;\n        }\n        dec = null;\n    }\n    if (!Character.isDigit(lastChar) && lastChar != '.') {\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp = null;\n        }\n        // Requesting a specific type..\n        final String numeric = str.substring(0, str.length() - 1);\n        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        switch(lastChar) {\n            case 'l':\n            case 'L':\n                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (final NumberFormatException nfe) {\n                    // NOPMD\n                    // Too big for a long\n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case 'f':\n            case 'F':\n                try {\n                    final Float f = NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        // has non-zeros in it, then float does not have the precision we want\n                        return f;\n                    }\n                } catch (final NumberFormatException nfe) {\n                // NOPMD\n                // ignore the bad number\n                }\n            // $FALL-THROUGH$\n            case 'd':\n            case 'D':\n                try {\n                    final Double d = NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (final NumberFormatException nfe) {\n                // NOPMD\n                // ignore the bad number\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (final NumberFormatException e) {\n                // NOPMD\n                // ignore the bad number\n                }\n            // $FALL-THROUGH$\n            default:\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    }\n    // small and go from there...\n    if (expPos > -1 && expPos < str.length() - 1) {\n        exp = str.substring(expPos + 1, str.length());\n    } else {\n        exp = null;\n    }\n    if (dec == null && exp == null) {\n        // Must be an Integer, Long, Biginteger\n        try {\n            return createInteger(str);\n        } catch (final NumberFormatException nfe) {\n        // NOPMD\n        // ignore the bad number\n        }\n        try {\n            return createLong(str);\n        } catch (final NumberFormatException nfe) {\n        // NOPMD\n        // ignore the bad number\n        }\n        return createBigInteger(str);\n    }\n    // Must be a Float, Double, BigDecimal\n    final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n    try {\n        final Float f = createFloat(str);\n        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n            return f;\n        }\n    } catch (final NumberFormatException nfe) {\n    // NOPMD\n    // ignore the bad number\n    }\n    try {\n        final Double d = createDouble(str);\n        if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n            return d;\n        }\n    } catch (final NumberFormatException nfe) {\n    // NOPMD\n    // ignore the bad number\n    }\n    return createBigDecimal(str);\n}", "code_comment": "/**\n * <p>Turns a string value into a java.lang.Number.</p>\n *\n * <p>If the string starts with {@code 0x} or {@code -0x} (lower or upper case) or {@code #} or {@code -#}, it\n * will be interpreted as a hexadecimal Integer - or Long, if the number of digits after the\n * prefix is more than 8 - or BigInteger if there are more than 16 digits.\n * </p>\n * <p>Then, the value is examined for a type qualifier on the end, i.e. one of\n * <code>'f','F','d','D','l','L'</code>.  If it is found, it starts\n * trying to create successively larger types from the type specified\n * until one is found that can represent the value.</p>\n *\n * <p>If a type specifier is not found, it will check for a decimal point\n * and then try successively larger types from <code>Integer</code> to\n * <code>BigInteger</code> and from <code>Float</code> to\n * <code>BigDecimal</code>.</p>\n *\n * <p>\n * Integral values with a leading {@code 0} will be interpreted as octal; the returned number will\n * be Integer, Long or BigDecimal as appropriate.\n * </p>\n *\n * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n *\n * <p>This method does not trim the input string, i.e., strings with leading\n * or trailing spaces will generate NumberFormatExceptions.</p>\n *\n * @param str  String containing a number, may be null\n * @return Number created from the string (or null if the input is null)\n * @throws NumberFormatException if the value cannot be converted\n */\n", "code_no_comment": "public static Number createNumber(final String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n        final String[] hex_prefixes = { \"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\" };\n    int pfxLen = 0;\n    for (final String pfx : hex_prefixes) {\n        if (str.startsWith(pfx)) {\n            pfxLen += pfx.length();\n            break;\n        }\n    }\n    if (pfxLen > 0) {\n                final int hexDigits = str.length() - pfxLen;\n        if (hexDigits > 16) {\n                        return createBigInteger(str);\n        }\n        if (hexDigits > 8) {\n                        return createLong(str);\n        }\n        return createInteger(str);\n    }\n    final char lastChar = str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    final int decPos = str.indexOf('.');\n        final int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n                int numDecimals = 0;\n    if (decPos > -1) {\n        if (expPos > -1) {\n                        if (expPos < decPos || expPos > str.length()) {\n                                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec = str.substring(decPos + 1, expPos);\n        } else {\n            dec = str.substring(decPos + 1);\n        }\n        mant = str.substring(0, decPos);\n                numDecimals = dec.length();\n    } else {\n        if (expPos > -1) {\n            if (expPos > str.length()) {\n                                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            mant = str.substring(0, expPos);\n        } else {\n            mant = str;\n        }\n        dec = null;\n    }\n    if (!Character.isDigit(lastChar) && lastChar != '.') {\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp = null;\n        }\n                final String numeric = str.substring(0, str.length() - 1);\n        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        switch(lastChar) {\n            case 'l':\n            case 'L':\n                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (final NumberFormatException nfe) {\n                                                            }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case 'f':\n            case 'F':\n                try {\n                    final Float f = NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                                                return f;\n                    }\n                } catch (final NumberFormatException nfe) {\n                                                }\n                        case 'd':\n            case 'D':\n                try {\n                    final Double d = NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (final NumberFormatException nfe) {\n                                                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (final NumberFormatException e) {\n                                                }\n                        default:\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    }\n        if (expPos > -1 && expPos < str.length() - 1) {\n        exp = str.substring(expPos + 1, str.length());\n    } else {\n        exp = null;\n    }\n    if (dec == null && exp == null) {\n                try {\n            return createInteger(str);\n        } catch (final NumberFormatException nfe) {\n                        }\n        try {\n            return createLong(str);\n        } catch (final NumberFormatException nfe) {\n                        }\n        return createBigInteger(str);\n    }\n        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n    try {\n        final Float f = createFloat(str);\n        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n            return f;\n        }\n    } catch (final NumberFormatException nfe) {\n            }\n    try {\n        final Double d = createDouble(str);\n        if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n            return d;\n        }\n    } catch (final NumberFormatException nfe) {\n            }\n    return createBigDecimal(str);\n}", "lc": 5.363636363636363, "pi": 1.1866028708133969, "ma": 7.8, "nbd": 1.5, "ml": 5.166666666666667, "d": 3.7777777777777777, "mi": -1.6723044397462996, "fo": 4.083333333333333, "r": -0.02631578947368421, "e": 23.020590930308945}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1225_3535afe2", "label": 1, "code": "/**\n * Returns the property at the specified absolute path in the workspace or\n * {@code null} if no such node exists.\n *\n * @param absPath An absolute path.\n * @return the specified {@code Property} or {@code null}.\n * @throws RepositoryException if another error occurs.\n */\n@CheckForNull\npublic Property getPropertyOrNull(final String absPath) throws RepositoryException {\n    if (absPath.equals(\"/\")) {\n        return null;\n    } else {\n        final String oakPath = getOakPathOrThrow(absPath);\n        return perform(new ReadOperation<Property>() {\n\n            @Override\n            public Property perform() throws RepositoryException {\n                PropertyDelegate pd = sd.getProperty(oakPath);\n                if (pd != null) {\n                    return new PropertyImpl(pd, sessionContext);\n                } else {\n                    return null;\n                }\n            }\n        });\n    }\n}", "code_comment": "/**\n * Returns the property at the specified absolute path in the workspace or\n * {@code null} if no such node exists.\n *\n * @param absPath An absolute path.\n * @return the specified {@code Property} or {@code null}.\n * @throws RepositoryException if another error occurs.\n */\n", "code_no_comment": "@CheckForNull\npublic Property getPropertyOrNull(final String absPath) throws RepositoryException {\n    if (absPath.equals(\"/\")) {\n        return null;\n    } else {\n        final String oakPath = getOakPathOrThrow(absPath);\n        return perform(new ReadOperation<Property>() {\n\n            @Override\n            public Property perform() throws RepositoryException {\n                PropertyDelegate pd = sd.getProperty(oakPath);\n                if (pd != null) {\n                    return new PropertyImpl(pd, sessionContext);\n                } else {\n                    return null;\n                }\n            }\n        });\n    }\n}", "lc": 0.22727272727272727, "pi": 1.6315789473684212, "ma": -0.2, "nbd": 0.5, "ml": -0.08333333333333333, "d": -0.053571428571428575, "mi": -0.13291050035236088, "fo": -0.16666666666666666, "r": 0.8421052631578947, "e": -0.04481480841156504}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-1978_0078c44e", "label": 1, "code": "@Override\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\npublic T copy(T from, T reuse) {\n    if (from == null) {\n        return null;\n    }\n    Class<?> actualType = from.getClass();\n    if (reuse == null || actualType != reuse.getClass()) {\n        // cannot reuse, do a non-reuse copy\n        return copy(from);\n    }\n    if (actualType == clazz) {\n        try {\n            for (int i = 0; i < numFields; i++) {\n                Object value = fields[i].get(from);\n                if (value != null) {\n                    Object copy = fieldSerializers[i].copy(fields[i].get(from), fields[i].get(reuse));\n                    fields[i].set(reuse, copy);\n                } else {\n                    fields[i].set(reuse, null);\n                }\n            }\n        } catch (IllegalAccessException e) {\n            throw new RuntimeException(\"Error during POJO copy, this should not happen since we check the fields\" + \"before.\");\n        }\n    } else {\n        TypeSerializer subclassSerializer = getSubclassSerializer(actualType);\n        reuse = (T) subclassSerializer.copy(from, reuse);\n    }\n    return reuse;\n}", "code_comment": NaN, "code_no_comment": "@Override\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\npublic T copy(T from, T reuse) {\n    if (from == null) {\n        return null;\n    }\n    Class<?> actualType = from.getClass();\n    if (reuse == null || actualType != reuse.getClass()) {\n                return copy(from);\n    }\n    if (actualType == clazz) {\n        try {\n            for (int i = 0; i < numFields; i++) {\n                Object value = fields[i].get(from);\n                if (value != null) {\n                    Object copy = fieldSerializers[i].copy(fields[i].get(from), fields[i].get(reuse));\n                    fields[i].set(reuse, copy);\n                } else {\n                    fields[i].set(reuse, null);\n                }\n            }\n        } catch (IllegalAccessException e) {\n            throw new RuntimeException(\"Error during POJO copy, this should not happen since we check the fields\" + \"before.\");\n        }\n    } else {\n        TypeSerializer subclassSerializer = getSubclassSerializer(actualType);\n        reuse = (T) subclassSerializer.copy(from, reuse);\n    }\n    return reuse;\n}", "lc": 0.7272727272727273, "pi": 1.5071770334928227, "ma": 0.8, "nbd": 1.0, "ml": 0.75, "d": 1.152777777777778, "mi": -0.5365750528541224, "fo": 0.4166666666666667, "r": -0.02631578947368421, "e": 1.5759501622263328}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5071_faaae8d3", "label": 1, "code": "/**\n *  Matches when the request url starts with\n *  {@link org.apache.wicket.core.request.mapper.IMapperContext#getNamespace()}/{@link org.apache.wicket.core.request.mapper.IMapperContext#getPageIdentifier()}\n *  or when the base url starts with\n *  {@link org.apache.wicket.core.request.mapper.IMapperContext#getNamespace()}/{@link org.apache.wicket.core.request.mapper.IMapperContext#getPageIdentifier()}\n *  and the request url with {@link org.apache.wicket.core.request.mapper.IMapperContext#getPageIdentifier()}\n *\n *  @param request\n *       the request to check\n *  @return {@code true} if the conditions match\n */\nprivate boolean matches(final Request request) {\n    boolean matches = false;\n    Url url = request.getUrl();\n    String namespace = getContext().getNamespace();\n    String pageIdentifier = getContext().getPageIdentifier();\n    if (urlStartsWith(url, namespace, pageIdentifier)) {\n        matches = true;\n    } else if (urlStartsWith(request.getClientUrl(), namespace, pageIdentifier) && urlStartsWith(url, pageIdentifier)) {\n        matches = true;\n    } else if (urlStartsWith(request.getClientUrl(), pageIdentifier) && urlStartsWith(url, pageIdentifier)) {\n        matches = true;\n    }\n    return matches;\n}", "code_comment": "/**\n *  Matches when the request url starts with\n *  {@link org.apache.wicket.core.request.mapper.IMapperContext#getNamespace()}/{@link org.apache.wicket.core.request.mapper.IMapperContext#getPageIdentifier()}\n *  or when the base url starts with\n *  {@link org.apache.wicket.core.request.mapper.IMapperContext#getNamespace()}/{@link org.apache.wicket.core.request.mapper.IMapperContext#getPageIdentifier()}\n *  and the request url with {@link org.apache.wicket.core.request.mapper.IMapperContext#getPageIdentifier()}\n *\n *  @param request\n *       the request to check\n *  @return {@code true} if the conditions match\n */\n", "code_no_comment": "private boolean matches(final Request request) {\n    boolean matches = false;\n    Url url = request.getUrl();\n    String namespace = getContext().getNamespace();\n    String pageIdentifier = getContext().getPageIdentifier();\n    if (urlStartsWith(url, namespace, pageIdentifier)) {\n        matches = true;\n    } else if (urlStartsWith(request.getClientUrl(), namespace, pageIdentifier) && urlStartsWith(url, pageIdentifier)) {\n        matches = true;\n    } else if (urlStartsWith(request.getClientUrl(), pageIdentifier) && urlStartsWith(url, pageIdentifier)) {\n        matches = true;\n    }\n    return matches;\n}", "lc": 0.0, "pi": -0.29665071770334933, "ma": 0.0, "nbd": 0.5, "ml": 0.6666666666666666, "d": 0.14880952380952375, "mi": -0.047498238195912666, "fo": 0.5, "r": -0.02631578947368421, "e": 0.10586031822870742}