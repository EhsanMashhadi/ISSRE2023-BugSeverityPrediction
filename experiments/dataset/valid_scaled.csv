project_name,project_version,label,code,code_comment,code_no_comment,lc,pi,ma,nbd,ml,d,mi,fo,r,e
commons-math,remotes/origin/bugs-dot-jar_MATH-369_f4a4464b,3,"/**
 * {@inheritDoc}
 */
public double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException {
    return solve(min, max);
}","/**
 * {@inheritDoc}
 */
","public double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException {
    return solve(min, max);
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.9360112755461594,-0.4166666666666667,1.9736842105263157,-0.16279340490885932
Closure,56,2,"/**
 * Gets the source line for the indicated line number.
 *
 * @param lineNumber the line number, 1 being the first line of the file.
 * @return The line indicated. Does not include the newline at the end
 *     of the file. Returns {@code null} if it does not exist,
 *     or if there was an IO exception.
 */
public String getLine(int lineNumber) {
    String js = """";
    try {
        // NOTE(nicksantos): Right now, this is optimized for few warnings.
        // This is probably the right trade-off, but will be slow if there
        // are lots of warnings in one file.
        js = getCode();
    } catch (IOException e) {
        return null;
    }
    int pos = 0;
    int startLine = 1;
    // one we're searching for, then start at that point.
    if (lineNumber >= lastLine) {
        pos = lastOffset;
        startLine = lastLine;
    }
    for (int n = startLine; n < lineNumber; n++) {
        int nextpos = js.indexOf('\n', pos);
        if (nextpos == -1) {
            return null;
        }
        pos = nextpos + 1;
    }
    // Remember this offset for the next search we do.
    lastOffset = pos;
    lastLine = lineNumber;
    if (js.indexOf('\n', pos) == -1) {
        // 2. otherwise, return the contents between pos and the end of file.
        return null;
    } else {
        return js.substring(pos, js.indexOf('\n', pos));
    }
}","/**
 * Gets the source line for the indicated line number.
 *
 * @param lineNumber the line number, 1 being the first line of the file.
 * @return The line indicated. Does not include the newline at the end
 *     of the file. Returns {@code null} if it does not exist,
 *     or if there was an IO exception.
 */
","public String getLine(int lineNumber) {
    String js = """";
    try {
                                js = getCode();
    } catch (IOException e) {
        return null;
    }
    int pos = 0;
    int startLine = 1;
        if (lineNumber >= lastLine) {
        pos = lastOffset;
        startLine = lastLine;
    }
    for (int n = startLine; n < lineNumber; n++) {
        int nextpos = js.indexOf('\n', pos);
        if (nextpos == -1) {
            return null;
        }
        pos = nextpos + 1;
    }
        lastOffset = pos;
    lastLine = lineNumber;
    if (js.indexOf('\n', pos) == -1) {
                return null;
    } else {
        return js.substring(pos, js.indexOf('\n', pos));
    }
}",0.6363636363636364,-0.1578947368421053,0.4,0.0,0.4166666666666667,1.1944444444444444,-0.44411557434813226,-0.08333333333333333,-0.02631578947368421,1.1258565146983395
wicket,remotes/origin/bugs-dot-jar_WICKET-4138_7c89598a,1,"@Override
public boolean shouldPreserveClientUrl() {
    return errorAttributes != null && !Strings.isEmpty(errorAttributes.getRequestUri());
}",,"@Override
public boolean shouldPreserveClientUrl() {
    return errorAttributes != null && !Strings.isEmpty(errorAttributes.getRequestUri());
}",-0.45454545454545453,-0.6028708133971293,-0.6,-1.0,-0.4166666666666667,-0.14285714285714285,0.791966173361522,-0.3333333333333333,1.4210526315789473,-0.14126311785757506
Closure,39,2,"@Override
String toStringHelper(boolean forAnnotations) {
    if (hasReferenceName()) {
        return getReferenceName();
    } else if (prettyPrint) {
        // Don't pretty print recursively.
        prettyPrint = false;
        // Use a tree set so that the properties are sorted.
        Set<String> propertyNames = Sets.newTreeSet();
        for (ObjectType current = this; current != null && !current.isNativeObjectType() && propertyNames.size() <= MAX_PRETTY_PRINTED_PROPERTIES; current = current.getImplicitPrototype()) {
            propertyNames.addAll(current.getOwnPropertyNames());
        }
        StringBuilder sb = new StringBuilder();
        sb.append(""{"");
        int i = 0;
        for (String property : propertyNames) {
            if (i > 0) {
                sb.append("", "");
            }
            sb.append(property);
            sb.append("": "");
            sb.append(getPropertyType(property).toString());
            ++i;
            if (i == MAX_PRETTY_PRINTED_PROPERTIES) {
                sb.append("", ..."");
                break;
            }
        }
        sb.append(""}"");
        prettyPrint = true;
        return sb.toString();
    } else {
        return ""{...}"";
    }
}",,"@Override
String toStringHelper(boolean forAnnotations) {
    if (hasReferenceName()) {
        return getReferenceName();
    } else if (prettyPrint) {
                prettyPrint = false;
                Set<String> propertyNames = Sets.newTreeSet();
        for (ObjectType current = this; current != null && !current.isNativeObjectType() && propertyNames.size() <= MAX_PRETTY_PRINTED_PROPERTIES; current = current.getImplicitPrototype()) {
            propertyNames.addAll(current.getOwnPropertyNames());
        }
        StringBuilder sb = new StringBuilder();
        sb.append(""{"");
        int i = 0;
        for (String property : propertyNames) {
            if (i > 0) {
                sb.append("", "");
            }
            sb.append(property);
            sb.append("": "");
            sb.append(getPropertyType(property).toString());
            ++i;
            if (i == MAX_PRETTY_PRINTED_PROPERTIES) {
                sb.append("", ..."");
                break;
            }
        }
        sb.append(""}"");
        prettyPrint = true;
        return sb.toString();
    } else {
        return ""{...}"";
    }
}",0.8636363636363636,0.5741626794258374,0.8,1.0,0.6666666666666666,1.1785714285714286,-0.5751937984496123,1.0,-0.02631578947368421,1.551801202146113
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-621_00b4b8a0,1,"@Override
public Iterable<Tree> getChildren() {
    root.checkLive();
    Iterable<String> childNames;
    if (hasOrderableChildren()) {
        childNames = getOrderedChildNames();
    } else {
        childNames = getNodeBuilder().getChildNodeNames();
    }
    return Iterables.filter(Iterables.transform(childNames, new Function<String, Tree>() {

        @Override
        public Tree apply(String input) {
            return new TreeImpl(root, TreeImpl.this, input);
        }
    }), new Predicate<Tree>() {

        @Override
        public boolean apply(Tree tree) {
            return tree != null && canRead(tree);
        }
    });
}",,"@Override
public Iterable<Tree> getChildren() {
    root.checkLive();
    Iterable<String> childNames;
    if (hasOrderableChildren()) {
        childNames = getOrderedChildNames();
    } else {
        childNames = getNodeBuilder().getChildNodeNames();
    }
    return Iterables.filter(Iterables.transform(childNames, new Function<String, Tree>() {

        @Override
        public Tree apply(String input) {
            return new TreeImpl(root, TreeImpl.this, input);
        }
    }), new Predicate<Tree>() {

        @Override
        public boolean apply(Tree tree) {
            return tree != null && canRead(tree);
        }
    });
}",0.3181818181818182,0.1961722488038276,-0.4,-0.5,-0.25,-0.009920634920634929,-0.21860465116279051,0.16666666666666666,0.0,0.021804602271744935
camel,remotes/origin/bugs-dot-jar_CAMEL-3498_b4606700,1,"@SuppressWarnings(""unchecked"")
private Iterable<ProcessorExchangePair> createProcessorExchangePairsIterable(final Exchange exchange, final Object value) {
    final Iterator iterator = ObjectHelper.createIterator(value);
    return new Iterable() {

        public Iterator iterator() {
            return new Iterator() {

                private int index;

                private boolean closed;

                public boolean hasNext() {
                    if (closed) {
                        return false;
                    }
                    boolean answer = iterator.hasNext();
                    if (!answer) {
                        // we are now closed
                        closed = true;
                        // nothing more so we need to close the expression value in case it needs to be
                        if (value instanceof Closeable) {
                            IOHelper.close((Closeable) value, value.getClass().getName(), LOG);
                        } else if (value instanceof Scanner) {
                            // special for Scanner as it does not implement Closeable
                            ((Scanner) value).close();
                        }
                    }
                    return answer;
                }

                public Object next() {
                    Object part = iterator.next();
                    Exchange newExchange = ExchangeHelper.createCopy(exchange, true);
                    if (part instanceof Message) {
                        newExchange.setIn((Message) part);
                    } else {
                        Message in = newExchange.getIn();
                        in.setBody(part);
                    }
                    return createProcessorExchangePair(index++, getProcessors().iterator().next(), newExchange);
                }

                public void remove() {
                    throw new UnsupportedOperationException(""Remove is not supported by this iterator"");
                }
            };
        }
    };
}",,"@SuppressWarnings(""unchecked"")
private Iterable<ProcessorExchangePair> createProcessorExchangePairsIterable(final Exchange exchange, final Object value) {
    final Iterator iterator = ObjectHelper.createIterator(value);
    return new Iterable() {

        public Iterator iterator() {
            return new Iterator() {

                private int index;

                private boolean closed;

                public boolean hasNext() {
                    if (closed) {
                        return false;
                    }
                    boolean answer = iterator.hasNext();
                    if (!answer) {
                                                closed = true;
                                                if (value instanceof Closeable) {
                            IOHelper.close((Closeable) value, value.getClass().getName(), LOG);
                        } else if (value instanceof Scanner) {
                                                        ((Scanner) value).close();
                        }
                    }
                    return answer;
                }

                public Object next() {
                    Object part = iterator.next();
                    Exchange newExchange = ExchangeHelper.createCopy(exchange, true);
                    if (part instanceof Message) {
                        newExchange.setIn((Message) part);
                    } else {
                        Message in = newExchange.getIn();
                        in.setBody(part);
                    }
                    return createProcessorExchangePair(index++, getProcessors().iterator().next(), newExchange);
                }

                public void remove() {
                    throw new UnsupportedOperationException(""Remove is not supported by this iterator"");
                }
            };
        }
    };
}",1.2272727272727273,2.186602870813397,0.6,1.5,0.3333333333333333,0.011904761904761871,-0.669626497533474,0.75,-0.02631578947368421,0.2616068186926228
Closure,46,2,"@Override
public JSType getLeastSupertype(JSType that) {
    if (!that.isRecordType()) {
        return super.getLeastSupertype(that);
    }
    RecordTypeBuilder builder = new RecordTypeBuilder(registry);
    for (String property : properties.keySet()) {
        if (that.toMaybeRecordType().hasProperty(property) && that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(getPropertyType(property))) {
            builder.addProperty(property, getPropertyType(property), getPropertyNode(property));
        }
    }
    return builder.build();
}",,"@Override
public JSType getLeastSupertype(JSType that) {
    if (!that.isRecordType()) {
        return super.getLeastSupertype(that);
    }
    RecordTypeBuilder builder = new RecordTypeBuilder(registry);
    for (String property : properties.keySet()) {
        if (that.toMaybeRecordType().hasProperty(property) && that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(getPropertyType(property))) {
            builder.addProperty(property, getPropertyType(property), getPropertyNode(property));
        }
    }
    return builder.build();
}",-0.045454545454545456,0.22009569377990432,0.0,0.0,0.25,0.011904761904761871,0.014799154334038212,0.5833333333333334,-0.02631578947368421,-0.000329639298536808
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1822_016df669,1,"/**
 * Creates a MongoDB update object from the given UpdateOp.
 *
 * @param updateOp the update op.
 * @return the DBObject.
 */
@Nonnull
private static DBObject createUpdate(UpdateOp updateOp) {
    BasicDBObject setUpdates = new BasicDBObject();
    BasicDBObject incUpdates = new BasicDBObject();
    BasicDBObject unsetUpdates = new BasicDBObject();
    // always increment modCount
    updateOp.increment(Document.MOD_COUNT, 1);
    // other updates
    for (Entry<Key, Operation> entry : updateOp.getChanges().entrySet()) {
        Key k = entry.getKey();
        if (k.getName().equals(Document.ID)) {
            // avoid exception ""Mod on _id not allowed""
            continue;
        }
        Operation op = entry.getValue();
        switch(op.type) {
            case SET:
                {
                    setUpdates.append(k.toString(), op.value);
                    break;
                }
            case INCREMENT:
                {
                    incUpdates.append(k.toString(), op.value);
                    break;
                }
            case SET_MAP_ENTRY:
                {
                    setUpdates.append(k.toString(), op.value);
                    break;
                }
            case REMOVE_MAP_ENTRY:
                {
                    unsetUpdates.append(k.toString(), ""1"");
                    break;
                }
        }
    }
    BasicDBObject update = new BasicDBObject();
    if (!setUpdates.isEmpty()) {
        update.append(""$set"", setUpdates);
    }
    if (!incUpdates.isEmpty()) {
        update.append(""$inc"", incUpdates);
    }
    if (!unsetUpdates.isEmpty()) {
        update.append(""$unset"", unsetUpdates);
    }
    return update;
}","/**
 * Creates a MongoDB update object from the given UpdateOp.
 *
 * @param updateOp the update op.
 * @return the DBObject.
 */
","@Nonnull
private static DBObject createUpdate(UpdateOp updateOp) {
    BasicDBObject setUpdates = new BasicDBObject();
    BasicDBObject incUpdates = new BasicDBObject();
    BasicDBObject unsetUpdates = new BasicDBObject();
        updateOp.increment(Document.MOD_COUNT, 1);
        for (Entry<Key, Operation> entry : updateOp.getChanges().entrySet()) {
        Key k = entry.getKey();
        if (k.getName().equals(Document.ID)) {
                        continue;
        }
        Operation op = entry.getValue();
        switch(op.type) {
            case SET:
                {
                    setUpdates.append(k.toString(), op.value);
                    break;
                }
            case INCREMENT:
                {
                    incUpdates.append(k.toString(), op.value);
                    break;
                }
            case SET_MAP_ENTRY:
                {
                    setUpdates.append(k.toString(), op.value);
                    break;
                }
            case REMOVE_MAP_ENTRY:
                {
                    unsetUpdates.append(k.toString(), ""1"");
                    break;
                }
        }
    }
    BasicDBObject update = new BasicDBObject();
    if (!setUpdates.isEmpty()) {
        update.append(""$set"", setUpdates);
    }
    if (!incUpdates.isEmpty()) {
        update.append(""$inc"", incUpdates);
    }
    if (!unsetUpdates.isEmpty()) {
        update.append(""$unset"", unsetUpdates);
    }
    return update;
}",1.5,1.6507177033492826,2.2,0.5,0.6666666666666666,0.0853174603174603,-0.799859055673009,1.25,-0.02631578947368421,0.4027800349233242
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1731_024e5d37,1,"private void copyPropertyDefinition(QPropertyDefinition def, NodeBuilder builder) throws NamespaceException {
    builder.setProperty(JCR_PRIMARYTYPE, NT_PROPERTYDEFINITION, NAME);
    copyItemDefinition(def, builder);
    // - jcr:requiredType (STRING) protected mandatory
    // < 'STRING', 'URI', 'BINARY', 'LONG', 'DOUBLE',
    // 'DECIMAL', 'BOOLEAN', 'DATE', 'NAME', 'PATH',
    // 'REFERENCE', 'WEAKREFERENCE', 'UNDEFINED'
    builder.setProperty(JCR_REQUIREDTYPE, Type.fromTag(def.getRequiredType(), false).toString());
    // - jcr:valueConstraints (STRING) protected multiple
    QValueConstraint[] constraints = def.getValueConstraints();
    if (constraints != null && constraints.length > 0) {
        List<String> strings = newArrayListWithCapacity(constraints.length);
        for (QValueConstraint constraint : constraints) {
            strings.add(constraint.getString());
        }
        builder.setProperty(JCR_VALUECONSTRAINTS, strings, STRINGS);
    }
    // - jcr:defaultValues (UNDEFINED) protected multiple
    QValue[] values = def.getDefaultValues();
    if (values != null) {
    // TODO
    }
    // - jcr:multiple (BOOLEAN) protected mandatory
    builder.setProperty(JCR_MULTIPLE, def.isMultiple());
    // - jcr:availableQueryOperators (NAME) protected mandatory multiple
    List<String> operators = asList(def.getAvailableQueryOperators());
    builder.setProperty(JCR_AVAILABLE_QUERY_OPERATORS, operators, NAMES);
    // - jcr:isFullTextSearchable (BOOLEAN) protected mandatory
    builder.setProperty(JCR_IS_FULLTEXT_SEARCHABLE, def.isFullTextSearchable());
    // - jcr:isQueryOrderable (BOOLEAN) protected mandatory
    builder.setProperty(JCR_IS_QUERY_ORDERABLE, def.isQueryOrderable());
}",,"private void copyPropertyDefinition(QPropertyDefinition def, NodeBuilder builder) throws NamespaceException {
    builder.setProperty(JCR_PRIMARYTYPE, NT_PROPERTYDEFINITION, NAME);
    copyItemDefinition(def, builder);
                    builder.setProperty(JCR_REQUIREDTYPE, Type.fromTag(def.getRequiredType(), false).toString());
        QValueConstraint[] constraints = def.getValueConstraints();
    if (constraints != null && constraints.length > 0) {
        List<String> strings = newArrayListWithCapacity(constraints.length);
        for (QValueConstraint constraint : constraints) {
            strings.add(constraint.getString());
        }
        builder.setProperty(JCR_VALUECONSTRAINTS, strings, STRINGS);
    }
        QValue[] values = def.getDefaultValues();
    if (values != null) {
        }
        builder.setProperty(JCR_MULTIPLE, def.isMultiple());
        List<String> operators = asList(def.getAvailableQueryOperators());
    builder.setProperty(JCR_AVAILABLE_QUERY_OPERATORS, operators, NAMES);
        builder.setProperty(JCR_IS_FULLTEXT_SEARCHABLE, def.isFullTextSearchable());
        builder.setProperty(JCR_IS_QUERY_ORDERABLE, def.isQueryOrderable());
}",0.3181818181818182,-0.16267942583732073,0.0,0.0,0.08333333333333333,0.33531746031746024,-0.3541930937279773,1.25,-0.02631578947368421,0.6777360926217273
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3517_24f7f60a,1,"@Nonnull
@Override
public Node perform() throws RepositoryException {
    String oakName = PathUtils.getName(oakPath);
    String parentPath = PathUtils.getParentPath(oakPath);
    NodeDelegate parent = dlg.getChild(parentPath);
    if (parent == null) {
        // is it a property?
        String grandParentPath = PathUtils.getParentPath(parentPath);
        NodeDelegate grandParent = dlg.getChild(grandParentPath);
        if (grandParent != null) {
            String propName = PathUtils.getName(parentPath);
            if (grandParent.getPropertyOrNull(propName) != null) {
                throw new ConstraintViolationException(""Can't add new node to property."");
            }
        }
        throw new PathNotFoundException(relPath);
    }
    if (parent.getChild(oakName) != null) {
        throw new ItemExistsException(relPath);
    }
    // modification of that property in the PermissionValidator
    if (oakTypeName != null) {
        PropertyState prop = PropertyStates.createProperty(JCR_PRIMARYTYPE, oakTypeName, NAME);
        sessionContext.getAccessManager().checkPermissions(dlg.getTree(), prop, Permissions.NODE_TYPE_MANAGEMENT);
    }
    NodeDelegate added = parent.addChild(oakName, oakTypeName);
    if (added == null) {
        throw new ItemExistsException();
    }
    return createNode(added, sessionContext);
}",,"@Nonnull
@Override
public Node perform() throws RepositoryException {
    String oakName = PathUtils.getName(oakPath);
    String parentPath = PathUtils.getParentPath(oakPath);
    NodeDelegate parent = dlg.getChild(parentPath);
    if (parent == null) {
                String grandParentPath = PathUtils.getParentPath(parentPath);
        NodeDelegate grandParent = dlg.getChild(grandParentPath);
        if (grandParent != null) {
            String propName = PathUtils.getName(parentPath);
            if (grandParent.getPropertyOrNull(propName) != null) {
                throw new ConstraintViolationException(""Can't add new node to property."");
            }
        }
        throw new PathNotFoundException(relPath);
    }
    if (parent.getChild(oakName) != null) {
        throw new ItemExistsException(relPath);
    }
        if (oakTypeName != null) {
        PropertyState prop = PropertyStates.createProperty(JCR_PRIMARYTYPE, oakTypeName, NAME);
        sessionContext.getAccessManager().checkPermissions(dlg.getTree(), prop, Permissions.NODE_TYPE_MANAGEMENT);
    }
    NodeDelegate added = parent.addChild(oakName, oakTypeName);
    if (added == null) {
        throw new ItemExistsException();
    }
    return createNode(added, sessionContext);
}",0.7272727272727273,0.40191387559808606,1.4,0.5,0.75,0.01785714285714283,-0.5678646934460886,0.6666666666666666,-0.02631578947368421,0.3140033309705341
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1732_941e3cb1,3,"/**
 * Gets the splits of the tables that have been set on the job.
 *
 * @param context
 *          the configuration of the job
 * @return the splits from the tables based on the ranges.
 * @throws java.io.IOException
 *           if a table set on the job doesn't exist or an error occurs initializing the tablet locator
 */
public List<InputSplit> getSplits(JobContext context) throws IOException {
    log.setLevel(getLogLevel(context));
    validateOptions(context);
    LinkedList<InputSplit> splits = new LinkedList<InputSplit>();
    Map<String, BatchScanConfig> tableConfigs = getBatchScanConfigs(context);
    for (Map.Entry<String, BatchScanConfig> tableConfigEntry : tableConfigs.entrySet()) {
        String tableName = tableConfigEntry.getKey();
        BatchScanConfig tableConfig = tableConfigEntry.getValue();
        boolean autoAdjust = tableConfig.shouldAutoAdjustRanges();
        String tableId = null;
        List<Range> ranges = autoAdjust ? Range.mergeOverlapping(tableConfig.getRanges()) : tableConfig.getRanges();
        if (ranges.isEmpty()) {
            ranges = new ArrayList<Range>(1);
            ranges.add(new Range());
        }
        // get the metadata information for these ranges
        Map<String, Map<KeyExtent, List<Range>>> binnedRanges = new HashMap<String, Map<KeyExtent, List<Range>>>();
        TabletLocator tl;
        try {
            // resolve table name to id once, and use id from this point forward
            tableId = Tables.getTableId(getInstance(context), tableName);
            if (tableConfig.isOfflineScan()) {
                binnedRanges = binOfflineTable(context, tableId, ranges);
                while (binnedRanges == null) {
                    // Some tablets were still online, try again
                    // sleep randomly between 100 and 200 ms
                    UtilWaitThread.sleep(100 + (int) (Math.random() * 100));
                    binnedRanges = binOfflineTable(context, tableId, ranges);
                }
            } else {
                Instance instance = getInstance(context);
                tl = getTabletLocator(context, tableId);
                // its possible that the cache could contain complete, but old information about a tables tablets... so clear it
                tl.invalidateCache();
                Credentials creds = new Credentials(getPrincipal(context), getAuthenticationToken(context));
                while (!tl.binRanges(creds, ranges, binnedRanges).isEmpty()) {
                    if (!(instance instanceof MockInstance)) {
                        if (!Tables.exists(instance, tableId))
                            throw new TableDeletedException(tableId);
                        if (Tables.getTableState(instance, tableId) == TableState.OFFLINE)
                            throw new TableOfflineException(instance, tableId);
                    }
                    binnedRanges.clear();
                    log.warn(""Unable to locate bins for specified ranges. Retrying."");
                    // sleep randomly between 100 and 200 ms
                    UtilWaitThread.sleep(100 + (int) (Math.random() * 100));
                    tl.invalidateCache();
                }
            }
        } catch (Exception e) {
            throw new IOException(e);
        }
        HashMap<Range, ArrayList<String>> splitsToAdd = null;
        if (!autoAdjust)
            splitsToAdd = new HashMap<Range, ArrayList<String>>();
        HashMap<String, String> hostNameCache = new HashMap<String, String>();
        for (Map.Entry<String, Map<KeyExtent, List<Range>>> tserverBin : binnedRanges.entrySet()) {
            String ip = tserverBin.getKey().split("":"", 2)[0];
            String location = hostNameCache.get(ip);
            if (location == null) {
                InetAddress inetAddress = InetAddress.getByName(ip);
                location = inetAddress.getHostName();
                hostNameCache.put(ip, location);
            }
            for (Map.Entry<KeyExtent, List<Range>> extentRanges : tserverBin.getValue().entrySet()) {
                Range ke = extentRanges.getKey().toDataRange();
                for (Range r : extentRanges.getValue()) {
                    if (autoAdjust) {
                        // divide ranges into smaller ranges, based on the tablets
                        splits.add(new RangeInputSplit(tableName, tableId, ke.clip(r), new String[] { location }));
                    } else {
                        // don't divide ranges
                        ArrayList<String> locations = splitsToAdd.get(r);
                        if (locations == null)
                            locations = new ArrayList<String>(1);
                        locations.add(location);
                        splitsToAdd.put(r, locations);
                    }
                }
            }
        }
        if (!autoAdjust)
            for (Map.Entry<Range, ArrayList<String>> entry : splitsToAdd.entrySet()) splits.add(new RangeInputSplit(tableName, tableId, entry.getKey(), entry.getValue().toArray(new String[0])));
    }
    return splits;
}","/**
 * Gets the splits of the tables that have been set on the job.
 *
 * @param context
 *          the configuration of the job
 * @return the splits from the tables based on the ranges.
 * @throws java.io.IOException
 *           if a table set on the job doesn't exist or an error occurs initializing the tablet locator
 */
","public List<InputSplit> getSplits(JobContext context) throws IOException {
    log.setLevel(getLogLevel(context));
    validateOptions(context);
    LinkedList<InputSplit> splits = new LinkedList<InputSplit>();
    Map<String, BatchScanConfig> tableConfigs = getBatchScanConfigs(context);
    for (Map.Entry<String, BatchScanConfig> tableConfigEntry : tableConfigs.entrySet()) {
        String tableName = tableConfigEntry.getKey();
        BatchScanConfig tableConfig = tableConfigEntry.getValue();
        boolean autoAdjust = tableConfig.shouldAutoAdjustRanges();
        String tableId = null;
        List<Range> ranges = autoAdjust ? Range.mergeOverlapping(tableConfig.getRanges()) : tableConfig.getRanges();
        if (ranges.isEmpty()) {
            ranges = new ArrayList<Range>(1);
            ranges.add(new Range());
        }
                Map<String, Map<KeyExtent, List<Range>>> binnedRanges = new HashMap<String, Map<KeyExtent, List<Range>>>();
        TabletLocator tl;
        try {
                        tableId = Tables.getTableId(getInstance(context), tableName);
            if (tableConfig.isOfflineScan()) {
                binnedRanges = binOfflineTable(context, tableId, ranges);
                while (binnedRanges == null) {
                                                            UtilWaitThread.sleep(100 + (int) (Math.random() * 100));
                    binnedRanges = binOfflineTable(context, tableId, ranges);
                }
            } else {
                Instance instance = getInstance(context);
                tl = getTabletLocator(context, tableId);
                                tl.invalidateCache();
                Credentials creds = new Credentials(getPrincipal(context), getAuthenticationToken(context));
                while (!tl.binRanges(creds, ranges, binnedRanges).isEmpty()) {
                    if (!(instance instanceof MockInstance)) {
                        if (!Tables.exists(instance, tableId))
                            throw new TableDeletedException(tableId);
                        if (Tables.getTableState(instance, tableId) == TableState.OFFLINE)
                            throw new TableOfflineException(instance, tableId);
                    }
                    binnedRanges.clear();
                    log.warn(""Unable to locate bins for specified ranges. Retrying."");
                                        UtilWaitThread.sleep(100 + (int) (Math.random() * 100));
                    tl.invalidateCache();
                }
            }
        } catch (Exception e) {
            throw new IOException(e);
        }
        HashMap<Range, ArrayList<String>> splitsToAdd = null;
        if (!autoAdjust)
            splitsToAdd = new HashMap<Range, ArrayList<String>>();
        HashMap<String, String> hostNameCache = new HashMap<String, String>();
        for (Map.Entry<String, Map<KeyExtent, List<Range>>> tserverBin : binnedRanges.entrySet()) {
            String ip = tserverBin.getKey().split("":"", 2)[0];
            String location = hostNameCache.get(ip);
            if (location == null) {
                InetAddress inetAddress = InetAddress.getByName(ip);
                location = inetAddress.getHostName();
                hostNameCache.put(ip, location);
            }
            for (Map.Entry<KeyExtent, List<Range>> extentRanges : tserverBin.getValue().entrySet()) {
                Range ke = extentRanges.getKey().toDataRange();
                for (Range r : extentRanges.getValue()) {
                    if (autoAdjust) {
                                                splits.add(new RangeInputSplit(tableName, tableId, ke.clip(r), new String[] { location }));
                    } else {
                                                ArrayList<String> locations = splitsToAdd.get(r);
                        if (locations == null)
                            locations = new ArrayList<String>(1);
                        locations.add(location);
                        splitsToAdd.put(r, locations);
                    }
                }
            }
        }
        if (!autoAdjust)
            for (Map.Entry<Range, ArrayList<String>> entry : splitsToAdd.entrySet()) splits.add(new RangeInputSplit(tableName, tableId, entry.getKey(), entry.getValue().toArray(new String[0])));
    }
    return splits;
}",2.909090909090909,1.7894736842105265,3.8,1.5,1.5833333333333333,0.8134920634920636,-1.2875264270613105,4.166666666666667,-0.02631578947368421,5.792248866144544
Closure,169,2,"/**
 * Determines if typeA is a subtype of typeB
 */
static boolean isSubtype(ObjectType typeA, RecordType typeB) {
    // to the property of z would not violate any restrictions on it.
    for (String property : typeB.properties.keySet()) {
        if (!typeA.hasProperty(property)) {
            return false;
        }
        JSType propA = typeA.getPropertyType(property);
        JSType propB = typeB.getPropertyType(property);
        if (!propA.isUnknownType() && !propB.isUnknownType()) {
            if (typeA.isPropertyTypeDeclared(property)) {
                // then the whole record isn't covariant.
                if (!propA.isInvariant(propB)) {
                    return false;
                }
            } else {
                // then the whole record isn't covariant.
                if (!propA.isSubtype(propB)) {
                    return false;
                }
            }
        }
    }
    return true;
}","/**
 * Determines if typeA is a subtype of typeB
 */
","static boolean isSubtype(ObjectType typeA, RecordType typeB) {
        for (String property : typeB.properties.keySet()) {
        if (!typeA.hasProperty(property)) {
            return false;
        }
        JSType propA = typeA.getPropertyType(property);
        JSType propB = typeB.getPropertyType(property);
        if (!propA.isUnknownType() && !propB.isUnknownType()) {
            if (typeA.isPropertyTypeDeclared(property)) {
                                if (!propA.isInvariant(propB)) {
                    return false;
                }
            } else {
                                if (!propA.isSubtype(propB)) {
                    return false;
                }
            }
        }
    }
    return true;
}",0.3181818181818182,1.3157894736842106,0.6,1.0,0.75,0.041666666666666616,-0.24989429175475666,0.25,0.10526315789473684,0.04669582706615259
Closure,84,2,"@Override
Node processAssignment(Assignment assignmentNode) {
    Node assign = processInfixExpression(assignmentNode);
    return assign;
}",,"@Override
Node processAssignment(Assignment assignmentNode) {
    Node assign = processInfixExpression(assignmentNode);
    return assign;
}",-0.4090909090909091,-0.49282296650717716,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.702889358703312,-0.4166666666666667,2.131578947368421,-0.16279340490885932
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1051_25cf3ccd,3,"@Override
public int hashCode() {
    int result = 0;
    for (ByteSequence b : auths) result += b.hashCode();
    return result;
}",,"@Override
public int hashCode() {
    int result = 0;
    for (ByteSequence b : auths) result += b.hashCode();
    return result;
}",-0.36363636363636365,-0.47368421052631593,-0.4,-1.0,-0.4166666666666667,-0.06746031746031747,0.5836504580690626,-0.4166666666666667,1.2894736842105263,-0.13063167418728353
commons-math,remotes/origin/bugs-dot-jar_MATH-1089_e91d0f05,1,"/**
 * Rounds the given value to the specified number of decimal places.
 * The value is rounded using the given method which is any method defined
 * in {@link BigDecimal}.
 * If {@code x} is infinite or {@code NaN}, then the value of {@code x} is
 * returned unchanged, regardless of the other parameters.
 *
 * @param x Value to round.
 * @param scale Number of digits to the right of the decimal point.
 * @param roundingMethod Rounding method as defined in {@link BigDecimal}.
 * @return the rounded value.
 * @throws ArithmeticException if {@code roundingMethod == ROUND_UNNECESSARY}
 * and the specified scaling operation would require rounding.
 * @throws IllegalArgumentException if {@code roundingMethod} does not
 * represent a valid rounding mode.
 * @since 1.1 (previously in {@code MathUtils}, moved as of version 3.0)
 */
public static double round(double x, int scale, int roundingMethod) {
    try {
        return (new BigDecimal(Double.toString(x)).setScale(scale, roundingMethod)).doubleValue();
    } catch (NumberFormatException ex) {
        if (Double.isInfinite(x)) {
            return x;
        } else {
            return Double.NaN;
        }
    }
}","/**
 * Rounds the given value to the specified number of decimal places.
 * The value is rounded using the given method which is any method defined
 * in {@link BigDecimal}.
 * If {@code x} is infinite or {@code NaN}, then the value of {@code x} is
 * returned unchanged, regardless of the other parameters.
 *
 * @param x Value to round.
 * @param scale Number of digits to the right of the decimal point.
 * @param roundingMethod Rounding method as defined in {@link BigDecimal}.
 * @return the rounded value.
 * @throws ArithmeticException if {@code roundingMethod == ROUND_UNNECESSARY}
 * and the specified scaling operation would require rounding.
 * @throws IllegalArgumentException if {@code roundingMethod} does not
 * represent a valid rounding mode.
 * @since 1.1 (previously in {@code MathUtils}, moved as of version 3.0)
 */
","public static double round(double x, int scale, int roundingMethod) {
    try {
        return (new BigDecimal(Double.toString(x)).setScale(scale, roundingMethod)).doubleValue();
    } catch (NumberFormatException ex) {
        if (Double.isInfinite(x)) {
            return x;
        } else {
            return Double.NaN;
        }
    }
}",-0.13636363636363635,0.45933014354066987,-0.2,0.0,-0.16666666666666666,-0.3650793650793651,0.22085976039464428,-0.16666666666666666,0.0,-0.16279340490885932
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1655_01a8b283,1,"@Nullable
@Override
public String apply(@Nullable DataIdentifier input) {
    return input.toString();
}",,"@Nullable
@Override
public String apply(@Nullable DataIdentifier input) {
    return input.toString();
}",-0.4090909090909091,-0.6650717703349284,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.7375616631430585,-0.4166666666666667,1.894736842105263,-0.16279340490885932
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3630_fcd64766,3,"@Override
public Aggregate getAggregate(NodeState matchedNodeState) {
    return aggMapper.getAggregate(ConfigUtil.getPrimaryTypeName(matchedNodeState));
}",,"@Override
public Aggregate getAggregate(NodeState matchedNodeState) {
    return aggMapper.getAggregate(ConfigUtil.getPrimaryTypeName(matchedNodeState));
}",-0.45454545454545453,-0.6028708133971293,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.8173361522198731,-0.3333333333333333,1.0526315789473684,-0.16279340490885932
Compress,4,1,"/**
 * Closes this output stream and releases any system resources
 * associated with the stream.
 *
 * @exception  IOException  if an I/O error occurs.
 */
public void close() throws IOException {
    finish();
    if (raf != null) {
        raf.close();
    }
    if (out != null) {
        out.close();
    }
}","/**
 * Closes this output stream and releases any system resources
 * associated with the stream.
 *
 * @exception  IOException  if an I/O error occurs.
 */
","public void close() throws IOException {
    finish();
    if (raf != null) {
        raf.close();
    }
    if (out != null) {
        out.close();
    }
}",-0.22727272727272727,-0.15311004784689008,-0.2,-0.5,-0.08333333333333333,-0.3650793650793651,0.4069062720225511,-0.25,2.552631578947368,-0.16279340490885932
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-2487_f2920c26,0,"/**
 * @return the current size of the buffer.
 */
public int getSize() {
    if (this.value == null) {
        throw new IllegalStateException(""Uninitialized. Null constructor "" + ""called w/o accompanying readFields invocation"");
    }
    return this.value.length;
}","/**
 * @return the current size of the buffer.
 */
","public int getSize() {
    if (this.value == null) {
        throw new IllegalStateException(""Uninitialized. Null constructor "" + ""called w/o accompanying readFields invocation"");
    }
    return this.value.length;
}",-0.36363636363636365,-0.11483253588516758,-0.2,-0.5,-0.25,-0.14285714285714285,0.6124031007751934,-0.5,2.5,-0.14384029782795363
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1429_c2f5ca6c,1,"private void diffFewChildren(JsopWriter w, DocumentNodeState.Children fromChildren, Revision fromRev, DocumentNodeState.Children toChildren, Revision toRev) {
    Set<String> childrenSet = Sets.newHashSet(toChildren.children);
    for (String n : fromChildren.children) {
        if (!childrenSet.contains(n)) {
            w.tag('-').value(n).newline();
        } else {
            DocumentNodeState n1 = getNode(n, fromRev);
            DocumentNodeState n2 = getNode(n, toRev);
            // this is not fully correct:
            // a change is detected if the node changed recently,
            // even if the revisions are well in the past
            // if this is a problem it would need to be changed
            checkNotNull(n1, ""Node at [%s] not found for fromRev [%s]"", n, fromRev);
            checkNotNull(n2, ""Node at [%s] not found for toRev [%s]"", n, toRev);
            if (!n1.getId().equals(n2.getId())) {
                w.tag('^').key(n).object().endObject().newline();
            }
        }
    }
    childrenSet = Sets.newHashSet(fromChildren.children);
    for (String n : toChildren.children) {
        if (!childrenSet.contains(n)) {
            w.tag('+').key(n).object().endObject().newline();
        }
    }
}",,"private void diffFewChildren(JsopWriter w, DocumentNodeState.Children fromChildren, Revision fromRev, DocumentNodeState.Children toChildren, Revision toRev) {
    Set<String> childrenSet = Sets.newHashSet(toChildren.children);
    for (String n : fromChildren.children) {
        if (!childrenSet.contains(n)) {
            w.tag('-').value(n).newline();
        } else {
            DocumentNodeState n1 = getNode(n, fromRev);
            DocumentNodeState n2 = getNode(n, toRev);
                                                            checkNotNull(n1, ""Node at [%s] not found for fromRev [%s]"", n, fromRev);
            checkNotNull(n2, ""Node at [%s] not found for toRev [%s]"", n, toRev);
            if (!n1.getId().equals(n2.getId())) {
                w.tag('^').key(n).object().endObject().newline();
            }
        }
    }
    childrenSet = Sets.newHashSet(fromChildren.children);
    for (String n : toChildren.children) {
        if (!childrenSet.contains(n)) {
            w.tag('+').key(n).object().endObject().newline();
        }
    }
}",0.36363636363636365,0.650717703349282,0.4,0.5,0.16666666666666666,0.11507936507936505,-0.3818181818181818,1.5,-0.02631578947368421,0.38682825907804724
Lang,10,1,"// Support for strategies
// -----------------------------------------------------------------------
/**
 * Escape constant fields into regular expression
 * @param regex The destination regex
 * @param value The source field
 * @param unquote If true, replace two success quotes ('') with single quote (')
 * @return The <code>StringBuilder</code>
 */
private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {
    boolean wasWhite = false;
    for (int i = 0; i < value.length(); ++i) {
        char c = value.charAt(i);
        if (Character.isWhitespace(c)) {
            if (!wasWhite) {
                wasWhite = true;
                regex.append(""\\s*+"");
            }
            continue;
        }
        wasWhite = false;
        switch(c) {
            case '\'':
                if (unquote) {
                    if (++i == value.length()) {
                        return regex;
                    }
                    c = value.charAt(i);
                }
                break;
            case '?':
            case '[':
            case ']':
            case '(':
            case ')':
            case '{':
            case '}':
            case '\\':
            case '|':
            case '*':
            case '+':
            case '^':
            case '$':
            case '.':
                regex.append('\\');
        }
        regex.append(c);
    }
    return regex;
}","/**
 * Escape constant fields into regular expression
 * @param regex The destination regex
 * @param value The source field
 * @param unquote If true, replace two success quotes ('') with single quote (')
 * @return The <code>StringBuilder</code>
 */
","private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {
    boolean wasWhite = false;
    for (int i = 0; i < value.length(); ++i) {
        char c = value.charAt(i);
        if (Character.isWhitespace(c)) {
            if (!wasWhite) {
                wasWhite = true;
                regex.append(""\\s*+"");
            }
            continue;
        }
        wasWhite = false;
        switch(c) {
            case '\'':
                if (unquote) {
                    if (++i == value.length()) {
                        return regex;
                    }
                    c = value.charAt(i);
                }
                break;
            case '?':
            case '[':
            case ']':
            case '(':
            case ')':
            case '{':
            case '}':
            case '\\':
            case '|':
            case '*':
            case '+':
            case '^':
            case '$':
            case '.':
                regex.append('\\');
        }
        regex.append(c);
    }
    return regex;
}",1.2272727272727273,1.0191387559808613,3.8,1.5,1.75,0.371031746031746,-0.7423537702607467,0.16666666666666666,-0.02631578947368421,0.5054476928130565
flink,remotes/origin/bugs-dot-jar_FLINK-3740_f2f5bd5b,1,"@Override
public void merge(W mergeResult, Collection<W> mergedWindows, W stateWindowResult, Collection<W> mergedStateWindows) throws Exception {
    context.window = mergeResult;
    // store for later use
    mergeTriggerResult.f0 = context.onMerge(mergedWindows);
    for (W m : mergedWindows) {
        context.window = m;
        context.clear();
    }
    // merge the merged state windows into the newly resulting state window
    getStateBackend().mergePartitionedStates(stateWindowResult, mergedStateWindows, windowSerializer, (StateDescriptor<? extends MergingState<?, ?>, ?>) windowStateDescriptor);
}",,"@Override
public void merge(W mergeResult, Collection<W> mergedWindows, W stateWindowResult, Collection<W> mergedStateWindows) throws Exception {
    context.window = mergeResult;
        mergeTriggerResult.f0 = context.onMerge(mergedWindows);
    for (W m : mergedWindows) {
        context.window = m;
        context.clear();
    }
        getStateBackend().mergePartitionedStates(stateWindowResult, mergedStateWindows, windowSerializer, (StateDescriptor<? extends MergingState<?, ?>, ?>) windowStateDescriptor);
}",-0.18181818181818182,-0.0909090909090911,-0.4,-0.5,-0.4166666666666667,-0.3650793650793651,0.14559548978153644,-0.16666666666666666,-0.02631578947368421,-0.16279340490885932
flink,remotes/origin/bugs-dot-jar_FLINK-2802_88a97768,0,"// ------------------------------------------------------------------------
@Override
protected void run() throws Exception {
    final String iterationId = configuration.getIterationId();
    if (iterationId == null || iterationId.length() == 0) {
        throw new Exception(""Missing iteration ID in the task configuration"");
    }
    final String brokerID = createBrokerIdString(getEnvironment().getJobID(), iterationId, getEnvironment().getIndexInSubtaskGroup());
    final long iterationWaitTime = configuration.getIterationWaitTime();
    final boolean shouldWait = iterationWaitTime > 0;
    final BlockingQueue<StreamRecord<OUT>> dataChannel = new ArrayBlockingQueue<StreamRecord<OUT>>(1);
    // offer the queue for the tail
    BlockingQueueBroker.INSTANCE.handIn(brokerID, dataChannel);
    LOG.info(""Iteration head {} added feedback queue under {}"", getName(), brokerID);
    // do the work
    try {
        @SuppressWarnings(""unchecked"")
        Collection<RecordWriterOutput<OUT>> outputs = (Collection<RecordWriterOutput<OUT>>) (Collection<?>) outputHandler.getOutputs();
        while (running) {
            StreamRecord<OUT> nextRecord = shouldWait ? dataChannel.poll(iterationWaitTime, TimeUnit.MILLISECONDS) : dataChannel.take();
            if (nextRecord != null) {
                for (RecordWriterOutput<OUT> output : outputs) {
                    output.collect(nextRecord);
                }
            } else {
                // done
                break;
            }
        }
    } finally {
        // make sure that we remove the queue from the broker, to prevent a resource leak
        BlockingQueueBroker.INSTANCE.remove(brokerID);
        LOG.info(""Iteration head {} removed feedback queue under {}"", getName(), brokerID);
    }
}",,"@Override
protected void run() throws Exception {
    final String iterationId = configuration.getIterationId();
    if (iterationId == null || iterationId.length() == 0) {
        throw new Exception(""Missing iteration ID in the task configuration"");
    }
    final String brokerID = createBrokerIdString(getEnvironment().getJobID(), iterationId, getEnvironment().getIndexInSubtaskGroup());
    final long iterationWaitTime = configuration.getIterationWaitTime();
    final boolean shouldWait = iterationWaitTime > 0;
    final BlockingQueue<StreamRecord<OUT>> dataChannel = new ArrayBlockingQueue<StreamRecord<OUT>>(1);
        BlockingQueueBroker.INSTANCE.handIn(brokerID, dataChannel);
    LOG.info(""Iteration head {} added feedback queue under {}"", getName(), brokerID);
        try {
        @SuppressWarnings(""unchecked"")
        Collection<RecordWriterOutput<OUT>> outputs = (Collection<RecordWriterOutput<OUT>>) (Collection<?>) outputHandler.getOutputs();
        while (running) {
            StreamRecord<OUT> nextRecord = shouldWait ? dataChannel.poll(iterationWaitTime, TimeUnit.MILLISECONDS) : dataChannel.take();
            if (nextRecord != null) {
                for (RecordWriterOutput<OUT> output : outputs) {
                    output.collect(nextRecord);
                }
            } else {
                                break;
            }
        }
    } finally {
                BlockingQueueBroker.INSTANCE.remove(brokerID);
        LOG.info(""Iteration head {} removed feedback queue under {}"", getName(), brokerID);
    }
}",0.7272727272727273,0.9952153110047848,0.8,1.0,0.4166666666666667,0.3412698412698413,-0.5610993657505284,1.0,-0.02631578947368421,0.7955809892636709
Closure,91,2,"/**
 * Since this pass reports errors only when a global {@code this} keyword
 * is encountered, there is no reason to traverse non global contexts.
 */
public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
    if (n.getType() == Token.FUNCTION) {
        // Don't traverse functions that are constructors or have the @this
        // or @override annotation.
        JSDocInfo jsDoc = getFunctionJsDocInfo(n);
        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.isInterface() || jsDoc.hasThisType() || jsDoc.isOverride())) {
            return false;
        }
        // Don't traverse functions unless they would normally
        // be able to have a @this annotation associated with them. e.g.,
        // var a = function() { }; // or
        // function a() {} // or
        // a.x = function() {}; // or
        // var a = {x: function() {}};
        int pType = parent.getType();
        if (!(pType == Token.BLOCK || pType == Token.SCRIPT || pType == Token.NAME || pType == Token.ASSIGN || // object literal keys
        pType == Token.STRING || pType == Token.NUMBER)) {
            return false;
        }
    // Don't traverse functions that are getting lent to a prototype.
    }
    if (parent != null && parent.getType() == Token.ASSIGN) {
        Node lhs = parent.getFirstChild();
        Node rhs = lhs.getNext();
        if (n == lhs) {
            // assignLhsChild should not be overridden.
            if (assignLhsChild == null) {
                assignLhsChild = lhs;
            }
        } else {
            // property or subproperty.
            if (NodeUtil.isGet(lhs)) {
                if (lhs.getType() == Token.GETPROP && lhs.getLastChild().getString().equals(""prototype"")) {
                    return false;
                }
                Node llhs = lhs.getFirstChild();
                if (llhs.getType() == Token.GETPROP && llhs.getLastChild().getString().equals(""prototype"")) {
                    return false;
                }
            }
        }
    }
    return true;
}","/**
 * Since this pass reports errors only when a global {@code this} keyword
 * is encountered, there is no reason to traverse non global contexts.
 */
","public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
    if (n.getType() == Token.FUNCTION) {
                        JSDocInfo jsDoc = getFunctionJsDocInfo(n);
        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.isInterface() || jsDoc.hasThisType() || jsDoc.isOverride())) {
            return false;
        }
                                                        int pType = parent.getType();
        if (!(pType == Token.BLOCK || pType == Token.SCRIPT || pType == Token.NAME || pType == Token.ASSIGN ||         pType == Token.STRING || pType == Token.NUMBER)) {
            return false;
        }
        }
    if (parent != null && parent.getType() == Token.ASSIGN) {
        Node lhs = parent.getFirstChild();
        Node rhs = lhs.getNext();
        if (n == lhs) {
                        if (assignLhsChild == null) {
                assignLhsChild = lhs;
            }
        } else {
                        if (NodeUtil.isGet(lhs)) {
                if (lhs.getType() == Token.GETPROP && lhs.getLastChild().getString().equals(""prototype"")) {
                    return false;
                }
                Node llhs = lhs.getFirstChild();
                if (llhs.getType() == Token.GETPROP && llhs.getLastChild().getString().equals(""prototype"")) {
                    return false;
                }
            }
        }
    }
    return true;
}",0.8636363636363636,1.0239234449760766,1.2,1.0,2.75,1.0773809523809523,-0.6456659619450316,1.1666666666666667,-0.02631578947368421,2.2085533329875573
Lang,14,1,"// Equals
// -----------------------------------------------------------------------
/**
 * <p>Compares two CharSequences, returning {@code true} if they represent
 * equal sequences of characters.</p>
 *
 * <p>{@code null}s are handled without exceptions. Two {@code null}
 * references are considered to be equal. The comparison is case sensitive.</p>
 *
 * <pre>
 * StringUtils.equals(null, null)   = true
 * StringUtils.equals(null, ""abc"")  = false
 * StringUtils.equals(""abc"", null)  = false
 * StringUtils.equals(""abc"", ""abc"") = true
 * StringUtils.equals(""abc"", ""ABC"") = false
 * </pre>
 *
 * @see java.lang.CharSequence#equals(Object)
 * @param cs1  the first CharSequence, may be {@code null}
 * @param cs2  the second CharSequence, may be {@code null}
 * @return {@code true} if the CharSequences are equal (case-sensitive), or both {@code null}
 * @since 3.0 Changed signature from equals(String, String) to equals(CharSequence, CharSequence)
 */
public static boolean equals(CharSequence cs1, CharSequence cs2) {
    if (cs1 == cs2) {
        return true;
    }
    if (cs1 == null || cs2 == null) {
        return false;
    }
    return cs1.equals(cs2);
}","/**
 * <p>Compares two CharSequences, returning {@code true} if they represent
 * equal sequences of characters.</p>
 *
 * <p>{@code null}s are handled without exceptions. Two {@code null}
 * references are considered to be equal. The comparison is case sensitive.</p>
 *
 * <pre>
 * StringUtils.equals(null, null)   = true
 * StringUtils.equals(null, ""abc"")  = false
 * StringUtils.equals(""abc"", null)  = false
 * StringUtils.equals(""abc"", ""abc"") = true
 * StringUtils.equals(""abc"", ""ABC"") = false
 * </pre>
 *
 * @see java.lang.CharSequence#equals(Object)
 * @param cs1  the first CharSequence, may be {@code null}
 * @param cs2  the second CharSequence, may be {@code null}
 * @return {@code true} if the CharSequences are equal (case-sensitive), or both {@code null}
 * @since 3.0 Changed signature from equals(String, String) to equals(CharSequence, CharSequence)
 */
","public static boolean equals(CharSequence cs1, CharSequence cs2) {
    if (cs1 == cs2) {
        return true;
    }
    if (cs1 == null || cs2 == null) {
        return false;
    }
    return cs1.equals(cs2);
}",-0.22727272727272727,-0.15311004784689008,-0.2,-0.5,0.0,0.05555555555555556,0.3324876673713883,-0.4166666666666667,0.02631578947368421,-0.09444972712551072
wicket,remotes/origin/bugs-dot-jar_WICKET-4066_4d3d1f85,1,"public IRequestHandler mapRequest(Request request) {
    InterceptData data = InterceptData.get();
    if (data != null) {
        if (data.originalUrl.equals(request.getOriginalUrl())) {
            if (data.postParameters.isEmpty() == false && request.getPostParameters() instanceof IWritableRequestParameters) {
                IWritableRequestParameters parameters = (IWritableRequestParameters) request.getPostParameters();
                parameters.reset();
                for (String s : data.postParameters.keySet()) {
                    parameters.setParameterValues(s, data.postParameters.get(s));
                }
            }
            InterceptData.clear();
        }
    }
    return null;
}",,"public IRequestHandler mapRequest(Request request) {
    InterceptData data = InterceptData.get();
    if (data != null) {
        if (data.originalUrl.equals(request.getOriginalUrl())) {
            if (data.postParameters.isEmpty() == false && request.getPostParameters() instanceof IWritableRequestParameters) {
                IWritableRequestParameters parameters = (IWritableRequestParameters) request.getPostParameters();
                parameters.reset();
                for (String s : data.postParameters.keySet()) {
                    parameters.setParameterValues(s, data.postParameters.get(s));
                }
            }
            InterceptData.clear();
        }
    }
    return null;
}",0.09090909090909091,1.5071770334928227,0.2,1.0,0.3333333333333333,0.37896825396825395,-0.12445384073291024,0.4166666666666667,-0.02631578947368421,0.2527734075598047
Closure,5,1,"/**
 * Counts the number of direct (full) references to an object.
 * Specifically, we check for references of the following type:
 * <pre>
 *   x;
 *   x.fn();
 * </pre>
 */
private boolean isInlinableObject(List<Reference> refs) {
    boolean ret = false;
    Set<String> validProperties = Sets.newHashSet();
    for (Reference ref : refs) {
        Node name = ref.getNode();
        Node parent = ref.getParent();
        Node gramps = ref.getGrandparent();
        //
        if (parent.isGetProp()) {
            Preconditions.checkState(parent.getFirstChild() == name);
            // A call target may be using the object as a 'this' value.
            if (gramps.isCall() && gramps.getFirstChild() == parent) {
                return false;
            }
            // Deleting a property has different semantics from deleting
            // a variable, so deleted properties should not be inlined.
            // NOTE(nicksantos): This pass's object-splitting algorithm has
            // a blind spot. It assumes that if a property isn't defined on an
            // object, then the value is undefined. This is not true, because
            // Object.prototype can have arbitrary properties on it.
            //
            // We short-circuit this problem by bailing out if we see a reference
            // to a property that isn't defined on the object literal. This
            // isn't a perfect algorithm, but it should catch most cases.
            String propName = parent.getLastChild().getString();
            if (!validProperties.contains(propName)) {
                if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {
                    validProperties.add(propName);
                } else {
                    return false;
                }
            }
            continue;
        }
        // Only rewrite VAR declarations or simple assignment statements
        if (!isVarOrAssignExprLhs(name)) {
            return false;
        }
        Node val = ref.getAssignedValue();
        if (val == null) {
            // A var with no assignment.
            continue;
        }
        // We're looking for object literal assignments only.
        if (!val.isObjectLit()) {
            return false;
        }
        // Also, ES5 getters/setters aren't handled by this pass.
        for (Node child = val.getFirstChild(); child != null; child = child.getNext()) {
            if (child.isGetterDef() || child.isSetterDef()) {
                // ES5 get/set not supported.
                return false;
            }
            validProperties.add(child.getString());
            Node childVal = child.getFirstChild();
            // will happen.
            for (Reference t : refs) {
                Node refNode = t.getParent();
                while (!NodeUtil.isStatementBlock(refNode)) {
                    if (refNode == childVal) {
                        // There's a self-referential assignment
                        return false;
                    }
                    refNode = refNode.getParent();
                }
            }
        }
        // We have found an acceptable object literal assignment. As
        // long as there are no other assignments that mess things up,
        // we can inline.
        ret = true;
    }
    return ret;
}","/**
 * Counts the number of direct (full) references to an object.
 * Specifically, we check for references of the following type:
 * <pre>
 *   x;
 *   x.fn();
 * </pre>
 */
","private boolean isInlinableObject(List<Reference> refs) {
    boolean ret = false;
    Set<String> validProperties = Sets.newHashSet();
    for (Reference ref : refs) {
        Node name = ref.getNode();
        Node parent = ref.getParent();
        Node gramps = ref.getGrandparent();
                if (parent.isGetProp()) {
            Preconditions.checkState(parent.getFirstChild() == name);
                        if (gramps.isCall() && gramps.getFirstChild() == parent) {
                return false;
            }
                                                                                                                                    String propName = parent.getLastChild().getString();
            if (!validProperties.contains(propName)) {
                if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {
                    validProperties.add(propName);
                } else {
                    return false;
                }
            }
            continue;
        }
                if (!isVarOrAssignExprLhs(name)) {
            return false;
        }
        Node val = ref.getAssignedValue();
        if (val == null) {
                        continue;
        }
                if (!val.isObjectLit()) {
            return false;
        }
                for (Node child = val.getFirstChild(); child != null; child = child.getNext()) {
            if (child.isGetterDef() || child.isSetterDef()) {
                                return false;
            }
            validProperties.add(child.getString());
            Node childVal = child.getFirstChild();
                        for (Reference t : refs) {
                Node refNode = t.getParent();
                while (!NodeUtil.isStatementBlock(refNode)) {
                    if (refNode == childVal) {
                                                return false;
                    }
                    refNode = refNode.getParent();
                }
            }
        }
                                ret = true;
    }
    return ret;
}",1.7272727272727273,1.062200956937799,2.4,1.5,2.1666666666666665,1.0456349206349207,-0.9024665257223394,1.75,-0.02631578947368421,2.321958472363894
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3089_ba38c380,3,"/**
 * Set the maximum memory this cache should use. This will not
 * immediately cause entries to get removed however; it will only change
 * the limit. To resize the internal array, call the clear method.
 *
 * @param maxMemory the maximum size (1 or larger)
 */
public void setMaxMemory(long maxMemory) {
    if (maxMemory <= 0) {
        throw new IllegalArgumentException(""Max memory must be larger than 0"");
    }
    this.maxMemory = maxMemory;
    if (segments != null) {
        long max = 1 + maxMemory / segments.length;
        for (Segment<K, V> s : segments) {
            s.setMaxMemory(max);
        }
    }
}","/**
 * Set the maximum memory this cache should use. This will not
 * immediately cause entries to get removed however; it will only change
 * the limit. To resize the internal array, call the clear method.
 *
 * @param maxMemory the maximum size (1 or larger)
 */
","public void setMaxMemory(long maxMemory) {
    if (maxMemory <= 0) {
        throw new IllegalArgumentException(""Max memory must be larger than 0"");
    }
    this.maxMemory = maxMemory;
    if (segments != null) {
        long max = 1 + maxMemory / segments.length;
        for (Segment<K, V> s : segments) {
            s.setMaxMemory(max);
        }
    }
}",-0.09090909090909091,0.1961722488038276,0.2,0.0,-0.08333333333333333,0.2698412698412699,0.09739252995066941,-0.4166666666666667,0.5526315789473684,0.028494205379114006
maven,remotes/origin/bugs-dot-jar_MNG-5212_c53d95ce,1,"protected static PluginDescriptor clone(PluginDescriptor original) {
    PluginDescriptor clone = null;
    if (original != null) {
        clone = new PluginDescriptor();
        clone.setGroupId(original.getGroupId());
        clone.setArtifactId(original.getArtifactId());
        clone.setVersion(original.getVersion());
        clone.setGoalPrefix(original.getGoalPrefix());
        clone.setInheritedByDefault(original.isInheritedByDefault());
        clone.setName(original.getName());
        clone.setDescription(original.getDescription());
        clone.setRequiredMavenVersion(original.getRequiredMavenVersion());
        clone.setPluginArtifact(ArtifactUtils.copyArtifactSafe(original.getPluginArtifact()));
        clone.setComponents(clone(original.getMojos(), clone));
        clone.setId(original.getId());
        clone.setIsolatedRealm(original.isIsolatedRealm());
        clone.setSource(original.getSource());
    }
    return clone;
}",,"protected static PluginDescriptor clone(PluginDescriptor original) {
    PluginDescriptor clone = null;
    if (original != null) {
        clone = new PluginDescriptor();
        clone.setGroupId(original.getGroupId());
        clone.setArtifactId(original.getArtifactId());
        clone.setVersion(original.getVersion());
        clone.setGoalPrefix(original.getGoalPrefix());
        clone.setInheritedByDefault(original.isInheritedByDefault());
        clone.setName(original.getName());
        clone.setDescription(original.getDescription());
        clone.setRequiredMavenVersion(original.getRequiredMavenVersion());
        clone.setPluginArtifact(ArtifactUtils.copyArtifactSafe(original.getPluginArtifact()));
        clone.setComponents(clone(original.getMojos(), clone));
        clone.setId(original.getId());
        clone.setIsolatedRealm(original.isIsolatedRealm());
        clone.setSource(original.getSource());
    }
    return clone;
}",0.2727272727272727,-0.16267942583732073,-0.4,-0.5,-0.25,0.04960317460317456,-0.269908386187456,1.8333333333333333,-0.02631578947368421,0.19321242717103784
commons-math,remotes/origin/bugs-dot-jar_MATH-757_76b7413d,1,"/**
 * Returns a hash code consistent with equals.
 *
 * @return the hash code representing this {@code ResizableDoubleArray}.
 * @since 2.0
 */
@Override
public synchronized int hashCode() {
    final int[] hashData = new int[6];
    hashData[0] = Double.valueOf(expansionFactor).hashCode();
    hashData[1] = Double.valueOf(contractionCriterion).hashCode();
    hashData[2] = expansionMode.hashCode();
    hashData[3] = Arrays.hashCode(internalArray);
    hashData[4] = numElements;
    hashData[5] = startIndex;
    return Arrays.hashCode(hashData);
}","/**
 * Returns a hash code consistent with equals.
 *
 * @return the hash code representing this {@code ResizableDoubleArray}.
 * @since 2.0
 */
","@Override
public synchronized int hashCode() {
    final int[] hashData = new int[6];
    hashData[0] = Double.valueOf(expansionFactor).hashCode();
    hashData[1] = Double.valueOf(contractionCriterion).hashCode();
    hashData[2] = expansionMode.hashCode();
    hashData[3] = Arrays.hashCode(internalArray);
    hashData[4] = numElements;
    hashData[5] = startIndex;
    return Arrays.hashCode(hashData);
}",-0.13636363636363635,-0.5789473684210528,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.11120507399577186,0.08333333333333333,0.2631578947368421,-0.16279340490885932
Closure,45,1,"/**
 * Look at all the property assigns to all variables.
 * These may or may not count as references. For example,
 *
 * <code>
 * var x = {};
 * x.foo = 3; // not a reference.
 * var y = foo();
 * y.foo = 3; // is a reference.
 * </code>
 *
 * Interpreting assignments could mark a variable as referenced that
 * wasn't referenced before, in order to keep it alive. Because we find
 * references by lazily traversing subtrees, marking a variable as
 * referenced could trigger new traversals of new subtrees, which could
 * find new references.
 *
 * Therefore, this interpretation needs to be run to a fixed point.
 */
private void interpretAssigns() {
    boolean changes = false;
    do {
        changes = false;
        // we traverse it.
        for (int current = 0; current < maybeUnreferenced.size(); current++) {
            Var var = maybeUnreferenced.get(current);
            if (referenced.contains(var)) {
                maybeUnreferenced.remove(current);
                current--;
            } else {
                boolean assignedToUnknownValue = false;
                boolean hasPropertyAssign = false;
                if (var.getParentNode().isVar() && !NodeUtil.isForIn(var.getParentNode().getParent())) {
                    Node value = var.getInitialValue();
                    assignedToUnknownValue = value != null && !NodeUtil.isLiteralValue(value, true);
                } else {
                    // This was initialized to a function arg or a catch param
                    // or a for...in variable.
                    assignedToUnknownValue = true;
                }
                for (Assign assign : assignsByVar.get(var)) {
                    if (assign.isPropertyAssign) {
                        hasPropertyAssign = true;
                    } else if (!NodeUtil.isLiteralValue(assign.assignNode.getLastChild(), true)) {
                        assignedToUnknownValue = true;
                    }
                }
                if (assignedToUnknownValue && hasPropertyAssign) {
                    changes = markReferencedVar(var) || changes;
                    maybeUnreferenced.remove(current);
                    current--;
                }
            }
        }
    } while (changes);
}","/**
 * Look at all the property assigns to all variables.
 * These may or may not count as references. For example,
 *
 * <code>
 * var x = {};
 * x.foo = 3; // not a reference.
 * var y = foo();
 * y.foo = 3; // is a reference.
 * </code>
 *
 * Interpreting assignments could mark a variable as referenced that
 * wasn't referenced before, in order to keep it alive. Because we find
 * references by lazily traversing subtrees, marking a variable as
 * referenced could trigger new traversals of new subtrees, which could
 * find new references.
 *
 * Therefore, this interpretation needs to be run to a fixed point.
 */
","private void interpretAssigns() {
    boolean changes = false;
    do {
        changes = false;
                for (int current = 0; current < maybeUnreferenced.size(); current++) {
            Var var = maybeUnreferenced.get(current);
            if (referenced.contains(var)) {
                maybeUnreferenced.remove(current);
                current--;
            } else {
                boolean assignedToUnknownValue = false;
                boolean hasPropertyAssign = false;
                if (var.getParentNode().isVar() && !NodeUtil.isForIn(var.getParentNode().getParent())) {
                    Node value = var.getInitialValue();
                    assignedToUnknownValue = value != null && !NodeUtil.isLiteralValue(value, true);
                } else {
                                                            assignedToUnknownValue = true;
                }
                for (Assign assign : assignsByVar.get(var)) {
                    if (assign.isPropertyAssign) {
                        hasPropertyAssign = true;
                    } else if (!NodeUtil.isLiteralValue(assign.assignNode.getLastChild(), true)) {
                        assignedToUnknownValue = true;
                    }
                }
                if (assignedToUnknownValue && hasPropertyAssign) {
                    changes = markReferencedVar(var) || changes;
                    maybeUnreferenced.remove(current);
                    current--;
                }
            }
        }
    } while (changes);
}",0.9090909090909091,1.6172248803827751,1.0,2.0,1.4166666666666667,1.4325396825396826,-0.6146582100070469,0.8333333333333334,-0.02631578947368421,2.1117869100926097
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1270_70564c7c,1,"@Override
public boolean visit(FullTextOr or) {
    BooleanQuery q = new BooleanQuery();
    for (FullTextExpression e : or.list) {
        Query x = getFullTextQuery(e, analyzer);
        q.add(x, SHOULD);
    }
    result.set(q);
    return true;
}",,"@Override
public boolean visit(FullTextOr or) {
    BooleanQuery q = new BooleanQuery();
    for (FullTextExpression e : or.list) {
        Query x = getFullTextQuery(e, analyzer);
        q.add(x, SHOULD);
    }
    result.set(q);
    return true;
}",-0.18181818181818182,-0.0909090909090911,-0.4,-0.5,-0.4166666666666667,-0.3650793650793651,0.2155038759689921,-0.25,0.6842105263157895,-0.16279340490885932
Lang,49,1,"// Calculations
// -------------------------------------------------------------------
/**
 * <p>Reduce the fraction to the smallest values for the numerator and
 * denominator, returning the result.</p>
 *
 * <p>For example, if this fraction represents 2/4, then the result
 * will be 1/2.</p>
 *
 * @return a new reduced fraction instance, or this if no simplification possible
 */
public Fraction reduce() {
    int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);
    if (gcd == 1) {
        return this;
    }
    return Fraction.getFraction(numerator / gcd, denominator / gcd);
}","/**
 * <p>Reduce the fraction to the smallest values for the numerator and
 * denominator, returning the result.</p>
 *
 * <p>For example, if this fraction represents 2/4, then the result
 * will be 1/2.</p>
 *
 * @return a new reduced fraction instance, or this if no simplification possible
 */
","public Fraction reduce() {
    int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);
    if (gcd == 1) {
        return this;
    }
    return Fraction.getFraction(numerator / gcd, denominator / gcd);
}",-0.3181818181818182,-0.20574162679425848,-0.4,-0.5,-0.25,-0.05753968253968254,0.4336856941508105,-0.25,1.9473684210526316,-0.10582343550999003
camel,remotes/origin/bugs-dot-jar_CAMEL-6667_1fc7bd7a,1,"protected boolean process(final Exchange exchange, final AsyncCallback callback, final AtomicInteger index, final AtomicInteger count) {
    // set current index as property
    LOG.debug(""LoopProcessor: iteration #{}"", index.get());
    exchange.setProperty(Exchange.LOOP_INDEX, index.get());
    boolean sync = processor.process(exchange, new AsyncCallback() {

        public void done(boolean doneSync) {
            // we only have to handle async completion of the routing slip
            if (doneSync) {
                return;
            }
            Exchange target = exchange;
            // increment index as we have just processed once
            index.getAndIncrement();
            // continue looping asynchronously
            while (index.get() < count.get()) {
                // and prepare for next iteration
                target = prepareExchange(exchange, index.get());
                // process again
                boolean sync = process(target, callback, index, count);
                if (!sync) {
                    LOG.trace(""Processing exchangeId: {} is continued being processed asynchronously"", target.getExchangeId());
                    // so we break out now, then the callback will be invoked which then continue routing from where we left here
                    return;
                }
                // increment counter before next loop
                index.getAndIncrement();
            }
            // we are done so prepare the result
            ExchangeHelper.copyResults(exchange, target);
            LOG.trace(""Processing complete for exchangeId: {} >>> {}"", exchange.getExchangeId(), exchange);
            callback.done(false);
        }
    });
    return sync;
}",,"protected boolean process(final Exchange exchange, final AsyncCallback callback, final AtomicInteger index, final AtomicInteger count) {
        LOG.debug(""LoopProcessor: iteration #{}"", index.get());
    exchange.setProperty(Exchange.LOOP_INDEX, index.get());
    boolean sync = processor.process(exchange, new AsyncCallback() {

        public void done(boolean doneSync) {
                        if (doneSync) {
                return;
            }
            Exchange target = exchange;
                        index.getAndIncrement();
                        while (index.get() < count.get()) {
                                target = prepareExchange(exchange, index.get());
                                boolean sync = process(target, callback, index, count);
                if (!sync) {
                    LOG.trace(""Processing exchangeId: {} is continued being processed asynchronously"", target.getExchangeId());
                                        return;
                }
                                index.getAndIncrement();
            }
                        ExchangeHelper.copyResults(exchange, target);
            LOG.trace(""Processing complete for exchangeId: {} >>> {}"", exchange.getExchangeId(), exchange);
            callback.done(false);
        }
    });
    return sync;
}",0.5454545454545454,1.263157894736842,0.0,0.5,0.16666666666666666,0.12103174603174605,-0.4088794926004226,1.0,-0.02631578947368421,0.2717726180391072
maven,remotes/origin/bugs-dot-jar_MNG-2221_cc859f5c,0,"public static void mergePluginLists(PluginContainer childContainer, PluginContainer parentContainer, boolean handleAsInheritance) {
    if (childContainer == null || parentContainer == null) {
        // nothing to do.
        return;
    }
    List mergedPlugins = new ArrayList();
    List parentPlugins = parentContainer.getPlugins();
    if (parentPlugins != null && !parentPlugins.isEmpty()) {
        Map assembledPlugins = new TreeMap();
        Map childPlugins = childContainer.getPluginsAsMap();
        for (Iterator it = parentPlugins.iterator(); it.hasNext(); ) {
            Plugin parentPlugin = (Plugin) it.next();
            String parentInherited = parentPlugin.getInherited();
            if (!handleAsInheritance || parentInherited == null || Boolean.valueOf(parentInherited).booleanValue()) {
                Plugin assembledPlugin = parentPlugin;
                Plugin childPlugin = (Plugin) childPlugins.get(parentPlugin.getKey());
                if (childPlugin != null) {
                    assembledPlugin = childPlugin;
                    mergePluginDefinitions(childPlugin, parentPlugin, handleAsInheritance);
                }
                if (handleAsInheritance && parentInherited == null) {
                    assembledPlugin.unsetInheritanceApplied();
                }
                mergedPlugins.add(assembledPlugin);
            }
        }
        // since assembledPlugins is never updated and remains empty.
        for (Iterator it = childPlugins.values().iterator(); it.hasNext(); ) {
            Plugin childPlugin = (Plugin) it.next();
            if (!assembledPlugins.containsKey(childPlugin.getKey())) {
                mergedPlugins.add(childPlugin);
            }
        }
        childContainer.setPlugins(mergedPlugins);
        childContainer.flushPluginMap();
    }
}",,"public static void mergePluginLists(PluginContainer childContainer, PluginContainer parentContainer, boolean handleAsInheritance) {
    if (childContainer == null || parentContainer == null) {
                return;
    }
    List mergedPlugins = new ArrayList();
    List parentPlugins = parentContainer.getPlugins();
    if (parentPlugins != null && !parentPlugins.isEmpty()) {
        Map assembledPlugins = new TreeMap();
        Map childPlugins = childContainer.getPluginsAsMap();
        for (Iterator it = parentPlugins.iterator(); it.hasNext(); ) {
            Plugin parentPlugin = (Plugin) it.next();
            String parentInherited = parentPlugin.getInherited();
            if (!handleAsInheritance || parentInherited == null || Boolean.valueOf(parentInherited).booleanValue()) {
                Plugin assembledPlugin = parentPlugin;
                Plugin childPlugin = (Plugin) childPlugins.get(parentPlugin.getKey());
                if (childPlugin != null) {
                    assembledPlugin = childPlugin;
                    mergePluginDefinitions(childPlugin, parentPlugin, handleAsInheritance);
                }
                if (handleAsInheritance && parentInherited == null) {
                    assembledPlugin.unsetInheritanceApplied();
                }
                mergedPlugins.add(assembledPlugin);
            }
        }
                for (Iterator it = childPlugins.values().iterator(); it.hasNext(); ) {
            Plugin childPlugin = (Plugin) it.next();
            if (!assembledPlugins.containsKey(childPlugin.getKey())) {
                mergedPlugins.add(childPlugin);
            }
        }
        childContainer.setPlugins(mergedPlugins);
        childContainer.flushPluginMap();
    }
}",0.9545454545454546,1.200956937799043,1.0,1.0,1.5833333333333333,1.0654761904761905,-0.6665257223396756,1.4166666666666667,-0.02631578947368421,2.1963267117327385
Closure,132,2,"/**
 * Try turning IF nodes into smaller HOOKs
 *
 * Returns the replacement for n or the original if no replacement was
 * necessary.
 */
private Node tryMinimizeIf(Node n) {
    Node parent = n.getParent();
    Node cond = n.getFirstChild();
    /* If the condition is a literal, we'll let other
     * optimizations try to remove useless code.
     */
    if (NodeUtil.isLiteralValue(cond, true)) {
        return n;
    }
    Node thenBranch = cond.getNext();
    Node elseBranch = thenBranch.getNext();
    if (elseBranch == null) {
        if (isFoldableExpressBlock(thenBranch)) {
            Node expr = getBlockExpression(thenBranch);
            if (!late && isPropertyAssignmentInExpression(expr)) {
                // until CollapseProperties has been run.
                return n;
            }
            if (cond.isNot()) {
                // if(!x)bar(); -> x||bar();
                if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), OR_PRECEDENCE)) {
                    // It's not okay to add two sets of parentheses.
                    return n;
                }
                Node or = IR.or(cond.removeFirstChild(), expr.removeFirstChild()).srcref(n);
                Node newExpr = NodeUtil.newExpr(or);
                parent.replaceChild(n, newExpr);
                reportCodeChange();
                return newExpr;
            }
            // if(x)foo(); -> x&&foo();
            if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), AND_PRECEDENCE)) {
                // we can further optimize its parent.
                return n;
            }
            n.removeChild(cond);
            Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);
            Node newExpr = NodeUtil.newExpr(and);
            parent.replaceChild(n, newExpr);
            reportCodeChange();
            return newExpr;
        } else {
            // Try to combine two IF-ELSE
            if (NodeUtil.isStatementBlock(thenBranch) && thenBranch.hasOneChild()) {
                Node innerIf = thenBranch.getFirstChild();
                if (innerIf.isIf()) {
                    Node innerCond = innerIf.getFirstChild();
                    Node innerThenBranch = innerCond.getNext();
                    Node innerElseBranch = innerThenBranch.getNext();
                    if (innerElseBranch == null && !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {
                        n.detachChildren();
                        n.addChildToBack(IR.and(cond, innerCond.detachFromParent()).srcref(cond));
                        n.addChildrenToBack(innerThenBranch.detachFromParent());
                        reportCodeChange();
                        // the inner IF-ELSE wasn't able to be folded into && anyways.
                        return n;
                    }
                }
            }
        }
        return n;
    }
    /* TODO(dcc) This modifies the siblings of n, which is undesirable for a
     * peephole optimization. This should probably get moved to another pass.
     */
    tryRemoveRepeatedStatements(n);
    // An additional set of curly braces isn't worth it.
    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {
        n.replaceChild(cond, cond.removeFirstChild());
        n.removeChild(thenBranch);
        n.addChildToBack(thenBranch);
        reportCodeChange();
        return n;
    }
    // if(x)return 1;else return 2; -> return x?1:2;
    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {
        Node thenExpr = getBlockReturnExpression(thenBranch);
        Node elseExpr = getBlockReturnExpression(elseBranch);
        n.removeChild(cond);
        thenExpr.detachFromParent();
        elseExpr.detachFromParent();
        // note - we ignore any cases with ""return;"", technically this
        // can be converted to ""return undefined;"" or some variant, but
        // that does not help code size.
        Node returnNode = IR.returnNode(IR.hook(cond, thenExpr, elseExpr).srcref(n));
        parent.replaceChild(n, returnNode);
        reportCodeChange();
        return returnNode;
    }
    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);
    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);
    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {
        Node thenOp = getBlockExpression(thenBranch).getFirstChild();
        Node elseOp = getBlockExpression(elseBranch).getFirstChild();
        if (thenOp.getType() == elseOp.getType()) {
            // if(x)a=1;else a=2; -> a=x?1:2;
            if (NodeUtil.isAssignmentOp(thenOp)) {
                Node lhs = thenOp.getFirstChild();
                if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && // proceed even if there are side effects...
                !mayEffectMutableState(lhs)) {
                    n.removeChild(cond);
                    Node assignName = thenOp.removeFirstChild();
                    Node thenExpr = thenOp.removeFirstChild();
                    Node elseExpr = elseOp.getLastChild();
                    elseOp.removeChild(elseExpr);
                    Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);
                    Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp);
                    Node expr = NodeUtil.newExpr(assign);
                    parent.replaceChild(n, expr);
                    reportCodeChange();
                    return expr;
                }
            }
        }
        // if(x)foo();else bar(); -> x?foo():bar()
        n.removeChild(cond);
        thenOp.detachFromParent();
        elseOp.detachFromParent();
        Node expr = IR.exprResult(IR.hook(cond, thenOp, elseOp).srcref(n));
        parent.replaceChild(n, expr);
        reportCodeChange();
        return expr;
    }
    boolean thenBranchIsVar = isVarBlock(thenBranch);
    boolean elseBranchIsVar = isVarBlock(elseBranch);
    // if(x)var y=1;else y=2  ->  var y=x?1:2
    if (thenBranchIsVar && elseBranchIsExpressionBlock && getBlockExpression(elseBranch).getFirstChild().isAssign()) {
        Node var = getBlockVar(thenBranch);
        Node elseAssign = getBlockExpression(elseBranch).getFirstChild();
        Node name1 = var.getFirstChild();
        Node maybeName2 = elseAssign.getFirstChild();
        if (name1.hasChildren() && maybeName2.isName() && name1.getString().equals(maybeName2.getString())) {
            Node thenExpr = name1.removeChildren();
            Node elseExpr = elseAssign.getLastChild().detachFromParent();
            cond.detachFromParent();
            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);
            var.detachFromParent();
            name1.addChildrenToBack(hookNode);
            parent.replaceChild(n, var);
            reportCodeChange();
            return var;
        }
    // if(x)y=1;else var y=2  ->  var y=x?1:2
    } else if (elseBranchIsVar && thenBranchIsExpressionBlock && getBlockExpression(thenBranch).getFirstChild().isAssign()) {
        Node var = getBlockVar(elseBranch);
        Node thenAssign = getBlockExpression(thenBranch).getFirstChild();
        Node maybeName1 = thenAssign.getFirstChild();
        Node name2 = var.getFirstChild();
        if (name2.hasChildren() && maybeName1.isName() && maybeName1.getString().equals(name2.getString())) {
            Node thenExpr = thenAssign.getLastChild().detachFromParent();
            Node elseExpr = name2.removeChildren();
            cond.detachFromParent();
            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);
            var.detachFromParent();
            name2.addChildrenToBack(hookNode);
            parent.replaceChild(n, var);
            reportCodeChange();
            return var;
        }
    }
    return n;
}","/**
 * Try turning IF nodes into smaller HOOKs
 *
 * Returns the replacement for n or the original if no replacement was
 * necessary.
 */
","private Node tryMinimizeIf(Node n) {
    Node parent = n.getParent();
    Node cond = n.getFirstChild();
        if (NodeUtil.isLiteralValue(cond, true)) {
        return n;
    }
    Node thenBranch = cond.getNext();
    Node elseBranch = thenBranch.getNext();
    if (elseBranch == null) {
        if (isFoldableExpressBlock(thenBranch)) {
            Node expr = getBlockExpression(thenBranch);
            if (!late && isPropertyAssignmentInExpression(expr)) {
                                return n;
            }
            if (cond.isNot()) {
                                if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), OR_PRECEDENCE)) {
                                        return n;
                }
                Node or = IR.or(cond.removeFirstChild(), expr.removeFirstChild()).srcref(n);
                Node newExpr = NodeUtil.newExpr(or);
                parent.replaceChild(n, newExpr);
                reportCodeChange();
                return newExpr;
            }
                        if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), AND_PRECEDENCE)) {
                                return n;
            }
            n.removeChild(cond);
            Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);
            Node newExpr = NodeUtil.newExpr(and);
            parent.replaceChild(n, newExpr);
            reportCodeChange();
            return newExpr;
        } else {
                        if (NodeUtil.isStatementBlock(thenBranch) && thenBranch.hasOneChild()) {
                Node innerIf = thenBranch.getFirstChild();
                if (innerIf.isIf()) {
                    Node innerCond = innerIf.getFirstChild();
                    Node innerThenBranch = innerCond.getNext();
                    Node innerElseBranch = innerThenBranch.getNext();
                    if (innerElseBranch == null && !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {
                        n.detachChildren();
                        n.addChildToBack(IR.and(cond, innerCond.detachFromParent()).srcref(cond));
                        n.addChildrenToBack(innerThenBranch.detachFromParent());
                        reportCodeChange();
                                                return n;
                    }
                }
            }
        }
        return n;
    }
        tryRemoveRepeatedStatements(n);
        if (cond.isNot() && !consumesDanglingElse(elseBranch)) {
        n.replaceChild(cond, cond.removeFirstChild());
        n.removeChild(thenBranch);
        n.addChildToBack(thenBranch);
        reportCodeChange();
        return n;
    }
        if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {
        Node thenExpr = getBlockReturnExpression(thenBranch);
        Node elseExpr = getBlockReturnExpression(elseBranch);
        n.removeChild(cond);
        thenExpr.detachFromParent();
        elseExpr.detachFromParent();
                                Node returnNode = IR.returnNode(IR.hook(cond, thenExpr, elseExpr).srcref(n));
        parent.replaceChild(n, returnNode);
        reportCodeChange();
        return returnNode;
    }
    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);
    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);
    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {
        Node thenOp = getBlockExpression(thenBranch).getFirstChild();
        Node elseOp = getBlockExpression(elseBranch).getFirstChild();
        if (thenOp.getType() == elseOp.getType()) {
                        if (NodeUtil.isAssignmentOp(thenOp)) {
                Node lhs = thenOp.getFirstChild();
                if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&                 !mayEffectMutableState(lhs)) {
                    n.removeChild(cond);
                    Node assignName = thenOp.removeFirstChild();
                    Node thenExpr = thenOp.removeFirstChild();
                    Node elseExpr = elseOp.getLastChild();
                    elseOp.removeChild(elseExpr);
                    Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);
                    Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp);
                    Node expr = NodeUtil.newExpr(assign);
                    parent.replaceChild(n, expr);
                    reportCodeChange();
                    return expr;
                }
            }
        }
                n.removeChild(cond);
        thenOp.detachFromParent();
        elseOp.detachFromParent();
        Node expr = IR.exprResult(IR.hook(cond, thenOp, elseOp).srcref(n));
        parent.replaceChild(n, expr);
        reportCodeChange();
        return expr;
    }
    boolean thenBranchIsVar = isVarBlock(thenBranch);
    boolean elseBranchIsVar = isVarBlock(elseBranch);
        if (thenBranchIsVar && elseBranchIsExpressionBlock && getBlockExpression(elseBranch).getFirstChild().isAssign()) {
        Node var = getBlockVar(thenBranch);
        Node elseAssign = getBlockExpression(elseBranch).getFirstChild();
        Node name1 = var.getFirstChild();
        Node maybeName2 = elseAssign.getFirstChild();
        if (name1.hasChildren() && maybeName2.isName() && name1.getString().equals(maybeName2.getString())) {
            Node thenExpr = name1.removeChildren();
            Node elseExpr = elseAssign.getLastChild().detachFromParent();
            cond.detachFromParent();
            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);
            var.detachFromParent();
            name1.addChildrenToBack(hookNode);
            parent.replaceChild(n, var);
            reportCodeChange();
            return var;
        }
        } else if (elseBranchIsVar && thenBranchIsExpressionBlock && getBlockExpression(thenBranch).getFirstChild().isAssign()) {
        Node var = getBlockVar(elseBranch);
        Node thenAssign = getBlockExpression(thenBranch).getFirstChild();
        Node maybeName1 = thenAssign.getFirstChild();
        Node name2 = var.getFirstChild();
        if (name2.hasChildren() && maybeName1.isName() && maybeName1.getString().equals(name2.getString())) {
            Node thenExpr = thenAssign.getLastChild().detachFromParent();
            Node elseExpr = name2.removeChildren();
            cond.detachFromParent();
            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);
            var.detachFromParent();
            name2.addChildrenToBack(hookNode);
            parent.replaceChild(n, var);
            reportCodeChange();
            return var;
        }
    }
    return n;
}",5.7272727272727275,1.2535885167464116,3.4,1.5,6.5,1.751984126984127,-1.6015503875968988,11.75,-0.02631578947368421,15.945019392241946
wicket,remotes/origin/bugs-dot-jar_WICKET-3563_c62b66c1,1,"/**
 *  Processes components added to the target. This involves attaching components, rendering
 *  markup into a client side xml envelope, and detaching them
 *
 *  @param response
 */
private void respondComponents(Response response) {
    // process component markup
    for (Map.Entry<String, Component> stringComponentEntry : markupIdToComponent.entrySet()) {
        final Component component = stringComponentEntry.getValue();
        if (!containsAncestorFor(component)) {
            respondComponent(response, getAjaxRegionMarkupId(component), component);
        }
    }
    if (header != null) {
        // some header responses buffer all calls to render*** until close is called.
        // when they are closed, they do something (i.e. aggregate all JS resource urls to a
        // single url), and then ""flush"" (by writing to the real response) before closing.
        // to support this, we need to allow header contributions to be written in the close
        // tag, which we do here:
        headerRendering = true;
        // save old response, set new
        Response oldResponse = RequestCycle.get().setResponse(encodingHeaderResponse);
        encodingHeaderResponse.reset();
        // now, close the response (which may render things)
        header.getHeaderResponse().close();
        // revert to old response
        RequestCycle.get().setResponse(oldResponse);
        // write the XML tags and we're done
        writeHeaderContribution(response);
        headerRendering = false;
    }
}","/**
 *  Processes components added to the target. This involves attaching components, rendering
 *  markup into a client side xml envelope, and detaching them
 *
 *  @param response
 */
","private void respondComponents(Response response) {
        for (Map.Entry<String, Component> stringComponentEntry : markupIdToComponent.entrySet()) {
        final Component component = stringComponentEntry.getValue();
        if (!containsAncestorFor(component)) {
            respondComponent(response, getAjaxRegionMarkupId(component), component);
        }
    }
    if (header != null) {
                                                headerRendering = true;
                Response oldResponse = RequestCycle.get().setResponse(encodingHeaderResponse);
        encodingHeaderResponse.reset();
                header.getHeaderResponse().close();
                RequestCycle.get().setResponse(oldResponse);
                writeHeaderContribution(response);
        headerRendering = false;
    }
}",0.13636363636363635,0.04784688995215294,0.0,0.0,0.0,-0.06746031746031747,-0.1557434813248768,0.5833333333333334,-0.02631578947368421,0.015119609504215557
flink,remotes/origin/bugs-dot-jar_FLINK-2874_17e7b423,3,"/**
 *  Checks if the given field is a valid pojo field:
 *  - it is public
 *  OR
 *   - there are getter and setter methods for the field.
 *
 *  @param f field to check
 *  @param clazz class of field
 *  @param typeHierarchy type hierarchy for materializing generic types
 */
private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy) {
    if (Modifier.isPublic(f.getModifiers())) {
        return true;
    } else {
        boolean hasGetter = false, hasSetter = false;
        final String fieldNameLow = f.getName().toLowerCase();
        Type fieldType = f.getGenericType();
        TypeVariable<?> fieldTypeGeneric = null;
        if (fieldType instanceof TypeVariable) {
            fieldTypeGeneric = (TypeVariable<?>) fieldType;
            fieldType = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) fieldType);
        }
        for (Method m : clazz.getMethods()) {
            // check for getter
            if (// The name should be ""get<FieldName>"" or ""<fieldName>"" (for scala) or ""is<fieldName>"" for boolean fields.
            (m.getName().toLowerCase().equals(""get"" + fieldNameLow) || m.getName().toLowerCase().equals(""is"" + fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow)) && // no arguments for the getter
            m.getParameterTypes().length == 0 && // return type is same as field type (or the generic variant of it)
            (m.getGenericReturnType().equals(fieldType) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)))) {
                if (hasGetter) {
                    throw new IllegalStateException(""Detected more than one getter"");
                }
                hasGetter = true;
            }
            // check for setters (<FieldName>_$eq for scala)
            if ((m.getName().toLowerCase().equals(""set"" + fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow + ""_$eq"")) && // one parameter of the field's type
            m.getParameterTypes().length == 1 && (m.getGenericParameterTypes()[0].equals(fieldType) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric))) && // return type is void.
            m.getReturnType().equals(Void.TYPE)) {
                if (hasSetter) {
                    throw new IllegalStateException(""Detected more than one setter"");
                }
                hasSetter = true;
            }
        }
        if (hasGetter && hasSetter) {
            return true;
        } else {
            if (!hasGetter) {
                LOG.debug(clazz + "" does not contain a getter for field "" + f.getName());
            }
            if (!hasSetter) {
                LOG.debug(clazz + "" does not contain a setter for field "" + f.getName());
            }
            return false;
        }
    }
}","/**
 *  Checks if the given field is a valid pojo field:
 *  - it is public
 *  OR
 *   - there are getter and setter methods for the field.
 *
 *  @param f field to check
 *  @param clazz class of field
 *  @param typeHierarchy type hierarchy for materializing generic types
 */
","private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy) {
    if (Modifier.isPublic(f.getModifiers())) {
        return true;
    } else {
        boolean hasGetter = false, hasSetter = false;
        final String fieldNameLow = f.getName().toLowerCase();
        Type fieldType = f.getGenericType();
        TypeVariable<?> fieldTypeGeneric = null;
        if (fieldType instanceof TypeVariable) {
            fieldTypeGeneric = (TypeVariable<?>) fieldType;
            fieldType = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) fieldType);
        }
        for (Method m : clazz.getMethods()) {
                        if (            (m.getName().toLowerCase().equals(""get"" + fieldNameLow) || m.getName().toLowerCase().equals(""is"" + fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow)) &&             m.getParameterTypes().length == 0 &&             (m.getGenericReturnType().equals(fieldType) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)))) {
                if (hasGetter) {
                    throw new IllegalStateException(""Detected more than one getter"");
                }
                hasGetter = true;
            }
                        if ((m.getName().toLowerCase().equals(""set"" + fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow + ""_$eq"")) &&             m.getParameterTypes().length == 1 && (m.getGenericParameterTypes()[0].equals(fieldType) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric))) &&             m.getReturnType().equals(Void.TYPE)) {
                if (hasSetter) {
                    throw new IllegalStateException(""Detected more than one setter"");
                }
                hasSetter = true;
            }
        }
        if (hasGetter && hasSetter) {
            return true;
        } else {
            if (!hasGetter) {
                LOG.debug(clazz + "" does not contain a getter for field "" + f.getName());
            }
            if (!hasSetter) {
                LOG.debug(clazz + "" does not contain a setter for field "" + f.getName());
            }
            return false;
        }
    }
}",1.3636363636363635,0.7033492822966506,1.8,1.0,2.9166666666666665,1.253968253968254,-0.845243128964059,2.6666666666666665,-0.02631578947368421,3.5456671449894244
Collections,25,1,"/**
 * Gets an iterator that provides an ordered iteration over the elements
 * contained in a collection of {@link Iterator}s.
 * <p>
 * Given two ordered {@link Iterator}s <code>A</code> and <code>B</code>,
 * the {@link Iterator#next()} method will return the lesser of
 * <code>A.next()</code> and <code>B.next()</code> and so on.
 * <p>
 * The comparator is optional. If null is specified then natural order is used.
 *
 * @param <E>  the element type
 * @param comparator  the comparator to use, may be null for natural order
 * @param iterators  the iterators to use, not null or empty or contain nulls
 * @return a combination iterator over the iterators
 * @throws NullPointerException if iterators collection is null or contains a null
 * @throws ClassCastException if the iterators collection contains the wrong object type
 */
public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator, final Collection<Iterator<? extends E>> iterators) {
    return new CollatingIterator<E>(comparator, iterators);
}","/**
 * Gets an iterator that provides an ordered iteration over the elements
 * contained in a collection of {@link Iterator}s.
 * <p>
 * Given two ordered {@link Iterator}s <code>A</code> and <code>B</code>,
 * the {@link Iterator#next()} method will return the lesser of
 * <code>A.next()</code> and <code>B.next()</code> and so on.
 * <p>
 * The comparator is optional. If null is specified then natural order is used.
 *
 * @param <E>  the element type
 * @param comparator  the comparator to use, may be null for natural order
 * @param iterators  the iterators to use, not null or empty or contain nulls
 * @return a combination iterator over the iterators
 * @throws NullPointerException if iterators collection is null or contains a null
 * @throws ClassCastException if the iterators collection contains the wrong object type
 */
","public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator, final Collection<Iterator<? extends E>> iterators) {
    return new CollatingIterator<E>(comparator, iterators);
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.8940098661028892,-0.5,0.02631578947368421,-0.16279340490885932
Closure,116,2,"/**
 * Determines whether a function can be inlined at a particular call site.
 * There are several criteria that the function and reference must hold in
 * order for the functions to be inlined:
 * 1) If a call's arguments have side effects,
 * the corresponding argument in the function must only be referenced once.
 * For instance, this will not be inlined:
 * <pre>
 *     function foo(a) { return a + a }
 *     x = foo(i++);
 * </pre>
 */
private CanInlineResult canInlineReferenceDirectly(Node callNode, Node fnNode) {
    if (!isDirectCallNodeReplacementPossible(fnNode)) {
        return CanInlineResult.NO;
    }
    Node block = fnNode.getLastChild();
    // CALL NODE: [ NAME, ARG1, ARG2, ... ]
    Node cArg = callNode.getFirstChild().getNext();
    // parameter list.
    if (!callNode.getFirstChild().isName()) {
        if (NodeUtil.isFunctionObjectCall(callNode)) {
            // TODO(johnlenz): Support replace this with a value.
            if (cArg == null || !cArg.isThis()) {
                return CanInlineResult.NO;
            }
            cArg = cArg.getNext();
        } else {
            // "".apply"" call should be filtered before this.
            Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));
        }
    }
    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]
    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();
    while (cArg != null || fnParam != null) {
        // For each named parameter check if a mutable argument use more than one.
        if (fnParam != null) {
            if (cArg != null) {
                // parameter reference will be in a loop.
                if (NodeUtil.mayEffectMutableState(cArg, compiler) && NodeUtil.getNameReferenceCount(block, fnParam.getString()) > 1) {
                    return CanInlineResult.NO;
                }
            }
            // Move to the next name.
            fnParam = fnParam.getNext();
        }
        // isn't a named parameter to match.
        if (cArg != null) {
            if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {
                return CanInlineResult.NO;
            }
            cArg = cArg.getNext();
        }
    }
    return CanInlineResult.YES;
}","/**
 * Determines whether a function can be inlined at a particular call site.
 * There are several criteria that the function and reference must hold in
 * order for the functions to be inlined:
 * 1) If a call's arguments have side effects,
 * the corresponding argument in the function must only be referenced once.
 * For instance, this will not be inlined:
 * <pre>
 *     function foo(a) { return a + a }
 *     x = foo(i++);
 * </pre>
 */
","private CanInlineResult canInlineReferenceDirectly(Node callNode, Node fnNode) {
    if (!isDirectCallNodeReplacementPossible(fnNode)) {
        return CanInlineResult.NO;
    }
    Node block = fnNode.getLastChild();
        Node cArg = callNode.getFirstChild().getNext();
        if (!callNode.getFirstChild().isName()) {
        if (NodeUtil.isFunctionObjectCall(callNode)) {
                        if (cArg == null || !cArg.isThis()) {
                return CanInlineResult.NO;
            }
            cArg = cArg.getNext();
        } else {
                        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));
        }
    }
        Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();
    while (cArg != null || fnParam != null) {
                if (fnParam != null) {
            if (cArg != null) {
                                if (NodeUtil.mayEffectMutableState(cArg, compiler) && NodeUtil.getNameReferenceCount(block, fnParam.getString()) > 1) {
                    return CanInlineResult.NO;
                }
            }
                        fnParam = fnParam.getNext();
        }
                if (cArg != null) {
            if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {
                return CanInlineResult.NO;
            }
            cArg = cArg.getNext();
        }
    }
    return CanInlineResult.YES;
}",0.9545454545454546,0.8947368421052633,1.4,1.0,1.8333333333333333,1.2619047619047619,-0.6372093023255814,1.0833333333333333,-0.02631578947368421,1.8460192596946798
Compress,43,3,"private void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {
    final boolean encodable = zipEncoding.canEncode(ze.getName());
    final ByteBuffer name = getName(ze);
    if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {
        addUnicodeExtraFields(ze, encodable, name);
    }
    final long localHeaderStart = streamCompressor.getTotalBytesWritten();
    final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);
    metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));
    // At crc offset
    entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET;
    writeCounted(localHeader);
    entry.dataStart = streamCompressor.getTotalBytesWritten();
}",,"private void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {
    final boolean encodable = zipEncoding.canEncode(ze.getName());
    final ByteBuffer name = getName(ze);
    if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {
        addUnicodeExtraFields(ze, encodable, name);
    }
    final long localHeaderStart = streamCompressor.getTotalBytesWritten();
    final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);
    metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));
        entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET;
    writeCounted(localHeader);
    entry.dataStart = streamCompressor.getTotalBytesWritten();
}",-0.045454545454545456,-0.5215311004784691,-0.4,-0.5,-0.25,-0.04563492063492063,-0.04045102184637074,0.4166666666666667,-0.02631578947368421,0.056621888740973805
Closure,153,2,"private void scanRoot(Node n, Scope parent) {
    if (n.getType() == Token.FUNCTION) {
        sourceName = (String) n.getProp(Node.SOURCENAME_PROP);
        final Node fnNameNode = n.getFirstChild();
        final Node args = fnNameNode.getNext();
        final Node body = args.getNext();
        // Bleed the function name into the scope, if it hasn't
        // been declared in the outer scope.
        String fnName = fnNameNode.getString();
        if (!fnName.isEmpty() && NodeUtil.isFunctionExpression(n)) {
            declareVar(fnName, fnNameNode, n, null, null, n);
        }
        // Args: Declare function variables
        Preconditions.checkState(args.getType() == Token.LP);
        for (Node a = args.getFirstChild(); a != null; a = a.getNext()) {
            Preconditions.checkState(a.getType() == Token.NAME);
            declareVar(a.getString(), a, args, n, null, n);
        }
        // Body
        scanVars(body, n);
    } else {
        // It's the global block
        Preconditions.checkState(scope.getParent() == null);
        scanVars(n, null);
    }
}",,"private void scanRoot(Node n, Scope parent) {
    if (n.getType() == Token.FUNCTION) {
        sourceName = (String) n.getProp(Node.SOURCENAME_PROP);
        final Node fnNameNode = n.getFirstChild();
        final Node args = fnNameNode.getNext();
        final Node body = args.getNext();
                        String fnName = fnNameNode.getString();
        if (!fnName.isEmpty() && NodeUtil.isFunctionExpression(n)) {
            declareVar(fnName, fnNameNode, n, null, null, n);
        }
                Preconditions.checkState(args.getType() == Token.LP);
        for (Node a = args.getFirstChild(); a != null; a = a.getNext()) {
            Preconditions.checkState(a.getType() == Token.NAME);
            declareVar(a.getString(), a, args, n, null, n);
        }
                scanVars(body, n);
    } else {
                Preconditions.checkState(scope.getParent() == null);
        scanVars(n, null);
    }
}",0.3181818181818182,0.09090909090909088,0.0,0.0,0.3333333333333333,0.6448412698412699,-0.35362931642001405,1.25,-0.02631578947368421,1.0443042132743208
wicket,remotes/origin/bugs-dot-jar_WICKET-5476_813d8bee,3,"/**
 *  @see Component#onComponentTag(ComponentTag)
 *  @param tag
 *             the abstraction representing html tag of this component
 */
@Override
protected void onComponentTag(final ComponentTag tag) {
    // Default handling for component tag
    super.onComponentTag(tag);
    // must be attached to <input type=""checkbox"" .../> tag
    checkComponentTag(tag, ""input"");
    checkComponentTagAttribute(tag, ""type"", ""checkbox"");
    CheckGroup<?> group = getGroup();
    final String uuid = getValue();
    // assign name and value
    tag.put(""name"", group.getInputName());
    tag.put(""value"", uuid);
    // check if the model collection of the group contains the model object.
    // if it does check the check box.
    Collection<?> collection = (Collection<?>) group.getDefaultModelObject();
    // check for npe in group's model object
    if (collection == null) {
        throw new WicketRuntimeException(""CheckGroup ["" + group.getPath() + ""] contains a null model object, must be an object of type java.util.Collection"");
    }
    if (group.hasRawInput()) {
        final String raw = group.getRawInput();
        if (!Strings.isEmpty(raw)) {
            final String[] values = raw.split(FormComponent.VALUE_SEPARATOR);
            for (String value : values) {
                if (uuid.equals(value)) {
                    tag.put(""checked"", ""checked"");
                }
            }
        }
    } else if (collection.contains(getDefaultModelObject())) {
        tag.put(""checked"", ""checked"");
    }
    if (group.wantOnSelectionChangedNotifications()) {
        // url that points to this components IOnChangeListener method
        CharSequence url = group.urlFor(IOnChangeListener.INTERFACE, new PageParameters());
        Form<?> form = group.findParent(Form.class);
        if (form != null) {
            tag.put(""onclick"", form.getJsForInterfaceUrl(url));
        } else {
            // NOTE: do not encode the url as that would give invalid JavaScript
            tag.put(""onclick"", ""window.location.href='"" + url + (url.toString().indexOf('?') > -1 ? ""&"" : ""?"") + group.getInputName() + ""=' + this.value;"");
        }
    }
    if (!isActionAuthorized(ENABLE) || !isEnabledInHierarchy() || !group.isEnabledInHierarchy()) {
        tag.put(ATTR_DISABLED, ATTR_DISABLED);
    }
    // put group id into the class so we can easily identify all radios belonging to the group
    final String marker = ""wicket-"" + getGroup().getMarkupId();
    String clazz = tag.getAttribute(""class"");
    if (Strings.isEmpty(clazz)) {
        clazz = marker;
    } else {
        clazz = clazz + "" "" + marker;
    }
    tag.put(""class"", clazz);
}","/**
 *  @see Component#onComponentTag(ComponentTag)
 *  @param tag
 *             the abstraction representing html tag of this component
 */
","@Override
protected void onComponentTag(final ComponentTag tag) {
        super.onComponentTag(tag);
        checkComponentTag(tag, ""input"");
    checkComponentTagAttribute(tag, ""type"", ""checkbox"");
    CheckGroup<?> group = getGroup();
    final String uuid = getValue();
        tag.put(""name"", group.getInputName());
    tag.put(""value"", uuid);
            Collection<?> collection = (Collection<?>) group.getDefaultModelObject();
        if (collection == null) {
        throw new WicketRuntimeException(""CheckGroup ["" + group.getPath() + ""] contains a null model object, must be an object of type java.util.Collection"");
    }
    if (group.hasRawInput()) {
        final String raw = group.getRawInput();
        if (!Strings.isEmpty(raw)) {
            final String[] values = raw.split(FormComponent.VALUE_SEPARATOR);
            for (String value : values) {
                if (uuid.equals(value)) {
                    tag.put(""checked"", ""checked"");
                }
            }
        }
    } else if (collection.contains(getDefaultModelObject())) {
        tag.put(""checked"", ""checked"");
    }
    if (group.wantOnSelectionChangedNotifications()) {
                CharSequence url = group.urlFor(IOnChangeListener.INTERFACE, new PageParameters());
        Form<?> form = group.findParent(Form.class);
        if (form != null) {
            tag.put(""onclick"", form.getJsForInterfaceUrl(url));
        } else {
                        tag.put(""onclick"", ""window.location.href='"" + url + (url.toString().indexOf('?') > -1 ? ""&"" : ""?"") + group.getInputName() + ""=' + this.value;"");
        }
    }
    if (!isActionAuthorized(ENABLE) || !isEnabledInHierarchy() || !group.isEnabledInHierarchy()) {
        tag.put(ATTR_DISABLED, ATTR_DISABLED);
    }
        final String marker = ""wicket-"" + getGroup().getMarkupId();
    String clazz = tag.getAttribute(""class"");
    if (Strings.isEmpty(clazz)) {
        clazz = marker;
    } else {
        clazz = clazz + "" "" + marker;
    }
    tag.put(""class"", clazz);
}",1.5,0.5598086124401914,1.8,1.0,1.9166666666666667,1.2440476190476188,-0.8835799859055671,2.5833333333333335,-0.02631578947368421,3.740440172196193
wicket,remotes/origin/bugs-dot-jar_WICKET-4658_ef3adb12,3,"@Override
public boolean isVisible() {
    return getTabs().get(tabIndex).isVisible();
}",,"@Override
public boolean isVisible() {
    return getTabs().get(tabIndex).isVisible();
}",-0.45454545454545453,-0.6028708133971293,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.9134601832276249,-0.25,1.3947368421052633,-0.16279340490885932
wicket,remotes/origin/bugs-dot-jar_WICKET-428_4a6a573b,3,"/**
 *  @see java.util.Map#keySet()
 */
public Set keySet() {
    return new AbstractSet() {

        public Iterator iterator() {
            return new Iterator() {

                public boolean hasNext() {
                    return i < size;
                }

                public Object next() {
                    // Find next key
                    i = nextKey(nextIndex(i));
                    // Just in case... (WICKET-428)
                    if (!hasNext()) {
                        throw new NoSuchElementException();
                    }
                    // Get key
                    return keys[i];
                }

                public void remove() {
                    keys[i] = null;
                    values[i] = null;
                    size--;
                }

                int i = -1;
            };
        }

        public int size() {
            return size;
        }
    };
}","/**
 *  @see java.util.Map#keySet()
 */
","public Set keySet() {
    return new AbstractSet() {

        public Iterator iterator() {
            return new Iterator() {

                public boolean hasNext() {
                    return i < size;
                }

                public Object next() {
                                        i = nextKey(nextIndex(i));
                                        if (!hasNext()) {
                        throw new NoSuchElementException();
                    }
                                        return keys[i];
                }

                public void remove() {
                    keys[i] = null;
                    values[i] = null;
                    size--;
                }

                int i = -1;
            };
        }

        public int size() {
            return size;
        }
    };
}",0.5909090909090909,1.708133971291866,-0.2,0.5,-0.25,0.30357142857142855,-0.31078224101479923,-0.25,1.9210526315789473,0.12201494902693011
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2359_b3071839,0,"/**
 * Get the earliest (oldest) revision where the node was alive at or before
 * the provided revision, if the node was alive at the given revision.
 *
 * @param context the revision context
 * @param maxRev the maximum revision to return
 * @param validRevisions the map of revisions to commit value already
 *                       checked against maxRev and considered valid.
 * @param lastRevs to keep track of the last modification.
 * @return the earliest revision, or null if the node is deleted at the
 *         given revision
 */
@CheckForNull
public Revision getLiveRevision(RevisionContext context, Revision maxRev, Map<Revision, String> validRevisions, LastRevs lastRevs) {
    // check local deleted map first
    Value value = getLatestValue(context, getLocalDeleted(), null, maxRev, validRevisions, lastRevs);
    if (value == null && !getPreviousRanges().isEmpty()) {
        // need to check complete map
        value = getLatestValue(context, getDeleted(), null, maxRev, validRevisions, lastRevs);
    }
    return value != null && ""false"".equals(value.value) ? value.revision : null;
}","/**
 * Get the earliest (oldest) revision where the node was alive at or before
 * the provided revision, if the node was alive at the given revision.
 *
 * @param context the revision context
 * @param maxRev the maximum revision to return
 * @param validRevisions the map of revisions to commit value already
 *                       checked against maxRev and considered valid.
 * @param lastRevs to keep track of the last modification.
 * @return the earliest revision, or null if the node is deleted at the
 *         given revision
 */
","@CheckForNull
public Revision getLiveRevision(RevisionContext context, Revision maxRev, Map<Revision, String> validRevisions, LastRevs lastRevs) {
        Value value = getLatestValue(context, getLocalDeleted(), null, maxRev, validRevisions, lastRevs);
    if (value == null && !getPreviousRanges().isEmpty()) {
                value = getLatestValue(context, getDeleted(), null, maxRev, validRevisions, lastRevs);
    }
    return value != null && ""false"".equals(value.value) ? value.revision : null;
}",-0.2727272727272727,-0.16267942583732073,-0.2,-0.5,0.25,0.3948412698412698,0.20197322057787187,0.08333333333333333,-0.02631578947368421,0.26968413409173414
Lang,3,3,"// -----------------------------------------------------------------------
// must handle Long, Float, Integer, Float, Short,
// BigDecimal, BigInteger and Byte
// useful methods:
// Byte.decode(String)
// Byte.valueOf(String,int radix)
// Byte.valueOf(String)
// Double.valueOf(String)
// Float.valueOf(String)
// Float.valueOf(String)
// Integer.valueOf(String,int radix)
// Integer.valueOf(String)
// Integer.decode(String)
// Integer.getInteger(String)
// Integer.getInteger(String,int val)
// Integer.getInteger(String,Integer val)
// Integer.valueOf(String)
// Double.valueOf(String)
// new Byte(String)
// Long.valueOf(String)
// Long.getLong(String)
// Long.getLong(String,int)
// Long.getLong(String,Integer)
// Long.valueOf(String,int)
// Long.valueOf(String)
// Short.valueOf(String)
// Short.decode(String)
// Short.valueOf(String,int)
// Short.valueOf(String)
// new BigDecimal(String)
// new BigInteger(String)
// new BigInteger(String,int radix)
// Possible inputs:
// 45 45.5 45E7 4.5E7 Hex Oct Binary xxxF xxxD xxxf xxxd
// plus minus everything. Prolly more. A lot are not separable.
/**
 * <p>Turns a string value into a java.lang.Number.</p>
 *
 * <p>If the string starts with {@code 0x} or {@code -0x} (lower or upper case) or {@code #} or {@code -#}, it
 * will be interpreted as a hexadecimal Integer - or Long, if the number of digits after the
 * prefix is more than 8 - or BigInteger if there are more than 16 digits.
 * </p>
 * <p>Then, the value is examined for a type qualifier on the end, i.e. one of
 * <code>'f','F','d','D','l','L'</code>.  If it is found, it starts
 * trying to create successively larger types from the type specified
 * until one is found that can represent the value.</p>
 *
 * <p>If a type specifier is not found, it will check for a decimal point
 * and then try successively larger types from <code>Integer</code> to
 * <code>BigInteger</code> and from <code>Float</code> to
 * <code>BigDecimal</code>.</p>
 *
 * <p>
 * Integral values with a leading {@code 0} will be interpreted as octal; the returned number will
 * be Integer, Long or BigDecimal as appropriate.
 * </p>
 *
 * <p>Returns <code>null</code> if the string is <code>null</code>.</p>
 *
 * <p>This method does not trim the input string, i.e., strings with leading
 * or trailing spaces will generate NumberFormatExceptions.</p>
 *
 * @param str  String containing a number, may be null
 * @return Number created from the string (or null if the input is null)
 * @throws NumberFormatException if the value cannot be converted
 */
public static Number createNumber(final String str) throws NumberFormatException {
    if (str == null) {
        return null;
    }
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }
    // Need to deal with all possible hex prefixes here
    final String[] hex_prefixes = { ""0x"", ""0X"", ""-0x"", ""-0X"", ""#"", ""-#"" };
    int pfxLen = 0;
    for (final String pfx : hex_prefixes) {
        if (str.startsWith(pfx)) {
            pfxLen += pfx.length();
            break;
        }
    }
    if (pfxLen > 0) {
        // we have a hex number
        final int hexDigits = str.length() - pfxLen;
        if (hexDigits > 16) {
            // too many for Long
            return createBigInteger(str);
        }
        if (hexDigits > 8) {
            // too many for an int
            return createLong(str);
        }
        return createInteger(str);
    }
    final char lastChar = str.charAt(str.length() - 1);
    String mant;
    String dec;
    String exp;
    final int decPos = str.indexOf('.');
    // assumes both not present
    final int expPos = str.indexOf('e') + str.indexOf('E') + 1;
    // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)
    // and the parsing which will detect if e or E appear in a number due to using the wrong offset
    // Check required precision (LANG-693)
    int numDecimals = 0;
    if (decPos > -1) {
        if (expPos > -1) {
            // there is an exponent
            if (expPos < decPos || expPos > str.length()) {
                // prevents double exponent causing IOOBE
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            dec = str.substring(decPos + 1, expPos);
        } else {
            dec = str.substring(decPos + 1);
        }
        mant = str.substring(0, decPos);
        // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.
        numDecimals = dec.length();
    } else {
        if (expPos > -1) {
            if (expPos > str.length()) {
                // prevents double exponent causing IOOBE
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            mant = str.substring(0, expPos);
        } else {
            mant = str;
        }
        dec = null;
    }
    if (!Character.isDigit(lastChar) && lastChar != '.') {
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length() - 1);
        } else {
            exp = null;
        }
        // Requesting a specific type..
        final String numeric = str.substring(0, str.length() - 1);
        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
        switch(lastChar) {
            case 'l':
            case 'L':
                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                    try {
                        return createLong(numeric);
                    } catch (final NumberFormatException nfe) {
                    // NOPMD
                    // Too big for a long
                    }
                    return createBigInteger(numeric);
                }
                throw new NumberFormatException(str + "" is not a valid number."");
            case 'f':
            case 'F':
                try {
                    final Float f = NumberUtils.createFloat(numeric);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        // has non-zeros in it, then float does not have the precision we want
                        return f;
                    }
                } catch (final NumberFormatException nfe) {
                // NOPMD
                // ignore the bad number
                }
            // $FALL-THROUGH$
            case 'd':
            case 'D':
                try {
                    final Double d = NumberUtils.createDouble(numeric);
                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (final NumberFormatException nfe) {
                // NOPMD
                // ignore the bad number
                }
                try {
                    return createBigDecimal(numeric);
                } catch (final NumberFormatException e) {
                // NOPMD
                // ignore the bad number
                }
            // $FALL-THROUGH$
            default:
                throw new NumberFormatException(str + "" is not a valid number."");
        }
    }
    // small and go from there...
    if (expPos > -1 && expPos < str.length() - 1) {
        exp = str.substring(expPos + 1, str.length());
    } else {
        exp = null;
    }
    if (dec == null && exp == null) {
        // Must be an Integer, Long, Biginteger
        try {
            return createInteger(str);
        } catch (final NumberFormatException nfe) {
        // NOPMD
        // ignore the bad number
        }
        try {
            return createLong(str);
        } catch (final NumberFormatException nfe) {
        // NOPMD
        // ignore the bad number
        }
        return createBigInteger(str);
    }
    // Must be a Float, Double, BigDecimal
    final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
    try {
        final Float f = createFloat(str);
        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
            return f;
        }
    } catch (final NumberFormatException nfe) {
    // NOPMD
    // ignore the bad number
    }
    try {
        final Double d = createDouble(str);
        if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
            return d;
        }
    } catch (final NumberFormatException nfe) {
    // NOPMD
    // ignore the bad number
    }
    return createBigDecimal(str);
}","/**
 * <p>Turns a string value into a java.lang.Number.</p>
 *
 * <p>If the string starts with {@code 0x} or {@code -0x} (lower or upper case) or {@code #} or {@code -#}, it
 * will be interpreted as a hexadecimal Integer - or Long, if the number of digits after the
 * prefix is more than 8 - or BigInteger if there are more than 16 digits.
 * </p>
 * <p>Then, the value is examined for a type qualifier on the end, i.e. one of
 * <code>'f','F','d','D','l','L'</code>.  If it is found, it starts
 * trying to create successively larger types from the type specified
 * until one is found that can represent the value.</p>
 *
 * <p>If a type specifier is not found, it will check for a decimal point
 * and then try successively larger types from <code>Integer</code> to
 * <code>BigInteger</code> and from <code>Float</code> to
 * <code>BigDecimal</code>.</p>
 *
 * <p>
 * Integral values with a leading {@code 0} will be interpreted as octal; the returned number will
 * be Integer, Long or BigDecimal as appropriate.
 * </p>
 *
 * <p>Returns <code>null</code> if the string is <code>null</code>.</p>
 *
 * <p>This method does not trim the input string, i.e., strings with leading
 * or trailing spaces will generate NumberFormatExceptions.</p>
 *
 * @param str  String containing a number, may be null
 * @return Number created from the string (or null if the input is null)
 * @throws NumberFormatException if the value cannot be converted
 */
","public static Number createNumber(final String str) throws NumberFormatException {
    if (str == null) {
        return null;
    }
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }
        final String[] hex_prefixes = { ""0x"", ""0X"", ""-0x"", ""-0X"", ""#"", ""-#"" };
    int pfxLen = 0;
    for (final String pfx : hex_prefixes) {
        if (str.startsWith(pfx)) {
            pfxLen += pfx.length();
            break;
        }
    }
    if (pfxLen > 0) {
                final int hexDigits = str.length() - pfxLen;
        if (hexDigits > 16) {
                        return createBigInteger(str);
        }
        if (hexDigits > 8) {
                        return createLong(str);
        }
        return createInteger(str);
    }
    final char lastChar = str.charAt(str.length() - 1);
    String mant;
    String dec;
    String exp;
    final int decPos = str.indexOf('.');
        final int expPos = str.indexOf('e') + str.indexOf('E') + 1;
                int numDecimals = 0;
    if (decPos > -1) {
        if (expPos > -1) {
                        if (expPos < decPos || expPos > str.length()) {
                                throw new NumberFormatException(str + "" is not a valid number."");
            }
            dec = str.substring(decPos + 1, expPos);
        } else {
            dec = str.substring(decPos + 1);
        }
        mant = str.substring(0, decPos);
                numDecimals = dec.length();
    } else {
        if (expPos > -1) {
            if (expPos > str.length()) {
                                throw new NumberFormatException(str + "" is not a valid number."");
            }
            mant = str.substring(0, expPos);
        } else {
            mant = str;
        }
        dec = null;
    }
    if (!Character.isDigit(lastChar) && lastChar != '.') {
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length() - 1);
        } else {
            exp = null;
        }
                final String numeric = str.substring(0, str.length() - 1);
        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
        switch(lastChar) {
            case 'l':
            case 'L':
                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                    try {
                        return createLong(numeric);
                    } catch (final NumberFormatException nfe) {
                                                            }
                    return createBigInteger(numeric);
                }
                throw new NumberFormatException(str + "" is not a valid number."");
            case 'f':
            case 'F':
                try {
                    final Float f = NumberUtils.createFloat(numeric);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                                                return f;
                    }
                } catch (final NumberFormatException nfe) {
                                                }
                        case 'd':
            case 'D':
                try {
                    final Double d = NumberUtils.createDouble(numeric);
                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (final NumberFormatException nfe) {
                                                }
                try {
                    return createBigDecimal(numeric);
                } catch (final NumberFormatException e) {
                                                }
                        default:
                throw new NumberFormatException(str + "" is not a valid number."");
        }
    }
        if (expPos > -1 && expPos < str.length() - 1) {
        exp = str.substring(expPos + 1, str.length());
    } else {
        exp = null;
    }
    if (dec == null && exp == null) {
                try {
            return createInteger(str);
        } catch (final NumberFormatException nfe) {
                        }
        try {
            return createLong(str);
        } catch (final NumberFormatException nfe) {
                        }
        return createBigInteger(str);
    }
        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
    try {
        final Float f = createFloat(str);
        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
            return f;
        }
    } catch (final NumberFormatException nfe) {
            }
    try {
        final Double d = createDouble(str);
        if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
            return d;
        }
    } catch (final NumberFormatException nfe) {
            }
    return createBigDecimal(str);
}",5.363636363636363,1.1866028708133969,7.8,1.5,5.166666666666667,3.7777777777777777,-1.6723044397462996,4.083333333333333,-0.02631578947368421,23.020590930308945
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1225_3535afe2,1,"/**
 * Returns the property at the specified absolute path in the workspace or
 * {@code null} if no such node exists.
 *
 * @param absPath An absolute path.
 * @return the specified {@code Property} or {@code null}.
 * @throws RepositoryException if another error occurs.
 */
@CheckForNull
public Property getPropertyOrNull(final String absPath) throws RepositoryException {
    if (absPath.equals(""/"")) {
        return null;
    } else {
        final String oakPath = getOakPathOrThrow(absPath);
        return perform(new ReadOperation<Property>() {

            @Override
            public Property perform() throws RepositoryException {
                PropertyDelegate pd = sd.getProperty(oakPath);
                if (pd != null) {
                    return new PropertyImpl(pd, sessionContext);
                } else {
                    return null;
                }
            }
        });
    }
}","/**
 * Returns the property at the specified absolute path in the workspace or
 * {@code null} if no such node exists.
 *
 * @param absPath An absolute path.
 * @return the specified {@code Property} or {@code null}.
 * @throws RepositoryException if another error occurs.
 */
","@CheckForNull
public Property getPropertyOrNull(final String absPath) throws RepositoryException {
    if (absPath.equals(""/"")) {
        return null;
    } else {
        final String oakPath = getOakPathOrThrow(absPath);
        return perform(new ReadOperation<Property>() {

            @Override
            public Property perform() throws RepositoryException {
                PropertyDelegate pd = sd.getProperty(oakPath);
                if (pd != null) {
                    return new PropertyImpl(pd, sessionContext);
                } else {
                    return null;
                }
            }
        });
    }
}",0.22727272727272727,1.6315789473684212,-0.2,0.5,-0.08333333333333333,-0.053571428571428575,-0.13291050035236088,-0.16666666666666666,0.8421052631578947,-0.04481480841156504
flink,remotes/origin/bugs-dot-jar_FLINK-1978_0078c44e,1,"@Override
@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
public T copy(T from, T reuse) {
    if (from == null) {
        return null;
    }
    Class<?> actualType = from.getClass();
    if (reuse == null || actualType != reuse.getClass()) {
        // cannot reuse, do a non-reuse copy
        return copy(from);
    }
    if (actualType == clazz) {
        try {
            for (int i = 0; i < numFields; i++) {
                Object value = fields[i].get(from);
                if (value != null) {
                    Object copy = fieldSerializers[i].copy(fields[i].get(from), fields[i].get(reuse));
                    fields[i].set(reuse, copy);
                } else {
                    fields[i].set(reuse, null);
                }
            }
        } catch (IllegalAccessException e) {
            throw new RuntimeException(""Error during POJO copy, this should not happen since we check the fields"" + ""before."");
        }
    } else {
        TypeSerializer subclassSerializer = getSubclassSerializer(actualType);
        reuse = (T) subclassSerializer.copy(from, reuse);
    }
    return reuse;
}",,"@Override
@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
public T copy(T from, T reuse) {
    if (from == null) {
        return null;
    }
    Class<?> actualType = from.getClass();
    if (reuse == null || actualType != reuse.getClass()) {
                return copy(from);
    }
    if (actualType == clazz) {
        try {
            for (int i = 0; i < numFields; i++) {
                Object value = fields[i].get(from);
                if (value != null) {
                    Object copy = fieldSerializers[i].copy(fields[i].get(from), fields[i].get(reuse));
                    fields[i].set(reuse, copy);
                } else {
                    fields[i].set(reuse, null);
                }
            }
        } catch (IllegalAccessException e) {
            throw new RuntimeException(""Error during POJO copy, this should not happen since we check the fields"" + ""before."");
        }
    } else {
        TypeSerializer subclassSerializer = getSubclassSerializer(actualType);
        reuse = (T) subclassSerializer.copy(from, reuse);
    }
    return reuse;
}",0.7272727272727273,1.5071770334928227,0.8,1.0,0.75,1.152777777777778,-0.5365750528541224,0.4166666666666667,-0.02631578947368421,1.5759501622263328
wicket,remotes/origin/bugs-dot-jar_WICKET-5071_faaae8d3,1,"/**
 *  Matches when the request url starts with
 *  {@link org.apache.wicket.core.request.mapper.IMapperContext#getNamespace()}/{@link org.apache.wicket.core.request.mapper.IMapperContext#getPageIdentifier()}
 *  or when the base url starts with
 *  {@link org.apache.wicket.core.request.mapper.IMapperContext#getNamespace()}/{@link org.apache.wicket.core.request.mapper.IMapperContext#getPageIdentifier()}
 *  and the request url with {@link org.apache.wicket.core.request.mapper.IMapperContext#getPageIdentifier()}
 *
 *  @param request
 *       the request to check
 *  @return {@code true} if the conditions match
 */
private boolean matches(final Request request) {
    boolean matches = false;
    Url url = request.getUrl();
    String namespace = getContext().getNamespace();
    String pageIdentifier = getContext().getPageIdentifier();
    if (urlStartsWith(url, namespace, pageIdentifier)) {
        matches = true;
    } else if (urlStartsWith(request.getClientUrl(), namespace, pageIdentifier) && urlStartsWith(url, pageIdentifier)) {
        matches = true;
    } else if (urlStartsWith(request.getClientUrl(), pageIdentifier) && urlStartsWith(url, pageIdentifier)) {
        matches = true;
    }
    return matches;
}","/**
 *  Matches when the request url starts with
 *  {@link org.apache.wicket.core.request.mapper.IMapperContext#getNamespace()}/{@link org.apache.wicket.core.request.mapper.IMapperContext#getPageIdentifier()}
 *  or when the base url starts with
 *  {@link org.apache.wicket.core.request.mapper.IMapperContext#getNamespace()}/{@link org.apache.wicket.core.request.mapper.IMapperContext#getPageIdentifier()}
 *  and the request url with {@link org.apache.wicket.core.request.mapper.IMapperContext#getPageIdentifier()}
 *
 *  @param request
 *       the request to check
 *  @return {@code true} if the conditions match
 */
","private boolean matches(final Request request) {
    boolean matches = false;
    Url url = request.getUrl();
    String namespace = getContext().getNamespace();
    String pageIdentifier = getContext().getPageIdentifier();
    if (urlStartsWith(url, namespace, pageIdentifier)) {
        matches = true;
    } else if (urlStartsWith(request.getClientUrl(), namespace, pageIdentifier) && urlStartsWith(url, pageIdentifier)) {
        matches = true;
    } else if (urlStartsWith(request.getClientUrl(), pageIdentifier) && urlStartsWith(url, pageIdentifier)) {
        matches = true;
    }
    return matches;
}",0.0,-0.29665071770334933,0.0,0.5,0.6666666666666666,0.14880952380952375,-0.047498238195912666,0.5,-0.02631578947368421,0.10586031822870742
wicket,remotes/origin/bugs-dot-jar_WICKET-5071_faaae8d3,1,"private boolean matches(final Request request) {
    boolean matches = false;
    Url url = request.getUrl();
    Url baseUrl = request.getClientUrl();
    String namespace = getContext().getNamespace();
    String bookmarkableIdentifier = getContext().getBookmarkableIdentifier();
    String pageIdentifier = getContext().getPageIdentifier();
    if (url.getSegments().size() >= 3 && urlStartsWith(url, namespace, bookmarkableIdentifier)) {
        matches = true;
    } else // baseUrl = 'wicket/bookmarkable/com.example.SomePage[?...]', requestUrl = 'bookmarkable/com.example.SomePage'
    if (baseUrl.getSegments().size() == 3 && urlStartsWith(baseUrl, namespace, bookmarkableIdentifier) && url.getSegments().size() >= 2 && urlStartsWith(url, bookmarkableIdentifier)) {
        matches = true;
    } else // baseUrl = 'wicket/page[?...]', requestUrl = 'bookmarkable/com.example.SomePage'
    if (baseUrl.getSegments().size() == 2 && urlStartsWith(baseUrl, namespace, pageIdentifier) && url.getSegments().size() >= 2 && urlStartsWith(url, bookmarkableIdentifier)) {
        matches = true;
    }
    return matches;
}",,"private boolean matches(final Request request) {
    boolean matches = false;
    Url url = request.getUrl();
    Url baseUrl = request.getClientUrl();
    String namespace = getContext().getNamespace();
    String bookmarkableIdentifier = getContext().getBookmarkableIdentifier();
    String pageIdentifier = getContext().getPageIdentifier();
    if (url.getSegments().size() >= 3 && urlStartsWith(url, namespace, bookmarkableIdentifier)) {
        matches = true;
    } else     if (baseUrl.getSegments().size() == 3 && urlStartsWith(baseUrl, namespace, bookmarkableIdentifier) && url.getSegments().size() >= 2 && urlStartsWith(url, bookmarkableIdentifier)) {
        matches = true;
    } else     if (baseUrl.getSegments().size() == 2 && urlStartsWith(baseUrl, namespace, pageIdentifier) && url.getSegments().size() >= 2 && urlStartsWith(url, bookmarkableIdentifier)) {
        matches = true;
    }
    return matches;
}",0.18181818181818182,-0.4258373205741628,0.0,0.5,1.3333333333333333,0.8095238095238095,-0.26116983791402393,1.4166666666666667,-0.02631578947368421,1.0436403243374077
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1505_b082fc1e,1,"synchronized void addMutation(Mutation m) {
    long now = System.currentTimeMillis();
    mutationCount++;
    for (ColumnUpdate u : m.getUpdates()) {
        Key key = new Key(m.getRow(), 0, m.getRow().length, u.getColumnFamily(), 0, u.getColumnFamily().length, u.getColumnQualifier(), 0, u.getColumnQualifier().length, u.getColumnVisibility(), 0, u.getColumnVisibility().length, u.getTimestamp());
        if (u.isDeleted())
            key.setDeleted(true);
        if (!u.hasTimestamp())
            if (timeType.equals(TimeType.LOGICAL))
                key.setTimestamp(mutationCount);
            else
                key.setTimestamp(now);
        table.put(new MockMemKey(key, mutationCount), new Value(u.getValue()));
    }
}",,"synchronized void addMutation(Mutation m) {
    long now = System.currentTimeMillis();
    mutationCount++;
    for (ColumnUpdate u : m.getUpdates()) {
        Key key = new Key(m.getRow(), 0, m.getRow().length, u.getColumnFamily(), 0, u.getColumnFamily().length, u.getColumnQualifier(), 0, u.getColumnQualifier().length, u.getColumnVisibility(), 0, u.getColumnVisibility().length, u.getTimestamp());
        if (u.isDeleted())
            key.setDeleted(true);
        if (!u.hasTimestamp())
            if (timeType.equals(TimeType.LOGICAL))
                key.setTimestamp(mutationCount);
            else
                key.setTimestamp(now);
        table.put(new MockMemKey(key, mutationCount), new Value(u.getValue()));
    }
}",0.045454545454545456,0.937799043062201,0.2,-0.5,0.08333333333333333,0.019841269841269816,-0.15630725863284003,1.0833333333333333,-0.02631578947368421,0.16355872132224544
Closure,2,2,"/**
 * Check whether there's any property conflict for for a particular super
 * interface
 * @param t The node traversal object that supplies context
 * @param n The node being visited
 * @param functionName The function name being checked
 * @param properties The property names in the super interfaces that have
 * been visited
 * @param currentProperties The property names in the super interface
 * that have been visited
 * @param interfaceType The super interface that is being visited
 */
private void checkInterfaceConflictProperties(NodeTraversal t, Node n, String functionName, HashMap<String, ObjectType> properties, HashMap<String, ObjectType> currentProperties, ObjectType interfaceType) {
    ObjectType implicitProto = interfaceType.getImplicitPrototype();
    Set<String> currentPropertyNames;
    // This can be the case if interfaceType is proxy to a non-existent
    // object (which is a bad type annotation, but shouldn't crash).
    currentPropertyNames = implicitProto.getOwnPropertyNames();
    for (String name : currentPropertyNames) {
        ObjectType oType = properties.get(name);
        if (oType != null) {
            if (!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))) {
                compiler.report(t.makeError(n, INCOMPATIBLE_EXTENDED_PROPERTY_TYPE, functionName, name, oType.toString(), interfaceType.toString()));
            }
        }
        currentProperties.put(name, interfaceType);
    }
    for (ObjectType iType : interfaceType.getCtorExtendedInterfaces()) {
        checkInterfaceConflictProperties(t, n, functionName, properties, currentProperties, iType);
    }
}","/**
 * Check whether there's any property conflict for for a particular super
 * interface
 * @param t The node traversal object that supplies context
 * @param n The node being visited
 * @param functionName The function name being checked
 * @param properties The property names in the super interfaces that have
 * been visited
 * @param currentProperties The property names in the super interface
 * that have been visited
 * @param interfaceType The super interface that is being visited
 */
","private void checkInterfaceConflictProperties(NodeTraversal t, Node n, String functionName, HashMap<String, ObjectType> properties, HashMap<String, ObjectType> currentProperties, ObjectType interfaceType) {
    ObjectType implicitProto = interfaceType.getImplicitPrototype();
    Set<String> currentPropertyNames;
            currentPropertyNames = implicitProto.getOwnPropertyNames();
    for (String name : currentPropertyNames) {
        ObjectType oType = properties.get(name);
        if (oType != null) {
            if (!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))) {
                compiler.report(t.makeError(n, INCOMPATIBLE_EXTENDED_PROPERTY_TYPE, functionName, name, oType.toString(), interfaceType.toString()));
            }
        }
        currentProperties.put(name, interfaceType);
    }
    for (ObjectType iType : interfaceType.getCtorExtendedInterfaces()) {
        checkInterfaceConflictProperties(t, n, functionName, properties, currentProperties, iType);
    }
}",0.13636363636363635,0.5454545454545453,0.2,0.5,0.08333333333333333,0.08134920634920634,-0.2250880902043692,0.5833333333333334,-0.02631578947368421,0.24690444494389788
Math,65,1,"/**
 * Get a Chi-Square-like value assuming the N residuals follow N
 * distinct normal distributions centered on 0 and whose variances are
 * the reciprocal of the weights.
 * @return chi-square value
 */
public double getChiSquare() {
    double chiSquare = 0;
    for (int i = 0; i < rows; ++i) {
        final double residual = residuals[i];
        chiSquare += residual * residual / residualsWeights[i];
    }
    return chiSquare;
}","/**
 * Get a Chi-Square-like value assuming the N residuals follow N
 * distinct normal distributions centered on 0 and whose variances are
 * the reciprocal of the weights.
 * @return chi-square value
 */
","public double getChiSquare() {
    double chiSquare = 0;
    for (int i = 0; i < rows; ++i) {
        final double residual = residuals[i];
        chiSquare += residual * residual / residualsWeights[i];
    }
    return chiSquare;
}",-0.2727272727272727,-0.07655502392344504,-0.4,-0.5,-0.16666666666666666,0.8253968253968255,0.33756166314305824,-0.5,2.552631578947368,0.1181929772998392
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-93_0be7e8f0,1,"public static NodeStateBuilder create(NodeStateBuilderContext context) {
    return new KernelNodeStateBuilder(context, """");
}",,"public static NodeStateBuilder create(NodeStateBuilderContext context) {
    return new KernelNodeStateBuilder(context, """");
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,1.0132487667371384,-0.5,1.0263157894736843,-0.16279340490885932
wicket,remotes/origin/bugs-dot-jar_WICKET-2172_ea4a3f8a,3,"/**
 *  @see IValueMap#getAsLong(String)
 */
public Long getAsLong(String key) {
    if (!containsKey(key))
        return null;
    try {
        return getLong(key);
    } catch (StringValueConversionException ignored) {
        return null;
    }
}","/**
 *  @see IValueMap#getAsLong(String)
 */
","public Long getAsLong(String key) {
    if (!containsKey(key))
        return null;
    try {
        return getLong(key);
    } catch (StringValueConversionException ignored) {
        return null;
    }
}",-0.22727272727272727,-0.01913875598086126,-0.2,-0.5,-0.16666666666666666,-0.3650793650793651,0.3860465116279071,-0.3333333333333333,2.5,-0.16279340490885932
wicket,remotes/origin/bugs-dot-jar_WICKET-4116_4624ab3d,1,"/**
 *  The page instance is new only if there is no cached instance or the data stores doesn't have
 *  a page with that id with the same {@linkplain #pageClass}.
 *
 *  @see org.apache.wicket.request.handler.IPageProvider#isNewPageInstance()
 */
public boolean isNewPageInstance() {
    boolean isNew = pageInstance == null;
    if (isNew && pageId != null) {
        IRequestablePage storedPageInstance = getStoredPage(pageId);
        if (storedPageInstance != null) {
            pageInstance = storedPageInstance;
            isNew = false;
        }
    }
    return isNew;
}","/**
 *  The page instance is new only if there is no cached instance or the data stores doesn't have
 *  a page with that id with the same {@linkplain #pageClass}.
 *
 *  @see org.apache.wicket.request.handler.IPageProvider#isNewPageInstance()
 */
","public boolean isNewPageInstance() {
    boolean isNew = pageInstance == null;
    if (isNew && pageId != null) {
        IRequestablePage storedPageInstance = getStoredPage(pageId);
        if (storedPageInstance != null) {
            pageInstance = storedPageInstance;
            isNew = false;
        }
    }
    return isNew;
}",-0.13636363636363635,0.45933014354066987,-0.2,0.0,0.08333333333333333,0.38888888888888884,0.1839323467230445,-0.4166666666666667,1.9736842105263157,0.017300300248382045
flink,remotes/origin/bugs-dot-jar_FLINK-3189_a5b05566,3,"public static InfoOptions parseInfoCommand(String[] args) throws CliArgsException {
    try {
        PosixParser parser = new PosixParser();
        CommandLine line = parser.parse(INFO_OPTIONS, args, false);
        return new InfoOptions(line);
    } catch (ParseException e) {
        throw new CliArgsException(e.getMessage());
    }
}",,"public static InfoOptions parseInfoCommand(String[] args) throws CliArgsException {
    try {
        PosixParser parser = new PosixParser();
        CommandLine line = parser.parse(INFO_OPTIONS, args, false);
        return new InfoOptions(line);
    } catch (ParseException e) {
        throw new CliArgsException(e.getMessage());
    }
}",-0.22727272727272727,0.07177033492822962,-0.2,-0.5,-0.4166666666666667,-0.3650793650793651,0.2766737138830161,-0.3333333333333333,0.894736842105263,-0.16279340490885932
flink,remotes/origin/bugs-dot-jar_FLINK-1820_39d526e6,0,"/**
 *  Static utility to parse a field of type short from a byte sequence that represents text characters
 *  (such as when read from a file stream).
 *
 *  @param bytes The bytes containing the text data that should be parsed.
 *  @param startPos The offset to start the parsing.
 *  @param length The length of the byte sequence (counting from the offset).
 *
 *  @return The parsed value.
 *
 *  @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.
 */
public static final short parseField(byte[] bytes, int startPos, int length) {
    return parseField(bytes, startPos, length, (char) 0xffff);
}","/**
 *  Static utility to parse a field of type short from a byte sequence that represents text characters
 *  (such as when read from a file stream).
 *
 *  @param bytes The bytes containing the text data that should be parsed.
 *  @param startPos The offset to start the parsing.
 *  @param length The length of the byte sequence (counting from the offset).
 *
 *  @return The parsed value.
 *
 *  @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.
 */
","public static final short parseField(byte[] bytes, int startPos, int length) {
    return parseField(bytes, startPos, length, (char) 0xffff);
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.9926708949964762,-0.4166666666666667,1.9210526315789473,-0.16279340490885932
camel,remotes/origin/bugs-dot-jar_CAMEL-6948_f744afd9,3,"/**
 * Releases an acquired producer back after usage.
 *
 * @param endpoint the endpoint
 * @param producer the producer to release
 * @throws Exception can be thrown if error stopping producer if that was needed.
 */
public void releaseProducer(Endpoint endpoint, Producer producer) throws Exception {
    if (producer instanceof ServicePoolAware) {
        // release back to the pool
        pool.release(endpoint, producer);
    } else if (!producer.isSingleton()) {
        // stop non singleton producers as we should not leak resources
        producer.stop();
    }
}","/**
 * Releases an acquired producer back after usage.
 *
 * @param endpoint the endpoint
 * @param producer the producer to release
 * @throws Exception can be thrown if error stopping producer if that was needed.
 */
","public void releaseProducer(Endpoint endpoint, Producer producer) throws Exception {
    if (producer instanceof ServicePoolAware) {
                pool.release(endpoint, producer);
    } else if (!producer.isSingleton()) {
                producer.stop();
    }
}",-0.3181818181818182,0.01435406698564584,-0.2,0.0,-0.08333333333333333,-0.3650793650793651,0.4539816772374912,-0.25,0.7894736842105263,-0.16279340490885932
JxPath,3,1,"public NodePointer createPath(JXPathContext context, Object value) {
    NodePointer newParent = parent.createPath(context);
    if (isAttribute()) {
        NodePointer pointer = newParent.createAttribute(context, getName());
        pointer.setValue(value);
        return pointer;
    } else {
        if (newParent instanceof PropertyOwnerPointer) {
            PropertyOwnerPointer pop = (PropertyOwnerPointer) newParent;
            newParent = pop.getPropertyPointer();
        }
        return newParent.createChild(context, getName(), index, value);
    }
}",,"public NodePointer createPath(JXPathContext context, Object value) {
    NodePointer newParent = parent.createPath(context);
    if (isAttribute()) {
        NodePointer pointer = newParent.createAttribute(context, getName());
        pointer.setValue(value);
        return pointer;
    } else {
        if (newParent instanceof PropertyOwnerPointer) {
            PropertyOwnerPointer pop = (PropertyOwnerPointer) newParent;
            newParent = pop.getPropertyPointer();
        }
        return newParent.createChild(context, getName(), index, value);
    }
}",0.0,0.29665071770334916,-0.2,0.0,-0.08333333333333333,-0.3650793650793651,-0.00944326990838601,0.16666666666666666,-0.02631578947368421,-0.16279340490885932
wicket,remotes/origin/bugs-dot-jar_WICKET-2172_ea4a3f8a,3,"/**
 *  THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT USE IT!
 *
 *  @param parameters
 *             Map of query parameters that parameterize this resource
 */
public final void setParameters(final Map<?, ?> parameters) {
    if (parameters == null) {
        Resource.parameters.set(null);
    } else {
        Resource.parameters.set(new ValueMap(parameters));
    }
}","/**
 *  THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT USE IT!
 *
 *  @param parameters
 *             Map of query parameters that parameterize this resource
 */
","public final void setParameters(final Map<?, ?> parameters) {
    if (parameters == null) {
        Resource.parameters.set(null);
    } else {
        Resource.parameters.set(new ValueMap(parameters));
    }
}",-0.3181818181818182,0.01435406698564584,-0.4,-0.5,-0.25,-0.3650793650793651,0.5004933051444677,-0.3333333333333333,1.6842105263157894,-0.16279340490885932
camel,remotes/origin/bugs-dot-jar_CAMEL-9444_baece126,1,"private Processor makeProcessorImpl(RouteContext routeContext) throws Exception {
    Processor processor = null;
    // allow any custom logic before we create the processor
    preCreateProcessor();
    // resolve properties before we create the processor
    ProcessorDefinitionHelper.resolvePropertyPlaceholders(routeContext.getCamelContext(), this);
    // resolve constant fields (eg Exchange.FILE_NAME)
    ProcessorDefinitionHelper.resolveKnownConstantFields(this);
    // also resolve properties and constant fields on embedded expressions
    ProcessorDefinition<?> me = (ProcessorDefinition<?>) this;
    if (me instanceof ExpressionNode) {
        ExpressionNode exp = (ExpressionNode) me;
        ExpressionDefinition expressionDefinition = exp.getExpression();
        if (expressionDefinition != null) {
            // resolve properties before we create the processor
            ProcessorDefinitionHelper.resolvePropertyPlaceholders(routeContext.getCamelContext(), expressionDefinition);
            // resolve constant fields (eg Exchange.FILE_NAME)
            ProcessorDefinitionHelper.resolveKnownConstantFields(expressionDefinition);
        }
    }
    // at first use custom factory
    if (routeContext.getCamelContext().getProcessorFactory() != null) {
        processor = routeContext.getCamelContext().getProcessorFactory().createProcessor(routeContext, this);
    }
    // fallback to default implementation if factory did not create the processor
    if (processor == null) {
        processor = createProcessor(routeContext);
    }
    // unwrap internal processor so we can set id on the actual processor
    Processor idProcessor = processor;
    if (processor instanceof CamelInternalProcessor) {
        idProcessor = ((CamelInternalProcessor) processor).getProcessor();
    }
    // inject id
    if (idProcessor instanceof IdAware) {
        String id = this.idOrCreate(routeContext.getCamelContext().getNodeIdFactory());
        ((IdAware) idProcessor).setId(id);
    }
    if (processor == null) {
        // no processor to make
        return null;
    }
    return wrapProcessor(routeContext, processor);
}",,"private Processor makeProcessorImpl(RouteContext routeContext) throws Exception {
    Processor processor = null;
        preCreateProcessor();
        ProcessorDefinitionHelper.resolvePropertyPlaceholders(routeContext.getCamelContext(), this);
        ProcessorDefinitionHelper.resolveKnownConstantFields(this);
        ProcessorDefinition<?> me = (ProcessorDefinition<?>) this;
    if (me instanceof ExpressionNode) {
        ExpressionNode exp = (ExpressionNode) me;
        ExpressionDefinition expressionDefinition = exp.getExpression();
        if (expressionDefinition != null) {
                        ProcessorDefinitionHelper.resolvePropertyPlaceholders(routeContext.getCamelContext(), expressionDefinition);
                        ProcessorDefinitionHelper.resolveKnownConstantFields(expressionDefinition);
        }
    }
        if (routeContext.getCamelContext().getProcessorFactory() != null) {
        processor = routeContext.getCamelContext().getProcessorFactory().createProcessor(routeContext, this);
    }
        if (processor == null) {
        processor = createProcessor(routeContext);
    }
        Processor idProcessor = processor;
    if (processor instanceof CamelInternalProcessor) {
        idProcessor = ((CamelInternalProcessor) processor).getProcessor();
    }
        if (idProcessor instanceof IdAware) {
        String id = this.idOrCreate(routeContext.getCamelContext().getNodeIdFactory());
        ((IdAware) idProcessor).setId(id);
    }
    if (processor == null) {
                return null;
    }
    return wrapProcessor(routeContext, processor);
}",0.8636363636363636,-0.11483253588516758,0.8,0.0,0.5833333333333334,0.13690476190476186,-0.5766032417195206,1.1666666666666667,-0.02631578947368421,0.3998755208243287
wicket,remotes/origin/bugs-dot-jar_WICKET-3767_84c3baac,1,"/**
 *  Validates this component using the component's validators.
 */
@SuppressWarnings(""unchecked"")
protected final void validateValidators() {
    final IValidatable<T> validatable = newValidatable();
    boolean isNull = getConvertedInput() == null;
    IValidator<T> validator = null;
    try {
        for (Behavior behavior : getBehaviors()) {
            if (behavior instanceof IValidator) {
                validator = (IValidator<T>) behavior;
                if (isNull == false || validator instanceof INullAcceptingValidator<?>) {
                    validator.validate(validatable);
                }
                if (!isValid()) {
                    break;
                }
            }
        }
    } catch (Exception e) {
        throw new WicketRuntimeException(""Exception '"" + e + ""' occurred during validation "" + validator.getClass().getName() + "" on component "" + getPath(), e);
    }
}","/**
 *  Validates this component using the component's validators.
 */
","@SuppressWarnings(""unchecked"")
protected final void validateValidators() {
    final IValidatable<T> validatable = newValidatable();
    boolean isNull = getConvertedInput() == null;
    IValidator<T> validator = null;
    try {
        for (Behavior behavior : getBehaviors()) {
            if (behavior instanceof IValidator) {
                validator = (IValidator<T>) behavior;
                if (isNull == false || validator instanceof INullAcceptingValidator<?>) {
                    validator.validate(validatable);
                }
                if (!isValid()) {
                    break;
                }
            }
        }
    } catch (Exception e) {
        throw new WicketRuntimeException(""Exception '"" + e + ""' occurred during validation "" + validator.getClass().getName() + "" on component "" + getPath(), e);
    }
}",0.3181818181818182,1.7033492822966507,0.8,1.0,0.25,0.23611111111111105,-0.28513037350246634,0.16666666666666666,0.31578947368421056,0.2144246007733845
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1308_69ba2a54,1,"private Expression parsePropertyOrFunction() throws ParseException {
    StringBuilder buff = new StringBuilder();
    boolean isPath = false;
    while (true) {
        if (currentTokenType == IDENTIFIER) {
            String name = readIdentifier();
            buff.append(name);
        } else if (readIf(""*"")) {
            // any node
            buff.append('*');
            isPath = true;
        } else if (readIf(""."")) {
            buff.append('.');
            if (readIf(""."")) {
                buff.append('.');
            }
            isPath = true;
        } else if (readIf(""@"")) {
            if (readIf(""*"")) {
                // xpath supports @*, even thought jackrabbit may not
                buff.append('*');
            } else {
                buff.append(readIdentifier());
            }
            return new Expression.Property(currentSelector, buff.toString());
        } else {
            break;
        }
        if (readIf(""/"")) {
            isPath = true;
            buff.append('/');
        } else {
            break;
        }
    }
    if (!isPath && readIf(""("")) {
        return parseFunction(buff.toString());
    } else if (buff.length() > 0) {
        // jcr:contains(jcr:content, 'x')
        if (buff.toString().equals(""."")) {
            buff = new StringBuilder(""*"");
        } else {
            buff.append(""/*"");
        }
        return new Expression.Property(currentSelector, buff.toString());
    }
    throw getSyntaxError();
}",,"private Expression parsePropertyOrFunction() throws ParseException {
    StringBuilder buff = new StringBuilder();
    boolean isPath = false;
    while (true) {
        if (currentTokenType == IDENTIFIER) {
            String name = readIdentifier();
            buff.append(name);
        } else if (readIf(""*"")) {
                        buff.append('*');
            isPath = true;
        } else if (readIf(""."")) {
            buff.append('.');
            if (readIf(""."")) {
                buff.append('.');
            }
            isPath = true;
        } else if (readIf(""@"")) {
            if (readIf(""*"")) {
                                buff.append('*');
            } else {
                buff.append(readIdentifier());
            }
            return new Expression.Property(currentSelector, buff.toString());
        } else {
            break;
        }
        if (readIf(""/"")) {
            isPath = true;
            buff.append('/');
        } else {
            break;
        }
    }
    if (!isPath && readIf(""("")) {
        return parseFunction(buff.toString());
    } else if (buff.length() > 0) {
                if (buff.toString().equals(""."")) {
            buff = new StringBuilder(""*"");
        } else {
            buff.append(""/*"");
        }
        return new Expression.Property(currentSelector, buff.toString());
    }
    throw getSyntaxError();
}",1.4090909090909092,0.4354066985645932,2.2,2.0,1.3333333333333333,0.7460317460317459,-0.7651867512332625,1.5833333333333333,-0.02631578947368421,1.095266909862093
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1104_7ae92779,1,"private static int compare(MapEntry before, MapEntry after) {
    if (before == null) {
        // sentinel value appear greater than any normal value.
        return 1;
    } else if (after == null) {
        // see above
        return -1;
    } else {
        return ComparisonChain.start().compare(before.getHash(), after.getHash()).compare(before.getName(), after.getName()).result();
    }
}",,"private static int compare(MapEntry before, MapEntry after) {
    if (before == null) {
                return 1;
    } else if (after == null) {
                return -1;
    } else {
        return ComparisonChain.start().compare(before.getHash(), after.getHash()).compare(before.getName(), after.getName()).result();
    }
}",-0.22727272727272727,-0.01913875598086126,-0.2,0.0,-0.08333333333333333,0.047619047619047616,0.2704721634954192,0.16666666666666666,0.0,-0.060397757069668
wicket,remotes/origin/bugs-dot-jar_WICKET-3861_d1e0e411,3,"@Override
protected void onAfterRenderChildren() {
    // Loop through child components
    final Iterator<? extends Component> iter = iterator();
    while (iter.hasNext()) {
        // Get next child
        final Component child = iter.next();
        // Call end request on the child
        child.afterRender();
    }
    super.onAfterRenderChildren();
}",,"@Override
protected void onAfterRenderChildren() {
        final Iterator<? extends Component> iter = iterator();
    while (iter.hasNext()) {
                final Component child = iter.next();
                child.afterRender();
    }
    super.onAfterRenderChildren();
}",-0.22727272727272727,-0.01913875598086126,-0.4,-0.5,-0.25,-0.3650793650793651,0.35052854122621563,-0.08333333333333333,1.3157894736842106,-0.16279340490885932
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1225_3535afe2,1,"@Override
public Node perform() throws RepositoryException {
    return NodeImpl.createNodeOrNull(sd.getNode(getOakPathOrThrow(absPath)), sessionContext);
}",,"@Override
public Node perform() throws RepositoryException {
    return NodeImpl.createNodeOrNull(sd.getNode(getOakPathOrThrow(absPath)), sessionContext);
}",-0.45454545454545453,-0.6028708133971293,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.7866102889358701,-0.25,0.2894736842105263,-0.16279340490885932
wicket,remotes/origin/bugs-dot-jar_WICKET-5359_61122bab,3,"/**
 *  Convert this text to an enum.
 *
 *  @param defaultValue
 *             This will be returned if there is an error converting the value
 *  @return The value as an enum
 */
public final <T extends Enum<T>> T toEnum(final T defaultValue) {
    Args.notNull(defaultValue, ""defaultValue"");
    return toEnum((Class<T>) defaultValue.getClass(), defaultValue);
}","/**
 *  Convert this text to an enum.
 *
 *  @param defaultValue
 *             This will be returned if there is an error converting the value
 *  @return The value as an enum
 */
","public final <T extends Enum<T>> T toEnum(final T defaultValue) {
    Args.notNull(defaultValue, ""defaultValue"");
    return toEnum((Class<T>) defaultValue.getClass(), defaultValue);
}",-0.45454545454545453,-0.47368421052631593,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.7451726568005637,-0.25,2.263157894736842,-0.16279340490885932
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-470_50340d0c,3,"@Override
@SuppressWarnings(""unchecked"")
public Map<String, String> getProperties() {
    return (Map<String, String>) componentMap.get(CONTEXT_PROPERTIES);
}",,"@Override
@SuppressWarnings(""unchecked"")
public Map<String, String> getProperties() {
    return (Map<String, String>) componentMap.get(CONTEXT_PROPERTIES);
}",-0.4090909090909091,-0.6650717703349284,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.673291050035236,-0.4166666666666667,0.07894736842105263,-0.16279340490885932
Math,54,3,"/**
 * Convert the instance into a double.
 * @return a double approximating the instance
 * @see #toSplitDouble()
 */
public double toDouble() {
    if (isInfinite()) {
        if (lessThan(getZero())) {
            return Double.NEGATIVE_INFINITY;
        } else {
            return Double.POSITIVE_INFINITY;
        }
    }
    if (isNaN()) {
        return Double.NaN;
    }
    Dfp y = this;
    boolean negate = false;
    if (lessThan(getZero())) {
        y = negate();
        negate = true;
    }
    /* Find the exponent, first estimate by integer log10, then adjust.
         Should be faster than doing a natural logarithm.  */
    int exponent = (int) (y.log10() * 3.32);
    if (exponent < 0) {
        exponent--;
    }
    Dfp tempDfp = DfpMath.pow(getTwo(), exponent);
    while (tempDfp.lessThan(y) || tempDfp.equals(y)) {
        tempDfp = tempDfp.multiply(2);
        exponent++;
    }
    exponent--;
    /* We have the exponent, now work on the mantissa */
    y = y.divide(DfpMath.pow(getTwo(), exponent));
    if (exponent > -1023) {
        y = y.subtract(getOne());
    }
    if (exponent < -1074) {
        return 0;
    }
    if (exponent > 1023) {
        return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;
    }
    y = y.multiply(newInstance(4503599627370496l)).rint();
    String str = y.toString();
    str = str.substring(0, str.length() - 1);
    long mantissa = Long.parseLong(str);
    if (mantissa == 4503599627370496L) {
        // Handle special case where we round up to next power of two
        mantissa = 0;
        exponent++;
    }
    /* Its going to be subnormal, so make adjustments */
    if (exponent <= -1023) {
        exponent--;
    }
    while (exponent < -1023) {
        exponent++;
        mantissa >>>= 1;
    }
    long bits = mantissa | ((exponent + 1023L) << 52);
    double x = Double.longBitsToDouble(bits);
    if (negate) {
        x = -x;
    }
    return x;
}","/**
 * Convert the instance into a double.
 * @return a double approximating the instance
 * @see #toSplitDouble()
 */
","public double toDouble() {
    if (isInfinite()) {
        if (lessThan(getZero())) {
            return Double.NEGATIVE_INFINITY;
        } else {
            return Double.POSITIVE_INFINITY;
        }
    }
    if (isNaN()) {
        return Double.NaN;
    }
    Dfp y = this;
    boolean negate = false;
    if (lessThan(getZero())) {
        y = negate();
        negate = true;
    }
        int exponent = (int) (y.log10() * 3.32);
    if (exponent < 0) {
        exponent--;
    }
    Dfp tempDfp = DfpMath.pow(getTwo(), exponent);
    while (tempDfp.lessThan(y) || tempDfp.equals(y)) {
        tempDfp = tempDfp.multiply(2);
        exponent++;
    }
    exponent--;
        y = y.divide(DfpMath.pow(getTwo(), exponent));
    if (exponent > -1023) {
        y = y.subtract(getOne());
    }
    if (exponent < -1074) {
        return 0;
    }
    if (exponent > 1023) {
        return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;
    }
    y = y.multiply(newInstance(4503599627370496l)).rint();
    String str = y.toString();
    str = str.substring(0, str.length() - 1);
    long mantissa = Long.parseLong(str);
    if (mantissa == 4503599627370496L) {
                mantissa = 0;
        exponent++;
    }
        if (exponent <= -1023) {
        exponent--;
    }
    while (exponent < -1023) {
        exponent++;
        mantissa >>>= 1;
    }
    long bits = mantissa | ((exponent + 1023L) << 52);
    double x = Double.longBitsToDouble(bits);
    if (negate) {
        x = -x;
    }
    return x;
}",2.0454545454545454,-0.2822966507177035,2.2,0.0,1.6666666666666667,2.9503968253968256,-0.9867512332628608,1.6666666666666667,-0.02631578947368421,7.160754482114761
wicket,remotes/origin/bugs-dot-jar_WICKET-442_246d53c5,1,"/**
 *  Common functionality to be called by processEvents()
 *
 *  @param requestCycle
 *             The request cycle
 */
protected void onProcessEvents(final RequestCycle requestCycle) {
    // Assume cluster needs to be updated now, unless listener
    // invocation changes this
    requestCycle.setUpdateSession(true);
    // Clear all feedback messages if it isn't a redirect
    getPage().getFeedbackMessages().clear();
    getPage().startComponentRender(getTarget());
    final Application application = requestCycle.getApplication();
    // and see if we have to redirect the render part by default
    IRequestCycleSettings.RenderStrategy strategy = application.getRequestCycleSettings().getRenderStrategy();
    boolean issueRedirect = (strategy == IRequestCycleSettings.REDIRECT_TO_RENDER || strategy == IRequestCycleSettings.REDIRECT_TO_BUFFER);
    requestCycle.setRedirect(issueRedirect);
}","/**
 *  Common functionality to be called by processEvents()
 *
 *  @param requestCycle
 *             The request cycle
 */
","protected void onProcessEvents(final RequestCycle requestCycle) {
            requestCycle.setUpdateSession(true);
        getPage().getFeedbackMessages().clear();
    getPage().startComponentRender(getTarget());
    final Application application = requestCycle.getApplication();
        IRequestCycleSettings.RenderStrategy strategy = application.getRequestCycleSettings().getRenderStrategy();
    boolean issueRedirect = (strategy == IRequestCycleSettings.REDIRECT_TO_RENDER || strategy == IRequestCycleSettings.REDIRECT_TO_BUFFER);
    requestCycle.setRedirect(issueRedirect);
}",-0.22727272727272727,-0.6363636363636366,-0.6,-1.0,-0.4166666666666667,-0.08134920634920638,0.20394644115574342,0.4166666666666667,0.5789473684210527,-0.04153224644571614
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1215_a9efe3c4,0,"/**
 * Get the property value. The property name may be relative. The special
 * property names ""jcr:path"", ""jcr:score"" and ""rep:excerpt"" are supported.
 *
 * @param oakPropertyName (must already be normalized)
 * @return the property value or null if not found
 */
public PropertyValue currentOakProperty(String oakPropertyName) {
    boolean relative = oakPropertyName.indexOf('/') >= 0;
    Tree t = currentTree();
    if (relative) {
        for (String p : PathUtils.elements(PathUtils.getParentPath(oakPropertyName))) {
            if (t == null) {
                return null;
            }
            if (p.equals("".."")) {
                t = t.isRoot() ? null : t.getParent();
            } else if (p.equals(""."")) {
            // same node
            } else {
                t = t.getChild(p);
            }
        }
        oakPropertyName = PathUtils.getName(oakPropertyName);
    }
    if (t == null || !t.exists()) {
        return null;
    }
    if (oakPropertyName.equals(QueryImpl.JCR_PATH)) {
        String path = currentPath();
        String local = getLocalPath(path);
        if (local == null) {
            // not a local path
            return null;
        }
        return PropertyValues.newString(local);
    } else if (oakPropertyName.equals(QueryImpl.JCR_SCORE)) {
        return currentRow.getValue(QueryImpl.JCR_SCORE);
    } else if (oakPropertyName.equals(QueryImpl.REP_EXCERPT)) {
        return currentRow.getValue(QueryImpl.REP_EXCERPT);
    }
    return PropertyValues.create(t.getProperty(oakPropertyName));
}","/**
 * Get the property value. The property name may be relative. The special
 * property names ""jcr:path"", ""jcr:score"" and ""rep:excerpt"" are supported.
 *
 * @param oakPropertyName (must already be normalized)
 * @return the property value or null if not found
 */
","public PropertyValue currentOakProperty(String oakPropertyName) {
    boolean relative = oakPropertyName.indexOf('/') >= 0;
    Tree t = currentTree();
    if (relative) {
        for (String p : PathUtils.elements(PathUtils.getParentPath(oakPropertyName))) {
            if (t == null) {
                return null;
            }
            if (p.equals("".."")) {
                t = t.isRoot() ? null : t.getParent();
            } else if (p.equals(""."")) {
                        } else {
                t = t.getChild(p);
            }
        }
        oakPropertyName = PathUtils.getName(oakPropertyName);
    }
    if (t == null || !t.exists()) {
        return null;
    }
    if (oakPropertyName.equals(QueryImpl.JCR_PATH)) {
        String path = currentPath();
        String local = getLocalPath(path);
        if (local == null) {
                        return null;
        }
        return PropertyValues.newString(local);
    } else if (oakPropertyName.equals(QueryImpl.JCR_SCORE)) {
        return currentRow.getValue(QueryImpl.JCR_SCORE);
    } else if (oakPropertyName.equals(QueryImpl.REP_EXCERPT)) {
        return currentRow.getValue(QueryImpl.REP_EXCERPT);
    }
    return PropertyValues.create(t.getProperty(oakPropertyName));
}",0.9090909090909091,0.5885167464114831,1.6,1.0,1.3333333333333333,0.5198412698412699,-0.6343904157857644,1.25,-0.02631578947368421,0.9601701215400839
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-209_76d727f0,1,"@Override
public void init(SortedKeyValueIterator<Key, Value> source, Map<String, String> options, IteratorEnvironment env) throws IOException {
    super.init(source, options, env);
    if (options.containsKey(ROW_REGEX)) {
        rowMatcher = Pattern.compile(options.get(ROW_REGEX)).matcher("""");
    } else {
        rowMatcher = null;
    }
    if (options.containsKey(COLF_REGEX)) {
        colfMatcher = Pattern.compile(options.get(COLF_REGEX)).matcher("""");
    } else {
        colfMatcher = null;
    }
    if (options.containsKey(COLQ_REGEX)) {
        colqMatcher = Pattern.compile(options.get(COLQ_REGEX)).matcher("""");
    } else {
        colqMatcher = null;
    }
    if (options.containsKey(VALUE_REGEX)) {
        valueMatcher = Pattern.compile(options.get(VALUE_REGEX)).matcher("""");
    } else {
        valueMatcher = null;
    }
    if (options.containsKey(OR_FIELDS)) {
        orFields = Boolean.parseBoolean(options.get(OR_FIELDS));
    } else {
        orFields = false;
    }
}",,"@Override
public void init(SortedKeyValueIterator<Key, Value> source, Map<String, String> options, IteratorEnvironment env) throws IOException {
    super.init(source, options, env);
    if (options.containsKey(ROW_REGEX)) {
        rowMatcher = Pattern.compile(options.get(ROW_REGEX)).matcher("""");
    } else {
        rowMatcher = null;
    }
    if (options.containsKey(COLF_REGEX)) {
        colfMatcher = Pattern.compile(options.get(COLF_REGEX)).matcher("""");
    } else {
        colfMatcher = null;
    }
    if (options.containsKey(COLQ_REGEX)) {
        colqMatcher = Pattern.compile(options.get(COLQ_REGEX)).matcher("""");
    } else {
        colqMatcher = null;
    }
    if (options.containsKey(VALUE_REGEX)) {
        valueMatcher = Pattern.compile(options.get(VALUE_REGEX)).matcher("""");
    } else {
        valueMatcher = null;
    }
    if (options.containsKey(OR_FIELDS)) {
        orFields = Boolean.parseBoolean(options.get(OR_FIELDS));
    } else {
        orFields = false;
    }
}",0.6818181818181818,-0.23444976076555035,0.4,-0.5,0.4166666666666667,-0.3650793650793651,-0.49880197322057757,1.1666666666666667,-0.02631578947368421,-0.16279340490885932
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-107_88641f49,1,"/**
 * Extract options.
 *
 * @param pattern conversion pattern.
 * @param i       start of options.
 * @param options array to receive extracted options
 * @return position in pattern after options.
 */
private static int extractOptions(String pattern, int i, List<String> options) {
    while ((i < pattern.length()) && (pattern.charAt(i) == '{')) {
        int begin = i;
        int end;
        int depth = 0;
        do {
            end = pattern.indexOf('}', i);
            if (end != -1) {
                int next = pattern.indexOf(""{"", i + 1);
                if (next != -1 && next < end) {
                    i = end + 1;
                    ++depth;
                } else if (depth > 0) {
                    --depth;
                }
            }
        } while (depth > 0);
        if (end == -1) {
            break;
        }
        String r = pattern.substring(begin + 1, end);
        options.add(r);
        i = end + 1;
    }
    return i;
}","/**
 * Extract options.
 *
 * @param pattern conversion pattern.
 * @param i       start of options.
 * @param options array to receive extracted options
 * @return position in pattern after options.
 */
","private static int extractOptions(String pattern, int i, List<String> options) {
    while ((i < pattern.length()) && (pattern.charAt(i) == '{')) {
        int begin = i;
        int end;
        int depth = 0;
        do {
            end = pattern.indexOf('}', i);
            if (end != -1) {
                int next = pattern.indexOf(""{"", i + 1);
                if (next != -1 && next < end) {
                    i = end + 1;
                    ++depth;
                } else if (depth > 0) {
                    --depth;
                }
            }
        } while (depth > 0);
        if (end == -1) {
            break;
        }
        String r = pattern.substring(begin + 1, end);
        options.add(r);
        i = end + 1;
    }
    return i;
}",0.5454545454545454,1.2344497607655505,0.8,1.5,0.75,2.5634920634920633,-0.4528541226215643,0.0,0.0,2.804301447070417
commons-math,remotes/origin/bugs-dot-jar_MATH-1096_19c1c3bb,0,"/**
 * Compute a dimension 4 minor, when 4<sup>th</sup> column is known to be filled with 1.0.
 * <p>
 * The computation is performed using {@link MathArrays#linearCombination(double[], double[])
 * high accuracy sum of products}, trying to avoid cancellations effect. This should reduce
 * risks in case of near co-planar points.
 * </p>
 * @param c1 first column
 * @param c2 second column
 * @param c3 third column
 * @return value of the minor computed to high accuracy
 */
private double minor(final double[] c1, final double[] c2, final double[] c3) {
    final double m01 = c2[0] * c3[1];
    final double m02 = c2[0] * c3[2];
    final double m03 = c2[0] * c3[3];
    final double m10 = c2[1] * c3[0];
    final double m12 = c2[1] * c3[2];
    final double m13 = c2[1] * c3[3];
    final double m20 = c2[2] * c3[0];
    final double m21 = c2[2] * c3[1];
    final double m23 = c2[2] * c3[3];
    final double m30 = c2[3] * c3[0];
    final double m31 = c2[3] * c3[1];
    final double m32 = c2[3] * c3[2];
    return MathArrays.linearCombination(new double[] { c1[2], c1[1], c1[3], -c1[1], -c1[3], -c1[2], c1[0], c1[3], c1[2], -c1[3], -c1[0], -c1[2], c1[1], c1[0], c1[3], -c1[0], -c1[3], -c1[1], c1[0], c1[2], c1[1], -c1[2], -c1[0], -c1[1] }, new double[] { m13, m32, m21, m23, m12, m31, m23, m02, m30, m20, m32, m03, m03, m31, m10, m13, m01, m30, m12, m01, m20, m10, m21, m02 });
}","/**
 * Compute a dimension 4 minor, when 4<sup>th</sup> column is known to be filled with 1.0.
 * <p>
 * The computation is performed using {@link MathArrays#linearCombination(double[], double[])
 * high accuracy sum of products}, trying to avoid cancellations effect. This should reduce
 * risks in case of near co-planar points.
 * </p>
 * @param c1 first column
 * @param c2 second column
 * @param c3 third column
 * @return value of the minor computed to high accuracy
 */
","private double minor(final double[] c1, final double[] c2, final double[] c3) {
    final double m01 = c2[0] * c3[1];
    final double m02 = c2[0] * c3[2];
    final double m03 = c2[0] * c3[3];
    final double m10 = c2[1] * c3[0];
    final double m12 = c2[1] * c3[2];
    final double m13 = c2[1] * c3[3];
    final double m20 = c2[2] * c3[0];
    final double m21 = c2[2] * c3[1];
    final double m23 = c2[2] * c3[3];
    final double m30 = c2[3] * c3[0];
    final double m31 = c2[3] * c3[1];
    final double m32 = c2[3] * c3[2];
    return MathArrays.linearCombination(new double[] { c1[2], c1[1], c1[3], -c1[1], -c1[3], -c1[2], c1[0], c1[3], c1[2], -c1[3], -c1[0], -c1[2], c1[1], c1[0], c1[3], -c1[0], -c1[3], -c1[1], c1[0], c1[2], c1[1], -c1[2], -c1[0], -c1[1] }, new double[] { m13, m32, m21, m23, m12, m31, m23, m02, m30, m20, m32, m03, m03, m31, m10, m13, m01, m30, m12, m01, m20, m10, m21, m02 });
}",0.045454545454545456,-0.7799043062200958,-0.6,-1.0,-0.4166666666666667,0.8333333333333334,-0.24961240310077526,-0.4166666666666667,-0.02631578947368421,2.12911256721011
wicket,remotes/origin/bugs-dot-jar_WICKET-4072_7d5b8645,1,"/**
 *  return path for current url in original encoding
 *
 *  @return path string
 */
public String getPath() {
    return getPath(getCharset());
}","/**
 *  return path for current url in original encoding
 *
 *  @return path string
 */
","public String getPath() {
    return getPath(getCharset());
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,1.1319238900634248,-0.3333333333333333,2.6052631578947367,-0.16279340490885932
Csv,5,1,"/**
 * Outputs the record separator.
 *
 * @throws IOException
 *             If an I/O error occurs
 */
public void println() throws IOException {
    final String recordSeparator = format.getRecordSeparator();
    out.append(recordSeparator);
    newRecord = true;
}","/**
 * Outputs the record separator.
 *
 * @throws IOException
 *             If an I/O error occurs
 */
","public void println() throws IOException {
    final String recordSeparator = format.getRecordSeparator();
    out.append(recordSeparator);
    newRecord = true;
}",-0.4090909090909091,-0.49282296650717716,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.6620155038759689,-0.3333333333333333,2.5789473684210527,-0.16279340490885932
Math,20,1,"/**
 * @param x Normalized objective variables.
 * @return the original objective variables, possibly repaired.
 */
public double[] repairAndDecode(final double[] x) {
    return decode(x);
}","/**
 * @param x Normalized objective variables.
 * @return the original objective variables, possibly repaired.
 */
","public double[] repairAndDecode(final double[] x) {
    return decode(x);
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,1.1319238900634248,-0.4166666666666667,2.6052631578947367,-0.16279340490885932
Math,63,3,"/**
 * Returns true iff they are equal as defined by
 * {@link #equals(double,double,int) equals(x, y, 1)}.
 *
 * @param x first value
 * @param y second value
 * @return {@code true} if the values are equal.
 */
public static boolean equals(double x, double y) {
    return (Double.isNaN(x) && Double.isNaN(y)) || x == y;
}","/**
 * Returns true iff they are equal as defined by
 * {@link #equals(double,double,int) equals(x, y, 1)}.
 *
 * @param x first value
 * @param y second value
 * @return {@code true} if the values are equal.
 */
","public static boolean equals(double x, double y) {
    return (Double.isNaN(x) && Double.isNaN(y)) || x == y;
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,0.03174603174603173,0.9033121916842841,-0.3333333333333333,2.4473684210526314,-0.11894907303354596
wicket,remotes/origin/bugs-dot-jar_WICKET-4309_b4274415,1,"/**
 *  Convert to object types, returning null if text is null.
 *
 *  @return converted
 *  @throws StringValueConversionException
 */
public final Boolean toOptionalBoolean() throws StringValueConversionException {
    return (text == null) ? null : toBooleanObject();
}","/**
 *  Convert to object types, returning null if text is null.
 *
 *  @return converted
 *  @throws StringValueConversionException
 */
","public final Boolean toOptionalBoolean() throws StringValueConversionException {
    return (text == null) ? null : toBooleanObject();
}",-0.5,-0.5263157894736844,-0.4,-1.0,-0.25,-0.3650793650793651,0.9797040169133189,-0.4166666666666667,2.6052631578947367,-0.16279340490885932
Closure,108,2,"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    if (isCallToScopeMethod(n)) {
        validateScopeCall(t, n, n.getParent());
    }
    if (t.getScopeDepth() < 2) {
        return;
    }
    int type = n.getType();
    Var aliasVar = null;
    if (type == Token.NAME) {
        String name = n.getString();
        Var lexicalVar = t.getScope().getVar(n.getString());
        if (lexicalVar != null && lexicalVar == aliases.get(name)) {
            aliasVar = lexicalVar;
        }
    }
    // Validate the top-level of the goog.scope block.
    if (t.getScopeDepth() == 2) {
        if (aliasVar != null && NodeUtil.isLValue(n)) {
            if (aliasVar.getNode() == n) {
                aliasDefinitionsInOrder.add(n);
                // twice.
                return;
            } else {
                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());
            }
        }
        if (type == Token.RETURN) {
            report(t, n, GOOG_SCOPE_USES_RETURN);
        } else if (type == Token.THIS) {
            report(t, n, GOOG_SCOPE_REFERENCES_THIS);
        } else if (type == Token.THROW) {
            report(t, n, GOOG_SCOPE_USES_THROW);
        }
    }
    // Validate all descendent scopes of the goog.scope block.
    if (t.getScopeDepth() >= 2) {
        // Check if this name points to an alias.
        if (aliasVar != null) {
            // Note, to support the transitive case, it's important we don't
            // clone aliasedNode here.  For example,
            // var g = goog; var d = g.dom; d.createElement('DIV');
            // The node in aliasedNode (which is ""g"") will be replaced in the
            // changes pass above with ""goog"".  If we cloned here, we'd end up
            // with <code>g.dom.createElement('DIV')</code>.
            aliasUsages.add(new AliasedNode(aliasVar, n));
        }
        // When we inject declarations, we duplicate jsdoc. Make sure
        // we only process that jsdoc once.
        JSDocInfo info = n.getJSDocInfo();
        if (info != null) {
            for (Node node : info.getTypeNodes()) {
                fixTypeNode(node);
            }
        }
    // TODO(robbyw): Error for goog.scope not at root.
    }
}",,"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    if (isCallToScopeMethod(n)) {
        validateScopeCall(t, n, n.getParent());
    }
    if (t.getScopeDepth() < 2) {
        return;
    }
    int type = n.getType();
    Var aliasVar = null;
    if (type == Token.NAME) {
        String name = n.getString();
        Var lexicalVar = t.getScope().getVar(n.getString());
        if (lexicalVar != null && lexicalVar == aliases.get(name)) {
            aliasVar = lexicalVar;
        }
    }
        if (t.getScopeDepth() == 2) {
        if (aliasVar != null && NodeUtil.isLValue(n)) {
            if (aliasVar.getNode() == n) {
                aliasDefinitionsInOrder.add(n);
                                return;
            } else {
                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());
            }
        }
        if (type == Token.RETURN) {
            report(t, n, GOOG_SCOPE_USES_RETURN);
        } else if (type == Token.THIS) {
            report(t, n, GOOG_SCOPE_REFERENCES_THIS);
        } else if (type == Token.THROW) {
            report(t, n, GOOG_SCOPE_USES_THROW);
        }
    }
        if (t.getScopeDepth() >= 2) {
                if (aliasVar != null) {
                                                                                    aliasUsages.add(new AliasedNode(aliasVar, n));
        }
                        JSDocInfo info = n.getJSDocInfo();
        if (info != null) {
            for (Node node : info.getTypeNodes()) {
                fixTypeNode(node);
            }
        }
        }
}",1.4545454545454546,0.5645933014354066,2.2,1.0,1.75,0.9702380952380953,-0.8398872445384071,1.5,-0.02631578947368421,2.188747313036312
wicket,remotes/origin/bugs-dot-jar_WICKET-3510_292a2582,1,"/**
 *  Creates a new DateTextField defaulting to using a short date pattern
 *
 *  @param id
 *             The id of the text field
 *  @param model
 *             The model
 *  @return DateTextField
 */
public static DateTextField forShortStyle(String id, IModel<Date> model) {
    return new DateTextField(id, model, new StyleDateConverter(true));
}","/**
 *  Creates a new DateTextField defaulting to using a short date pattern
 *
 *  @param id
 *             The id of the text field
 *  @param model
 *             The model
 *  @return DateTextField
 */
","public static DateTextField forShortStyle(String id, IModel<Date> model) {
    return new DateTextField(id, model, new StyleDateConverter(true));
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.917406624383368,-0.5,2.5789473684210527,-0.16279340490885932
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-479_3270e761,1,"void checkProtected() throws RepositoryException {
    ItemDefinition definition = (isNode()) ? ((Node) this).getDefinition() : ((Property) this).getDefinition();
    checkProtected(definition);
}",,"void checkProtected() throws RepositoryException {
    ItemDefinition definition = (isNode()) ? ((Node) this).getDefinition() : ((Property) this).getDefinition();
    checkProtected(definition);
}",-0.45454545454545453,-0.47368421052631593,-0.4,-1.0,-0.25,-0.3650793650793651,0.7795630725863283,-0.16666666666666666,2.026315789473684,-0.16279340490885932
wicket,remotes/origin/bugs-dot-jar_WICKET-5500_825da305,1,"/**
 *  Loads page class with given name.
 *
 *  @param name
 *  @return class
 */
protected Class<? extends IRequestablePage> getPageClass(String name) {
    Args.notEmpty(name, ""name"");
    return WicketObjects.resolveClass(name);
}","/**
 *  Loads page class with given name.
 *
 *  @param name
 *  @return class
 */
","protected Class<? extends IRequestablePage> getPageClass(String name) {
    Args.notEmpty(name, ""name"");
    return WicketObjects.resolveClass(name);
}",-0.45454545454545453,-0.47368421052631593,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.7860465116279065,-0.3333333333333333,2.4736842105263155,-0.16279340490885932
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2420_24cb1908,0,"@Override
public NodeDocument apply(String name) {
    String p = concat(path, name);
    NodeDocument doc = store.find(Collection.NODES, Utils.getIdFromPath(p));
    if (doc == null) {
        docChildrenCache.invalidateAll();
        throw new NullPointerException(""Document "" + p + "" not found"");
    }
    return doc;
}",,"@Override
public NodeDocument apply(String name) {
    String p = concat(path, name);
    NodeDocument doc = store.find(Collection.NODES, Utils.getIdFromPath(p));
    if (doc == null) {
        docChildrenCache.invalidateAll();
        throw new NullPointerException(""Document "" + p + "" not found"");
    }
    return doc;
}",-0.18181818181818182,-0.0909090909090911,-0.2,-0.5,-0.25,-0.10317460317460318,0.1689922480620156,-0.16666666666666666,0.894736842105263,-0.06965992980757595
flink,remotes/origin/bugs-dot-jar_FLINK-2754_68912126,1,"/**
 *  Writes a subset of the records in this buffer in their logical order to the given output.
 *
 *  @param output The output view to write the records to.
 *  @param start The logical start position of the subset.
 *  @param num The number of elements to write.
 *  @throws IOException Thrown, if an I/O exception occurred writing to the output view.
 */
@Override
public void writeToOutput(final ChannelWriterOutputView output, final int start, int num) throws IOException {
    final TypeComparator<T> comparator = this.comparator;
    final TypeSerializer<T> serializer = this.serializer;
    T record = this.recordInstance;
    final SingleSegmentInputView inView = this.inView;
    final int recordsPerSegment = this.recordsPerSegment;
    int currentMemSeg = start / recordsPerSegment;
    int offset = (start % recordsPerSegment) * this.recordSize;
    while (num > 0) {
        final MemorySegment currentIndexSegment = this.sortBuffer.get(currentMemSeg++);
        inView.set(currentIndexSegment, offset);
        // check whether we have a full or partially full segment
        if (num >= recordsPerSegment && offset == 0) {
            // full segment
            for (int numInMemSeg = 0; numInMemSeg < recordsPerSegment; numInMemSeg++) {
                record = comparator.readWithKeyDenormalization(record, inView);
                serializer.serialize(record, output);
            }
            num -= recordsPerSegment;
        } else {
            // partially filled segment
            for (; num > 0; num--) {
                record = comparator.readWithKeyDenormalization(record, inView);
                serializer.serialize(record, output);
            }
        }
    }
}","/**
 *  Writes a subset of the records in this buffer in their logical order to the given output.
 *
 *  @param output The output view to write the records to.
 *  @param start The logical start position of the subset.
 *  @param num The number of elements to write.
 *  @throws IOException Thrown, if an I/O exception occurred writing to the output view.
 */
","@Override
public void writeToOutput(final ChannelWriterOutputView output, final int start, int num) throws IOException {
    final TypeComparator<T> comparator = this.comparator;
    final TypeSerializer<T> serializer = this.serializer;
    T record = this.recordInstance;
    final SingleSegmentInputView inView = this.inView;
    final int recordsPerSegment = this.recordsPerSegment;
    int currentMemSeg = start / recordsPerSegment;
    int offset = (start % recordsPerSegment) * this.recordSize;
    while (num > 0) {
        final MemorySegment currentIndexSegment = this.sortBuffer.get(currentMemSeg++);
        inView.set(currentIndexSegment, offset);
                if (num >= recordsPerSegment && offset == 0) {
                        for (int numInMemSeg = 0; numInMemSeg < recordsPerSegment; numInMemSeg++) {
                record = comparator.readWithKeyDenormalization(record, inView);
                serializer.serialize(record, output);
            }
            num -= recordsPerSegment;
        } else {
                        for (; num > 0; num--) {
                record = comparator.readWithKeyDenormalization(record, inView);
                serializer.serialize(record, output);
            }
        }
    }
}",0.5454545454545454,0.9952153110047848,0.2,0.5,0.3333333333333333,2.5714285714285716,-0.4615926708949964,0.0,-0.02631578947368421,3.442962604380975
flink,remotes/origin/bugs-dot-jar_FLINK-3251_117ba95f,1,"@Override
public Option<OperatorCheckpointStats> getOperatorStats(JobVertexID operatorId) {
    synchronized (statsLock) {
        OperatorCheckpointStats stats = operatorStatsCache.get(operatorId);
        if (stats != null) {
            return Option.apply(stats);
        } else if (latestCompletedCheckpoint != null && subTaskStats != null) {
            long[][] subTaskStats = this.subTaskStats.get(operatorId);
            if (subTaskStats == null) {
                throw new IllegalArgumentException(""Unknown operator ID."");
            }
            long maxDuration = Long.MIN_VALUE;
            long stateSize = 0;
            for (long[] subTaskStat : subTaskStats) {
                if (subTaskStat[0] > maxDuration) {
                    maxDuration = subTaskStat[0];
                }
                stateSize += subTaskStat[1];
            }
            stats = new OperatorCheckpointStats(latestCompletedCheckpoint.getCheckpointID(), latestCompletedCheckpoint.getTimestamp(), maxDuration, stateSize, subTaskStats);
            // Remember this and don't recompute if requested again
            operatorStatsCache.put(operatorId, stats);
            return Option.apply(stats);
        } else {
            return Option.empty();
        }
    }
}",,"@Override
public Option<OperatorCheckpointStats> getOperatorStats(JobVertexID operatorId) {
    synchronized (statsLock) {
        OperatorCheckpointStats stats = operatorStatsCache.get(operatorId);
        if (stats != null) {
            return Option.apply(stats);
        } else if (latestCompletedCheckpoint != null && subTaskStats != null) {
            long[][] subTaskStats = this.subTaskStats.get(operatorId);
            if (subTaskStats == null) {
                throw new IllegalArgumentException(""Unknown operator ID."");
            }
            long maxDuration = Long.MIN_VALUE;
            long stateSize = 0;
            for (long[] subTaskStat : subTaskStats) {
                if (subTaskStat[0] > maxDuration) {
                    maxDuration = subTaskStat[0];
                }
                stateSize += subTaskStat[1];
            }
            stats = new OperatorCheckpointStats(latestCompletedCheckpoint.getCheckpointID(), latestCompletedCheckpoint.getTimestamp(), maxDuration, stateSize, subTaskStats);
                        operatorStatsCache.put(operatorId, stats);
            return Option.apply(stats);
        } else {
            return Option.empty();
        }
    }
}",0.5909090909090909,0.9760765550239235,0.6,1.5,0.3333333333333333,0.9960317460317462,-0.44806201550387575,0.16666666666666666,-0.02631578947368421,1.0756268621450755
camel,remotes/origin/bugs-dot-jar_CAMEL-8146_17475d80,3,"@Override
protected void doStop() throws Exception {
    if (future != null) {
        LOG.debug(""This consumer is stopping, so cancelling scheduled task: "" + future);
        future.cancel(false);
        future = null;
    }
}",,"@Override
protected void doStop() throws Exception {
    if (future != null) {
        LOG.debug(""This consumer is stopping, so cancelling scheduled task: "" + future);
        future.cancel(false);
        future = null;
    }
}",-0.2727272727272727,0.22488038277511951,-0.4,-0.5,-0.25,-0.09523809523809523,0.3953488372093024,-0.3333333333333333,1.0263157894736843,-0.11970977910709242
commons-math,remotes/origin/bugs-dot-jar_MATH-1129_d4f978dd,1,"/**
 * Sort in place a (small) array slice using insertion sort
 * @param work array to sort
 * @param begin index of the first element of the slice to sort
 * @param end index after the last element of the slice to sort
 */
private void insertionSort(final double[] work, final int begin, final int end) {
    for (int j = begin + 1; j < end; j++) {
        final double saved = work[j];
        int i = j - 1;
        while ((i >= begin) && (saved < work[i])) {
            work[i + 1] = work[i];
            i--;
        }
        work[i + 1] = saved;
    }
}","/**
 * Sort in place a (small) array slice using insertion sort
 * @param work array to sort
 * @param begin index of the first element of the slice to sort
 * @param end index after the last element of the slice to sort
 */
","private void insertionSort(final double[] work, final int begin, final int end) {
    for (int j = begin + 1; j < end; j++) {
        final double saved = work[j];
        int i = j - 1;
        while ((i >= begin) && (saved < work[i])) {
            work[i + 1] = work[i];
            i--;
        }
        work[i + 1] = saved;
    }
}",-0.13636363636363635,0.4449760765550238,-0.2,0.0,0.25,2.4563492063492065,0.09231853417899943,-0.5,1.1842105263157894,1.0968620874466206
flink,remotes/origin/bugs-dot-jar_FLINK-2447_5546a1ef,1,"@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
private <OUT, IN1, IN2> TypeInformation<OUT> privateGetForClass(Class<OUT> clazz, ArrayList<Type> typeHierarchy, ParameterizedType parameterizedType, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {
    Preconditions.checkNotNull(clazz);
    if (clazz.equals(Object.class)) {
        return new GenericTypeInfo<OUT>(clazz);
    }
    // check for arrays
    if (clazz.isArray()) {
        // primitive arrays: int[], byte[], ...
        PrimitiveArrayTypeInfo<OUT> primitiveArrayInfo = PrimitiveArrayTypeInfo.getInfoFor(clazz);
        if (primitiveArrayInfo != null) {
            return primitiveArrayInfo;
        }
        // basic type arrays: String[], Integer[], Double[]
        BasicArrayTypeInfo<OUT, ?> basicArrayInfo = BasicArrayTypeInfo.getInfoFor(clazz);
        if (basicArrayInfo != null) {
            return basicArrayInfo;
        } else // object arrays
        {
            return ObjectArrayTypeInfo.getInfoFor(clazz);
        }
    }
    // check for writable types
    if (Writable.class.isAssignableFrom(clazz) && !Writable.class.equals(clazz)) {
        return (TypeInformation<OUT>) WritableTypeInfo.getWritableTypeInfo((Class<? extends Writable>) clazz);
    }
    // check for basic types
    TypeInformation<OUT> basicTypeInfo = BasicTypeInfo.getInfoFor(clazz);
    if (basicTypeInfo != null) {
        return basicTypeInfo;
    }
    // check for subclasses of Value
    if (Value.class.isAssignableFrom(clazz)) {
        Class<? extends Value> valueClass = clazz.asSubclass(Value.class);
        return (TypeInformation<OUT>) ValueTypeInfo.getValueTypeInfo(valueClass);
    }
    // check for subclasses of Tuple
    if (Tuple.class.isAssignableFrom(clazz)) {
        throw new InvalidTypesException(""Type information extraction for tuples cannot be done based on the class."");
    }
    // check for Enums
    if (Enum.class.isAssignableFrom(clazz)) {
        return (TypeInformation<OUT>) new EnumTypeInfo(clazz);
    }
    // special case for POJOs generated by Avro.
    if (SpecificRecordBase.class.isAssignableFrom(clazz)) {
        return (TypeInformation<OUT>) new AvroTypeInfo(clazz);
    }
    if (alreadySeen.contains(clazz)) {
        return new GenericTypeInfo<OUT>(clazz);
    }
    alreadySeen.add(clazz);
    if (Modifier.isInterface(clazz.getModifiers())) {
        // Interface has no members and is therefore not handled as POJO
        return new GenericTypeInfo<OUT>(clazz);
    }
    if (clazz.equals(Class.class)) {
        // special case handling for Class, this should not be handled by the POJO logic
        return new GenericTypeInfo<OUT>(clazz);
    }
    try {
        TypeInformation<OUT> pojoType = analyzePojo(clazz, new ArrayList<Type>(typeHierarchy), parameterizedType, in1Type, in2Type);
        if (pojoType != null) {
            return pojoType;
        }
    } catch (InvalidTypesException e) {
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Unable to handle type "" + clazz + "" as POJO. Message: "" + e.getMessage(), e);
        }
    // ignore and create generic type info
    }
    // return a generic type
    return new GenericTypeInfo<OUT>(clazz);
}",,"@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
private <OUT, IN1, IN2> TypeInformation<OUT> privateGetForClass(Class<OUT> clazz, ArrayList<Type> typeHierarchy, ParameterizedType parameterizedType, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {
    Preconditions.checkNotNull(clazz);
    if (clazz.equals(Object.class)) {
        return new GenericTypeInfo<OUT>(clazz);
    }
        if (clazz.isArray()) {
                PrimitiveArrayTypeInfo<OUT> primitiveArrayInfo = PrimitiveArrayTypeInfo.getInfoFor(clazz);
        if (primitiveArrayInfo != null) {
            return primitiveArrayInfo;
        }
                BasicArrayTypeInfo<OUT, ?> basicArrayInfo = BasicArrayTypeInfo.getInfoFor(clazz);
        if (basicArrayInfo != null) {
            return basicArrayInfo;
        } else         {
            return ObjectArrayTypeInfo.getInfoFor(clazz);
        }
    }
        if (Writable.class.isAssignableFrom(clazz) && !Writable.class.equals(clazz)) {
        return (TypeInformation<OUT>) WritableTypeInfo.getWritableTypeInfo((Class<? extends Writable>) clazz);
    }
        TypeInformation<OUT> basicTypeInfo = BasicTypeInfo.getInfoFor(clazz);
    if (basicTypeInfo != null) {
        return basicTypeInfo;
    }
        if (Value.class.isAssignableFrom(clazz)) {
        Class<? extends Value> valueClass = clazz.asSubclass(Value.class);
        return (TypeInformation<OUT>) ValueTypeInfo.getValueTypeInfo(valueClass);
    }
        if (Tuple.class.isAssignableFrom(clazz)) {
        throw new InvalidTypesException(""Type information extraction for tuples cannot be done based on the class."");
    }
        if (Enum.class.isAssignableFrom(clazz)) {
        return (TypeInformation<OUT>) new EnumTypeInfo(clazz);
    }
        if (SpecificRecordBase.class.isAssignableFrom(clazz)) {
        return (TypeInformation<OUT>) new AvroTypeInfo(clazz);
    }
    if (alreadySeen.contains(clazz)) {
        return new GenericTypeInfo<OUT>(clazz);
    }
    alreadySeen.add(clazz);
    if (Modifier.isInterface(clazz.getModifiers())) {
                return new GenericTypeInfo<OUT>(clazz);
    }
    if (clazz.equals(Class.class)) {
                return new GenericTypeInfo<OUT>(clazz);
    }
    try {
        TypeInformation<OUT> pojoType = analyzePojo(clazz, new ArrayList<Type>(typeHierarchy), parameterizedType, in1Type, in2Type);
        if (pojoType != null) {
            return pojoType;
        }
    } catch (InvalidTypesException e) {
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Unable to handle type "" + clazz + "" as POJO. Message: "" + e.getMessage(), e);
        }
        }
        return new GenericTypeInfo<OUT>(clazz);
}",2.1363636363636362,-0.06220095693779921,2.8,0.0,2.4166666666666665,0.6388888888888888,-1.0377730796335445,1.5833333333333333,-0.02631578947368421,2.3179613077228955
commons-math,remotes/origin/bugs-dot-jar_MATH-1103_a6f96306,1,"/**
 * {@inheritDoc}
 */
public Evaluation evaluate(final RealVector point) {
    // evaluate value and jacobian in one function call
    final Pair<RealVector, RealMatrix> value = this.model.value(point);
    return new UnweightedEvaluation(value.getFirst(), value.getSecond(), this.target, point);
}","/**
 * {@inheritDoc}
 */
","public Evaluation evaluate(final RealVector point) {
        final Pair<RealVector, RealMatrix> value = this.model.value(point);
    return new UnweightedEvaluation(value.getFirst(), value.getSecond(), this.target, point);
}",-0.45454545454545453,-0.47368421052631593,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.702889358703312,-0.25,1.131578947368421,-0.16279340490885932
wicket,remotes/origin/bugs-dot-jar_WICKET-2172_ea4a3f8a,3,"/**
 *  @see IValueMap#getAsEnum(String, Class<T>)
 */
public <T extends Enum<T>> T getAsEnum(String key, Class<T> eClass) {
    return getEnumImpl(key, eClass, null);
}","/**
 *  @see IValueMap#getAsEnum(String, Class<T>)
 */
","public <T extends Enum<T>> T getAsEnum(String key, Class<T> eClass) {
    return getEnumImpl(key, eClass, null);
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.8965468639887244,-0.4166666666666667,1.7631578947368423,-0.16279340490885932
camel,remotes/origin/bugs-dot-jar_CAMEL-8125_36e7b668,3,"/**
 * Inspects the given definition and resolves any property placeholders from its properties.
 * <p/>
 * This implementation will check all the getter/setter pairs on this instance and for all the values
 * (which is a String type) will be property placeholder resolved.
 *
 * @param routeContext the route context
 * @param definition   the definition
 * @throws Exception is thrown if property placeholders was used and there was an error resolving them
 * @see org.apache.camel.CamelContext#resolvePropertyPlaceholders(String)
 * @see org.apache.camel.component.properties.PropertiesComponent
 */
public static void resolvePropertyPlaceholders(RouteContext routeContext, Object definition) throws Exception {
    LOG.trace(""Resolving property placeholders for: {}"", definition);
    // find all getter/setter which we can use for property placeholders
    Map<String, Object> properties = new HashMap<String, Object>();
    IntrospectionSupport.getProperties(definition, properties, null);
    ProcessorDefinition<?> processorDefinition = null;
    if (definition instanceof ProcessorDefinition) {
        processorDefinition = (ProcessorDefinition<?>) definition;
    }
    // and when the definition parameter is this (otherAttributes belong to this)
    if (processorDefinition != null && processorDefinition.getOtherAttributes() != null) {
        for (QName key : processorDefinition.getOtherAttributes().keySet()) {
            if (Constants.PLACEHOLDER_QNAME.equals(key.getNamespaceURI())) {
                String local = key.getLocalPart();
                Object value = processorDefinition.getOtherAttributes().get(key);
                if (value != null && value instanceof String) {
                    // value must be enclosed with placeholder tokens
                    String s = (String) value;
                    String prefixToken = routeContext.getCamelContext().getPropertyPrefixToken();
                    String suffixToken = routeContext.getCamelContext().getPropertySuffixToken();
                    if (prefixToken == null) {
                        throw new IllegalArgumentException(""Property with name ["" + local + ""] uses property placeholders; however, no properties component is configured."");
                    }
                    if (!s.startsWith(prefixToken)) {
                        s = prefixToken + s;
                    }
                    if (!s.endsWith(suffixToken)) {
                        s = s + suffixToken;
                    }
                    value = s;
                }
                properties.put(local, value);
            }
        }
    }
    if (!properties.isEmpty()) {
        LOG.trace(""There are {} properties on: {}"", properties.size(), definition);
        // lookup and resolve properties for String based properties
        for (Map.Entry<String, Object> entry : properties.entrySet()) {
            // the name is always a String
            String name = entry.getKey();
            Object value = entry.getValue();
            if (value instanceof String) {
                // value must be a String, as a String is the key for a property placeholder
                String text = (String) value;
                text = routeContext.getCamelContext().resolvePropertyPlaceholders(text);
                if (text != value) {
                    // invoke setter as the text has changed
                    boolean changed = IntrospectionSupport.setProperty(routeContext.getCamelContext().getTypeConverter(), definition, name, text);
                    if (!changed) {
                        throw new IllegalArgumentException(""No setter to set property: "" + name + "" to: "" + text + "" on: "" + definition);
                    }
                    if (LOG.isDebugEnabled()) {
                        LOG.debug(""Changed property [{}] from: {} to: {}"", new Object[] { name, value, text });
                    }
                }
            }
        }
    }
}","/**
 * Inspects the given definition and resolves any property placeholders from its properties.
 * <p/>
 * This implementation will check all the getter/setter pairs on this instance and for all the values
 * (which is a String type) will be property placeholder resolved.
 *
 * @param routeContext the route context
 * @param definition   the definition
 * @throws Exception is thrown if property placeholders was used and there was an error resolving them
 * @see org.apache.camel.CamelContext#resolvePropertyPlaceholders(String)
 * @see org.apache.camel.component.properties.PropertiesComponent
 */
","public static void resolvePropertyPlaceholders(RouteContext routeContext, Object definition) throws Exception {
    LOG.trace(""Resolving property placeholders for: {}"", definition);
        Map<String, Object> properties = new HashMap<String, Object>();
    IntrospectionSupport.getProperties(definition, properties, null);
    ProcessorDefinition<?> processorDefinition = null;
    if (definition instanceof ProcessorDefinition) {
        processorDefinition = (ProcessorDefinition<?>) definition;
    }
        if (processorDefinition != null && processorDefinition.getOtherAttributes() != null) {
        for (QName key : processorDefinition.getOtherAttributes().keySet()) {
            if (Constants.PLACEHOLDER_QNAME.equals(key.getNamespaceURI())) {
                String local = key.getLocalPart();
                Object value = processorDefinition.getOtherAttributes().get(key);
                if (value != null && value instanceof String) {
                                        String s = (String) value;
                    String prefixToken = routeContext.getCamelContext().getPropertyPrefixToken();
                    String suffixToken = routeContext.getCamelContext().getPropertySuffixToken();
                    if (prefixToken == null) {
                        throw new IllegalArgumentException(""Property with name ["" + local + ""] uses property placeholders; however, no properties component is configured."");
                    }
                    if (!s.startsWith(prefixToken)) {
                        s = prefixToken + s;
                    }
                    if (!s.endsWith(suffixToken)) {
                        s = s + suffixToken;
                    }
                    value = s;
                }
                properties.put(local, value);
            }
        }
    }
    if (!properties.isEmpty()) {
        LOG.trace(""There are {} properties on: {}"", properties.size(), definition);
                for (Map.Entry<String, Object> entry : properties.entrySet()) {
                        String name = entry.getKey();
            Object value = entry.getValue();
            if (value instanceof String) {
                                String text = (String) value;
                text = routeContext.getCamelContext().resolvePropertyPlaceholders(text);
                if (text != value) {
                                        boolean changed = IntrospectionSupport.setProperty(routeContext.getCamelContext().getTypeConverter(), definition, name, text);
                    if (!changed) {
                        throw new IllegalArgumentException(""No setter to set property: "" + name + "" to: "" + text + "" on: "" + definition);
                    }
                    if (LOG.isDebugEnabled()) {
                        LOG.debug(""Changed property [{}] from: {} to: {}"", new Object[] { name, value, text });
                    }
                }
            }
        }
    }
}",1.7727272727272727,1.9856459330143539,2.6,1.5,1.9166666666666667,1.1706349206349207,-0.9802677942212825,2.0,-0.02631578947368421,3.9872454948335374
Lang,63,1,"/**
 * <p>Formats the time gap as a string, using the specified format.
 * Padding the left hand side of numbers with zeroes is optional and
 * the timezone may be specified.
 *
 * @param startMillis  the start of the duration
 * @param endMillis  the end of the duration
 * @param format  the way in which to format the duration
 * @param padWithZeros whether to pad the left hand side of numbers with 0's
 * @param timezone the millis are defined in
 * @return the time as a String
 */
public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {
    long millis = endMillis - startMillis;
    if (millis < 28 * DateUtils.MILLIS_PER_DAY) {
        return formatDuration(millis, format, padWithZeros);
    }
    Token[] tokens = lexx(format);
    // timezones get funky around 0, so normalizing everything to GMT
    // stops the hours being off
    Calendar start = Calendar.getInstance(timezone);
    start.setTime(new Date(startMillis));
    Calendar end = Calendar.getInstance(timezone);
    end.setTime(new Date(endMillis));
    // initial estimates
    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);
    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);
    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);
    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);
    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);
    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);
    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);
    // each initial estimate is adjusted in case it is under 0
    while (milliseconds < 0) {
        milliseconds += 1000;
        seconds -= 1;
    }
    while (seconds < 0) {
        seconds += 60;
        minutes -= 1;
    }
    while (minutes < 0) {
        minutes += 60;
        hours -= 1;
    }
    while (hours < 0) {
        hours += 24;
        days -= 1;
    }
    while (days < 0) {
        days += 31;
        // days += 31; // TODO: Need tests to show this is bad and the new code is good.
        // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is
        // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.
        // Also it's contextual - if asked for no M in the format then I should probably
        // be doing no calculating here.
        months -= 1;
    }
    while (months < 0) {
        months += 12;
        years -= 1;
    }
    milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);
    seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);
    minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);
    hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);
    days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);
    months -= reduceAndCorrect(start, end, Calendar.MONTH, months);
    years -= reduceAndCorrect(start, end, Calendar.YEAR, years);
    // number of months and get the real count and not just 0->11.
    if (!Token.containsTokenWithValue(tokens, y)) {
        if (Token.containsTokenWithValue(tokens, M)) {
            months += 12 * years;
            years = 0;
        } else {
            // TODO: this is a bit weak, needs work to know about leap years
            days += 365 * years;
            years = 0;
        }
    }
    if (!Token.containsTokenWithValue(tokens, M)) {
        days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);
        months = 0;
    }
    if (!Token.containsTokenWithValue(tokens, d)) {
        hours += 24 * days;
        days = 0;
    }
    if (!Token.containsTokenWithValue(tokens, H)) {
        minutes += 60 * hours;
        hours = 0;
    }
    if (!Token.containsTokenWithValue(tokens, m)) {
        seconds += 60 * minutes;
        minutes = 0;
    }
    if (!Token.containsTokenWithValue(tokens, s)) {
        milliseconds += 1000 * seconds;
        seconds = 0;
    }
    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);
}","/**
 * <p>Formats the time gap as a string, using the specified format.
 * Padding the left hand side of numbers with zeroes is optional and
 * the timezone may be specified.
 *
 * @param startMillis  the start of the duration
 * @param endMillis  the end of the duration
 * @param format  the way in which to format the duration
 * @param padWithZeros whether to pad the left hand side of numbers with 0's
 * @param timezone the millis are defined in
 * @return the time as a String
 */
","public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {
    long millis = endMillis - startMillis;
    if (millis < 28 * DateUtils.MILLIS_PER_DAY) {
        return formatDuration(millis, format, padWithZeros);
    }
    Token[] tokens = lexx(format);
            Calendar start = Calendar.getInstance(timezone);
    start.setTime(new Date(startMillis));
    Calendar end = Calendar.getInstance(timezone);
    end.setTime(new Date(endMillis));
        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);
    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);
    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);
    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);
    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);
    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);
    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);
        while (milliseconds < 0) {
        milliseconds += 1000;
        seconds -= 1;
    }
    while (seconds < 0) {
        seconds += 60;
        minutes -= 1;
    }
    while (minutes < 0) {
        minutes += 60;
        hours -= 1;
    }
    while (hours < 0) {
        hours += 24;
        days -= 1;
    }
    while (days < 0) {
        days += 31;
                                                months -= 1;
    }
    while (months < 0) {
        months += 12;
        years -= 1;
    }
    milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);
    seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);
    minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);
    hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);
    days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);
    months -= reduceAndCorrect(start, end, Calendar.MONTH, months);
    years -= reduceAndCorrect(start, end, Calendar.YEAR, years);
        if (!Token.containsTokenWithValue(tokens, y)) {
        if (Token.containsTokenWithValue(tokens, M)) {
            months += 12 * years;
            years = 0;
        } else {
                        days += 365 * years;
            years = 0;
        }
    }
    if (!Token.containsTokenWithValue(tokens, M)) {
        days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);
        months = 0;
    }
    if (!Token.containsTokenWithValue(tokens, d)) {
        hours += 24 * days;
        days = 0;
    }
    if (!Token.containsTokenWithValue(tokens, H)) {
        minutes += 60 * hours;
        hours = 0;
    }
    if (!Token.containsTokenWithValue(tokens, m)) {
        seconds += 60 * minutes;
        minutes = 0;
    }
    if (!Token.containsTokenWithValue(tokens, s)) {
        milliseconds += 1000 * seconds;
        seconds = 0;
    }
    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);
}",2.9545454545454546,-0.22966507177033516,2.2,0.0,2.25,2.557539682539683,-1.2322762508809015,2.5833333333333335,-0.02631578947368421,13.703887092777324
wicket,remotes/origin/bugs-dot-jar_WICKET-3297_71499e17,1,"protected static String encodeResourceReferenceAttributes(ResourceReference.UrlAttributes attributes) {
    if (attributes == null || (attributes.getLocale() == null && attributes.getStyle() == null && attributes.getVariation() == null)) {
        return null;
    } else {
        StringBuilder res = new StringBuilder();
        if (attributes.getLocale() != null) {
            res.append(attributes.getLocale().toString());
        }
        if (!Strings.isEmpty(attributes.getStyle())) {
            res.append(""-"");
            res.append(attributes.getStyle());
        }
        if (!Strings.isEmpty(attributes.getVariation())) {
            res.append(""-"");
            res.append(attributes.getVariation());
        }
        return res.toString();
    }
}",,"protected static String encodeResourceReferenceAttributes(ResourceReference.UrlAttributes attributes) {
    if (attributes == null || (attributes.getLocale() == null && attributes.getStyle() == null && attributes.getVariation() == null)) {
        return null;
    } else {
        StringBuilder res = new StringBuilder();
        if (attributes.getLocale() != null) {
            res.append(attributes.getLocale().toString());
        }
        if (!Strings.isEmpty(attributes.getStyle())) {
            res.append(""-"");
            res.append(attributes.getStyle());
        }
        if (!Strings.isEmpty(attributes.getVariation())) {
            res.append(""-"");
            res.append(attributes.getVariation());
        }
        return res.toString();
    }
}",0.22727272727272727,0.3157894736842104,0.2,0.0,0.6666666666666666,1.4900793650793651,-0.23016208597603918,1.0,-0.02631578947368421,1.0855713651792556
camel,remotes/origin/bugs-dot-jar_CAMEL-8964_ea8ee025,1,"public synchronized void suspendRoute(String routeId, long timeout, TimeUnit timeUnit) throws Exception {
    if (!routeSupportsSuspension(routeId)) {
        stopRoute(routeId, timeout, timeUnit);
        return;
    }
    RouteService routeService = routeServices.get(routeId);
    if (routeService != null) {
        List<RouteStartupOrder> routes = new ArrayList<RouteStartupOrder>(1);
        RouteStartupOrder order = new DefaultRouteStartupOrder(1, routeService.getRoutes().iterator().next(), routeService);
        routes.add(order);
        getShutdownStrategy().suspend(this, routes, timeout, timeUnit);
        // must suspend route service as well
        suspendRouteService(routeService);
    }
}",,"public synchronized void suspendRoute(String routeId, long timeout, TimeUnit timeUnit) throws Exception {
    if (!routeSupportsSuspension(routeId)) {
        stopRoute(routeId, timeout, timeUnit);
        return;
    }
    RouteService routeService = routeServices.get(routeId);
    if (routeService != null) {
        List<RouteStartupOrder> routes = new ArrayList<RouteStartupOrder>(1);
        RouteStartupOrder order = new DefaultRouteStartupOrder(1, routeService.getRoutes().iterator().next(), routeService);
        routes.add(order);
        getShutdownStrategy().suspend(this, routes, timeout, timeUnit);
                suspendRouteService(routeService);
    }
}",0.0,-0.05741626794258379,-0.2,-0.5,0.0,-0.0496031746031746,-0.059337561663143155,0.3333333333333333,-0.02631578947368421,0.02368562092633253
wicket,remotes/origin/bugs-dot-jar_WICKET-5582_1fb66533,1,"@Override
public String encodeURL(CharSequence url) {
    Args.notNull(url, ""url"");
    /*
		  WICKET-4645 - always pass absolute url to the web container for encoding
		  because when REDIRECT_TO_BUFFER is in use Wicket may render PageB when
		  PageA is actually the requested one and the web container cannot resolve
		  the base url properly
		 */
    UrlRenderer urlRenderer = RequestCycle.get().getUrlRenderer();
    Url relativeUrl = Url.parse(url);
    String fullUrl = urlRenderer.renderFullUrl(relativeUrl);
    String encodedFullUrl = httpServletResponse.encodeURL(fullUrl);
    final String encodedRelativeUrl;
    if (fullUrl.equals(encodedFullUrl)) {
        // no encoding happened so just reuse the relative url
        encodedRelativeUrl = url.toString();
    } else {
        // get the relative url with the jsessionid encoded in it
        Url _encoded = Url.parse(encodedFullUrl);
        encodedRelativeUrl = urlRenderer.renderRelativeUrl(_encoded);
    }
    return encodedRelativeUrl;
}",,"@Override
public String encodeURL(CharSequence url) {
    Args.notNull(url, ""url"");
        UrlRenderer urlRenderer = RequestCycle.get().getUrlRenderer();
    Url relativeUrl = Url.parse(url);
    String fullUrl = urlRenderer.renderFullUrl(relativeUrl);
    String encodedFullUrl = httpServletResponse.encodeURL(fullUrl);
    final String encodedRelativeUrl;
    if (fullUrl.equals(encodedFullUrl)) {
                encodedRelativeUrl = url.toString();
    } else {
                Url _encoded = Url.parse(encodedFullUrl);
        encodedRelativeUrl = urlRenderer.renderRelativeUrl(_encoded);
    }
    return encodedRelativeUrl;
}",0.09090909090909091,-0.2583732057416268,-0.4,-0.5,-0.16666666666666666,-0.3650793650793651,-0.11571529245947859,0.3333333333333333,-0.02631578947368421,-0.16279340490885932
wicket,remotes/origin/bugs-dot-jar_WICKET-4658_ef3adb12,3,"@Override
protected void onComponentTag(final ComponentTag tag) {
    super.onComponentTag(tag);
    String cssClass = tag.getAttribute(""class"");
    if (cssClass == null) {
        cssClass = "" "";
    }
    cssClass += "" tab"" + getIndex();
    if (getIndex() == getSelectedTab()) {
        cssClass += ' ' + getSelectedTabCssClass();
    }
    if (getIndex() == getTabs().size() - 1) {
        cssClass += ' ' + getLastTabCssClass();
    }
    tag.put(""class"", cssClass.trim());
}",,"@Override
protected void onComponentTag(final ComponentTag tag) {
    super.onComponentTag(tag);
    String cssClass = tag.getAttribute(""class"");
    if (cssClass == null) {
        cssClass = "" "";
    }
    cssClass += "" tab"" + getIndex();
    if (getIndex() == getSelectedTab()) {
        cssClass += ' ' + getSelectedTabCssClass();
    }
    if (getIndex() == getTabs().size() - 1) {
        cssClass += ' ' + getLastTabCssClass();
    }
    tag.put(""class"", cssClass.trim());
}",0.09090909090909091,-0.2583732057416268,0.0,-0.5,0.16666666666666666,0.31547619047619047,-0.10866807610993666,0.5,0.10526315789473684,0.19384404372907332
flink,remotes/origin/bugs-dot-jar_FLINK-2460_a17d4e82,1,"@Override
public Buffer getNextBuffer() throws IOException, InterruptedException {
    if (isReleased.get()) {
        return null;
    }
    // 1) In-memory
    synchronized (parent.buffers) {
        if (parent.isReleased) {
            return null;
        }
        if (parent.spillWriter == null) {
            if (currentQueuePosition < numberOfBuffers) {
                Buffer buffer = parent.buffers.get(currentQueuePosition);
                buffer.retain();
                // TODO Fix hard coding of 8 bytes for the header
                currentBytesRead += buffer.getSize() + 8;
                currentQueuePosition++;
                return buffer;
            }
            return null;
        }
    }
    // 2) Spilled
    if (spilledView != null) {
        return spilledView.getNextBuffer();
    }
    // because this might be called from an network I/O thread.
    if (parent.spillWriter.getNumberOfOutstandingRequests() > 0) {
        return null;
    }
    if (ioMode.isSynchronous()) {
        spilledView = new SpilledSubpartitionViewSyncIO(parent, bufferProvider.getMemorySegmentSize(), parent.spillWriter.getChannelID(), currentBytesRead);
    } else {
        spilledView = new SpilledSubpartitionViewAsyncIO(parent, bufferProvider, parent.ioManager, parent.spillWriter.getChannelID(), currentBytesRead);
    }
    return spilledView.getNextBuffer();
}",,"@Override
public Buffer getNextBuffer() throws IOException, InterruptedException {
    if (isReleased.get()) {
        return null;
    }
        synchronized (parent.buffers) {
        if (parent.isReleased) {
            return null;
        }
        if (parent.spillWriter == null) {
            if (currentQueuePosition < numberOfBuffers) {
                Buffer buffer = parent.buffers.get(currentQueuePosition);
                buffer.retain();
                                currentBytesRead += buffer.getSize() + 8;
                currentQueuePosition++;
                return buffer;
            }
            return null;
        }
    }
        if (spilledView != null) {
        return spilledView.getNextBuffer();
    }
        if (parent.spillWriter.getNumberOfOutstandingRequests() > 0) {
        return null;
    }
    if (ioMode.isSynchronous()) {
        spilledView = new SpilledSubpartitionViewSyncIO(parent, bufferProvider.getMemorySegmentSize(), parent.spillWriter.getChannelID(), currentBytesRead);
    } else {
        spilledView = new SpilledSubpartitionViewAsyncIO(parent, bufferProvider, parent.ioManager, parent.spillWriter.getChannelID(), currentBytesRead);
    }
    return spilledView.getNextBuffer();
}",0.8636363636363636,0.8660287081339711,0.8,0.5,0.8333333333333334,1.3809523809523812,-0.5486962649753347,0.4166666666666667,-0.02631578947368421,1.4553482823602633
wicket,remotes/origin/bugs-dot-jar_WICKET-4594_556a2236,1,"private void resolvePageInstance(Integer pageId, Class<? extends IRequestablePage> pageClass, PageParameters pageParameters, Integer renderCount) {
    IRequestablePage page = null;
    boolean freshCreated = false;
    if (pageId != null) {
        page = getStoredPage(pageId);
    }
    if (page == null) {
        if (pageClass != null) {
            page = getPageSource().newPageInstance(pageClass, pageParameters);
            freshCreated = true;
        }
    }
    if (page != null && !freshCreated) {
        if (renderCount != null && page.getRenderCount() != renderCount) {
            throw new StalePageException(page);
        }
    }
    pageInstanceIsFresh = freshCreated;
    pageInstance = page;
}",,"private void resolvePageInstance(Integer pageId, Class<? extends IRequestablePage> pageClass, PageParameters pageParameters, Integer renderCount) {
    IRequestablePage page = null;
    boolean freshCreated = false;
    if (pageId != null) {
        page = getStoredPage(pageId);
    }
    if (page == null) {
        if (pageClass != null) {
            page = getPageSource().newPageInstance(pageClass, pageParameters);
            freshCreated = true;
        }
    }
    if (page != null && !freshCreated) {
        if (renderCount != null && page.getRenderCount() != renderCount) {
            throw new StalePageException(page);
        }
    }
    pageInstanceIsFresh = freshCreated;
    pageInstance = page;
}",0.2727272727272727,0.22488038277511951,0.6,0.0,0.6666666666666666,0.46428571428571425,-0.26934460887949235,-0.16666666666666666,-0.02631578947368421,0.4055739008661675
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1199_813109d7,3,"@Override
public void read(org.apache.thrift.protocol.TProtocol prot, removeConstraint_result struct) throws org.apache.thrift.TException {
    TTupleProtocol iprot = (TTupleProtocol) prot;
    BitSet incoming = iprot.readBitSet(2);
    if (incoming.get(0)) {
        struct.ouch1 = new AccumuloException();
        struct.ouch1.read(iprot);
        struct.setOuch1IsSet(true);
    }
    if (incoming.get(1)) {
        struct.ouch2 = new AccumuloSecurityException();
        struct.ouch2.read(iprot);
        struct.setOuch2IsSet(true);
    }
}",,"@Override
public void read(org.apache.thrift.protocol.TProtocol prot, removeConstraint_result struct) throws org.apache.thrift.TException {
    TTupleProtocol iprot = (TTupleProtocol) prot;
    BitSet incoming = iprot.readBitSet(2);
    if (incoming.get(0)) {
        struct.ouch1 = new AccumuloException();
        struct.ouch1.read(iprot);
        struct.setOuch1IsSet(true);
    }
    if (incoming.get(1)) {
        struct.ouch2 = new AccumuloSecurityException();
        struct.ouch2.read(iprot);
        struct.setOuch2IsSet(true);
    }
}",0.045454545454545456,0.0,-0.2,-0.5,-0.08333333333333333,-0.3650793650793651,-0.09485553206483423,0.08333333333333333,-0.02631578947368421,-0.16279340490885932
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-843_65390f8c,3,"@Override
public void compact(String tableName, Text start, Text end, boolean flush, boolean wait) throws AccumuloSecurityException, TableNotFoundException, AccumuloException {
    throw new NotImplementedException();
}",,"@Override
public void compact(String tableName, Text start, Text end, boolean flush, boolean wait) throws AccumuloSecurityException, TableNotFoundException, AccumuloException {
    throw new NotImplementedException();
}",-0.45454545454545453,-0.6028708133971293,-0.4,-1.0,-0.4166666666666667,-0.3650793650793651,0.738689217758985,-0.5,-0.02631578947368421,-0.16279340490885932
commons-math,remotes/origin/bugs-dot-jar_MATH-320_c06cc933,1,"/**
 * Solve the linear equation A &times; X = B in least square sense.
 * <p>The m&times;n matrix A may not be square, the solution X is
 * such that ||A &times; X - B|| is minimal.</p>
 * @param b right-hand side of the equation A &times; X = B
 * @return a matrix X that minimizes the two norm of A &times; X - B
 * @exception IllegalArgumentException if matrices dimensions don't match
 * @exception InvalidMatrixException if decomposed matrix is singular
 */
public RealMatrix solve(final RealMatrix b) throws IllegalArgumentException, InvalidMatrixException {
    if (b.getRowDimension() != singularValues.length) {
        throw MathRuntimeException.createIllegalArgumentException(""dimensions mismatch: got {0}x{1} but expected {2}x{3}"", b.getRowDimension(), b.getColumnDimension(), singularValues.length, ""n"");
    }
    final RealMatrix w = uT.multiply(b);
    for (int i = 0; i < singularValues.length; ++i) {
        final double si = singularValues[i];
        if (si == 0) {
            throw new SingularMatrixException();
        }
        final double inv = 1.0 / si;
        for (int j = 0; j < b.getColumnDimension(); ++j) {
            w.multiplyEntry(i, j, inv);
        }
    }
    return v.multiply(w);
}","/**
 * Solve the linear equation A &times; X = B in least square sense.
 * <p>The m&times;n matrix A may not be square, the solution X is
 * such that ||A &times; X - B|| is minimal.</p>
 * @param b right-hand side of the equation A &times; X = B
 * @return a matrix X that minimizes the two norm of A &times; X - B
 * @exception IllegalArgumentException if matrices dimensions don't match
 * @exception InvalidMatrixException if decomposed matrix is singular
 */
","public RealMatrix solve(final RealMatrix b) throws IllegalArgumentException, InvalidMatrixException {
    if (b.getRowDimension() != singularValues.length) {
        throw MathRuntimeException.createIllegalArgumentException(""dimensions mismatch: got {0}x{1} but expected {2}x{3}"", b.getRowDimension(), b.getColumnDimension(), singularValues.length, ""n"");
    }
    final RealMatrix w = uT.multiply(b);
    for (int i = 0; i < singularValues.length; ++i) {
        final double si = singularValues[i];
        if (si == 0) {
            throw new SingularMatrixException();
        }
        final double inv = 1.0 / si;
        for (int j = 0; j < b.getColumnDimension(); ++j) {
            w.multiplyEntry(i, j, inv);
        }
    }
    return v.multiply(w);
}",0.13636363636363635,0.1913875598086124,0.6,0.0,0.4166666666666667,0.8948412698412698,-0.21381254404510194,0.16666666666666666,0.0,0.8173464036467787
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-2899_31aea2ad,0,"private int removeMetadataEntries(Map<String, Path> nameToFileMap, Map<String, Path> sortedWALogs, GCStatus status) throws IOException, KeeperException, InterruptedException {
    int count = 0;
    Iterator<LogEntry> iterator = MetadataTableUtil.getLogEntries(SystemCredentials.get());
    while (iterator.hasNext()) {
        for (String entry : iterator.next().logSet) {
            String uuid = new Path(entry).getName();
            if (!isUUID(uuid)) {
                // fully expect this to be a uuid, if its not then something is wrong and walog GC should not proceed!
                throw new IllegalArgumentException(""Expected uuid, but got "" + uuid + "" from "" + entry);
            }
            Path pathFromNN = nameToFileMap.remove(uuid);
            if (pathFromNN != null) {
                status.currentLog.inUse++;
                sortedWALogs.remove(uuid);
            }
            count++;
        }
    }
    return count;
}",,"private int removeMetadataEntries(Map<String, Path> nameToFileMap, Map<String, Path> sortedWALogs, GCStatus status) throws IOException, KeeperException, InterruptedException {
    int count = 0;
    Iterator<LogEntry> iterator = MetadataTableUtil.getLogEntries(SystemCredentials.get());
    while (iterator.hasNext()) {
        for (String entry : iterator.next().logSet) {
            String uuid = new Path(entry).getName();
            if (!isUUID(uuid)) {
                                throw new IllegalArgumentException(""Expected uuid, but got "" + uuid + "" from "" + entry);
            }
            Path pathFromNN = nameToFileMap.remove(uuid);
            if (pathFromNN != null) {
                status.currentLog.inUse++;
                sortedWALogs.remove(uuid);
            }
            count++;
        }
    }
    return count;
}",0.22727272727272727,1.0191387559808613,0.4,0.5,0.16666666666666666,0.27380952380952384,-0.26821705426356585,0.16666666666666666,-0.02631578947368421,0.3704569423073598
camel,remotes/origin/bugs-dot-jar_CAMEL-6889_cd40b712,1,"public boolean process(final Exchange exchange, final AsyncCallback callback) {
    Iterator<Processor> processors = next().iterator();
    // callback to restore existing FILTER_MATCHED property on the Exchange
    final Object existing = exchange.getProperty(Exchange.FILTER_MATCHED);
    final AsyncCallback choiceCallback = new AsyncCallback() {

        @Override
        public void done(boolean doneSync) {
            if (existing != null) {
                exchange.setProperty(Exchange.FILTER_MATCHED, existing);
            } else {
                exchange.removeProperty(Exchange.FILTER_MATCHED);
            }
            callback.done(doneSync);
        }
    };
    // and if not, we just continue without using any processor
    while (processors.hasNext()) {
        // get the next processor
        Processor processor = processors.next();
        // evaluate the predicate on filter predicate early to be faster
        // and avoid issues when having nested choices
        // as we should only pick one processor
        boolean matches = true;
        if (processor instanceof FilterProcessor) {
            FilterProcessor filter = (FilterProcessor) processor;
            try {
                matches = filter.getPredicate().matches(exchange);
                exchange.setProperty(Exchange.FILTER_MATCHED, matches);
            } catch (Throwable e) {
                exchange.setException(e);
                choiceCallback.done(true);
                return true;
            }
            // as we have pre evaluated the predicate then use its processor directly when routing
            processor = filter.getProcessor();
        }
        // if we did not match then continue to next filter
        if (!matches) {
            continue;
        }
        // okay we found a filter or its the otherwise we are processing
        AsyncProcessor async = AsyncProcessorConverterHelper.convert(processor);
        return async.process(exchange, choiceCallback);
    }
    // when no filter matches and there is no otherwise, then just continue
    choiceCallback.done(true);
    return true;
}",,"public boolean process(final Exchange exchange, final AsyncCallback callback) {
    Iterator<Processor> processors = next().iterator();
        final Object existing = exchange.getProperty(Exchange.FILTER_MATCHED);
    final AsyncCallback choiceCallback = new AsyncCallback() {

        @Override
        public void done(boolean doneSync) {
            if (existing != null) {
                exchange.setProperty(Exchange.FILTER_MATCHED, existing);
            } else {
                exchange.removeProperty(Exchange.FILTER_MATCHED);
            }
            callback.done(doneSync);
        }
    };
        while (processors.hasNext()) {
                Processor processor = processors.next();
                                boolean matches = true;
        if (processor instanceof FilterProcessor) {
            FilterProcessor filter = (FilterProcessor) processor;
            try {
                matches = filter.getPredicate().matches(exchange);
                exchange.setProperty(Exchange.FILTER_MATCHED, matches);
            } catch (Throwable e) {
                exchange.setException(e);
                choiceCallback.done(true);
                return true;
            }
                        processor = filter.getProcessor();
        }
                if (!matches) {
            continue;
        }
                AsyncProcessor async = AsyncProcessorConverterHelper.convert(processor);
        return async.process(exchange, choiceCallback);
    }
        choiceCallback.done(true);
    return true;
}",1.0909090909090908,0.7703349282296649,0.6,0.5,0.25,0.10119047619047619,-0.645947850599013,0.9166666666666666,-0.02631578947368421,0.40259101098989747
camel,remotes/origin/bugs-dot-jar_CAMEL-7611_e30f1c53,1,"@SuppressWarnings(""unchecked"")
@Override
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    if (o == null || getClass() != o.getClass()) {
        return false;
    }
    KeyValueHolder<K, V> that = (KeyValueHolder<K, V>) o;
    if (key != null ? !key.equals(that.key) : that.key != null) {
        return false;
    }
    return true;
}",,"@SuppressWarnings(""unchecked"")
@Override
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    if (o == null || getClass() != o.getClass()) {
        return false;
    }
    KeyValueHolder<K, V> that = (KeyValueHolder<K, V>) o;
    if (key != null ? !key.equals(that.key) : that.key != null) {
        return false;
    }
    return true;
}",0.045454545454545456,-0.1291866028708134,0.2,-0.5,0.3333333333333333,0.4781746031746032,-0.05623678646934473,-0.25,0.5789473684210527,0.1986710695412135
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-3006_d6472040,0,"@Override
public boolean isReady() throws IOException {
    for (Volume volume : getFileSystems().values()) {
        FileSystem fs = volume.getFileSystem();
        if (ViewFSUtils.isViewFS(fs)) {
            try {
                FileSystem resolvedFs = ViewFSUtils.resolvePath(fs, new Path(""/"")).getFileSystem(fs.getConf());
                log.debug(""resolved "" + fs.getUri() + "" to "" + resolvedFs.getUri() + "" for ready check"");
                fs = resolvedFs;
            } catch (IOException e) {
                log.warn(""Failed to resolve "" + fs.getUri(), e);
            }
        }
        if (!(fs instanceof DistributedFileSystem))
            continue;
        DistributedFileSystem dfs = (DistributedFileSystem) fs;
        // So this: if (!dfs.setSafeMode(SafeModeAction.SAFEMODE_GET))
        // Becomes this:
        Class<?> safeModeAction;
        try {
            // hadoop 2.0
            safeModeAction = Class.forName(""org.apache.hadoop.hdfs.protocol.HdfsConstants$SafeModeAction"");
        } catch (ClassNotFoundException ex) {
            // hadoop 1.0
            try {
                safeModeAction = Class.forName(""org.apache.hadoop.hdfs.protocol.FSConstants$SafeModeAction"");
            } catch (ClassNotFoundException e) {
                throw new RuntimeException(""Cannot figure out the right class for Constants"");
            }
        }
        Object get = null;
        for (Object obj : safeModeAction.getEnumConstants()) {
            if (obj.toString().equals(""SAFEMODE_GET""))
                get = obj;
        }
        if (get == null) {
            throw new RuntimeException(""cannot find SAFEMODE_GET"");
        }
        try {
            Method setSafeMode = dfs.getClass().getMethod(""setSafeMode"", safeModeAction);
            boolean inSafeMode = (Boolean) setSafeMode.invoke(dfs, get);
            if (inSafeMode) {
                return false;
            }
        } catch (IllegalArgumentException exception) {
            /* Send IAEs back as-is, so that those that wrap UnknownHostException can be handled in the same place as similar sources of failure. */
            throw exception;
        } catch (Exception ex) {
            throw new RuntimeException(""cannot find method setSafeMode"");
        }
    }
    return true;
}",,"@Override
public boolean isReady() throws IOException {
    for (Volume volume : getFileSystems().values()) {
        FileSystem fs = volume.getFileSystem();
        if (ViewFSUtils.isViewFS(fs)) {
            try {
                FileSystem resolvedFs = ViewFSUtils.resolvePath(fs, new Path(""/"")).getFileSystem(fs.getConf());
                log.debug(""resolved "" + fs.getUri() + "" to "" + resolvedFs.getUri() + "" for ready check"");
                fs = resolvedFs;
            } catch (IOException e) {
                log.warn(""Failed to resolve "" + fs.getUri(), e);
            }
        }
        if (!(fs instanceof DistributedFileSystem))
            continue;
        DistributedFileSystem dfs = (DistributedFileSystem) fs;
                        Class<?> safeModeAction;
        try {
                        safeModeAction = Class.forName(""org.apache.hadoop.hdfs.protocol.HdfsConstants$SafeModeAction"");
        } catch (ClassNotFoundException ex) {
                        try {
                safeModeAction = Class.forName(""org.apache.hadoop.hdfs.protocol.FSConstants$SafeModeAction"");
            } catch (ClassNotFoundException e) {
                throw new RuntimeException(""Cannot figure out the right class for Constants"");
            }
        }
        Object get = null;
        for (Object obj : safeModeAction.getEnumConstants()) {
            if (obj.toString().equals(""SAFEMODE_GET""))
                get = obj;
        }
        if (get == null) {
            throw new RuntimeException(""cannot find SAFEMODE_GET"");
        }
        try {
            Method setSafeMode = dfs.getClass().getMethod(""setSafeMode"", safeModeAction);
            boolean inSafeMode = (Boolean) setSafeMode.invoke(dfs, get);
            if (inSafeMode) {
                return false;
            }
        } catch (IllegalArgumentException exception) {
                        throw exception;
        } catch (Exception ex) {
            throw new RuntimeException(""cannot find method setSafeMode"");
        }
    }
    return true;
}",1.5454545454545454,0.5598086124401914,2.8,0.5,0.4166666666666667,0.33531746031746024,-0.8714587737843548,1.1666666666666667,-0.02631578947368421,1.0100770503045704
wicket,remotes/origin/bugs-dot-jar_WICKET-5209_55eb5212,1,"/**
 *  Collects the html generated by the rendering of a component.
 *
 *  @param component
 *             the component to render.
 *  @return the html rendered by the component
 */
public static CharSequence renderComponent(final Component component) {
    RequestCycle requestCycle = RequestCycle.get();
    final Response originalResponse = requestCycle.getResponse();
    BufferedWebResponse tempResponse = new BufferedWebResponse(null);
    try {
        requestCycle.setResponse(tempResponse);
        RenderPage page = new RenderPage();
        page.add(component);
        component.render();
    } finally {
        requestCycle.setResponse(originalResponse);
    }
    return tempResponse.getText();
}","/**
 *  Collects the html generated by the rendering of a component.
 *
 *  @param component
 *             the component to render.
 *  @return the html rendered by the component
 */
","public static CharSequence renderComponent(final Component component) {
    RequestCycle requestCycle = RequestCycle.get();
    final Response originalResponse = requestCycle.getResponse();
    BufferedWebResponse tempResponse = new BufferedWebResponse(null);
    try {
        requestCycle.setResponse(tempResponse);
        RenderPage page = new RenderPage();
        page.add(component);
        component.render();
    } finally {
        requestCycle.setResponse(originalResponse);
    }
    return tempResponse.getText();
}",0.0,-0.13875598086124405,-0.6,-0.5,-0.4166666666666667,-0.3650793650793651,0.01987315010570819,0.08333333333333333,0.05263157894736841,-0.16279340490885932
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3433_b76b31f7,0,"BackgroundWriteStats backgroundWrite() {
    return unsavedLastRevisions.persist(this, new UnsavedModifications.Snapshot() {

        @Override
        public void acquiring() {
            if (store.create(JOURNAL, singletonList(changes.asUpdateOp(getHeadRevision())))) {
                changes = JOURNAL.newDocument(getDocumentStore());
            }
        }
    }, backgroundOperationLock.writeLock());
}",,"BackgroundWriteStats backgroundWrite() {
    return unsavedLastRevisions.persist(this, new UnsavedModifications.Snapshot() {

        @Override
        public void acquiring() {
            if (store.create(JOURNAL, singletonList(changes.asUpdateOp(getHeadRevision())))) {
                changes = JOURNAL.newDocument(getDocumentStore());
            }
        }
    }, backgroundOperationLock.writeLock());
}",-0.18181818181818182,0.9617224880382774,-0.4,0.0,0.0,-0.3650793650793651,0.23664552501761787,0.16666666666666666,0.42105263157894735,-0.16279340490885932
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-177_f91ce934,1,"@Override
public synchronized void flush() throws IOException {
    if (this.ds != null && this.address != null) {
        final DatagramPacket packet = new DatagramPacket(data, data.length, address, port);
        ds.send(packet);
    }
    data = null;
}",,"@Override
public synchronized void flush() throws IOException {
    if (this.ds != null && this.address != null) {
        final DatagramPacket packet = new DatagramPacket(data, data.length, address, port);
        ds.send(packet);
    }
    data = null;
}",-0.2727272727272727,0.06220095693779899,-0.4,-0.5,-0.08333333333333333,-0.04365079365079365,0.3341789992952784,-0.4166666666666667,0.39473684210526316,-0.08533969560231208
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3792_94110f21,3,"private boolean changePassword(User user, SimpleCredentials credentials) {
    try {
        Object newPasswordObject = credentials.getAttribute(CREDENTIALS_ATTRIBUTE_NEWPASSWORD);
        if (newPasswordObject != null) {
            if (newPasswordObject instanceof String) {
                user.changePassword((String) newPasswordObject);
                root.commit();
                log.debug(""User "" + userId + "": changed user password"");
                return true;
            } else {
                log.warn(""Aborted password change for user "" + userId + "": provided new password is of incompatible type "" + newPasswordObject.getClass().getName());
            }
        }
    } catch (PasswordHistoryException e) {
        credentials.setAttribute(e.getClass().getName(), e.getMessage());
        log.error(""Failed to change password for user "" + userId, e.getMessage());
    } catch (RepositoryException e) {
        log.error(""Failed to change password for user "" + userId, e.getMessage());
    } catch (CommitFailedException e) {
        root.refresh();
        log.error(""Failed to change password for user "" + userId, e.getMessage());
    }
    return false;
}",,"private boolean changePassword(User user, SimpleCredentials credentials) {
    try {
        Object newPasswordObject = credentials.getAttribute(CREDENTIALS_ATTRIBUTE_NEWPASSWORD);
        if (newPasswordObject != null) {
            if (newPasswordObject instanceof String) {
                user.changePassword((String) newPasswordObject);
                root.commit();
                log.debug(""User "" + userId + "": changed user password"");
                return true;
            } else {
                log.warn(""Aborted password change for user "" + userId + "": provided new password is of incompatible type "" + newPasswordObject.getClass().getName());
            }
        }
    } catch (PasswordHistoryException e) {
        credentials.setAttribute(e.getClass().getName(), e.getMessage());
        log.error(""Failed to change password for user "" + userId, e.getMessage());
    } catch (RepositoryException e) {
        log.error(""Failed to change password for user "" + userId, e.getMessage());
    } catch (CommitFailedException e) {
        root.refresh();
        log.error(""Failed to change password for user "" + userId, e.getMessage());
    }
    return false;
}",0.45454545454545453,0.9330143540669857,0.4,0.5,-0.16666666666666666,0.02579365079365077,-0.39055673009161385,1.0,-0.02631578947368421,0.19971300634498015
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1894_35562cce,1,"@Override
public double getCost(Filter filter, NodeState root) {
    if (filter.getFullTextConstraint() != null) {
        // not an appropriate index for full-text search
        return Double.POSITIVE_INFINITY;
    }
    if (filter.containsNativeConstraint()) {
        // not an appropriate index for native search
        return Double.POSITIVE_INFINITY;
    }
    PropertyIndexLookup lookup = getLookup(root);
    for (PropertyRestriction pr : filter.getPropertyRestrictions()) {
        String propertyName = PathUtils.getName(pr.propertyName);
        // currently, only indexes on the root node are supported
        if (lookup.isIndexed(propertyName, ""/"", filter)) {
            if (pr.firstIncluding && pr.lastIncluding && pr.first != null && pr.first.equals(pr.last)) {
                // ""[property] = $value""
                return lookup.getCost(filter, propertyName, pr.first);
            } else if (pr.list != null) {
                double cost = 0;
                for (PropertyValue p : pr.list) {
                    cost += lookup.getCost(filter, propertyName, p);
                }
                return cost;
            } else {
                // processed as ""[property] is not null""
                return lookup.getCost(filter, propertyName, null);
            }
        }
    }
    // not an appropriate index
    return Double.POSITIVE_INFINITY;
}",,"@Override
public double getCost(Filter filter, NodeState root) {
    if (filter.getFullTextConstraint() != null) {
                return Double.POSITIVE_INFINITY;
    }
    if (filter.containsNativeConstraint()) {
                return Double.POSITIVE_INFINITY;
    }
    PropertyIndexLookup lookup = getLookup(root);
    for (PropertyRestriction pr : filter.getPropertyRestrictions()) {
        String propertyName = PathUtils.getName(pr.propertyName);
                if (lookup.isIndexed(propertyName, ""/"", filter)) {
            if (pr.firstIncluding && pr.lastIncluding && pr.first != null && pr.first.equals(pr.last)) {
                                return lookup.getCost(filter, propertyName, pr.first);
            } else if (pr.list != null) {
                double cost = 0;
                for (PropertyValue p : pr.list) {
                    cost += lookup.getCost(filter, propertyName, p);
                }
                return cost;
            } else {
                                return lookup.getCost(filter, propertyName, null);
            }
        }
    }
        return Double.POSITIVE_INFINITY;
}",0.5909090909090909,1.325358851674641,0.8,1.5,1.1666666666666667,0.5218253968253967,-0.47371388301620826,0.3333333333333333,-0.02631578947368421,0.7566051762590549
flink,remotes/origin/bugs-dot-jar_FLINK-1458_91f9bfc7,1,"// --------------------------------------------------------------------------------------------
// Utility methods
// --------------------------------------------------------------------------------------------
/**
 *  @param curT : start type
 *  @return Type The immediate child of the top class
 */
private static Type getTypeHierarchy(ArrayList<Type> typeHierarchy, Type curT, Class<?> stopAtClass) {
    // skip first one
    if (typeHierarchy.size() > 0 && typeHierarchy.get(0) == curT && isClassType(curT)) {
        curT = typeToClass(curT).getGenericSuperclass();
    }
    while (!(isClassType(curT) && typeToClass(curT).equals(stopAtClass))) {
        typeHierarchy.add(curT);
        curT = typeToClass(curT).getGenericSuperclass();
    }
    return curT;
}","/**
 *  @param curT : start type
 *  @return Type The immediate child of the top class
 */
","private static Type getTypeHierarchy(ArrayList<Type> typeHierarchy, Type curT, Class<?> stopAtClass) {
        if (typeHierarchy.size() > 0 && typeHierarchy.get(0) == curT && isClassType(curT)) {
        curT = typeToClass(curT).getGenericSuperclass();
    }
    while (!(isClassType(curT) && typeToClass(curT).equals(stopAtClass))) {
        typeHierarchy.add(curT);
        curT = typeToClass(curT).getGenericSuperclass();
    }
    return curT;
}",-0.18181818181818182,-0.0909090909090911,-0.2,-0.5,0.5,0.5515873015873016,0.131782945736434,0.4166666666666667,-0.02631578947368421,0.2586608115350702
commons-math,remotes/origin/bugs-dot-jar_MATH-757_76b7413d,1,"/**
 * Returns the ""start index"" of the internal array.
 * This index is the position of the first addressable element in the
 * internal storage array.
 * The addressable elements in the array are at indices contained in
 * the interval [{@link #getStartIndex()},
 *               {@link #getStartIndex()} + {@link #getNumElements()} - 1].
 *
 * @return the start index.
 * @since 3.1
 */
protected int getStartIndex() {
    return startIndex;
}","/**
 * Returns the ""start index"" of the internal array.
 * This index is the position of the first addressable element in the
 * internal storage array.
 * The addressable elements in the array are at indices contained in
 * the interval [{@link #getStartIndex()},
 *               {@link #getStartIndex()} + {@link #getNumElements()} - 1].
 *
 * @return the start index.
 * @since 3.1
 */
","protected int getStartIndex() {
    return startIndex;
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,1.2407329105003524,-0.5,2.3947368421052633,-0.16279340490885932
wicket,remotes/origin/bugs-dot-jar_WICKET-4494_35843c19,1,"@Override
public void postProcess(final Markup markup) {
    // If there's still a non-simple tag left, it's an error
    while (stack.size() > 0) {
        final ComponentTag top = stack.peek();
        if (!requiresCloseTag(top.getName())) {
            stack.pop();
        } else {
            throw new MarkupException(markup, ""Tag does not have a close tag"", null);
        }
    }
}",,"@Override
public void postProcess(final Markup markup) {
        while (stack.size() > 0) {
        final ComponentTag top = stack.peek();
        if (!requiresCloseTag(top.getName())) {
            stack.pop();
        } else {
            throw new MarkupException(markup, ""Tag does not have a close tag"", null);
        }
    }
}",-0.13636363636363635,0.6267942583732056,0.0,0.0,0.0,-0.11904761904761907,0.17632135306553895,-0.08333333333333333,0.39473684210526316,-0.10372112054309802
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-633_8dad5e0f,3,"// this is only ever called immediately after getting ""next"" entry
@Override
protected void consume() throws IOException {
    int count = 0;
    while (getSource().hasTop() && lastRowFound.equals(getSource().getTopKey().getRow())) {
        // try to efficiently jump to the next matching key
        if (count < numscans) {
            ++count;
            // scan
            getSource().next();
        } else {
            // too many scans, just seek
            count = 0;
            // determine where to seek to, but don't go beyond the user-specified range
            Key nextKey = getSource().getTopKey().followingKey(PartialKey.ROW);
            if (!latestRange.afterEndKey(nextKey))
                getSource().seek(new Range(nextKey, true, latestRange.getEndKey(), latestRange.isEndKeyInclusive()), latestColumnFamilies, latestInclusive);
        }
    }
    lastRowFound = getSource().hasTop() ? getSource().getTopKey().getRow(lastRowFound) : null;
}",,"@Override
protected void consume() throws IOException {
    int count = 0;
    while (getSource().hasTop() && lastRowFound.equals(getSource().getTopKey().getRow())) {
                if (count < numscans) {
            ++count;
                        getSource().next();
        } else {
                        count = 0;
                        Key nextKey = getSource().getTopKey().followingKey(PartialKey.ROW);
            if (!latestRange.afterEndKey(nextKey))
                getSource().seek(new Range(nextKey, true, latestRange.getEndKey(), latestRange.isEndKeyInclusive()), latestColumnFamilies, latestInclusive);
        }
    }
    lastRowFound = getSource().hasTop() ? getSource().getTopKey().getRow(lastRowFound) : null;
}",0.09090909090909091,0.9330143540669857,0.2,0.0,0.5833333333333334,0.3055555555555555,-0.15207892882311472,1.25,-0.02631578947368421,0.28899684768013456
wicket,remotes/origin/bugs-dot-jar_WICKET-3511_4a875f46,1,"public String getReference() {
    return null;
}",,"public String getReference() {
    return null;
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,1.1646229739252991,-0.5,2.1842105263157894,-0.16279340490885932
commons-math,remotes/origin/bugs-dot-jar_MATH-554_fbbb96eb,1,"/**
 * Compute the cross-product of two vectors.
 * @param v1 first vector
 * @param v2 second vector
 * @return the cross product v1 ^ v2 as a new Vector
 */
public static Vector3D crossProduct(Vector3D v1, Vector3D v2) {
    return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);
}","/**
 * Compute the cross-product of two vectors.
 * @param v1 first vector
 * @param v2 second vector
 * @return the cross product v1 ^ v2 as a new Vector
 */
","public static Vector3D crossProduct(Vector3D v1, Vector3D v2) {
    return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,0.4285714285714286,0.7491190979563072,-0.5,0.05263157894736841,0.08837790955665815
wicket,remotes/origin/bugs-dot-jar_WICKET-5968_8b7946d8,1,"@Override
public boolean equals(Object o) {
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    if (!super.equals(o))
        return false;
    CacheKey cacheKey = (CacheKey) o;
    return !(extension != null ? !extension.equals(cacheKey.extension) : cacheKey.extension != null);
}",,"@Override
public boolean equals(Object o) {
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    if (!super.equals(o))
        return false;
    CacheKey cacheKey = (CacheKey) o;
    return !(extension != null ? !extension.equals(cacheKey.extension) : cacheKey.extension != null);
}",-0.13636363636363635,-0.01913875598086126,0.2,-1.0,0.4166666666666667,0.5932539682539683,0.10669485553206472,-0.16666666666666666,0.763157894736842,0.19242866939829298
flink,remotes/origin/bugs-dot-jar_FLINK-1761_380ef878,1,"private boolean decodeBufferOrEvent(RemoteInputChannel inputChannel, NettyMessage.BufferResponse bufferOrEvent) throws Throwable {
    boolean releaseNettyBuffer = true;
    try {
        if (bufferOrEvent.isBuffer()) {
            // ---- Buffer ------------------------------------------------
            BufferProvider bufferProvider = inputChannel.getBufferProvider();
            if (bufferProvider == null) {
                // receiver has been cancelled/failed
                return false;
            }
            while (true) {
                Buffer buffer = bufferProvider.requestBuffer();
                if (buffer != null) {
                    buffer.setSize(bufferOrEvent.getSize());
                    bufferOrEvent.getNettyBuffer().readBytes(buffer.getNioBuffer());
                    inputChannel.onBuffer(buffer, bufferOrEvent.sequenceNumber);
                    return true;
                } else if (bufferListener.waitForBuffer(bufferProvider, bufferOrEvent)) {
                    releaseNettyBuffer = false;
                    return false;
                } else if (bufferProvider.isDestroyed()) {
                    return false;
                }
            }
        } else {
            // ---- Event -------------------------------------------------
            // TODO We can just keep the serialized data in the Netty buffer and release it later at the reader
            byte[] byteArray = new byte[bufferOrEvent.getSize()];
            bufferOrEvent.getNettyBuffer().readBytes(byteArray);
            Buffer buffer = new Buffer(new MemorySegment(byteArray), EventSerializer.RECYCLER, false);
            inputChannel.onBuffer(buffer, bufferOrEvent.sequenceNumber);
            return true;
        }
    } finally {
        if (releaseNettyBuffer) {
            bufferOrEvent.releaseBuffer();
        }
    }
}",,"private boolean decodeBufferOrEvent(RemoteInputChannel inputChannel, NettyMessage.BufferResponse bufferOrEvent) throws Throwable {
    boolean releaseNettyBuffer = true;
    try {
        if (bufferOrEvent.isBuffer()) {
                        BufferProvider bufferProvider = inputChannel.getBufferProvider();
            if (bufferProvider == null) {
                                return false;
            }
            while (true) {
                Buffer buffer = bufferProvider.requestBuffer();
                if (buffer != null) {
                    buffer.setSize(bufferOrEvent.getSize());
                    bufferOrEvent.getNettyBuffer().readBytes(buffer.getNioBuffer());
                    inputChannel.onBuffer(buffer, bufferOrEvent.sequenceNumber);
                    return true;
                } else if (bufferListener.waitForBuffer(bufferProvider, bufferOrEvent)) {
                    releaseNettyBuffer = false;
                    return false;
                } else if (bufferProvider.isDestroyed()) {
                    return false;
                }
            }
        } else {
                                    byte[] byteArray = new byte[bufferOrEvent.getSize()];
            bufferOrEvent.getNettyBuffer().readBytes(byteArray);
            Buffer buffer = new Buffer(new MemorySegment(byteArray), EventSerializer.RECYCLER, false);
            inputChannel.onBuffer(buffer, bufferOrEvent.sequenceNumber);
            return true;
        }
    } finally {
        if (releaseNettyBuffer) {
            bufferOrEvent.releaseBuffer();
        }
    }
}",0.9545454545454546,1.334928229665072,0.8,2.0,0.75,0.07341269841269839,-0.5875968992248061,0.8333333333333334,-0.02631578947368421,0.2769361986595436
camel,remotes/origin/bugs-dot-jar_CAMEL-3395_8433e6db,3,"public Object next() {
    Object part = iterator.next();
    Exchange newExchange = exchange.copy();
    if (part instanceof Message) {
        newExchange.setIn((Message) part);
    } else {
        Message in = newExchange.getIn();
        in.setBody(part);
    }
    return createProcessorExchangePair(index++, getProcessors().iterator().next(), newExchange);
}",,"public Object next() {
    Object part = iterator.next();
    Exchange newExchange = exchange.copy();
    if (part instanceof Message) {
        newExchange.setIn((Message) part);
    } else {
        Message in = newExchange.getIn();
        in.setBody(part);
    }
    return createProcessorExchangePair(index++, getProcessors().iterator().next(), newExchange);
}",-0.13636363636363635,-0.15311004784689008,-0.4,-0.5,-0.25,-0.015873015873015886,0.14080338266384787,0.25,0.13157894736842105,-0.045285063075211934
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1977_4bfbfcdd,1,"/**
 * queries through the index as other query() but provides the PropertyRestriction to be applied
 * for advanced cases like range queries
 *
 * @param filter
 * @param indexName
 * @param indexMeta
 * @param indexStorageNodeName
 * @param pr
 * @return the iterable
 */
public Iterable<String> query(final Filter filter, final String indexName, final NodeState indexMeta, final String indexStorageNodeName, final PropertyRestriction pr) {
    if (LOG.isDebugEnabled()) {
        LOG.debug(""query() - filter: {}"", filter);
        LOG.debug(""query() - indexName: {}"", indexName);
        LOG.debug(""query() - indexMeta: {}"", indexMeta);
        LOG.debug(""query() - indexStorageNodeName: {}"", indexStorageNodeName);
        LOG.debug(""query() - pr: {}"", pr);
    }
    final NodeState indexState = indexMeta.getChildNode(indexStorageNodeName);
    final NodeBuilder index = new ReadOnlyBuilder(indexState);
    final String firstEncoded = (pr.first == null) ? null : encode(pr.first.getValue(Type.STRING));
    final String lastEncoded = (pr.last == null) ? null : encode(pr.last.getValue(Type.STRING));
    if (firstEncoded != null && !firstEncoded.equals(lastEncoded)) {
        // '>' & '>=' and between use case
        LOG.debug(""'>' & '>=' and between use case"");
        ChildNodeEntry firstValueableItem;
        String firstValuableItemKey;
        Iterable<String> it = Collections.emptyList();
        Iterable<ChildNodeEntry> childrenIterable;
        if (lastEncoded == null) {
            LOG.debug(""> & >= case."");
            firstValuableItemKey = seek(index, new PredicateGreaterThan(firstEncoded, pr.firstIncluding));
            if (firstValuableItemKey != null) {
                firstValueableItem = new OrderedChildNodeEntry(firstValuableItemKey, indexState.getChildNode(firstValuableItemKey));
                if (direction.isAscending()) {
                    childrenIterable = new SeekedIterable(indexState, firstValueableItem);
                    it = new QueryResultsWrapper(filter, indexName, childrenIterable);
                } else {
                    it = new QueryResultsWrapper(filter, indexName, new BetweenIterable(indexState, firstValueableItem, firstEncoded, pr.firstIncluding, direction));
                }
            }
        } else {
            String first, last;
            boolean includeFirst, includeLast;
            first = firstEncoded;
            last = lastEncoded;
            includeFirst = pr.firstIncluding;
            includeLast = pr.lastIncluding;
            if (LOG.isDebugEnabled()) {
                final String op1 = includeFirst ? "">="" : "">"";
                final String op2 = includeLast ? ""<="" : ""<"";
                LOG.debug(""in between case. direction: {} - Condition: (x {} {} AND x {} {})"", new Object[] { direction, op1, first, op2, last });
            }
            if (direction.equals(OrderDirection.ASC)) {
                firstValuableItemKey = seek(index, new PredicateGreaterThan(first, includeFirst));
            } else {
                firstValuableItemKey = seek(index, new PredicateLessThan(last, includeLast));
            }
            LOG.debug(""firstValueableItem: {}"", firstValuableItemKey);
            if (firstValuableItemKey != null) {
                firstValueableItem = new OrderedChildNodeEntry(firstValuableItemKey, indexState.getChildNode(firstValuableItemKey));
                childrenIterable = new BetweenIterable(indexState, firstValueableItem, last, includeLast, direction);
                it = new QueryResultsWrapper(filter, indexName, childrenIterable);
            }
        }
        return it;
    } else if (lastEncoded != null && !lastEncoded.equals(firstEncoded)) {
        // '<' & '<=' use case
        LOG.debug(""'<' & '<=' use case"");
        final String searchfor = lastEncoded;
        final boolean include = pr.lastIncluding;
        Predicate<String> predicate = new PredicateLessThan(searchfor, include);
        LOG.debug(""< & <= case. - searchfor: {} - include: {} - predicate: {}"", new Object[] { searchfor, include, predicate });
        ChildNodeEntry firstValueableItem;
        String firstValueableItemKey = seek(index, predicate);
        LOG.debug(""firstValuableItem: {}"", firstValueableItemKey);
        Iterable<String> it = Collections.emptyList();
        if (firstValueableItemKey != null) {
            firstValueableItem = new OrderedChildNodeEntry(firstValueableItemKey, indexState.getChildNode(firstValueableItemKey));
            if (direction.isAscending()) {
                it = new QueryResultsWrapper(filter, indexName, new BetweenIterable(indexState, firstValueableItem, searchfor, include, direction));
            } else {
                it = new QueryResultsWrapper(filter, indexName, new SeekedIterable(indexState, firstValueableItem));
            }
        }
        return it;
    } else {
        // property is not null. AKA ""open query""
        LOG.debug(""property is not null. AKA 'open query'. FullIterable"");
        return new QueryResultsWrapper(filter, indexName, new FullIterable(indexState, false));
    }
}","/**
 * queries through the index as other query() but provides the PropertyRestriction to be applied
 * for advanced cases like range queries
 *
 * @param filter
 * @param indexName
 * @param indexMeta
 * @param indexStorageNodeName
 * @param pr
 * @return the iterable
 */
","public Iterable<String> query(final Filter filter, final String indexName, final NodeState indexMeta, final String indexStorageNodeName, final PropertyRestriction pr) {
    if (LOG.isDebugEnabled()) {
        LOG.debug(""query() - filter: {}"", filter);
        LOG.debug(""query() - indexName: {}"", indexName);
        LOG.debug(""query() - indexMeta: {}"", indexMeta);
        LOG.debug(""query() - indexStorageNodeName: {}"", indexStorageNodeName);
        LOG.debug(""query() - pr: {}"", pr);
    }
    final NodeState indexState = indexMeta.getChildNode(indexStorageNodeName);
    final NodeBuilder index = new ReadOnlyBuilder(indexState);
    final String firstEncoded = (pr.first == null) ? null : encode(pr.first.getValue(Type.STRING));
    final String lastEncoded = (pr.last == null) ? null : encode(pr.last.getValue(Type.STRING));
    if (firstEncoded != null && !firstEncoded.equals(lastEncoded)) {
                LOG.debug(""'>' & '>=' and between use case"");
        ChildNodeEntry firstValueableItem;
        String firstValuableItemKey;
        Iterable<String> it = Collections.emptyList();
        Iterable<ChildNodeEntry> childrenIterable;
        if (lastEncoded == null) {
            LOG.debug(""> & >= case."");
            firstValuableItemKey = seek(index, new PredicateGreaterThan(firstEncoded, pr.firstIncluding));
            if (firstValuableItemKey != null) {
                firstValueableItem = new OrderedChildNodeEntry(firstValuableItemKey, indexState.getChildNode(firstValuableItemKey));
                if (direction.isAscending()) {
                    childrenIterable = new SeekedIterable(indexState, firstValueableItem);
                    it = new QueryResultsWrapper(filter, indexName, childrenIterable);
                } else {
                    it = new QueryResultsWrapper(filter, indexName, new BetweenIterable(indexState, firstValueableItem, firstEncoded, pr.firstIncluding, direction));
                }
            }
        } else {
            String first, last;
            boolean includeFirst, includeLast;
            first = firstEncoded;
            last = lastEncoded;
            includeFirst = pr.firstIncluding;
            includeLast = pr.lastIncluding;
            if (LOG.isDebugEnabled()) {
                final String op1 = includeFirst ? "">="" : "">"";
                final String op2 = includeLast ? ""<="" : ""<"";
                LOG.debug(""in between case. direction: {} - Condition: (x {} {} AND x {} {})"", new Object[] { direction, op1, first, op2, last });
            }
            if (direction.equals(OrderDirection.ASC)) {
                firstValuableItemKey = seek(index, new PredicateGreaterThan(first, includeFirst));
            } else {
                firstValuableItemKey = seek(index, new PredicateLessThan(last, includeLast));
            }
            LOG.debug(""firstValueableItem: {}"", firstValuableItemKey);
            if (firstValuableItemKey != null) {
                firstValueableItem = new OrderedChildNodeEntry(firstValuableItemKey, indexState.getChildNode(firstValuableItemKey));
                childrenIterable = new BetweenIterable(indexState, firstValueableItem, last, includeLast, direction);
                it = new QueryResultsWrapper(filter, indexName, childrenIterable);
            }
        }
        return it;
    } else if (lastEncoded != null && !lastEncoded.equals(firstEncoded)) {
                LOG.debug(""'<' & '<=' use case"");
        final String searchfor = lastEncoded;
        final boolean include = pr.lastIncluding;
        Predicate<String> predicate = new PredicateLessThan(searchfor, include);
        LOG.debug(""< & <= case. - searchfor: {} - include: {} - predicate: {}"", new Object[] { searchfor, include, predicate });
        ChildNodeEntry firstValueableItem;
        String firstValueableItemKey = seek(index, predicate);
        LOG.debug(""firstValuableItem: {}"", firstValueableItemKey);
        Iterable<String> it = Collections.emptyList();
        if (firstValueableItemKey != null) {
            firstValueableItem = new OrderedChildNodeEntry(firstValueableItemKey, indexState.getChildNode(firstValueableItemKey));
            if (direction.isAscending()) {
                it = new QueryResultsWrapper(filter, indexName, new BetweenIterable(indexState, firstValueableItem, searchfor, include, direction));
            } else {
                it = new QueryResultsWrapper(filter, indexName, new SeekedIterable(indexState, firstValueableItem));
            }
        }
        return it;
    } else {
                LOG.debug(""property is not null. AKA 'open query'. FullIterable"");
        return new QueryResultsWrapper(filter, indexName, new FullIterable(indexState, false));
    }
}",2.9545454545454546,0.6937799043062203,2.4,1.0,2.0833333333333335,1.0813492063492063,-1.2429880197322054,2.3333333333333335,-0.02631578947368421,6.906604888112814
Math,71,0,"/**
 * {@inheritDoc}
 */
public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException {
    sanityChecks(equations, t0, y0, t, y);
    setEquations(equations);
    resetEvaluations();
    final boolean forward = t > t0;
    // create some internal working arrays
    final int stages = c.length + 1;
    if (y != y0) {
        System.arraycopy(y0, 0, y, 0, y0.length);
    }
    final double[][] yDotK = new double[stages][];
    for (int i = 0; i < stages; ++i) {
        yDotK[i] = new double[y0.length];
    }
    final double[] yTmp = new double[y0.length];
    // set up an interpolator sharing the integrator arrays
    AbstractStepInterpolator interpolator;
    if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {
        final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();
        rki.reinitialize(this, yTmp, yDotK, forward);
        interpolator = rki;
    } else {
        interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);
    }
    interpolator.storeTime(t0);
    // set up integration control objects
    stepStart = t0;
    stepSize = forward ? step : -step;
    for (StepHandler handler : stepHandlers) {
        handler.reset();
    }
    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);
    boolean lastStep = false;
    // main integration loop
    while (!lastStep) {
        interpolator.shift();
        for (boolean loop = true; loop; ) {
            // first stage
            computeDerivatives(stepStart, y, yDotK[0]);
            // next stages
            for (int k = 1; k < stages; ++k) {
                for (int j = 0; j < y0.length; ++j) {
                    double sum = a[k - 1][0] * yDotK[0][j];
                    for (int l = 1; l < k; ++l) {
                        sum += a[k - 1][l] * yDotK[l][j];
                    }
                    yTmp[j] = y[j] + stepSize * sum;
                }
                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);
            }
            // estimate the state at the end of the step
            for (int j = 0; j < y0.length; ++j) {
                double sum = b[0] * yDotK[0][j];
                for (int l = 1; l < stages; ++l) {
                    sum += b[l] * yDotK[l][j];
                }
                yTmp[j] = y[j] + stepSize * sum;
            }
            // discrete events handling
            interpolator.storeTime(stepStart + stepSize);
            if (manager.evaluateStep(interpolator)) {
                final double dt = manager.getEventTime() - stepStart;
                if (Math.abs(dt) <= Math.ulp(stepStart)) {
                    // we cannot simply truncate the step, reject the current computation
                    // and let the loop compute another state with the truncated step.
                    // it is so small (much probably exactly 0 due to limited accuracy)
                    // that the code above would fail handling it.
                    // So we set up an artificial 0 size step by copying states
                    loop = false;
                } else {
                    // reject the step to match exactly the next switch time
                    stepSize = dt;
                }
            } else {
                loop = false;
            }
        }
        // the step has been accepted
        final double nextStep = stepStart + stepSize;
        System.arraycopy(yTmp, 0, y, 0, y0.length);
        manager.stepAccepted(nextStep, y);
        lastStep = manager.stop();
        // provide the step data to the step handler
        interpolator.storeTime(nextStep);
        for (StepHandler handler : stepHandlers) {
            handler.handleStep(interpolator, lastStep);
        }
        stepStart = nextStep;
        if (manager.reset(stepStart, y) && !lastStep) {
            // some events handler has triggered changes that
            // invalidate the derivatives, we need to recompute them
            computeDerivatives(stepStart, y, yDotK[0]);
        }
        // make sure step size is set to default before next step
        stepSize = forward ? step : -step;
    }
    final double stopTime = stepStart;
    stepStart = Double.NaN;
    stepSize = Double.NaN;
    return stopTime;
}","/**
 * {@inheritDoc}
 */
","public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException {
    sanityChecks(equations, t0, y0, t, y);
    setEquations(equations);
    resetEvaluations();
    final boolean forward = t > t0;
        final int stages = c.length + 1;
    if (y != y0) {
        System.arraycopy(y0, 0, y, 0, y0.length);
    }
    final double[][] yDotK = new double[stages][];
    for (int i = 0; i < stages; ++i) {
        yDotK[i] = new double[y0.length];
    }
    final double[] yTmp = new double[y0.length];
        AbstractStepInterpolator interpolator;
    if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {
        final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();
        rki.reinitialize(this, yTmp, yDotK, forward);
        interpolator = rki;
    } else {
        interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);
    }
    interpolator.storeTime(t0);
        stepStart = t0;
    stepSize = forward ? step : -step;
    for (StepHandler handler : stepHandlers) {
        handler.reset();
    }
    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);
    boolean lastStep = false;
        while (!lastStep) {
        interpolator.shift();
        for (boolean loop = true; loop; ) {
                        computeDerivatives(stepStart, y, yDotK[0]);
                        for (int k = 1; k < stages; ++k) {
                for (int j = 0; j < y0.length; ++j) {
                    double sum = a[k - 1][0] * yDotK[0][j];
                    for (int l = 1; l < k; ++l) {
                        sum += a[k - 1][l] * yDotK[l][j];
                    }
                    yTmp[j] = y[j] + stepSize * sum;
                }
                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);
            }
                        for (int j = 0; j < y0.length; ++j) {
                double sum = b[0] * yDotK[0][j];
                for (int l = 1; l < stages; ++l) {
                    sum += b[l] * yDotK[l][j];
                }
                yTmp[j] = y[j] + stepSize * sum;
            }
                        interpolator.storeTime(stepStart + stepSize);
            if (manager.evaluateStep(interpolator)) {
                final double dt = manager.getEventTime() - stepStart;
                if (Math.abs(dt) <= Math.ulp(stepStart)) {
                                                                                                                        loop = false;
                } else {
                                        stepSize = dt;
                }
            } else {
                loop = false;
            }
        }
                final double nextStep = stepStart + stepSize;
        System.arraycopy(yTmp, 0, y, 0, y0.length);
        manager.stepAccepted(nextStep, y);
        lastStep = manager.stop();
                interpolator.storeTime(nextStep);
        for (StepHandler handler : stepHandlers) {
            handler.handleStep(interpolator, lastStep);
        }
        stepStart = nextStep;
        if (manager.reset(stepStart, y) && !lastStep) {
                                    computeDerivatives(stepStart, y, yDotK[0]);
        }
                stepSize = forward ? step : -step;
    }
    final double stopTime = stepStart;
    stepStart = Double.NaN;
    stepSize = Double.NaN;
    return stopTime;
}",3.090909090909091,1.2775119617224882,2.8,1.5,2.6666666666666665,3.9781746031746033,-1.27568710359408,1.6666666666666667,-0.02631578947368421,21.445910916708442
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1364_b481a14c,1,"synchronized void refresh(K key, int hash, CacheLoader<K, V> loader) throws ExecutionException {
    V value;
    V old = get(key, hash);
    long start = System.nanoTime();
    try {
        if (old == null) {
            value = loader.load(key);
        } else {
            ListenableFuture<V> future = loader.reload(key, old);
            value = future.get();
        }
        loadSuccessCount++;
    } catch (Exception e) {
        loadExceptionCount++;
        throw new ExecutionException(e);
    } finally {
        long time = System.nanoTime() - start;
        totalLoadTime += time;
    }
    put(key, hash, value, cache.sizeOf(key, value));
}",,"synchronized void refresh(K key, int hash, CacheLoader<K, V> loader) throws ExecutionException {
    V value;
    V old = get(key, hash);
    long start = System.nanoTime();
    try {
        if (old == null) {
            value = loader.load(key);
        } else {
            ListenableFuture<V> future = loader.reload(key, old);
            value = future.get();
        }
        loadSuccessCount++;
    } catch (Exception e) {
        loadExceptionCount++;
        throw new ExecutionException(e);
    } finally {
        long time = System.nanoTime() - start;
        totalLoadTime += time;
    }
    put(key, hash, value, cache.sizeOf(key, value));
}",0.3181818181818182,0.1961722488038276,0.0,0.0,-0.25,0.4007936507936507,-0.29330514446793515,0.16666666666666666,0.0,0.4441209522656938
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-43_668f08f2,1,"public void moveNode(String srcPath, String destPath) throws NotFoundException, Exception {
    if (PathUtils.isAncestor(srcPath, destPath)) {
        throw new Exception(""target path cannot be descendant of source path: "" + destPath);
    }
    String srcParentPath = PathUtils.getParentPath(srcPath);
    String srcNodeName = PathUtils.getName(srcPath);
    String destParentPath = PathUtils.getParentPath(destPath);
    String destNodeName = PathUtils.getName(destPath);
    MutableNode srcParent = getOrCreateStagedNode(srcParentPath);
    if (srcParentPath.equals(destParentPath)) {
        if (srcParent.getChildNodeEntry(destNodeName) != null) {
            throw new Exception(""node already exists at move destination path: "" + destPath);
        }
        if (srcParent.rename(srcNodeName, destNodeName) == null) {
            throw new NotFoundException(srcPath);
        }
    } else {
        ChildNode srcCNE = srcParent.remove(srcNodeName);
        if (srcCNE == null) {
            throw new NotFoundException(srcPath);
        }
        MutableNode destParent = getOrCreateStagedNode(destParentPath);
        if (destParent.getChildNodeEntry(destNodeName) != null) {
            throw new Exception(""node already exists at move destination path: "" + destPath);
        }
        destParent.add(new ChildNode(destNodeName, srcCNE.getId()));
    }
    // update staging area
    moveStagedNodes(srcPath, destPath);
    // update change log
    changeLog.add(new MoveNode(srcPath, destPath));
}",,"public void moveNode(String srcPath, String destPath) throws NotFoundException, Exception {
    if (PathUtils.isAncestor(srcPath, destPath)) {
        throw new Exception(""target path cannot be descendant of source path: "" + destPath);
    }
    String srcParentPath = PathUtils.getParentPath(srcPath);
    String srcNodeName = PathUtils.getName(srcPath);
    String destParentPath = PathUtils.getParentPath(destPath);
    String destNodeName = PathUtils.getName(destPath);
    MutableNode srcParent = getOrCreateStagedNode(srcParentPath);
    if (srcParentPath.equals(destParentPath)) {
        if (srcParent.getChildNodeEntry(destNodeName) != null) {
            throw new Exception(""node already exists at move destination path: "" + destPath);
        }
        if (srcParent.rename(srcNodeName, destNodeName) == null) {
            throw new NotFoundException(srcPath);
        }
    } else {
        ChildNode srcCNE = srcParent.remove(srcNodeName);
        if (srcCNE == null) {
            throw new NotFoundException(srcPath);
        }
        MutableNode destParent = getOrCreateStagedNode(destParentPath);
        if (destParent.getChildNodeEntry(destNodeName) != null) {
            throw new Exception(""node already exists at move destination path: "" + destPath);
        }
        destParent.add(new ChildNode(destNodeName, srcCNE.getId()));
    }
        moveStagedNodes(srcPath, destPath);
        changeLog.add(new MoveNode(srcPath, destPath));
}",0.7272727272727273,0.10047846889952151,1.6,0.0,1.0,0.7162698412698413,-0.5760394644115574,0.8333333333333334,-0.02631578947368421,1.1996450038323447
camel,remotes/origin/bugs-dot-jar_CAMEL-7586_1f92fa42,3,"public boolean isMessageHistory() {
    return context.isMessageHistory();
}",,"public boolean isMessageHistory() {
    return context.isMessageHistory();
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,1.1987315010570823,-0.4166666666666667,0.9473684210526315,-0.16279340490885932
camel,remotes/origin/bugs-dot-jar_CAMEL-7990_d581c4a4,1,"public boolean process(Exchange exchange, AsyncCallback callback) {
    final String messageId = messageIdExpression.evaluate(exchange, String.class);
    if (messageId == null) {
        throw new NoMessageIdException(exchange, messageIdExpression);
    }
    boolean newKey;
    if (eager) {
        // add the key to the repository
        if (idempotentRepository instanceof ExchangeIdempotentRepository) {
            newKey = ((ExchangeIdempotentRepository<String>) idempotentRepository).add(exchange, messageId);
        } else {
            newKey = idempotentRepository.add(messageId);
        }
    } else {
        // check if we already have the key
        if (idempotentRepository instanceof ExchangeIdempotentRepository) {
            newKey = ((ExchangeIdempotentRepository<String>) idempotentRepository).contains(exchange, messageId);
        } else {
            newKey = !idempotentRepository.contains(messageId);
        }
    }
    if (!newKey) {
        // mark the exchange as duplicate
        exchange.setProperty(Exchange.DUPLICATE_MESSAGE, Boolean.TRUE);
        // we already have this key so its a duplicate message
        onDuplicate(exchange, messageId);
        if (skipDuplicate) {
            // if we should skip duplicate then we are done
            LOG.debug(""Ignoring duplicate message with id: {} for exchange: {}"", messageId, exchange);
            callback.done(true);
            return true;
        }
    }
    // register our on completion callback
    exchange.addOnCompletion(new IdempotentOnCompletion(idempotentRepository, messageId, eager, removeOnFailure));
    // process the exchange
    return processor.process(exchange, callback);
}",,"public boolean process(Exchange exchange, AsyncCallback callback) {
    final String messageId = messageIdExpression.evaluate(exchange, String.class);
    if (messageId == null) {
        throw new NoMessageIdException(exchange, messageIdExpression);
    }
    boolean newKey;
    if (eager) {
                if (idempotentRepository instanceof ExchangeIdempotentRepository) {
            newKey = ((ExchangeIdempotentRepository<String>) idempotentRepository).add(exchange, messageId);
        } else {
            newKey = idempotentRepository.add(messageId);
        }
    } else {
                if (idempotentRepository instanceof ExchangeIdempotentRepository) {
            newKey = ((ExchangeIdempotentRepository<String>) idempotentRepository).contains(exchange, messageId);
        } else {
            newKey = !idempotentRepository.contains(messageId);
        }
    }
    if (!newKey) {
                exchange.setProperty(Exchange.DUPLICATE_MESSAGE, Boolean.TRUE);
                onDuplicate(exchange, messageId);
        if (skipDuplicate) {
                        LOG.debug(""Ignoring duplicate message with id: {} for exchange: {}"", messageId, exchange);
            callback.done(true);
            return true;
        }
    }
        exchange.addOnCompletion(new IdempotentOnCompletion(idempotentRepository, messageId, eager, removeOnFailure));
        return processor.process(exchange, callback);
}",0.7727272727272727,0.24880382775119597,0.8,0.0,0.5,0.09126984126984122,-0.5326286116983789,0.4166666666666667,-0.02631578947368421,0.2983097341562789
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-217_add180fb,1,"@Override
public Set<String> listIterators(String tableName) throws AccumuloSecurityException, AccumuloException, TableNotFoundException {
    Set<String> result = new HashSet<String>();
    Set<String> lifecycles = new HashSet<String>();
    for (IteratorScope scope : IteratorScope.values()) lifecycles.add(scope.name().toLowerCase());
    for (Entry<String, String> property : this.getProperties(tableName)) {
        String name = property.getKey();
        String[] parts = name.split(""\\."");
        if (parts.length == 4) {
            if (parts[0].equals(""table"") && parts[1].equals(""iterator"") && lifecycles.contains(parts[2]))
                result.add(parts[3]);
        }
    }
    return result;
}",,"@Override
public Set<String> listIterators(String tableName) throws AccumuloSecurityException, AccumuloException, TableNotFoundException {
    Set<String> result = new HashSet<String>();
    Set<String> lifecycles = new HashSet<String>();
    for (IteratorScope scope : IteratorScope.values()) lifecycles.add(scope.name().toLowerCase());
    for (Entry<String, String> property : this.getProperties(tableName)) {
        String name = property.getKey();
        String[] parts = name.split(""\\."");
        if (parts.length == 4) {
            if (parts[0].equals(""table"") && parts[1].equals(""iterator"") && lifecycles.contains(parts[2]))
                result.add(parts[3]);
        }
    }
    return result;
}",0.045454545454545456,0.6411483253588517,0.2,0.0,0.25,-0.0019841269841269858,-0.1571529245947851,0.4166666666666667,-0.02631578947368421,0.14689695314165843
Closure,70,2,"/**
 * Declares all of a function's arguments.
 */
private void declareArguments(Node functionNode) {
    Node astParameters = functionNode.getFirstChild().getNext();
    Node body = astParameters.getNext();
    FunctionType functionType = (FunctionType) functionNode.getJSType();
    if (functionType != null) {
        Node jsDocParameters = functionType.getParametersNode();
        if (jsDocParameters != null) {
            Node jsDocParameter = jsDocParameters.getFirstChild();
            for (Node astParameter : astParameters.children()) {
                if (jsDocParameter != null) {
                    defineSlot(astParameter, functionNode, jsDocParameter.getJSType(), true);
                    jsDocParameter = jsDocParameter.getNext();
                } else {
                    defineSlot(astParameter, functionNode, null, true);
                }
            }
        }
    }
}","/**
 * Declares all of a function's arguments.
 */
","private void declareArguments(Node functionNode) {
    Node astParameters = functionNode.getFirstChild().getNext();
    Node body = astParameters.getNext();
    FunctionType functionType = (FunctionType) functionNode.getJSType();
    if (functionType != null) {
        Node jsDocParameters = functionType.getParametersNode();
        if (jsDocParameters != null) {
            Node jsDocParameter = jsDocParameters.getFirstChild();
            for (Node astParameter : astParameters.children()) {
                if (jsDocParameter != null) {
                    defineSlot(astParameter, functionNode, jsDocParameter.getJSType(), true);
                    jsDocParameter = jsDocParameter.getNext();
                } else {
                    defineSlot(astParameter, functionNode, null, true);
                }
            }
        }
    }
}",0.22727272727272727,1.6985645933014355,0.2,1.0,0.08333333333333333,0.15674603174603172,-0.2140944326990838,0.4166666666666667,0.0,0.15161794113748608
Math,93,3,"/**
 * Returns n!. Shorthand for <code>n</code> <a
 * href=""http://mathworld.wolfram.com/Factorial.html""> Factorial</a>, the
 * product of the numbers <code>1,...,n</code>.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>n >= 0</code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>long</code>. The
 * largest value of <code>n</code> for which <code>n!</code> <
 * Long.MAX_VALUE</code> is 20. If the computed value exceeds <code>Long.MAX_VALUE</code>
 * an <code>ArithMeticException </code> is thrown.</li>
 * </ul>
 * </p>
 *
 * @param n argument
 * @return <code>n!</code>
 * @throws ArithmeticException if the result is too large to be represented
 *         by a long integer.
 * @throws IllegalArgumentException if n < 0
 */
public static long factorial(final int n) {
    long result = Math.round(factorialDouble(n));
    if (result == Long.MAX_VALUE) {
        throw new ArithmeticException(""factorial value is too large to fit in a long"");
    }
    return factorials[n];
}","/**
 * Returns n!. Shorthand for <code>n</code> <a
 * href=""http://mathworld.wolfram.com/Factorial.html""> Factorial</a>, the
 * product of the numbers <code>1,...,n</code>.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>n >= 0</code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>long</code>. The
 * largest value of <code>n</code> for which <code>n!</code> <
 * Long.MAX_VALUE</code> is 20. If the computed value exceeds <code>Long.MAX_VALUE</code>
 * an <code>ArithMeticException </code> is thrown.</li>
 * </ul>
 * </p>
 *
 * @param n argument
 * @return <code>n!</code>
 * @throws ArithmeticException if the result is too large to be represented
 *         by a long integer.
 * @throws IllegalArgumentException if n < 0
 */
","public static long factorial(final int n) {
    long result = Math.round(factorialDouble(n));
    if (result == Long.MAX_VALUE) {
        throw new ArithmeticException(""factorial value is too large to fit in a long"");
    }
    return factorials[n];
}",-0.3181818181818182,-0.20574162679425848,-0.2,-0.5,-0.25,-0.11706349206349208,0.4582100070472161,-0.3333333333333333,-0.02631578947368421,-0.12549114526604543
Closure,120,2,"/**
 * @return Whether the variable is only assigned a value once for its
 *     lifetime.
 */
boolean isAssignedOnceInLifetime() {
    Reference ref = getOneAndOnlyAssignment();
    if (ref == null) {
        return false;
    }
    // Make sure this assignment is not in a loop.
    for (BasicBlock block = ref.getBasicBlock(); block != null; block = block.getParent()) {
        if (block.isFunction) {
            break;
        } else if (block.isLoop) {
            return false;
        }
    }
    return true;
}","/**
 * @return Whether the variable is only assigned a value once for its
 *     lifetime.
 */
","boolean isAssignedOnceInLifetime() {
    Reference ref = getOneAndOnlyAssignment();
    if (ref == null) {
        return false;
    }
        for (BasicBlock block = ref.getBasicBlock(); block != null; block = block.getParent()) {
        if (block.isFunction) {
            break;
        } else if (block.isLoop) {
            return false;
        }
    }
    return true;
}",0.0,0.29665071770334916,0.4,0.5,0.25,-0.039682539682539715,0.03875968992248061,-0.25,1.0,-0.07610979524328186
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-1251_424068f7,1,"@Override
public void log(final LogRecord record) {
    if (isFiltered(record)) {
        return;
    }
    final org.apache.logging.log4j.Level level = LevelTranslator.toLevel(record.getLevel());
    final Message message = logger.getMessageFactory().newMessage(record.getMessage(), record.getParameters());
    final Throwable thrown = record.getThrown();
    logger.logIfEnabled(FQCN, level, null, message, thrown);
}",,"@Override
public void log(final LogRecord record) {
    if (isFiltered(record)) {
        return;
    }
    final org.apache.logging.log4j.Level level = LevelTranslator.toLevel(record.getLevel());
    final Message message = logger.getMessageFactory().newMessage(record.getMessage(), record.getParameters());
    final Throwable thrown = record.getThrown();
    logger.logIfEnabled(FQCN, level, null, message, thrown);
}",-0.18181818181818182,-0.2822966507177035,-0.4,-0.5,-0.16666666666666666,-0.3650793650793651,0.14080338266384787,0.25,-0.02631578947368421,-0.16279340490885932
commons-math,remotes/origin/bugs-dot-jar_MATH-812_6eb46555,1,"/**
 * {@inheritDoc}
 */
@Override
public double dotProduct(RealVector v) {
    if (v instanceof ArrayRealVector) {
        final double[] vData = ((ArrayRealVector) v).data;
        checkVectorDimensions(vData.length);
        double dot = 0;
        for (int i = 0; i < data.length; i++) {
            dot += data[i] * vData[i];
        }
        return dot;
    } else {
        checkVectorDimensions(v);
        double dot = 0;
        Iterator<Entry> it = v.sparseIterator();
        while (it.hasNext()) {
            final Entry e = it.next();
            dot += data[e.getIndex()] * e.getValue();
        }
        return dot;
    }
}","/**
 * {@inheritDoc}
 */
","@Override
public double dotProduct(RealVector v) {
    if (v instanceof ArrayRealVector) {
        final double[] vData = ((ArrayRealVector) v).data;
        checkVectorDimensions(vData.length);
        double dot = 0;
        for (int i = 0; i < data.length; i++) {
            dot += data[i] * vData[i];
        }
        return dot;
    } else {
        checkVectorDimensions(v);
        double dot = 0;
        Iterator<Entry> it = v.sparseIterator();
        while (it.hasNext()) {
            final Entry e = it.next();
            dot += data[e.getIndex()] * e.getValue();
        }
        return dot;
    }
}",0.3181818181818182,0.2535885167464114,0.0,0.0,0.16666666666666666,0.5376984126984127,-0.27216349541930934,0.08333333333333333,0.39473684210526316,0.4549967439474881
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-398_2c966ad9,1,"@SuppressWarnings(""unchecked"")
protected void doConfigure() {
    boolean setRoot = false;
    boolean setLoggers = false;
    for (final Node child : rootNode.getChildren()) {
        createConfiguration(child, null);
        if (child.getObject() == null) {
            continue;
        }
        if (child.getName().equalsIgnoreCase(""Properties"")) {
            if (tempLookup == subst.getVariableResolver()) {
                subst.setVariableResolver((StrLookup) child.getObject());
            } else {
                LOGGER.error(""Properties declaration must be the first element in the configuration"");
            }
            continue;
        } else if (tempLookup == subst.getVariableResolver()) {
            final Map<String, String> map = (Map<String, String>) componentMap.get(CONTEXT_PROPERTIES);
            final StrLookup lookup = map == null ? null : new MapLookup(map);
            subst.setVariableResolver(new Interpolator(lookup));
        }
        if (child.getName().equalsIgnoreCase(""Appenders"")) {
            appenders = (ConcurrentMap<String, Appender>) child.getObject();
        } else if (child.getObject() instanceof Filter) {
            addFilter((Filter) child.getObject());
        } else if (child.getName().equalsIgnoreCase(""Loggers"")) {
            final Loggers l = (Loggers) child.getObject();
            loggers = l.getMap();
            setLoggers = true;
            if (l.getRoot() != null) {
                root = l.getRoot();
                setRoot = true;
            }
        } else {
            LOGGER.error(""Unknown object \"""" + child.getName() + ""\"" of type "" + child.getObject().getClass().getName() + "" is ignored"");
        }
    }
    if (!setLoggers) {
        LOGGER.warn(""No Loggers were configured, using default. Is the Loggers element missing?"");
        setToDefault();
        return;
    } else if (!setRoot) {
        LOGGER.warn(""No Root logger was configured, creating default ERROR-level Root logger with Console appender"");
        setToDefault();
    // return; // LOG4J2-219: creating default root=ok, but don't exclude configured Loggers
    }
    for (final Map.Entry<String, LoggerConfig> entry : loggers.entrySet()) {
        final LoggerConfig l = entry.getValue();
        for (final AppenderRef ref : l.getAppenderRefs()) {
            final Appender app = appenders.get(ref.getRef());
            if (app != null) {
                l.addAppender(app, ref.getLevel(), ref.getFilter());
            } else {
                LOGGER.error(""Unable to locate appender "" + ref.getRef() + "" for logger "" + l.getName());
            }
        }
    }
    setParents();
}",,"@SuppressWarnings(""unchecked"")
protected void doConfigure() {
    boolean setRoot = false;
    boolean setLoggers = false;
    for (final Node child : rootNode.getChildren()) {
        createConfiguration(child, null);
        if (child.getObject() == null) {
            continue;
        }
        if (child.getName().equalsIgnoreCase(""Properties"")) {
            if (tempLookup == subst.getVariableResolver()) {
                subst.setVariableResolver((StrLookup) child.getObject());
            } else {
                LOGGER.error(""Properties declaration must be the first element in the configuration"");
            }
            continue;
        } else if (tempLookup == subst.getVariableResolver()) {
            final Map<String, String> map = (Map<String, String>) componentMap.get(CONTEXT_PROPERTIES);
            final StrLookup lookup = map == null ? null : new MapLookup(map);
            subst.setVariableResolver(new Interpolator(lookup));
        }
        if (child.getName().equalsIgnoreCase(""Appenders"")) {
            appenders = (ConcurrentMap<String, Appender>) child.getObject();
        } else if (child.getObject() instanceof Filter) {
            addFilter((Filter) child.getObject());
        } else if (child.getName().equalsIgnoreCase(""Loggers"")) {
            final Loggers l = (Loggers) child.getObject();
            loggers = l.getMap();
            setLoggers = true;
            if (l.getRoot() != null) {
                root = l.getRoot();
                setRoot = true;
            }
        } else {
            LOGGER.error(""Unknown object \"""" + child.getName() + ""\"" of type "" + child.getObject().getClass().getName() + "" is ignored"");
        }
    }
    if (!setLoggers) {
        LOGGER.warn(""No Loggers were configured, using default. Is the Loggers element missing?"");
        setToDefault();
        return;
    } else if (!setRoot) {
        LOGGER.warn(""No Root logger was configured, creating default ERROR-level Root logger with Console appender"");
        setToDefault();
        }
    for (final Map.Entry<String, LoggerConfig> entry : loggers.entrySet()) {
        final LoggerConfig l = entry.getValue();
        for (final AppenderRef ref : l.getAppenderRefs()) {
            final Appender app = appenders.get(ref.getRef());
            if (app != null) {
                l.addAppender(app, ref.getLevel(), ref.getFilter());
            } else {
                LOGGER.error(""Unable to locate appender "" + ref.getRef() + "" for logger "" + l.getName());
            }
        }
    }
    setParents();
}",2.0,0.5406698564593301,2.8,1.5,1.5,0.5059523809523809,-1.0214235377026073,3.25,-0.02631578947368421,2.09033038847876
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-466_7b9e48e8,3,"/**
 * Tries to convert the specified URL to a file object. If this fails,
 * <b>null</b> is returned.
 *
 * @param uri the URI
 * @return the resulting file object
 */
public static File fileFromURI(URI uri) {
    if (uri == null || (uri.getScheme() != null && (!PROTOCOL_FILE.equals(uri.getScheme()) && !JBOSS_FILE.equals(uri.getScheme())))) {
        return null;
    }
    if (uri.getScheme() == null) {
        try {
            uri = new File(uri.getPath()).toURI();
        } catch (final Exception ex) {
            LOGGER.warn(""Invalid URI "" + uri);
            return null;
        }
    }
    try {
        return new File(URLDecoder.decode(uri.toURL().getFile(), ""UTF8""));
    } catch (final MalformedURLException ex) {
        LOGGER.warn(""Invalid URL "" + uri, ex);
    } catch (final UnsupportedEncodingException uee) {
        LOGGER.warn(""Invalid encoding: UTF8"", uee);
    }
    return null;
}","/**
 * Tries to convert the specified URL to a file object. If this fails,
 * <b>null</b> is returned.
 *
 * @param uri the URI
 * @return the resulting file object
 */
","public static File fileFromURI(URI uri) {
    if (uri == null || (uri.getScheme() != null && (!PROTOCOL_FILE.equals(uri.getScheme()) && !JBOSS_FILE.equals(uri.getScheme())))) {
        return null;
    }
    if (uri.getScheme() == null) {
        try {
            uri = new File(uri.getPath()).toURI();
        } catch (final Exception ex) {
            LOGGER.warn(""Invalid URI "" + uri);
            return null;
        }
    }
    try {
        return new File(URLDecoder.decode(uri.toURL().getFile(), ""UTF8""));
    } catch (final MalformedURLException ex) {
        LOGGER.warn(""Invalid URL "" + uri, ex);
    } catch (final UnsupportedEncodingException uee) {
        LOGGER.warn(""Invalid encoding: UTF8"", uee);
    }
    return null;
}",0.3181818181818182,0.20095693779904303,0.4,0.0,0.3333333333333333,0.8472222222222223,-0.30429880197322057,0.6666666666666666,-0.02631578947368421,0.7832206681535011
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1199_813109d7,3,"@Override
public String toString() {
    StringBuilder sb = new StringBuilder(""removeTableProperty_result("");
    boolean first = true;
    sb.append(""ouch1:"");
    if (this.ouch1 == null) {
        sb.append(""null"");
    } else {
        sb.append(this.ouch1);
    }
    first = false;
    if (!first)
        sb.append("", "");
    sb.append(""ouch2:"");
    if (this.ouch2 == null) {
        sb.append(""null"");
    } else {
        sb.append(this.ouch2);
    }
    first = false;
    sb.append("")"");
    return sb.toString();
}",,"@Override
public String toString() {
    StringBuilder sb = new StringBuilder(""removeTableProperty_result("");
    boolean first = true;
    sb.append(""ouch1:"");
    if (this.ouch1 == null) {
        sb.append(""null"");
    } else {
        sb.append(this.ouch1);
    }
    first = false;
    if (!first)
        sb.append("", "");
    sb.append(""ouch2:"");
    if (this.ouch2 == null) {
        sb.append(""null"");
    } else {
        sb.append(this.ouch2);
    }
    first = false;
    sb.append("")"");
    return sb.toString();
}",0.4090909090909091,-0.3157894736842106,0.0,-0.5,0.08333333333333333,0.13095238095238093,-0.27639182522903427,0.25,0.0,0.1004569999366078
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3630_fcd64766,3,"@Override
public boolean match(String name, NodeState nodeState, int depth) {
    // last segment -> add to collector if node type matches
    if (depth == maxDepth() - 1 && primaryType != null && !primaryType.equals(ConfigUtil.getPrimaryTypeName(nodeState))) {
        return false;
    }
    return super.match(name, nodeState, depth);
}",,"@Override
public boolean match(String name, NodeState nodeState, int depth) {
        if (depth == maxDepth() - 1 && primaryType != null && !primaryType.equals(ConfigUtil.getPrimaryTypeName(nodeState))) {
        return false;
    }
    return super.match(name, nodeState, depth);
}",-0.3181818181818182,-0.0909090909090911,-0.4,-0.5,0.3333333333333333,0.2063492063492063,0.36546863988724454,-0.16666666666666666,0.2894736842105263,0.006041850359894635
commons-math,remotes/origin/bugs-dot-jar_MATH-929_cedf0d27,0,"/**
 * {@inheritDoc}
 */
public double density(final double[] vals) throws DimensionMismatchException {
    final int dim = getDimension();
    if (vals.length != dim) {
        throw new DimensionMismatchException(vals.length, dim);
    }
    return FastMath.pow(2 * FastMath.PI, -dim / 2) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * getExponentTerm(vals);
}","/**
 * {@inheritDoc}
 */
","public double density(final double[] vals) throws DimensionMismatchException {
    final int dim = getDimension();
    if (vals.length != dim) {
        throw new DimensionMismatchException(vals.length, dim);
    }
    return FastMath.pow(2 * FastMath.PI, -dim / 2) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * getExponentTerm(vals);
}",-0.3181818181818182,-0.20574162679425848,-0.2,-0.5,-0.16666666666666666,0.371031746031746,0.344890768146582,-0.16666666666666666,1.0263157894736843,0.07725315952352134
Closure,149,2,"/**
 * Generates JavaScript source code for an AST.
 */
private String toSource(Node n, SourceMap sourceMap) {
    CodePrinter.Builder builder = new CodePrinter.Builder(n);
    builder.setPrettyPrint(options.prettyPrint);
    builder.setLineBreak(options.lineBreak);
    builder.setSourceMap(sourceMap);
    builder.setSourceMapDetailLevel(options.sourceMapDetailLevel);
    Charset charset = options.outputCharset;
    builder.setOutputCharset(charset);
    return builder.build();
}","/**
 * Generates JavaScript source code for an AST.
 */
","private String toSource(Node n, SourceMap sourceMap) {
    CodePrinter.Builder builder = new CodePrinter.Builder(n);
    builder.setPrettyPrint(options.prettyPrint);
    builder.setLineBreak(options.lineBreak);
    builder.setSourceMap(sourceMap);
    builder.setSourceMapDetailLevel(options.sourceMapDetailLevel);
    Charset charset = options.outputCharset;
    builder.setOutputCharset(charset);
    return builder.build();
}",-0.18181818181818182,-0.6650717703349284,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.15940803382663848,0.0,0.0,-0.16279340490885932
commons-math,remotes/origin/bugs-dot-jar_MATH-1005_91d280b7,1,"/**
 * Compute a linear combination accurately.
 * This method computes the sum of the products
 * <code>a<sub>i</sub> b<sub>i</sub></code> to high accuracy.
 * It does so by using specific multiplication and addition algorithms to
 * preserve accuracy and reduce cancellation effects.
 * <br/>
 * It is based on the 2005 paper
 * <a href=""http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547"">
 * Accurate Sum and Dot Product</a> by Takeshi Ogita, Siegfried M. Rump,
 * and Shin'ichi Oishi published in SIAM J. Sci. Comput.
 *
 * @param a Factors.
 * @param b Factors.
 * @return <code>&Sigma;<sub>i</sub> a<sub>i</sub> b<sub>i</sub></code>.
 * @throws DimensionMismatchException if arrays dimensions don't match
 */
public static double linearCombination(final double[] a, final double[] b) throws DimensionMismatchException {
    final int len = a.length;
    if (len != b.length) {
        throw new DimensionMismatchException(len, b.length);
    }
    final double[] prodHigh = new double[len];
    double prodLowSum = 0;
    for (int i = 0; i < len; i++) {
        final double ai = a[i];
        final double ca = SPLIT_FACTOR * ai;
        final double aHigh = ca - (ca - ai);
        final double aLow = ai - aHigh;
        final double bi = b[i];
        final double cb = SPLIT_FACTOR * bi;
        final double bHigh = cb - (cb - bi);
        final double bLow = bi - bHigh;
        prodHigh[i] = ai * bi;
        final double prodLow = aLow * bLow - (((prodHigh[i] - aHigh * bHigh) - aLow * bHigh) - aHigh * bLow);
        prodLowSum += prodLow;
    }
    final double prodHighCur = prodHigh[0];
    double prodHighNext = prodHigh[1];
    double sHighPrev = prodHighCur + prodHighNext;
    double sPrime = sHighPrev - prodHighNext;
    double sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime);
    final int lenMinusOne = len - 1;
    for (int i = 1; i < lenMinusOne; i++) {
        prodHighNext = prodHigh[i + 1];
        final double sHighCur = sHighPrev + prodHighNext;
        sPrime = sHighCur - prodHighNext;
        sLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);
        sHighPrev = sHighCur;
    }
    double result = sHighPrev + (prodLowSum + sLowSum);
    if (Double.isNaN(result)) {
        // either we have split infinite numbers or some coefficients were NaNs,
        // just rely on the naive implementation and let IEEE754 handle this
        result = 0;
        for (int i = 0; i < len; ++i) {
            result += a[i] * b[i];
        }
    }
    return result;
}","/**
 * Compute a linear combination accurately.
 * This method computes the sum of the products
 * <code>a<sub>i</sub> b<sub>i</sub></code> to high accuracy.
 * It does so by using specific multiplication and addition algorithms to
 * preserve accuracy and reduce cancellation effects.
 * <br/>
 * It is based on the 2005 paper
 * <a href=""http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547"">
 * Accurate Sum and Dot Product</a> by Takeshi Ogita, Siegfried M. Rump,
 * and Shin'ichi Oishi published in SIAM J. Sci. Comput.
 *
 * @param a Factors.
 * @param b Factors.
 * @return <code>&Sigma;<sub>i</sub> a<sub>i</sub> b<sub>i</sub></code>.
 * @throws DimensionMismatchException if arrays dimensions don't match
 */
","public static double linearCombination(final double[] a, final double[] b) throws DimensionMismatchException {
    final int len = a.length;
    if (len != b.length) {
        throw new DimensionMismatchException(len, b.length);
    }
    final double[] prodHigh = new double[len];
    double prodLowSum = 0;
    for (int i = 0; i < len; i++) {
        final double ai = a[i];
        final double ca = SPLIT_FACTOR * ai;
        final double aHigh = ca - (ca - ai);
        final double aLow = ai - aHigh;
        final double bi = b[i];
        final double cb = SPLIT_FACTOR * bi;
        final double bHigh = cb - (cb - bi);
        final double bLow = bi - bHigh;
        prodHigh[i] = ai * bi;
        final double prodLow = aLow * bLow - (((prodHigh[i] - aHigh * bHigh) - aLow * bHigh) - aHigh * bLow);
        prodLowSum += prodLow;
    }
    final double prodHighCur = prodHigh[0];
    double prodHighNext = prodHigh[1];
    double sHighPrev = prodHighCur + prodHighNext;
    double sPrime = sHighPrev - prodHighNext;
    double sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime);
    final int lenMinusOne = len - 1;
    for (int i = 1; i < lenMinusOne; i++) {
        prodHighNext = prodHigh[i + 1];
        final double sHighCur = sHighPrev + prodHighNext;
        sPrime = sHighCur - prodHighNext;
        sLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);
        sHighPrev = sHighCur;
    }
    double result = sHighPrev + (prodLowSum + sLowSum);
    if (Double.isNaN(result)) {
                        result = 0;
        for (int i = 0; i < len; ++i) {
            result += a[i] * b[i];
        }
    }
    return result;
}",1.2727272727272727,-0.22966507177033516,0.6,0.0,0.5,2.884920634920635,-0.7984496124031006,-0.4166666666666667,-0.02631578947368421,7.993243546964955
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1183_cfbf5999,3,"@Override
public String createBatchScanner(ByteBuffer login, String tableName, BatchScanOptions opts) throws TException {
    try {
        Connector connector = getConnector(login);
        int threads = 10;
        Authorizations auth;
        if (opts != null && opts.isSetAuthorizations()) {
            auth = getAuthorizations(opts.authorizations);
        } else {
            auth = connector.securityOperations().getUserAuthorizations(connector.whoami());
        }
        if (opts != null && opts.threads > 0)
            threads = opts.threads;
        BatchScanner scanner = connector.createBatchScanner(tableName, auth, threads);
        if (opts != null) {
            if (opts.iterators != null) {
                for (org.apache.accumulo.proxy.thrift.IteratorSetting iter : opts.iterators) {
                    IteratorSetting is = new IteratorSetting(iter.getPriority(), iter.getName(), iter.getIteratorClass(), iter.getProperties());
                    scanner.addScanIterator(is);
                }
            }
            ArrayList<Range> ranges = new ArrayList<Range>();
            if (opts.ranges == null) {
                ranges.add(new Range());
            } else {
                for (org.apache.accumulo.proxy.thrift.Range range : opts.ranges) {
                    Range aRange = new Range(range.getStart() == null ? null : Util.fromThrift(range.getStart()), true, range.getStop() == null ? null : Util.fromThrift(range.getStop()), false);
                    ranges.add(aRange);
                }
            }
            scanner.setRanges(ranges);
        }
        UUID uuid = UUID.randomUUID();
        ScannerPlusIterator spi = new ScannerPlusIterator();
        spi.scanner = scanner;
        spi.iterator = scanner.iterator();
        scannerCache.put(uuid, spi);
        return uuid.toString();
    } catch (Exception e) {
        throw translateException(e);
    }
}",,"@Override
public String createBatchScanner(ByteBuffer login, String tableName, BatchScanOptions opts) throws TException {
    try {
        Connector connector = getConnector(login);
        int threads = 10;
        Authorizations auth;
        if (opts != null && opts.isSetAuthorizations()) {
            auth = getAuthorizations(opts.authorizations);
        } else {
            auth = connector.securityOperations().getUserAuthorizations(connector.whoami());
        }
        if (opts != null && opts.threads > 0)
            threads = opts.threads;
        BatchScanner scanner = connector.createBatchScanner(tableName, auth, threads);
        if (opts != null) {
            if (opts.iterators != null) {
                for (org.apache.accumulo.proxy.thrift.IteratorSetting iter : opts.iterators) {
                    IteratorSetting is = new IteratorSetting(iter.getPriority(), iter.getName(), iter.getIteratorClass(), iter.getProperties());
                    scanner.addScanIterator(is);
                }
            }
            ArrayList<Range> ranges = new ArrayList<Range>();
            if (opts.ranges == null) {
                ranges.add(new Range());
            } else {
                for (org.apache.accumulo.proxy.thrift.Range range : opts.ranges) {
                    Range aRange = new Range(range.getStart() == null ? null : Util.fromThrift(range.getStart()), true, range.getStop() == null ? null : Util.fromThrift(range.getStop()), false);
                    ranges.add(aRange);
                }
            }
            scanner.setRanges(ranges);
        }
        UUID uuid = UUID.randomUUID();
        ScannerPlusIterator spi = new ScannerPlusIterator();
        spi.scanner = scanner;
        spi.iterator = scanner.iterator();
        scannerCache.put(uuid, spi);
        return uuid.toString();
    } catch (Exception e) {
        throw translateException(e);
    }
}",1.2727272727272727,1.0095693779904304,1.6,1.0,0.9166666666666666,0.5178571428571429,-0.8260747004933048,1.6666666666666667,-0.02631578947368421,1.9842602997873475
camel,remotes/origin/bugs-dot-jar_CAMEL-8624_597883fa,1,"private MethodInfo chooseBestPossibleMethodInfo(Exchange exchange, Collection<MethodInfo> operationList, Object body, List<MethodInfo> possibles, List<MethodInfo> possiblesWithException, List<MethodInfo> possibleWithCustomAnnotation) throws AmbiguousMethodCallException {
    Exception exception = ExpressionBuilder.exchangeExceptionExpression().evaluate(exchange, Exception.class);
    if (exception != null && possiblesWithException.size() == 1) {
        LOG.trace(""Exchange has exception set so we prefer method that also has exception as parameter"");
        // prefer the method that accepts exception in case we have an exception also
        return possiblesWithException.get(0);
    } else if (possibles.size() == 1) {
        return possibles.get(0);
    } else if (possibles.isEmpty()) {
        LOG.trace(""No possible methods so now trying to convert body to parameter types"");
        // let's try converting
        Object newBody = null;
        MethodInfo matched = null;
        int matchCounter = 0;
        for (MethodInfo methodInfo : operationList) {
            if (methodInfo.getBodyParameterType().isInstance(body)) {
                return methodInfo;
            }
            // we should only try to convert, as we are looking for best match
            Object value = exchange.getContext().getTypeConverter().tryConvertTo(methodInfo.getBodyParameterType(), exchange, body);
            if (value != null) {
                if (LOG.isTraceEnabled()) {
                    LOG.trace(""Converted body from: {} to: {}"", body.getClass().getCanonicalName(), methodInfo.getBodyParameterType().getCanonicalName());
                }
                matchCounter++;
                newBody = value;
                matched = methodInfo;
            }
        }
        if (matchCounter > 1) {
            throw new AmbiguousMethodCallException(exchange, Arrays.asList(matched, matched));
        }
        if (matched != null) {
            LOG.trace(""Setting converted body: {}"", body);
            Message in = exchange.getIn();
            in.setBody(newBody);
            return matched;
        }
    } else {
        // if we only have a single method with custom annotations, let's use that one
        if (possibleWithCustomAnnotation.size() == 1) {
            MethodInfo answer = possibleWithCustomAnnotation.get(0);
            LOG.trace(""There are only one method with annotations so we choose it: {}"", answer);
            return answer;
        }
        // try to choose among multiple methods with annotations
        MethodInfo chosen = chooseMethodWithCustomAnnotations(exchange, possibles);
        if (chosen != null) {
            return chosen;
        }
        // just make sure the methods aren't all actually the same
        chosen = getSingleCovariantMethod(possibles);
        if (chosen != null) {
            return chosen;
        }
        throw new AmbiguousMethodCallException(exchange, possibles);
    }
    // cannot find a good method to use
    return null;
}",,"private MethodInfo chooseBestPossibleMethodInfo(Exchange exchange, Collection<MethodInfo> operationList, Object body, List<MethodInfo> possibles, List<MethodInfo> possiblesWithException, List<MethodInfo> possibleWithCustomAnnotation) throws AmbiguousMethodCallException {
    Exception exception = ExpressionBuilder.exchangeExceptionExpression().evaluate(exchange, Exception.class);
    if (exception != null && possiblesWithException.size() == 1) {
        LOG.trace(""Exchange has exception set so we prefer method that also has exception as parameter"");
                return possiblesWithException.get(0);
    } else if (possibles.size() == 1) {
        return possibles.get(0);
    } else if (possibles.isEmpty()) {
        LOG.trace(""No possible methods so now trying to convert body to parameter types"");
                Object newBody = null;
        MethodInfo matched = null;
        int matchCounter = 0;
        for (MethodInfo methodInfo : operationList) {
            if (methodInfo.getBodyParameterType().isInstance(body)) {
                return methodInfo;
            }
                        Object value = exchange.getContext().getTypeConverter().tryConvertTo(methodInfo.getBodyParameterType(), exchange, body);
            if (value != null) {
                if (LOG.isTraceEnabled()) {
                    LOG.trace(""Converted body from: {} to: {}"", body.getClass().getCanonicalName(), methodInfo.getBodyParameterType().getCanonicalName());
                }
                matchCounter++;
                newBody = value;
                matched = methodInfo;
            }
        }
        if (matchCounter > 1) {
            throw new AmbiguousMethodCallException(exchange, Arrays.asList(matched, matched));
        }
        if (matched != null) {
            LOG.trace(""Setting converted body: {}"", body);
            Message in = exchange.getIn();
            in.setBody(newBody);
            return matched;
        }
    } else {
                if (possibleWithCustomAnnotation.size() == 1) {
            MethodInfo answer = possibleWithCustomAnnotation.get(0);
            LOG.trace(""There are only one method with annotations so we choose it: {}"", answer);
            return answer;
        }
                MethodInfo chosen = chooseMethodWithCustomAnnotations(exchange, possibles);
        if (chosen != null) {
            return chosen;
        }
                chosen = getSingleCovariantMethod(possibles);
        if (chosen != null) {
            return chosen;
        }
        throw new AmbiguousMethodCallException(exchange, possibles);
    }
        return null;
}",1.7727272727272727,0.5406698564593301,2.2,2.0,1.5833333333333333,1.2142857142857142,-0.944749823819591,2.0,-0.02631578947368421,3.4953637269987263
camel,remotes/origin/bugs-dot-jar_CAMEL-9700_4d03e9de,1,"@Override
public boolean process(final Exchange exchange, final AsyncCallback callback) {
    WaitForTaskToComplete wait = waitForTaskToComplete;
    if (exchange.getProperty(Exchange.ASYNC_WAIT) != null) {
        wait = exchange.getProperty(Exchange.ASYNC_WAIT, WaitForTaskToComplete.class);
    }
    if (wait == WaitForTaskToComplete.Always || (wait == WaitForTaskToComplete.IfReplyExpected && ExchangeHelper.isOutCapable(exchange))) {
        // do not handover the completion as we wait for the copy to complete, and copy its result back when it done
        Exchange copy = prepareCopy(exchange, false);
        // latch that waits until we are complete
        final CountDownLatch latch = new CountDownLatch(1);
        // we should wait for the reply so install a on completion so we know when its complete
        copy.addOnCompletion(new SynchronizationAdapter() {

            @Override
            public void onDone(Exchange response) {
                // check for timeout, which then already would have invoked the latch
                if (latch.getCount() == 0) {
                    if (log.isTraceEnabled()) {
                        log.trace(""{}. Timeout occurred so response will be ignored: {}"", this, response.hasOut() ? response.getOut() : response.getIn());
                    }
                    return;
                } else {
                    if (log.isTraceEnabled()) {
                        log.trace(""{} with response: {}"", this, response.hasOut() ? response.getOut() : response.getIn());
                    }
                    try {
                        ExchangeHelper.copyResults(exchange, response);
                    } finally {
                        // always ensure latch is triggered
                        latch.countDown();
                    }
                }
            }

            @Override
            public boolean allowHandover() {
                // at this point in the routing (at this leg), instead of at the very last (this ensure timeout is honored)
                return false;
            }

            @Override
            public String toString() {
                return ""onDone at endpoint: "" + endpoint;
            }
        });
        log.trace(""Adding Exchange to queue: {}"", copy);
        try {
            addToQueue(copy);
        } catch (SedaConsumerNotAvailableException e) {
            exchange.setException(e);
            callback.done(true);
            return true;
        }
        if (timeout > 0) {
            if (log.isTraceEnabled()) {
                log.trace(""Waiting for task to complete using timeout (ms): {} at [{}]"", timeout, endpoint.getEndpointUri());
            }
            // lets see if we can get the task done before the timeout
            boolean done = false;
            try {
                done = latch.await(timeout, TimeUnit.MILLISECONDS);
            } catch (InterruptedException e) {
            // ignore
            }
            if (!done) {
                exchange.setException(new ExchangeTimedOutException(exchange, timeout));
                // remove timed out Exchange from queue
                endpoint.getQueue().remove(copy);
                // count down to indicate timeout
                latch.countDown();
            }
        } else {
            if (log.isTraceEnabled()) {
                log.trace(""Waiting for task to complete (blocking) at [{}]"", endpoint.getEndpointUri());
            }
            // no timeout then wait until its done
            try {
                latch.await();
            } catch (InterruptedException e) {
            // ignore
            }
        }
    } else {
        // no wait, eg its a InOnly then just add to queue and return
        // handover the completion so its the copy which performs that, as we do not wait
        Exchange copy = prepareCopy(exchange, true);
        log.trace(""Adding Exchange to queue: {}"", copy);
        try {
            addToQueue(copy);
        } catch (SedaConsumerNotAvailableException e) {
            exchange.setException(e);
            callback.done(true);
            return true;
        }
    }
    // we use OnCompletion on the Exchange to callback and wait for the Exchange to be done
    // so we should just signal the callback we are done synchronously
    callback.done(true);
    return true;
}",,"@Override
public boolean process(final Exchange exchange, final AsyncCallback callback) {
    WaitForTaskToComplete wait = waitForTaskToComplete;
    if (exchange.getProperty(Exchange.ASYNC_WAIT) != null) {
        wait = exchange.getProperty(Exchange.ASYNC_WAIT, WaitForTaskToComplete.class);
    }
    if (wait == WaitForTaskToComplete.Always || (wait == WaitForTaskToComplete.IfReplyExpected && ExchangeHelper.isOutCapable(exchange))) {
                Exchange copy = prepareCopy(exchange, false);
                final CountDownLatch latch = new CountDownLatch(1);
                copy.addOnCompletion(new SynchronizationAdapter() {

            @Override
            public void onDone(Exchange response) {
                                if (latch.getCount() == 0) {
                    if (log.isTraceEnabled()) {
                        log.trace(""{}. Timeout occurred so response will be ignored: {}"", this, response.hasOut() ? response.getOut() : response.getIn());
                    }
                    return;
                } else {
                    if (log.isTraceEnabled()) {
                        log.trace(""{} with response: {}"", this, response.hasOut() ? response.getOut() : response.getIn());
                    }
                    try {
                        ExchangeHelper.copyResults(exchange, response);
                    } finally {
                                                latch.countDown();
                    }
                }
            }

            @Override
            public boolean allowHandover() {
                                return false;
            }

            @Override
            public String toString() {
                return ""onDone at endpoint: "" + endpoint;
            }
        });
        log.trace(""Adding Exchange to queue: {}"", copy);
        try {
            addToQueue(copy);
        } catch (SedaConsumerNotAvailableException e) {
            exchange.setException(e);
            callback.done(true);
            return true;
        }
        if (timeout > 0) {
            if (log.isTraceEnabled()) {
                log.trace(""Waiting for task to complete using timeout (ms): {} at [{}]"", timeout, endpoint.getEndpointUri());
            }
                        boolean done = false;
            try {
                done = latch.await(timeout, TimeUnit.MILLISECONDS);
            } catch (InterruptedException e) {
                        }
            if (!done) {
                exchange.setException(new ExchangeTimedOutException(exchange, timeout));
                                endpoint.getQueue().remove(copy);
                                latch.countDown();
            }
        } else {
            if (log.isTraceEnabled()) {
                log.trace(""Waiting for task to complete (blocking) at [{}]"", endpoint.getEndpointUri());
            }
                        try {
                latch.await();
            } catch (InterruptedException e) {
                        }
        }
    } else {
                        Exchange copy = prepareCopy(exchange, true);
        log.trace(""Adding Exchange to queue: {}"", copy);
        try {
            addToQueue(copy);
        } catch (SedaConsumerNotAvailableException e) {
            exchange.setException(e);
            callback.done(true);
            return true;
        }
    }
            callback.done(true);
    return true;
}",3.090909090909091,1.2105263157894735,2.4,1.0,1.5833333333333333,1.7718253968253967,-1.1680056377730794,2.8333333333333335,-0.02631578947368421,5.40878846031938
commons-math,remotes/origin/bugs-dot-jar_MATH-373_bfe4623c,1,"/**
 * {@inheritDoc}
 */
@Override
public void clear() {
    value = Double.NaN;
    n = 0;
}","/**
 * {@inheritDoc}
 */
","@Override
public void clear() {
    value = Double.NaN;
    n = 0;
}",-0.4090909090909091,-0.49282296650717716,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.7293868921775897,-0.5,2.6052631578947367,-0.16279340490885932
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1429_c2f5ca6c,1,"/**
 * Returns up to {@code limit} child nodes, starting at the given
 * {@code name} (exclusive).
 *
 * @param parent the parent node.
 * @param name the name of the lower bound child node (exclusive) or
 *             {@code null}, if the method should start with the first known
 *             child node.
 * @param limit the maximum number of child nodes to return.
 * @return the child nodes.
 */
@Nonnull
Iterable<DocumentNodeState> getChildNodes(@Nonnull final DocumentNodeState parent, @Nullable final String name, final int limit) {
    // return straight away
    if (checkNotNull(parent).hasNoChildren()) {
        return Collections.emptyList();
    }
    final Revision readRevision = parent.getLastRevision();
    return Iterables.transform(getChildren(parent, name, limit).children, new Function<String, DocumentNodeState>() {

        @Override
        public DocumentNodeState apply(String input) {
            return getNode(input, readRevision);
        }
    });
}","/**
 * Returns up to {@code limit} child nodes, starting at the given
 * {@code name} (exclusive).
 *
 * @param parent the parent node.
 * @param name the name of the lower bound child node (exclusive) or
 *             {@code null}, if the method should start with the first known
 *             child node.
 * @param limit the maximum number of child nodes to return.
 * @return the child nodes.
 */
","@Nonnull
Iterable<DocumentNodeState> getChildNodes(@Nonnull final DocumentNodeState parent, @Nullable final String name, final int limit) {
        if (checkNotNull(parent).hasNoChildren()) {
        return Collections.emptyList();
    }
    final Revision readRevision = parent.getLastRevision();
    return Iterables.transform(getChildren(parent, name, limit).children, new Function<String, DocumentNodeState>() {

        @Override
        public DocumentNodeState apply(String input) {
            return getNode(input, readRevision);
        }
    });
}",-0.045454545454545456,0.27272727272727265,-0.4,-0.5,-0.25,-0.3650793650793651,0.02410147991543351,0.08333333333333333,0.02631578947368421,-0.16279340490885932
wicket,remotes/origin/bugs-dot-jar_WICKET-3884_b772ff87,3,"@Override
protected String newValue(String currentValue, String appendValue) {
    // Short circuit when one of the values is empty: return the other value.
    if (Strings.isEmpty(currentValue))
        return appendValue != null ? appendValue : """";
    else if (Strings.isEmpty(appendValue))
        return currentValue != null ? currentValue : """";
    StringBuilder sb = new StringBuilder(currentValue);
    sb.append((getSeparator() == null ? """" : getSeparator()));
    sb.append(appendValue);
    return sb.toString();
}",,"@Override
protected String newValue(String currentValue, String appendValue) {
        if (Strings.isEmpty(currentValue))
        return appendValue != null ? appendValue : """";
    else if (Strings.isEmpty(appendValue))
        return currentValue != null ? currentValue : """";
    StringBuilder sb = new StringBuilder(currentValue);
    sb.append((getSeparator() == null ? """" : getSeparator()));
    sb.append(appendValue);
    return sb.toString();
}",-0.13636363636363635,-0.15311004784689008,0.4,-1.0,0.4166666666666667,0.12500000000000003,0.09006342494714606,0.08333333333333333,0.31578947368421056,0.031633846809932975
wicket,remotes/origin/bugs-dot-jar_WICKET-3713_e1168a57,3,"/**
 *  @param userAgent
 *             The user agent string
 *  @return Whether the user agent matches this enum or not
 */
public boolean matches(String userAgent) {
    if (notAllowedList != null) {
        for (String value : notAllowedList) {
            if (userAgent.contains(value)) {
                return false;
            }
        }
    }
    for (List<String> detectionGroup : detectionStrings) {
        for (String detectionString : detectionGroup) {
            if (!userAgent.contains(detectionString)) {
                return false;
            }
        }
        return true;
    }
    return false;
}","/**
 *  @param userAgent
 *             The user agent string
 *  @return Whether the user agent matches this enum or not
 */
","public boolean matches(String userAgent) {
    if (notAllowedList != null) {
        for (String value : notAllowedList) {
            if (userAgent.contains(value)) {
                return false;
            }
        }
    }
    for (List<String> detectionGroup : detectionStrings) {
        for (String detectionString : detectionGroup) {
            if (!userAgent.contains(detectionString)) {
                return false;
            }
        }
        return true;
    }
    return false;
}",0.18181818181818182,0.8229665071770335,0.6,0.5,0.25,0.0039682539682539715,-0.07935165609584206,-0.3333333333333333,0.763157894736842,-0.06689833624361036
Lang,30,3,"// ContainsAny
// -----------------------------------------------------------------------
/**
 * <p>Checks if the CharSequence contains any character in the given
 * set of characters.</p>
 *
 * <p>A <code>null</code> CharSequence will return <code>false</code>.
 * A <code>null</code> or zero length search array will return <code>false</code>.</p>
 *
 * <pre>
 * StringUtils.containsAny(null, *)                = false
 * StringUtils.containsAny("""", *)                  = false
 * StringUtils.containsAny(*, null)                = false
 * StringUtils.containsAny(*, [])                  = false
 * StringUtils.containsAny(""zzabyycdxx"",['z','a']) = true
 * StringUtils.containsAny(""zzabyycdxx"",['b','y']) = true
 * StringUtils.containsAny(""aba"", ['z'])           = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the <code>true</code> if any of the chars are found,
 * <code>false</code> if no match or null input
 * @since 2.4
 */
public static boolean containsAny(CharSequence cs, char[] searchChars) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
        return false;
    }
    int csLength = cs.length();
    int searchLength = searchChars.length;
    int csLast = csLength - 1;
    int searchLast = searchLength - 1;
    for (int i = 0; i < csLength; i++) {
        char ch = cs.charAt(i);
        for (int j = 0; j < searchLength; j++) {
            if (searchChars[j] == ch) {
                if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {
                    // missing low surrogate, fine, like String.indexOf(String)
                    if (searchChars[j + 1] == cs.charAt(i + 1)) {
                        return true;
                    }
                } else {
                    // ch is in the Basic Multilingual Plane
                    return true;
                }
            }
        }
    }
    return false;
}","/**
 * <p>Checks if the CharSequence contains any character in the given
 * set of characters.</p>
 *
 * <p>A <code>null</code> CharSequence will return <code>false</code>.
 * A <code>null</code> or zero length search array will return <code>false</code>.</p>
 *
 * <pre>
 * StringUtils.containsAny(null, *)                = false
 * StringUtils.containsAny("""", *)                  = false
 * StringUtils.containsAny(*, null)                = false
 * StringUtils.containsAny(*, [])                  = false
 * StringUtils.containsAny(""zzabyycdxx"",['z','a']) = true
 * StringUtils.containsAny(""zzabyycdxx"",['b','y']) = true
 * StringUtils.containsAny(""aba"", ['z'])           = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the <code>true</code> if any of the chars are found,
 * <code>false</code> if no match or null input
 * @since 2.4
 */
","public static boolean containsAny(CharSequence cs, char[] searchChars) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
        return false;
    }
    int csLength = cs.length();
    int searchLength = searchChars.length;
    int csLast = csLength - 1;
    int searchLast = searchLength - 1;
    for (int i = 0; i < csLength; i++) {
        char ch = cs.charAt(i);
        for (int j = 0; j < searchLength; j++) {
            if (searchChars[j] == ch) {
                if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {
                                        if (searchChars[j + 1] == cs.charAt(i + 1)) {
                        return true;
                    }
                } else {
                                        return true;
                }
            }
        }
    }
    return false;
}",0.45454545454545453,1.8708133971291867,0.6,1.5,1.4166666666666667,2.222222222222222,-0.4074700493305143,-0.08333333333333333,-0.02631578947368421,2.415631357226419
Closure,169,2,"/**
 * Two function types are equal if their signatures match. Since they don't
 * have signatures, two interfaces are equal if their names match.
 */
boolean checkFunctionEquivalenceHelper(FunctionType that, boolean tolerateUnknowns) {
    if (isConstructor()) {
        if (that.isConstructor()) {
            return this == that;
        }
        return false;
    }
    if (isInterface()) {
        if (that.isInterface()) {
            return getReferenceName().equals(that.getReferenceName());
        }
        return false;
    }
    if (that.isInterface()) {
        return false;
    }
    return typeOfThis.checkEquivalenceHelper(that.typeOfThis, tolerateUnknowns) && call.checkArrowEquivalenceHelper(that.call, tolerateUnknowns);
}","/**
 * Two function types are equal if their signatures match. Since they don't
 * have signatures, two interfaces are equal if their names match.
 */
","boolean checkFunctionEquivalenceHelper(FunctionType that, boolean tolerateUnknowns) {
    if (isConstructor()) {
        if (that.isConstructor()) {
            return this == that;
        }
        return false;
    }
    if (isInterface()) {
        if (that.isInterface()) {
            return getReferenceName().equals(that.getReferenceName());
        }
        return false;
    }
    if (that.isInterface()) {
        return false;
    }
    return typeOfThis.checkEquivalenceHelper(that.typeOfThis, tolerateUnknowns) && call.checkArrowEquivalenceHelper(that.call, tolerateUnknowns);
}",0.18181818181818182,0.1626794258373205,0.4,0.0,0.3333333333333333,0.07341269841269839,-0.09682875264270617,0.3333333333333333,-0.02631578947368421,-0.028037781734986136
camel,remotes/origin/bugs-dot-jar_CAMEL-5681_78c73502,1,"public boolean process(Exchange exchange, AsyncCallback callback) {
    final AtomicExchange result = new AtomicExchange();
    final Iterable<ProcessorExchangePair> pairs;
    // multicast uses fine grained error handling on the output processors
    // so use try .. catch to cater for this
    boolean exhaust = false;
    try {
        boolean sync = true;
        pairs = createProcessorExchangePairs(exchange);
        // after we have created the processors we consider the exchange as exhausted if an unhandled
        // exception was thrown, (used in the catch block)
        // if the processors is working in Streaming model, the exchange could not be processed at this point.
        exhaust = !isStreaming();
        if (isParallelProcessing()) {
            // ensure an executor is set when running in parallel
            ObjectHelper.notNull(executorService, ""executorService"", this);
            doProcessParallel(exchange, result, pairs, isStreaming(), callback);
        } else {
            sync = doProcessSequential(exchange, result, pairs, callback);
        }
        if (!sync) {
            // so we break out now, then the callback will be invoked which then continue routing from where we left here
            return false;
        }
    } catch (Throwable e) {
        exchange.setException(e);
        // and do the done work
        doDone(exchange, null, callback, true, exhaust);
        return true;
    }
    // multicasting was processed successfully
    // and do the done work
    Exchange subExchange = result.get() != null ? result.get() : null;
    doDone(exchange, subExchange, callback, true, exhaust);
    return true;
}",,"public boolean process(Exchange exchange, AsyncCallback callback) {
    final AtomicExchange result = new AtomicExchange();
    final Iterable<ProcessorExchangePair> pairs;
            boolean exhaust = false;
    try {
        boolean sync = true;
        pairs = createProcessorExchangePairs(exchange);
                                exhaust = !isStreaming();
        if (isParallelProcessing()) {
                        ObjectHelper.notNull(executorService, ""executorService"", this);
            doProcessParallel(exchange, result, pairs, isStreaming(), callback);
        } else {
            sync = doProcessSequential(exchange, result, pairs, callback);
        }
        if (!sync) {
                        return false;
        }
    } catch (Throwable e) {
        exchange.setException(e);
                doDone(exchange, null, callback, true, exhaust);
        return true;
    }
            Exchange subExchange = result.get() != null ? result.get() : null;
    doDone(exchange, subExchange, callback, true, exhaust);
    return true;
}",0.5454545454545454,0.1578947368421051,0.2,0.0,0.08333333333333333,0.07738095238095236,-0.41649048625792817,0.5,-0.02631578947368421,0.23713974516346534
wicket,remotes/origin/bugs-dot-jar_WICKET-4927_8c827e33,1,"private void checkHeader() {
    if (bufferedWritten) {
        throw new IllegalStateException(""Header was already written to response!"");
    }
}",,"private void checkHeader() {
    if (bufferedWritten) {
        throw new IllegalStateException(""Header was already written to response!"");
    }
}",-0.4090909090909091,0.0,-0.2,-0.5,-0.25,-0.3650793650793651,0.8638477801268499,-0.5,2.263157894736842,-0.16279340490885932
commons-math,remotes/origin/bugs-dot-jar_MATH-724_9c8bb934,1,"/**
 * Generate a random int value uniformly distributed between
 * <code>lower</code> and <code>upper</code>, inclusive.
 *
 * @param lower
 *            the lower bound.
 * @param upper
 *            the upper bound.
 * @return the random integer.
 * @throws NumberIsTooLargeException if {@code lower >= upper}.
 */
public int nextInt(int lower, int upper) {
    if (lower >= upper) {
        throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND, lower, upper, false);
    }
    double r = getRan().nextDouble();
    return (int) ((r * upper) + ((1.0 - r) * lower) + r);
}","/**
 * Generate a random int value uniformly distributed between
 * <code>lower</code> and <code>upper</code>, inclusive.
 *
 * @param lower
 *            the lower bound.
 * @param upper
 *            the upper bound.
 * @return the random integer.
 * @throws NumberIsTooLargeException if {@code lower >= upper}.
 */
","public int nextInt(int lower, int upper) {
    if (lower >= upper) {
        throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND, lower, upper, false);
    }
    double r = getRan().nextDouble();
    return (int) ((r * upper) + ((1.0 - r) * lower) + r);
}",-0.3181818181818182,-0.20574162679425848,-0.2,-0.5,-0.16666666666666666,0.32936507936507936,0.38012684989429163,-0.3333333333333333,0.5,0.01529019207828355
wicket,remotes/origin/bugs-dot-jar_WICKET-5966_d547fcd4,1,"/**
 *  Extract the locale from the filename
 *
 *  @param path
 *             The file path
 *  @return The updated path, without the locale
 */
public static PathLocale getLocaleFromFilename(String path) {
    String extension = """";
    int pos = path.lastIndexOf('.');
    if (pos != -1) {
        extension = path.substring(pos);
        path = path.substring(0, pos);
    }
    String filename = Strings.lastPathComponent(path, '/');
    Matcher matcher = LOCALE_PATTERN.matcher(filename);
    if (matcher.find()) {
        String language = matcher.group(1);
        String country = matcher.group(3);
        String variant = matcher.group(5);
        // did we find a language?
        if (language != null) {
            if (isoLanguages.contains(language) == false) {
                language = null;
                country = null;
                variant = null;
            }
        }
        // did we find a country?
        if ((language != null) && (country != null)) {
            if (isoCountries.contains(country) == false) {
                country = null;
                variant = null;
            }
        }
        if (language != null) {
            pos = path.length() - filename.length() + matcher.start();
            String basePath = path.substring(0, pos) + extension;
            Locale locale = new Locale(language, country != null ? country : """", variant != null ? variant : """");
            return new PathLocale(basePath, locale);
        }
    }
    return new PathLocale(path + extension, null);
}","/**
 *  Extract the locale from the filename
 *
 *  @param path
 *             The file path
 *  @return The updated path, without the locale
 */
","public static PathLocale getLocaleFromFilename(String path) {
    String extension = """";
    int pos = path.lastIndexOf('.');
    if (pos != -1) {
        extension = path.substring(pos);
        path = path.substring(0, pos);
    }
    String filename = Strings.lastPathComponent(path, '/');
    Matcher matcher = LOCALE_PATTERN.matcher(filename);
    if (matcher.find()) {
        String language = matcher.group(1);
        String country = matcher.group(3);
        String variant = matcher.group(5);
                if (language != null) {
            if (isoLanguages.contains(language) == false) {
                language = null;
                country = null;
                variant = null;
            }
        }
                if ((language != null) && (country != null)) {
            if (isoCountries.contains(country) == false) {
                country = null;
                variant = null;
            }
        }
        if (language != null) {
            pos = path.length() - filename.length() + matcher.start();
            String basePath = path.substring(0, pos) + extension;
            Locale locale = new Locale(language, country != null ? country : """", variant != null ? variant : """");
            return new PathLocale(basePath, locale);
        }
    }
    return new PathLocale(path + extension, null);
}",0.9545454545454546,0.722488038277512,1.2,0.5,1.0,1.4047619047619047,-0.6851303735024662,0.75,-0.02631578947368421,3.0055658327714476
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-4113_27300d81,0,"public static String toString(ByteBuffer bytes) {
    return new String(bytes.array(), bytes.position(), bytes.remaining(), UTF_8);
}",,"public static String toString(ByteBuffer bytes) {
    return new String(bytes.array(), bytes.position(), bytes.remaining(), UTF_8);
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.9244538407329099,-0.25,-0.02631578947368421,-0.16279340490885932
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-606_f0fbacab,1,"/**
 * The underlying {@link org.apache.jackrabbit.oak.api.TreeLocation} of this item.
 * @return  tree location of the underlying item
 * @throws InvalidItemStateException if the location points to a stale item
 */
@Nonnull
public TreeLocation getLocation() throws InvalidItemStateException {
    TreeLocation location = getLocationOrNull();
    if (!location.exists()) {
        throw new InvalidItemStateException(""Item is stale"");
    }
    return location;
}","/**
 * The underlying {@link org.apache.jackrabbit.oak.api.TreeLocation} of this item.
 * @return  tree location of the underlying item
 * @throws InvalidItemStateException if the location points to a stale item
 */
","@Nonnull
public TreeLocation getLocation() throws InvalidItemStateException {
    TreeLocation location = getLocationOrNull();
    if (!location.exists()) {
        throw new InvalidItemStateException(""Item is stale"");
    }
    return location;
}",-0.2727272727272727,-0.16267942583732073,-0.2,-0.5,-0.25,-0.07936507936507939,0.429739252995067,-0.3333333333333333,1.8157894736842104,-0.12823890781049196
camel,remotes/origin/bugs-dot-jar_CAMEL-6918_5761250c,1,"public boolean process(Exchange exchange, final AsyncCallback callback) {
    if (!isStarted()) {
        exchange.setException(new IllegalStateException(""SendProcessor has not been started: "" + this));
        callback.done(true);
        return true;
    }
    // we should preserve existing MEP so remember old MEP
    // if you want to permanently to change the MEP then use .setExchangePattern in the DSL
    final ExchangePattern existingPattern = exchange.getPattern();
    // if we have a producer then use that as its optimized
    if (producer != null) {
        // record timing for sending the exchange using the producer
        final StopWatch watch = new StopWatch();
        final Exchange target = configureExchange(exchange, pattern);
        EventHelper.notifyExchangeSending(exchange.getContext(), target, destination);
        LOG.debug("">>>> {} {}"", destination, exchange);
        return producer.process(exchange, new AsyncCallback() {

            @Override
            public void done(boolean doneSync) {
                try {
                    // restore previous MEP
                    target.setPattern(existingPattern);
                    // emit event that the exchange was sent to the endpoint
                    long timeTaken = watch.stop();
                    EventHelper.notifyExchangeSent(target.getContext(), target, destination, timeTaken);
                } finally {
                    callback.done(doneSync);
                }
            }
        });
    }
    // send the exchange to the destination using the producer cache for the non optimized producers
    return producerCache.doInAsyncProducer(destination, exchange, pattern, callback, new AsyncProducerCallback() {

        public boolean doInAsyncProducer(Producer producer, AsyncProcessor asyncProducer, final Exchange exchange, ExchangePattern pattern, final AsyncCallback callback) {
            final Exchange target = configureExchange(exchange, pattern);
            LOG.debug("">>>> {} {}"", destination, exchange);
            return asyncProducer.process(target, new AsyncCallback() {

                public void done(boolean doneSync) {
                    // restore previous MEP
                    target.setPattern(existingPattern);
                    // signal we are done
                    callback.done(doneSync);
                }
            });
        }
    });
}",,"public boolean process(Exchange exchange, final AsyncCallback callback) {
    if (!isStarted()) {
        exchange.setException(new IllegalStateException(""SendProcessor has not been started: "" + this));
        callback.done(true);
        return true;
    }
            final ExchangePattern existingPattern = exchange.getPattern();
        if (producer != null) {
                final StopWatch watch = new StopWatch();
        final Exchange target = configureExchange(exchange, pattern);
        EventHelper.notifyExchangeSending(exchange.getContext(), target, destination);
        LOG.debug("">>>> {} {}"", destination, exchange);
        return producer.process(exchange, new AsyncCallback() {

            @Override
            public void done(boolean doneSync) {
                try {
                                        target.setPattern(existingPattern);
                                        long timeTaken = watch.stop();
                    EventHelper.notifyExchangeSent(target.getContext(), target, destination, timeTaken);
                } finally {
                    callback.done(doneSync);
                }
            }
        });
    }
        return producerCache.doInAsyncProducer(destination, exchange, pattern, callback, new AsyncProducerCallback() {

        public boolean doInAsyncProducer(Producer producer, AsyncProcessor asyncProducer, final Exchange exchange, ExchangePattern pattern, final AsyncCallback callback) {
            final Exchange target = configureExchange(exchange, pattern);
            LOG.debug("">>>> {} {}"", destination, exchange);
            return asyncProducer.process(target, new AsyncCallback() {

                public void done(boolean doneSync) {
                                        target.setPattern(existingPattern);
                                        callback.done(doneSync);
                }
            });
        }
    });
}",1.0909090909090908,1.3588516746411483,-0.2,0.5,-0.08333333333333333,0.6309523809523809,-0.6431289640591964,1.1666666666666667,-0.02631578947368421,1.2492845328861302
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1429_c2f5ca6c,1,"String diff(@Nonnull final String fromRevisionId, @Nonnull final String toRevisionId, @Nonnull final String path) throws MicroKernelException {
    if (fromRevisionId.equals(toRevisionId)) {
        return """";
    }
    Revision fromRev = Revision.fromString(fromRevisionId);
    Revision toRev = Revision.fromString(toRevisionId);
    final DocumentNodeState from = getNode(path, fromRev);
    final DocumentNodeState to = getNode(path, toRev);
    if (from == null || to == null) {
        // TODO implement correct behavior if the node does't/didn't exist
        String msg = String.format(""Diff is only supported if the node exists in both cases. "" + ""Node [%s], fromRev [%s] -> %s, toRev [%s] -> %s"", path, fromRev, from != null, toRev, to != null);
        throw new MicroKernelException(msg);
    }
    PathRev key = diffCacheKey(path, fromRev, toRev);
    try {
        JsopWriter writer = new JsopStream();
        diffProperties(from, to, writer);
        return writer.toString() + diffCache.get(key, new Callable<StringValue>() {

            @Override
            public StringValue call() throws Exception {
                return new StringValue(diffImpl(from, to));
            }
        });
    } catch (ExecutionException e) {
        if (e.getCause() instanceof MicroKernelException) {
            throw (MicroKernelException) e.getCause();
        } else {
            throw new MicroKernelException(e.getCause());
        }
    }
}",,"String diff(@Nonnull final String fromRevisionId, @Nonnull final String toRevisionId, @Nonnull final String path) throws MicroKernelException {
    if (fromRevisionId.equals(toRevisionId)) {
        return """";
    }
    Revision fromRev = Revision.fromString(fromRevisionId);
    Revision toRev = Revision.fromString(toRevisionId);
    final DocumentNodeState from = getNode(path, fromRev);
    final DocumentNodeState to = getNode(path, toRev);
    if (from == null || to == null) {
                String msg = String.format(""Diff is only supported if the node exists in both cases. "" + ""Node [%s], fromRev [%s] -> %s, toRev [%s] -> %s"", path, fromRev, from != null, toRev, to != null);
        throw new MicroKernelException(msg);
    }
    PathRev key = diffCacheKey(path, fromRev, toRev);
    try {
        JsopWriter writer = new JsopStream();
        diffProperties(from, to, writer);
        return writer.toString() + diffCache.get(key, new Callable<StringValue>() {

            @Override
            public StringValue call() throws Exception {
                return new StringValue(diffImpl(from, to));
            }
        });
    } catch (ExecutionException e) {
        if (e.getCause() instanceof MicroKernelException) {
            throw (MicroKernelException) e.getCause();
        } else {
            throw new MicroKernelException(e.getCause());
        }
    }
}",0.7272727272727273,0.36363636363636354,0.8,0.0,0.3333333333333333,0.5317460317460316,-0.5664552501761803,0.6666666666666666,-0.02631578947368421,1.0999510151392033
Closure,147,2,"/**
 * Insert checks for the parameters of the function.
 */
private void visitFunction(NodeTraversal t, Node n) {
    FunctionType funType = (FunctionType) n.getJSType();
    Node block = n.getLastChild();
    Node paramName = NodeUtil.getFnParameters(n).getFirstChild();
    Node insertionPoint = null;
    for (Node paramType : funType.getParameters()) {
        // Can this ever happen?
        if (paramName == null) {
            return;
        }
        Node checkNode = createCheckTypeCallNode(paramType.getJSType(), paramName.cloneTree());
        if (checkNode == null) {
            // We don't know how to check this parameter type.
            paramName = paramName.getNext();
            continue;
        }
        checkNode = new Node(Token.EXPR_RESULT, checkNode);
        if (insertionPoint == null) {
            block.addChildToFront(checkNode);
        } else {
            block.addChildAfter(checkNode, insertionPoint);
        }
        compiler.reportCodeChange();
        paramName = paramName.getNext();
        insertionPoint = checkNode;
    }
}","/**
 * Insert checks for the parameters of the function.
 */
","private void visitFunction(NodeTraversal t, Node n) {
    FunctionType funType = (FunctionType) n.getJSType();
    Node block = n.getLastChild();
    Node paramName = NodeUtil.getFnParameters(n).getFirstChild();
    Node insertionPoint = null;
    for (Node paramType : funType.getParameters()) {
                if (paramName == null) {
            return;
        }
        Node checkNode = createCheckTypeCallNode(paramType.getJSType(), paramName.cloneTree());
        if (checkNode == null) {
                        paramName = paramName.getNext();
            continue;
        }
        checkNode = new Node(Token.EXPR_RESULT, checkNode);
        if (insertionPoint == null) {
            block.addChildToFront(checkNode);
        } else {
            block.addChildAfter(checkNode, insertionPoint);
        }
        compiler.reportCodeChange();
        paramName = paramName.getNext();
        insertionPoint = checkNode;
    }
}",0.5,0.1913875598086124,0.4,0.0,0.08333333333333333,0.06547619047619045,-0.39873150105708227,0.5833333333333334,-0.02631578947368421,0.20934861660990184
flink,remotes/origin/bugs-dot-jar_FLINK-2968_59685903,1,"@Override
public final void setOutputType(TypeInformation<OUT> outTypeInfo, ExecutionConfig executionConfig) {
    if (userFunction instanceof OutputTypeConfigurable) {
        @SuppressWarnings(""unchecked"")
        OutputTypeConfigurable<OUT> typeConfigurable = (OutputTypeConfigurable<OUT>) userFunction;
        typeConfigurable.setOutputType(outTypeInfo, executionConfig);
    }
}",,"@Override
public final void setOutputType(TypeInformation<OUT> outTypeInfo, ExecutionConfig executionConfig) {
    if (userFunction instanceof OutputTypeConfigurable) {
        @SuppressWarnings(""unchecked"")
        OutputTypeConfigurable<OUT> typeConfigurable = (OutputTypeConfigurable<OUT>) userFunction;
        typeConfigurable.setOutputType(outTypeInfo, executionConfig);
    }
}",-0.2727272727272727,0.22488038277511951,-0.4,-0.5,-0.25,-0.3650793650793651,0.35954897815362913,-0.4166666666666667,0.13157894736842105,-0.16279340490885932
Closure,68,2,"/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */
boolean parse() {
    int lineno;
    int charno;
    // JSTypes are represented as Rhino AST nodes, and then resolved later.
    JSTypeExpression type;
    state = State.SEARCHING_ANNOTATION;
    skipEOLs();
    JsDocToken token = next();
    List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();
    // Always record that we have a comment.
    if (jsdocBuilder.shouldParseDocumentation()) {
        ExtractionInfo blockInfo = extractBlockComment(token);
        token = blockInfo.token;
        if (!blockInfo.string.isEmpty()) {
            jsdocBuilder.recordBlockDescription(blockInfo.string);
        }
    } else {
        if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) {
            // Mark that there was a description, but don't bother marking
            // what it was.
            jsdocBuilder.recordBlockDescription("""");
        }
    }
    // Parse the actual JsDoc.
    retry: for (; ; ) {
        switch(token) {
            case ANNOTATION:
                if (state == State.SEARCHING_ANNOTATION) {
                    state = State.SEARCHING_NEWLINE;
                    lineno = stream.getLineno();
                    charno = stream.getCharno();
                    String annotationName = stream.getString();
                    Annotation annotation = annotationNames.get(annotationName);
                    if (annotation == null) {
                        parser.addParserWarning(""msg.bad.jsdoc.tag"", annotationName, stream.getLineno(), stream.getCharno());
                    } else {
                        // Mark the beginning of the annotation.
                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);
                        switch(annotation) {
                            case AUTHOR:
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo authorInfo = extractSingleLineBlock();
                                    String author = authorInfo.string;
                                    if (author.length() == 0) {
                                        parser.addParserWarning(""msg.jsdoc.authormissing"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        jsdocBuilder.addAuthor(author);
                                    }
                                    token = authorInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case CONSTANT:
                                if (!jsdocBuilder.recordConstancy()) {
                                    parser.addParserWarning(""msg.jsdoc.const"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case CONSTRUCTOR:
                                if (!jsdocBuilder.recordConstructor()) {
                                    if (jsdocBuilder.isInterfaceRecorded()) {
                                        parser.addTypeWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DEPRECATED:
                                if (!jsdocBuilder.recordDeprecated()) {
                                    parser.addParserWarning(""msg.jsdoc.deprecated"", stream.getLineno(), stream.getCharno());
                                }
                                // Find the reason/description, if any.
                                ExtractionInfo reasonInfo = extractMultilineTextualBlock(token);
                                String reason = reasonInfo.string;
                                if (reason.length() > 0) {
                                    jsdocBuilder.recordDeprecationReason(reason);
                                }
                                token = reasonInfo.token;
                                continue retry;
                            case INTERFACE:
                                if (!jsdocBuilder.recordInterface()) {
                                    if (jsdocBuilder.isConstructorRecorded()) {
                                        parser.addTypeWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DESC:
                                if (jsdocBuilder.isDescriptionRecorded()) {
                                    parser.addParserWarning(""msg.jsdoc.desc.extra"", stream.getLineno(), stream.getCharno());
                                    token = eatTokensUntilEOL();
                                    continue retry;
                                } else {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    jsdocBuilder.recordDescription(description);
                                    token = descriptionInfo.token;
                                    continue retry;
                                }
                            case FILE_OVERVIEW:
                                String fileOverview = """";
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM);
                                    fileOverview = fileOverviewInfo.string;
                                    token = fileOverviewInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo != null) {
                                    parser.addParserWarning(""msg.jsdoc.fileoverview.extra"", stream.getLineno(), stream.getCharno());
                                }
                                continue retry;
                            case LICENSE:
                            case PRESERVE:
                                ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);
                                String preserve = preserveInfo.string;
                                if (preserve.length() > 0) {
                                    if (fileLevelJsDocBuilder != null) {
                                        fileLevelJsDocBuilder.append(preserve);
                                    }
                                }
                                token = preserveInfo.token;
                                continue retry;
                            case ENUM:
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                }
                                if (type == null) {
                                    type = createJSTypeExpression(newStringNode(""number""));
                                }
                                if (!jsdocBuilder.recordEnumParameterType(type)) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case EXPORT:
                                if (!jsdocBuilder.recordExport()) {
                                    parser.addParserWarning(""msg.jsdoc.export"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTERNS:
                                if (!jsdocBuilder.recordExterns()) {
                                    parser.addParserWarning(""msg.jsdoc.externs"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case JAVA_DISPATCH:
                                if (!jsdocBuilder.recordJavaDispatch()) {
                                    parser.addParserWarning(""msg.jsdoc.javadispatch"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTENDS:
                            case IMPLEMENTS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                boolean matchingRc = false;
                                if (token == JsDocToken.LC) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (token == JsDocToken.STRING) {
                                    Node typeNode = parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    if (typeNode != null && !matchingRc) {
                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);
                                    }
                                    type = createJSTypeExpression(typeNode);
                                    if (annotation == Annotation.EXTENDS) {
                                        // record the extended type, check later
                                        extendedTypes.add(new ExtendedTypeInfo(type, stream.getLineno(), stream.getCharno()));
                                    } else {
                                        Preconditions.checkState(annotation == Annotation.IMPLEMENTS);
                                        if (!jsdocBuilder.recordImplementedInterface(type)) {
                                            parser.addTypeWarning(""msg.jsdoc.implements.duplicate"", lineno, charno);
                                        }
                                    }
                                    token = next();
                                    if (matchingRc) {
                                        if (token != JsDocToken.RC) {
                                            parser.addTypeWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                        }
                                    } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) {
                                        parser.addTypeWarning(""msg.end.annotation.expected"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addTypeWarning(""msg.no.type.name"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case HIDDEN:
                                if (!jsdocBuilder.recordHiddenness()) {
                                    parser.addParserWarning(""msg.jsdoc.hidden"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case LENDS:
                                skipEOLs();
                                matchingRc = false;
                                if (match(JsDocToken.LC)) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (match(JsDocToken.STRING)) {
                                    token = next();
                                    if (!jsdocBuilder.recordLends(stream.getString())) {
                                        parser.addTypeWarning(""msg.jsdoc.lends.incompatible"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addTypeWarning(""msg.jsdoc.lends.missing"", stream.getLineno(), stream.getCharno());
                                }
                                if (matchingRc && !match(JsDocToken.RC)) {
                                    parser.addTypeWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case MEANING:
                                ExtractionInfo meaningInfo = extractMultilineTextualBlock(token);
                                String meaning = meaningInfo.string;
                                token = meaningInfo.token;
                                if (!jsdocBuilder.recordMeaning(meaning)) {
                                    parser.addParserWarning(""msg.jsdoc.meaning.extra"", stream.getLineno(), stream.getCharno());
                                }
                                continue retry;
                            case NO_ALIAS:
                                if (!jsdocBuilder.recordNoAlias()) {
                                    parser.addParserWarning(""msg.jsdoc.noalias"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_COMPILE:
                                if (!jsdocBuilder.recordNoCompile()) {
                                    parser.addParserWarning(""msg.jsdoc.nocompile"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_TYPE_CHECK:
                                if (!jsdocBuilder.recordNoTypeCheck()) {
                                    parser.addParserWarning(""msg.jsdoc.nocheck"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NOT_IMPLEMENTED:
                                token = eatTokensUntilEOL();
                                continue retry;
                            case INHERIT_DOC:
                            case OVERRIDE:
                                if (!jsdocBuilder.recordOverride()) {
                                    parser.addTypeWarning(""msg.jsdoc.override"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case THROWS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                }
                                // *Update* the token to that after the type annotation.
                                token = current();
                                // Save the throw type.
                                jsdocBuilder.recordThrowType(type);
                                // Find the throw's description (if applicable).
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    if (description.length() > 0) {
                                        jsdocBuilder.recordThrowDescription(type, description);
                                    }
                                    token = descriptionInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case PARAM:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordParamTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                    skipEOLs();
                                    token = next();
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                }
                                String name = null;
                                boolean isBracketedParam = JsDocToken.LB == token;
                                if (isBracketedParam) {
                                    token = next();
                                }
                                if (JsDocToken.STRING != token) {
                                    parser.addTypeWarning(""msg.missing.variable.name"", lineno, charno);
                                } else {
                                    name = stream.getString();
                                    if (isBracketedParam) {
                                        token = next();
                                        // system.
                                        if (JsDocToken.EQUALS == token) {
                                            token = next();
                                            if (JsDocToken.STRING == token) {
                                                token = next();
                                            }
                                        }
                                        if (JsDocToken.RB != token) {
                                            reportTypeSyntaxWarning(""msg.jsdoc.missing.rb"");
                                        } else if (type != null) {
                                            // Make the type expression optional, if it isn't
                                            // already.
                                            type = JSTypeExpression.makeOptionalArg(type);
                                        }
                                    }
                                    // for handling properties of params.
                                    if (name.indexOf('.') > -1) {
                                        name = null;
                                    } else if (!jsdocBuilder.recordParameter(name, type)) {
                                        if (jsdocBuilder.hasParameter(name)) {
                                            parser.addTypeWarning(""msg.dup.variable.name"", name, lineno, charno);
                                        } else {
                                            parser.addTypeWarning(""msg.jsdoc.incompat.type"", name, lineno, charno);
                                        }
                                    }
                                }
                                if (name == null) {
                                    token = eatTokensUntilEOL(token);
                                    continue retry;
                                }
                                jsdocBuilder.markName(name, lineno, charno);
                                // Find the parameter's description (if applicable).
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token);
                                    String paramDescription = paramDescriptionInfo.string;
                                    if (paramDescription.length() > 0) {
                                        jsdocBuilder.recordParameterDescription(name, paramDescription);
                                    }
                                    token = paramDescriptionInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case PRESERVE_TRY:
                                if (!jsdocBuilder.recordPreserveTry()) {
                                    parser.addParserWarning(""msg.jsdoc.preservertry"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PRIVATE:
                                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
                                    parser.addParserWarning(""msg.jsdoc.visibility.private"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PROTECTED:
                                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
                                    parser.addParserWarning(""msg.jsdoc.visibility.protected"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PUBLIC:
                                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
                                    parser.addParserWarning(""msg.jsdoc.visibility.public"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SHADOW:
                                if (!jsdocBuilder.recordNoShadow()) {
                                    parser.addParserWarning(""msg.jsdoc.noshadow"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SIDE_EFFECTS:
                                if (!jsdocBuilder.recordNoSideEffects()) {
                                    parser.addParserWarning(""msg.jsdoc.nosideeffects"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case MODIFIES:
                                token = parseModifiesTag(next());
                                continue retry;
                            case IMPLICIT_CAST:
                                if (!jsdocBuilder.recordImplicitCast()) {
                                    parser.addTypeWarning(""msg.jsdoc.implicitcast"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SEE:
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo referenceInfo = extractSingleLineBlock();
                                    String reference = referenceInfo.string;
                                    if (reference.length() == 0) {
                                        parser.addParserWarning(""msg.jsdoc.seemissing"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        jsdocBuilder.addReference(reference);
                                    }
                                    token = referenceInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case SUPPRESS:
                                token = parseSuppressTag(next());
                                continue retry;
                            case TEMPLATE:
                                ExtractionInfo templateInfo = extractSingleLineBlock();
                                String templateTypeName = templateInfo.string;
                                if (templateTypeName.length() == 0) {
                                    parser.addTypeWarning(""msg.jsdoc.templatemissing"", stream.getLineno(), stream.getCharno());
                                } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {
                                    parser.addTypeWarning(""msg.jsdoc.template.at.most.once"", stream.getLineno(), stream.getCharno());
                                }
                                token = templateInfo.token;
                                continue retry;
                            case VERSION:
                                ExtractionInfo versionInfo = extractSingleLineBlock();
                                String version = versionInfo.string;
                                if (version.length() == 0) {
                                    parser.addParserWarning(""msg.jsdoc.versionmissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    if (!jsdocBuilder.recordVersion(version)) {
                                        parser.addParserWarning(""msg.jsdoc.extraversion"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = versionInfo.token;
                                continue retry;
                            case DEFINE:
                            case RETURN:
                            case THIS:
                            case TYPE:
                            case TYPEDEF:
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                Node typeNode = null;
                                if (!lookAheadForTypeAnnotation() && annotation == Annotation.RETURN) {
                                    // If RETURN doesn't have a type annotation, record
                                    // it as the unknown type.
                                    typeNode = newNode(Token.QMARK);
                                } else {
                                    skipEOLs();
                                    token = next();
                                    typeNode = parseAndRecordTypeNode(token, lineno, charno);
                                }
                                if (annotation == Annotation.THIS) {
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    if (typeNode != null && token != JsDocToken.LC) {
                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);
                                    }
                                }
                                type = createJSTypeExpression(typeNode);
                                if (type == null) {
                                // error reported during recursive descent
                                // recovering parsing
                                } else {
                                    switch(annotation) {
                                        case DEFINE:
                                            if (!jsdocBuilder.recordDefineType(type)) {
                                                parser.addParserWarning(""msg.jsdoc.define"", lineno, charno);
                                            }
                                            break;
                                        case RETURN:
                                            if (!jsdocBuilder.recordReturnType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                                break;
                                            }
                                            // Find the return's description (if applicable).
                                            if (jsdocBuilder.shouldParseDocumentation()) {
                                                ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token);
                                                String returnDescription = returnDescriptionInfo.string;
                                                if (returnDescription.length() > 0) {
                                                    jsdocBuilder.recordReturnDescription(returnDescription);
                                                }
                                                token = returnDescriptionInfo.token;
                                            } else {
                                                token = eatTokensUntilEOL(token);
                                            }
                                            continue retry;
                                        case THIS:
                                            if (!jsdocBuilder.recordThisType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPE:
                                            if (!jsdocBuilder.recordType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPEDEF:
                                            if (!jsdocBuilder.recordTypedef(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                    }
                                    token = eatTokensUntilEOL();
                                }
                                continue retry;
                        }
                    }
                }
                break;
            case EOC:
                if (hasParsedFileOverviewDocInfo()) {
                    fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();
                }
                checkExtendedTypes(extendedTypes);
                return true;
            case EOF:
                // discard any accumulated information
                jsdocBuilder.build(null);
                parser.addParserWarning(""msg.unexpected.eof"", stream.getLineno(), stream.getCharno());
                checkExtendedTypes(extendedTypes);
                return false;
            case EOL:
                if (state == State.SEARCHING_NEWLINE) {
                    state = State.SEARCHING_ANNOTATION;
                }
                token = next();
                continue retry;
            default:
                if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {
                    token = next();
                    continue retry;
                } else {
                    state = State.SEARCHING_NEWLINE;
                    token = eatTokensUntilEOL();
                    continue retry;
                }
        }
        // next token
        token = next();
    }
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */
","boolean parse() {
    int lineno;
    int charno;
        JSTypeExpression type;
    state = State.SEARCHING_ANNOTATION;
    skipEOLs();
    JsDocToken token = next();
    List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();
        if (jsdocBuilder.shouldParseDocumentation()) {
        ExtractionInfo blockInfo = extractBlockComment(token);
        token = blockInfo.token;
        if (!blockInfo.string.isEmpty()) {
            jsdocBuilder.recordBlockDescription(blockInfo.string);
        }
    } else {
        if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) {
                                    jsdocBuilder.recordBlockDescription("""");
        }
    }
        retry: for (; ; ) {
        switch(token) {
            case ANNOTATION:
                if (state == State.SEARCHING_ANNOTATION) {
                    state = State.SEARCHING_NEWLINE;
                    lineno = stream.getLineno();
                    charno = stream.getCharno();
                    String annotationName = stream.getString();
                    Annotation annotation = annotationNames.get(annotationName);
                    if (annotation == null) {
                        parser.addParserWarning(""msg.bad.jsdoc.tag"", annotationName, stream.getLineno(), stream.getCharno());
                    } else {
                                                jsdocBuilder.markAnnotation(annotationName, lineno, charno);
                        switch(annotation) {
                            case AUTHOR:
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo authorInfo = extractSingleLineBlock();
                                    String author = authorInfo.string;
                                    if (author.length() == 0) {
                                        parser.addParserWarning(""msg.jsdoc.authormissing"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        jsdocBuilder.addAuthor(author);
                                    }
                                    token = authorInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case CONSTANT:
                                if (!jsdocBuilder.recordConstancy()) {
                                    parser.addParserWarning(""msg.jsdoc.const"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case CONSTRUCTOR:
                                if (!jsdocBuilder.recordConstructor()) {
                                    if (jsdocBuilder.isInterfaceRecorded()) {
                                        parser.addTypeWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DEPRECATED:
                                if (!jsdocBuilder.recordDeprecated()) {
                                    parser.addParserWarning(""msg.jsdoc.deprecated"", stream.getLineno(), stream.getCharno());
                                }
                                                                ExtractionInfo reasonInfo = extractMultilineTextualBlock(token);
                                String reason = reasonInfo.string;
                                if (reason.length() > 0) {
                                    jsdocBuilder.recordDeprecationReason(reason);
                                }
                                token = reasonInfo.token;
                                continue retry;
                            case INTERFACE:
                                if (!jsdocBuilder.recordInterface()) {
                                    if (jsdocBuilder.isConstructorRecorded()) {
                                        parser.addTypeWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DESC:
                                if (jsdocBuilder.isDescriptionRecorded()) {
                                    parser.addParserWarning(""msg.jsdoc.desc.extra"", stream.getLineno(), stream.getCharno());
                                    token = eatTokensUntilEOL();
                                    continue retry;
                                } else {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    jsdocBuilder.recordDescription(description);
                                    token = descriptionInfo.token;
                                    continue retry;
                                }
                            case FILE_OVERVIEW:
                                String fileOverview = """";
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM);
                                    fileOverview = fileOverviewInfo.string;
                                    token = fileOverviewInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo != null) {
                                    parser.addParserWarning(""msg.jsdoc.fileoverview.extra"", stream.getLineno(), stream.getCharno());
                                }
                                continue retry;
                            case LICENSE:
                            case PRESERVE:
                                ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);
                                String preserve = preserveInfo.string;
                                if (preserve.length() > 0) {
                                    if (fileLevelJsDocBuilder != null) {
                                        fileLevelJsDocBuilder.append(preserve);
                                    }
                                }
                                token = preserveInfo.token;
                                continue retry;
                            case ENUM:
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                }
                                if (type == null) {
                                    type = createJSTypeExpression(newStringNode(""number""));
                                }
                                if (!jsdocBuilder.recordEnumParameterType(type)) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case EXPORT:
                                if (!jsdocBuilder.recordExport()) {
                                    parser.addParserWarning(""msg.jsdoc.export"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTERNS:
                                if (!jsdocBuilder.recordExterns()) {
                                    parser.addParserWarning(""msg.jsdoc.externs"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case JAVA_DISPATCH:
                                if (!jsdocBuilder.recordJavaDispatch()) {
                                    parser.addParserWarning(""msg.jsdoc.javadispatch"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTENDS:
                            case IMPLEMENTS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                boolean matchingRc = false;
                                if (token == JsDocToken.LC) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (token == JsDocToken.STRING) {
                                    Node typeNode = parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    if (typeNode != null && !matchingRc) {
                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);
                                    }
                                    type = createJSTypeExpression(typeNode);
                                    if (annotation == Annotation.EXTENDS) {
                                                                                extendedTypes.add(new ExtendedTypeInfo(type, stream.getLineno(), stream.getCharno()));
                                    } else {
                                        Preconditions.checkState(annotation == Annotation.IMPLEMENTS);
                                        if (!jsdocBuilder.recordImplementedInterface(type)) {
                                            parser.addTypeWarning(""msg.jsdoc.implements.duplicate"", lineno, charno);
                                        }
                                    }
                                    token = next();
                                    if (matchingRc) {
                                        if (token != JsDocToken.RC) {
                                            parser.addTypeWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                        }
                                    } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) {
                                        parser.addTypeWarning(""msg.end.annotation.expected"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addTypeWarning(""msg.no.type.name"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case HIDDEN:
                                if (!jsdocBuilder.recordHiddenness()) {
                                    parser.addParserWarning(""msg.jsdoc.hidden"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case LENDS:
                                skipEOLs();
                                matchingRc = false;
                                if (match(JsDocToken.LC)) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (match(JsDocToken.STRING)) {
                                    token = next();
                                    if (!jsdocBuilder.recordLends(stream.getString())) {
                                        parser.addTypeWarning(""msg.jsdoc.lends.incompatible"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addTypeWarning(""msg.jsdoc.lends.missing"", stream.getLineno(), stream.getCharno());
                                }
                                if (matchingRc && !match(JsDocToken.RC)) {
                                    parser.addTypeWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case MEANING:
                                ExtractionInfo meaningInfo = extractMultilineTextualBlock(token);
                                String meaning = meaningInfo.string;
                                token = meaningInfo.token;
                                if (!jsdocBuilder.recordMeaning(meaning)) {
                                    parser.addParserWarning(""msg.jsdoc.meaning.extra"", stream.getLineno(), stream.getCharno());
                                }
                                continue retry;
                            case NO_ALIAS:
                                if (!jsdocBuilder.recordNoAlias()) {
                                    parser.addParserWarning(""msg.jsdoc.noalias"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_COMPILE:
                                if (!jsdocBuilder.recordNoCompile()) {
                                    parser.addParserWarning(""msg.jsdoc.nocompile"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_TYPE_CHECK:
                                if (!jsdocBuilder.recordNoTypeCheck()) {
                                    parser.addParserWarning(""msg.jsdoc.nocheck"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NOT_IMPLEMENTED:
                                token = eatTokensUntilEOL();
                                continue retry;
                            case INHERIT_DOC:
                            case OVERRIDE:
                                if (!jsdocBuilder.recordOverride()) {
                                    parser.addTypeWarning(""msg.jsdoc.override"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case THROWS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                    if (type == null) {
                                                                                                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                }
                                                                token = current();
                                                                jsdocBuilder.recordThrowType(type);
                                                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    if (description.length() > 0) {
                                        jsdocBuilder.recordThrowDescription(type, description);
                                    }
                                    token = descriptionInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case PARAM:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordParamTypeNode(token));
                                    if (type == null) {
                                                                                                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                    skipEOLs();
                                    token = next();
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                }
                                String name = null;
                                boolean isBracketedParam = JsDocToken.LB == token;
                                if (isBracketedParam) {
                                    token = next();
                                }
                                if (JsDocToken.STRING != token) {
                                    parser.addTypeWarning(""msg.missing.variable.name"", lineno, charno);
                                } else {
                                    name = stream.getString();
                                    if (isBracketedParam) {
                                        token = next();
                                                                                if (JsDocToken.EQUALS == token) {
                                            token = next();
                                            if (JsDocToken.STRING == token) {
                                                token = next();
                                            }
                                        }
                                        if (JsDocToken.RB != token) {
                                            reportTypeSyntaxWarning(""msg.jsdoc.missing.rb"");
                                        } else if (type != null) {
                                                                                                                                    type = JSTypeExpression.makeOptionalArg(type);
                                        }
                                    }
                                                                        if (name.indexOf('.') > -1) {
                                        name = null;
                                    } else if (!jsdocBuilder.recordParameter(name, type)) {
                                        if (jsdocBuilder.hasParameter(name)) {
                                            parser.addTypeWarning(""msg.dup.variable.name"", name, lineno, charno);
                                        } else {
                                            parser.addTypeWarning(""msg.jsdoc.incompat.type"", name, lineno, charno);
                                        }
                                    }
                                }
                                if (name == null) {
                                    token = eatTokensUntilEOL(token);
                                    continue retry;
                                }
                                jsdocBuilder.markName(name, lineno, charno);
                                                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token);
                                    String paramDescription = paramDescriptionInfo.string;
                                    if (paramDescription.length() > 0) {
                                        jsdocBuilder.recordParameterDescription(name, paramDescription);
                                    }
                                    token = paramDescriptionInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case PRESERVE_TRY:
                                if (!jsdocBuilder.recordPreserveTry()) {
                                    parser.addParserWarning(""msg.jsdoc.preservertry"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PRIVATE:
                                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
                                    parser.addParserWarning(""msg.jsdoc.visibility.private"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PROTECTED:
                                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
                                    parser.addParserWarning(""msg.jsdoc.visibility.protected"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PUBLIC:
                                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
                                    parser.addParserWarning(""msg.jsdoc.visibility.public"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SHADOW:
                                if (!jsdocBuilder.recordNoShadow()) {
                                    parser.addParserWarning(""msg.jsdoc.noshadow"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SIDE_EFFECTS:
                                if (!jsdocBuilder.recordNoSideEffects()) {
                                    parser.addParserWarning(""msg.jsdoc.nosideeffects"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case MODIFIES:
                                token = parseModifiesTag(next());
                                continue retry;
                            case IMPLICIT_CAST:
                                if (!jsdocBuilder.recordImplicitCast()) {
                                    parser.addTypeWarning(""msg.jsdoc.implicitcast"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SEE:
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo referenceInfo = extractSingleLineBlock();
                                    String reference = referenceInfo.string;
                                    if (reference.length() == 0) {
                                        parser.addParserWarning(""msg.jsdoc.seemissing"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        jsdocBuilder.addReference(reference);
                                    }
                                    token = referenceInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case SUPPRESS:
                                token = parseSuppressTag(next());
                                continue retry;
                            case TEMPLATE:
                                ExtractionInfo templateInfo = extractSingleLineBlock();
                                String templateTypeName = templateInfo.string;
                                if (templateTypeName.length() == 0) {
                                    parser.addTypeWarning(""msg.jsdoc.templatemissing"", stream.getLineno(), stream.getCharno());
                                } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {
                                    parser.addTypeWarning(""msg.jsdoc.template.at.most.once"", stream.getLineno(), stream.getCharno());
                                }
                                token = templateInfo.token;
                                continue retry;
                            case VERSION:
                                ExtractionInfo versionInfo = extractSingleLineBlock();
                                String version = versionInfo.string;
                                if (version.length() == 0) {
                                    parser.addParserWarning(""msg.jsdoc.versionmissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    if (!jsdocBuilder.recordVersion(version)) {
                                        parser.addParserWarning(""msg.jsdoc.extraversion"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = versionInfo.token;
                                continue retry;
                            case DEFINE:
                            case RETURN:
                            case THIS:
                            case TYPE:
                            case TYPEDEF:
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                Node typeNode = null;
                                if (!lookAheadForTypeAnnotation() && annotation == Annotation.RETURN) {
                                                                                                            typeNode = newNode(Token.QMARK);
                                } else {
                                    skipEOLs();
                                    token = next();
                                    typeNode = parseAndRecordTypeNode(token, lineno, charno);
                                }
                                if (annotation == Annotation.THIS) {
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    if (typeNode != null && token != JsDocToken.LC) {
                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);
                                    }
                                }
                                type = createJSTypeExpression(typeNode);
                                if (type == null) {
                                                                                                } else {
                                    switch(annotation) {
                                        case DEFINE:
                                            if (!jsdocBuilder.recordDefineType(type)) {
                                                parser.addParserWarning(""msg.jsdoc.define"", lineno, charno);
                                            }
                                            break;
                                        case RETURN:
                                            if (!jsdocBuilder.recordReturnType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                                break;
                                            }
                                                                                        if (jsdocBuilder.shouldParseDocumentation()) {
                                                ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token);
                                                String returnDescription = returnDescriptionInfo.string;
                                                if (returnDescription.length() > 0) {
                                                    jsdocBuilder.recordReturnDescription(returnDescription);
                                                }
                                                token = returnDescriptionInfo.token;
                                            } else {
                                                token = eatTokensUntilEOL(token);
                                            }
                                            continue retry;
                                        case THIS:
                                            if (!jsdocBuilder.recordThisType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPE:
                                            if (!jsdocBuilder.recordType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPEDEF:
                                            if (!jsdocBuilder.recordTypedef(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                    }
                                    token = eatTokensUntilEOL();
                                }
                                continue retry;
                        }
                    }
                }
                break;
            case EOC:
                if (hasParsedFileOverviewDocInfo()) {
                    fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();
                }
                checkExtendedTypes(extendedTypes);
                return true;
            case EOF:
                                jsdocBuilder.build(null);
                parser.addParserWarning(""msg.unexpected.eof"", stream.getLineno(), stream.getCharno());
                checkExtendedTypes(extendedTypes);
                return false;
            case EOL:
                if (state == State.SEARCHING_NEWLINE) {
                    state = State.SEARCHING_ANNOTATION;
                }
                token = next();
                continue retry;
            default:
                if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {
                    token = next();
                    continue retry;
                } else {
                    state = State.SEARCHING_NEWLINE;
                    token = eatTokensUntilEOL();
                    continue retry;
                }
        }
                token = next();
    }
}",23.545454545454547,2.6889952153110044,38.0,5.0,17.833333333333332,3.373015873015873,-3.515292459478505,26.083333333333332,-0.02631578947368421,98.55931259832988
wicket,remotes/origin/bugs-dot-jar_WICKET-5165_0d4d1df7,1,"/**
 *  @param url
 *  @param requestCycle
 */
protected void redirectTo(Url url, RequestCycle requestCycle) {
    WebResponse response = (WebResponse) requestCycle.getResponse();
    String relativeUrl = requestCycle.getUrlRenderer().renderUrl(url);
    response.sendRedirect(relativeUrl);
}","/**
 *  @param url
 *  @param requestCycle
 */
","protected void redirectTo(Url url, RequestCycle requestCycle) {
    WebResponse response = (WebResponse) requestCycle.getResponse();
    String relativeUrl = requestCycle.getUrlRenderer().renderUrl(url);
    response.sendRedirect(relativeUrl);
}",-0.4090909090909091,-0.49282296650717716,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.5833685694150811,-0.16666666666666666,2.1578947368421053,-0.16279340490885932
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-43_668f08f2,1,"void apply() throws Exception {
    addNode(parentNodePath, nodeName, properties);
}",,"void apply() throws Exception {
    addNode(parentNodePath, nodeName, properties);
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,1.0329809725158563,-0.4166666666666667,0.5263157894736842,-0.16279340490885932
commons-math,remotes/origin/bugs-dot-jar_MATH-393_d4b02f6a,3,"/**
 * Get the number of evaluations of the objective function.
 * <p>
 * The number of evaluations corresponds to the last call to the
 * {@link #optimize(UnivariateRealFunction, GoalType, double, double) optimize}
 * method. It is 0 if the method has not been called yet.
 * </p>
 * @return number of evaluations of the objective function
 */
int getEvaluations();","/**
 * Get the number of evaluations of the objective function.
 * <p>
 * The number of evaluations corresponds to the last call to the
 * {@link #optimize(UnivariateRealFunction, GoalType, double, double) optimize}
 * method. It is 0 if the method has not been called yet.
 * </p>
 * @return number of evaluations of the objective function
 */
",int getEvaluations();,-0.5909090909090909,-1.4306220095693782,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,1.8696264975334735,-0.5,2.526315789473684,-0.16279340490885932
commons-math,remotes/origin/bugs-dot-jar_MATH-326_ce185345,1,"/**
 * {@inheritDoc}
 */
public double getL1Norm() {
    double res = 0;
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        res += Math.abs(iter.value());
    }
    return res;
}","/**
 * {@inheritDoc}
 */
","public double getL1Norm() {
    double res = 0;
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        res += Math.abs(iter.value());
    }
    return res;
}",-0.22727272727272727,-0.15311004784689008,-0.4,-0.5,-0.25,-0.0912698412698413,0.315292459478506,-0.08333333333333333,2.0,-0.11041994433014643
camel,remotes/origin/bugs-dot-jar_CAMEL-9444_baece126,1,"private AggregationStrategy createAggregationStrategy(RouteContext routeContext) {
    AggregationStrategy strategy = getAggregationStrategy();
    if (strategy == null && strategyRef != null) {
        Object aggStrategy = routeContext.lookup(strategyRef, Object.class);
        if (aggStrategy instanceof AggregationStrategy) {
            strategy = (AggregationStrategy) aggStrategy;
        } else if (aggStrategy != null) {
            AggregationStrategyBeanAdapter adapter = new AggregationStrategyBeanAdapter(aggStrategy, getStrategyMethodName());
            if (getStrategyMethodAllowNull() != null) {
                adapter.setAllowNullNewExchange(getStrategyMethodAllowNull());
                adapter.setAllowNullOldExchange(getStrategyMethodAllowNull());
            }
            strategy = adapter;
        } else {
            throw new IllegalArgumentException(""Cannot find AggregationStrategy in Registry with name: "" + strategyRef);
        }
    }
    if (strategy == null) {
        // fallback to use latest
        strategy = new UseLatestAggregationStrategy();
    }
    if (strategy instanceof CamelContextAware) {
        ((CamelContextAware) strategy).setCamelContext(routeContext.getCamelContext());
    }
    return strategy;
}",,"private AggregationStrategy createAggregationStrategy(RouteContext routeContext) {
    AggregationStrategy strategy = getAggregationStrategy();
    if (strategy == null && strategyRef != null) {
        Object aggStrategy = routeContext.lookup(strategyRef, Object.class);
        if (aggStrategy instanceof AggregationStrategy) {
            strategy = (AggregationStrategy) aggStrategy;
        } else if (aggStrategy != null) {
            AggregationStrategyBeanAdapter adapter = new AggregationStrategyBeanAdapter(aggStrategy, getStrategyMethodName());
            if (getStrategyMethodAllowNull() != null) {
                adapter.setAllowNullNewExchange(getStrategyMethodAllowNull());
                adapter.setAllowNullOldExchange(getStrategyMethodAllowNull());
            }
            strategy = adapter;
        } else {
            throw new IllegalArgumentException(""Cannot find AggregationStrategy in Registry with name: "" + strategyRef);
        }
    }
    if (strategy == null) {
                strategy = new UseLatestAggregationStrategy();
    }
    if (strategy instanceof CamelContextAware) {
        ((CamelContextAware) strategy).setCamelContext(routeContext.getCamelContext());
    }
    return strategy;
}",0.5,0.6602870813397129,0.8,1.0,0.5,0.5436507936507937,-0.39450317124735734,0.3333333333333333,-0.02631578947368421,0.5352443191968786
Closure,27,2,"public static Node tryFinally(Node tryBody, Node finallyBody) {
    Preconditions.checkState(tryBody.isLabelName());
    Preconditions.checkState(finallyBody.isLabelName());
    Node catchBody = block().copyInformationFrom(tryBody);
    return new Node(Token.TRY, tryBody, catchBody, finallyBody);
}",,"public static Node tryFinally(Node tryBody, Node finallyBody) {
    Preconditions.checkState(tryBody.isLabelName());
    Preconditions.checkState(finallyBody.isLabelName());
    Node catchBody = block().copyInformationFrom(tryBody);
    return new Node(Token.TRY, tryBody, catchBody, finallyBody);
}",-0.36363636363636365,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.4737138830162087,0.0,-0.02631578947368421,-0.16279340490885932
flink,remotes/origin/bugs-dot-jar_FLINK-2447_5546a1ef,1,"@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
private <IN1, IN2, OUT> TypeInformation<OUT> createTypeInfoWithTypeHierarchy(ArrayList<Type> typeHierarchy, Type t, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {
    // check if type is a subclass of tuple
    if (isClassType(t) && Tuple.class.isAssignableFrom(typeToClass(t))) {
        Type curT = t;
        // do not allow usage of Tuple as type
        if (typeToClass(t).equals(Tuple.class)) {
            throw new InvalidTypesException(""Usage of class Tuple as a type is not allowed. Use a concrete subclass (e.g. Tuple1, Tuple2, etc.) instead."");
        }
        // collect the types while moving up for a later top-down
        while (!(isClassType(curT) && typeToClass(curT).getSuperclass().equals(Tuple.class))) {
            typeHierarchy.add(curT);
            curT = typeToClass(curT).getGenericSuperclass();
        }
        // check if immediate child of Tuple has generics
        if (curT instanceof Class<?>) {
            throw new InvalidTypesException(""Tuple needs to be parameterized by using generics."");
        }
        typeHierarchy.add(curT);
        ParameterizedType tupleChild = (ParameterizedType) curT;
        Type[] subtypes = new Type[tupleChild.getActualTypeArguments().length];
        // materialize possible type variables
        for (int i = 0; i < subtypes.length; i++) {
            // materialize immediate TypeVariables
            if (tupleChild.getActualTypeArguments()[i] instanceof TypeVariable<?>) {
                subtypes[i] = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) tupleChild.getActualTypeArguments()[i]);
            } else // class or parameterized type
            {
                subtypes[i] = tupleChild.getActualTypeArguments()[i];
            }
        }
        TypeInformation<?>[] tupleSubTypes = new TypeInformation<?>[subtypes.length];
        for (int i = 0; i < subtypes.length; i++) {
            // try to derive the type info of the TypeVariable from the immediate base child input as a last attempt
            if (subtypes[i] instanceof TypeVariable<?>) {
                tupleSubTypes[i] = createTypeInfoFromInputs((TypeVariable<?>) subtypes[i], typeHierarchy, in1Type, in2Type);
                // variable could not be determined
                if (tupleSubTypes[i] == null) {
                    throw new InvalidTypesException(""Type of TypeVariable '"" + ((TypeVariable<?>) subtypes[i]).getName() + ""' in '"" + ((TypeVariable<?>) subtypes[i]).getGenericDeclaration() + ""' could not be determined. This is most likely a type erasure problem. "" + ""The type extraction currently supports types with generic variables only in cases where "" + ""all variables in the return type can be deduced from the input type(s)."");
                }
            } else {
                tupleSubTypes[i] = createTypeInfoWithTypeHierarchy(new ArrayList<Type>(typeHierarchy), subtypes[i], in1Type, in2Type);
            }
        }
        Class<?> tAsClass = null;
        if (isClassType(t)) {
            tAsClass = typeToClass(t);
        }
        Preconditions.checkNotNull(tAsClass, ""t has a unexpected type"");
        // check if the class we assumed to be a Tuple so far is actually a pojo because it contains additional fields.
        // check for additional fields.
        int fieldCount = countFieldsInClass(tAsClass);
        if (fieldCount != tupleSubTypes.length) {
            // the class is not a real tuple because it contains additional fields. treat as a pojo
            if (t instanceof ParameterizedType) {
                return (TypeInformation<OUT>) analyzePojo(tAsClass, new ArrayList<Type>(typeHierarchy), (ParameterizedType) t, in1Type, in2Type);
            } else {
                return (TypeInformation<OUT>) analyzePojo(tAsClass, new ArrayList<Type>(typeHierarchy), null, in1Type, in2Type);
            }
        }
        return new TupleTypeInfo(tAsClass, tupleSubTypes);
    } else // e.g. class MyMapper<E> extends MapFunction<String, E>
    if (t instanceof TypeVariable) {
        Type typeVar = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) t);
        if (!(typeVar instanceof TypeVariable)) {
            return createTypeInfoWithTypeHierarchy(typeHierarchy, typeVar, in1Type, in2Type);
        } else // try to derive the type info of the TypeVariable from the immediate base child input as a last attempt
        {
            TypeInformation<OUT> typeInfo = (TypeInformation<OUT>) createTypeInfoFromInputs((TypeVariable<?>) t, typeHierarchy, in1Type, in2Type);
            if (typeInfo != null) {
                return typeInfo;
            } else {
                throw new InvalidTypesException(""Type of TypeVariable '"" + ((TypeVariable<?>) t).getName() + ""' in '"" + ((TypeVariable<?>) t).getGenericDeclaration() + ""' could not be determined. This is most likely a type erasure problem. "" + ""The type extraction currently supports types with generic variables only in cases where "" + ""all variables in the return type can be deduced from the input type(s)."");
            }
        }
    } else // arrays with generics
    if (t instanceof GenericArrayType) {
        GenericArrayType genericArray = (GenericArrayType) t;
        Type componentType = genericArray.getGenericComponentType();
        // due to a Java 6 bug, it is possible that the JVM classifies e.g. String[] or int[] as GenericArrayType instead of Class
        if (componentType instanceof Class) {
            Class<?> componentClass = (Class<?>) componentType;
            String className;
            // for int[], double[] etc.
            if (componentClass.isPrimitive()) {
                className = encodePrimitiveClass(componentClass);
            } else // for String[], Integer[] etc.
            {
                className = ""L"" + componentClass.getName() + "";"";
            }
            Class<OUT> classArray;
            try {
                classArray = (Class<OUT>) Class.forName(""["" + className);
            } catch (ClassNotFoundException e) {
                throw new InvalidTypesException(""Could not convert GenericArrayType to Class."");
            }
            return getForClass(classArray);
        }
        TypeInformation<?> componentInfo = createTypeInfoWithTypeHierarchy(typeHierarchy, genericArray.getGenericComponentType(), in1Type, in2Type);
        return ObjectArrayTypeInfo.getInfoFor(t, componentInfo);
    } else // objects with generics are treated as Class first
    if (t instanceof ParameterizedType) {
        return (TypeInformation<OUT>) privateGetForClass(typeToClass(t), typeHierarchy, (ParameterizedType) t, in1Type, in2Type);
    } else // no tuple, no TypeVariable, no generic type
    if (t instanceof Class) {
        return privateGetForClass((Class<OUT>) t, typeHierarchy);
    }
    throw new InvalidTypesException(""Type Information could not be created."");
}",,"@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
private <IN1, IN2, OUT> TypeInformation<OUT> createTypeInfoWithTypeHierarchy(ArrayList<Type> typeHierarchy, Type t, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {
        if (isClassType(t) && Tuple.class.isAssignableFrom(typeToClass(t))) {
        Type curT = t;
                if (typeToClass(t).equals(Tuple.class)) {
            throw new InvalidTypesException(""Usage of class Tuple as a type is not allowed. Use a concrete subclass (e.g. Tuple1, Tuple2, etc.) instead."");
        }
                while (!(isClassType(curT) && typeToClass(curT).getSuperclass().equals(Tuple.class))) {
            typeHierarchy.add(curT);
            curT = typeToClass(curT).getGenericSuperclass();
        }
                if (curT instanceof Class<?>) {
            throw new InvalidTypesException(""Tuple needs to be parameterized by using generics."");
        }
        typeHierarchy.add(curT);
        ParameterizedType tupleChild = (ParameterizedType) curT;
        Type[] subtypes = new Type[tupleChild.getActualTypeArguments().length];
                for (int i = 0; i < subtypes.length; i++) {
                        if (tupleChild.getActualTypeArguments()[i] instanceof TypeVariable<?>) {
                subtypes[i] = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) tupleChild.getActualTypeArguments()[i]);
            } else             {
                subtypes[i] = tupleChild.getActualTypeArguments()[i];
            }
        }
        TypeInformation<?>[] tupleSubTypes = new TypeInformation<?>[subtypes.length];
        for (int i = 0; i < subtypes.length; i++) {
                        if (subtypes[i] instanceof TypeVariable<?>) {
                tupleSubTypes[i] = createTypeInfoFromInputs((TypeVariable<?>) subtypes[i], typeHierarchy, in1Type, in2Type);
                                if (tupleSubTypes[i] == null) {
                    throw new InvalidTypesException(""Type of TypeVariable '"" + ((TypeVariable<?>) subtypes[i]).getName() + ""' in '"" + ((TypeVariable<?>) subtypes[i]).getGenericDeclaration() + ""' could not be determined. This is most likely a type erasure problem. "" + ""The type extraction currently supports types with generic variables only in cases where "" + ""all variables in the return type can be deduced from the input type(s)."");
                }
            } else {
                tupleSubTypes[i] = createTypeInfoWithTypeHierarchy(new ArrayList<Type>(typeHierarchy), subtypes[i], in1Type, in2Type);
            }
        }
        Class<?> tAsClass = null;
        if (isClassType(t)) {
            tAsClass = typeToClass(t);
        }
        Preconditions.checkNotNull(tAsClass, ""t has a unexpected type"");
                        int fieldCount = countFieldsInClass(tAsClass);
        if (fieldCount != tupleSubTypes.length) {
                        if (t instanceof ParameterizedType) {
                return (TypeInformation<OUT>) analyzePojo(tAsClass, new ArrayList<Type>(typeHierarchy), (ParameterizedType) t, in1Type, in2Type);
            } else {
                return (TypeInformation<OUT>) analyzePojo(tAsClass, new ArrayList<Type>(typeHierarchy), null, in1Type, in2Type);
            }
        }
        return new TupleTypeInfo(tAsClass, tupleSubTypes);
    } else     if (t instanceof TypeVariable) {
        Type typeVar = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) t);
        if (!(typeVar instanceof TypeVariable)) {
            return createTypeInfoWithTypeHierarchy(typeHierarchy, typeVar, in1Type, in2Type);
        } else         {
            TypeInformation<OUT> typeInfo = (TypeInformation<OUT>) createTypeInfoFromInputs((TypeVariable<?>) t, typeHierarchy, in1Type, in2Type);
            if (typeInfo != null) {
                return typeInfo;
            } else {
                throw new InvalidTypesException(""Type of TypeVariable '"" + ((TypeVariable<?>) t).getName() + ""' in '"" + ((TypeVariable<?>) t).getGenericDeclaration() + ""' could not be determined. This is most likely a type erasure problem. "" + ""The type extraction currently supports types with generic variables only in cases where "" + ""all variables in the return type can be deduced from the input type(s)."");
            }
        }
    } else     if (t instanceof GenericArrayType) {
        GenericArrayType genericArray = (GenericArrayType) t;
        Type componentType = genericArray.getGenericComponentType();
                if (componentType instanceof Class) {
            Class<?> componentClass = (Class<?>) componentType;
            String className;
                        if (componentClass.isPrimitive()) {
                className = encodePrimitiveClass(componentClass);
            } else             {
                className = ""L"" + componentClass.getName() + "";"";
            }
            Class<OUT> classArray;
            try {
                classArray = (Class<OUT>) Class.forName(""["" + className);
            } catch (ClassNotFoundException e) {
                throw new InvalidTypesException(""Could not convert GenericArrayType to Class."");
            }
            return getForClass(classArray);
        }
        TypeInformation<?> componentInfo = createTypeInfoWithTypeHierarchy(typeHierarchy, genericArray.getGenericComponentType(), in1Type, in2Type);
        return ObjectArrayTypeInfo.getInfoFor(t, componentInfo);
    } else     if (t instanceof ParameterizedType) {
        return (TypeInformation<OUT>) privateGetForClass(typeToClass(t), typeHierarchy, (ParameterizedType) t, in1Type, in2Type);
    } else     if (t instanceof Class) {
        return privateGetForClass((Class<OUT>) t, typeHierarchy);
    }
    throw new InvalidTypesException(""Type Information could not be created."");
}",3.727272727272727,0.5023923444976076,4.8,1.5,2.75,2.630952380952381,-1.4160676532769552,3.25,-0.02631578947368421,15.126347515891261
Csv,7,1,"/**
 * Initializes the name to index mapping if the format defines a header.
 *
 * @return null if the format has no header.
 */
private Map<String, Integer> initializeHeader() throws IOException {
    Map<String, Integer> hdrMap = null;
    final String[] formatHeader = this.format.getHeader();
    if (formatHeader != null) {
        hdrMap = new LinkedHashMap<String, Integer>();
        String[] header = null;
        if (formatHeader.length == 0) {
            // read the header from the first line of the file
            final CSVRecord nextRecord = this.nextRecord();
            if (nextRecord != null) {
                header = nextRecord.values();
            }
        } else {
            if (this.format.getSkipHeaderRecord()) {
                this.nextRecord();
            }
            header = formatHeader;
        }
        // build the name to index mappings
        if (header != null) {
            for (int i = 0; i < header.length; i++) {
                hdrMap.put(header[i], Integer.valueOf(i));
            }
        }
    }
    return hdrMap;
}","/**
 * Initializes the name to index mapping if the format defines a header.
 *
 * @return null if the format has no header.
 */
","private Map<String, Integer> initializeHeader() throws IOException {
    Map<String, Integer> hdrMap = null;
    final String[] formatHeader = this.format.getHeader();
    if (formatHeader != null) {
        hdrMap = new LinkedHashMap<String, Integer>();
        String[] header = null;
        if (formatHeader.length == 0) {
                        final CSVRecord nextRecord = this.nextRecord();
            if (nextRecord != null) {
                header = nextRecord.values();
            }
        } else {
            if (this.format.getSkipHeaderRecord()) {
                this.nextRecord();
            }
            header = formatHeader;
        }
                if (header != null) {
            for (int i = 0; i < header.length; i++) {
                hdrMap.put(header[i], Integer.valueOf(i));
            }
        }
    }
    return hdrMap;
}",0.5,0.736842105263158,0.6,0.5,0.6666666666666666,0.6448412698412699,-0.38914728682170513,0.08333333333333333,-0.02631578947368421,0.6184148499046235
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1199_813109d7,3,"public void setTableProperty(ByteBuffer login, String tableName, String property, String value) throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException;",,"public void setTableProperty(ByteBuffer login, String tableName, String property, String value) throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException;",-0.5909090909090909,-1.4306220095693782,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,1.3687103594080336,-0.5,-0.02631578947368421,-0.16279340490885932
commons-math,remotes/origin/bugs-dot-jar_MATH-1103_a6f96306,1,"/**
 * {@inheritDoc}
 */
public Optimum optimize(final LeastSquaresProblem problem) {
    // pull in relevant data from the problem as locals
    // Number of observed data.
    final int nR = problem.getObservationSize();
    // Number of parameters.
    final int nC = problem.getParameterSize();
    final double[] currentPoint = problem.getStart().toArray();
    // counters
    final Incrementor iterationCounter = problem.getIterationCounter();
    final Incrementor evaluationCounter = problem.getEvaluationCounter();
    // convergence criterion
    final ConvergenceChecker<Evaluation> checker = problem.getConvergenceChecker();
    // arrays shared with the other private methods
    final int solvedCols = FastMath.min(nR, nC);
    /* Parameters evolution direction associated with lmPar. */
    double[] lmDir = new double[nC];
    /* Levenberg-Marquardt parameter. */
    double lmPar = 0;
    // local point
    double delta = 0;
    double xNorm = 0;
    double[] diag = new double[nC];
    double[] oldX = new double[nC];
    double[] oldRes = new double[nR];
    double[] qtf = new double[nR];
    double[] work1 = new double[nC];
    double[] work2 = new double[nC];
    double[] work3 = new double[nC];
    // Evaluate the function at the starting point and calculate its norm.
    evaluationCounter.incrementCount();
    // value will be reassigned in the loop
    Evaluation current = problem.evaluate(new ArrayRealVector(currentPoint, false));
    double[] currentResiduals = current.getResiduals().toArray();
    double currentCost = current.getCost();
    // Outer loop.
    boolean firstIteration = true;
    while (true) {
        iterationCounter.incrementCount();
        final Evaluation previous = current;
        // QR decomposition of the jacobian matrix
        final InternalData internalData = qrDecomposition(current.getJacobian(), solvedCols);
        final double[][] weightedJacobian = internalData.weightedJacobian;
        final int[] permutation = internalData.permutation;
        final double[] diagR = internalData.diagR;
        final double[] jacNorm = internalData.jacNorm;
        // residuals already have weights applied
        double[] weightedResidual = currentResiduals;
        for (int i = 0; i < nR; i++) {
            qtf[i] = weightedResidual[i];
        }
        // compute Qt.res
        qTy(qtf, internalData);
        // so let jacobian contain the R matrix with its diagonal elements
        for (int k = 0; k < solvedCols; ++k) {
            int pk = permutation[k];
            weightedJacobian[k][pk] = diagR[pk];
        }
        if (firstIteration) {
            // scale the point according to the norms of the columns
            // of the initial jacobian
            xNorm = 0;
            for (int k = 0; k < nC; ++k) {
                double dk = jacNorm[k];
                if (dk == 0) {
                    dk = 1.0;
                }
                double xk = dk * currentPoint[k];
                xNorm += xk * xk;
                diag[k] = dk;
            }
            xNorm = FastMath.sqrt(xNorm);
            // initialize the step bound delta
            delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);
        }
        // check orthogonality between function vector and jacobian columns
        double maxCosine = 0;
        if (currentCost != 0) {
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                double s = jacNorm[pj];
                if (s != 0) {
                    double sum = 0;
                    for (int i = 0; i <= j; ++i) {
                        sum += weightedJacobian[i][pj] * qtf[i];
                    }
                    maxCosine = FastMath.max(maxCosine, FastMath.abs(sum) / (s * currentCost));
                }
            }
        }
        if (maxCosine <= orthoTolerance) {
            // Convergence has been reached.
            return new OptimumImpl(current, evaluationCounter.getCount(), iterationCounter.getCount());
        }
        // rescale if necessary
        for (int j = 0; j < nC; ++j) {
            diag[j] = FastMath.max(diag[j], jacNorm[j]);
        }
        // Inner loop.
        for (double ratio = 0; ratio < 1.0e-4; ) {
            // save the state
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                oldX[pj] = currentPoint[pj];
            }
            final double previousCost = currentCost;
            double[] tmpVec = weightedResidual;
            weightedResidual = oldRes;
            oldRes = tmpVec;
            // determine the Levenberg-Marquardt parameter
            lmPar = determineLMParameter(qtf, delta, diag, internalData, solvedCols, work1, work2, work3, lmDir, lmPar);
            // compute the new point and the norm of the evolution direction
            double lmNorm = 0;
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                lmDir[pj] = -lmDir[pj];
                currentPoint[pj] = oldX[pj] + lmDir[pj];
                double s = diag[pj] * lmDir[pj];
                lmNorm += s * s;
            }
            lmNorm = FastMath.sqrt(lmNorm);
            // on the first iteration, adjust the initial step bound.
            if (firstIteration) {
                delta = FastMath.min(delta, lmNorm);
            }
            // Evaluate the function at x + p and calculate its norm.
            evaluationCounter.incrementCount();
            current = problem.evaluate(new ArrayRealVector(currentPoint, false));
            currentResiduals = current.getResiduals().toArray();
            currentCost = current.getCost();
            // compute the scaled actual reduction
            double actRed = -1.0;
            if (0.1 * currentCost < previousCost) {
                double r = currentCost / previousCost;
                actRed = 1.0 - r * r;
            }
            // and the scaled directional derivative
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                double dirJ = lmDir[pj];
                work1[j] = 0;
                for (int i = 0; i <= j; ++i) {
                    work1[i] += weightedJacobian[i][pj] * dirJ;
                }
            }
            double coeff1 = 0;
            for (int j = 0; j < solvedCols; ++j) {
                coeff1 += work1[j] * work1[j];
            }
            double pc2 = previousCost * previousCost;
            coeff1 /= pc2;
            double coeff2 = lmPar * lmNorm * lmNorm / pc2;
            double preRed = coeff1 + 2 * coeff2;
            double dirDer = -(coeff1 + coeff2);
            // ratio of the actual to the predicted reduction
            ratio = (preRed == 0) ? 0 : (actRed / preRed);
            // update the step bound
            if (ratio <= 0.25) {
                double tmp = (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;
                if ((0.1 * currentCost >= previousCost) || (tmp < 0.1)) {
                    tmp = 0.1;
                }
                delta = tmp * FastMath.min(delta, 10.0 * lmNorm);
                lmPar /= tmp;
            } else if ((lmPar == 0) || (ratio >= 0.75)) {
                delta = 2 * lmNorm;
                lmPar *= 0.5;
            }
            // test for successful iteration.
            if (ratio >= 1.0e-4) {
                // successful iteration, update the norm
                firstIteration = false;
                xNorm = 0;
                for (int k = 0; k < nC; ++k) {
                    double xK = diag[k] * currentPoint[k];
                    xNorm += xK * xK;
                }
                xNorm = FastMath.sqrt(xNorm);
                // tests for convergence.
                if (checker != null && checker.converged(iterationCounter.getCount(), previous, current)) {
                    return new OptimumImpl(current, iterationCounter.getCount(), evaluationCounter.getCount());
                }
            } else {
                // failed iteration, reset the previous values
                currentCost = previousCost;
                for (int j = 0; j < solvedCols; ++j) {
                    int pj = permutation[j];
                    currentPoint[pj] = oldX[pj];
                }
                tmpVec = weightedResidual;
                weightedResidual = oldRes;
                oldRes = tmpVec;
                // Reset ""current"" to previous values.
                current = previous;
            }
            // Default convergence criteria.
            if ((FastMath.abs(actRed) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0) || delta <= parRelativeTolerance * xNorm) {
                return new OptimumImpl(current, iterationCounter.getCount(), evaluationCounter.getCount());
            }
            // tests for termination and stringent tolerances
            if (FastMath.abs(actRed) <= TWO_EPS && preRed <= TWO_EPS && ratio <= 2.0) {
                throw new ConvergenceException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance);
            } else if (delta <= TWO_EPS * xNorm) {
                throw new ConvergenceException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance);
            } else if (maxCosine <= TWO_EPS) {
                throw new ConvergenceException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance);
            }
        }
    }
}","/**
 * {@inheritDoc}
 */
","public Optimum optimize(final LeastSquaresProblem problem) {
            final int nR = problem.getObservationSize();
        final int nC = problem.getParameterSize();
    final double[] currentPoint = problem.getStart().toArray();
        final Incrementor iterationCounter = problem.getIterationCounter();
    final Incrementor evaluationCounter = problem.getEvaluationCounter();
        final ConvergenceChecker<Evaluation> checker = problem.getConvergenceChecker();
        final int solvedCols = FastMath.min(nR, nC);
        double[] lmDir = new double[nC];
        double lmPar = 0;
        double delta = 0;
    double xNorm = 0;
    double[] diag = new double[nC];
    double[] oldX = new double[nC];
    double[] oldRes = new double[nR];
    double[] qtf = new double[nR];
    double[] work1 = new double[nC];
    double[] work2 = new double[nC];
    double[] work3 = new double[nC];
        evaluationCounter.incrementCount();
        Evaluation current = problem.evaluate(new ArrayRealVector(currentPoint, false));
    double[] currentResiduals = current.getResiduals().toArray();
    double currentCost = current.getCost();
        boolean firstIteration = true;
    while (true) {
        iterationCounter.incrementCount();
        final Evaluation previous = current;
                final InternalData internalData = qrDecomposition(current.getJacobian(), solvedCols);
        final double[][] weightedJacobian = internalData.weightedJacobian;
        final int[] permutation = internalData.permutation;
        final double[] diagR = internalData.diagR;
        final double[] jacNorm = internalData.jacNorm;
                double[] weightedResidual = currentResiduals;
        for (int i = 0; i < nR; i++) {
            qtf[i] = weightedResidual[i];
        }
                qTy(qtf, internalData);
                for (int k = 0; k < solvedCols; ++k) {
            int pk = permutation[k];
            weightedJacobian[k][pk] = diagR[pk];
        }
        if (firstIteration) {
                                    xNorm = 0;
            for (int k = 0; k < nC; ++k) {
                double dk = jacNorm[k];
                if (dk == 0) {
                    dk = 1.0;
                }
                double xk = dk * currentPoint[k];
                xNorm += xk * xk;
                diag[k] = dk;
            }
            xNorm = FastMath.sqrt(xNorm);
                        delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);
        }
                double maxCosine = 0;
        if (currentCost != 0) {
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                double s = jacNorm[pj];
                if (s != 0) {
                    double sum = 0;
                    for (int i = 0; i <= j; ++i) {
                        sum += weightedJacobian[i][pj] * qtf[i];
                    }
                    maxCosine = FastMath.max(maxCosine, FastMath.abs(sum) / (s * currentCost));
                }
            }
        }
        if (maxCosine <= orthoTolerance) {
                        return new OptimumImpl(current, evaluationCounter.getCount(), iterationCounter.getCount());
        }
                for (int j = 0; j < nC; ++j) {
            diag[j] = FastMath.max(diag[j], jacNorm[j]);
        }
                for (double ratio = 0; ratio < 1.0e-4; ) {
                        for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                oldX[pj] = currentPoint[pj];
            }
            final double previousCost = currentCost;
            double[] tmpVec = weightedResidual;
            weightedResidual = oldRes;
            oldRes = tmpVec;
                        lmPar = determineLMParameter(qtf, delta, diag, internalData, solvedCols, work1, work2, work3, lmDir, lmPar);
                        double lmNorm = 0;
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                lmDir[pj] = -lmDir[pj];
                currentPoint[pj] = oldX[pj] + lmDir[pj];
                double s = diag[pj] * lmDir[pj];
                lmNorm += s * s;
            }
            lmNorm = FastMath.sqrt(lmNorm);
                        if (firstIteration) {
                delta = FastMath.min(delta, lmNorm);
            }
                        evaluationCounter.incrementCount();
            current = problem.evaluate(new ArrayRealVector(currentPoint, false));
            currentResiduals = current.getResiduals().toArray();
            currentCost = current.getCost();
                        double actRed = -1.0;
            if (0.1 * currentCost < previousCost) {
                double r = currentCost / previousCost;
                actRed = 1.0 - r * r;
            }
                        for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                double dirJ = lmDir[pj];
                work1[j] = 0;
                for (int i = 0; i <= j; ++i) {
                    work1[i] += weightedJacobian[i][pj] * dirJ;
                }
            }
            double coeff1 = 0;
            for (int j = 0; j < solvedCols; ++j) {
                coeff1 += work1[j] * work1[j];
            }
            double pc2 = previousCost * previousCost;
            coeff1 /= pc2;
            double coeff2 = lmPar * lmNorm * lmNorm / pc2;
            double preRed = coeff1 + 2 * coeff2;
            double dirDer = -(coeff1 + coeff2);
                        ratio = (preRed == 0) ? 0 : (actRed / preRed);
                        if (ratio <= 0.25) {
                double tmp = (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;
                if ((0.1 * currentCost >= previousCost) || (tmp < 0.1)) {
                    tmp = 0.1;
                }
                delta = tmp * FastMath.min(delta, 10.0 * lmNorm);
                lmPar /= tmp;
            } else if ((lmPar == 0) || (ratio >= 0.75)) {
                delta = 2 * lmNorm;
                lmPar *= 0.5;
            }
                        if (ratio >= 1.0e-4) {
                                firstIteration = false;
                xNorm = 0;
                for (int k = 0; k < nC; ++k) {
                    double xK = diag[k] * currentPoint[k];
                    xNorm += xK * xK;
                }
                xNorm = FastMath.sqrt(xNorm);
                                if (checker != null && checker.converged(iterationCounter.getCount(), previous, current)) {
                    return new OptimumImpl(current, iterationCounter.getCount(), evaluationCounter.getCount());
                }
            } else {
                                currentCost = previousCost;
                for (int j = 0; j < solvedCols; ++j) {
                    int pj = permutation[j];
                    currentPoint[pj] = oldX[pj];
                }
                tmpVec = weightedResidual;
                weightedResidual = oldRes;
                oldRes = tmpVec;
                                current = previous;
            }
                        if ((FastMath.abs(actRed) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0) || delta <= parRelativeTolerance * xNorm) {
                return new OptimumImpl(current, iterationCounter.getCount(), evaluationCounter.getCount());
            }
                        if (FastMath.abs(actRed) <= TWO_EPS && preRed <= TWO_EPS && ratio <= 2.0) {
                throw new ConvergenceException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance);
            } else if (delta <= TWO_EPS * xNorm) {
                throw new ConvergenceException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance);
            } else if (maxCosine <= TWO_EPS) {
                throw new ConvergenceException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance);
            }
        }
    }
}",7.090909090909091,0.8899521531100476,6.8,1.5,5.416666666666667,7.162698412698411,-1.8639887244538402,2.9166666666666665,-0.02631578947368421,88.18485388104168
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-93_0be7e8f0,1,"@Override
public TreeImpl getChild(String name) {
    NodeStateBuilder childBuilder = builder.getChildBuilder(name);
    if (childBuilder == null) {
        return null;
    } else {
        NodeState childBaseState = baseState == null ? null : baseState.getChildNode(name);
        return new TreeImpl(store, childBaseState, childBuilder, this, name, listener);
    }
}",,"@Override
public TreeImpl getChild(String name) {
    NodeStateBuilder childBuilder = builder.getChildBuilder(name);
    if (childBuilder == null) {
        return null;
    } else {
        NodeState childBaseState = baseState == null ? null : baseState.getChildNode(name);
        return new TreeImpl(store, childBaseState, childBuilder, this, name, listener);
    }
}",-0.18181818181818182,0.05263157894736836,-0.2,-0.5,-0.08333333333333333,-0.03769841269841273,0.18646934460887932,-0.3333333333333333,0.05263157894736841,-0.0595725062383661
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1199_813109d7,3,"public int compareTo(removeTableProperty_result other) {
    if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
    }
    int lastComparison = 0;
    removeTableProperty_result typedOther = (removeTableProperty_result) other;
    lastComparison = Boolean.valueOf(isSetOuch1()).compareTo(typedOther.isSetOuch1());
    if (lastComparison != 0) {
        return lastComparison;
    }
    if (isSetOuch1()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.ouch1, typedOther.ouch1);
        if (lastComparison != 0) {
            return lastComparison;
        }
    }
    lastComparison = Boolean.valueOf(isSetOuch2()).compareTo(typedOther.isSetOuch2());
    if (lastComparison != 0) {
        return lastComparison;
    }
    if (isSetOuch2()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.ouch2, typedOther.ouch2);
        if (lastComparison != 0) {
            return lastComparison;
        }
    }
    return 0;
}",,"public int compareTo(removeTableProperty_result other) {
    if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
    }
    int lastComparison = 0;
    removeTableProperty_result typedOther = (removeTableProperty_result) other;
    lastComparison = Boolean.valueOf(isSetOuch1()).compareTo(typedOther.isSetOuch1());
    if (lastComparison != 0) {
        return lastComparison;
    }
    if (isSetOuch1()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.ouch1, typedOther.ouch1);
        if (lastComparison != 0) {
            return lastComparison;
        }
    }
    lastComparison = Boolean.valueOf(isSetOuch2()).compareTo(typedOther.isSetOuch2());
    if (lastComparison != 0) {
        return lastComparison;
    }
    if (isSetOuch2()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.ouch2, typedOther.ouch2);
        if (lastComparison != 0) {
            return lastComparison;
        }
    }
    return 0;
}",0.6363636363636364,-0.04306220095693795,0.8,0.0,0.5833333333333334,0.2996031746031746,-0.4556730091613809,1.1666666666666667,-0.02631578947368421,0.3821533744806163
wicket,remotes/origin/bugs-dot-jar_WICKET-2057_e2d88568,1,"/**
 *  @see org.apache.wicket.ajax.IAjaxCallDecorator#decorateOnSuccessScript(CharSequence)
 */
public CharSequence decorateOnSuccessScript(CharSequence script) {
    CharSequence s = (delegate == null) ? script : delegate.decorateOnSuccessScript(script);
    return preDecorateOnSuccessScript(s);
}","/**
 *  @see org.apache.wicket.ajax.IAjaxCallDecorator#decorateOnSuccessScript(CharSequence)
 */
","public CharSequence decorateOnSuccessScript(CharSequence script) {
    CharSequence s = (delegate == null) ? script : delegate.decorateOnSuccessScript(script);
    return preDecorateOnSuccessScript(s);
}",-0.45454545454545453,-0.47368421052631593,-0.4,-1.0,-0.25,0.0079365079365079,0.7403805496828751,-0.3333333333333333,2.4210526315789473,-0.11397451634653619
camel,remotes/origin/bugs-dot-jar_CAMEL-5681_78c73502,1,"public Exchange call() throws Exception {
    // the aggregation task to early and pile up too many threads
    if (aggregationTaskSubmitted.compareAndSet(false, true)) {
        // but only submit the task once
        aggregateExecutorService.submit(aggregateOnTheFlyTask);
    }
    if (!running.get()) {
        // do not start processing the task if we are not running
        return subExchange;
    }
    try {
        doProcessParallel(pair);
    } catch (Throwable e) {
        subExchange.setException(e);
    }
    // Decide whether to continue with the multicast or not; similar logic to the Pipeline
    Integer number = getExchangeIndex(subExchange);
    boolean continueProcessing = PipelineHelper.continueProcessing(subExchange, ""Parallel processing failed for number "" + number, LOG);
    if (stopOnException && !continueProcessing) {
        // signal to stop running
        running.set(false);
        // throw caused exception
        if (subExchange.getException() != null) {
            // wrap in exception to explain where it failed
            throw new CamelExchangeException(""Parallel processing failed for number "" + number, subExchange, subExchange.getException());
        }
    }
    LOG.trace(""Parallel processing complete for exchange: {}"", subExchange);
    return subExchange;
}",,"public Exchange call() throws Exception {
        if (aggregationTaskSubmitted.compareAndSet(false, true)) {
                aggregateExecutorService.submit(aggregateOnTheFlyTask);
    }
    if (!running.get()) {
                return subExchange;
    }
    try {
        doProcessParallel(pair);
    } catch (Throwable e) {
        subExchange.setException(e);
    }
        Integer number = getExchangeIndex(subExchange);
    boolean continueProcessing = PipelineHelper.continueProcessing(subExchange, ""Parallel processing failed for number "" + number, LOG);
    if (stopOnException && !continueProcessing) {
                running.set(false);
                if (subExchange.getException() != null) {
                        throw new CamelExchangeException(""Parallel processing failed for number "" + number, subExchange, subExchange.getException());
        }
    }
    LOG.trace(""Parallel processing complete for exchange: {}"", subExchange);
    return subExchange;
}",0.4090909090909091,-0.11483253588516758,0.6,0.0,0.4166666666666667,0.24801587301587297,-0.3403805496828753,0.4166666666666667,-0.02631578947368421,0.27842994876759847
Math,91,1,"/**
 * Compares this object to another based on size.
 * @param object the object to compare to
 * @return -1 if this is less than <tt>object</tt>, +1 if this is greater
 *         than <tt>object</tt>, 0 if they are equal.
 */
public int compareTo(Fraction object) {
    double nOd = doubleValue();
    double dOn = object.doubleValue();
    return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);
}","/**
 * Compares this object to another based on size.
 * @param object the object to compare to
 * @return -1 if this is less than <tt>object</tt>, +1 if this is greater
 *         than <tt>object</tt>, 0 if they are equal.
 */
","public int compareTo(Fraction object) {
    double nOd = doubleValue();
    double dOn = object.doubleValue();
    return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);
}",-0.4090909090909091,-0.49282296650717716,-0.2,-1.0,-0.08333333333333333,0.3412698412698413,0.5740662438336854,-0.3333333333333333,0.868421052631579,-0.025488263803645633
wicket,remotes/origin/bugs-dot-jar_WICKET-428_4a6a573b,3,"public boolean hasNext() {
    return i < size;
}",,"public boolean hasNext() {
    return i < size;
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,1.1099365750528538,-0.5,2.4473684210526314,-0.16279340490885932
Closure,163,1,"/**
 * Processes a NAME node to see if it's a global function declaration.
 * If it is, record it and return true. Otherwise, return false.
 */
private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) {
    Node firstChild = nameNode.getFirstChild();
    if (// Check for a named FUNCTION.
    isGlobalFunctionDeclaration(t, parent) || // Check for a VAR declaration.
    firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) {
        String name = nameNode.getString();
        getNameInfoForName(name, VAR).getDeclarations().add(new GlobalFunction(nameNode, parent, gramps, t.getModule()));
        // so that it's never removed.
        if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) {
            addGlobalUseOfSymbol(name, t.getModule(), VAR);
        }
        return true;
    }
    return false;
}","/**
 * Processes a NAME node to see if it's a global function declaration.
 * If it is, record it and return true. Otherwise, return false.
 */
","private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) {
    Node firstChild = nameNode.getFirstChild();
    if (    isGlobalFunctionDeclaration(t, parent) ||     firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) {
        String name = nameNode.getString();
        getNameInfoForName(name, VAR).getDeclarations().add(new GlobalFunction(nameNode, parent, gramps, t.getModule()));
                if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) {
            addGlobalUseOfSymbol(name, t.getModule(), VAR);
        }
        return true;
    }
    return false;
}",0.0,0.12440191387559799,-0.2,0.0,0.6666666666666666,0.32936507936507936,-0.07033121916842858,0.5,-0.02631578947368421,0.28095180465990094
camel,remotes/origin/bugs-dot-jar_CAMEL-7344_91228815,1,"@Override
public String toString() {
    return String.format(""Endpoint[%s]"", URISupport.sanitizeUri(getEndpointUri()));
}",,"@Override
public String toString() {
    return String.format(""Endpoint[%s]"", URISupport.sanitizeUri(getEndpointUri()));
}",-0.45454545454545453,-0.6028708133971293,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.8314305849189569,-0.25,0.21052631578947367,-0.16279340490885932
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-217_46f62443,1,"@Override
public Collection<Text> getSplits(String tableName, int maxSplits) {
    return Collections.emptyList();
}",,"@Override
public Collection<Text> getSplits(String tableName, int maxSplits) {
    return Collections.emptyList();
}",-0.45454545454545453,-0.6028708133971293,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.8246652572233965,-0.4166666666666667,0.763157894736842,-0.16279340490885932
wicket,remotes/origin/bugs-dot-jar_WICKET-2624_ef880545,1,"/**
 *  @param object
 *  @param value
 *  @param converter
 */
public final void setValue(final Object object, final Object value, PropertyResolverConverter converter) {
    Class type = null;
    if (setMethod != null) {
        type = getMethod.getReturnType();
    } else if (field != null) {
        type = field.getType();
    }
    Object converted = null;
    if (type != null) {
        converted = converter.convert(value, getMethod.getReturnType());
        if (converted == null) {
            if (value != null) {
                throw new ConversionException(""Can't convert value: "" + value + "" to class: "" + getMethod.getReturnType() + "" for setting it on "" + object);
            } else if (getMethod.getReturnType().isPrimitive()) {
                throw new ConversionException(""Can't convert null value to a primitive class: "" + getMethod.getReturnType() + "" for setting it on "" + object);
            }
        }
    }
    if (setMethod != null) {
        try {
            setMethod.invoke(object, new Object[] { converted });
        } catch (InvocationTargetException ex) {
            throw new WicketRuntimeException(""Error calling method: "" + setMethod + "" on object: "" + object, ex.getCause());
        } catch (Exception ex) {
            throw new WicketRuntimeException(""Error calling method: "" + setMethod + "" on object: "" + object, ex);
        }
    } else if (field != null) {
        try {
            field.set(object, converted);
        } catch (Exception ex) {
            throw new WicketRuntimeException(""Error setting field: "" + field + "" on object: "" + object, ex);
        }
    } else {
        throw new WicketRuntimeException(""no set method defined for value: "" + value + "" on object: "" + object + "" while respective getMethod being "" + getMethod.getName());
    }
}","/**
 *  @param object
 *  @param value
 *  @param converter
 */
","public final void setValue(final Object object, final Object value, PropertyResolverConverter converter) {
    Class type = null;
    if (setMethod != null) {
        type = getMethod.getReturnType();
    } else if (field != null) {
        type = field.getType();
    }
    Object converted = null;
    if (type != null) {
        converted = converter.convert(value, getMethod.getReturnType());
        if (converted == null) {
            if (value != null) {
                throw new ConversionException(""Can't convert value: "" + value + "" to class: "" + getMethod.getReturnType() + "" for setting it on "" + object);
            } else if (getMethod.getReturnType().isPrimitive()) {
                throw new ConversionException(""Can't convert null value to a primitive class: "" + getMethod.getReturnType() + "" for setting it on "" + object);
            }
        }
    }
    if (setMethod != null) {
        try {
            setMethod.invoke(object, new Object[] { converted });
        } catch (InvocationTargetException ex) {
            throw new WicketRuntimeException(""Error calling method: "" + setMethod + "" on object: "" + object, ex.getCause());
        } catch (Exception ex) {
            throw new WicketRuntimeException(""Error calling method: "" + setMethod + "" on object: "" + object, ex);
        }
    } else if (field != null) {
        try {
            field.set(object, converted);
        } catch (Exception ex) {
            throw new WicketRuntimeException(""Error setting field: "" + field + "" on object: "" + object, ex);
        }
    } else {
        throw new WicketRuntimeException(""no set method defined for value: "" + value + "" on object: "" + object + "" while respective getMethod being "" + getMethod.getName());
    }
}",1.0,0.44976076555023925,2.8,1.0,0.75,0.7261904761904762,-0.718675123326286,0.5,-0.02631578947368421,1.416091238625427
commons-math,remotes/origin/bugs-dot-jar_MATH-848_ad252a8c,1,"/**
 * Transform original matrix to Schur form.
 * @throws MaxCountExceededException if the transformation does not converge
 */
private void transform() {
    final int n = matrixT.length;
    // compute matrix norm
    final double norm = getNorm();
    // shift information
    final ShiftInfo shift = new ShiftInfo();
    // Outer loop over eigenvalue index
    int iteration = 0;
    int idx = n - 1;
    while (idx >= 0) {
        // Look for single small sub-diagonal element
        final int l = findSmallSubDiagonalElement(idx, norm);
        // Check for convergence
        if (l == idx) {
            // One root found
            matrixT[idx][idx] = matrixT[idx][idx] + shift.exShift;
            idx--;
            iteration = 0;
        } else if (l == idx - 1) {
            // Two roots found
            shift.w = matrixT[idx][idx - 1] * matrixT[idx - 1][idx];
            double p = (matrixT[idx - 1][idx - 1] - matrixT[idx][idx]) / 2.0;
            double q = p * p + shift.w;
            double z = FastMath.sqrt(FastMath.abs(q));
            matrixT[idx][idx] = matrixT[idx][idx] + shift.exShift;
            matrixT[idx - 1][idx - 1] = matrixT[idx - 1][idx - 1] + shift.exShift;
            shift.x = matrixT[idx][idx];
            if (q >= 0) {
                if (p >= 0) {
                    z = p + z;
                } else {
                    z = p - z;
                }
                shift.x = matrixT[idx][idx - 1];
                double s = FastMath.abs(shift.x) + FastMath.abs(z);
                p = shift.x / s;
                q = z / s;
                double r = FastMath.sqrt(p * p + q * q);
                p = p / r;
                q = q / r;
                // Row modification
                for (int j = idx - 1; j < n; j++) {
                    z = matrixT[idx - 1][j];
                    matrixT[idx - 1][j] = q * z + p * matrixT[idx][j];
                    matrixT[idx][j] = q * matrixT[idx][j] - p * z;
                }
                // Column modification
                for (int i = 0; i <= idx; i++) {
                    z = matrixT[i][idx - 1];
                    matrixT[i][idx - 1] = q * z + p * matrixT[i][idx];
                    matrixT[i][idx] = q * matrixT[i][idx] - p * z;
                }
                // Accumulate transformations
                for (int i = 0; i <= n - 1; i++) {
                    z = matrixP[i][idx - 1];
                    matrixP[i][idx - 1] = q * z + p * matrixP[i][idx];
                    matrixP[i][idx] = q * matrixP[i][idx] - p * z;
                }
            }
            idx -= 2;
            iteration = 0;
        } else {
            // No convergence yet
            computeShift(l, idx, iteration, shift);
            // stop transformation after too many iterations
            if (++iteration > MAX_ITERATIONS) {
                throw new MaxCountExceededException(LocalizedFormats.CONVERGENCE_FAILED, MAX_ITERATIONS);
            }
            // Look for two consecutive small sub-diagonal elements
            int m = idx - 2;
            // the initial houseHolder vector for the QR step
            final double[] hVec = new double[3];
            while (m >= l) {
                double z = matrixT[m][m];
                hVec[2] = shift.x - z;
                double s = shift.y - z;
                hVec[0] = (hVec[2] * s - shift.w) / matrixT[m + 1][m] + matrixT[m][m + 1];
                hVec[1] = matrixT[m + 1][m + 1] - z - hVec[2] - s;
                hVec[2] = matrixT[m + 2][m + 1];
                s = FastMath.abs(hVec[0]) + FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]);
                if (m == l) {
                    break;
                }
                for (int i = 0; i < hVec.length; i++) {
                    hVec[i] /= s;
                }
                final double lhs = FastMath.abs(matrixT[m][m - 1]) * (FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]));
                final double rhs = FastMath.abs(hVec[0]) * (FastMath.abs(matrixT[m - 1][m - 1]) + FastMath.abs(z) + FastMath.abs(matrixT[m + 1][m + 1]));
                if (lhs < epsilon * rhs) {
                    break;
                }
                m--;
            }
            performDoubleQRStep(l, m, idx, shift, hVec);
        }
    }
}","/**
 * Transform original matrix to Schur form.
 * @throws MaxCountExceededException if the transformation does not converge
 */
","private void transform() {
    final int n = matrixT.length;
        final double norm = getNorm();
        final ShiftInfo shift = new ShiftInfo();
        int iteration = 0;
    int idx = n - 1;
    while (idx >= 0) {
                final int l = findSmallSubDiagonalElement(idx, norm);
                if (l == idx) {
                        matrixT[idx][idx] = matrixT[idx][idx] + shift.exShift;
            idx--;
            iteration = 0;
        } else if (l == idx - 1) {
                        shift.w = matrixT[idx][idx - 1] * matrixT[idx - 1][idx];
            double p = (matrixT[idx - 1][idx - 1] - matrixT[idx][idx]) / 2.0;
            double q = p * p + shift.w;
            double z = FastMath.sqrt(FastMath.abs(q));
            matrixT[idx][idx] = matrixT[idx][idx] + shift.exShift;
            matrixT[idx - 1][idx - 1] = matrixT[idx - 1][idx - 1] + shift.exShift;
            shift.x = matrixT[idx][idx];
            if (q >= 0) {
                if (p >= 0) {
                    z = p + z;
                } else {
                    z = p - z;
                }
                shift.x = matrixT[idx][idx - 1];
                double s = FastMath.abs(shift.x) + FastMath.abs(z);
                p = shift.x / s;
                q = z / s;
                double r = FastMath.sqrt(p * p + q * q);
                p = p / r;
                q = q / r;
                                for (int j = idx - 1; j < n; j++) {
                    z = matrixT[idx - 1][j];
                    matrixT[idx - 1][j] = q * z + p * matrixT[idx][j];
                    matrixT[idx][j] = q * matrixT[idx][j] - p * z;
                }
                                for (int i = 0; i <= idx; i++) {
                    z = matrixT[i][idx - 1];
                    matrixT[i][idx - 1] = q * z + p * matrixT[i][idx];
                    matrixT[i][idx] = q * matrixT[i][idx] - p * z;
                }
                                for (int i = 0; i <= n - 1; i++) {
                    z = matrixP[i][idx - 1];
                    matrixP[i][idx - 1] = q * z + p * matrixP[i][idx];
                    matrixP[i][idx] = q * matrixP[i][idx] - p * z;
                }
            }
            idx -= 2;
            iteration = 0;
        } else {
                        computeShift(l, idx, iteration, shift);
                        if (++iteration > MAX_ITERATIONS) {
                throw new MaxCountExceededException(LocalizedFormats.CONVERGENCE_FAILED, MAX_ITERATIONS);
            }
                        int m = idx - 2;
                        final double[] hVec = new double[3];
            while (m >= l) {
                double z = matrixT[m][m];
                hVec[2] = shift.x - z;
                double s = shift.y - z;
                hVec[0] = (hVec[2] * s - shift.w) / matrixT[m + 1][m] + matrixT[m][m + 1];
                hVec[1] = matrixT[m + 1][m + 1] - z - hVec[2] - s;
                hVec[2] = matrixT[m + 2][m + 1];
                s = FastMath.abs(hVec[0]) + FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]);
                if (m == l) {
                    break;
                }
                for (int i = 0; i < hVec.length; i++) {
                    hVec[i] /= s;
                }
                final double lhs = FastMath.abs(matrixT[m][m - 1]) * (FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]));
                final double rhs = FastMath.abs(hVec[0]) * (FastMath.abs(matrixT[m - 1][m - 1]) + FastMath.abs(z) + FastMath.abs(matrixT[m + 1][m + 1]));
                if (lhs < epsilon * rhs) {
                    break;
                }
                m--;
            }
            performDoubleQRStep(l, m, idx, shift, hVec);
        }
    }
}",3.1363636363636362,0.9138755980861245,2.6,1.5,1.75,11.156746031746032,-1.3252995066948552,1.0833333333333333,-0.02631578947368421,80.75962033851418
Math,77,1,"/**
 * {@inheritDoc}
 */
@Override
public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","/**
 * {@inheritDoc}
 */
","@Override
public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}",-0.2727272727272727,-0.16267942583732073,-0.4,-0.5,-0.4166666666666667,-0.03373015873015876,0.4178999295278365,-0.3333333333333333,2.1842105263157894,-0.11760285380036076
commons-math,remotes/origin/bugs-dot-jar_MATH-904_6844aba9,1,"/**
 * Power function.  Compute x^y.
 *
 * @param x   a double
 * @param y   a double
 * @return double
 */
public static double pow(double x, double y) {
    final double[] lns = new double[2];
    if (y == 0.0) {
        return 1.0;
    }
    if (x != x) {
        // X is NaN
        return x;
    }
    if (x == 0) {
        long bits = Double.doubleToLongBits(x);
        if ((bits & 0x8000000000000000L) != 0) {
            // -zero
            long yi = (long) y;
            if (y < 0 && y == yi && (yi & 1) == 1) {
                return Double.NEGATIVE_INFINITY;
            }
            if (y > 0 && y == yi && (yi & 1) == 1) {
                return -0.0;
            }
        }
        if (y < 0) {
            return Double.POSITIVE_INFINITY;
        }
        if (y > 0) {
            return 0.0;
        }
        return Double.NaN;
    }
    if (x == Double.POSITIVE_INFINITY) {
        if (y != y) {
            // y is NaN
            return y;
        }
        if (y < 0.0) {
            return 0.0;
        } else {
            return Double.POSITIVE_INFINITY;
        }
    }
    if (y == Double.POSITIVE_INFINITY) {
        if (x * x == 1.0) {
            return Double.NaN;
        }
        if (x * x > 1.0) {
            return Double.POSITIVE_INFINITY;
        } else {
            return 0.0;
        }
    }
    if (x == Double.NEGATIVE_INFINITY) {
        if (y != y) {
            // y is NaN
            return y;
        }
        if (y < 0) {
            long yi = (long) y;
            if (y == yi && (yi & 1) == 1) {
                return -0.0;
            }
            return 0.0;
        }
        if (y > 0) {
            long yi = (long) y;
            if (y == yi && (yi & 1) == 1) {
                return Double.NEGATIVE_INFINITY;
            }
            return Double.POSITIVE_INFINITY;
        }
    }
    if (y == Double.NEGATIVE_INFINITY) {
        if (x * x == 1.0) {
            return Double.NaN;
        }
        if (x * x < 1.0) {
            return Double.POSITIVE_INFINITY;
        } else {
            return 0.0;
        }
    }
    /* Handle special case x<0 */
    if (x < 0) {
        // y is an even integer in this case
        if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {
            return pow(-x, y);
        }
        if (y == (long) y) {
            // If y is an integer
            return ((long) y & 1) == 0 ? pow(-x, y) : -pow(-x, y);
        } else {
            return Double.NaN;
        }
    }
    /* Split y into ya and yb such that y = ya+yb */
    double ya;
    double yb;
    if (y < 8e298 && y > -8e298) {
        double tmp1 = y * HEX_40000000;
        ya = y + tmp1 - tmp1;
        yb = y - ya;
    } else {
        double tmp1 = y * 9.31322574615478515625E-10;
        double tmp2 = tmp1 * 9.31322574615478515625E-10;
        ya = (tmp1 + tmp2 - tmp1) * HEX_40000000 * HEX_40000000;
        yb = y - ya;
    }
    /* Compute ln(x) */
    final double lores = log(x, lns);
    if (Double.isInfinite(lores)) {
        // don't allow this to be converted to NaN
        return lores;
    }
    double lna = lns[0];
    double lnb = lns[1];
    /* resplit lns */
    double tmp1 = lna * HEX_40000000;
    double tmp2 = lna + tmp1 - tmp1;
    lnb += lna - tmp2;
    lna = tmp2;
    // y*ln(x) = (aa+ab)
    final double aa = lna * ya;
    final double ab = lna * yb + lnb * ya + lnb * yb;
    lna = aa + ab;
    lnb = -(lna - aa - ab);
    double z = 1.0 / 120.0;
    z = z * lnb + (1.0 / 24.0);
    z = z * lnb + (1.0 / 6.0);
    z = z * lnb + 0.5;
    z = z * lnb + 1.0;
    z = z * lnb;
    final double result = exp(lna, z, null);
    // result = result + result * z;
    return result;
}","/**
 * Power function.  Compute x^y.
 *
 * @param x   a double
 * @param y   a double
 * @return double
 */
","public static double pow(double x, double y) {
    final double[] lns = new double[2];
    if (y == 0.0) {
        return 1.0;
    }
    if (x != x) {
                return x;
    }
    if (x == 0) {
        long bits = Double.doubleToLongBits(x);
        if ((bits & 0x8000000000000000L) != 0) {
                        long yi = (long) y;
            if (y < 0 && y == yi && (yi & 1) == 1) {
                return Double.NEGATIVE_INFINITY;
            }
            if (y > 0 && y == yi && (yi & 1) == 1) {
                return -0.0;
            }
        }
        if (y < 0) {
            return Double.POSITIVE_INFINITY;
        }
        if (y > 0) {
            return 0.0;
        }
        return Double.NaN;
    }
    if (x == Double.POSITIVE_INFINITY) {
        if (y != y) {
                        return y;
        }
        if (y < 0.0) {
            return 0.0;
        } else {
            return Double.POSITIVE_INFINITY;
        }
    }
    if (y == Double.POSITIVE_INFINITY) {
        if (x * x == 1.0) {
            return Double.NaN;
        }
        if (x * x > 1.0) {
            return Double.POSITIVE_INFINITY;
        } else {
            return 0.0;
        }
    }
    if (x == Double.NEGATIVE_INFINITY) {
        if (y != y) {
                        return y;
        }
        if (y < 0) {
            long yi = (long) y;
            if (y == yi && (yi & 1) == 1) {
                return -0.0;
            }
            return 0.0;
        }
        if (y > 0) {
            long yi = (long) y;
            if (y == yi && (yi & 1) == 1) {
                return Double.NEGATIVE_INFINITY;
            }
            return Double.POSITIVE_INFINITY;
        }
    }
    if (y == Double.NEGATIVE_INFINITY) {
        if (x * x == 1.0) {
            return Double.NaN;
        }
        if (x * x < 1.0) {
            return Double.POSITIVE_INFINITY;
        } else {
            return 0.0;
        }
    }
        if (x < 0) {
                if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {
            return pow(-x, y);
        }
        if (y == (long) y) {
                        return ((long) y & 1) == 0 ? pow(-x, y) : -pow(-x, y);
        } else {
            return Double.NaN;
        }
    }
        double ya;
    double yb;
    if (y < 8e298 && y > -8e298) {
        double tmp1 = y * HEX_40000000;
        ya = y + tmp1 - tmp1;
        yb = y - ya;
    } else {
        double tmp1 = y * 9.31322574615478515625E-10;
        double tmp2 = tmp1 * 9.31322574615478515625E-10;
        ya = (tmp1 + tmp2 - tmp1) * HEX_40000000 * HEX_40000000;
        yb = y - ya;
    }
        final double lores = log(x, lns);
    if (Double.isInfinite(lores)) {
                return lores;
    }
    double lna = lns[0];
    double lnb = lns[1];
        double tmp1 = lna * HEX_40000000;
    double tmp2 = lna + tmp1 - tmp1;
    lnb += lna - tmp2;
    lna = tmp2;
        final double aa = lna * ya;
    final double ab = lna * yb + lnb * ya + lnb * yb;
    lna = aa + ab;
    lnb = -(lna - aa - ab);
    double z = 1.0 / 120.0;
    z = z * lnb + (1.0 / 24.0);
    z = z * lnb + (1.0 / 6.0);
    z = z * lnb + 0.5;
    z = z * lnb + 1.0;
    z = z * lnb;
    final double result = exp(lna, z, null);
        return result;
}",4.863636363636363,0.25837320574162664,5.2,0.5,3.1666666666666665,7.900793650793649,-1.5319238900634244,0.08333333333333333,-0.02631578947368421,41.21708591944583
wicket,remotes/origin/bugs-dot-jar_WICKET-4441_54c86ebb,1,"/**
 *  Looks up a page by id from the {@link IPageStore}. <br/>
 *  If {@linkplain #pageClass} is specified then compares it against the stored instance class
 *  and returns the found instance only if they match.
 *
 *  @param pageId
 *             the id of the page to look for.
 *  @return the found page instance by id.
 */
private IRequestablePage getStoredPage(final int pageId) {
    IRequestablePage storedPageInstance = getPageSource().getPageInstance(pageId);
    if (storedPageInstance != null) {
        if (pageClass == null || pageClass.equals(storedPageInstance.getClass())) {
            pageInstance = storedPageInstance;
            pageInstanceIsFresh = false;
            if (renderCount != null && pageInstance.getRenderCount() != renderCount) {
                throw new StalePageException(pageInstance);
            }
        } else {
            // the found page class doesn't match the requested one
            storedPageInstance = null;
        }
    }
    return storedPageInstance;
}","/**
 *  Looks up a page by id from the {@link IPageStore}. <br/>
 *  If {@linkplain #pageClass} is specified then compares it against the stored instance class
 *  and returns the found instance only if they match.
 *
 *  @param pageId
 *             the id of the page to look for.
 *  @return the found page instance by id.
 */
","private IRequestablePage getStoredPage(final int pageId) {
    IRequestablePage storedPageInstance = getPageSource().getPageInstance(pageId);
    if (storedPageInstance != null) {
        if (pageClass == null || pageClass.equals(storedPageInstance.getClass())) {
            pageInstance = storedPageInstance;
            pageInstanceIsFresh = false;
            if (renderCount != null && pageInstance.getRenderCount() != renderCount) {
                throw new StalePageException(pageInstance);
            }
        } else {
                        storedPageInstance = null;
        }
    }
    return storedPageInstance;
}",0.045454545454545456,0.8325358851674642,0.2,0.5,0.5,0.3591269841269841,-0.05510923185341784,-0.08333333333333333,0.10526315789473684,0.1446332762803778
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2430_be3a9114,1,"@Override
public boolean propertyAdded(PropertyState after) {
    if (!loader.isRunning()) {
        return false;
    }
    builder.setProperty(binaryCheck(after));
    return true;
}",,"@Override
public boolean propertyAdded(PropertyState after) {
    if (!loader.isRunning()) {
        return false;
    }
    builder.setProperty(binaryCheck(after));
    return true;
}",-0.2727272727272727,-0.16267942583732073,-0.4,-0.5,-0.25,-0.3650793650793651,0.4365045806906271,-0.25,1.263157894736842,-0.16279340490885932
Cli,15,1,"public List getValues(final Option option, List defaultValues) {
    // initialize the return list
    List valueList = (List) values.get(option);
    // grab the correct default values
    if ((valueList == null) || valueList.isEmpty()) {
        valueList = defaultValues;
    }
    // augment the list with the default values
    if ((valueList == null) || valueList.isEmpty()) {
        valueList = (List) this.defaultValues.get(option);
    }
    return valueList == null ? Collections.EMPTY_LIST : valueList;
}",,"public List getValues(final Option option, List defaultValues) {
        List valueList = (List) values.get(option);
        if ((valueList == null) || valueList.isEmpty()) {
        valueList = defaultValues;
    }
        if ((valueList == null) || valueList.isEmpty()) {
        valueList = (List) this.defaultValues.get(option);
    }
    return valueList == null ? Collections.EMPTY_LIST : valueList;
}",-0.18181818181818182,-0.2200956937799045,0.0,-0.5,0.16666666666666666,0.13888888888888887,0.15264270613107836,-0.16666666666666666,0.2894736842105263,0.029139652956668555
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-1008_0c20bfd8,1,"/**
 * Finds matches in a physical directory on a filesystem.  Examines all
 * files within a directory - if the File object is not a directory, and ends with <i>.class</i>
 * the file is loaded and tested to see if it is acceptable according to the Test.  Operates
 * recursively to find classes within a folder structure matching the package structure.
 *
 * @param test a Test used to filter the classes that are discovered
 * @param parent the package name up to this directory in the package hierarchy.  E.g. if
 *        /classes is in the classpath and we wish to examine files in /classes/org/apache then
 *        the values of <i>parent</i> would be <i>org/apache</i>
 * @param location a File object representing a directory
 */
private void loadImplementationsInDirectory(final Test test, final String parent, final File location) {
    final File[] files = location.listFiles();
    if (files == null) {
        return;
    }
    StringBuilder builder;
    for (final File file : files) {
        builder = new StringBuilder();
        builder.append(parent).append('/').append(file.getName());
        final String packageOrClass = parent == null ? file.getName() : builder.toString();
        if (file.isDirectory()) {
            loadImplementationsInDirectory(test, packageOrClass, file);
        } else if (isTestApplicable(test, file.getName())) {
            addIfMatching(test, packageOrClass);
        }
    }
}","/**
 * Finds matches in a physical directory on a filesystem.  Examines all
 * files within a directory - if the File object is not a directory, and ends with <i>.class</i>
 * the file is loaded and tested to see if it is acceptable according to the Test.  Operates
 * recursively to find classes within a folder structure matching the package structure.
 *
 * @param test a Test used to filter the classes that are discovered
 * @param parent the package name up to this directory in the package hierarchy.  E.g. if
 *        /classes is in the classpath and we wish to examine files in /classes/org/apache then
 *        the values of <i>parent</i> would be <i>org/apache</i>
 * @param location a File object representing a directory
 */
","private void loadImplementationsInDirectory(final Test test, final String parent, final File location) {
    final File[] files = location.listFiles();
    if (files == null) {
        return;
    }
    StringBuilder builder;
    for (final File file : files) {
        builder = new StringBuilder();
        builder.append(parent).append('/').append(file.getName());
        final String packageOrClass = parent == null ? file.getName() : builder.toString();
        if (file.isDirectory()) {
            loadImplementationsInDirectory(test, packageOrClass, file);
        } else if (isTestApplicable(test, file.getName())) {
            addIfMatching(test, packageOrClass);
        }
    }
}",0.13636363636363635,0.1913875598086124,0.4,0.5,0.4166666666666667,0.0853174603174603,-0.16560958421423533,0.5,-0.02631578947368421,0.101434391982619
Closure,134,2,"/**
 * Find the function that's being overridden on this type, if any.
 */
private FunctionType findOverriddenFunction(ObjectType ownerType, String propName) {
    // First, check to see if the property is implemented
    // on a superclass.
    JSType propType = ownerType.getPropertyType(propName);
    if (propType instanceof FunctionType) {
        return (FunctionType) propType;
    }
    return null;
}","/**
 * Find the function that's being overridden on this type, if any.
 */
","private FunctionType findOverriddenFunction(ObjectType ownerType, String propName) {
            JSType propType = ownerType.getPropertyType(propName);
    if (propType instanceof FunctionType) {
        return (FunctionType) propType;
    }
    return null;
}",-0.3181818181818182,-0.20574162679425848,-0.4,-0.5,-0.25,-0.3650793650793651,0.465257223396758,-0.4166666666666667,2.289473684210526,-0.16279340490885932
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1199_813109d7,3,"public void getResult() throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException {
    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
        throw new IllegalStateException(""Method call not finished!"");
    }
    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
    (new Client(prot)).recv_setTableProperty();
}",,"public void getResult() throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException {
    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
        throw new IllegalStateException(""Method call not finished!"");
    }
    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
    (new Client(prot)).recv_setTableProperty();
}",-0.2727272727272727,-0.2822966507177035,-0.2,-0.5,-0.25,-0.053571428571428575,0.21099365750528534,0.0,-0.02631578947368421,0.004289921220817992
wicket,remotes/origin/bugs-dot-jar_WICKET-4309_b4274415,1,"/**
 *  Convert to object types, returning null if text is null.
 *
 *  @return converted
 *  @throws StringValueConversionException
 */
public final Double toOptionalDouble() throws StringValueConversionException {
    return (text == null) ? null : toDoubleObject();
}","/**
 *  Convert to object types, returning null if text is null.
 *
 *  @return converted
 *  @throws StringValueConversionException
 */
","public final Double toOptionalDouble() throws StringValueConversionException {
    return (text == null) ? null : toDoubleObject();
}",-0.5,-0.5263157894736844,-0.4,-1.0,-0.25,-0.3650793650793651,0.9797040169133189,-0.4166666666666667,2.6052631578947367,-0.16279340490885932
flink,remotes/origin/bugs-dot-jar_FLINK-1820_39d526e6,0,"/**
 *  Static utility to parse a field of type long from a byte sequence that represents text characters
 *  (such as when read from a file stream).
 *
 *  @param bytes The bytes containing the text data that should be parsed.
 *  @param startPos The offset to start the parsing.
 *  @param length The length of the byte sequence (counting from the offset).
 *  @param delimiter The delimiter that terminates the field.
 *
 *  @return The parsed value.
 *
 *  @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.
 */
public static final long parseField(byte[] bytes, int startPos, int length, char delimiter) {
    if (length <= 0) {
        throw new NumberFormatException(""Invalid input: Empty string"");
    }
    long val = 0;
    boolean neg = false;
    if (bytes[startPos] == '-') {
        neg = true;
        startPos++;
        length--;
        if (length == 0 || bytes[startPos] == delimiter) {
            throw new NumberFormatException(""Orphaned minus sign."");
        }
    }
    for (; length > 0; startPos++, length--) {
        if (bytes[startPos] == delimiter) {
            return neg ? -val : val;
        }
        if (bytes[startPos] < 48 || bytes[startPos] > 57) {
            throw new NumberFormatException(""Invalid character."");
        }
        val *= 10;
        val += bytes[startPos] - 48;
        // check for overflow / underflow
        if (val < 0) {
            // this is an overflow/underflow, unless we hit exactly the Long.MIN_VALUE
            if (neg && val == Long.MIN_VALUE) {
                if (length == 1 || bytes[startPos + 1] == delimiter) {
                    return Long.MIN_VALUE;
                } else {
                    throw new NumberFormatException(""value overflow"");
                }
            } else {
                throw new NumberFormatException(""value overflow"");
            }
        }
    }
    return neg ? -val : val;
}","/**
 *  Static utility to parse a field of type long from a byte sequence that represents text characters
 *  (such as when read from a file stream).
 *
 *  @param bytes The bytes containing the text data that should be parsed.
 *  @param startPos The offset to start the parsing.
 *  @param length The length of the byte sequence (counting from the offset).
 *  @param delimiter The delimiter that terminates the field.
 *
 *  @return The parsed value.
 *
 *  @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.
 */
","public static final long parseField(byte[] bytes, int startPos, int length, char delimiter) {
    if (length <= 0) {
        throw new NumberFormatException(""Invalid input: Empty string"");
    }
    long val = 0;
    boolean neg = false;
    if (bytes[startPos] == '-') {
        neg = true;
        startPos++;
        length--;
        if (length == 0 || bytes[startPos] == delimiter) {
            throw new NumberFormatException(""Orphaned minus sign."");
        }
    }
    for (; length > 0; startPos++, length--) {
        if (bytes[startPos] == delimiter) {
            return neg ? -val : val;
        }
        if (bytes[startPos] < 48 || bytes[startPos] > 57) {
            throw new NumberFormatException(""Invalid character."");
        }
        val *= 10;
        val += bytes[startPos] - 48;
                if (val < 0) {
                        if (neg && val == Long.MIN_VALUE) {
                if (length == 1 || bytes[startPos + 1] == delimiter) {
                    return Long.MIN_VALUE;
                } else {
                    throw new NumberFormatException(""value overflow"");
                }
            } else {
                throw new NumberFormatException(""value overflow"");
            }
        }
    }
    return neg ? -val : val;
}",1.0454545454545454,0.9186602870813397,2.6,1.0,1.1666666666666667,3.4126984126984126,-0.7003523608174769,-0.5,-0.02631578947368421,4.467020510249361
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2528_239de7b8,1,"private void removeGarbage() {
    if (garbage.isEmpty()) {
        return;
    } else if (main == null) {
        main = new UpdateOp(id, false);
    }
    for (Map.Entry<String, Set<Revision>> entry : garbage.entrySet()) {
        for (Revision r : entry.getValue()) {
            main.removeMapEntry(entry.getKey(), r);
            NodeDocument.removeCommitRoot(main, r);
            NodeDocument.removeRevision(main, r);
        }
    }
}",,"private void removeGarbage() {
    if (garbage.isEmpty()) {
        return;
    } else if (main == null) {
        main = new UpdateOp(id, false);
    }
    for (Map.Entry<String, Set<Revision>> entry : garbage.entrySet()) {
        for (Revision r : entry.getValue()) {
            main.removeMapEntry(entry.getKey(), r);
            NodeDocument.removeCommitRoot(main, r);
            NodeDocument.removeRevision(main, r);
        }
    }
}",0.0,0.4449760765550238,0.2,0.0,-0.08333333333333333,-0.0634920634920635,-0.014235377026074568,0.08333333333333333,-0.02631578947368421,-0.04224684912086581
commons-math,remotes/origin/bugs-dot-jar_MATH-393_d4b02f6a,3,"/**
 * Get the result of the last run of the optimizer.
 *
 * @return the last result.
 * @throws IllegalStateException if there is no result available, either
 * because no result was yet computed or the last attempt failed.
 */
double getResult();","/**
 * Get the result of the last run of the optimizer.
 *
 * @return the last result.
 * @throws IllegalStateException if there is no result available, either
 * because no result was yet computed or the last attempt failed.
 */
",double getResult();,-0.5909090909090909,-1.4306220095693782,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,1.8696264975334735,-0.5,2.6052631578947367,-0.16279340490885932
wicket,remotes/origin/bugs-dot-jar_WICKET-4520_b91154ea,1,"/**
 *  THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT OVERRIDE OR CALL.
 *
 *  Internal initialization.
 */
protected void internalInit() {
    settingsAccessible = true;
    IPageSettings pageSettings = getPageSettings();
    // Install default component resolvers
    pageSettings.addComponentResolver(new MarkupInheritanceResolver());
    pageSettings.addComponentResolver(new HtmlHeaderResolver());
    pageSettings.addComponentResolver(new WicketLinkTagHandler());
    pageSettings.addComponentResolver(new WicketMessageResolver());
    pageSettings.addComponentResolver(new WicketMessageTagHandler());
    pageSettings.addComponentResolver(new FragmentResolver());
    pageSettings.addComponentResolver(new RelativePathPrefixHandler());
    pageSettings.addComponentResolver(new EnclosureHandler());
    pageSettings.addComponentResolver(new InlineEnclosureHandler());
    pageSettings.addComponentResolver(new WicketContainerResolver());
    // Install button image resource factory
    getResourceSettings().addResourceFactory(""buttonFactory"", new DefaultButtonImageResourceFactory());
    String applicationKey = getApplicationKey();
    applicationKeyToApplication.put(applicationKey, this);
    converterLocator = newConverterLocator();
    setPageManagerProvider(new DefaultPageManagerProvider(this));
    resourceReferenceRegistry = newResourceReferenceRegistry();
    sharedResources = newSharedResources(resourceReferenceRegistry);
    resourceBundles = newResourceBundles(resourceReferenceRegistry);
    // set up default request mapper
    setRootRequestMapper(new SystemMapper(this));
    pageFactory = newPageFactory();
    requestCycleProvider = new DefaultRequestCycleProvider();
    exceptionMapperProvider = new DefaultExceptionMapperProvider();
    // add a request cycle listener that logs each request for the requestlogger.
    getRequestCycleListeners().add(new RequestLoggerRequestCycleListener());
}","/**
 *  THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT OVERRIDE OR CALL.
 *
 *  Internal initialization.
 */
","protected void internalInit() {
    settingsAccessible = true;
    IPageSettings pageSettings = getPageSettings();
        pageSettings.addComponentResolver(new MarkupInheritanceResolver());
    pageSettings.addComponentResolver(new HtmlHeaderResolver());
    pageSettings.addComponentResolver(new WicketLinkTagHandler());
    pageSettings.addComponentResolver(new WicketMessageResolver());
    pageSettings.addComponentResolver(new WicketMessageTagHandler());
    pageSettings.addComponentResolver(new FragmentResolver());
    pageSettings.addComponentResolver(new RelativePathPrefixHandler());
    pageSettings.addComponentResolver(new EnclosureHandler());
    pageSettings.addComponentResolver(new InlineEnclosureHandler());
    pageSettings.addComponentResolver(new WicketContainerResolver());
        getResourceSettings().addResourceFactory(""buttonFactory"", new DefaultButtonImageResourceFactory());
    String applicationKey = getApplicationKey();
    applicationKeyToApplication.put(applicationKey, this);
    converterLocator = newConverterLocator();
    setPageManagerProvider(new DefaultPageManagerProvider(this));
    resourceReferenceRegistry = newResourceReferenceRegistry();
    sharedResources = newSharedResources(resourceReferenceRegistry);
    resourceBundles = newResourceBundles(resourceReferenceRegistry);
        setRootRequestMapper(new SystemMapper(this));
    pageFactory = newPageFactory();
    requestCycleProvider = new DefaultRequestCycleProvider();
    exceptionMapperProvider = new DefaultExceptionMapperProvider();
        getRequestCycleListeners().add(new RequestLoggerRequestCycleListener());
}",0.5909090909090909,-0.9282296650717705,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,-0.42917547568710335,1.5,-0.02631578947368421,-0.16279340490885932
Csv,11,1,"/**
 * Initializes the name to index mapping if the format defines a header.
 *
 * @return null if the format has no header.
 * @throws IOException if there is a problem reading the header or skipping the first record
 */
private Map<String, Integer> initializeHeader() throws IOException {
    Map<String, Integer> hdrMap = null;
    final String[] formatHeader = this.format.getHeader();
    if (formatHeader != null) {
        hdrMap = new LinkedHashMap<String, Integer>();
        String[] headerRecord = null;
        if (formatHeader.length == 0) {
            // read the header from the first line of the file
            final CSVRecord nextRecord = this.nextRecord();
            if (nextRecord != null) {
                headerRecord = nextRecord.values();
            }
        } else {
            if (this.format.getSkipHeaderRecord()) {
                this.nextRecord();
            }
            headerRecord = formatHeader;
        }
        // build the name to index mappings
        if (headerRecord != null) {
            for (int i = 0; i < headerRecord.length; i++) {
                final String header = headerRecord[i];
                final boolean containsHeader = hdrMap.containsKey(header);
                final boolean emptyHeader = header.trim().isEmpty();
                if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {
                    throw new IllegalArgumentException(""The header contains a duplicate name: \"""" + header + ""\"" in "" + Arrays.toString(headerRecord));
                }
                hdrMap.put(header, Integer.valueOf(i));
            }
        }
    }
    return hdrMap;
}","/**
 * Initializes the name to index mapping if the format defines a header.
 *
 * @return null if the format has no header.
 * @throws IOException if there is a problem reading the header or skipping the first record
 */
","private Map<String, Integer> initializeHeader() throws IOException {
    Map<String, Integer> hdrMap = null;
    final String[] formatHeader = this.format.getHeader();
    if (formatHeader != null) {
        hdrMap = new LinkedHashMap<String, Integer>();
        String[] headerRecord = null;
        if (formatHeader.length == 0) {
                        final CSVRecord nextRecord = this.nextRecord();
            if (nextRecord != null) {
                headerRecord = nextRecord.values();
            }
        } else {
            if (this.format.getSkipHeaderRecord()) {
                this.nextRecord();
            }
            headerRecord = formatHeader;
        }
                if (headerRecord != null) {
            for (int i = 0; i < headerRecord.length; i++) {
                final String header = headerRecord[i];
                final boolean containsHeader = hdrMap.containsKey(header);
                final boolean emptyHeader = header.trim().isEmpty();
                if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {
                    throw new IllegalArgumentException(""The header contains a duplicate name: \"""" + header + ""\"" in "" + Arrays.toString(headerRecord));
                }
                hdrMap.put(header, Integer.valueOf(i));
            }
        }
    }
    return hdrMap;
}",0.7727272727272727,1.0382775119617225,1.0,1.0,1.25,1.478174603174603,-0.5746300211416491,0.5,-0.02631578947368421,2.20881151201858
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2799_3979fa8d,1,"@Override
public void readBytes(byte[] b, int o, int n) throws IOException {
    file.readBytes(b, o, n);
}",,"@Override
public void readBytes(byte[] b, int o, int n) throws IOException {
    file.readBytes(b, o, n);
}",-0.45454545454545453,-0.6028708133971293,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.8128259337561663,-0.4166666666666667,0.0,-0.16279340490885932
wicket,remotes/origin/bugs-dot-jar_WICKET-2172_ea4a3f8a,3,"/**
 *  @see IValueMap#getAsDouble(String, double)
 */
public double getAsDouble(String key, double defaultValue) {
    try {
        return getDouble(key, defaultValue);
    } catch (StringValueConversionException ignored) {
        return defaultValue;
    }
}","/**
 *  @see IValueMap#getAsDouble(String, double)
 */
","public double getAsDouble(String key, double defaultValue) {
    try {
        return getDouble(key, defaultValue);
    } catch (StringValueConversionException ignored) {
        return defaultValue;
    }
}",-0.3181818181818182,0.01435406698564584,-0.4,-0.5,-0.4166666666666667,-0.3650793650793651,0.5633544749823818,-0.4166666666666667,2.131578947368421,-0.16279340490885932
flink,remotes/origin/bugs-dot-jar_FLINK-2121_03340919,3,"/**
 *  Enumerate all files in the directory and recursive if enumerateNestedFiles is true.
 *  @return the total length of accepted files.
 */
private long addFilesInDir(Path path, List<FileStatus> files, long length, boolean logExcludedFiles) throws IOException {
    final FileSystem fs = path.getFileSystem();
    for (FileStatus dir : fs.listStatus(path)) {
        if (dir.isDir()) {
            if (acceptFile(dir) && enumerateNestedFiles) {
                length += addFilesInDir(dir.getPath(), files, length, logExcludedFiles);
            } else {
                if (logExcludedFiles && LOG.isDebugEnabled()) {
                    LOG.debug(""Directory "" + dir.getPath().toString() + "" did not pass the file-filter and is excluded."");
                }
            }
        } else {
            if (acceptFile(dir)) {
                files.add(dir);
                length += dir.getLen();
                testForUnsplittable(dir);
            } else {
                if (logExcludedFiles && LOG.isDebugEnabled()) {
                    LOG.debug(""Directory "" + dir.getPath().toString() + "" did not pass the file-filter and is excluded."");
                }
            }
        }
    }
    return length;
}","/**
 *  Enumerate all files in the directory and recursive if enumerateNestedFiles is true.
 *  @return the total length of accepted files.
 */
","private long addFilesInDir(Path path, List<FileStatus> files, long length, boolean logExcludedFiles) throws IOException {
    final FileSystem fs = path.getFileSystem();
    for (FileStatus dir : fs.listStatus(path)) {
        if (dir.isDir()) {
            if (acceptFile(dir) && enumerateNestedFiles) {
                length += addFilesInDir(dir.getPath(), files, length, logExcludedFiles);
            } else {
                if (logExcludedFiles && LOG.isDebugEnabled()) {
                    LOG.debug(""Directory "" + dir.getPath().toString() + "" did not pass the file-filter and is excluded."");
                }
            }
        } else {
            if (acceptFile(dir)) {
                files.add(dir);
                length += dir.getLen();
                testForUnsplittable(dir);
            } else {
                if (logExcludedFiles && LOG.isDebugEnabled()) {
                    LOG.debug(""Directory "" + dir.getPath().toString() + "" did not pass the file-filter and is excluded."");
                }
            }
        }
    }
    return length;
}",0.5,1.3301435406698563,0.6,1.0,0.75,0.5138888888888888,-0.39647639182522887,1.0,-0.02631578947368421,0.5518092702408325
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-843_65390f8c,3,"@Override
public void setLocalityGroups(String tableName, Map<String, Set<Text>> groups) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {
    throw new NotImplementedException();
}",,"@Override
public void setLocalityGroups(String tableName, Map<String, Set<Text>> groups) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {
    throw new NotImplementedException();
}",-0.45454545454545453,-0.6028708133971293,-0.4,-1.0,-0.4166666666666667,-0.3650793650793651,0.7527836504580688,-0.5,0.0,-0.16279340490885932
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-776_dc9f23d9,3,"/**
 * A convenience method for setting the end timestamp accepted by the timestamp filter.
 *
 * @param is
 *          the iterator setting object to configure
 * @param end
 *          the end timestamp (yyyyMMddHHmmssz)
 * @param endInclusive
 *          boolean indicating whether the end is inclusive
 */
public static void setEnd(IteratorSetting is, String end, boolean endInclusive) {
    is.addOption(END, end);
    is.addOption(END_INCL, Boolean.toString(endInclusive));
}","/**
 * A convenience method for setting the end timestamp accepted by the timestamp filter.
 *
 * @param is
 *          the iterator setting object to configure
 * @param end
 *          the end timestamp (yyyyMMddHHmmssz)
 * @param endInclusive
 *          boolean indicating whether the end is inclusive
 */
","public static void setEnd(IteratorSetting is, String end, boolean endInclusive) {
    is.addOption(END, end);
    is.addOption(END_INCL, Boolean.toString(endInclusive));
}",-0.45454545454545453,-0.47368421052631593,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.7355884425651865,-0.25,2.3157894736842106,-0.16279340490885932
flink,remotes/origin/bugs-dot-jar_FLINK-1640_8f321c72,1,"/**
 *  Normalizes a path string.
 *
 *  @param path
 *         the path string to normalize
 *  @return the normalized path string
 */
private String normalizePath(String path) {
    // remove double slashes & backslashes
    path = path.replace(""//"", ""/"");
    path = path.replace(""\\"", ""/"");
    return path;
}","/**
 *  Normalizes a path string.
 *
 *  @param path
 *         the path string to normalize
 *  @return the normalized path string
 */
","private String normalizePath(String path) {
        path = path.replace(""//"", ""/"");
    path = path.replace(""\\"", ""/"");
    return path;
}",-0.4090909090909091,-0.49282296650717716,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.6434108527131782,-0.3333333333333333,2.236842105263158,-0.16279340490885932
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1364_05c89637,1,"@SuppressWarnings(""unchecked"")
@Override
public V get(Object key) {
    return CacheLIRS.this.getUnchecked((K) key);
}",,"@SuppressWarnings(""unchecked"")
@Override
public V get(Object key) {
    return CacheLIRS.this.getUnchecked((K) key);
}",-0.4090909090909091,-0.6650717703349284,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.6899224806201547,-0.4166666666666667,1.526315789473684,-0.16279340490885932
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-4358_74cbba24,1,"@Override
public Iterator<Revision> iterator() {
    final Set<Revision> changes = getValueMap(property).keySet();
    final Set<Integer> clusterIds = Sets.newHashSet();
    for (Revision r : getLocalMap(property).keySet()) {
        clusterIds.add(r.getClusterId());
    }
    for (Range r : getPreviousRanges().values()) {
        if (min.isRevisionNewer(r.high)) {
            clusterIds.add(r.high.getClusterId());
        }
    }
    final Iterator<Revision> unfiltered = changes.iterator();
    return new AbstractIterator<Revision>() {

        @Override
        protected Revision computeNext() {
            while (unfiltered.hasNext()) {
                Revision next = unfiltered.next();
                if (min.isRevisionNewer(next)) {
                    return next;
                } else {
                    // further revisions with this clusterId
                    // are older than min revision
                    clusterIds.remove(next.getClusterId());
                    // no more revisions to check
                    if (clusterIds.isEmpty()) {
                        return endOfData();
                    }
                }
            }
            return endOfData();
        }
    };
}",,"@Override
public Iterator<Revision> iterator() {
    final Set<Revision> changes = getValueMap(property).keySet();
    final Set<Integer> clusterIds = Sets.newHashSet();
    for (Revision r : getLocalMap(property).keySet()) {
        clusterIds.add(r.getClusterId());
    }
    for (Range r : getPreviousRanges().values()) {
        if (min.isRevisionNewer(r.high)) {
            clusterIds.add(r.high.getClusterId());
        }
    }
    final Iterator<Revision> unfiltered = changes.iterator();
    return new AbstractIterator<Revision>() {

        @Override
        protected Revision computeNext() {
            while (unfiltered.hasNext()) {
                Revision next = unfiltered.next();
                if (min.isRevisionNewer(next)) {
                    return next;
                } else {
                                                            clusterIds.remove(next.getClusterId());
                                        if (clusterIds.isEmpty()) {
                        return endOfData();
                    }
                }
            }
            return endOfData();
        }
    };
}",0.7727272727272727,1.7846889952153109,0.6,1.0,0.4166666666666667,-0.3650793650793651,-0.49598308668076097,1.25,-0.02631578947368421,-0.16279340490885932
wicket,remotes/origin/bugs-dot-jar_WICKET-5898_ffdd0864,1,"/**
 *  Search for the child's markup in the associated markup file.
 *
 *  @param parent
 *             The container expected to contain the markup for child
 *  @param child
 *             The child component to find the markup for
 *  @return The markup associated with the child
 */
@Override
public IMarkupFragment getMarkup(final MarkupContainer parent, final Component child) {
    Args.notNull(tagName, ""tagName"");
    IMarkupFragment associatedMarkup = parent.getAssociatedMarkup();
    if (associatedMarkup == null) {
        throw new MarkupNotFoundException(""Failed to find markup file associated. "" + Classes.simpleName(parent.getClass()) + "": "" + parent.toString());
    }
    // Find <wicket:panel>
    IMarkupFragment markup = MarkupUtil.findStartTag(associatedMarkup, tagName);
    if (markup == null) {
        throw new MarkupNotFoundException(""Expected to find <wicket:"" + tagName + ""> in associated markup file. Markup: "" + associatedMarkup.toString());
    }
    // If child == null, than return the markup fragment starting with <wicket:panel>
    if (child == null) {
        return markup;
    }
    // Find the markup for the child component
    associatedMarkup = markup.find(child.getId());
    if (associatedMarkup != null) {
        return associatedMarkup;
    }
    associatedMarkup = searchMarkupInTransparentResolvers(parent, child);
    if (associatedMarkup != null) {
        return associatedMarkup;
    }
    return findMarkupInAssociatedFileHeader(parent, child);
}","/**
 *  Search for the child's markup in the associated markup file.
 *
 *  @param parent
 *             The container expected to contain the markup for child
 *  @param child
 *             The child component to find the markup for
 *  @return The markup associated with the child
 */
","@Override
public IMarkupFragment getMarkup(final MarkupContainer parent, final Component child) {
    Args.notNull(tagName, ""tagName"");
    IMarkupFragment associatedMarkup = parent.getAssociatedMarkup();
    if (associatedMarkup == null) {
        throw new MarkupNotFoundException(""Failed to find markup file associated. "" + Classes.simpleName(parent.getClass()) + "": "" + parent.toString());
    }
        IMarkupFragment markup = MarkupUtil.findStartTag(associatedMarkup, tagName);
    if (markup == null) {
        throw new MarkupNotFoundException(""Expected to find <wicket:"" + tagName + ""> in associated markup file. Markup: "" + associatedMarkup.toString());
    }
        if (child == null) {
        return markup;
    }
        associatedMarkup = markup.find(child.getId());
    if (associatedMarkup != null) {
        return associatedMarkup;
    }
    associatedMarkup = searchMarkupInTransparentResolvers(parent, child);
    if (associatedMarkup != null) {
        return associatedMarkup;
    }
    return findMarkupInAssociatedFileHeader(parent, child);
}",0.45454545454545453,-0.33492822966507185,0.8,-0.5,0.25,0.45436507936507936,-0.3928118393234672,0.4166666666666667,-0.02631578947368421,0.5449214225203574
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1655_c91bfa54,1,"@Override
public boolean apply(DataIdentifier input) {
    try {
        DataRecord dr = delegate.getRecord(input);
        if (dr != null && dr.getLastModified() < maxLastModifiedTime) {
            return true;
        }
    } catch (DataStoreException e) {
        log.warn(""Error occurred while fetching DataRecord for identifier {}"", input, e);
    }
    return false;
}",,"@Override
public boolean apply(DataIdentifier input) {
    try {
        DataRecord dr = delegate.getRecord(input);
        if (dr != null && dr.getLastModified() < maxLastModifiedTime) {
            return true;
        }
    } catch (DataStoreException e) {
        log.warn(""Error occurred while fetching DataRecord for identifier {}"", input, e);
    }
    return false;
}",-0.09090909090909091,0.3397129186602871,-0.2,0.0,0.0,0.13690476190476186,0.11374207188160664,-0.25,0.21052631578947367,-0.015271750718924866
commons-math,remotes/origin/bugs-dot-jar_MATH-1096_faf99727,0,"/**
 * Compute enclosing ball using Welzl's move to front heuristic.
 * @param extreme subset of extreme points
 * @param support points that must belong to the ball support
 * @return enclosing ball, for the extreme subset only
 */
private EnclosingBall<S, P> moveToFrontBall(final List<P> extreme, final List<P> support) {
    // create a new ball on the prescribed support
    EnclosingBall<S, P> ball = generator.ballOnSupport(support);
    if (ball.getSupportSize() < max) {
        for (int i = 0; i < extreme.size(); ++i) {
            final P pi = extreme.get(i);
            if (!ball.contains(pi, tolerance)) {
                // we have found an outside point,
                // enlarge the ball by adding it to the support
                support.add(pi);
                ball = moveToFrontBall(extreme.subList(i + 1, extreme.size()), support);
                // according to Welzl's heuristic
                for (int j = i; j > 1; --j) {
                    extreme.set(j, extreme.get(j - 1));
                }
                extreme.set(0, pi);
            }
        }
    }
    return ball;
}","/**
 * Compute enclosing ball using Welzl's move to front heuristic.
 * @param extreme subset of extreme points
 * @param support points that must belong to the ball support
 * @return enclosing ball, for the extreme subset only
 */
","private EnclosingBall<S, P> moveToFrontBall(final List<P> extreme, final List<P> support) {
        EnclosingBall<S, P> ball = generator.ballOnSupport(support);
    if (ball.getSupportSize() < max) {
        for (int i = 0; i < extreme.size(); ++i) {
            final P pi = extreme.get(i);
            if (!ball.contains(pi, tolerance)) {
                                                support.add(pi);
                ball = moveToFrontBall(extreme.subList(i + 1, extreme.size()), support);
                                for (int j = i; j > 1; --j) {
                    extreme.set(j, extreme.get(j - 1));
                }
                extreme.set(0, pi);
            }
        }
    }
    return ball;
}",0.13636363636363635,1.5119617224880384,0.2,1.0,0.5833333333333334,1.6984126984126986,-0.22452431289640595,0.5,-0.02631578947368421,1.723762267826167
maven,remotes/origin/bugs-dot-jar_MNG-5655_96337372,1,"public void afterMojoExecutionSuccess(MojoExecutionEvent event) throws MojoExecutionException {
    for (Object provided : getScopeState().provided.values()) {
        if (provided instanceof WeakMojoExecutionListener) {
            ((WeakMojoExecutionListener) provided).afterMojoExecutionSuccess(event);
        }
    }
}",,"public void afterMojoExecutionSuccess(MojoExecutionEvent event) throws MojoExecutionException {
    for (Object provided : getScopeState().provided.values()) {
        if (provided instanceof WeakMojoExecutionListener) {
            ((WeakMojoExecutionListener) provided).afterMojoExecutionSuccess(event);
        }
    }
}",-0.3181818181818182,0.5406698564593301,-0.2,0.0,-0.25,-0.3650793650793651,0.4872445384073289,-0.25,0.15789473684210528,-0.16279340490885932
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-276_1bf5c550,1,"// ---------------------------------------------------< Persistence >
public void initialize(File homeDir) throws Exception {
    File dbDir = new File(homeDir, ""db"");
    if (!dbDir.exists()) {
        dbDir.mkdirs();
    }
    Driver.load();
    String url = ""jdbc:h2:"" + dbDir.getCanonicalPath() + ""/revs"";
    if (FAST) {
        url += "";log=0;undo_log=0"";
    }
    cp = JdbcConnectionPool.create(url, ""sa"", """");
    cp.setMaxConnections(40);
    Connection con = cp.getConnection();
    try {
        Statement stmt = con.createStatement();
        stmt.execute(""create table if not exists REVS(ID binary primary key, DATA binary, TIME timestamp)"");
        stmt.execute(""create table if not exists HEAD(ID binary) as select null"");
        stmt.execute(""create sequence if not exists DATASTORE_ID"");
    /*
            DbBlobStore store = new DbBlobStore();
            store.setConnectionPool(cp);
            blobStore = store;
*/
    } finally {
        con.close();
    }
}",,"public void initialize(File homeDir) throws Exception {
    File dbDir = new File(homeDir, ""db"");
    if (!dbDir.exists()) {
        dbDir.mkdirs();
    }
    Driver.load();
    String url = ""jdbc:h2:"" + dbDir.getCanonicalPath() + ""/revs"";
    if (FAST) {
        url += "";log=0;undo_log=0"";
    }
    cp = JdbcConnectionPool.create(url, ""sa"", """");
    cp.setMaxConnections(40);
    Connection con = cp.getConnection();
    try {
        Statement stmt = con.createStatement();
        stmt.execute(""create table if not exists REVS(ID binary primary key, DATA binary, TIME timestamp)"");
        stmt.execute(""create table if not exists HEAD(ID binary) as select null"");
        stmt.execute(""create sequence if not exists DATASTORE_ID"");
        } finally {
        con.close();
    }
}",0.36363636363636365,-0.2870813397129187,-0.2,-0.5,-0.16666666666666666,0.21825396825396823,-0.3009161381254403,0.5,0.31578947368421056,0.2778997596860358
Closure,105,2,"/**
 * Try to fold an array join: ['a', 'b', 'c'].join('') -> 'abc';
 */
void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right, Node parent) {
    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {
        return;
    }
    Node arrayNode = left.getFirstChild();
    Node functionName = arrayNode.getNext();
    if ((arrayNode.getType() != Token.ARRAYLIT) || !functionName.getString().equals(""join"")) {
        return;
    }
    String joinString = NodeUtil.getStringValue(right);
    List<Node> arrayFoldedChildren = Lists.newLinkedList();
    StringBuilder sb = new StringBuilder();
    int foldedSize = 0;
    Node elem = arrayNode.getFirstChild();
    // Merges adjacent String nodes.
    while (elem != null) {
        if (NodeUtil.isImmutableValue(elem)) {
            if (sb.length() > 0) {
                sb.append(joinString);
            }
            sb.append(NodeUtil.getStringValue(elem));
        } else {
            if (sb.length() > 0) {
                // + 2 for the quotes.
                foldedSize += sb.length() + 2;
                arrayFoldedChildren.add(Node.newString(sb.toString()));
                sb = new StringBuilder();
            }
            foldedSize += InlineCostEstimator.getCost(elem);
            arrayFoldedChildren.add(elem);
        }
        elem = elem.getNext();
    }
    if (sb.length() > 0) {
        // + 2 for the quotes.
        foldedSize += sb.length() + 2;
        arrayFoldedChildren.add(Node.newString(sb.toString()));
    }
    // one for each comma.
    foldedSize += arrayFoldedChildren.size() - 1;
    int originalSize = InlineCostEstimator.getCost(n);
    switch(arrayFoldedChildren.size()) {
        case 0:
            Node emptyStringNode = Node.newString("""");
            parent.replaceChild(n, emptyStringNode);
            break;
        case 1:
            Node foldedStringNode = arrayFoldedChildren.remove(0);
            if (foldedSize > originalSize) {
                return;
            }
            arrayNode.detachChildren();
            if (foldedStringNode.getType() != Token.STRING) {
                // If the Node is not a string literal, ensure that
                // it is coerced to a string.
                Node replacement = new Node(Token.ADD, Node.newString(""""), foldedStringNode);
                foldedStringNode = replacement;
            }
            parent.replaceChild(n, foldedStringNode);
            break;
        default:
            // No folding could actually be performed.
            if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {
                return;
            }
            int kJoinOverhead = ""[].join()"".length();
            foldedSize += kJoinOverhead;
            foldedSize += InlineCostEstimator.getCost(right);
            if (foldedSize > originalSize) {
                return;
            }
            arrayNode.detachChildren();
            for (Node node : arrayFoldedChildren) {
                arrayNode.addChildToBack(node);
            }
            break;
    }
    t.getCompiler().reportCodeChange();
}","/**
 * Try to fold an array join: ['a', 'b', 'c'].join('') -> 'abc';
 */
","void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right, Node parent) {
    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {
        return;
    }
    Node arrayNode = left.getFirstChild();
    Node functionName = arrayNode.getNext();
    if ((arrayNode.getType() != Token.ARRAYLIT) || !functionName.getString().equals(""join"")) {
        return;
    }
    String joinString = NodeUtil.getStringValue(right);
    List<Node> arrayFoldedChildren = Lists.newLinkedList();
    StringBuilder sb = new StringBuilder();
    int foldedSize = 0;
    Node elem = arrayNode.getFirstChild();
        while (elem != null) {
        if (NodeUtil.isImmutableValue(elem)) {
            if (sb.length() > 0) {
                sb.append(joinString);
            }
            sb.append(NodeUtil.getStringValue(elem));
        } else {
            if (sb.length() > 0) {
                                foldedSize += sb.length() + 2;
                arrayFoldedChildren.add(Node.newString(sb.toString()));
                sb = new StringBuilder();
            }
            foldedSize += InlineCostEstimator.getCost(elem);
            arrayFoldedChildren.add(elem);
        }
        elem = elem.getNext();
    }
    if (sb.length() > 0) {
                foldedSize += sb.length() + 2;
        arrayFoldedChildren.add(Node.newString(sb.toString()));
    }
        foldedSize += arrayFoldedChildren.size() - 1;
    int originalSize = InlineCostEstimator.getCost(n);
    switch(arrayFoldedChildren.size()) {
        case 0:
            Node emptyStringNode = Node.newString("""");
            parent.replaceChild(n, emptyStringNode);
            break;
        case 1:
            Node foldedStringNode = arrayFoldedChildren.remove(0);
            if (foldedSize > originalSize) {
                return;
            }
            arrayNode.detachChildren();
            if (foldedStringNode.getType() != Token.STRING) {
                                                Node replacement = new Node(Token.ADD, Node.newString(""""), foldedStringNode);
                foldedStringNode = replacement;
            }
            parent.replaceChild(n, foldedStringNode);
            break;
        default:
                        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {
                return;
            }
            int kJoinOverhead = ""[].join()"".length();
            foldedSize += kJoinOverhead;
            foldedSize += InlineCostEstimator.getCost(right);
            if (foldedSize > originalSize) {
                return;
            }
            arrayNode.detachChildren();
            for (Node node : arrayFoldedChildren) {
                arrayNode.addChildToBack(node);
            }
            break;
    }
    t.getCompiler().reportCodeChange();
}",2.6363636363636362,0.6889952153110046,3.0,0.5,2.0,1.9642857142857144,-1.1553206483439038,3.3333333333333335,-0.02631578947368421,7.161280060856485
Cli,9,1,"/**
 * <p>Throws a {@link MissingOptionException} if all of the
 * required options are no present.</p>
 *
 * @throws MissingOptionException if any of the required Options
 * are not present.
 */
protected void checkRequiredOptions() throws MissingOptionException {
    // processsed
    if (getRequiredOptions().size() > 0) {
        Iterator iter = getRequiredOptions().iterator();
        StringBuffer buff = new StringBuffer(""Missing required option"");
        buff.append(getRequiredOptions().size() == 1 ? """" : ""s"");
        buff.append("": "");
        // loop through the required options
        while (iter.hasNext()) {
            buff.append(iter.next());
        }
        throw new MissingOptionException(buff.toString());
    }
}","/**
 * <p>Throws a {@link MissingOptionException} if all of the
 * required options are no present.</p>
 *
 * @throws MissingOptionException if any of the required Options
 * are not present.
 */
","protected void checkRequiredOptions() throws MissingOptionException {
        if (getRequiredOptions().size() > 0) {
        Iterator iter = getRequiredOptions().iterator();
        StringBuffer buff = new StringBuffer(""Missing required option"");
        buff.append(getRequiredOptions().size() == 1 ? """" : ""s"");
        buff.append("": "");
                while (iter.hasNext()) {
            buff.append(iter.next());
        }
        throw new MissingOptionException(buff.toString());
    }
}",-0.09090909090909091,0.22009569377990432,0.2,0.0,0.0,-0.03769841269841273,0.059901338971106395,0.5,1.263157894736842,-0.0354742598963826
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-4038_557eec4f,1,"@Override
public double getCost(Filter filter, NodeState root) {
    if (filter.getFullTextConstraint() != null) {
        // not an appropriate index for full-text search
        return Double.POSITIVE_INFINITY;
    }
    if (filter.containsNativeConstraint()) {
        // not an appropriate index for native search
        return Double.POSITIVE_INFINITY;
    }
    if (filter.getPropertyRestrictions().isEmpty() && filter.getSelector().getSelectorConstraints().isEmpty()) {
        // not an appropriate index for no property restrictions & selector constraints
        return Double.POSITIVE_INFINITY;
    }
    PropertyIndexPlan plan = getPlan(root, filter);
    if (plan != null) {
        return plan.getCost();
    } else {
        return Double.POSITIVE_INFINITY;
    }
}",,"@Override
public double getCost(Filter filter, NodeState root) {
    if (filter.getFullTextConstraint() != null) {
                return Double.POSITIVE_INFINITY;
    }
    if (filter.containsNativeConstraint()) {
                return Double.POSITIVE_INFINITY;
    }
    if (filter.getPropertyRestrictions().isEmpty() && filter.getSelector().getSelectorConstraints().isEmpty()) {
                return Double.POSITIVE_INFINITY;
    }
    PropertyIndexPlan plan = getPlan(root, filter);
    if (plan != null) {
        return plan.getCost();
    } else {
        return Double.POSITIVE_INFINITY;
    }
}",0.18181818181818182,-0.17224880382775137,0.2,-0.5,0.4166666666666667,0.009920634920634885,-0.134601832276251,0.25,0.0,-0.006973139007509089
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3930_b939aa6e,1,"@Override
public void endElement(String namespaceURI, String localName, String qName) throws SAXException {
    // check element name
    ImportState state = stack.peek();
    if (namespaceURI.equals(NamespaceConstants.NAMESPACE_SV) && ""node"".equals(localName)) {
        // sv:node element
        if (!state.started) {
            // need to start & end current node
            processNode(state, true, true);
            state.started = true;
        } else {
            // need to end current node
            processNode(state, false, true);
        }
        // pop current state from stack
        stack.pop();
    } else if (namespaceURI.equals(NamespaceConstants.NAMESPACE_SV) && ""property"".equals(localName)) {
        // have been collected and create node as necessary primaryType
        if (currentPropName != null && currentPropName.getNamespaceUri().equals(NamespaceRegistry.NAMESPACE_JCR) && currentPropName.getLocalName().equals(""primaryType"")) {
            BufferedStringValue val = currentPropValues.get(0);
            String s = null;
            try {
                s = val.retrieve();
                state.nodeTypeName = new NameInfo(s).getRepoQualifiedName();
            } catch (IOException e) {
                throw new SAXException(new InvalidSerializedDataException(""illegal node type name: "" + s, e));
            } catch (RepositoryException e) {
                throw new SAXException(new InvalidSerializedDataException(""illegal node type name: "" + s, e));
            }
        } else if (currentPropName != null && currentPropName.getNamespaceUri().equals(NamespaceRegistry.NAMESPACE_JCR) && currentPropName.getLocalName().equals(""mixinTypes"")) {
            if (state.mixinNames == null) {
                state.mixinNames = new ArrayList<String>(currentPropValues.size());
            }
            for (BufferedStringValue val : currentPropValues) {
                String s = null;
                try {
                    s = val.retrieve();
                    state.mixinNames.add(new NameInfo(s).getRepoQualifiedName());
                } catch (IOException ioe) {
                    throw new SAXException(""error while retrieving value"", ioe);
                } catch (RepositoryException e) {
                    throw new SAXException(new InvalidSerializedDataException(""illegal mixin type name: "" + s, e));
                }
            }
        } else if (currentPropName != null && currentPropName.getNamespaceUri().equals(NamespaceRegistry.NAMESPACE_JCR) && currentPropName.getLocalName().equals(""uuid"")) {
            BufferedStringValue val = currentPropValues.get(0);
            try {
                state.uuid = val.retrieve();
            } catch (IOException ioe) {
                throw new SAXException(""error while retrieving value"", ioe);
            }
        } else {
            if (currentPropMultipleStatus == PropInfo.MultipleStatus.UNKNOWN && currentPropValues.size() != 1) {
                currentPropMultipleStatus = PropInfo.MultipleStatus.MULTIPLE;
            }
            PropInfo prop = new PropInfo(currentPropName == null ? null : currentPropName.getRepoQualifiedName(), currentPropType, currentPropValues);
            state.props.add(prop);
        }
        // reset temp fields
        currentPropValues.clear();
    } else if (namespaceURI.equals(NamespaceConstants.NAMESPACE_SV) && ""value"".equals(localName)) {
        // sv:value element
        currentPropValues.add(currentPropValue);
        // reset temp fields
        currentPropValue = null;
    } else {
        throw new SAXException(new InvalidSerializedDataException(""invalid element in system view xml document: "" + localName));
    }
}",,"@Override
public void endElement(String namespaceURI, String localName, String qName) throws SAXException {
        ImportState state = stack.peek();
    if (namespaceURI.equals(NamespaceConstants.NAMESPACE_SV) && ""node"".equals(localName)) {
                if (!state.started) {
                        processNode(state, true, true);
            state.started = true;
        } else {
                        processNode(state, false, true);
        }
                stack.pop();
    } else if (namespaceURI.equals(NamespaceConstants.NAMESPACE_SV) && ""property"".equals(localName)) {
                if (currentPropName != null && currentPropName.getNamespaceUri().equals(NamespaceRegistry.NAMESPACE_JCR) && currentPropName.getLocalName().equals(""primaryType"")) {
            BufferedStringValue val = currentPropValues.get(0);
            String s = null;
            try {
                s = val.retrieve();
                state.nodeTypeName = new NameInfo(s).getRepoQualifiedName();
            } catch (IOException e) {
                throw new SAXException(new InvalidSerializedDataException(""illegal node type name: "" + s, e));
            } catch (RepositoryException e) {
                throw new SAXException(new InvalidSerializedDataException(""illegal node type name: "" + s, e));
            }
        } else if (currentPropName != null && currentPropName.getNamespaceUri().equals(NamespaceRegistry.NAMESPACE_JCR) && currentPropName.getLocalName().equals(""mixinTypes"")) {
            if (state.mixinNames == null) {
                state.mixinNames = new ArrayList<String>(currentPropValues.size());
            }
            for (BufferedStringValue val : currentPropValues) {
                String s = null;
                try {
                    s = val.retrieve();
                    state.mixinNames.add(new NameInfo(s).getRepoQualifiedName());
                } catch (IOException ioe) {
                    throw new SAXException(""error while retrieving value"", ioe);
                } catch (RepositoryException e) {
                    throw new SAXException(new InvalidSerializedDataException(""illegal mixin type name: "" + s, e));
                }
            }
        } else if (currentPropName != null && currentPropName.getNamespaceUri().equals(NamespaceRegistry.NAMESPACE_JCR) && currentPropName.getLocalName().equals(""uuid"")) {
            BufferedStringValue val = currentPropValues.get(0);
            try {
                state.uuid = val.retrieve();
            } catch (IOException ioe) {
                throw new SAXException(""error while retrieving value"", ioe);
            }
        } else {
            if (currentPropMultipleStatus == PropInfo.MultipleStatus.UNKNOWN && currentPropValues.size() != 1) {
                currentPropMultipleStatus = PropInfo.MultipleStatus.MULTIPLE;
            }
            PropInfo prop = new PropInfo(currentPropName == null ? null : currentPropName.getRepoQualifiedName(), currentPropType, currentPropValues);
            state.props.add(prop);
        }
                currentPropValues.clear();
    } else if (namespaceURI.equals(NamespaceConstants.NAMESPACE_SV) && ""value"".equals(localName)) {
                currentPropValues.add(currentPropValue);
                currentPropValue = null;
    } else {
        throw new SAXException(new InvalidSerializedDataException(""invalid element in system view xml document: "" + localName));
    }
}",2.090909090909091,0.9138755980861245,3.8,2.0,2.4166666666666665,1.4305555555555558,-1.1082452431289638,2.5,-0.02631578947368421,5.883805605020659
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2642_36fe017c,0,"/**
 * Creates a new merge commit. The caller must acknowledge the commit either with
 * {@link #done(Commit, boolean, CommitInfo)} or {@link #canceled(Commit)},
 * depending on the result of the commit.
 *
 * @param base the base revision for the commit or <code>null</code> if the
 *             commit should use the current head revision as base.
 * @param numBranchCommits the number of branch commits to merge.
 * @return a new merge commit.
 */
@Nonnull
MergeCommit newMergeCommit(@Nullable Revision base, int numBranchCommits) {
    if (base == null) {
        base = headRevision;
    }
    backgroundOperationLock.readLock().lock();
    boolean success = false;
    MergeCommit c;
    try {
        c = new MergeCommit(this, base, commitQueue.createRevisions(numBranchCommits));
        success = true;
    } finally {
        if (!success) {
            backgroundOperationLock.readLock().unlock();
        }
    }
    return c;
}","/**
 * Creates a new merge commit. The caller must acknowledge the commit either with
 * {@link #done(Commit, boolean, CommitInfo)} or {@link #canceled(Commit)},
 * depending on the result of the commit.
 *
 * @param base the base revision for the commit or <code>null</code> if the
 *             commit should use the current head revision as base.
 * @param numBranchCommits the number of branch commits to merge.
 * @return a new merge commit.
 */
","@Nonnull
MergeCommit newMergeCommit(@Nullable Revision base, int numBranchCommits) {
    if (base == null) {
        base = headRevision;
    }
    backgroundOperationLock.readLock().lock();
    boolean success = false;
    MergeCommit c;
    try {
        c = new MergeCommit(this, base, commitQueue.createRevisions(numBranchCommits));
        success = true;
    } finally {
        if (!success) {
            backgroundOperationLock.readLock().unlock();
        }
    }
    return c;
}",0.18181818181818182,0.07177033492822962,-0.2,0.0,-0.08333333333333333,-0.047619047619047616,-0.11627906976744183,-0.08333333333333333,0.02631578947368421,-0.03599522829826595
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-238_24ce6788,1,"@Override
public Value createValue(String value, int type) throws ValueFormatException {
    if (value == null) {
        throw new ValueFormatException();
    }
    try {
        CoreValue cv;
        switch(type) {
            case PropertyType.NAME:
                String oakName = namePathMapper.getOakName(value);
                if (oakName == null) {
                    throw new ValueFormatException(""Invalid name: "" + value);
                }
                cv = factory.createValue(oakName, type);
                break;
            case PropertyType.PATH:
                // TODO we special case identifier paths here for now
                // eventually this should be done in the path mapper (OAK-23)
                String oakValue;
                if (value.startsWith(""["") && value.endsWith(""]"")) {
                    oakValue = value;
                } else {
                    oakValue = namePathMapper.getOakPath(value);
                    if (oakValue == null) {
                        throw new ValueFormatException(""Invalid path: "" + value);
                    }
                }
                cv = factory.createValue(oakValue, type);
                break;
            case PropertyType.DATE:
                if (ISO8601.parse(value) == null) {
                    throw new ValueFormatException(""Invalid date "" + value);
                }
                cv = factory.createValue(value, type);
                break;
            case PropertyType.BINARY:
                cv = factory.createValue(new ByteArrayInputStream(value.getBytes(""UTF-8"")));
                break;
            default:
                cv = factory.createValue(value, type);
                break;
        }
        return new ValueImpl(cv, namePathMapper);
    } catch (UnsupportedEncodingException e) {
        throw new ValueFormatException(""Encoding UTF-8 not supported (this should not happen!)"", e);
    } catch (IOException e) {
        throw new ValueFormatException(e);
    } catch (NumberFormatException e) {
        throw new ValueFormatException(""Invalid value "" + value + "" for type "" + PropertyType.nameFromValue(type));
    }
}",,"@Override
public Value createValue(String value, int type) throws ValueFormatException {
    if (value == null) {
        throw new ValueFormatException();
    }
    try {
        CoreValue cv;
        switch(type) {
            case PropertyType.NAME:
                String oakName = namePathMapper.getOakName(value);
                if (oakName == null) {
                    throw new ValueFormatException(""Invalid name: "" + value);
                }
                cv = factory.createValue(oakName, type);
                break;
            case PropertyType.PATH:
                                                String oakValue;
                if (value.startsWith(""["") && value.endsWith(""]"")) {
                    oakValue = value;
                } else {
                    oakValue = namePathMapper.getOakPath(value);
                    if (oakValue == null) {
                        throw new ValueFormatException(""Invalid path: "" + value);
                    }
                }
                cv = factory.createValue(oakValue, type);
                break;
            case PropertyType.DATE:
                if (ISO8601.parse(value) == null) {
                    throw new ValueFormatException(""Invalid date "" + value);
                }
                cv = factory.createValue(value, type);
                break;
            case PropertyType.BINARY:
                cv = factory.createValue(new ByteArrayInputStream(value.getBytes(""UTF-8"")));
                break;
            default:
                cv = factory.createValue(value, type);
                break;
        }
        return new ValueImpl(cv, namePathMapper);
    } catch (UnsupportedEncodingException e) {
        throw new ValueFormatException(""Encoding UTF-8 not supported (this should not happen!)"", e);
    } catch (IOException e) {
        throw new ValueFormatException(e);
    } catch (NumberFormatException e) {
        throw new ValueFormatException(""Invalid value "" + value + "" for type "" + PropertyType.nameFromValue(type));
    }
}",1.5909090909090908,1.4976076555023925,4.4,1.5,1.0,0.613095238095238,-0.9250176180408736,0.5,-0.02631578947368421,1.3901580770272526
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2021_004db804,1,"public Statement optimize() {
    if (explain || measure || orderList.size() > 0) {
        return this;
    }
    if (where == null) {
        return this;
    }
    ArrayList<Expression> unionList = new ArrayList<Expression>();
    addToUnionList(where, unionList);
    if (unionList.size() == 1) {
        return this;
    }
    Statement union = null;
    for (int i = 0; i < unionList.size(); i++) {
        Expression e = unionList.get(i);
        Statement s = new Statement();
        s.columnSelector = columnSelector;
        s.selectors = selectors;
        s.columnList = columnList;
        s.where = e;
        if (i == unionList.size() - 1) {
            s.xpathQuery = xpathQuery;
        }
        if (union == null) {
            union = s;
        } else {
            union = new UnionStatement(union.optimize(), s.optimize());
        }
    }
    return union;
}",,"public Statement optimize() {
    if (explain || measure || orderList.size() > 0) {
        return this;
    }
    if (where == null) {
        return this;
    }
    ArrayList<Expression> unionList = new ArrayList<Expression>();
    addToUnionList(where, unionList);
    if (unionList.size() == 1) {
        return this;
    }
    Statement union = null;
    for (int i = 0; i < unionList.size(); i++) {
        Expression e = unionList.get(i);
        Statement s = new Statement();
        s.columnSelector = columnSelector;
        s.selectors = selectors;
        s.columnList = columnList;
        s.where = e;
        if (i == unionList.size() - 1) {
            s.xpathQuery = xpathQuery;
        }
        if (union == null) {
            union = s;
        } else {
            union = new UnionStatement(union.optimize(), s.optimize());
        }
    }
    return union;
}",0.7727272727272727,0.009569377990430419,0.6,0.0,0.8333333333333334,1.253968253968254,-0.5298097251585623,0.16666666666666666,0.0,1.5113131976740832
Time,16,2,"// -----------------------------------------------------------------------
/**
 * Parses a datetime from the given text, at the given position, saving the
 * result into the fields of the given ReadWritableInstant. If the parse
 * succeeds, the return value is the new text position. Note that the parse
 * may succeed without fully reading the text and in this case those fields
 * that were read will be set.
 * <p>
 * Only those fields present in the string will be changed in the specified
 * instant. All other fields will remain unaltered. Thus if the string only
 * contains a year and a month, then the day and time will be retained from
 * the input instant. If this is not the behaviour you want, then reset the
 * fields before calling this method, or use {@link #parseDateTime(String)}
 * or {@link #parseMutableDateTime(String)}.
 * <p>
 * If it fails, the return value is negative, but the instant may still be
 * modified. To determine the position where the parse failed, apply the
 * one's complement operator (~) on the return value.
 * <p>
 * This parse method ignores the {@link #getDefaultYear() default year} and
 * parses using the year from the supplied instant as the default.
 * <p>
 * The parse will use the chronology of the instant.
 *
 * @param instant  an instant that will be modified, not null
 * @param text  the text to parse
 * @param position  position to start parsing from
 * @return new position, negative value means parse failed -
 *  apply complement operator (~) to get position of failure
 * @throws UnsupportedOperationException if parsing is not supported
 * @throws IllegalArgumentException if the instant is null
 * @throws IllegalArgumentException if any field is out of range
 */
public int parseInto(ReadWritableInstant instant, String text, int position) {
    DateTimeParser parser = requireParser();
    if (instant == null) {
        throw new IllegalArgumentException(""Instant must not be null"");
    }
    long instantMillis = instant.getMillis();
    Chronology chrono = instant.getChronology();
    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);
    chrono = selectChronology(chrono);
    DateTimeParserBucket bucket = new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);
    int newPos = parser.parseInto(bucket, text, position);
    instant.setMillis(bucket.computeMillis(false, text));
    if (iOffsetParsed && bucket.getOffsetInteger() != null) {
        int parsedOffset = bucket.getOffsetInteger();
        DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
        chrono = chrono.withZone(parsedZone);
    } else if (bucket.getZone() != null) {
        chrono = chrono.withZone(bucket.getZone());
    }
    instant.setChronology(chrono);
    if (iZone != null) {
        instant.setZone(iZone);
    }
    return newPos;
}","/**
 * Parses a datetime from the given text, at the given position, saving the
 * result into the fields of the given ReadWritableInstant. If the parse
 * succeeds, the return value is the new text position. Note that the parse
 * may succeed without fully reading the text and in this case those fields
 * that were read will be set.
 * <p>
 * Only those fields present in the string will be changed in the specified
 * instant. All other fields will remain unaltered. Thus if the string only
 * contains a year and a month, then the day and time will be retained from
 * the input instant. If this is not the behaviour you want, then reset the
 * fields before calling this method, or use {@link #parseDateTime(String)}
 * or {@link #parseMutableDateTime(String)}.
 * <p>
 * If it fails, the return value is negative, but the instant may still be
 * modified. To determine the position where the parse failed, apply the
 * one's complement operator (~) on the return value.
 * <p>
 * This parse method ignores the {@link #getDefaultYear() default year} and
 * parses using the year from the supplied instant as the default.
 * <p>
 * The parse will use the chronology of the instant.
 *
 * @param instant  an instant that will be modified, not null
 * @param text  the text to parse
 * @param position  position to start parsing from
 * @return new position, negative value means parse failed -
 *  apply complement operator (~) to get position of failure
 * @throws UnsupportedOperationException if parsing is not supported
 * @throws IllegalArgumentException if the instant is null
 * @throws IllegalArgumentException if any field is out of range
 */
","public int parseInto(ReadWritableInstant instant, String text, int position) {
    DateTimeParser parser = requireParser();
    if (instant == null) {
        throw new IllegalArgumentException(""Instant must not be null"");
    }
    long instantMillis = instant.getMillis();
    Chronology chrono = instant.getChronology();
    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);
    chrono = selectChronology(chrono);
    DateTimeParserBucket bucket = new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);
    int newPos = parser.parseInto(bucket, text, position);
    instant.setMillis(bucket.computeMillis(false, text));
    if (iOffsetParsed && bucket.getOffsetInteger() != null) {
        int parsedOffset = bucket.getOffsetInteger();
        DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
        chrono = chrono.withZone(parsedZone);
    } else if (bucket.getZone() != null) {
        chrono = chrono.withZone(bucket.getZone());
    }
    instant.setChronology(chrono);
    if (iZone != null) {
        instant.setZone(iZone);
    }
    return newPos;
}",0.5,-0.39234449760765566,0.4,0.0,0.4166666666666667,0.4384920634920635,-0.4568005637773078,1.0,-0.02631578947368421,0.868249165816635
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-93_0be7e8f0,1,"@Override
public boolean removeChild(String name) {
    boolean result = builder.removeNode(name);
    if (result) {
        listener.removeChild(this, name);
    }
    return result;
}",,"@Override
public boolean removeChild(String name) {
    boolean result = builder.removeNode(name);
    if (result) {
        listener.removeChild(this, name);
    }
    return result;
}",-0.2727272727272727,-0.16267942583732073,-0.4,-0.5,-0.25,-0.3650793650793651,0.44214235377026073,-0.3333333333333333,0.7894736842105263,-0.16279340490885932
camel,remotes/origin/bugs-dot-jar_CAMEL-6447_020c451a,1,"/**
 * Ends the current block and returns back to the {@link ChoiceDefinition choice()} DSL.
 *
 * @return the builder
 */
public ChoiceDefinition endChoice() {
    // are we already a choice?
    ProcessorDefinition<?> def = this;
    if (def instanceof ChoiceDefinition) {
        return (ChoiceDefinition) def;
    }
    // okay end this and get back to the choice
    def = end();
    if (def instanceof WhenDefinition) {
        return (ChoiceDefinition) def.getParent();
    } else if (def instanceof OtherwiseDefinition) {
        return (ChoiceDefinition) def.getParent();
    } else {
        return (ChoiceDefinition) def;
    }
}","/**
 * Ends the current block and returns back to the {@link ChoiceDefinition choice()} DSL.
 *
 * @return the builder
 */
","public ChoiceDefinition endChoice() {
        ProcessorDefinition<?> def = this;
    if (def instanceof ChoiceDefinition) {
        return (ChoiceDefinition) def;
    }
        def = end();
    if (def instanceof WhenDefinition) {
        return (ChoiceDefinition) def.getParent();
    } else if (def instanceof OtherwiseDefinition) {
        return (ChoiceDefinition) def.getParent();
    } else {
        return (ChoiceDefinition) def;
    }
}",0.0,-0.20574162679425848,0.0,0.0,-0.08333333333333333,-0.3650793650793651,0.09880197322057772,-0.25,0.31578947368421056,-0.16279340490885932
Closure,170,2,"/**
 * Computes the number of uses of the variable varName and store it in
 * numUseWithinUseCfgNode.
 */
private void getNumUseInUseCfgNode(final Node cfgNode) {
    numUsesWithinCfgNode = 0;
    AbstractCfgNodeTraversalCallback gatherCb = new AbstractCfgNodeTraversalCallback() {

        @Override
        public void visit(NodeTraversal t, Node n, Node parent) {
            if (n.isName() && n.getString().equals(varName) && // and remove this special case.
            !(parent.isAssign() && (parent.getFirstChild() == n))) {
                // Don't count lhs of top-level assignment chain
                numUsesWithinCfgNode++;
            }
        }
    };
    NodeTraversal.traverse(compiler, cfgNode, gatherCb);
}","/**
 * Computes the number of uses of the variable varName and store it in
 * numUseWithinUseCfgNode.
 */
","private void getNumUseInUseCfgNode(final Node cfgNode) {
    numUsesWithinCfgNode = 0;
    AbstractCfgNodeTraversalCallback gatherCb = new AbstractCfgNodeTraversalCallback() {

        @Override
        public void visit(NodeTraversal t, Node n, Node parent) {
            if (n.isName() && n.getString().equals(varName) &&             !(parent.isAssign() && (parent.getFirstChild() == n))) {
                                numUsesWithinCfgNode++;
            }
        }
    };
    NodeTraversal.traverse(compiler, cfgNode, gatherCb);
}",-0.045454545454545456,0.8421052631578947,-0.4,0.0,0.4166666666666667,0.24801587301587297,0.020436927413671434,0.0,1.4736842105263157,0.11501184281046316
wicket,remotes/origin/bugs-dot-jar_WICKET-4997_ee02c883,1,"/**
 *  Gets a URL for the listener interface on a behavior (e.g. IBehaviorListener on
 *  AjaxPagingNavigationBehavior).
 *
 *  @param behaviour
 *             The behavior that the URL should point to
 *  @param listener
 *             The listener interface that the URL should call
 *  @param parameters
 *             The parameters that should be rendered into the urls
 *  @return The URL
 */
public final CharSequence urlFor(final Behavior behaviour, final RequestListenerInterface listener, final PageParameters parameters) {
    int id = getBehaviorId(behaviour);
    Page page = getPage();
    PageAndComponentProvider provider = new PageAndComponentProvider(page, this, parameters);
    IRequestHandler handler;
    if (page.isBookmarkable()) {
        handler = new BookmarkableListenerInterfaceRequestHandler(provider, listener, id);
    } else {
        handler = new ListenerInterfaceRequestHandler(provider, listener, id);
    }
    return getRequestCycle().urlFor(handler);
}","/**
 *  Gets a URL for the listener interface on a behavior (e.g. IBehaviorListener on
 *  AjaxPagingNavigationBehavior).
 *
 *  @param behaviour
 *             The behavior that the URL should point to
 *  @param listener
 *             The listener interface that the URL should call
 *  @param parameters
 *             The parameters that should be rendered into the urls
 *  @return The URL
 */
","public final CharSequence urlFor(final Behavior behaviour, final RequestListenerInterface listener, final PageParameters parameters) {
    int id = getBehaviorId(behaviour);
    Page page = getPage();
    PageAndComponentProvider provider = new PageAndComponentProvider(page, this, parameters);
    IRequestHandler handler;
    if (page.isBookmarkable()) {
        handler = new BookmarkableListenerInterfaceRequestHandler(provider, listener, id);
    } else {
        handler = new ListenerInterfaceRequestHandler(provider, listener, id);
    }
    return getRequestCycle().urlFor(handler);
}",-0.09090909090909091,-0.32535885167464124,-0.4,-0.5,-0.25,-0.3650793650793651,0.06074700493305146,-0.08333333333333333,0.1842105263157895,-0.16279340490885932
maven,remotes/origin/bugs-dot-jar_MNG-3616_912a565f,1,"// ----------------------------------------------------------------------
// Field validation
// ----------------------------------------------------------------------
private boolean validateStringNotEmpty(SettingsProblemCollector problems, String fieldName, String string) {
    return validateStringNotEmpty(problems, fieldName, string, null);
}",,"private boolean validateStringNotEmpty(SettingsProblemCollector problems, String fieldName, String string) {
    return validateStringNotEmpty(problems, fieldName, string, null);
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.9323467230443969,-0.4166666666666667,2.6052631578947367,-0.16279340490885932
wicket,remotes/origin/bugs-dot-jar_WICKET-3278_60d07288,1,"/**
 *  The localizer will be ask for the property to display Depending on if null is allowed or not
 *  it will ask for:
 *
 *  <ul>
 *  <li>nullValid: when null is valid and by default it will show an empty string as a choice.</li>
 *  <li>null: when null is not a valid choice and it will make a choice with ""Choose One""</li>
 *  </ul>
 *
 *  The choice for null is valid will always be returned. The choice when null is not valid will
 *  only be returned if the selected object is null.
 *
 *  @see org.apache.wicket.markup.html.form.AbstractChoice#getDefaultChoice(Object)
 */
@Override
protected CharSequence getDefaultChoice(final Object selected) {
    // Is null a valid selection value?
    if (isNullValid()) {
        // Null is valid, so look up the value for it
        String option = getLocalizer().getStringIgnoreSettings(getNullValidKey(), this, null, null);
        if (Strings.isEmpty(option)) {
            option = getLocalizer().getString(""nullValid"", this, """");
        }
        // The <option> tag buffer
        final AppendingStringBuffer buffer = new AppendingStringBuffer(64 + option.length());
        // Add option tag
        buffer.append(""\n<option"");
        // If null is selected, indicate that
        if (selected == null) {
            buffer.append("" selected=\""selected\"""");
        }
        // Add body of option tag
        buffer.append("" value=\""\"">"").append(option).append(""</option>"");
        return buffer;
    } else {
        // Null is not valid. Is it selected anyway?
        if ((selected == null) || getNoSelectionValue().equals(selected) || selected.equals(EMPTY_STRING)) {
            // Force the user to pick a non-null value
            String option = getLocalizer().getStringIgnoreSettings(getNullKey(), this, null, null);
            if (Strings.isEmpty(option)) {
                option = getLocalizer().getString(""null"", this, CHOOSE_ONE);
            }
            return ""\n<option selected=\""selected\"" value=\""\"">"" + option + ""</option>"";
        }
    }
    return """";
}","/**
 *  The localizer will be ask for the property to display Depending on if null is allowed or not
 *  it will ask for:
 *
 *  <ul>
 *  <li>nullValid: when null is valid and by default it will show an empty string as a choice.</li>
 *  <li>null: when null is not a valid choice and it will make a choice with ""Choose One""</li>
 *  </ul>
 *
 *  The choice for null is valid will always be returned. The choice when null is not valid will
 *  only be returned if the selected object is null.
 *
 *  @see org.apache.wicket.markup.html.form.AbstractChoice#getDefaultChoice(Object)
 */
","@Override
protected CharSequence getDefaultChoice(final Object selected) {
        if (isNullValid()) {
                String option = getLocalizer().getStringIgnoreSettings(getNullValidKey(), this, null, null);
        if (Strings.isEmpty(option)) {
            option = getLocalizer().getString(""nullValid"", this, """");
        }
                final AppendingStringBuffer buffer = new AppendingStringBuffer(64 + option.length());
                buffer.append(""\n<option"");
                if (selected == null) {
            buffer.append("" selected=\""selected\"""");
        }
                buffer.append("" value=\""\"">"").append(option).append(""</option>"");
        return buffer;
    } else {
                if ((selected == null) || getNoSelectionValue().equals(selected) || selected.equals(EMPTY_STRING)) {
                        String option = getLocalizer().getStringIgnoreSettings(getNullKey(), this, null, null);
            if (Strings.isEmpty(option)) {
                option = getLocalizer().getString(""null"", this, CHOOSE_ONE);
            }
            return ""\n<option selected=\""selected\"" value=\""\"">"" + option + ""</option>"";
        }
    }
    return """";
}",0.5,0.5167464114832536,0.4,0.5,0.6666666666666666,0.4880952380952381,-0.41733615221987286,1.3333333333333333,-0.02631578947368421,0.6743198308005278
wicket,remotes/origin/bugs-dot-jar_WICKET-5082_217fbb3b,1,"@Override
public void component(final Component component, final IVisit<Void> visit) {
    if (component.isVisibleInHierarchy()) {
        component.renderHead(header);
    } else {
        visit.dontGoDeeper();
    }
}",,"@Override
public void component(final Component component, final IVisit<Void> visit) {
    if (component.isVisibleInHierarchy()) {
        component.renderHead(header);
    } else {
        visit.dontGoDeeper();
    }
}",-0.2727272727272727,0.06220095693779899,-0.4,-0.5,-0.25,-0.3650793650793651,0.43622269203664527,-0.25,0.21052631578947367,-0.16279340490885932
Math,98,1,"/**
 * Returns the result of multiplying this by the vector <code>v</code>.
 *
 * @param v the vector to operate on
 * @return this*v
 * @throws IllegalArgumentException if columnDimension != v.size()
 */
public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {
    if (v.length != this.getColumnDimension()) {
        throw new IllegalArgumentException(""vector has wrong length"");
    }
    final int nRows = this.getRowDimension();
    final int nCols = this.getColumnDimension();
    final BigDecimal[] out = new BigDecimal[v.length];
    for (int row = 0; row < nRows; row++) {
        BigDecimal sum = ZERO;
        for (int i = 0; i < nCols; i++) {
            sum = sum.add(data[row][i].multiply(v[i]));
        }
        out[row] = sum;
    }
    return out;
}","/**
 * Returns the result of multiplying this by the vector <code>v</code>.
 *
 * @param v the vector to operate on
 * @return this*v
 * @throws IllegalArgumentException if columnDimension != v.size()
 */
","public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {
    if (v.length != this.getColumnDimension()) {
        throw new IllegalArgumentException(""vector has wrong length"");
    }
    final int nRows = this.getRowDimension();
    final int nCols = this.getColumnDimension();
    final BigDecimal[] out = new BigDecimal[v.length];
    for (int row = 0; row < nRows; row++) {
        BigDecimal sum = ZERO;
        for (int i = 0; i < nCols; i++) {
            sum = sum.add(data[row][i].multiply(v[i]));
        }
        out[row] = sum;
    }
    return out;
}",0.09090909090909091,0.03827751196172231,0.2,0.0,0.3333333333333333,0.5476190476190476,-0.14193093727977435,-0.08333333333333333,1.368421052631579,0.4108988433809926
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-776_dc9f23d9,3,"@Override
public void init(SortedKeyValueIterator<Key, Value> source, Map<String, String> options, IteratorEnvironment env) throws IOException {
    super.init(source, options, env);
    if (options == null)
        throw new IllegalArgumentException(""start and/or end must be set for "" + TimestampFilter.class.getName());
    hasStart = false;
    hasEnd = false;
    startInclusive = true;
    endInclusive = true;
    if (options.containsKey(START))
        hasStart = true;
    if (options.containsKey(END))
        hasEnd = true;
    if (!hasStart && !hasEnd)
        throw new IllegalArgumentException(""must have either start or end for "" + TimestampFilter.class.getName());
    try {
        if (hasStart)
            start = dateParser.parse(options.get(START)).getTime();
        if (hasEnd)
            end = dateParser.parse(options.get(END)).getTime();
    } catch (Exception e) {
        throw new IllegalArgumentException(e);
    }
    if (options.get(START_INCL) != null)
        startInclusive = Boolean.parseBoolean(options.get(START_INCL));
    if (options.get(END_INCL) != null)
        endInclusive = Boolean.parseBoolean(options.get(END_INCL));
}",,"@Override
public void init(SortedKeyValueIterator<Key, Value> source, Map<String, String> options, IteratorEnvironment env) throws IOException {
    super.init(source, options, env);
    if (options == null)
        throw new IllegalArgumentException(""start and/or end must be set for "" + TimestampFilter.class.getName());
    hasStart = false;
    hasEnd = false;
    startInclusive = true;
    endInclusive = true;
    if (options.containsKey(START))
        hasStart = true;
    if (options.containsKey(END))
        hasEnd = true;
    if (!hasStart && !hasEnd)
        throw new IllegalArgumentException(""must have either start or end for "" + TimestampFilter.class.getName());
    try {
        if (hasStart)
            start = dateParser.parse(options.get(START)).getTime();
        if (hasEnd)
            end = dateParser.parse(options.get(END)).getTime();
    } catch (Exception e) {
        throw new IllegalArgumentException(e);
    }
    if (options.get(START_INCL) != null)
        startInclusive = Boolean.parseBoolean(options.get(START_INCL));
    if (options.get(END_INCL) != null)
        endInclusive = Boolean.parseBoolean(options.get(END_INCL));
}",0.6363636363636364,0.0334928229665071,1.8,-0.5,0.9166666666666666,0.9444444444444444,-0.5625088090204368,0.9166666666666666,-0.02631578947368421,1.6187709986572383
Closure,135,2,"/**
 * Replaces references to ""this"" with references to name.  Do not
 * traverse function boundaries.
 */
private void replaceReferencesToThis(Node node, String name) {
    if (NodeUtil.isFunction(node)) {
        return;
    }
    for (Node child : node.children()) {
        if (NodeUtil.isThis(child)) {
            Node newName = Node.newString(Token.NAME, name);
            node.replaceChild(child, newName);
        } else {
            replaceReferencesToThis(child, name);
        }
    }
}","/**
 * Replaces references to ""this"" with references to name.  Do not
 * traverse function boundaries.
 */
","private void replaceReferencesToThis(Node node, String name) {
    if (NodeUtil.isFunction(node)) {
        return;
    }
    for (Node child : node.children()) {
        if (NodeUtil.isThis(child)) {
            Node newName = Node.newString(Token.NAME, name);
            node.replaceChild(child, newName);
        } else {
            replaceReferencesToThis(child, name);
        }
    }
}",-0.045454545454545456,0.48803827751196155,0.0,0.0,0.08333333333333333,-0.3650793650793651,0.07061310782241001,0.0,0.21052631578947367,-0.16279340490885932
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-217_46f62443,1,"@Override
public Iterable<Entry<String, String>> getProperties(String tableName) throws TableNotFoundException {
    return acu.tables.get(tableName).settings.entrySet();
}",,"@Override
public Iterable<Entry<String, String>> getProperties(String tableName) throws TableNotFoundException {
    return acu.tables.get(tableName).settings.entrySet();
}",-0.45454545454545453,-0.6028708133971293,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.7398167723749118,-0.3333333333333333,0.0,-0.16279340490885932
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-3475_7651b777,1,"public int start() throws IOException {
    if (configError)
        return 1;
    String input;
    if (isVerbose())
        printInfo();
    if (execFile != null) {
        java.util.Scanner scanner = new java.util.Scanner(new File(execFile), UTF_8.name());
        try {
            while (scanner.hasNextLine() && !hasExited()) {
                execCommand(scanner.nextLine(), true, isVerbose());
            }
        } finally {
            scanner.close();
        }
    } else if (execCommand != null) {
        for (String command : execCommand.split(""\n"")) {
            execCommand(command, true, isVerbose());
        }
        return exitCode;
    }
    while (true) {
        if (hasExited())
            return exitCode;
        reader.setDefaultPrompt(getDefaultPrompt());
        input = reader.readLine();
        if (input == null) {
            reader.printNewline();
            return exitCode;
        }
        // user canceled
        execCommand(input, false, false);
    }
}",,"public int start() throws IOException {
    if (configError)
        return 1;
    String input;
    if (isVerbose())
        printInfo();
    if (execFile != null) {
        java.util.Scanner scanner = new java.util.Scanner(new File(execFile), UTF_8.name());
        try {
            while (scanner.hasNextLine() && !hasExited()) {
                execCommand(scanner.nextLine(), true, isVerbose());
            }
        } finally {
            scanner.close();
        }
    } else if (execCommand != null) {
        for (String command : execCommand.split(""\n"")) {
            execCommand(command, true, isVerbose());
        }
        return exitCode;
    }
    while (true) {
        if (hasExited())
            return exitCode;
        reader.setDefaultPrompt(getDefaultPrompt());
        input = reader.readLine();
        if (input == null) {
            reader.printNewline();
            return exitCode;
        }
                execCommand(input, false, false);
    }
}",0.8636363636363636,0.29186602870813394,1.2,0.5,0.9166666666666666,0.3591269841269841,-0.5486962649753347,1.0,-0.02631578947368421,0.4504094558070111
Lang,43,1,"/**
 * Consume a quoted string, adding it to <code>appendTo</code> if
 * specified.
 *
 * @param pattern pattern to parse
 * @param pos current parse position
 * @param appendTo optional StringBuffer to append
 * @param escapingOn whether to process escaped quotes
 * @return <code>appendTo</code>
 */
private StringBuffer appendQuotedString(String pattern, ParsePosition pos, StringBuffer appendTo, boolean escapingOn) {
    int start = pos.getIndex();
    char[] c = pattern.toCharArray();
    if (escapingOn && c[start] == QUOTE) {
        return appendTo == null ? null : appendTo.append(QUOTE);
    }
    int lastHold = start;
    for (int i = pos.getIndex(); i < pattern.length(); i++) {
        if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {
            appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(QUOTE);
            pos.setIndex(i + ESCAPED_QUOTE.length());
            lastHold = pos.getIndex();
            continue;
        }
        switch(c[pos.getIndex()]) {
            case QUOTE:
                next(pos);
                return appendTo == null ? null : appendTo.append(c, lastHold, pos.getIndex() - lastHold);
            default:
                next(pos);
        }
    }
    throw new IllegalArgumentException(""Unterminated quoted string at position "" + start);
}","/**
 * Consume a quoted string, adding it to <code>appendTo</code> if
 * specified.
 *
 * @param pattern pattern to parse
 * @param pos current parse position
 * @param appendTo optional StringBuffer to append
 * @param escapingOn whether to process escaped quotes
 * @return <code>appendTo</code>
 */
","private StringBuffer appendQuotedString(String pattern, ParsePosition pos, StringBuffer appendTo, boolean escapingOn) {
    int start = pos.getIndex();
    char[] c = pattern.toCharArray();
    if (escapingOn && c[start] == QUOTE) {
        return appendTo == null ? null : appendTo.append(QUOTE);
    }
    int lastHold = start;
    for (int i = pos.getIndex(); i < pattern.length(); i++) {
        if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {
            appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(QUOTE);
            pos.setIndex(i + ESCAPED_QUOTE.length());
            lastHold = pos.getIndex();
            continue;
        }
        switch(c[pos.getIndex()]) {
            case QUOTE:
                next(pos);
                return appendTo == null ? null : appendTo.append(c, lastHold, pos.getIndex() - lastHold);
            default:
                next(pos);
        }
    }
    throw new IllegalArgumentException(""Unterminated quoted string at position "" + start);
}",0.45454545454545453,0.8468899521531099,1.2,0.5,0.6666666666666666,1.4444444444444442,-0.4432699083861872,1.0,-0.02631578947368421,1.8511182955573608
Math,100,0,"/**
 * Guess the errors in unbound estimated parameters.
 * <p>Guessing is covariance-based, it only gives rough order of magnitude.</p>
 * @param problem estimation problem
 * @return errors in estimated parameters
 * @exception EstimationException if the covariances matrix cannot be computed
 * or the number of degrees of freedom is not positive (number of measurements
 * lesser or equal to number of parameters)
 */
public double[] guessParametersErrors(EstimationProblem problem) throws EstimationException {
    int m = problem.getMeasurements().length;
    int p = problem.getAllParameters().length;
    if (m <= p) {
        throw new EstimationException(""no degrees of freedom ({0} measurements, {1} parameters)"", new Object[] { new Integer(m), new Integer(p) });
    }
    double[] errors = new double[problem.getAllParameters().length];
    final double c = Math.sqrt(getChiSquare(problem) / (m - p));
    double[][] covar = getCovariances(problem);
    for (int i = 0; i < errors.length; ++i) {
        errors[i] = Math.sqrt(covar[i][i]) * c;
    }
    return errors;
}","/**
 * Guess the errors in unbound estimated parameters.
 * <p>Guessing is covariance-based, it only gives rough order of magnitude.</p>
 * @param problem estimation problem
 * @return errors in estimated parameters
 * @exception EstimationException if the covariances matrix cannot be computed
 * or the number of degrees of freedom is not positive (number of measurements
 * lesser or equal to number of parameters)
 */
","public double[] guessParametersErrors(EstimationProblem problem) throws EstimationException {
    int m = problem.getMeasurements().length;
    int p = problem.getAllParameters().length;
    if (m <= p) {
        throw new EstimationException(""no degrees of freedom ({0} measurements, {1} parameters)"", new Object[] { new Integer(m), new Integer(p) });
    }
    double[] errors = new double[problem.getAllParameters().length];
    final double c = Math.sqrt(getChiSquare(problem) / (m - p));
    double[][] covar = getCovariances(problem);
    for (int i = 0; i < errors.length; ++i) {
        errors[i] = Math.sqrt(covar[i][i]) * c;
    }
    return errors;
}",0.0,-0.4066985645933015,0.0,-0.5,0.08333333333333333,1.0138888888888888,-0.09485553206483423,0.08333333333333333,-0.02631578947368421,0.834072716585121
Compress,4,1,"/**
 * Closes the CPIO output stream as well as the stream being filtered.
 *
 * @throws IOException
 *             if an I/O error has occurred or if a CPIO file error has
 *             occurred
 */
public void close() throws IOException {
    if (!this.closed) {
        this.finish();
        out.close();
        this.closed = true;
    }
}","/**
 * Closes the CPIO output stream as well as the stream being filtered.
 *
 * @throws IOException
 *             if an I/O error has occurred or if a CPIO file error has
 *             occurred
 */
","public void close() throws IOException {
    if (!this.closed) {
        this.finish();
        out.close();
        this.closed = true;
    }
}",-0.3181818181818182,0.1626794258373205,-0.4,-0.5,-0.25,-0.10912698412698414,0.5554615926708948,-0.3333333333333333,2.5789473684210527,-0.14212525140759438
wicket,remotes/origin/bugs-dot-jar_WICKET-4715_4fc82e35,1,"/**
 *  @see org.apache.wicket.Component#onComponentTag(ComponentTag)
 */
@Override
protected void onComponentTag(final ComponentTag tag) {
    super.onComponentTag(tag);
    checkComponentTag(tag, ""form"");
    if (isRootForm()) {
        String method = getMethod().toLowerCase(Locale.ENGLISH);
        tag.put(""method"", method);
        String url = getActionUrl().toString();
        if (encodeUrlInHiddenFields()) {
            int i = url.indexOf('?');
            String action = (i > -1) ? url.substring(0, i) : """";
            tag.put(""action"", action);
        // alternatively, we could just put an empty string here, so
        // that mounted paths stay in good order. I decided against this
        // as I'm not sure whether that could have side effects with
        // other encoders
        } else {
            tag.put(""action"", url);
        }
        if (isMultiPart()) {
            if (METHOD_GET.equalsIgnoreCase(method)) {
                log.warn(""Form with id '{}' is multipart. It should use method 'POST'!"", getId());
                tag.put(""method"", METHOD_POST.toLowerCase(Locale.ENGLISH));
            }
            tag.put(""enctype"", ""multipart/form-data"");
            //
            // require the application-encoding for multipart/form-data to be sure to
            // get multipart-uploaded characters with the proper encoding on the following
            // request.
            //
            // for details see: http://stackoverflow.com/questions/546365
            //
            tag.put(""accept-charset"", getApplication().getRequestCycleSettings().getResponseRequestEncoding());
        } else {
            // sanity check
            String enctype = (String) tag.getAttributes().get(""enctype"");
            if (""multipart/form-data"".equalsIgnoreCase(enctype)) {
                // though not set explicitly in Java, this is a multipart
                // form
                setMultiPart(true);
            }
        }
    } else {
        tag.setName(""div"");
        tag.remove(""method"");
        tag.remove(""action"");
        tag.remove(""enctype"");
    }
}","/**
 *  @see org.apache.wicket.Component#onComponentTag(ComponentTag)
 */
","@Override
protected void onComponentTag(final ComponentTag tag) {
    super.onComponentTag(tag);
    checkComponentTag(tag, ""form"");
    if (isRootForm()) {
        String method = getMethod().toLowerCase(Locale.ENGLISH);
        tag.put(""method"", method);
        String url = getActionUrl().toString();
        if (encodeUrlInHiddenFields()) {
            int i = url.indexOf('?');
            String action = (i > -1) ? url.substring(0, i) : """";
            tag.put(""action"", action);
                                        } else {
            tag.put(""action"", url);
        }
        if (isMultiPart()) {
            if (METHOD_GET.equalsIgnoreCase(method)) {
                log.warn(""Form with id '{}' is multipart. It should use method 'POST'!"", getId());
                tag.put(""method"", METHOD_POST.toLowerCase(Locale.ENGLISH));
            }
            tag.put(""enctype"", ""multipart/form-data"");
                                                                                                tag.put(""accept-charset"", getApplication().getRequestCycleSettings().getResponseRequestEncoding());
        } else {
                        String enctype = (String) tag.getAttributes().get(""enctype"");
            if (""multipart/form-data"".equalsIgnoreCase(enctype)) {
                                                setMultiPart(true);
            }
        }
    } else {
        tag.setName(""div"");
        tag.remove(""method"");
        tag.remove(""action"");
        tag.remove(""enctype"");
    }
}",0.9545454545454546,0.5885167464114831,0.6,0.5,0.75,0.03174603174603173,-0.6250880902043691,2.1666666666666665,-0.02631578947368421,0.3759340260368942
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1081_4ce4e3c9,3,"/**
 * Set a property
 *
 * @param propertyState
 * @return the set property
 */
@Nonnull
public PropertyDelegate setProperty(PropertyState propertyState, boolean exactTypeMatch, boolean setProtected) throws RepositoryException {
    Tree tree = getTree();
    String name = propertyState.getName();
    Type<?> type = propertyState.getType();
    PropertyState old = tree.getProperty(name);
    if (old != null && old.isArray() && !propertyState.isArray()) {
        throw new ValueFormatException(""Can not assign a single value to multi-valued property: "" + propertyState);
    }
    if (old != null && !old.isArray() && propertyState.isArray()) {
        throw new ValueFormatException(""Can not assign multiple values to single valued property: "" + propertyState);
    }
    Tree definition = findMatchingPropertyDefinition(getNodeTypes(tree), name, type, exactTypeMatch);
    if (definition == null) {
        throw new ConstraintViolationException(""No matching property definition: "" + propertyState);
    } else if (!setProtected && TreeUtil.getBoolean(definition, JCR_PROTECTED)) {
        throw new ConstraintViolationException(""Property is protected: "" + propertyState);
    }
    Type<?> requiredType = Type.fromString(TreeUtil.getString(definition, JCR_REQUIREDTYPE));
    if (requiredType != Type.UNDEFINED) {
        if (TreeUtil.getBoolean(definition, JCR_MULTIPLE)) {
            requiredType = requiredType.getArrayType();
        }
        propertyState = PropertyStates.convert(propertyState, requiredType);
    }
    tree.setProperty(propertyState);
    return new PropertyDelegate(sessionDelegate, tree, name);
}","/**
 * Set a property
 *
 * @param propertyState
 * @return the set property
 */
","@Nonnull
public PropertyDelegate setProperty(PropertyState propertyState, boolean exactTypeMatch, boolean setProtected) throws RepositoryException {
    Tree tree = getTree();
    String name = propertyState.getName();
    Type<?> type = propertyState.getType();
    PropertyState old = tree.getProperty(name);
    if (old != null && old.isArray() && !propertyState.isArray()) {
        throw new ValueFormatException(""Can not assign a single value to multi-valued property: "" + propertyState);
    }
    if (old != null && !old.isArray() && propertyState.isArray()) {
        throw new ValueFormatException(""Can not assign multiple values to single valued property: "" + propertyState);
    }
    Tree definition = findMatchingPropertyDefinition(getNodeTypes(tree), name, type, exactTypeMatch);
    if (definition == null) {
        throw new ConstraintViolationException(""No matching property definition: "" + propertyState);
    } else if (!setProtected && TreeUtil.getBoolean(definition, JCR_PROTECTED)) {
        throw new ConstraintViolationException(""Property is protected: "" + propertyState);
    }
    Type<?> requiredType = Type.fromString(TreeUtil.getString(definition, JCR_REQUIREDTYPE));
    if (requiredType != Type.UNDEFINED) {
        if (TreeUtil.getBoolean(definition, JCR_MULTIPLE)) {
            requiredType = requiredType.getArrayType();
        }
        propertyState = PropertyStates.convert(propertyState, requiredType);
    }
    tree.setProperty(propertyState);
    return new PropertyDelegate(sessionDelegate, tree, name);
}",0.6363636363636364,-0.13875598086124405,1.4,0.0,1.1666666666666667,0.9067460317460317,-0.5684284707540518,0.9166666666666666,-0.02631578947368421,1.8050333385199653
Lang,34,1,"/**
 * <p>
 * Returns <code>true</code> if the registry contains the given object.
 * Used by the reflection methods to avoid infinite loops.
 * </p>
 *
 * @param value
 *                  The object to lookup in the registry.
 * @return boolean <code>true</code> if the registry contains the given
 *             object.
 */
static boolean isRegistered(Object value) {
    Map<Object, Object> m = getRegistry();
    return m.containsKey(value);
}","/**
 * <p>
 * Returns <code>true</code> if the registry contains the given object.
 * Used by the reflection methods to avoid infinite loops.
 * </p>
 *
 * @param value
 *                  The object to lookup in the registry.
 * @return boolean <code>true</code> if the registry contains the given
 *             object.
 */
","static boolean isRegistered(Object value) {
    Map<Object, Object> m = getRegistry();
    return m.containsKey(value);
}",-0.45454545454545453,-0.47368421052631593,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.7930937279774485,-0.3333333333333333,2.3157894736842106,-0.16279340490885932
wicket,remotes/origin/bugs-dot-jar_WICKET-208_b224bad8,3,"/**
 *  @param updateInterval
 *             Duration between AJAX callbacks
 *  @return JS script
 */
protected final String getJsTimeoutCall(final Duration updateInterval) {
    return ""setTimeout(function() { "" + getCallbackScript(false, true) + "" }, "" + updateInterval.getMilliseconds() + "");"";
}","/**
 *  @param updateInterval
 *             Duration between AJAX callbacks
 *  @return JS script
 */
","protected final String getJsTimeoutCall(final Duration updateInterval) {
    return ""setTimeout(function() { "" + getCallbackScript(false, true) + "" }, "" + updateInterval.getMilliseconds() + "");"";
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.8909090909090904,-0.3333333333333333,2.6052631578947367,-0.16279340490885932
wicket,remotes/origin/bugs-dot-jar_WICKET-5418_e350f19e,1,"@SuppressWarnings(""unchecked"")
@Override
public void bind(Component component) {
    if (this.component != null) {
        throw new //
        IllegalStateException(""This validator has already been added to component: "" + this.component + "". This validator does not support reusing instances, please create a new one"");
    }
    if (!(component instanceof FormComponent)) {
        throw new IllegalStateException(getClass().getSimpleName() + "" can only be added to FormComponents"");
    }
    // TODO add a validation key that appends the type so we can have different messages for
    // @Size on String vs Collection - done but need to add a key for each superclass/interface
    this.component = (FormComponent<T>) component;
}",,"@SuppressWarnings(""unchecked"")
@Override
public void bind(Component component) {
    if (this.component != null) {
        throw new         IllegalStateException(""This validator has already been added to component: "" + this.component + "". This validator does not support reusing instances, please create a new one"");
    }
    if (!(component instanceof FormComponent)) {
        throw new IllegalStateException(getClass().getSimpleName() + "" can only be added to FormComponents"");
    }
            this.component = (FormComponent<T>) component;
}",-0.09090909090909091,0.02392344497607647,0.2,-0.5,-0.08333333333333333,0.2063492063492063,0.10754052149400978,-0.3333333333333333,0.02631578947368421,-0.002390461206871712
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-412_be2fdba7,1,"/**
 * Iterates over the source until an acceptable key/value pair is found.
 */
protected void findTop() {
    while (getSource().hasTop() && (negate == accept(getSource().getTopKey(), getSource().getTopValue()))) {
        try {
            getSource().next();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}","/**
 * Iterates over the source until an acceptable key/value pair is found.
 */
","protected void findTop() {
    while (getSource().hasTop() && (negate == accept(getSource().getTopKey(), getSource().getTopValue()))) {
        try {
            getSource().next();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}",-0.22727272727272727,0.6076555023923443,0.0,0.0,0.16666666666666666,-0.10119047619047619,0.3285412262156448,0.25,1.3157894736842106,-0.12066411945390523
Cli,23,1,"/**
 * Render the specified text and return the rendered Options
 * in a StringBuffer.
 *
 * @param sb The StringBuffer to place the rendered text into.
 * @param width The number of characters to display per line
 * @param nextLineTabStop The position on the next line for the first tab.
 * @param text The text to be rendered.
 *
 * @return the StringBuffer with the rendered Options contents.
 */
protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) {
    int pos = findWrapPos(text, width, 0);
    if (pos == -1) {
        sb.append(rtrim(text));
        return sb;
    }
    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);
    // all following lines must be padded with nextLineTabStop space
    // characters
    final String padding = createPadding(nextLineTabStop);
    while (true) {
        int lastPos = pos;
        text = padding + text.substring(pos).trim();
        pos = findWrapPos(text, width, 0);
        if (pos == -1) {
            sb.append(text);
            return sb;
        } else if (pos == lastPos) {
            throw new RuntimeException(""Text too long for line - throwing exception to avoid infinite loop [CLI-162]: "" + text);
        }
        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);
    }
}","/**
 * Render the specified text and return the rendered Options
 * in a StringBuffer.
 *
 * @param sb The StringBuffer to place the rendered text into.
 * @param width The number of characters to display per line
 * @param nextLineTabStop The position on the next line for the first tab.
 * @param text The text to be rendered.
 *
 * @return the StringBuffer with the rendered Options contents.
 */
","protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) {
    int pos = findWrapPos(text, width, 0);
    if (pos == -1) {
        sb.append(rtrim(text));
        return sb;
    }
    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);
            final String padding = createPadding(nextLineTabStop);
    while (true) {
        int lastPos = pos;
        text = padding + text.substring(pos).trim();
        pos = findWrapPos(text, width, 0);
        if (pos == -1) {
            sb.append(text);
            return sb;
        } else if (pos == lastPos) {
            throw new RuntimeException(""Text too long for line - throwing exception to avoid infinite loop [CLI-162]: "" + text);
        }
        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);
    }
}",0.3181818181818182,0.186602870813397,0.4,0.5,0.08333333333333333,0.8075396825396826,-0.32262156448202933,0.8333333333333334,-0.02631578947368421,0.8741965042098164
wicket,remotes/origin/bugs-dot-jar_WICKET-4173_84bbbf68,1,"/*
	 * TODO: simplify the code below. See WICKET-3347
	 */
@Override
public void respond(RequestCycle requestCycle) {
    Url currentUrl = requestCycle.getUrlRenderer().getBaseUrl();
    Url targetUrl = requestCycle.mapUrlFor(getRenderPageRequestHandler());
    //
    // the code below is little hairy but we have to handle 3 redirect policies,
    // 3 rendering strategies and two kind of requests (ajax and normal)
    //
    // try to get an already rendered buffered response for current URL
    BufferedWebResponse bufferedResponse = getAndRemoveBufferedResponse(currentUrl);
    boolean isAjax = isAjax(requestCycle);
    boolean shouldPreserveClientUrl = ((WebRequest) requestCycle.getRequest()).shouldPreserveClientUrl();
    if (bufferedResponse != null) {
        logger.warn(""The Buffered response should be handled by BufferedResponseRequestHandler"");
        // if there is saved response for this URL render it
        bufferedResponse.writeTo((WebResponse) requestCycle.getResponse());
    } else if (getRedirectPolicy() == RedirectPolicy.NEVER_REDIRECT || //
    (isOnePassRender() && isAjax == false) || (//
    !isAjax && //
    (targetUrl.equals(currentUrl) && !getPageProvider().isNewPageInstance() && !getPage().isPageStateless()) || //
    (targetUrl.equals(currentUrl) && isRedirectToRender())) || //
    shouldPreserveClientUrl) {
        // if the policy is never to redirect
        // or one pass render mode is on
        // or the targetUrl matches current url and the page is not stateless
        // or the targetUrl matches current url, page is stateless but it's redirect-to-render
        // or the request determines that the current url should be preserved
        // just render the page
        BufferedWebResponse response = renderPage(currentUrl, requestCycle);
        if (response != null) {
            response.writeTo((WebResponse) requestCycle.getResponse());
        }
    } else if (//
    getRedirectPolicy() == RedirectPolicy.ALWAYS_REDIRECT || //
    isRedirectToRender() || (isAjax && targetUrl.equals(currentUrl))) {
        // if target URL is different
        // and render policy is always-redirect or it's redirect-to-render
        redirectTo(targetUrl, requestCycle);
    } else if (//
    !targetUrl.equals(currentUrl) && (getPageProvider().isNewPageInstance() || (isSessionTemporary() && getPage().isPageStateless()))) {
        // if target URL is different and session is temporary and page is stateless
        // this is special case when page is stateless but there is no session so we can't
        // render it to buffer
        // alternatively if URLs are different and we have a page class and not an instance we
        // can redirect to the url which will instantiate the instance of us
        // note: if we had session here we would render the page to buffer and then redirect to
        // URL generated *after* page has been rendered (the statelessness may change during
        // render). this would save one redirect because now we have to render to URL generated
        // *before* page is rendered, render the page, get URL after render and if the URL is
        // different (meaning page is not stateless), save the buffer and redirect again (which
        // is pretty much what the next step does)
        redirectTo(targetUrl, requestCycle);
    } else {
        if (isRedirectToBuffer() == false && logger.isWarnEnabled()) {
            logger.warn(""Falling back to Redirect_To_Buffer render strategy because none of the conditions matched."");
        }
        // redirect to buffer
        BufferedWebResponse response = renderPage(targetUrl, requestCycle);
        if (response == null) {
            return;
        }
        // check if the url hasn't changed after page has been rendered
        // (i.e. the stateless flag might have changed which could result in different page url)
        Url targetUrl2 = requestCycle.mapUrlFor(getRenderPageRequestHandler());
        if (targetUrl.getSegments().equals(targetUrl2.getSegments()) == false) {
            // the amount of segments is different - generated relative URLs will not work, we
            // need to rerender the page. This shouldn't happen, but in theory it can - with
            // RequestHandlerEncoders that produce different URLs with different amount of
            // segments for stateless and stateful pages
            response = renderPage(targetUrl2, requestCycle);
        }
        if (currentUrl.equals(targetUrl2)) {
            // no need to redirect when both urls are exactly the same
            response.writeTo((WebResponse) requestCycle.getResponse());
        } else // if page is still stateless after render
        if (getPage().isPageStateless() && !enableRedirectForStatelessPage()) {
            // we don't want the redirect to happen for stateless page
            // example:
            // when a normal mounted stateful page is hit at /mount/point
            // wicket renders the page to buffer and redirects to /mount/point?12
            // but for stateless page the redirect is not necessary
            // also for listener interface on stateful page we want to redirect
            // after the listener is invoked, but on stateless page the user
            // must ask for redirect explicitly
            response.writeTo((WebResponse) requestCycle.getResponse());
        } else {
            storeBufferedResponse(targetUrl2, response);
            redirectTo(targetUrl2, requestCycle);
        }
    }
}",,"@Override
public void respond(RequestCycle requestCycle) {
    Url currentUrl = requestCycle.getUrlRenderer().getBaseUrl();
    Url targetUrl = requestCycle.mapUrlFor(getRenderPageRequestHandler());
                        BufferedWebResponse bufferedResponse = getAndRemoveBufferedResponse(currentUrl);
    boolean isAjax = isAjax(requestCycle);
    boolean shouldPreserveClientUrl = ((WebRequest) requestCycle.getRequest()).shouldPreserveClientUrl();
    if (bufferedResponse != null) {
        logger.warn(""The Buffered response should be handled by BufferedResponseRequestHandler"");
                bufferedResponse.writeTo((WebResponse) requestCycle.getResponse());
    } else if (getRedirectPolicy() == RedirectPolicy.NEVER_REDIRECT ||     (isOnePassRender() && isAjax == false) || (    !isAjax &&     (targetUrl.equals(currentUrl) && !getPageProvider().isNewPageInstance() && !getPage().isPageStateless()) ||     (targetUrl.equals(currentUrl) && isRedirectToRender())) ||     shouldPreserveClientUrl) {
                                                        BufferedWebResponse response = renderPage(currentUrl, requestCycle);
        if (response != null) {
            response.writeTo((WebResponse) requestCycle.getResponse());
        }
    } else if (    getRedirectPolicy() == RedirectPolicy.ALWAYS_REDIRECT ||     isRedirectToRender() || (isAjax && targetUrl.equals(currentUrl))) {
                        redirectTo(targetUrl, requestCycle);
    } else if (    !targetUrl.equals(currentUrl) && (getPageProvider().isNewPageInstance() || (isSessionTemporary() && getPage().isPageStateless()))) {
                                                                                                redirectTo(targetUrl, requestCycle);
    } else {
        if (isRedirectToBuffer() == false && logger.isWarnEnabled()) {
            logger.warn(""Falling back to Redirect_To_Buffer render strategy because none of the conditions matched."");
        }
                BufferedWebResponse response = renderPage(targetUrl, requestCycle);
        if (response == null) {
            return;
        }
                        Url targetUrl2 = requestCycle.mapUrlFor(getRenderPageRequestHandler());
        if (targetUrl.getSegments().equals(targetUrl2.getSegments()) == false) {
                                                            response = renderPage(targetUrl2, requestCycle);
        }
        if (currentUrl.equals(targetUrl2)) {
                        response.writeTo((WebResponse) requestCycle.getResponse());
        } else         if (getPage().isPageStateless() && !enableRedirectForStatelessPage()) {
                                                                                                            response.writeTo((WebResponse) requestCycle.getResponse());
        } else {
            storeBufferedResponse(targetUrl2, response);
            redirectTo(targetUrl2, requestCycle);
        }
    }
}",1.6363636363636365,0.1291866028708132,1.4,2.0,3.4166666666666665,1.3472222222222223,-0.8976744186046509,4.0,-0.02631578947368421,3.955909014943264
Compress,19,1,"/**
 * Parses the raw bytes read from the central directory extra
 * field with knowledge which fields are expected to be there.
 *
 * <p>All four fields inside the zip64 extended information extra
 * field are optional and must only be present if their corresponding
 * entry inside the central directory contains the correct magic
 * value.</p>
 */
public void reparseCentralDirectoryData(boolean hasUncompressedSize, boolean hasCompressedSize, boolean hasRelativeHeaderOffset, boolean hasDiskStart) throws ZipException {
    if (rawCentralDirectoryData != null) {
        int expectedLength = (hasUncompressedSize ? DWORD : 0) + (hasCompressedSize ? DWORD : 0) + (hasRelativeHeaderOffset ? DWORD : 0) + (hasDiskStart ? WORD : 0);
        if (rawCentralDirectoryData.length != expectedLength) {
            throw new ZipException(""central directory zip64 extended"" + "" information extra field's length"" + "" doesn't match central directory"" + "" data.  Expected length "" + expectedLength + "" but is "" + rawCentralDirectoryData.length);
        }
        int offset = 0;
        if (hasUncompressedSize) {
            size = new ZipEightByteInteger(rawCentralDirectoryData, offset);
            offset += DWORD;
        }
        if (hasCompressedSize) {
            compressedSize = new ZipEightByteInteger(rawCentralDirectoryData, offset);
            offset += DWORD;
        }
        if (hasRelativeHeaderOffset) {
            relativeHeaderOffset = new ZipEightByteInteger(rawCentralDirectoryData, offset);
            offset += DWORD;
        }
        if (hasDiskStart) {
            diskStart = new ZipLong(rawCentralDirectoryData, offset);
            offset += WORD;
        }
    }
}","/**
 * Parses the raw bytes read from the central directory extra
 * field with knowledge which fields are expected to be there.
 *
 * <p>All four fields inside the zip64 extended information extra
 * field are optional and must only be present if their corresponding
 * entry inside the central directory contains the correct magic
 * value.</p>
 */
","public void reparseCentralDirectoryData(boolean hasUncompressedSize, boolean hasCompressedSize, boolean hasRelativeHeaderOffset, boolean hasDiskStart) throws ZipException {
    if (rawCentralDirectoryData != null) {
        int expectedLength = (hasUncompressedSize ? DWORD : 0) + (hasCompressedSize ? DWORD : 0) + (hasRelativeHeaderOffset ? DWORD : 0) + (hasDiskStart ? WORD : 0);
        if (rawCentralDirectoryData.length != expectedLength) {
            throw new ZipException(""central directory zip64 extended"" + "" information extra field's length"" + "" doesn't match central directory"" + "" data.  Expected length "" + expectedLength + "" but is "" + rawCentralDirectoryData.length);
        }
        int offset = 0;
        if (hasUncompressedSize) {
            size = new ZipEightByteInteger(rawCentralDirectoryData, offset);
            offset += DWORD;
        }
        if (hasCompressedSize) {
            compressedSize = new ZipEightByteInteger(rawCentralDirectoryData, offset);
            offset += DWORD;
        }
        if (hasRelativeHeaderOffset) {
            relativeHeaderOffset = new ZipEightByteInteger(rawCentralDirectoryData, offset);
            offset += DWORD;
        }
        if (hasDiskStart) {
            diskStart = new ZipLong(rawCentralDirectoryData, offset);
            offset += WORD;
        }
    }
}",0.5,0.22009569377990432,1.6,0.0,1.0,0.6111111111111112,-0.4438336856941508,-0.5,-0.02631578947368421,0.7170438500948
Lang,32,1,"@Override
protected Set<IDKey> initialValue() {
    return new HashSet<IDKey>();
}",,"@Override
protected Set<IDKey> initialValue() {
    return new HashSet<IDKey>();
}",-0.45454545454545453,-0.6028708133971293,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.9134601832276249,-0.5,1.368421052631579,-0.16279340490885932
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-217_add180fb,1,"@Override
public void removeIterator(String tableName, String name, EnumSet<IteratorScope> scopes) throws AccumuloSecurityException, AccumuloException, TableNotFoundException {
    Map<String, String> copy = new HashMap<String, String>();
    for (Entry<String, String> property : this.getProperties(tableName)) {
        copy.put(property.getKey(), property.getValue());
    }
    for (IteratorScope scope : scopes) {
        String root = String.format(""%s%s.%s"", Property.TABLE_ITERATOR_PREFIX, scope.name().toLowerCase(), name);
        for (Entry<String, String> property : copy.entrySet()) {
            if (property.getKey().equals(root) || property.getKey().startsWith(root + "".opt.""))
                this.removeProperty(tableName, property.getKey());
        }
    }
}",,"@Override
public void removeIterator(String tableName, String name, EnumSet<IteratorScope> scopes) throws AccumuloSecurityException, AccumuloException, TableNotFoundException {
    Map<String, String> copy = new HashMap<String, String>();
    for (Entry<String, String> property : this.getProperties(tableName)) {
        copy.put(property.getKey(), property.getValue());
    }
    for (IteratorScope scope : scopes) {
        String root = String.format(""%s%s.%s"", Property.TABLE_ITERATOR_PREFIX, scope.name().toLowerCase(), name);
        for (Entry<String, String> property : copy.entrySet()) {
            if (property.getKey().equals(root) || property.getKey().startsWith(root + "".opt.""))
                this.removeProperty(tableName, property.getKey());
        }
    }
}",0.0,0.7033492822966506,0.2,0.0,0.0,0.02579365079365077,-0.1213530655391118,0.6666666666666666,-0.02631578947368421,0.16114751358609516
Lang,32,1,"/**
 * <p>
 * Registers the given object. Used by the reflection methods to avoid infinite loops.
 * </p>
 *
 * @param value
 *            The object to register.
 */
static void register(Object value) {
    getRegistry().add(new IDKey(value));
}","/**
 * <p>
 * Registers the given object. Used by the reflection methods to avoid infinite loops.
 * </p>
 *
 * @param value
 *            The object to register.
 */
","static void register(Object value) {
    getRegistry().add(new IDKey(value));
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,1.0132487667371384,-0.3333333333333333,2.6052631578947367,-0.16279340490885932
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-619_3b4b370e,0,"@Override
public Configuration reconfigure() {
    if (configFile != null) {
        try {
            final ConfigurationFactory.ConfigurationSource source = new ConfigurationFactory.ConfigurationSource(new FileInputStream(configFile), configFile);
            final XmlConfiguration config = new XmlConfiguration(source);
            if (config.rootElement == null) {
                return null;
            }
        } catch (final FileNotFoundException ex) {
            LOGGER.error(""Cannot locate file "" + configFile, ex);
        }
    }
    return null;
}",,"@Override
public Configuration reconfigure() {
    if (configFile != null) {
        try {
            final ConfigurationFactory.ConfigurationSource source = new ConfigurationFactory.ConfigurationSource(new FileInputStream(configFile), configFile);
            final XmlConfiguration config = new XmlConfiguration(source);
            if (config.rootElement == null) {
                return null;
            }
        } catch (final FileNotFoundException ex) {
            LOGGER.error(""Cannot locate file "" + configFile, ex);
        }
    }
    return null;
}",0.045454545454545456,0.9760765550239235,0.0,0.5,-0.08333333333333333,0.29563492063492064,-0.025229034531359995,-0.4166666666666667,0.2368421052631579,0.07706874592993433
camel,remotes/origin/bugs-dot-jar_CAMEL-3314_4badd9c5,1,"protected Processor createOutputsProcessor(RouteContext routeContext, Collection<ProcessorDefinition> outputs) throws Exception {
    List<Processor> list = new ArrayList<Processor>();
    for (ProcessorDefinition<?> output : outputs) {
        Processor processor = null;
        // at first use custom factory
        if (routeContext.getCamelContext().getProcessorFactory() != null) {
            processor = routeContext.getCamelContext().getProcessorFactory().createProcessor(routeContext, output);
        }
        // fallback to default implementation if factory did not create the processor
        if (processor == null) {
            processor = output.createProcessor(routeContext);
        }
        if (output instanceof Channel && processor == null) {
            continue;
        }
        Processor channel = wrapChannel(routeContext, processor, output);
        list.add(channel);
    }
    // if more than one output wrap than in a composite processor else just keep it as is
    Processor processor = null;
    if (!list.isEmpty()) {
        if (list.size() == 1) {
            processor = list.get(0);
        } else {
            processor = createCompositeProcessor(routeContext, list);
        }
    }
    return processor;
}",,"protected Processor createOutputsProcessor(RouteContext routeContext, Collection<ProcessorDefinition> outputs) throws Exception {
    List<Processor> list = new ArrayList<Processor>();
    for (ProcessorDefinition<?> output : outputs) {
        Processor processor = null;
                if (routeContext.getCamelContext().getProcessorFactory() != null) {
            processor = routeContext.getCamelContext().getProcessorFactory().createProcessor(routeContext, output);
        }
                if (processor == null) {
            processor = output.createProcessor(routeContext);
        }
        if (output instanceof Channel && processor == null) {
            continue;
        }
        Processor channel = wrapChannel(routeContext, processor, output);
        list.add(channel);
    }
        Processor processor = null;
    if (!list.isEmpty()) {
        if (list.size() == 1) {
            processor = list.get(0);
        } else {
            processor = createCompositeProcessor(routeContext, list);
        }
    }
    return processor;
}",0.5454545454545454,0.186602870813397,0.8,0.0,0.5,0.5853174603174603,-0.443551797040169,0.5,-0.02631578947368421,0.7387216680209538
camel,remotes/origin/bugs-dot-jar_CAMEL-7304_fa165d6b,3,"public Endpoint registerEndpoint(String uri, Endpoint endpoint) {
    if (endpoint instanceof InterceptSendToEndpoint) {
        // endpoint already decorated
        return endpoint;
    } else if (getUri() == null || EndpointHelper.matchEndpoint(routeContext.getCamelContext(), uri, getUri())) {
        // only proxy if the uri is matched decorate endpoint with our proxy
        // should be false by default
        boolean skip = isSkipSendToOriginalEndpoint();
        InterceptSendToEndpoint proxy = new InterceptSendToEndpoint(endpoint, skip);
        proxy.setDetour(detour);
        return proxy;
    } else {
        // no proxy so return regular endpoint
        return endpoint;
    }
}",,"public Endpoint registerEndpoint(String uri, Endpoint endpoint) {
    if (endpoint instanceof InterceptSendToEndpoint) {
                return endpoint;
    } else if (getUri() == null || EndpointHelper.matchEndpoint(routeContext.getCamelContext(), uri, getUri())) {
                        boolean skip = isSkipSendToOriginalEndpoint();
        InterceptSendToEndpoint proxy = new InterceptSendToEndpoint(endpoint, skip);
        proxy.setDetour(detour);
        return proxy;
    } else {
                return endpoint;
    }
}",-0.09090909090909091,-0.004784688995215422,-0.2,0.0,0.25,-0.03373015873015876,0.08949964763918242,0.0,0.21052631578947367,-0.04804204629933784
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1731_024e5d37,1,"private void copyNodeTypes(NodeBuilder root) throws RepositoryException {
    NodeTypeRegistry sourceRegistry = source.getNodeTypeRegistry();
    NodeBuilder system = root.child(JCR_SYSTEM);
    NodeBuilder types = system.child(JCR_NODE_TYPES);
    logger.info(""Copying registered node types"");
    for (Name name : sourceRegistry.getRegisteredNodeTypes()) {
        String oakName = getOakName(name);
        // skip built-in nodetypes (OAK-1235)
        if (!types.hasChildNode(oakName)) {
            QNodeTypeDefinition def = sourceRegistry.getNodeTypeDef(name);
            NodeBuilder type = types.child(oakName);
            copyNodeType(def, type);
        }
    }
}",,"private void copyNodeTypes(NodeBuilder root) throws RepositoryException {
    NodeTypeRegistry sourceRegistry = source.getNodeTypeRegistry();
    NodeBuilder system = root.child(JCR_SYSTEM);
    NodeBuilder types = system.child(JCR_NODE_TYPES);
    logger.info(""Copying registered node types"");
    for (Name name : sourceRegistry.getRegisteredNodeTypes()) {
        String oakName = getOakName(name);
                if (!types.hasChildNode(oakName)) {
            QNodeTypeDefinition def = sourceRegistry.getNodeTypeDef(name);
            NodeBuilder type = types.child(oakName);
            copyNodeType(def, type);
        }
    }
}",0.0,0.44976076555023925,-0.2,0.0,-0.16666666666666666,-0.0496031746031746,-0.06356589147286808,0.3333333333333333,0.10526315789473684,0.029222639073782718
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-668_60f64cc1,3,"/**
 * Actual writing occurs here.
 * <p/>
 * @param logEvent The LogEvent.
 */
@Override
public void append(final LogEvent logEvent) {
    if (!isStarted()) {
        throw new IllegalStateException(""AsyncAppender "" + getName() + "" is not active"");
    }
    if (!(logEvent instanceof Log4jLogEvent)) {
        // only know how to Serialize Log4jLogEvents
        return;
    }
    Log4jLogEvent coreEvent = (Log4jLogEvent) logEvent;
    boolean appendSuccessful = false;
    if (blocking) {
        if (isAppenderThread.get() == Boolean.TRUE && queue.remainingCapacity() == 0) {
            // LOG4J2-485: avoid deadlock that would result from trying
            // to add to a full queue from appender thread
            // queue is definitely not empty!
            coreEvent.setEndOfBatch(false);
            appendSuccessful = thread.callAppenders(coreEvent);
        } else {
            try {
                // wait for free slots in the queue
                queue.put(Log4jLogEvent.serialize(coreEvent, includeLocation));
                appendSuccessful = true;
            } catch (final InterruptedException e) {
                LOGGER.warn(""Interrupted while waiting for a free slot in the AsyncAppender LogEvent-queue {}"", getName());
            }
        }
    } else {
        appendSuccessful = queue.offer(Log4jLogEvent.serialize(coreEvent, includeLocation));
        if (!appendSuccessful) {
            error(""Appender "" + getName() + "" is unable to write primary appenders. queue is full"");
        }
    }
    if (!appendSuccessful && errorAppender != null) {
        errorAppender.callAppender(coreEvent);
    }
}","/**
 * Actual writing occurs here.
 * <p/>
 * @param logEvent The LogEvent.
 */
","@Override
public void append(final LogEvent logEvent) {
    if (!isStarted()) {
        throw new IllegalStateException(""AsyncAppender "" + getName() + "" is not active"");
    }
    if (!(logEvent instanceof Log4jLogEvent)) {
                return;
    }
    Log4jLogEvent coreEvent = (Log4jLogEvent) logEvent;
    boolean appendSuccessful = false;
    if (blocking) {
        if (isAppenderThread.get() == Boolean.TRUE && queue.remainingCapacity() == 0) {
                                                coreEvent.setEndOfBatch(false);
            appendSuccessful = thread.callAppenders(coreEvent);
        } else {
            try {
                                queue.put(Log4jLogEvent.serialize(coreEvent, includeLocation));
                appendSuccessful = true;
            } catch (final InterruptedException e) {
                LOGGER.warn(""Interrupted while waiting for a free slot in the AsyncAppender LogEvent-queue {}"", getName());
            }
        }
    } else {
        appendSuccessful = queue.offer(Log4jLogEvent.serialize(coreEvent, includeLocation));
        if (!appendSuccessful) {
            error(""Appender "" + getName() + "" is unable to write primary appenders. queue is full"");
        }
    }
    if (!appendSuccessful && errorAppender != null) {
        errorAppender.callAppender(coreEvent);
    }
}",0.8181818181818182,0.7129186602870815,1.0,0.5,0.8333333333333334,0.5793650793650793,-0.5588442565186751,0.75,-0.02631578947368421,0.8237593863637671
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1788_dd3437d4,3,"/**
 * Get the seen-at revision from the revision range.
 * <p>
 * <ul>
 *     <li>
 *         {@code null} if the revision is older than the earliest range
 *     </li>
 *     <li>
 *         if the revision is newer than the lower bound of the newest
 *         range, then {@link #NEWEST} is returned for a local cluster
 *         revision and {@link #FUTURE} for a foreign cluster revision.
 *     </li>
 *     <li>
 *         if the revision matches the lower seen-at bound of a range,
 *         then this seen-at revision is returned.
 *     </li>
 *     <li>
 *         otherwise the lower bound seen-at revision of next higher
 *         range is returned.
 *     </li>
 * </ul>
 *
 * @param r the revision
 * @return the seen-at revision or {@code null} if the revision is older
 *          than the earliest range.
 */
Revision getRevisionSeen(Revision r) {
    List<RevisionRange> list = map.get(r.getClusterId());
    if (list == null) {
        if (r.getTimestamp() <= oldestTimestamp) {
            // old revision with already purged range
            return null;
        }
        if (r.getClusterId() != currentClusterNodeId) {
            // see also OAK-1170
            return FUTURE;
        }
        return null;
    }
    // at the end of the list)
    for (int i = list.size() - 1; i >= 0; i--) {
        RevisionRange range = list.get(i);
        int compare = r.compareRevisionTime(range.revision);
        if (compare == 0) {
            return range.seenAt;
        } else if (compare > 0) {
            if (i == list.size() - 1) {
                // newer than the newest range
                if (r.getClusterId() == currentClusterNodeId) {
                    // newer than all others, except for FUTURE
                    return NEWEST;
                }
                // happens in the future (not visible yet)
                return FUTURE;
            } else {
                // there is a newer range
                return list.get(i + 1).seenAt;
            }
        }
    }
    return null;
}","/**
 * Get the seen-at revision from the revision range.
 * <p>
 * <ul>
 *     <li>
 *         {@code null} if the revision is older than the earliest range
 *     </li>
 *     <li>
 *         if the revision is newer than the lower bound of the newest
 *         range, then {@link #NEWEST} is returned for a local cluster
 *         revision and {@link #FUTURE} for a foreign cluster revision.
 *     </li>
 *     <li>
 *         if the revision matches the lower seen-at bound of a range,
 *         then this seen-at revision is returned.
 *     </li>
 *     <li>
 *         otherwise the lower bound seen-at revision of next higher
 *         range is returned.
 *     </li>
 * </ul>
 *
 * @param r the revision
 * @return the seen-at revision or {@code null} if the revision is older
 *          than the earliest range.
 */
","Revision getRevisionSeen(Revision r) {
    List<RevisionRange> list = map.get(r.getClusterId());
    if (list == null) {
        if (r.getTimestamp() <= oldestTimestamp) {
                        return null;
        }
        if (r.getClusterId() != currentClusterNodeId) {
                        return FUTURE;
        }
        return null;
    }
        for (int i = list.size() - 1; i >= 0; i--) {
        RevisionRange range = list.get(i);
        int compare = r.compareRevisionTime(range.revision);
        if (compare == 0) {
            return range.seenAt;
        } else if (compare > 0) {
            if (i == list.size() - 1) {
                                if (r.getClusterId() == currentClusterNodeId) {
                                        return NEWEST;
                }
                                return FUTURE;
            } else {
                                return list.get(i + 1).seenAt;
            }
        }
    }
    return null;
}",0.6818181818181818,0.909090909090909,1.0,1.5,0.9166666666666666,1.5714285714285714,-0.49372797744890756,0.3333333333333333,-0.02631578947368421,1.5998916570137673
wicket,remotes/origin/bugs-dot-jar_WICKET-16_6c5083b4,1,"/**
 *  Encode a page class target.
 *
 *  If you override this method to behave different then also
 *  {@link #addBookmarkablePageParameters(Request, RequestParameters)} should
 *  be overridden to by in sync with that behaviour.
 *
 *  @param requestCycle
 *             the current request cycle
 *  @param requestTarget
 *             the target to encode
 *  @return the encoded url
 */
protected CharSequence encode(RequestCycle requestCycle, IBookmarkablePageRequestTarget requestTarget) {
    // Begin encoding URL
    final AppendingStringBuffer url = new AppendingStringBuffer(64);
    url.append(urlPrefix(requestCycle));
    // Get page Class
    final Class pageClass = requestTarget.getPageClass();
    final Application application = Application.get();
    // Find pagemap name
    String pageMapName = requestTarget.getPageMapName();
    if (pageMapName == null) {
        IRequestTarget currentTarget = requestCycle.getRequestTarget();
        if (currentTarget instanceof IPageRequestTarget) {
            Page currentPage = ((IPageRequestTarget) currentTarget).getPage();
            final PageMap pageMap = currentPage.getPageMap();
            if (pageMap.isDefault()) {
                pageMapName = """";
            } else {
                pageMapName = pageMap.getName();
            }
        } else {
            pageMapName = """";
        }
    }
    boolean firstParameter = true;
    if (!application.getHomePage().equals(pageClass) || !"""".equals(pageMapName)) {
        firstParameter = false;
        url.append('?');
        url.append(WebRequestCodingStrategy.BOOKMARKABLE_PAGE_PARAMETER_NAME);
        url.append('=');
        // Add <page-map-name>:<bookmarkable-page-class>
        url.append(pageMapName + Component.PATH_SEPARATOR + pageClass.getName());
    }
    // Get page parameters
    final PageParameters parameters = requestTarget.getPageParameters();
    if (parameters != null) {
        for (final Iterator iterator = parameters.keySet().iterator(); iterator.hasNext(); ) {
            final String key = (String) iterator.next();
            final String value = parameters.getString(key);
            if (value != null) {
                String escapedValue = value;
                try {
                    escapedValue = URLEncoder.encode(escapedValue, application.getRequestCycleSettings().getResponseRequestEncoding());
                } catch (UnsupportedEncodingException ex) {
                    log.error(ex.getMessage(), ex);
                }
                if (!firstParameter) {
                    url.append('&');
                } else {
                    firstParameter = false;
                    url.append('?');
                }
                url.append(key);
                url.append('=');
                url.append(escapedValue);
            }
        }
    }
    return requestCycle.getOriginalResponse().encodeURL(url);
}","/**
 *  Encode a page class target.
 *
 *  If you override this method to behave different then also
 *  {@link #addBookmarkablePageParameters(Request, RequestParameters)} should
 *  be overridden to by in sync with that behaviour.
 *
 *  @param requestCycle
 *             the current request cycle
 *  @param requestTarget
 *             the target to encode
 *  @return the encoded url
 */
","protected CharSequence encode(RequestCycle requestCycle, IBookmarkablePageRequestTarget requestTarget) {
        final AppendingStringBuffer url = new AppendingStringBuffer(64);
    url.append(urlPrefix(requestCycle));
        final Class pageClass = requestTarget.getPageClass();
    final Application application = Application.get();
        String pageMapName = requestTarget.getPageMapName();
    if (pageMapName == null) {
        IRequestTarget currentTarget = requestCycle.getRequestTarget();
        if (currentTarget instanceof IPageRequestTarget) {
            Page currentPage = ((IPageRequestTarget) currentTarget).getPage();
            final PageMap pageMap = currentPage.getPageMap();
            if (pageMap.isDefault()) {
                pageMapName = """";
            } else {
                pageMapName = pageMap.getName();
            }
        } else {
            pageMapName = """";
        }
    }
    boolean firstParameter = true;
    if (!application.getHomePage().equals(pageClass) || !"""".equals(pageMapName)) {
        firstParameter = false;
        url.append('?');
        url.append(WebRequestCodingStrategy.BOOKMARKABLE_PAGE_PARAMETER_NAME);
        url.append('=');
                url.append(pageMapName + Component.PATH_SEPARATOR + pageClass.getName());
    }
        final PageParameters parameters = requestTarget.getPageParameters();
    if (parameters != null) {
        for (final Iterator iterator = parameters.keySet().iterator(); iterator.hasNext(); ) {
            final String key = (String) iterator.next();
            final String value = parameters.getString(key);
            if (value != null) {
                String escapedValue = value;
                try {
                    escapedValue = URLEncoder.encode(escapedValue, application.getRequestCycleSettings().getResponseRequestEncoding());
                } catch (UnsupportedEncodingException ex) {
                    log.error(ex.getMessage(), ex);
                }
                if (!firstParameter) {
                    url.append('&');
                } else {
                    firstParameter = false;
                    url.append('?');
                }
                url.append(key);
                url.append('=');
                url.append(escapedValue);
            }
        }
    }
    return requestCycle.getOriginalResponse().encodeURL(url);
}",1.8181818181818181,1.2679425837320573,1.2,1.0,1.1666666666666667,0.8849206349206349,-0.9315010570824522,2.5,-0.02631578947368421,2.95112693994456
Csv,13,3,"private void print(final Object object, final CharSequence value, final int offset, final int len) throws IOException {
    if (!newRecord) {
        out.append(format.getDelimiter());
    }
    if (format.isQuoteCharacterSet()) {
        // the original object is needed so can check for Number
        printAndQuote(object, value, offset, len);
    } else if (format.isEscapeCharacterSet()) {
        printAndEscape(value, offset, len);
    } else {
        out.append(value, offset, offset + len);
    }
    newRecord = false;
}",,"private void print(final Object object, final CharSequence value, final int offset, final int len) throws IOException {
    if (!newRecord) {
        out.append(format.getDelimiter());
    }
    if (format.isQuoteCharacterSet()) {
                printAndQuote(object, value, offset, len);
    } else if (format.isEscapeCharacterSet()) {
        printAndEscape(value, offset, len);
    } else {
        out.append(value, offset, offset + len);
    }
    newRecord = false;
}",-0.045454545454545456,-0.16267942583732073,0.0,0.0,0.08333333333333333,0.0,0.028047921071177005,0.08333333333333333,-0.02631578947368421,-0.01887703647355105
Closure,49,3,"@Override
public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
    switch(n.getType()) {
        case Token.FUNCTION:
            {
                // Add recursive function name, if needed.
                // NOTE: ""enterScope"" is called after we need to pick up this name.
                Renamer renamer = nameStack.peek().forChildScope();
                // If needed, add the function recursive name.
                String name = n.getFirstChild().getString();
                if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) {
                    renamer.addDeclaredName(name);
                }
                // Add the function parameters
                // Add the function body declarations
                nameStack.push(renamer);
            }
            break;
        case Token.CATCH:
            {
                Renamer renamer = nameStack.peek().forChildScope();
                String name = n.getFirstChild().getString();
                renamer.addDeclaredName(name);
                nameStack.push(renamer);
            }
            break;
    }
    return true;
}",,"@Override
public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
    switch(n.getType()) {
        case Token.FUNCTION:
            {
                                                Renamer renamer = nameStack.peek().forChildScope();
                                String name = n.getFirstChild().getString();
                if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) {
                    renamer.addDeclaredName(name);
                }
                                                nameStack.push(renamer);
            }
            break;
        case Token.CATCH:
            {
                Renamer renamer = nameStack.peek().forChildScope();
                String name = n.getFirstChild().getString();
                renamer.addDeclaredName(name);
                nameStack.push(renamer);
            }
            break;
    }
    return true;
}",0.45454545454545453,1.401913875598086,0.4,0.5,0.5833333333333334,0.44246031746031755,-0.36687808315715287,0.75,-0.02631578947368421,0.4754113287575709
maven,remotes/origin/bugs-dot-jar_MNG-4915_1c3abfba,1,"private boolean validatePluginVersion(String fieldName, ModelProblemCollector problems, String string, String sourceHint, InputLocationTracker tracker, ModelBuildingRequest request) {
    Severity errOn30 = getSeverity(request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0);
    if (string == null) {
        // NOTE: The check for missing plugin versions is handled directly by the model builder
        return true;
    }
    if (string.length() > 0 && !hasExpression(string) && !""RELEASE"".equals(string) && !""LATEST"".equals(string)) {
        return true;
    }
    addViolation(problems, errOn30, fieldName, sourceHint, ""must be a valid version but is '"" + string + ""'."", tracker);
    return false;
}",,"private boolean validatePluginVersion(String fieldName, ModelProblemCollector problems, String string, String sourceHint, InputLocationTracker tracker, ModelBuildingRequest request) {
    Severity errOn30 = getSeverity(request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0);
    if (string == null) {
                return true;
    }
    if (string.length() > 0 && !hasExpression(string) && !""RELEASE"".equals(string) && !""LATEST"".equals(string)) {
        return true;
    }
    addViolation(problems, errOn30, fieldName, sourceHint, ""must be a valid version but is '"" + string + ""'."", tracker);
    return false;
}",-0.13636363636363635,-0.2775119617224881,-0.2,-0.5,0.4166666666666667,0.5912698412698414,0.037350246652572305,0.0,-0.02631578947368421,0.4591829325219134
Math,89,1,"/**
 * Adds 1 to the frequency count for v.
 * <p>
 * If other objects have already been added to this Frequency, v must
 * be comparable to those that have already been added.
 * </p>
 *
 * @param v the value to add.
 * @throws IllegalArgumentException if <code>v</code> is not Comparable,
 *         or is not comparable with previous entries
 * @deprecated use {@link #addValue(Comparable)} instead
 */
@Deprecated
public void addValue(Object v) {
    addValue((Comparable<?>) v);
}","/**
 * Adds 1 to the frequency count for v.
 * <p>
 * If other objects have already been added to this Frequency, v must
 * be comparable to those that have already been added.
 * </p>
 *
 * @param v the value to add.
 * @throws IllegalArgumentException if <code>v</code> is not Comparable,
 *         or is not comparable with previous entries
 * @deprecated use {@link #addValue(Comparable)} instead
 */
","@Deprecated
public void addValue(Object v) {
    addValue((Comparable<?>) v);
}",-0.45454545454545453,-0.6028708133971293,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.8940098661028892,-0.4166666666666667,2.5,-0.16279340490885932
camel,remotes/origin/bugs-dot-jar_CAMEL-3394_18e1a142,3,"public boolean process(Exchange exchange, AsyncCallback callback) {
    final AtomicExchange result = new AtomicExchange();
    final Iterable<ProcessorExchangePair> pairs;
    // so use try .. catch to cater for this
    try {
        boolean sync = true;
        pairs = createProcessorExchangePairs(exchange);
        if (isParallelProcessing()) {
            // ensure an executor is set when running in parallel
            ObjectHelper.notNull(executorService, ""executorService"", this);
            doProcessParallel(exchange, result, pairs, isStreaming(), callback);
        } else {
            sync = doProcessSequential(exchange, result, pairs, callback);
        }
        if (!sync) {
            // so we break out now, then the callback will be invoked which then continue routing from where we left here
            return false;
        }
    } catch (Throwable e) {
        exchange.setException(e);
        // and do the done work
        doDone(exchange, null, callback, true);
        return true;
    }
    // multicasting was processed successfully
    // and do the done work
    Exchange subExchange = result.get() != null ? result.get() : null;
    doDone(exchange, subExchange, callback, true);
    return true;
}",,"public boolean process(Exchange exchange, AsyncCallback callback) {
    final AtomicExchange result = new AtomicExchange();
    final Iterable<ProcessorExchangePair> pairs;
        try {
        boolean sync = true;
        pairs = createProcessorExchangePairs(exchange);
        if (isParallelProcessing()) {
                        ObjectHelper.notNull(executorService, ""executorService"", this);
            doProcessParallel(exchange, result, pairs, isStreaming(), callback);
        } else {
            sync = doProcessSequential(exchange, result, pairs, callback);
        }
        if (!sync) {
                        return false;
        }
    } catch (Throwable e) {
        exchange.setException(e);
                doDone(exchange, null, callback, true);
        return true;
    }
            Exchange subExchange = result.get() != null ? result.get() : null;
    doDone(exchange, subExchange, callback, true);
    return true;
}",0.45454545454545453,0.1961722488038276,0.2,0.0,0.08333333333333333,0.05158730158730159,-0.36039464411557415,0.4166666666666667,-0.02631578947368421,0.16692426940520846
maven,remotes/origin/bugs-dot-jar_MNG-5209_87884c7b,3,"public List<String> getCompileClasspathElements() throws DependencyResolutionRequiredException {
    List<String> list = new ArrayList<String>(getArtifacts().size() + 1);
    list.add(getBuild().getOutputDirectory());
    for (Artifact a : getArtifacts()) {
        if (a.getArtifactHandler().isAddedToClasspath()) {
            // TODO: let the scope handler deal with this
            if (Artifact.SCOPE_COMPILE.equals(a.getScope()) || Artifact.SCOPE_PROVIDED.equals(a.getScope()) || Artifact.SCOPE_SYSTEM.equals(a.getScope())) {
                addArtifactPath(a, list);
            }
        }
    }
    return list;
}",,"public List<String> getCompileClasspathElements() throws DependencyResolutionRequiredException {
    List<String> list = new ArrayList<String>(getArtifacts().size() + 1);
    list.add(getBuild().getOutputDirectory());
    for (Artifact a : getArtifacts()) {
        if (a.getArtifactHandler().isAddedToClasspath()) {
                        if (Artifact.SCOPE_COMPILE.equals(a.getScope()) || Artifact.SCOPE_PROVIDED.equals(a.getScope()) || Artifact.SCOPE_SYSTEM.equals(a.getScope())) {
                addArtifactPath(a, list);
            }
        }
    }
    return list;
}",-0.09090909090909091,0.8421052631578947,0.0,0.5,0.3333333333333333,-0.0019841269841269858,0.0319943622269205,0.75,0.0,0.01528097139860421
commons-math,remotes/origin/bugs-dot-jar_MATH-293_59a0da9c,1,"/**
 * Returns the offset of the extra decision variable added when there is a
 * negative decision variable in the original problem.
 * @return the offset of x-
 */
protected final int getNegativeDecisionVariableOffset() {
    return getNumObjectiveFunctions() + getOriginalNumDecisionVariables();
}","/**
 * Returns the offset of the extra decision variable added when there is a
 * negative decision variable in the original problem.
 * @return the offset of x-
 */
","protected final int getNegativeDecisionVariableOffset() {
    return getNumObjectiveFunctions() + getOriginalNumDecisionVariables();
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,1.1099365750528538,-0.3333333333333333,2.6052631578947367,-0.16279340490885932
Math,48,1,"/**
 * {@inheritDoc}
 */
protected final double doSolve() {
    // Get initial solution
    double x0 = getMin();
    double x1 = getMax();
    double f0 = computeObjectiveValue(x0);
    double f1 = computeObjectiveValue(x1);
    // regardless of the allowed solutions.
    if (f0 == 0.0) {
        return x0;
    }
    if (f1 == 0.0) {
        return x1;
    }
    // Verify bracketing of initial solution.
    verifyBracketing(x0, x1);
    // Get accuracies.
    final double ftol = getFunctionValueAccuracy();
    final double atol = getAbsoluteAccuracy();
    final double rtol = getRelativeAccuracy();
    // Keep track of inverted intervals, meaning that the left bound is
    // larger than the right bound.
    boolean inverted = false;
    // Keep finding better approximations.
    while (true) {
        // Calculate the next approximation.
        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
        final double fx = computeObjectiveValue(x);
        // we can return it regardless of the allowed solutions.
        if (fx == 0.0) {
            return x;
        }
        // Update the bounds with the new approximation.
        if (f1 * fx < 0) {
            // The value of x1 has switched to the other bound, thus inverting
            // the interval.
            x0 = x1;
            f0 = f1;
            inverted = !inverted;
        } else {
            switch(method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                    break;
                case REGULA_FALSI:
                    // for the maximum number of iterations to be exceeded.
                    break;
                default:
                    // Should never happen.
                    throw new MathInternalError();
            }
        }
        // Update from [x0, x1] to [x0, x].
        x1 = x;
        f1 = fx;
        // the root than we already are.
        if (FastMath.abs(f1) <= ftol) {
            switch(allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
            }
        }
        // are satisfied with the current approximation.
        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {
            switch(allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
            }
        }
    }
}","/**
 * {@inheritDoc}
 */
","protected final double doSolve() {
        double x0 = getMin();
    double x1 = getMax();
    double f0 = computeObjectiveValue(x0);
    double f1 = computeObjectiveValue(x1);
        if (f0 == 0.0) {
        return x0;
    }
    if (f1 == 0.0) {
        return x1;
    }
        verifyBracketing(x0, x1);
        final double ftol = getFunctionValueAccuracy();
    final double atol = getAbsoluteAccuracy();
    final double rtol = getRelativeAccuracy();
            boolean inverted = false;
        while (true) {
                final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
        final double fx = computeObjectiveValue(x);
                if (fx == 0.0) {
            return x;
        }
                if (f1 * fx < 0) {
                                    x0 = x1;
            f0 = f1;
            inverted = !inverted;
        } else {
            switch(method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                    break;
                case REGULA_FALSI:
                                        break;
                default:
                                        throw new MathInternalError();
            }
        }
                x1 = x;
        f1 = fx;
                if (FastMath.abs(f1) <= ftol) {
            switch(allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
            }
        }
                if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {
            switch(allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
            }
        }
    }
}",3.3636363636363638,1.727272727272727,7.6,1.5,3.1666666666666665,2.8194444444444446,-1.3371388301620857,0.5833333333333334,-0.02631578947368421,6.527303008823037
camel,remotes/origin/bugs-dot-jar_CAMEL-9032_108d94f7,1,"/**
 * Validates whether the given method is a valid candidate for Camel Bean Binding.
 *
 * @param clazz   the class
 * @param method  the method
 * @return true if valid, false to skip the method
 */
protected boolean isValidMethod(Class<?> clazz, Method method) {
    // must not be in the excluded list
    for (Method excluded : EXCLUDED_METHODS) {
        if (ObjectHelper.isOverridingMethod(excluded, method)) {
            // the method is overriding an excluded method so its not valid
            return false;
        }
    }
    // must be a public method
    if (!Modifier.isPublic(method.getModifiers())) {
        return false;
    }
    // must not be abstract
    if (Modifier.isAbstract(method.getModifiers())) {
        return false;
    }
    // return type must not be an Exchange and it should not be a bridge method
    if ((method.getReturnType() != null && Exchange.class.isAssignableFrom(method.getReturnType())) || method.isBridge()) {
        return false;
    }
    return true;
}","/**
 * Validates whether the given method is a valid candidate for Camel Bean Binding.
 *
 * @param clazz   the class
 * @param method  the method
 * @return true if valid, false to skip the method
 */
","protected boolean isValidMethod(Class<?> clazz, Method method) {
        for (Method excluded : EXCLUDED_METHODS) {
        if (ObjectHelper.isOverridingMethod(excluded, method)) {
                        return false;
        }
    }
        if (!Modifier.isPublic(method.getModifiers())) {
        return false;
    }
        if (Modifier.isAbstract(method.getModifiers())) {
        return false;
    }
        if ((method.getReturnType() != null && Exchange.class.isAssignableFrom(method.getReturnType())) || method.isBridge()) {
        return false;
    }
    return true;
}",0.13636363636363635,0.0,0.4,0.0,0.8333333333333334,0.29563492063492064,-0.11712473572938689,0.25,-0.02631578947368421,0.11553281121234649
Closure,149,2,"/**
 * Sets options based on the configurations set flags API.
 * Called during the run() run() method.
 * If you want to ignore the flags API, or intepret flags your own way,
 * then you should override this method.
 */
protected final void setRunOptions(CompilerOptions options) throws FlagUsageException, IOException {
    DiagnosticGroups diagnosticGroups = getDiagnosticGroups();
    diagnosticGroups.setWarningLevels(options, config.jscompError, CheckLevel.ERROR);
    diagnosticGroups.setWarningLevels(options, config.jscompWarning, CheckLevel.WARNING);
    diagnosticGroups.setWarningLevels(options, config.jscompOff, CheckLevel.OFF);
    createDefineReplacements(config.define, options);
    options.manageClosureDependencies = config.manageClosureDependencies;
    options.devMode = config.jscompDevMode;
    options.setCodingConvention(config.codingConvention);
    options.setSummaryDetailLevel(config.summaryDetailLevel);
    inputCharset = getInputCharset();
    if (config.jsOutputFile.length() > 0) {
        options.jsOutputFile = config.jsOutputFile;
    }
    if (config.createSourceMap.length() > 0) {
        options.sourceMapOutputPath = config.createSourceMap;
    }
    options.sourceMapDetailLevel = config.sourceMapDetailLevel;
    if (!config.variableMapInputFile.equals("""")) {
        options.inputVariableMapSerialized = VariableMap.load(config.variableMapInputFile).toBytes();
    }
    if (!config.propertyMapInputFile.equals("""")) {
        options.inputPropertyMapSerialized = VariableMap.load(config.propertyMapInputFile).toBytes();
    }
}","/**
 * Sets options based on the configurations set flags API.
 * Called during the run() run() method.
 * If you want to ignore the flags API, or intepret flags your own way,
 * then you should override this method.
 */
","protected final void setRunOptions(CompilerOptions options) throws FlagUsageException, IOException {
    DiagnosticGroups diagnosticGroups = getDiagnosticGroups();
    diagnosticGroups.setWarningLevels(options, config.jscompError, CheckLevel.ERROR);
    diagnosticGroups.setWarningLevels(options, config.jscompWarning, CheckLevel.WARNING);
    diagnosticGroups.setWarningLevels(options, config.jscompOff, CheckLevel.OFF);
    createDefineReplacements(config.define, options);
    options.manageClosureDependencies = config.manageClosureDependencies;
    options.devMode = config.jscompDevMode;
    options.setCodingConvention(config.codingConvention);
    options.setSummaryDetailLevel(config.summaryDetailLevel);
    inputCharset = getInputCharset();
    if (config.jsOutputFile.length() > 0) {
        options.jsOutputFile = config.jsOutputFile;
    }
    if (config.createSourceMap.length() > 0) {
        options.sourceMapOutputPath = config.createSourceMap;
    }
    options.sourceMapDetailLevel = config.sourceMapDetailLevel;
    if (!config.variableMapInputFile.equals("""")) {
        options.inputVariableMapSerialized = VariableMap.load(config.variableMapInputFile).toBytes();
    }
    if (!config.propertyMapInputFile.equals("""")) {
        options.inputPropertyMapSerialized = VariableMap.load(config.propertyMapInputFile).toBytes();
    }
}",0.5,-0.5071770334928232,0.2,-0.5,0.25,0.059523809523809534,-0.46102889358703314,0.8333333333333334,-0.02631578947368421,0.4225952755542492
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-2742_1f7dd2d5,1,"@Override
public String next() {
    return super.next().toString();
}",,"@Override
public String next() {
    return super.next().toString();
}",-0.45454545454545453,-0.6028708133971293,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.9517970401691334,-0.3333333333333333,1.4999999999999998,-0.16279340490885932
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-185_7fe28a0e,3,"/**
 * @see Node#setProperty(String, javax.jcr.Value, int)
 */
@Override
@Nonnull
public Property setProperty(String jcrName, Value value, int type) throws RepositoryException {
    checkStatus();
    int targetType = getTargetType(value, type);
    Value targetValue = ValueHelper.convert(value, targetType, getValueFactory());
    if (value == null) {
        Property p = getProperty(jcrName);
        p.remove();
        return p;
    } else {
        String oakName = sessionDelegate.getOakPathOrThrow(jcrName);
        CoreValue oakValue = ValueConverter.toCoreValue(targetValue, sessionDelegate);
        return new PropertyImpl(dlg.setProperty(oakName, oakValue));
    }
}","/**
 * @see Node#setProperty(String, javax.jcr.Value, int)
 */
","@Override
@Nonnull
public Property setProperty(String jcrName, Value value, int type) throws RepositoryException {
    checkStatus();
    int targetType = getTargetType(value, type);
    Value targetValue = ValueHelper.convert(value, targetType, getValueFactory());
    if (value == null) {
        Property p = getProperty(jcrName);
        p.remove();
        return p;
    } else {
        String oakName = sessionDelegate.getOakPathOrThrow(jcrName);
        CoreValue oakValue = ValueConverter.toCoreValue(targetValue, sessionDelegate);
        return new PropertyImpl(dlg.setProperty(oakName, oakValue));
    }
}",0.09090909090909091,0.06220095693779899,-0.4,-0.5,-0.25,-0.05753968253968254,-0.12332628611698376,0.25,0.0,0.031661508848971
wicket,remotes/origin/bugs-dot-jar_WICKET-1677_01a3dd66,1,"/**
 *  @see org.apache.wicket.ajax.AbstractDefaultAjaxBehavior#renderHead(org.apache.wicket.markup.html.IHeaderResponse)
 */
@Override
public void renderHead(IHeaderResponse response) {
    super.renderHead(response);
    AppendingStringBuffer asb = new AppendingStringBuffer();
    asb.append(""function attachChoiceHandlers(markupId, callbackScript) {\n"");
    asb.append("" var inputNodes = wicketGet(markupId).getElementsByTagName('input');\n"");
    asb.append("" for (var i = 0 ; i < inputNodes.length ; i ++) {\n"");
    asb.append("" var inputNode = inputNodes[i];\n"");
    asb.append("" if (!inputNode.type) continue;\n"");
    asb.append("" var inputType = inputNode.type.toLowerCase();\n"");
    asb.append("" if (inputType == 'checkbox' || inputType == 'radio') {\n"");
    asb.append("" Wicket.Event.add(inputNode, 'click', callbackScript);\n"");
    asb.append("" }\n"");
    asb.append("" }\n"");
    asb.append(""}\n"");
    response.renderJavascript(asb, ""attachChoice"");
    response.renderOnLoadJavascript(""attachChoiceHandlers('"" + getComponent().getMarkupId() + ""', function() {"" + getEventHandler() + ""});"");
}","/**
 *  @see org.apache.wicket.ajax.AbstractDefaultAjaxBehavior#renderHead(org.apache.wicket.markup.html.IHeaderResponse)
 */
","@Override
public void renderHead(IHeaderResponse response) {
    super.renderHead(response);
    AppendingStringBuffer asb = new AppendingStringBuffer();
    asb.append(""function attachChoiceHandlers(markupId, callbackScript) {\n"");
    asb.append("" var inputNodes = wicketGet(markupId).getElementsByTagName('input');\n"");
    asb.append("" for (var i = 0 ; i < inputNodes.length ; i ++) {\n"");
    asb.append("" var inputNode = inputNodes[i];\n"");
    asb.append("" if (!inputNode.type) continue;\n"");
    asb.append("" var inputType = inputNode.type.toLowerCase();\n"");
    asb.append("" if (inputType == 'checkbox' || inputType == 'radio') {\n"");
    asb.append("" Wicket.Event.add(inputNode, 'click', callbackScript);\n"");
    asb.append("" }\n"");
    asb.append("" }\n"");
    asb.append(""}\n"");
    response.renderJavascript(asb, ""attachChoice"");
    response.renderOnLoadJavascript(""attachChoiceHandlers('"" + getComponent().getMarkupId() + ""', function() {"" + getEventHandler() + ""});"");
}",0.18181818181818182,-0.7177033492822968,-0.6,-1.0,-0.4166666666666667,0.03968253968253967,-0.1732205778717405,0.9166666666666666,-0.02631578947368421,0.09726203442771275
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-614_6feacf6b,1,"/**
 * Determine whether this child has been removed.
 * Assumes {@code read()}, {@code write()} needs not be called.
 * @return  {@code true} iff this child has been removed
 */
private boolean removed() {
    return !isRoot() && parent.writeState != null && parent.hasBaseState(name) && !parent.writeState.hasChildNode(name);
}","/**
 * Determine whether this child has been removed.
 * Assumes {@code read()}, {@code write()} needs not be called.
 * @return  {@code true} iff this child has been removed
 */
","private boolean removed() {
    return !isRoot() && parent.writeState != null && parent.hasBaseState(name) && !parent.writeState.hasChildNode(name);
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.07936507936507939,0.8505990133897112,-0.25,2.5,-0.11743227122629277
wicket,remotes/origin/bugs-dot-jar_WICKET-4696_f5f802c5,1,"/**
 *  Returns the minimum value for the numberType's type
 *
 *  @param numberType
 *             the type of the number for which the minimum value will be returned
 *  @return the minimum value of the numberType or {@value Double#MIN_VALUE} if the numberType
 *          itself is either {@code null} or has no minimum value
 */
public static Number getMinValue(Class<? extends Number> numberType) {
    Number result;
    if (Integer.class == numberType || int.class == numberType) {
        result = Integer.MIN_VALUE;
    } else if (Long.class == numberType || long.class == numberType) {
        result = Long.MIN_VALUE;
    } else if (Float.class == numberType || float.class == numberType) {
        result = Float.MIN_VALUE;
    } else if (Double.class == numberType || double.class == numberType) {
        result = Double.MIN_VALUE;
    } else if (Byte.class == numberType || byte.class == numberType) {
        result = Byte.MIN_VALUE;
    } else if (Short.class == numberType || short.class == numberType) {
        result = Short.MIN_VALUE;
    } else {
        // null of any other Number
        LOG.debug(""'{}' has no minimum value. Falling back to Double.MIN_VALUE."", numberType);
        result = Double.MIN_VALUE;
    }
    return result;
}","/**
 *  Returns the minimum value for the numberType's type
 *
 *  @param numberType
 *             the type of the number for which the minimum value will be returned
 *  @return the minimum value of the numberType or {@value Double#MIN_VALUE} if the numberType
 *          itself is either {@code null} or has no minimum value
 */
","public static Number getMinValue(Class<? extends Number> numberType) {
    Number result;
    if (Integer.class == numberType || int.class == numberType) {
        result = Integer.MIN_VALUE;
    } else if (Long.class == numberType || long.class == numberType) {
        result = Long.MIN_VALUE;
    } else if (Float.class == numberType || float.class == numberType) {
        result = Float.MIN_VALUE;
    } else if (Double.class == numberType || double.class == numberType) {
        result = Double.MIN_VALUE;
    } else if (Byte.class == numberType || byte.class == numberType) {
        result = Byte.MIN_VALUE;
    } else if (Short.class == numberType || short.class == numberType) {
        result = Short.MIN_VALUE;
    } else {
                LOG.debug(""'{}' has no minimum value. Falling back to Double.MIN_VALUE."", numberType);
        result = Double.MIN_VALUE;
    }
    return result;
}",0.2727272727272727,-0.20574162679425848,0.6,2.0,0.6666666666666666,0.27976190476190477,-0.2845665961945031,-0.4166666666666667,-0.02631578947368421,0.32730416140799773
Closure,18,2,"// ------------------------------------------------------------------------
// Parsing
// ------------------------------------------------------------------------
/**
 * Parses the externs and main inputs.
 *
 * @return A synthetic root node whose two children are the externs root
 *     and the main root
 */
Node parseInputs() {
    boolean devMode = options.devMode != DevMode.OFF;
    // individual file parse trees.
    if (externsRoot != null) {
        externsRoot.detachChildren();
    }
    if (jsRoot != null) {
        jsRoot.detachChildren();
    }
    // Parse main JS sources.
    jsRoot = IR.block();
    jsRoot.setIsSyntheticBlock(true);
    externsRoot = IR.block();
    externsRoot.setIsSyntheticBlock(true);
    externAndJsRoot = IR.block(externsRoot, jsRoot);
    externAndJsRoot.setIsSyntheticBlock(true);
    if (options.tracer.isOn()) {
        tracker = new PerformanceTracker(jsRoot, options.tracer);
        addChangeHandler(tracker.getCodeChangeHandler());
    }
    Tracer tracer = newTracer(""parseInputs"");
    try {
        // Parse externs sources.
        for (CompilerInput input : externs) {
            Node n = input.getAstRoot(this);
            if (hasErrors()) {
                return null;
            }
            externsRoot.addChildToBack(n);
        }
        // Modules inferred in ProcessCommonJS pass.
        if (options.transformAMDToCJSModules || options.processCommonJSModules) {
            processAMDAndCommonJSModules();
        }
        hoistExterns(externsRoot);
        // Check if the sources need to be re-ordered.
        boolean staleInputs = false;
        if (options.dependencyOptions.needsManagement() && options.closurePass) {
            for (CompilerInput input : inputs) {
                // are not flagged even if they are dropped from the process.
                for (String provide : input.getProvides()) {
                    getTypeRegistry().forwardDeclareType(provide);
                }
            }
            try {
                inputs = (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph).manageDependencies(options.dependencyOptions, inputs);
                staleInputs = true;
            } catch (CircularDependencyException e) {
                report(JSError.make(JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));
                // If in IDE mode, we ignore the error and keep going.
                if (hasErrors()) {
                    return null;
                }
            } catch (MissingProvideException e) {
                report(JSError.make(MISSING_ENTRY_ERROR, e.getMessage()));
                // If in IDE mode, we ignore the error and keep going.
                if (hasErrors()) {
                    return null;
                }
            }
        }
        hoistNoCompileFiles();
        if (staleInputs) {
            repartitionInputs();
        }
        // Build the AST.
        for (CompilerInput input : inputs) {
            Node n = input.getAstRoot(this);
            if (n == null) {
                continue;
            }
            if (devMode) {
                runSanityCheck();
                if (hasErrors()) {
                    return null;
                }
            }
            if (options.sourceMapOutputPath != null || options.nameReferenceReportPath != null) {
                // Annotate the nodes in the tree with information from the
                // input file. This information is used to construct the SourceMap.
                SourceInformationAnnotator sia = new SourceInformationAnnotator(input.getName(), options.devMode != DevMode.OFF);
                NodeTraversal.traverse(this, n, sia);
            }
            jsRoot.addChildToBack(n);
        }
        if (hasErrors()) {
            return null;
        }
        return externAndJsRoot;
    } finally {
        stopTracer(tracer, ""parseInputs"");
    }
}","/**
 * Parses the externs and main inputs.
 *
 * @return A synthetic root node whose two children are the externs root
 *     and the main root
 */
","Node parseInputs() {
    boolean devMode = options.devMode != DevMode.OFF;
        if (externsRoot != null) {
        externsRoot.detachChildren();
    }
    if (jsRoot != null) {
        jsRoot.detachChildren();
    }
        jsRoot = IR.block();
    jsRoot.setIsSyntheticBlock(true);
    externsRoot = IR.block();
    externsRoot.setIsSyntheticBlock(true);
    externAndJsRoot = IR.block(externsRoot, jsRoot);
    externAndJsRoot.setIsSyntheticBlock(true);
    if (options.tracer.isOn()) {
        tracker = new PerformanceTracker(jsRoot, options.tracer);
        addChangeHandler(tracker.getCodeChangeHandler());
    }
    Tracer tracer = newTracer(""parseInputs"");
    try {
                for (CompilerInput input : externs) {
            Node n = input.getAstRoot(this);
            if (hasErrors()) {
                return null;
            }
            externsRoot.addChildToBack(n);
        }
                if (options.transformAMDToCJSModules || options.processCommonJSModules) {
            processAMDAndCommonJSModules();
        }
        hoistExterns(externsRoot);
                boolean staleInputs = false;
        if (options.dependencyOptions.needsManagement() && options.closurePass) {
            for (CompilerInput input : inputs) {
                                for (String provide : input.getProvides()) {
                    getTypeRegistry().forwardDeclareType(provide);
                }
            }
            try {
                inputs = (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph).manageDependencies(options.dependencyOptions, inputs);
                staleInputs = true;
            } catch (CircularDependencyException e) {
                report(JSError.make(JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));
                                if (hasErrors()) {
                    return null;
                }
            } catch (MissingProvideException e) {
                report(JSError.make(MISSING_ENTRY_ERROR, e.getMessage()));
                                if (hasErrors()) {
                    return null;
                }
            }
        }
        hoistNoCompileFiles();
        if (staleInputs) {
            repartitionInputs();
        }
                for (CompilerInput input : inputs) {
            Node n = input.getAstRoot(this);
            if (n == null) {
                continue;
            }
            if (devMode) {
                runSanityCheck();
                if (hasErrors()) {
                    return null;
                }
            }
            if (options.sourceMapOutputPath != null || options.nameReferenceReportPath != null) {
                                                SourceInformationAnnotator sia = new SourceInformationAnnotator(input.getName(), options.devMode != DevMode.OFF);
                NodeTraversal.traverse(this, n, sia);
            }
            jsRoot.addChildToBack(n);
        }
        if (hasErrors()) {
            return null;
        }
        return externAndJsRoot;
    } finally {
        stopTracer(tracer, ""parseInputs"");
    }
}",3.090909090909091,0.923444976076555,3.8,1.0,2.25,0.5515873015873016,-1.2193093727977444,2.8333333333333335,-0.02631578947368421,2.3256421338957947
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-4166_374e3f3d,1,"/**
 * Copies the full content from the source to the target repository.
 * <p>
 * The source repository <strong>must not be modified</strong> while
 * the copy operation is running to avoid an inconsistent copy.
 * <p>
 * Note that both the source and the target repository must be closed
 * during the copy operation as this method requires exclusive access
 * to the repositories.
 *
 * @param initializer optional extra repository initializer to use
 * @throws RepositoryException if the copy operation fails
 */
public void copy(RepositoryInitializer initializer) throws RepositoryException {
    RepositoryConfig config = source.getRepositoryConfig();
    logger.info(""Copying repository content from {} to Oak"", config.getHomeDir());
    try {
        NodeBuilder targetBuilder = target.getRoot().builder();
        final Root upgradeRoot = new UpgradeRoot(targetBuilder);
        String workspaceName = source.getRepositoryConfig().getDefaultWorkspaceName();
        SecurityProviderImpl security = new SecurityProviderImpl(mapSecurityConfig(config.getSecurityConfig()));
        // init target repository first
        logger.info(""Initializing initial repository content from {}"", config.getHomeDir());
        new InitialContent().initialize(targetBuilder);
        if (initializer != null) {
            initializer.initialize(targetBuilder);
        }
        logger.debug(""InitialContent completed from {}"", config.getHomeDir());
        for (SecurityConfiguration sc : security.getConfigurations()) {
            RepositoryInitializer ri = sc.getRepositoryInitializer();
            ri.initialize(targetBuilder);
            logger.debug(""Repository initializer '"" + ri.getClass().getName() + ""' completed"", config.getHomeDir());
        }
        for (SecurityConfiguration sc : security.getConfigurations()) {
            WorkspaceInitializer wi = sc.getWorkspaceInitializer();
            wi.initialize(targetBuilder, workspaceName);
            logger.debug(""Workspace initializer '"" + wi.getClass().getName() + ""' completed"", config.getHomeDir());
        }
        HashBiMap<String, String> uriToPrefix = HashBiMap.create();
        logger.info(""Copying registered namespaces"");
        copyNamespaces(targetBuilder, uriToPrefix);
        logger.debug(""Namespace registration completed."");
        logger.info(""Copying registered node types"");
        NodeTypeManager ntMgr = new ReadWriteNodeTypeManager() {

            @Override
            protected Tree getTypes() {
                return upgradeRoot.getTree(NODE_TYPES_PATH);
            }

            @Nonnull
            @Override
            protected Root getWriteRoot() {
                return upgradeRoot;
            }
        };
        copyNodeTypes(ntMgr, new ValueFactoryImpl(upgradeRoot, NamePathMapper.DEFAULT));
        logger.debug(""Node type registration completed."");
        // migrate privileges
        logger.info(""Copying registered privileges"");
        PrivilegeConfiguration privilegeConfiguration = security.getConfiguration(PrivilegeConfiguration.class);
        copyCustomPrivileges(privilegeConfiguration.getPrivilegeManager(upgradeRoot, NamePathMapper.DEFAULT));
        logger.debug(""Privilege registration completed."");
        // Triggers compilation of type information, which we need for
        // the type predicates used by the bulk  copy operations below.
        new TypeEditorProvider(false).getRootEditor(targetBuilder.getBaseState(), targetBuilder.getNodeState(), targetBuilder, null);
        final NodeState reportingSourceRoot = ReportingNodeState.wrap(JackrabbitNodeState.createRootNodeState(source, workspaceName, targetBuilder.getNodeState(), uriToPrefix, copyBinariesByReference, skipOnError), new LoggingReporter(logger, ""Migrating"", 10000, -1));
        final NodeState sourceRoot;
        if (skipLongNames) {
            sourceRoot = NameFilteringNodeState.wrap(reportingSourceRoot);
        } else {
            sourceRoot = reportingSourceRoot;
        }
        final Stopwatch watch = Stopwatch.createStarted();
        logger.info(""Copying workspace content"");
        copyWorkspace(sourceRoot, targetBuilder, workspaceName);
        // on TarMK this does call triggers the actual copy
        targetBuilder.getNodeState();
        logger.info(""Upgrading workspace content completed in {}s ({})"", watch.elapsed(TimeUnit.SECONDS), watch);
        if (!versionCopyConfiguration.skipOrphanedVersionsCopy()) {
            logger.info(""Copying version storage"");
            watch.reset().start();
            copyVersionStorage(sourceRoot, targetBuilder, versionCopyConfiguration);
            // on TarMK this does call triggers the actual copy
            targetBuilder.getNodeState();
            logger.info(""Version storage copied in {}s ({})"", watch.elapsed(TimeUnit.SECONDS), watch);
        } else {
            logger.info(""Skipping the version storage as the copyOrphanedVersions is set to false"");
        }
        watch.reset().start();
        logger.info(""Applying default commit hooks"");
        // TODO: default hooks?
        List<CommitHook> hooks = newArrayList();
        UserConfiguration userConf = security.getConfiguration(UserConfiguration.class);
        String groupsPath = userConf.getParameters().getConfigValue(UserConstants.PARAM_GROUP_PATH, UserConstants.DEFAULT_GROUP_PATH);
        // hooks specific to the upgrade, need to run first
        hooks.add(new EditorHook(new CompositeEditorProvider(new RestrictionEditorProvider(), new GroupEditorProvider(groupsPath), // copy referenced version histories
        new VersionableEditor.Provider(sourceRoot, workspaceName, versionCopyConfiguration), new SameNameSiblingsEditor.Provider())));
        // security-related hooks
        for (SecurityConfiguration sc : security.getConfigurations()) {
            hooks.addAll(sc.getCommitHooks(workspaceName));
        }
        if (customCommitHooks != null) {
            hooks.addAll(customCommitHooks);
        }
        // type validation, reference and indexing hooks
        hooks.add(new EditorHook(new CompositeEditorProvider(createTypeEditorProvider(), createIndexEditorProvider())));
        target.merge(targetBuilder, new LoggingCompositeHook(hooks, source, overrideEarlyShutdown()), CommitInfo.EMPTY);
        logger.info(""Processing commit hooks completed in {}s ({})"", watch.elapsed(TimeUnit.SECONDS), watch);
        logger.debug(""Repository upgrade completed."");
    } catch (Exception e) {
        throw new RepositoryException(""Failed to copy content"", e);
    }
}","/**
 * Copies the full content from the source to the target repository.
 * <p>
 * The source repository <strong>must not be modified</strong> while
 * the copy operation is running to avoid an inconsistent copy.
 * <p>
 * Note that both the source and the target repository must be closed
 * during the copy operation as this method requires exclusive access
 * to the repositories.
 *
 * @param initializer optional extra repository initializer to use
 * @throws RepositoryException if the copy operation fails
 */
","public void copy(RepositoryInitializer initializer) throws RepositoryException {
    RepositoryConfig config = source.getRepositoryConfig();
    logger.info(""Copying repository content from {} to Oak"", config.getHomeDir());
    try {
        NodeBuilder targetBuilder = target.getRoot().builder();
        final Root upgradeRoot = new UpgradeRoot(targetBuilder);
        String workspaceName = source.getRepositoryConfig().getDefaultWorkspaceName();
        SecurityProviderImpl security = new SecurityProviderImpl(mapSecurityConfig(config.getSecurityConfig()));
                logger.info(""Initializing initial repository content from {}"", config.getHomeDir());
        new InitialContent().initialize(targetBuilder);
        if (initializer != null) {
            initializer.initialize(targetBuilder);
        }
        logger.debug(""InitialContent completed from {}"", config.getHomeDir());
        for (SecurityConfiguration sc : security.getConfigurations()) {
            RepositoryInitializer ri = sc.getRepositoryInitializer();
            ri.initialize(targetBuilder);
            logger.debug(""Repository initializer '"" + ri.getClass().getName() + ""' completed"", config.getHomeDir());
        }
        for (SecurityConfiguration sc : security.getConfigurations()) {
            WorkspaceInitializer wi = sc.getWorkspaceInitializer();
            wi.initialize(targetBuilder, workspaceName);
            logger.debug(""Workspace initializer '"" + wi.getClass().getName() + ""' completed"", config.getHomeDir());
        }
        HashBiMap<String, String> uriToPrefix = HashBiMap.create();
        logger.info(""Copying registered namespaces"");
        copyNamespaces(targetBuilder, uriToPrefix);
        logger.debug(""Namespace registration completed."");
        logger.info(""Copying registered node types"");
        NodeTypeManager ntMgr = new ReadWriteNodeTypeManager() {

            @Override
            protected Tree getTypes() {
                return upgradeRoot.getTree(NODE_TYPES_PATH);
            }

            @Nonnull
            @Override
            protected Root getWriteRoot() {
                return upgradeRoot;
            }
        };
        copyNodeTypes(ntMgr, new ValueFactoryImpl(upgradeRoot, NamePathMapper.DEFAULT));
        logger.debug(""Node type registration completed."");
                logger.info(""Copying registered privileges"");
        PrivilegeConfiguration privilegeConfiguration = security.getConfiguration(PrivilegeConfiguration.class);
        copyCustomPrivileges(privilegeConfiguration.getPrivilegeManager(upgradeRoot, NamePathMapper.DEFAULT));
        logger.debug(""Privilege registration completed."");
                        new TypeEditorProvider(false).getRootEditor(targetBuilder.getBaseState(), targetBuilder.getNodeState(), targetBuilder, null);
        final NodeState reportingSourceRoot = ReportingNodeState.wrap(JackrabbitNodeState.createRootNodeState(source, workspaceName, targetBuilder.getNodeState(), uriToPrefix, copyBinariesByReference, skipOnError), new LoggingReporter(logger, ""Migrating"", 10000, -1));
        final NodeState sourceRoot;
        if (skipLongNames) {
            sourceRoot = NameFilteringNodeState.wrap(reportingSourceRoot);
        } else {
            sourceRoot = reportingSourceRoot;
        }
        final Stopwatch watch = Stopwatch.createStarted();
        logger.info(""Copying workspace content"");
        copyWorkspace(sourceRoot, targetBuilder, workspaceName);
                targetBuilder.getNodeState();
        logger.info(""Upgrading workspace content completed in {}s ({})"", watch.elapsed(TimeUnit.SECONDS), watch);
        if (!versionCopyConfiguration.skipOrphanedVersionsCopy()) {
            logger.info(""Copying version storage"");
            watch.reset().start();
            copyVersionStorage(sourceRoot, targetBuilder, versionCopyConfiguration);
                        targetBuilder.getNodeState();
            logger.info(""Version storage copied in {}s ({})"", watch.elapsed(TimeUnit.SECONDS), watch);
        } else {
            logger.info(""Skipping the version storage as the copyOrphanedVersions is set to false"");
        }
        watch.reset().start();
        logger.info(""Applying default commit hooks"");
                List<CommitHook> hooks = newArrayList();
        UserConfiguration userConf = security.getConfiguration(UserConfiguration.class);
        String groupsPath = userConf.getParameters().getConfigValue(UserConstants.PARAM_GROUP_PATH, UserConstants.DEFAULT_GROUP_PATH);
                hooks.add(new EditorHook(new CompositeEditorProvider(new RestrictionEditorProvider(), new GroupEditorProvider(groupsPath),         new VersionableEditor.Provider(sourceRoot, workspaceName, versionCopyConfiguration), new SameNameSiblingsEditor.Provider())));
                for (SecurityConfiguration sc : security.getConfigurations()) {
            hooks.addAll(sc.getCommitHooks(workspaceName));
        }
        if (customCommitHooks != null) {
            hooks.addAll(customCommitHooks);
        }
                hooks.add(new EditorHook(new CompositeEditorProvider(createTypeEditorProvider(), createIndexEditorProvider())));
        target.merge(targetBuilder, new LoggingCompositeHook(hooks, source, overrideEarlyShutdown()), CommitInfo.EMPTY);
        logger.info(""Processing commit hooks completed in {}s ({})"", watch.elapsed(TimeUnit.SECONDS), watch);
        logger.debug(""Repository upgrade completed."");
    } catch (Exception e) {
        throw new RepositoryException(""Failed to copy content"", e);
    }
}",3.409090909090909,-0.13397129186602882,1.2,0.0,0.25,0.4761904761904763,-1.2816067653276952,6.5,-0.02631578947368421,4.65453225220864
Closure,137,2,"@Override
public void process(Node externs, Node root) {
    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));
    removeDuplicateDeclarations(root);
    if (MAKE_LOCAL_NAMES_UNIQUE) {
        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();
        NodeTraversal t = new NodeTraversal(compiler, renamer);
        t.traverseRoots(externs, root);
    }
    // It is important that removeDuplicateDeclarations runs after
    // MakeDeclaredNamesUnique in order for catch block exception names to be
    // handled properly. Specifically, catch block exception names are
    // only valid within the catch block, but our currect Scope logic
    // has no concept of this and includes it in the containing function
    // (or global scope). MakeDeclaredNamesUnique makes the catch exception
    // names unique so that removeDuplicateDeclarations() will properly handle
    // cases where a function scope variable conflict with a exception name:
    // function f() {
    // try {throw 0;} catch(e) {e; /* catch scope 'e'*/}
    // var e = 1; // f scope 'e'
    // }
    // otherwise 'var e = 1' would be rewritten as 'e = 1'.
    // TODO(johnlenz): Introduce a seperate scope for catch nodes.
    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);
}",,"@Override
public void process(Node externs, Node root) {
    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));
    removeDuplicateDeclarations(root);
    if (MAKE_LOCAL_NAMES_UNIQUE) {
        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();
        NodeTraversal t = new NodeTraversal(compiler, renamer);
        t.traverseRoots(externs, root);
    }
                                                            new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);
}",-0.13636363636363635,-0.01913875598086126,-0.4,-0.5,-0.3333333333333333,-0.3650793650793651,0.12840028188865416,-0.16666666666666666,0.0,-0.16279340490885932
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1190_e29dc4f5,3,"@Override
public void update(String writer, Map<ByteBuffer, List<ColumnUpdate>> cells) throws TException {
    try {
        BatchWriter batchwriter = writerCache.getIfPresent(UUID.fromString(writer));
        if (batchwriter == null) {
            throw new UnknownWriter(""Writer never existed or no longer exists"");
        }
        addCellsToWriter(cells, batchwriter);
    } catch (Exception e) {
        throw translateException(e);
    }
}",,"@Override
public void update(String writer, Map<ByteBuffer, List<ColumnUpdate>> cells) throws TException {
    try {
        BatchWriter batchwriter = writerCache.getIfPresent(UUID.fromString(writer));
        if (batchwriter == null) {
            throw new UnknownWriter(""Writer never existed or no longer exists"");
        }
        addCellsToWriter(cells, batchwriter);
    } catch (Exception e) {
        throw translateException(e);
    }
}",-0.09090909090909091,0.3732057416267942,0.2,0.0,-0.25,-0.12500000000000003,0.08019732205778712,-0.16666666666666666,0.2894736842105263,-0.08161915135169401
wicket,remotes/origin/bugs-dot-jar_WICKET-5968_8b7946d8,1,"@Override
public int hashCode() {
    int result = super.hashCode();
    result = 31 * result + (extension != null ? extension.hashCode() : 0);
    return result;
}",,"@Override
public int hashCode() {
    int result = super.hashCode();
    result = 31 * result + (extension != null ? extension.hashCode() : 0);
    return result;
}",-0.36363636363636365,-0.47368421052631593,-0.4,-1.0,-0.25,0.32936507936507936,0.5275546159267089,-0.3333333333333333,1.2368421052631577,-0.05288290313099704
camel,remotes/origin/bugs-dot-jar_CAMEL-7160_095fa2b4,1,"// Implementation methods
// -----------------------------------------------------------------------
protected long calculateDelay(Exchange exchange) {
    // evaluate as Object first to see if we get any result at all
    Object result = maxRequestsPerPeriodExpression.evaluate(exchange, Object.class);
    if (result == null) {
        throw new RuntimeExchangeException(""The max requests per period expression was evaluated as null: "" + maxRequestsPerPeriodExpression, exchange);
    }
    // then must convert value to long
    Long longValue = exchange.getContext().getTypeConverter().convertTo(Long.class, result);
    if (longValue != null) {
        // log if we changed max period after initial setting
        if (maximumRequestsPerPeriod > 0 && longValue.longValue() != maximumRequestsPerPeriod) {
            log.debug(""Throttler changed maximum requests per period from {} to {}"", maximumRequestsPerPeriod, longValue);
        }
        maximumRequestsPerPeriod = longValue;
    }
    if (maximumRequestsPerPeriod <= 0) {
        throw new IllegalStateException(""The maximumRequestsPerPeriod must be a positive number, was: "" + maximumRequestsPerPeriod);
    }
    TimeSlot slot = nextSlot();
    if (!slot.isActive()) {
        long delay = slot.startTime - currentSystemTime();
        return delay;
    } else {
        return 0;
    }
}",,"protected long calculateDelay(Exchange exchange) {
        Object result = maxRequestsPerPeriodExpression.evaluate(exchange, Object.class);
    if (result == null) {
        throw new RuntimeExchangeException(""The max requests per period expression was evaluated as null: "" + maxRequestsPerPeriodExpression, exchange);
    }
        Long longValue = exchange.getContext().getTypeConverter().convertTo(Long.class, result);
    if (longValue != null) {
                if (maximumRequestsPerPeriod > 0 && longValue.longValue() != maximumRequestsPerPeriod) {
            log.debug(""Throttler changed maximum requests per period from {} to {}"", maximumRequestsPerPeriod, longValue);
        }
        maximumRequestsPerPeriod = longValue;
    }
    if (maximumRequestsPerPeriod <= 0) {
        throw new IllegalStateException(""The maximumRequestsPerPeriod must be a positive number, was: "" + maximumRequestsPerPeriod);
    }
    TimeSlot slot = nextSlot();
    if (!slot.isActive()) {
        long delay = slot.startTime - currentSystemTime();
        return delay;
    } else {
        return 0;
    }
}",0.4090909090909091,-0.09569377990430632,0.8,0.0,0.5,1.0634920634920635,-0.37082452431289636,0.25,-0.02631578947368421,1.0477850198532757
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-2487_f2920c26,0,"/**
 * @param b
 *          Use passed bytes as backing array for this instance.
 */
public void set(final byte[] b) {
    this.value = b;
}","/**
 * @param b
 *          Use passed bytes as backing array for this instance.
 */
","public void set(final byte[] b) {
    this.value = b;
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,1.083157152924595,-0.5,2.6052631578947367,-0.16279340490885932
wicket,remotes/origin/bugs-dot-jar_WICKET-5326_ded3c583,1,"protected Url decryptUrl(final Request request, final Url encryptedUrl) {
    /*
		 * If the encrypted URL has no segments it is the home page URL, and does not need
		 * decrypting.
		 */
    if (encryptedUrl.getSegments().isEmpty()) {
        return encryptedUrl;
    }
    List<String> encryptedSegments = encryptedUrl.getSegments();
    Url url = new Url(request.getCharset());
    try {
        /*
			 * The first encrypted segment contains an encrypted version of the entire plain text
			 * url.
			 */
        String encryptedUrlString = encryptedSegments.get(0);
        if (Strings.isEmpty(encryptedUrlString)) {
            return null;
        }
        String decryptedUrl = getCrypt().decryptUrlSafe(encryptedUrlString);
        if (decryptedUrl == null) {
            return null;
        }
        Url originalUrl = Url.parse(decryptedUrl, request.getCharset());
        int originalNumberOfSegments = originalUrl.getSegments().size();
        int encryptedNumberOfSegments = encryptedUrl.getSegments().size();
        HashedSegmentGenerator generator = new HashedSegmentGenerator(encryptedUrlString);
        int segNo = 1;
        for (; segNo < encryptedNumberOfSegments; segNo++) {
            if (segNo > originalNumberOfSegments) {
                break;
            }
            String next = generator.next();
            String encryptedSegment = encryptedSegments.get(segNo);
            if (!next.equals(encryptedSegment)) {
                /*
					 * This segment received from the browser is not the same as the expected
					 * segment generated by the HashSegmentGenerator. Hence it, and all subsequent
					 * segments are considered plain text siblings of the original encrypted url.
					 */
                break;
            }
            /*
				 * This segments matches the expected checksum, so we add the corresponding segment
				 * from the original URL.
				 */
            url.getSegments().add(originalUrl.getSegments().get(segNo - 1));
        }
        /*
			 * Add all remaining segments from the encrypted url as plain text segments.
			 */
        for (; segNo < encryptedNumberOfSegments; segNo++) {
            // modified or additional segment
            url.getSegments().add(encryptedUrl.getSegments().get(segNo));
        }
        url.getQueryParameters().addAll(originalUrl.getQueryParameters());
        // WICKET-4923 additional parameters
        url.getQueryParameters().addAll(encryptedUrl.getQueryParameters());
    } catch (Exception e) {
        log.error(""Error decrypting URL"", e);
        url = null;
    }
    return url;
}",,"protected Url decryptUrl(final Request request, final Url encryptedUrl) {
        if (encryptedUrl.getSegments().isEmpty()) {
        return encryptedUrl;
    }
    List<String> encryptedSegments = encryptedUrl.getSegments();
    Url url = new Url(request.getCharset());
    try {
                String encryptedUrlString = encryptedSegments.get(0);
        if (Strings.isEmpty(encryptedUrlString)) {
            return null;
        }
        String decryptedUrl = getCrypt().decryptUrlSafe(encryptedUrlString);
        if (decryptedUrl == null) {
            return null;
        }
        Url originalUrl = Url.parse(decryptedUrl, request.getCharset());
        int originalNumberOfSegments = originalUrl.getSegments().size();
        int encryptedNumberOfSegments = encryptedUrl.getSegments().size();
        HashedSegmentGenerator generator = new HashedSegmentGenerator(encryptedUrlString);
        int segNo = 1;
        for (; segNo < encryptedNumberOfSegments; segNo++) {
            if (segNo > originalNumberOfSegments) {
                break;
            }
            String next = generator.next();
            String encryptedSegment = encryptedSegments.get(segNo);
            if (!next.equals(encryptedSegment)) {
                                break;
            }
                        url.getSegments().add(originalUrl.getSegments().get(segNo - 1));
        }
                for (; segNo < encryptedNumberOfSegments; segNo++) {
                        url.getSegments().add(encryptedUrl.getSegments().get(segNo));
        }
        url.getQueryParameters().addAll(originalUrl.getQueryParameters());
                url.getQueryParameters().addAll(encryptedUrl.getQueryParameters());
    } catch (Exception e) {
        log.error(""Error decrypting URL"", e);
        url = null;
    }
    return url;
}",1.2727272727272727,0.2870813397129185,1.4,0.5,0.9166666666666666,1.2757936507936507,-0.7694150810429878,2.1666666666666665,-0.02631578947368421,2.66873440408476
camel,remotes/origin/bugs-dot-jar_CAMEL-5826_a04674f2,1,"@Override
String getNext(boolean first) {
    String next = scanner.next();
    if (next == null) {
        return null;
    }
    // initialize inherited namespaces on first
    if (first && inheritNamespaceToken != null) {
        rootTokenNamespaces = getNamespacesFromNamespaceToken(next);
    }
    // make sure next is positioned at start token as we can have leading data
    // or we reached EOL and there is no more start tags
    Matcher matcher = startTokenPattern.matcher(next);
    if (!matcher.find()) {
        return null;
    } else {
        int index = matcher.start();
        next = next.substring(index);
    }
    // build answer accordingly to whether namespaces should be inherited or not
    StringBuilder sb = new StringBuilder();
    if (inheritNamespaceToken != null && rootTokenNamespaces != null) {
        // append root namespaces to local start token
        String tag = ObjectHelper.before(next, "">"");
        // grab the text
        String text = ObjectHelper.after(next, "">"");
        // build result with inherited namespaces
        next = sb.append(tag).append(rootTokenNamespaces).append("">"").append(text).append(endToken).toString();
    } else {
        next = sb.append(next).append(endToken).toString();
    }
    return next;
}",,"@Override
String getNext(boolean first) {
    String next = scanner.next();
    if (next == null) {
        return null;
    }
        if (first && inheritNamespaceToken != null) {
        rootTokenNamespaces = getNamespacesFromNamespaceToken(next);
    }
            Matcher matcher = startTokenPattern.matcher(next);
    if (!matcher.find()) {
        return null;
    } else {
        int index = matcher.start();
        next = next.substring(index);
    }
        StringBuilder sb = new StringBuilder();
    if (inheritNamespaceToken != null && rootTokenNamespaces != null) {
                String tag = ObjectHelper.before(next, "">"");
                String text = ObjectHelper.after(next, "">"");
                next = sb.append(tag).append(rootTokenNamespaces).append("">"").append(text).append(endToken).toString();
    } else {
        next = sb.append(next).append(endToken).toString();
    }
    return next;
}",0.5454545454545454,-0.20574162679425848,0.2,-0.5,0.5,0.632936507936508,-0.4407329105003524,0.9166666666666666,-0.02631578947368421,0.8999590832339228
Closure,137,2,"private static String getOrginalNameInternal(String name, int index) {
    return name.substring(0, index);
}",,"private static String getOrginalNameInternal(String name, int index) {
    return name.substring(0, index);
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.9805496828752639,-0.4166666666666667,0.07894736842105263,-0.16279340490885932
flink,remotes/origin/bugs-dot-jar_FLINK-1951_adb321d6,0,"private void addLocalInfoFromChannelToConfig(Channel channel, TaskConfig config, int inputNum, boolean isBroadcastChannel) {
    // serializer
    if (isBroadcastChannel) {
        config.setBroadcastInputSerializer(channel.getSerializer(), inputNum);
        if (channel.getLocalStrategy() != LocalStrategy.NONE || (channel.getTempMode() != null && channel.getTempMode() != TempMode.NONE)) {
            throw new CompilerException(""Found local strategy or temp mode on a broadcast variable channel."");
        } else {
            return;
        }
    } else {
        config.setInputSerializer(channel.getSerializer(), inputNum);
    }
    // local strategy
    if (channel.getLocalStrategy() != LocalStrategy.NONE) {
        config.setInputLocalStrategy(inputNum, channel.getLocalStrategy());
        if (channel.getLocalStrategyComparator() != null) {
            config.setInputComparator(channel.getLocalStrategyComparator(), inputNum);
        }
    }
    assignLocalStrategyResources(channel, config, inputNum);
    // materialization / caching
    if (channel.getTempMode() != null) {
        final TempMode tm = channel.getTempMode();
        boolean needsMemory = false;
        // Don't add a pipeline breaker if the data exchange is already blocking.
        if (tm.breaksPipeline() && channel.getDataExchangeMode() != DataExchangeMode.BATCH) {
            config.setInputAsynchronouslyMaterialized(inputNum, true);
            needsMemory = true;
        }
        if (tm.isCached()) {
            config.setInputCached(inputNum, true);
            needsMemory = true;
        }
        if (needsMemory) {
            // sanity check
            if (tm == null || tm == TempMode.NONE || channel.getRelativeTempMemory() <= 0) {
                throw new CompilerException(""Bug in compiler: Inconsistent description of input materialization."");
            }
            config.setRelativeInputMaterializationMemory(inputNum, channel.getRelativeTempMemory());
        }
    }
}",,"private void addLocalInfoFromChannelToConfig(Channel channel, TaskConfig config, int inputNum, boolean isBroadcastChannel) {
        if (isBroadcastChannel) {
        config.setBroadcastInputSerializer(channel.getSerializer(), inputNum);
        if (channel.getLocalStrategy() != LocalStrategy.NONE || (channel.getTempMode() != null && channel.getTempMode() != TempMode.NONE)) {
            throw new CompilerException(""Found local strategy or temp mode on a broadcast variable channel."");
        } else {
            return;
        }
    } else {
        config.setInputSerializer(channel.getSerializer(), inputNum);
    }
        if (channel.getLocalStrategy() != LocalStrategy.NONE) {
        config.setInputLocalStrategy(inputNum, channel.getLocalStrategy());
        if (channel.getLocalStrategyComparator() != null) {
            config.setInputComparator(channel.getLocalStrategyComparator(), inputNum);
        }
    }
    assignLocalStrategyResources(channel, config, inputNum);
        if (channel.getTempMode() != null) {
        final TempMode tm = channel.getTempMode();
        boolean needsMemory = false;
                if (tm.breaksPipeline() && channel.getDataExchangeMode() != DataExchangeMode.BATCH) {
            config.setInputAsynchronouslyMaterialized(inputNum, true);
            needsMemory = true;
        }
        if (tm.isCached()) {
            config.setInputCached(inputNum, true);
            needsMemory = true;
        }
        if (needsMemory) {
                        if (tm == null || tm == TempMode.NONE || channel.getRelativeTempMemory() <= 0) {
                throw new CompilerException(""Bug in compiler: Inconsistent description of input materialization."");
            }
            config.setRelativeInputMaterializationMemory(inputNum, channel.getRelativeTempMemory());
        }
    }
}",1.0454545454545454,0.29186602870813394,1.6,0.5,1.5833333333333333,1.1706349206349207,-0.6961240310077516,1.5,-0.02631578947368421,2.1156042714798615
wicket,remotes/origin/bugs-dot-jar_WICKET-2172_ea4a3f8a,3,"/**
 *  get enum implementation
 */
@SuppressWarnings({ ""unchecked"" })
private <T extends Enum<T>> T getEnumImpl(String key, Class<?> eClass, T defaultValue) {
    if (eClass == null)
        throw new IllegalArgumentException(""eClass value cannot be null"");
    String value = getString(key);
    if (value == null)
        return defaultValue;
    Method valueOf = null;
    try {
        valueOf = eClass.getMethod(""valueOf"", String.class);
    } catch (NoSuchMethodException e) {
        throw new RuntimeException(""Could not find method valueOf(String s) for "" + eClass.getName(), e);
    }
    try {
        return (T) valueOf.invoke(eClass, value);
    } catch (IllegalAccessException e) {
        throw new RuntimeException(""Could not invoke method valueOf(String s) on "" + eClass.getName(), e);
    } catch (InvocationTargetException e) {
        // IllegalArgumentException thrown if enum isn't defined - just return default
        if (e.getCause() instanceof IllegalArgumentException) {
            return defaultValue;
        }
        // shouldn't happen
        throw new RuntimeException(e);
    }
}","/**
 *  get enum implementation
 */
","@SuppressWarnings({ ""unchecked"" })
private <T extends Enum<T>> T getEnumImpl(String key, Class<?> eClass, T defaultValue) {
    if (eClass == null)
        throw new IllegalArgumentException(""eClass value cannot be null"");
    String value = getString(key);
    if (value == null)
        return defaultValue;
    Method valueOf = null;
    try {
        valueOf = eClass.getMethod(""valueOf"", String.class);
    } catch (NoSuchMethodException e) {
        throw new RuntimeException(""Could not find method valueOf(String s) for "" + eClass.getName(), e);
    }
    try {
        return (T) valueOf.invoke(eClass, value);
    } catch (IllegalAccessException e) {
        throw new RuntimeException(""Could not invoke method valueOf(String s) on "" + eClass.getName(), e);
    } catch (InvocationTargetException e) {
                if (e.getCause() instanceof IllegalArgumentException) {
            return defaultValue;
        }
                throw new RuntimeException(e);
    }
}",0.45454545454545453,-0.004784688995215422,1.4,0.0,0.08333333333333333,0.045634920634920584,-0.39732205778717394,0.0,-0.02631578947368421,0.15674924937904483
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1208_cb3ac20d,1,"private static void addNonFullTextConstraints(List<Query> qs, Filter filter, IndexReader reader) {
    if (!filter.matchesAllTypes()) {
        addNodeTypeConstraints(qs, filter);
    }
    String path = filter.getPath();
    switch(filter.getPathRestriction()) {
        case ALL_CHILDREN:
            if (""/"".equals(path)) {
                break;
            }
            if (!path.endsWith(""/"")) {
                path += ""/"";
            }
            qs.add(new PrefixQuery(newPathTerm(path)));
            break;
        case DIRECT_CHILDREN:
            if (!path.endsWith(""/"")) {
                path += ""/"";
            }
            qs.add(new PrefixQuery(newPathTerm(path)));
            break;
        case EXACT:
            qs.add(new TermQuery(newPathTerm(path)));
            break;
        case PARENT:
            if (PathUtils.denotesRoot(path)) {
                // there's no parent of the root node
                // we add a path that can not possibly occur because there
                // is no way to say ""match no documents"" in Lucene
                qs.add(new TermQuery(new Term(FieldNames.PATH, ""///"")));
            } else {
                qs.add(new TermQuery(newPathTerm(PathUtils.getParentPath(path))));
            }
            break;
        case NO_RESTRICTION:
            break;
    }
    for (PropertyRestriction pr : filter.getPropertyRestrictions()) {
        String name = pr.propertyName;
        if (name.contains(""/"")) {
            // lucene cannot handle child-level property restrictions
            continue;
        }
        if (""rep:excerpt"".equals(name)) {
            continue;
        }
        // TODO OAK-985
        if (JcrConstants.JCR_PRIMARYTYPE.equals(name)) {
            continue;
        }
        String first = null;
        String last = null;
        boolean isLike = pr.isLike;
        // TODO what to do with escaped tokens?
        if (pr.first != null) {
            first = pr.first.getValue(Type.STRING);
            first = first.replace(""\\"", """");
        }
        if (pr.last != null) {
            last = pr.last.getValue(Type.STRING);
            last = last.replace(""\\"", """");
        }
        if (isLike) {
            first = first.replace('%', WildcardQuery.WILDCARD_STRING);
            first = first.replace('_', WildcardQuery.WILDCARD_CHAR);
            int indexOfWS = first.indexOf(WildcardQuery.WILDCARD_STRING);
            int indexOfWC = first.indexOf(WildcardQuery.WILDCARD_CHAR);
            int len = first.length();
            if (indexOfWS == len || indexOfWC == len) {
                // remove trailing ""*"" for prefixquery
                first = first.substring(0, first.length() - 1);
                if (JCR_PATH.equals(name)) {
                    qs.add(new PrefixQuery(newPathTerm(first)));
                } else {
                    qs.add(new PrefixQuery(new Term(name, first)));
                }
            } else {
                if (JCR_PATH.equals(name)) {
                    qs.add(new WildcardQuery(newPathTerm(first)));
                } else {
                    qs.add(new WildcardQuery(new Term(name, first)));
                }
            }
            continue;
        }
        if (first != null && first.equals(last) && pr.firstIncluding && pr.lastIncluding) {
            if (JCR_PATH.equals(name)) {
                qs.add(new TermQuery(newPathTerm(first)));
            } else {
                if (""*"".equals(name)) {
                    addReferenceConstraint(first, qs, reader);
                } else {
                    qs.add(new TermQuery(new Term(name, first)));
                }
            }
            continue;
        }
        qs.add(TermRangeQuery.newStringRange(name, first, last, pr.firstIncluding, pr.lastIncluding));
    }
}",,"private static void addNonFullTextConstraints(List<Query> qs, Filter filter, IndexReader reader) {
    if (!filter.matchesAllTypes()) {
        addNodeTypeConstraints(qs, filter);
    }
    String path = filter.getPath();
    switch(filter.getPathRestriction()) {
        case ALL_CHILDREN:
            if (""/"".equals(path)) {
                break;
            }
            if (!path.endsWith(""/"")) {
                path += ""/"";
            }
            qs.add(new PrefixQuery(newPathTerm(path)));
            break;
        case DIRECT_CHILDREN:
            if (!path.endsWith(""/"")) {
                path += ""/"";
            }
            qs.add(new PrefixQuery(newPathTerm(path)));
            break;
        case EXACT:
            qs.add(new TermQuery(newPathTerm(path)));
            break;
        case PARENT:
            if (PathUtils.denotesRoot(path)) {
                                                                qs.add(new TermQuery(new Term(FieldNames.PATH, ""///"")));
            } else {
                qs.add(new TermQuery(newPathTerm(PathUtils.getParentPath(path))));
            }
            break;
        case NO_RESTRICTION:
            break;
    }
    for (PropertyRestriction pr : filter.getPropertyRestrictions()) {
        String name = pr.propertyName;
        if (name.contains(""/"")) {
                        continue;
        }
        if (""rep:excerpt"".equals(name)) {
            continue;
        }
                if (JcrConstants.JCR_PRIMARYTYPE.equals(name)) {
            continue;
        }
        String first = null;
        String last = null;
        boolean isLike = pr.isLike;
                if (pr.first != null) {
            first = pr.first.getValue(Type.STRING);
            first = first.replace(""\\"", """");
        }
        if (pr.last != null) {
            last = pr.last.getValue(Type.STRING);
            last = last.replace(""\\"", """");
        }
        if (isLike) {
            first = first.replace('%', WildcardQuery.WILDCARD_STRING);
            first = first.replace('_', WildcardQuery.WILDCARD_CHAR);
            int indexOfWS = first.indexOf(WildcardQuery.WILDCARD_STRING);
            int indexOfWC = first.indexOf(WildcardQuery.WILDCARD_CHAR);
            int len = first.length();
            if (indexOfWS == len || indexOfWC == len) {
                                first = first.substring(0, first.length() - 1);
                if (JCR_PATH.equals(name)) {
                    qs.add(new PrefixQuery(newPathTerm(first)));
                } else {
                    qs.add(new PrefixQuery(new Term(name, first)));
                }
            } else {
                if (JCR_PATH.equals(name)) {
                    qs.add(new WildcardQuery(newPathTerm(first)));
                } else {
                    qs.add(new WildcardQuery(new Term(name, first)));
                }
            }
            continue;
        }
        if (first != null && first.equals(last) && pr.firstIncluding && pr.lastIncluding) {
            if (JCR_PATH.equals(name)) {
                qs.add(new TermQuery(newPathTerm(first)));
            } else {
                if (""*"".equals(name)) {
                    addReferenceConstraint(first, qs, reader);
                } else {
                    qs.add(new TermQuery(new Term(name, first)));
                }
            }
            continue;
        }
        qs.add(TermRangeQuery.newStringRange(name, first, last, pr.firstIncluding, pr.lastIncluding));
    }
}",3.590909090909091,0.6315789473684208,6.2,1.0,3.6666666666666665,2.1468253968253967,-1.4056377730796332,3.6666666666666665,-0.02631578947368421,9.49330059992047
Math,10,3,"/**
 * Compute two arguments arc tangent of a derivative structure.
 * @param y array holding the first operand
 * @param yOffset offset of the first operand in its array
 * @param x array holding the second operand
 * @param xOffset offset of the second operand in its array
 * @param result array where result must be stored (for
 * two arguments arc tangent the result array <em>cannot</em>
 * be the input array)
 * @param resultOffset offset of the result in its array
 */
public void atan2(final double[] y, final int yOffset, final double[] x, final int xOffset, final double[] result, final int resultOffset) {
    // compute r = sqrt(x^2+y^2)
    double[] tmp1 = new double[getSize()];
    // x^2
    multiply(x, xOffset, x, xOffset, tmp1, 0);
    double[] tmp2 = new double[getSize()];
    // y^2
    multiply(y, yOffset, y, yOffset, tmp2, 0);
    // x^2 + y^2
    add(tmp1, 0, tmp2, 0, tmp2, 0);
    // r = sqrt(x^2 + y^2)
    rootN(tmp2, 0, 2, tmp1, 0);
    if (x[xOffset] >= 0) {
        // compute atan2(y, x) = 2 atan(y / (r + x))
        // r + x
        add(tmp1, 0, x, xOffset, tmp2, 0);
        // y /(r + x)
        divide(y, yOffset, tmp2, 0, tmp1, 0);
        // atan(y / (r + x))
        atan(tmp1, 0, tmp2, 0);
        for (int i = 0; i < tmp2.length; ++i) {
            // 2 * atan(y / (r + x))
            result[resultOffset + i] = 2 * tmp2[i];
        }
    } else {
        // compute atan2(y, x) = +/- pi - 2 atan(y / (r - x))
        // r - x
        subtract(tmp1, 0, x, xOffset, tmp2, 0);
        // y /(r - x)
        divide(y, yOffset, tmp2, 0, tmp1, 0);
        // atan(y / (r - x))
        atan(tmp1, 0, tmp2, 0);
        result[resultOffset] = // +/-pi - 2 * atan(y / (r - x))
        ((tmp2[0] <= 0) ? -FastMath.PI : FastMath.PI) - 2 * tmp2[0];
        for (int i = 1; i < tmp2.length; ++i) {
            // +/-pi - 2 * atan(y / (r - x))
            result[resultOffset + i] = -2 * tmp2[i];
        }
    }
// fix value to take special cases (+0/+0, +0/-0, -0/+0, -0/-0, +/-infinity) correctly
}","/**
 * Compute two arguments arc tangent of a derivative structure.
 * @param y array holding the first operand
 * @param yOffset offset of the first operand in its array
 * @param x array holding the second operand
 * @param xOffset offset of the second operand in its array
 * @param result array where result must be stored (for
 * two arguments arc tangent the result array <em>cannot</em>
 * be the input array)
 * @param resultOffset offset of the result in its array
 */
","public void atan2(final double[] y, final int yOffset, final double[] x, final int xOffset, final double[] result, final int resultOffset) {
        double[] tmp1 = new double[getSize()];
        multiply(x, xOffset, x, xOffset, tmp1, 0);
    double[] tmp2 = new double[getSize()];
        multiply(y, yOffset, y, yOffset, tmp2, 0);
        add(tmp1, 0, tmp2, 0, tmp2, 0);
        rootN(tmp2, 0, 2, tmp1, 0);
    if (x[xOffset] >= 0) {
                        add(tmp1, 0, x, xOffset, tmp2, 0);
                divide(y, yOffset, tmp2, 0, tmp1, 0);
                atan(tmp1, 0, tmp2, 0);
        for (int i = 0; i < tmp2.length; ++i) {
                        result[resultOffset + i] = 2 * tmp2[i];
        }
    } else {
                        subtract(tmp1, 0, x, xOffset, tmp2, 0);
                divide(y, yOffset, tmp2, 0, tmp1, 0);
                atan(tmp1, 0, tmp2, 0);
        result[resultOffset] =         ((tmp2[0] <= 0) ? -FastMath.PI : FastMath.PI) - 2 * tmp2[0];
        for (int i = 1; i < tmp2.length; ++i) {
                        result[resultOffset + i] = -2 * tmp2[i];
        }
    }
}",0.5,0.009569377990430419,0.2,0.0,0.08333333333333333,3.470238095238095,-0.4818886539816771,0.5,-0.02631578947368421,5.942831785988024
camel,remotes/origin/bugs-dot-jar_CAMEL-7418_cabee0e9,3,"public <T> Map<String, T> findByTypeWithName(Class<T> type) {
    Map<String, T> answer = new LinkedHashMap<String, T>();
    try {
        NamingEnumeration<NameClassPair> list = getContext().list("""");
        while (list.hasMore()) {
            NameClassPair pair = list.next();
            if (type.isInstance(pair.getClass()) || type.getName().equals(pair.getClassName())) {
                Object instance = context.lookup(pair.getName());
                answer.put(pair.getName(), type.cast(instance));
            }
        }
    } catch (NamingException e) {
    // ignore
    }
    return answer;
}",,"public <T> Map<String, T> findByTypeWithName(Class<T> type) {
    Map<String, T> answer = new LinkedHashMap<String, T>();
    try {
        NamingEnumeration<NameClassPair> list = getContext().list("""");
        while (list.hasMore()) {
            NameClassPair pair = list.next();
            if (type.isInstance(pair.getClass()) || type.getName().equals(pair.getClassName())) {
                Object instance = context.lookup(pair.getName());
                answer.put(pair.getName(), type.cast(instance));
            }
        }
    } catch (NamingException e) {
        }
    return answer;
}",0.045454545454545456,0.9760765550239235,0.0,0.5,0.25,-0.0138888888888889,-0.11599718111346001,0.6666666666666666,-0.02631578947368421,0.07340813609723207
Closure,6,2,"/**
 * Expect that the first type can be assigned to a symbol of the second
 * type.
 *
 * @param t The node traversal.
 * @param n The node to issue warnings on.
 * @param rightType The type on the RHS of the assign.
 * @param leftType The type of the symbol on the LHS of the assign.
 * @param msg An extra message for the mismatch warning, if necessary.
 * @return True if the types matched, false otherwise.
 */
boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) {
    if (!rightType.canAssignTo(leftType)) {
        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {
            registerMismatch(rightType, leftType, null);
        } else {
            mismatch(t, n, msg, rightType, leftType);
        }
        return false;
    }
    return true;
}","/**
 * Expect that the first type can be assigned to a symbol of the second
 * type.
 *
 * @param t The node traversal.
 * @param n The node to issue warnings on.
 * @param rightType The type on the RHS of the assign.
 * @param leftType The type of the symbol on the LHS of the assign.
 * @param msg An extra message for the mismatch warning, if necessary.
 * @return True if the types matched, false otherwise.
 */
","boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) {
    if (!rightType.canAssignTo(leftType)) {
        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {
            registerMismatch(rightType, leftType, null);
        } else {
            mismatch(t, n, msg, rightType, leftType);
        }
        return false;
    }
    return true;
}",-0.13636363636363635,0.45933014354066987,-0.2,0.0,0.5,0.0,0.10697674418604654,0.08333333333333333,-0.02631578947368421,-0.01509194746517753
commons-math,remotes/origin/bugs-dot-jar_MATH-880_2a9cbbab,1,"/**
 * Add a node whose hyperplane contains this vertex.
 * @param node node whose hyperplane contains this vertex
 */
public void addNode(final BSPTree<Euclidean2D> node) {
    nodes.add(node);
}","/**
 * Add a node whose hyperplane contains this vertex.
 * @param node node whose hyperplane contains this vertex
 */
","public void addNode(final BSPTree<Euclidean2D> node) {
    nodes.add(node);
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,1.0132487667371384,-0.4166666666666667,2.552631578947368,-0.16279340490885932
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-498_f2a2edec,1,"private String getOakPath(String jcrPath, final boolean keepIndex) {
    if (""/"".equals(jcrPath)) {
        // avoid the need to special case the root path later on
        return ""/"";
    }
    int length = jcrPath.length();
    // identifier path?
    if (length > 0 && jcrPath.charAt(0) == '[') {
        if (jcrPath.charAt(length - 1) != ']') {
            // TODO error handling?
            log.debug(""Could not parse path "" + jcrPath + "": unterminated identifier"");
            return null;
        }
        if (this.idManager == null) {
            // TODO error handling?
            log.debug(""Could not parse path "" + jcrPath + "": could not resolve identifier"");
            return null;
        }
        return this.idManager.getPath(jcrPath.substring(1, length - 1));
    }
    boolean hasClarkBrackets = false;
    boolean hasIndexBrackets = false;
    boolean hasColon = false;
    boolean hasNameStartingWithDot = false;
    boolean hasTrailingSlash = false;
    char prev = 0;
    for (int i = 0; i < length; i++) {
        char c = jcrPath.charAt(i);
        if (c == '{' || c == '}') {
            hasClarkBrackets = true;
        } else if (c == '[' || c == ']') {
            hasIndexBrackets = true;
        } else if (c == ':') {
            hasColon = true;
        } else if (c == '.' && (prev == 0 || prev == '/')) {
            hasNameStartingWithDot = true;
        } else if (c == '/' && i == (length - 1)) {
            hasTrailingSlash = true;
        }
        prev = c;
    }
    // try a shortcut
    if (!hasNameStartingWithDot && !hasClarkBrackets && !hasIndexBrackets) {
        if (!hasColon || !hasSessionLocalMappings()) {
            if (JcrPathParser.validate(jcrPath)) {
                if (hasTrailingSlash) {
                    return jcrPath.substring(0, length - 1);
                }
                return jcrPath;
            } else {
                log.debug(""Invalid path: {}"", jcrPath);
                return null;
            }
        }
    }
    final List<String> elements = new ArrayList<String>();
    final StringBuilder parseErrors = new StringBuilder();
    JcrPathParser.Listener listener = new JcrPathParser.Listener() {

        @Override
        public boolean root() {
            if (!elements.isEmpty()) {
                parseErrors.append(""/ on non-empty path"");
                return false;
            }
            elements.add("""");
            return true;
        }

        @Override
        public boolean current() {
            // nothing to do here
            return true;
        }

        @Override
        public boolean parent() {
            if (elements.isEmpty() || "".."".equals(elements.get(elements.size() - 1))) {
                elements.add("".."");
                return true;
            }
            elements.remove(elements.size() - 1);
            return true;
        }

        @Override
        public void error(String message) {
            parseErrors.append(message);
        }

        @Override
        public boolean name(String name, int index) {
            if (!keepIndex && index > 1) {
                parseErrors.append(""index > 1"");
                return false;
            }
            String p = nameMapper.getOakName(name);
            if (p == null) {
                parseErrors.append(""Invalid name: "").append(name);
                return false;
            }
            if (keepIndex && index > 0) {
                p += ""["" + index + ']';
            }
            elements.add(p);
            return true;
        }
    };
    JcrPathParser.parse(jcrPath, listener);
    if (parseErrors.length() != 0) {
        log.debug(""Could not parse path "" + jcrPath + "": "" + parseErrors.toString());
        return null;
    }
    // Empty path maps to """"
    if (elements.isEmpty()) {
        return """";
    }
    StringBuilder oakPath = new StringBuilder();
    for (String element : elements) {
        if (element.isEmpty()) {
            // root
            oakPath.append('/');
        } else {
            oakPath.append(element);
            oakPath.append('/');
        }
    }
    // root path is special-cased early on so it does not need to
    // be considered here
    oakPath.deleteCharAt(oakPath.length() - 1);
    return oakPath.toString();
}",,"private String getOakPath(String jcrPath, final boolean keepIndex) {
    if (""/"".equals(jcrPath)) {
                return ""/"";
    }
    int length = jcrPath.length();
        if (length > 0 && jcrPath.charAt(0) == '[') {
        if (jcrPath.charAt(length - 1) != ']') {
                        log.debug(""Could not parse path "" + jcrPath + "": unterminated identifier"");
            return null;
        }
        if (this.idManager == null) {
                        log.debug(""Could not parse path "" + jcrPath + "": could not resolve identifier"");
            return null;
        }
        return this.idManager.getPath(jcrPath.substring(1, length - 1));
    }
    boolean hasClarkBrackets = false;
    boolean hasIndexBrackets = false;
    boolean hasColon = false;
    boolean hasNameStartingWithDot = false;
    boolean hasTrailingSlash = false;
    char prev = 0;
    for (int i = 0; i < length; i++) {
        char c = jcrPath.charAt(i);
        if (c == '{' || c == '}') {
            hasClarkBrackets = true;
        } else if (c == '[' || c == ']') {
            hasIndexBrackets = true;
        } else if (c == ':') {
            hasColon = true;
        } else if (c == '.' && (prev == 0 || prev == '/')) {
            hasNameStartingWithDot = true;
        } else if (c == '/' && i == (length - 1)) {
            hasTrailingSlash = true;
        }
        prev = c;
    }
        if (!hasNameStartingWithDot && !hasClarkBrackets && !hasIndexBrackets) {
        if (!hasColon || !hasSessionLocalMappings()) {
            if (JcrPathParser.validate(jcrPath)) {
                if (hasTrailingSlash) {
                    return jcrPath.substring(0, length - 1);
                }
                return jcrPath;
            } else {
                log.debug(""Invalid path: {}"", jcrPath);
                return null;
            }
        }
    }
    final List<String> elements = new ArrayList<String>();
    final StringBuilder parseErrors = new StringBuilder();
    JcrPathParser.Listener listener = new JcrPathParser.Listener() {

        @Override
        public boolean root() {
            if (!elements.isEmpty()) {
                parseErrors.append(""/ on non-empty path"");
                return false;
            }
            elements.add("""");
            return true;
        }

        @Override
        public boolean current() {
                        return true;
        }

        @Override
        public boolean parent() {
            if (elements.isEmpty() || "".."".equals(elements.get(elements.size() - 1))) {
                elements.add("".."");
                return true;
            }
            elements.remove(elements.size() - 1);
            return true;
        }

        @Override
        public void error(String message) {
            parseErrors.append(message);
        }

        @Override
        public boolean name(String name, int index) {
            if (!keepIndex && index > 1) {
                parseErrors.append(""index > 1"");
                return false;
            }
            String p = nameMapper.getOakName(name);
            if (p == null) {
                parseErrors.append(""Invalid name: "").append(name);
                return false;
            }
            if (keepIndex && index > 0) {
                p += ""["" + index + ']';
            }
            elements.add(p);
            return true;
        }
    };
    JcrPathParser.parse(jcrPath, listener);
    if (parseErrors.length() != 0) {
        log.debug(""Could not parse path "" + jcrPath + "": "" + parseErrors.toString());
        return null;
    }
        if (elements.isEmpty()) {
        return """";
    }
    StringBuilder oakPath = new StringBuilder();
    for (String element : elements) {
        if (element.isEmpty()) {
                        oakPath.append('/');
        } else {
            oakPath.append(element);
            oakPath.append('/');
        }
    }
            oakPath.deleteCharAt(oakPath.length() - 1);
    return oakPath.toString();
}",4.681818181818182,0.5645933014354066,4.0,2.0,4.5,3.6507936507936507,-1.4727272727272722,2.9166666666666665,-0.02631578947368421,19.25635909937011
camel,remotes/origin/bugs-dot-jar_CAMEL-8954_7b1253db,3,"protected void doReleaseExclusiveReadLock(GenericFileOperations<File> operations, GenericFile<File> file, Exchange exchange) throws Exception {
    if (!markerFile) {
        // if not using marker file then nothing to release
        return;
    }
    // only release the file if camel get the lock before
    if (exchange.getProperty(Exchange.FILE_LOCK_FILE_ACQUIRED, false, Boolean.class)) {
        String lockFileName = exchange.getProperty(Exchange.FILE_LOCK_FILE_NAME, getLockFileName(file), String.class);
        File lock = new File(lockFileName);
        if (lock.exists()) {
            LOG.trace(""Unlocking file: {}"", lockFileName);
            boolean deleted = FileUtil.deleteFile(lock);
            LOG.trace(""Lock file: {} was deleted: {}"", lockFileName, deleted);
        }
    }
}",,"protected void doReleaseExclusiveReadLock(GenericFileOperations<File> operations, GenericFile<File> file, Exchange exchange) throws Exception {
    if (!markerFile) {
                return;
    }
        if (exchange.getProperty(Exchange.FILE_LOCK_FILE_ACQUIRED, false, Boolean.class)) {
        String lockFileName = exchange.getProperty(Exchange.FILE_LOCK_FILE_NAME, getLockFileName(file), String.class);
        File lock = new File(lockFileName);
        if (lock.exists()) {
            LOG.trace(""Unlocking file: {}"", lockFileName);
            boolean deleted = FileUtil.deleteFile(lock);
            LOG.trace(""Lock file: {} was deleted: {}"", lockFileName, deleted);
        }
    }
}",0.0,0.43062200956937796,0.0,0.0,0.08333333333333333,-0.039682539682539715,-0.06018322762508822,0.08333333333333333,-0.02631578947368421,0.023035563008938283
Codec,9,3,"/**
 * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.
 *
 * @param binaryData
 *            Array containing binary data to encode.
 * @param isChunked
 *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks
 * @param urlSafe
 *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.
 * @param maxResultSize
 *            The maximum result size to accept.
 * @return Base64-encoded data.
 * @throws IllegalArgumentException
 *             Thrown when the input array needs an output array bigger than maxResultSize
 * @since 1.4
 */
public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
    if (binaryData == null || binaryData.length == 0) {
        return binaryData;
    }
    long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
    if (len > maxResultSize) {
        throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" + len + "") than the specified maxium size of "" + maxResultSize);
    }
    Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
    return b64.encode(binaryData);
}","/**
 * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.
 *
 * @param binaryData
 *            Array containing binary data to encode.
 * @param isChunked
 *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks
 * @param urlSafe
 *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.
 * @param maxResultSize
 *            The maximum result size to accept.
 * @return Base64-encoded data.
 * @throws IllegalArgumentException
 *             Thrown when the input array needs an output array bigger than maxResultSize
 * @since 1.4
 */
","public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
    if (binaryData == null || binaryData.length == 0) {
        return binaryData;
    }
    long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
    if (len > maxResultSize) {
        throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" + len + "") than the specified maxium size of "" + maxResultSize);
    }
    Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
    return b64.encode(binaryData);
}",-0.13636363636363635,-0.2775119617224881,0.2,-0.5,0.3333333333333333,0.3869047619047619,0.07568710359408039,-0.3333333333333333,0.21052631578947367,0.18164969485313182
JxPath,9,1,"protected boolean equal(Object l, Object r) {
    if (l instanceof Pointer && r instanceof Pointer) {
        if (l.equals(r)) {
            return true;
        }
    }
    if (l instanceof Pointer) {
        l = ((Pointer) l).getValue();
    }
    if (r instanceof Pointer) {
        r = ((Pointer) r).getValue();
    }
    if (l == r) {
        return true;
    }
    if (l instanceof Boolean || r instanceof Boolean) {
        return (InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r));
    }
    // if either side is NaN, no comparison returns true:
    if (l instanceof Number || r instanceof Number) {
        return (InfoSetUtil.doubleValue(l) == InfoSetUtil.doubleValue(r));
    }
    if (l instanceof String || r instanceof String) {
        return (InfoSetUtil.stringValue(l).equals(InfoSetUtil.stringValue(r)));
    }
    return l != null && l.equals(r);
}",,"protected boolean equal(Object l, Object r) {
    if (l instanceof Pointer && r instanceof Pointer) {
        if (l.equals(r)) {
            return true;
        }
    }
    if (l instanceof Pointer) {
        l = ((Pointer) l).getValue();
    }
    if (r instanceof Pointer) {
        r = ((Pointer) r).getValue();
    }
    if (l == r) {
        return true;
    }
    if (l instanceof Boolean || r instanceof Boolean) {
        return (InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r));
    }
        if (l instanceof Number || r instanceof Number) {
        return (InfoSetUtil.doubleValue(l) == InfoSetUtil.doubleValue(r));
    }
    if (l instanceof String || r instanceof String) {
        return (InfoSetUtil.stringValue(l).equals(InfoSetUtil.stringValue(r)));
    }
    return l != null && l.equals(r);
}",0.5454545454545454,-0.1578947368421053,1.0,0.0,0.8333333333333334,1.152777777777778,-0.42269203664552507,0.4166666666666667,-0.02631578947368421,1.0320775920195016
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3053_7552a10b,1,"protected Directory createLocalDirForIndexWriter(IndexDefinition definition) throws IOException {
    String indexPath = definition.getIndexPathFromConfig();
    File indexWriterDir;
    if (indexPath == null) {
        // If indexPath is not known create a unique directory for work
        indexWriterDir = new File(indexWorkDir, String.valueOf(UNIQUE_COUNTER.incrementAndGet()));
    } else {
        File indexDir = getIndexDir(indexPath);
        String newVersion = String.valueOf(definition.getReindexCount());
        indexWriterDir = getVersionedDir(indexPath, indexDir, newVersion);
    }
    Directory dir = FSDirectory.open(indexWriterDir);
    log.debug(""IndexWriter would use {}"", indexWriterDir);
    if (indexPath == null) {
        dir = new DeleteOldDirOnClose(dir, indexWriterDir);
        log.debug(""IndexPath [{}] not configured in index definition {}. Writer would create index "" + ""files in temporary dir {} which would be deleted upon close. For better performance do "" + ""configure the 'indexPath' as part of your index definition"", LuceneIndexConstants.INDEX_PATH, definition, indexWriterDir);
    }
    return dir;
}",,"protected Directory createLocalDirForIndexWriter(IndexDefinition definition) throws IOException {
    String indexPath = definition.getIndexPathFromConfig();
    File indexWriterDir;
    if (indexPath == null) {
                indexWriterDir = new File(indexWorkDir, String.valueOf(UNIQUE_COUNTER.incrementAndGet()));
    } else {
        File indexDir = getIndexDir(indexPath);
        String newVersion = String.valueOf(definition.getReindexCount());
        indexWriterDir = getVersionedDir(indexPath, indexDir, newVersion);
    }
    Directory dir = FSDirectory.open(indexWriterDir);
    log.debug(""IndexWriter would use {}"", indexWriterDir);
    if (indexPath == null) {
        dir = new DeleteOldDirOnClose(dir, indexWriterDir);
        log.debug(""IndexPath [{}] not configured in index definition {}. Writer would create index "" + ""files in temporary dir {} which would be deleted upon close. For better performance do "" + ""configure the 'indexPath' as part of your index definition"", LuceneIndexConstants.INDEX_PATH, definition, indexWriterDir);
    }
    return dir;
}",0.18181818181818182,-0.22966507177033516,-0.2,-0.5,-0.16666666666666666,0.0019841269841269858,-0.22734319943622258,0.3333333333333333,-0.02631578947368421,0.15002276355295835
wicket,remotes/origin/bugs-dot-jar_WICKET-5319_c863b032,3,"protected Url decryptUrl(final Request request, final Url encryptedUrl) {
    /*
		 * If the encrypted URL has no segments it is the home page URL,
		 * and does not need decrypting.
		 */
    if (encryptedUrl.getSegments().isEmpty()) {
        return encryptedUrl;
    }
    List<String> encryptedSegments = encryptedUrl.getSegments();
    Url url = new Url(request.getCharset());
    try {
        /*
			 * The first encrypted segment contains an encrypted version of the
			 * entire plain text url.
			 */
        String encryptedUrlString = encryptedSegments.get(0);
        if (Strings.isEmpty(encryptedUrlString)) {
            return null;
        }
        String decryptedUrl = getCrypt().decryptUrlSafe(encryptedUrlString);
        if (decryptedUrl == null) {
            return null;
        }
        Url originalUrl = Url.parse(decryptedUrl, request.getCharset());
        int originalNumberOfSegments = originalUrl.getSegments().size();
        int encryptedNumberOfSegments = encryptedUrl.getSegments().size();
        HashedSegmentGenerator generator = new HashedSegmentGenerator(encryptedUrlString);
        int segNo = 1;
        for (; segNo < encryptedNumberOfSegments; segNo++) {
            if (segNo > originalNumberOfSegments) {
                break;
            }
            String next = generator.next();
            String encryptedSegment = encryptedSegments.get(segNo);
            if (!next.equals(encryptedSegment)) {
                /*
					 * This segment received from the browser is not the same as the
					 * expected segment generated by the HashSegmentGenerator. Hence it,
					 * and all subsequent segments are considered plain text siblings of the
					 * original encrypted url.
					 */
                break;
            }
            /*
				 * This segments matches the expected checksum, so we add the corresponding
				 * segment from the original URL.
				 */
            url.getSegments().add(originalUrl.getSegments().get(segNo - 1));
        }
        /*
			 * Add all remaining segments from the encrypted url as plain text segments.
			 */
        for (; segNo < encryptedNumberOfSegments; segNo++) {
            // modified or additional segment
            url.getSegments().add(encryptedUrl.getSegments().get(segNo));
        }
        url.getQueryParameters().addAll(originalUrl.getQueryParameters());
        // WICKET-4923 additional parameters
        url.getQueryParameters().addAll(encryptedUrl.getQueryParameters());
    } catch (Exception e) {
        log.error(""Error decrypting URL"", e);
        url = null;
    }
    return url;
}",,"protected Url decryptUrl(final Request request, final Url encryptedUrl) {
        if (encryptedUrl.getSegments().isEmpty()) {
        return encryptedUrl;
    }
    List<String> encryptedSegments = encryptedUrl.getSegments();
    Url url = new Url(request.getCharset());
    try {
                String encryptedUrlString = encryptedSegments.get(0);
        if (Strings.isEmpty(encryptedUrlString)) {
            return null;
        }
        String decryptedUrl = getCrypt().decryptUrlSafe(encryptedUrlString);
        if (decryptedUrl == null) {
            return null;
        }
        Url originalUrl = Url.parse(decryptedUrl, request.getCharset());
        int originalNumberOfSegments = originalUrl.getSegments().size();
        int encryptedNumberOfSegments = encryptedUrl.getSegments().size();
        HashedSegmentGenerator generator = new HashedSegmentGenerator(encryptedUrlString);
        int segNo = 1;
        for (; segNo < encryptedNumberOfSegments; segNo++) {
            if (segNo > originalNumberOfSegments) {
                break;
            }
            String next = generator.next();
            String encryptedSegment = encryptedSegments.get(segNo);
            if (!next.equals(encryptedSegment)) {
                                break;
            }
                        url.getSegments().add(originalUrl.getSegments().get(segNo - 1));
        }
                for (; segNo < encryptedNumberOfSegments; segNo++) {
                        url.getSegments().add(encryptedUrl.getSegments().get(segNo));
        }
        url.getQueryParameters().addAll(originalUrl.getQueryParameters());
                url.getQueryParameters().addAll(encryptedUrl.getQueryParameters());
    } catch (Exception e) {
        log.error(""Error decrypting URL"", e);
        url = null;
    }
    return url;
}",1.2727272727272727,0.2870813397129185,1.4,0.5,0.9166666666666666,1.2757936507936507,-0.7694150810429878,2.1666666666666665,-0.02631578947368421,2.66873440408476
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3021_494da6de,1,"@Override
public Validator childNodeAdded(String name, NodeState after) throws CommitFailedException {
    Tree treeAfter = checkNotNull(parentAfter.getChild(name));
    checkValidTree(parentAfter, treeAfter, after);
    return new AccessControlValidator(this, treeAfter);
}",,"@Override
public Validator childNodeAdded(String name, NodeState after) throws CommitFailedException {
    Tree treeAfter = checkNotNull(parentAfter.getChild(name));
    checkValidTree(parentAfter, treeAfter, after);
    return new AccessControlValidator(this, treeAfter);
}",-0.36363636363636365,-0.47368421052631593,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.49344608879492574,-0.25,0.07894736842105263,-0.16279340490885932
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1120_474b2577,0,"public SecurityToken getToken() {
    PasswordToken pt = new PasswordToken();
    if (securePassword == null) {
        if (password.value == null)
            return null;
        return pt.setPassword(password.value);
    }
    return pt.setPassword(securePassword.value);
}",,"public SecurityToken getToken() {
    PasswordToken pt = new PasswordToken();
    if (securePassword == null) {
        if (password.value == null)
            return null;
        return pt.setPassword(password.value);
    }
    return pt.setPassword(securePassword.value);
}",-0.22727272727272727,0.32057416267942584,-0.2,-0.5,-0.08333333333333333,0.03174603174603173,0.30796335447498224,-0.3333333333333333,0.8421052631578947,-0.08676429061277179
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-260_9d817953,1,"@Override
public /**
 * @return The content type.
 */
String getContentType() {
    return ""text/xml"";
}","/**
 * @return The content type.
 */
","@Override
public String getContentType() {
    return ""text/xml"";
}",-0.4090909090909091,-0.6650717703349284,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.8768146582100066,-0.5,2.6052631578947367,-0.16279340490885932
flink,remotes/origin/bugs-dot-jar_FLINK-1458_91f9bfc7,1,"/**
 *  Checks if the given field is a valid pojo field:
 *  - it is public
 *  OR
 *   - there are getter and setter methods for the field.
 *
 *  @param f field to check
 *  @param clazz class of field
 *  @param typeHierarchy type hierarchy for materializing generic types
 */
private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy) {
    if (Modifier.isPublic(f.getModifiers())) {
        return true;
    } else {
        boolean hasGetter = false, hasSetter = false;
        final String fieldNameLow = f.getName().toLowerCase();
        Type fieldType = f.getGenericType();
        TypeVariable<?> fieldTypeGeneric = null;
        if (fieldType instanceof TypeVariable) {
            fieldTypeGeneric = (TypeVariable<?>) fieldType;
            fieldType = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) fieldType);
        }
        for (Method m : clazz.getMethods()) {
            // check for getter
            if (// The name should be ""get<FieldName>"" or ""<fieldName>"" (for scala) or ""is<fieldName>"" for boolean fields.
            (m.getName().toLowerCase().equals(""get"" + fieldNameLow) || m.getName().toLowerCase().equals(""is"" + fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow)) && // no arguments for the getter
            m.getParameterTypes().length == 0 && // return type is same as field type (or the generic variant of it)
            (m.getGenericReturnType().equals(fieldType) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)))) {
                if (hasGetter) {
                    throw new IllegalStateException(""Detected more than one getter"");
                }
                hasGetter = true;
            }
            // check for setters (<FieldName>_$eq for scala)
            if ((m.getName().toLowerCase().equals(""set"" + fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow + ""_$eq"")) && // one parameter of the field's type
            m.getParameterTypes().length == 1 && (m.getGenericParameterTypes()[0].equals(fieldType) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric))) && // return type is void.
            m.getReturnType().equals(Void.TYPE)) {
                if (hasSetter) {
                    throw new IllegalStateException(""Detected more than one setter"");
                }
                hasSetter = true;
            }
        }
        if (hasGetter && hasSetter) {
            return true;
        } else {
            if (!hasGetter) {
                LOG.warn(""Class "" + clazz + "" does not contain a getter for field "" + f.getName());
            }
            if (!hasSetter) {
                LOG.warn(""Class "" + clazz + "" does not contain a setter for field "" + f.getName());
            }
            return false;
        }
    }
}","/**
 *  Checks if the given field is a valid pojo field:
 *  - it is public
 *  OR
 *   - there are getter and setter methods for the field.
 *
 *  @param f field to check
 *  @param clazz class of field
 *  @param typeHierarchy type hierarchy for materializing generic types
 */
","private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy) {
    if (Modifier.isPublic(f.getModifiers())) {
        return true;
    } else {
        boolean hasGetter = false, hasSetter = false;
        final String fieldNameLow = f.getName().toLowerCase();
        Type fieldType = f.getGenericType();
        TypeVariable<?> fieldTypeGeneric = null;
        if (fieldType instanceof TypeVariable) {
            fieldTypeGeneric = (TypeVariable<?>) fieldType;
            fieldType = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) fieldType);
        }
        for (Method m : clazz.getMethods()) {
                        if (            (m.getName().toLowerCase().equals(""get"" + fieldNameLow) || m.getName().toLowerCase().equals(""is"" + fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow)) &&             m.getParameterTypes().length == 0 &&             (m.getGenericReturnType().equals(fieldType) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)))) {
                if (hasGetter) {
                    throw new IllegalStateException(""Detected more than one getter"");
                }
                hasGetter = true;
            }
                        if ((m.getName().toLowerCase().equals(""set"" + fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow + ""_$eq"")) &&             m.getParameterTypes().length == 1 && (m.getGenericParameterTypes()[0].equals(fieldType) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric))) &&             m.getReturnType().equals(Void.TYPE)) {
                if (hasSetter) {
                    throw new IllegalStateException(""Detected more than one setter"");
                }
                hasSetter = true;
            }
        }
        if (hasGetter && hasSetter) {
            return true;
        } else {
            if (!hasGetter) {
                LOG.warn(""Class "" + clazz + "" does not contain a getter for field "" + f.getName());
            }
            if (!hasSetter) {
                LOG.warn(""Class "" + clazz + "" does not contain a setter for field "" + f.getName());
            }
            return false;
        }
    }
}",1.3636363636363635,0.7033492822966506,1.8,1.0,2.9166666666666665,1.2460317460317458,-0.8474982381959123,2.6666666666666665,-0.02631578947368421,3.5861367081020954
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2528_239de7b8,1,"/**
 * Returns a map of all local property changes committed by the current
 * cluster node.
 *
 * @return local changes committed by the current cluster node.
 */
@Nonnull
private Map<String, NavigableMap<Revision, String>> getCommittedLocalChanges() {
    Map<String, NavigableMap<Revision, String>> committedLocally = new HashMap<String, NavigableMap<Revision, String>>();
    for (String property : filter(doc.keySet(), PROPERTY_OR_DELETED)) {
        NavigableMap<Revision, String> splitMap = new TreeMap<Revision, String>(context.getRevisionComparator());
        committedLocally.put(property, splitMap);
        Map<Revision, String> valueMap = doc.getLocalMap(property);
        // collect committed changes of this cluster node
        for (Map.Entry<Revision, String> entry : valueMap.entrySet()) {
            Revision rev = entry.getKey();
            if (rev.getClusterId() != context.getClusterId()) {
                continue;
            }
            if (doc.isCommitted(rev)) {
                splitMap.put(rev, entry.getValue());
            } else if (isGarbage(rev)) {
                addGarbage(rev, property);
            }
        }
    }
    return committedLocally;
}","/**
 * Returns a map of all local property changes committed by the current
 * cluster node.
 *
 * @return local changes committed by the current cluster node.
 */
","@Nonnull
private Map<String, NavigableMap<Revision, String>> getCommittedLocalChanges() {
    Map<String, NavigableMap<Revision, String>> committedLocally = new HashMap<String, NavigableMap<Revision, String>>();
    for (String property : filter(doc.keySet(), PROPERTY_OR_DELETED)) {
        NavigableMap<Revision, String> splitMap = new TreeMap<Revision, String>(context.getRevisionComparator());
        committedLocally.put(property, splitMap);
        Map<Revision, String> valueMap = doc.getLocalMap(property);
                for (Map.Entry<Revision, String> entry : valueMap.entrySet()) {
            Revision rev = entry.getKey();
            if (rev.getClusterId() != context.getClusterId()) {
                continue;
            }
            if (doc.isCommitted(rev)) {
                splitMap.put(rev, entry.getValue());
            } else if (isGarbage(rev)) {
                addGarbage(rev, property);
            }
        }
    }
    return committedLocally;
}",0.3181818181818182,1.0,0.6,1.0,0.25,0.10912698412698414,-0.33587033121916815,0.6666666666666666,-0.02631578947368421,0.2757790033597851
flink,remotes/origin/bugs-dot-jar_FLINK-2713_63d9800e,1,"@Override
public void restoreState(StateHandle<Serializable> snapshots, ClassLoader userCodeClassLoader) throws Exception {
    stateStore.restoreStates(snapshots, userCodeClassLoader);
}",,"@Override
public void restoreState(StateHandle<Serializable> snapshots, ClassLoader userCodeClassLoader) throws Exception {
    stateStore.restoreStates(snapshots, userCodeClassLoader);
}",-0.45454545454545453,-0.6028708133971293,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.7801268498942919,-0.4166666666666667,0.1842105263157895,-0.16279340490885932
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-1008_0c20bfd8,1,"/**
 * Sets an explicit ClassLoader that should be used when scanning for classes. If none
 * is set then the context classloader will be used.
 *
 * @param classloader a ClassLoader to use when scanning for classes
 */
public void setClassLoader(final ClassLoader classloader) {
    this.classloader = classloader;
}","/**
 * Sets an explicit ClassLoader that should be used when scanning for classes. If none
 * is set then the context classloader will be used.
 *
 * @param classloader a ClassLoader to use when scanning for classes
 */
","public void setClassLoader(final ClassLoader classloader) {
    this.classloader = classloader;
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,1.0606060606060603,-0.5,2.4736842105263155,-0.16279340490885932
wicket,remotes/origin/bugs-dot-jar_WICKET-5138_e8dab4a0,1,"/**
 *  A filterPath should have all leading slashes removed and exactly one trailing slash. A
 *  wildcard asterisk character has no special meaning. If your intention is to mean the top
 *  level ""/"" then an empty string should be used instead.
 *
 *  @param filterPath
 *  @return
 */
static String canonicaliseFilterPath(String filterPath) {
    if (Strings.isEmpty(filterPath)) {
        return filterPath;
    }
    int beginIndex = 0;
    int endIndex = filterPath.length();
    while (beginIndex < endIndex) {
        char c = filterPath.charAt(beginIndex);
        if (c != '/') {
            break;
        }
        beginIndex++;
    }
    int o;
    int i = o = beginIndex;
    while (i < endIndex) {
        char c = filterPath.charAt(i);
        i++;
        if (c != '/') {
            o = i;
        }
    }
    if (o < endIndex) {
        // include exactly one trailing slash
        o++;
        filterPath = filterPath.substring(beginIndex, o);
    } else {
        // ensure to append trailing slash
        filterPath = filterPath.substring(beginIndex) + '/';
    }
    if (filterPath.equals(""/"")) {
        return """";
    }
    return filterPath;
}","/**
 *  A filterPath should have all leading slashes removed and exactly one trailing slash. A
 *  wildcard asterisk character has no special meaning. If your intention is to mean the top
 *  level ""/"" then an empty string should be used instead.
 *
 *  @param filterPath
 *  @return
 */
","static String canonicaliseFilterPath(String filterPath) {
    if (Strings.isEmpty(filterPath)) {
        return filterPath;
    }
    int beginIndex = 0;
    int endIndex = filterPath.length();
    while (beginIndex < endIndex) {
        char c = filterPath.charAt(beginIndex);
        if (c != '/') {
            break;
        }
        beginIndex++;
    }
    int o;
    int i = o = beginIndex;
    while (i < endIndex) {
        char c = filterPath.charAt(i);
        i++;
        if (c != '/') {
            o = i;
        }
    }
    if (o < endIndex) {
                o++;
        filterPath = filterPath.substring(beginIndex, o);
    } else {
                filterPath = filterPath.substring(beginIndex) + '/';
    }
    if (filterPath.equals(""/"")) {
        return """";
    }
    return filterPath;
}",0.8636363636363636,-0.0909090909090911,1.0,0.0,0.8333333333333334,0.8690476190476191,-0.5295278365045805,0.08333333333333333,-0.02631578947368421,0.7974712285979378
wicket,remotes/origin/bugs-dot-jar_WICKET-5968_8b7946d8,1,"@Override
public IResourceStream locate(Class<?> scope, String path, String style, String variation, Locale locale, String extension, boolean strict) {
    CacheKey key = new CacheKey(scope.getName(), path, extension, locale, style, variation);
    IResourceStreamReference resourceStreamReference = cache.get(key);
    final IResourceStream result;
    if (resourceStreamReference == null) {
        result = delegate.locate(scope, path, style, variation, locale, extension, strict);
        updateCache(key, result);
    } else {
        result = resourceStreamReference.getReference();
    }
    return result;
}",,"@Override
public IResourceStream locate(Class<?> scope, String path, String style, String variation, Locale locale, String extension, boolean strict) {
    CacheKey key = new CacheKey(scope.getName(), path, extension, locale, style, variation);
    IResourceStreamReference resourceStreamReference = cache.get(key);
    final IResourceStream result;
    if (resourceStreamReference == null) {
        result = delegate.locate(scope, path, style, variation, locale, extension, strict);
        updateCache(key, result);
    } else {
        result = resourceStreamReference.getReference();
    }
    return result;
}",-0.045454545454545456,-0.1291866028708134,-0.4,-0.5,-0.25,0.03968253968253967,-0.0319943622269205,-0.08333333333333333,-0.02631578947368421,0.09924909089861284
wicket,remotes/origin/bugs-dot-jar_WICKET-4572_dfc56674,0,"/**
 *  Splits the window with given index to two windows. First of those will have size specified by
 *  the argument, the other one will fill up the rest of the original window.
 *
 *  @param index
 *  @param size
 */
private void splitWindow(int index, int size) {
    PageWindowInternal window = windows.get(index);
    int delta = window.filePartSize - size;
    if (index == windows.size() - 1) {
        // if this is last window
        totalSize -= delta;
        window.filePartSize = size;
    } else if (window.filePartSize != size) {
        PageWindowInternal newWindow = new PageWindowInternal();
        newWindow.pageId = -1;
        window.filePartSize = size;
        windows.add(index + 1, newWindow);
        newWindow.filePartOffset = getWindowFileOffset(index + 1);
        newWindow.filePartSize = delta;
    }
    idToWindowIndex = null;
}","/**
 *  Splits the window with given index to two windows. First of those will have size specified by
 *  the argument, the other one will fill up the rest of the original window.
 *
 *  @param index
 *  @param size
 */
","private void splitWindow(int index, int size) {
    PageWindowInternal window = windows.get(index);
    int delta = window.filePartSize - size;
    if (index == windows.size() - 1) {
                totalSize -= delta;
        window.filePartSize = size;
    } else if (window.filePartSize != size) {
        PageWindowInternal newWindow = new PageWindowInternal();
        newWindow.pageId = -1;
        window.filePartSize = size;
        windows.add(index + 1, newWindow);
        newWindow.filePartOffset = getWindowFileOffset(index + 1);
        newWindow.filePartSize = delta;
    }
    idToWindowIndex = null;
}",0.09090909090909091,-0.10047846889952174,-0.2,0.0,0.08333333333333333,1.1706349206349207,-0.14728682170542617,-0.16666666666666666,0.07894736842105263,0.9304564812733758
wicket,remotes/origin/bugs-dot-jar_WICKET-5019_917dd2b5,3,"/**
 *  Initializes the cache for the existence of the minified resource.
 *  @return the name of the minified resource or the special constant {@link #NO_MINIFIED_NAME}
 *  if there is no minified version
 */
private String internalGetMinifiedName() {
    String minifiedName = MINIFIED_NAMES_CACHE.get(this);
    if (minifiedName != null && minifiedName != NO_MINIFIED_NAME) {
        return minifiedName;
    }
    String name = getMinifiedName();
    IResourceStreamLocator locator = Application.get().getResourceSettings().getResourceStreamLocator();
    String absolutePath = Packages.absolutePath(getScope(), name);
    IResourceStream stream = locator.locate(getScope(), absolutePath, getStyle(), getVariation(), getLocale(), null, true);
    minifiedName = stream != null ? name : NO_MINIFIED_NAME;
    MINIFIED_NAMES_CACHE.put(this, minifiedName);
    if (minifiedName == NO_MINIFIED_NAME && log.isDebugEnabled()) {
        log.debug(""No minified version of '"" + super.getName() + ""' found, expected a file with the name '"" + name + ""', using full version"");
    }
    return minifiedName;
}","/**
 *  Initializes the cache for the existence of the minified resource.
 *  @return the name of the minified resource or the special constant {@link #NO_MINIFIED_NAME}
 *  if there is no minified version
 */
","private String internalGetMinifiedName() {
    String minifiedName = MINIFIED_NAMES_CACHE.get(this);
    if (minifiedName != null && minifiedName != NO_MINIFIED_NAME) {
        return minifiedName;
    }
    String name = getMinifiedName();
    IResourceStreamLocator locator = Application.get().getResourceSettings().getResourceStreamLocator();
    String absolutePath = Packages.absolutePath(getScope(), name);
    IResourceStream stream = locator.locate(getScope(), absolutePath, getStyle(), getVariation(), getLocale(), null, true);
    minifiedName = stream != null ? name : NO_MINIFIED_NAME;
    MINIFIED_NAMES_CACHE.put(this, minifiedName);
    if (minifiedName == NO_MINIFIED_NAME && log.isDebugEnabled()) {
        log.debug(""No minified version of '"" + super.getName() + ""' found, expected a file with the name '"" + name + ""', using full version"");
    }
    return minifiedName;
}",0.09090909090909091,-0.47368421052631593,0.0,-0.5,0.25,0.3333333333333333,-0.1822410147991544,0.8333333333333334,-0.02631578947368421,0.44105046593246994
wicket,remotes/origin/bugs-dot-jar_WICKET-4927_8c827e33,1,"@Override
public void clearCookie(Cookie cookie) {
    checkHeader();
    bufferedResponse.clearCookie(cookie);
}",,"@Override
public void clearCookie(Cookie cookie) {
    checkHeader();
    bufferedResponse.clearCookie(cookie);
}",-0.4090909090909091,-0.49282296650717716,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.7626497533474278,-0.3333333333333333,1.4736842105263157,-0.16279340490885932
wicket,remotes/origin/bugs-dot-jar_WICKET-172_99e22ce4,1,"/**
 *  @param component
 *             Component to remove from this container
 */
public void remove(final Component component) {
    if (component == null) {
        throw new IllegalArgumentException(""argument component may not be null"");
    }
    if (children_remove(component) != null) {
        component.setFlag(FLAG_REMOVED_FROM_PARENT, true);
        removedComponent(component);
    }
}","/**
 *  @param component
 *             Component to remove from this container
 */
","public void remove(final Component component) {
    if (component == null) {
        throw new IllegalArgumentException(""argument component may not be null"");
    }
    if (children_remove(component) != null) {
        component.setFlag(FLAG_REMOVED_FROM_PARENT, true);
        removedComponent(component);
    }
}",-0.22727272727272727,-0.01913875598086126,0.0,-0.5,-0.08333333333333333,-0.08333333333333336,0.3206483439041578,-0.25,1.7631578947368423,-0.11554664223186549
Math,81,1,"/**
 * Compute the Gershgorin circles for all rows.
 */
private void computeGershgorinCircles() {
    final int m = main.length;
    final int lowerStart = 4 * m;
    final int upperStart = 5 * m;
    lowerSpectra = Double.POSITIVE_INFINITY;
    upperSpectra = Double.NEGATIVE_INFINITY;
    double eMax = 0;
    double eCurrent = 0;
    for (int i = 0; i < m - 1; ++i) {
        final double dCurrent = main[i];
        final double ePrevious = eCurrent;
        eCurrent = Math.abs(secondary[i]);
        eMax = Math.max(eMax, eCurrent);
        final double radius = ePrevious + eCurrent;
        final double lower = dCurrent - radius;
        work[lowerStart + i] = lower;
        lowerSpectra = Math.min(lowerSpectra, lower);
        final double upper = dCurrent + radius;
        work[upperStart + i] = upper;
        upperSpectra = Math.max(upperSpectra, upper);
    }
    final double dCurrent = main[m - 1];
    final double lower = dCurrent - eCurrent;
    work[lowerStart + m - 1] = lower;
    lowerSpectra = Math.min(lowerSpectra, lower);
    final double upper = dCurrent + eCurrent;
    work[upperStart + m - 1] = upper;
    minPivot = MathUtils.SAFE_MIN * Math.max(1.0, eMax * eMax);
}","/**
 * Compute the Gershgorin circles for all rows.
 */
","private void computeGershgorinCircles() {
    final int m = main.length;
    final int lowerStart = 4 * m;
    final int upperStart = 5 * m;
    lowerSpectra = Double.POSITIVE_INFINITY;
    upperSpectra = Double.NEGATIVE_INFINITY;
    double eMax = 0;
    double eCurrent = 0;
    for (int i = 0; i < m - 1; ++i) {
        final double dCurrent = main[i];
        final double ePrevious = eCurrent;
        eCurrent = Math.abs(secondary[i]);
        eMax = Math.max(eMax, eCurrent);
        final double radius = ePrevious + eCurrent;
        final double lower = dCurrent - radius;
        work[lowerStart + i] = lower;
        lowerSpectra = Math.min(lowerSpectra, lower);
        final double upper = dCurrent + radius;
        work[upperStart + i] = upper;
        upperSpectra = Math.max(upperSpectra, upper);
    }
    final double dCurrent = main[m - 1];
    final double lower = dCurrent - eCurrent;
    work[lowerStart + m - 1] = lower;
    lowerSpectra = Math.min(lowerSpectra, lower);
    final double upper = dCurrent + eCurrent;
    work[upperStart + m - 1] = upper;
    minPivot = MathUtils.SAFE_MIN * Math.max(1.0, eMax * eMax);
}",0.6818181818181818,-0.29665071770334933,-0.4,-0.5,-0.16666666666666666,1.4206349206349207,-0.5495419309372798,0.0,-0.02631578947368421,3.083305383148055
camel,remotes/origin/bugs-dot-jar_CAMEL-3433_e76d23b0,3,"@Override
public String toString() {
    return """" + expression + "".convertTo("" + type.getCanonicalName() + "".class)"";
}",,"@Override
public String toString() {
    return """" + expression + "".convertTo("" + type.getCanonicalName() + "".class)"";
}",-0.45454545454545453,-0.6028708133971293,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.8046511627906971,-0.4166666666666667,1.8421052631578947,-0.16279340490885932
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-412_5594b2e0,1,"@Override
public void run() {
    ClientService.Iface client = null;
    try {
        client = ServerClient.getConnection(HdfsZooInstance.getInstance());
        List<String> fail = client.bulkImportFiles(null, SecurityConstants.getSystemCredentials(), tid, tableId, attempt, errorDir, setTime);
        attempt.removeAll(fail);
        filesToLoad.removeAll(attempt);
    } catch (Exception ex) {
        log.error(ex, ex);
    } finally {
        ServerClient.close(client);
    }
}",,"@Override
public void run() {
    ClientService.Iface client = null;
    try {
        client = ServerClient.getConnection(HdfsZooInstance.getInstance());
        List<String> fail = client.bulkImportFiles(null, SecurityConstants.getSystemCredentials(), tid, tableId, attempt, errorDir, setTime);
        attempt.removeAll(fail);
        filesToLoad.removeAll(attempt);
    } catch (Exception ex) {
        log.error(ex, ex);
    } finally {
        ServerClient.close(client);
    }
}",0.0,0.04784688995215294,-0.4,-0.5,-0.4166666666666667,-0.3650793650793651,-0.024947145877378573,0.16666666666666666,-0.02631578947368421,-0.16279340490885932
Closure,37,2,"/**
 * Traverses a function.
 */
private void traverseFunction(Node n, Node parent) {
    Preconditions.checkState(n.getChildCount() == 3);
    Preconditions.checkState(n.isFunction());
    final Node fnName = n.getFirstChild();
    boolean isFunctionExpression = (parent != null) && NodeUtil.isFunctionExpression(n);
    if (!isFunctionExpression) {
        // Functions declarations are in the scope containing the declaration.
        traverseBranch(fnName, n);
    }
    curNode = n;
    pushScope(n);
    if (isFunctionExpression) {
        // Function expression names are only accessible within the function
        // scope.
        traverseBranch(fnName, n);
    }
    final Node args = fnName.getNext();
    final Node body = args.getNext();
    // Args
    traverseBranch(args, n);
    // Body
    Preconditions.checkState(body.getNext() == null && body.isBlock());
    traverseBranch(body, n);
    popScope();
}","/**
 * Traverses a function.
 */
","private void traverseFunction(Node n, Node parent) {
    Preconditions.checkState(n.getChildCount() == 3);
    Preconditions.checkState(n.isFunction());
    final Node fnName = n.getFirstChild();
    boolean isFunctionExpression = (parent != null) && NodeUtil.isFunctionExpression(n);
    if (!isFunctionExpression) {
                traverseBranch(fnName, n);
    }
    curNode = n;
    pushScope(n);
    if (isFunctionExpression) {
                        traverseBranch(fnName, n);
    }
    final Node args = fnName.getNext();
    final Node body = args.getNext();
        traverseBranch(args, n);
        Preconditions.checkState(body.getNext() == null && body.isBlock());
    traverseBranch(body, n);
    popScope();
}",0.2727272727272727,-0.5741626794258374,-0.2,-0.5,-0.16666666666666666,0.6527777777777778,-0.262861169837914,0.9166666666666666,0.2368421052631579,0.6331679373915848
commons-math,remotes/origin/bugs-dot-jar_MATH-1088_63d88c74,3,"/**
 * @return the unidimensional count after the counter has been
 * incremented by {@code 1}.
 */
public Integer next() {
    for (int i = last; i >= 0; i--) {
        if (counter[i] == size[i] - 1) {
            counter[i] = 0;
        } else {
            ++counter[i];
            break;
        }
    }
    return ++count;
}","/**
 * @return the unidimensional count after the counter has been
 * incremented by {@code 1}.
 */
","public Integer next() {
    for (int i = last; i >= 0; i--) {
        if (counter[i] == size[i] - 1) {
            counter[i] = 0;
        } else {
            ++counter[i];
            break;
        }
    }
    return ++count;
}",-0.13636363636363635,0.6124401913875596,0.0,0.0,-0.16666666666666666,0.7658730158730159,0.1704016913319239,-0.5,2.3947368421052633,0.12101911562156023
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1727_26041fe7,1,"@Override
public int compare(Revision o1, Revision o2) {
    if (o1.getClusterId() == o2.getClusterId()) {
        return o1.compareRevisionTime(o2);
    }
    Revision range1 = getRevisionSeen(o1);
    Revision range2 = getRevisionSeen(o2);
    if (range1 == FUTURE && range2 == FUTURE) {
        return o1.compareRevisionTimeThenClusterId(o2);
    }
    if (range1 == null || range2 == null) {
        return o1.compareRevisionTimeThenClusterId(o2);
    }
    int comp = range1.compareRevisionTimeThenClusterId(range2);
    if (comp != 0) {
        return comp;
    }
    return Integer.signum(o1.getClusterId() - o2.getClusterId());
}",,"@Override
public int compare(Revision o1, Revision o2) {
    if (o1.getClusterId() == o2.getClusterId()) {
        return o1.compareRevisionTime(o2);
    }
    Revision range1 = getRevisionSeen(o1);
    Revision range2 = getRevisionSeen(o2);
    if (range1 == FUTURE && range2 == FUTURE) {
        return o1.compareRevisionTimeThenClusterId(o2);
    }
    if (range1 == null || range2 == null) {
        return o1.compareRevisionTimeThenClusterId(o2);
    }
    int comp = range1.compareRevisionTimeThenClusterId(range2);
    if (comp != 0) {
        return comp;
    }
    return Integer.signum(o1.getClusterId() - o2.getClusterId());
}",0.22727272727272727,-0.2727272727272729,0.2,-0.5,0.5,1.255952380952381,-0.2250880902043692,0.4166666666666667,0.02631578947368421,0.8902450971917265
wicket,remotes/origin/bugs-dot-jar_WICKET-5447_2abc18f1,3,"@Override
public void afterRender(Component component) {
    Response response = component.getResponse();
    for (int i = 0; i < branches.length; i++) {
        response.write(""</div>"");
    }
}",,"@Override
public void afterRender(Component component) {
    Response response = component.getResponse();
    for (int i = 0; i < branches.length; i++) {
        response.write(""</div>"");
    }
}",-0.3181818181818182,-0.0909090909090911,-0.4,-0.5,-0.16666666666666666,-0.10912698412698414,0.41649048625792817,-0.3333333333333333,0.6052631578947368,-0.109488655682532
Lang,33,1,"/**
 * <p>Converts an array of <code>Object</code> in to an array of <code>Class</code> objects.
 * If any of these objects is null, a null element will be inserted into the array.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array an <code>Object</code> array
 * @return a <code>Class</code> array, <code>null</code> if null array input
 * @since 2.4
 */
public static Class<?>[] toClass(Object[] array) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return ArrayUtils.EMPTY_CLASS_ARRAY;
    }
    Class<?>[] classes = new Class[array.length];
    for (int i = 0; i < array.length; i++) {
        classes[i] = array[i].getClass();
    }
    return classes;
}","/**
 * <p>Converts an array of <code>Object</code> in to an array of <code>Class</code> objects.
 * If any of these objects is null, a null element will be inserted into the array.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array an <code>Object</code> array
 * @return a <code>Class</code> array, <code>null</code> if null array input
 * @since 2.4
 */
","public static Class<?>[] toClass(Object[] array) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return ArrayUtils.EMPTY_CLASS_ARRAY;
    }
    Class<?>[] classes = new Class[array.length];
    for (int i = 0; i < array.length; i++) {
        classes[i] = array[i].getClass();
    }
    return classes;
}",-0.09090909090909091,-0.20574162679425848,0.0,0.0,0.08333333333333333,0.5515873015873016,0.081324876673714,-0.4166666666666667,-0.02631578947368421,0.15901292624032545
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-621_00b4b8a0,1,"@Override
protected synchronized NodeBuilder getNodeBuilder() {
    if (nodeBuilder == null) {
        nodeBuilder = root.createRootBuilder();
    }
    return nodeBuilder;
}",,"@Override
protected synchronized NodeBuilder getNodeBuilder() {
    if (nodeBuilder == null) {
        nodeBuilder = root.createRootBuilder();
    }
    return nodeBuilder;
}",-0.3181818181818182,-0.0909090909090911,-0.4,-0.5,-0.25,-0.11706349206349208,0.5357293868921773,-0.4166666666666667,1.3157894736842106,-0.13982008148775665
Lang,20,1,"/**
 * <p>Joins the elements of the provided array into a single String
 * containing the provided list of elements.</p>
 *
 * <p>No delimiter is added before or after the list.
 * A {@code null} separator is the same as an empty String ("""").
 * Null objects or empty strings within the array are represented by
 * empty strings.</p>
 *
 * <pre>
 * StringUtils.join(null, *)                = null
 * StringUtils.join([], *)                  = """"
 * StringUtils.join([null], *)              = """"
 * StringUtils.join([""a"", ""b"", ""c""], ""--"")  = ""a--b--c""
 * StringUtils.join([""a"", ""b"", ""c""], null)  = ""abc""
 * StringUtils.join([""a"", ""b"", ""c""], """")    = ""abc""
 * StringUtils.join([null, """", ""a""], ',')   = "",,a""
 * </pre>
 *
 * @param array  the array of values to join together, may be null
 * @param separator  the separator character to use, null treated as """"
 * @param startIndex the first index to start joining from.  It is
 * an error to pass in an end index past the end of the array
 * @param endIndex the index to stop joining from (exclusive). It is
 * an error to pass in an end index past the end of the array
 * @return the joined String, {@code null} if null array input
 */
public static String join(Object[] array, String separator, int startIndex, int endIndex) {
    if (array == null) {
        return null;
    }
    if (separator == null) {
        separator = EMPTY;
    }
    // endIndex - startIndex > 0:   Len = NofStrings *(len(firstString) + len(separator))
    // (Assuming that all Strings are roughly equally long)
    int noOfItems = (endIndex - startIndex);
    if (noOfItems <= 0) {
        return EMPTY;
    }
    StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length());
    for (int i = startIndex; i < endIndex; i++) {
        if (i > startIndex) {
            buf.append(separator);
        }
        if (array[i] != null) {
            buf.append(array[i]);
        }
    }
    return buf.toString();
}","/**
 * <p>Joins the elements of the provided array into a single String
 * containing the provided list of elements.</p>
 *
 * <p>No delimiter is added before or after the list.
 * A {@code null} separator is the same as an empty String ("""").
 * Null objects or empty strings within the array are represented by
 * empty strings.</p>
 *
 * <pre>
 * StringUtils.join(null, *)                = null
 * StringUtils.join([], *)                  = """"
 * StringUtils.join([null], *)              = """"
 * StringUtils.join([""a"", ""b"", ""c""], ""--"")  = ""a--b--c""
 * StringUtils.join([""a"", ""b"", ""c""], null)  = ""abc""
 * StringUtils.join([""a"", ""b"", ""c""], """")    = ""abc""
 * StringUtils.join([null, """", ""a""], ',')   = "",,a""
 * </pre>
 *
 * @param array  the array of values to join together, may be null
 * @param separator  the separator character to use, null treated as """"
 * @param startIndex the first index to start joining from.  It is
 * an error to pass in an end index past the end of the array
 * @param endIndex the index to stop joining from (exclusive). It is
 * an error to pass in an end index past the end of the array
 * @return the joined String, {@code null} if null array input
 */
","public static String join(Object[] array, String separator, int startIndex, int endIndex) {
    if (array == null) {
        return null;
    }
    if (separator == null) {
        separator = EMPTY;
    }
            int noOfItems = (endIndex - startIndex);
    if (noOfItems <= 0) {
        return EMPTY;
    }
    StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length());
    for (int i = startIndex; i < endIndex; i++) {
        if (i > startIndex) {
            buf.append(separator);
        }
        if (array[i] != null) {
            buf.append(array[i]);
        }
    }
    return buf.toString();
}",0.36363636363636365,0.057416267942583574,0.8,0.0,0.6666666666666666,1.8908730158730158,-0.3344608879492598,0.0,-0.02631578947368421,1.55056563106908
Math,34,1,"/**
 * Returns an iterator over the unmodifiable list of chromosomes.
 * <p>Any call to {@link Iterator#remove()} will result in a {@link UnsupportedOperationException}.</p>
 *
 * @return chromosome iterator
 */
public Iterator<Chromosome> iterator() {
    return chromosomes.iterator();
}","/**
 * Returns an iterator over the unmodifiable list of chromosomes.
 * <p>Any call to {@link Iterator#remove()} will result in a {@link UnsupportedOperationException}.</p>
 *
 * @return chromosome iterator
 */
","public Iterator<Chromosome> iterator() {
    return chromosomes.iterator();
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,1.083157152924595,-0.4166666666666667,2.5789473684210527,-0.16279340490885932
Compress,24,0,"/**
 * Parse an octal string from a buffer.
 *
 * <p>Leading spaces are ignored.
 * The buffer must contain a trailing space or NUL,
 * and may contain an additional trailing space or NUL.</p>
 *
 * <p>The input buffer is allowed to contain all NULs,
 * in which case the method returns 0L
 * (this allows for missing fields).</p>
 *
 * <p>To work-around some tar implementations that insert a
 * leading NUL this method returns 0 if it detects a leading NUL
 * since Commons Compress 1.4.</p>
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse - must be at least 2 bytes.
 * @return The long value of the octal string.
 * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.
 */
public static long parseOctal(final byte[] buffer, final int offset, final int length) {
    long result = 0;
    int end = offset + length;
    int start = offset;
    if (length < 2) {
        throw new IllegalArgumentException(""Length "" + length + "" must be at least 2"");
    }
    if (buffer[start] == 0) {
        return 0L;
    }
    // Skip leading spaces
    while (start < end) {
        if (buffer[start] == ' ') {
            start++;
        } else {
            break;
        }
    }
    // Trim all trailing NULs and spaces.
    // The ustar and POSIX tar specs require a trailing NUL or
    // space but some implementations use the extra digit for big
    // sizes/uids/gids ...
    byte trailer = buffer[end - 1];
    if (trailer == 0 || trailer == ' ') {
        end--;
    } else {
        throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, end - 1, trailer));
    }
    trailer = buffer[end - 1];
    while (start < end - 1 && (trailer == 0 || trailer == ' ')) {
        end--;
        trailer = buffer[end - 1];
    }
    for (; start < end; start++) {
        final byte currentByte = buffer[start];
        // CheckStyle:MagicNumber OFF
        if (currentByte < '0' || currentByte > '7') {
            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));
        }
        // convert from ASCII
        result = (result << 3) + (currentByte - '0');
    // CheckStyle:MagicNumber ON
    }
    return result;
}","/**
 * Parse an octal string from a buffer.
 *
 * <p>Leading spaces are ignored.
 * The buffer must contain a trailing space or NUL,
 * and may contain an additional trailing space or NUL.</p>
 *
 * <p>The input buffer is allowed to contain all NULs,
 * in which case the method returns 0L
 * (this allows for missing fields).</p>
 *
 * <p>To work-around some tar implementations that insert a
 * leading NUL this method returns 0 if it detects a leading NUL
 * since Commons Compress 1.4.</p>
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse - must be at least 2 bytes.
 * @return The long value of the octal string.
 * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.
 */
","public static long parseOctal(final byte[] buffer, final int offset, final int length) {
    long result = 0;
    int end = offset + length;
    int start = offset;
    if (length < 2) {
        throw new IllegalArgumentException(""Length "" + length + "" must be at least 2"");
    }
    if (buffer[start] == 0) {
        return 0L;
    }
        while (start < end) {
        if (buffer[start] == ' ') {
            start++;
        } else {
            break;
        }
    }
                    byte trailer = buffer[end - 1];
    if (trailer == 0 || trailer == ' ') {
        end--;
    } else {
        throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, end - 1, trailer));
    }
    trailer = buffer[end - 1];
    while (start < end - 1 && (trailer == 0 || trailer == ' ')) {
        end--;
        trailer = buffer[end - 1];
    }
    for (; start < end; start++) {
        final byte currentByte = buffer[start];
                if (currentByte < '0' || currentByte > '7') {
            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));
        }
                result = (result << 3) + (currentByte - '0');
        }
    return result;
}",1.0454545454545454,-0.05263157894736858,1.8,0.0,1.0,3.6031746031746033,-0.6958421423537702,-0.3333333333333333,-0.02631578947368421,5.461821199495167
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-621_00b4b8a0,1,"@Override
public Iterable<? extends PropertyState> getProperties() {
    root.checkLive();
    return Iterables.filter(getNodeBuilder().getProperties(), new Predicate<PropertyState>() {

        @Override
        public boolean apply(PropertyState propertyState) {
            return canRead(propertyState);
        }
    });
}",,"@Override
public Iterable<? extends PropertyState> getProperties() {
    root.checkLive();
    return Iterables.filter(getNodeBuilder().getProperties(), new Predicate<PropertyState>() {

        @Override
        public boolean apply(PropertyState propertyState) {
            return canRead(propertyState);
        }
    });
}",-0.18181818181818182,0.4449760765550238,-0.6,-0.5,-0.4166666666666667,-0.3650793650793651,0.2918957011980268,-0.08333333333333333,0.3684210526315789,-0.16279340490885932
Closure,11,2,"/**
 * Visits a GETPROP node.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of <code>n</code>
 */
private void visitGetProp(NodeTraversal t, Node n, Node parent) {
    // obj.prop or obj.method()
    // Lots of types can appear on the left, a call to a void function can
    // never be on the left. getPropertyType will decide what is acceptable
    // and what isn't.
    Node property = n.getLastChild();
    Node objNode = n.getFirstChild();
    JSType childType = getJSType(objNode);
    if (childType.isDict()) {
        report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, ""'.'"", ""dict"");
    } else if (n.getJSType() != null && parent.isAssign()) {
        return;
    } else if (validator.expectNotNullOrUndefined(t, n, childType, ""No properties on this expression"", getNativeType(OBJECT_TYPE))) {
        checkPropertyAccess(childType, property.getString(), t, n);
    }
    ensureTyped(t, n);
}","/**
 * Visits a GETPROP node.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of <code>n</code>
 */
","private void visitGetProp(NodeTraversal t, Node n, Node parent) {
                    Node property = n.getLastChild();
    Node objNode = n.getFirstChild();
    JSType childType = getJSType(objNode);
    if (childType.isDict()) {
        report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, ""'.'"", ""dict"");
    } else if (n.getJSType() != null && parent.isAssign()) {
        return;
    } else if (validator.expectNotNullOrUndefined(t, n, childType, ""No properties on this expression"", getNativeType(OBJECT_TYPE))) {
        checkPropertyAccess(childType, property.getString(), t, n);
    }
    ensureTyped(t, n);
}",-0.045454545454545456,-0.25358851674641164,0.0,0.5,0.5833333333333334,-0.0277777777777778,-0.046934460887949024,0.5,0.0,0.058608945211873924
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-43_668f08f2,1,"void apply() throws Exception {
    copyNode(srcPath, destPath);
}",,"void apply() throws Exception {
    copyNode(srcPath, destPath);
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,1.0676532769556022,-0.4166666666666667,1.6578947368421053,-0.16279340490885932
Lang,36,3,"/**
 * <p>Checks whether the String a valid Java number.</p>
 *
 * <p>Valid numbers include hexadecimal marked with the <code>0x</code>
 * qualifier, scientific notation and numbers marked with a type
 * qualifier (e.g. 123L).</p>
 *
 * <p><code>Null</code> and empty String will return
 * <code>false</code>.</p>
 *
 * @param str  the <code>String</code> to check
 * @return <code>true</code> if the string is a correctly formatted number
 */
public static boolean isNumber(String str) {
    if (StringUtils.isEmpty(str)) {
        return false;
    }
    char[] chars = str.toCharArray();
    int sz = chars.length;
    boolean hasExp = false;
    boolean hasDecPoint = false;
    boolean allowSigns = false;
    boolean foundDigit = false;
    // deal with any possible sign up front
    int start = (chars[0] == '-') ? 1 : 0;
    if (sz > start + 1) {
        if (chars[start] == '0' && chars[start + 1] == 'x') {
            int i = start + 2;
            if (i == sz) {
                // str == ""0x""
                return false;
            }
            // checking hex (it can't be anything else)
            for (; i < chars.length; i++) {
                if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) {
                    return false;
                }
            }
            return true;
        }
    }
    // don't want to loop to the last char, check it afterwords
    sz--;
    // for type qualifiers
    int i = start;
    // make a valid number (e.g. chars[0..5] = ""1234E"")
    while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {
        if (chars[i] >= '0' && chars[i] <= '9') {
            foundDigit = true;
            allowSigns = false;
        } else if (chars[i] == '.') {
            if (hasDecPoint || hasExp) {
                // two decimal points or dec in exponent
                return false;
            }
            hasDecPoint = true;
        } else if (chars[i] == 'e' || chars[i] == 'E') {
            // we've already taken care of hex.
            if (hasExp) {
                // two E's
                return false;
            }
            if (!foundDigit) {
                return false;
            }
            hasExp = true;
            allowSigns = true;
        } else if (chars[i] == '+' || chars[i] == '-') {
            if (!allowSigns) {
                return false;
            }
            allowSigns = false;
            // we need a digit after the E
            foundDigit = false;
        } else {
            return false;
        }
        i++;
    }
    if (i < chars.length) {
        if (chars[i] >= '0' && chars[i] <= '9') {
            // no type qualifier, OK
            return true;
        }
        if (chars[i] == 'e' || chars[i] == 'E') {
            // can't have an E at the last byte
            return false;
        }
        if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) {
            return foundDigit;
        }
        if (chars[i] == 'l' || chars[i] == 'L') {
            // not allowing L with an exponent
            return foundDigit && !hasExp;
        }
        // last character is illegal
        return false;
    }
    // found digit it to make sure weird stuff like '.' and '1E-' doesn't pass
    return !allowSigns && foundDigit;
}","/**
 * <p>Checks whether the String a valid Java number.</p>
 *
 * <p>Valid numbers include hexadecimal marked with the <code>0x</code>
 * qualifier, scientific notation and numbers marked with a type
 * qualifier (e.g. 123L).</p>
 *
 * <p><code>Null</code> and empty String will return
 * <code>false</code>.</p>
 *
 * @param str  the <code>String</code> to check
 * @return <code>true</code> if the string is a correctly formatted number
 */
","public static boolean isNumber(String str) {
    if (StringUtils.isEmpty(str)) {
        return false;
    }
    char[] chars = str.toCharArray();
    int sz = chars.length;
    boolean hasExp = false;
    boolean hasDecPoint = false;
    boolean allowSigns = false;
    boolean foundDigit = false;
        int start = (chars[0] == '-') ? 1 : 0;
    if (sz > start + 1) {
        if (chars[start] == '0' && chars[start + 1] == 'x') {
            int i = start + 2;
            if (i == sz) {
                                return false;
            }
                        for (; i < chars.length; i++) {
                if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) {
                    return false;
                }
            }
            return true;
        }
    }
        sz--;
        int i = start;
        while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {
        if (chars[i] >= '0' && chars[i] <= '9') {
            foundDigit = true;
            allowSigns = false;
        } else if (chars[i] == '.') {
            if (hasDecPoint || hasExp) {
                                return false;
            }
            hasDecPoint = true;
        } else if (chars[i] == 'e' || chars[i] == 'E') {
                        if (hasExp) {
                                return false;
            }
            if (!foundDigit) {
                return false;
            }
            hasExp = true;
            allowSigns = true;
        } else if (chars[i] == '+' || chars[i] == '-') {
            if (!allowSigns) {
                return false;
            }
            allowSigns = false;
                        foundDigit = false;
        } else {
            return false;
        }
        i++;
    }
    if (i < chars.length) {
        if (chars[i] >= '0' && chars[i] <= '9') {
                        return true;
        }
        if (chars[i] == 'e' || chars[i] == 'E') {
                        return false;
        }
        if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) {
            return foundDigit;
        }
        if (chars[i] == 'l' || chars[i] == 'L') {
                        return foundDigit && !hasExp;
        }
                return false;
    }
        return !allowSigns && foundDigit;
}",2.6818181818181817,0.6076555023923443,3.6,2.0,3.8333333333333335,5.125,-1.1846370683579983,-0.3333333333333333,-0.02631578947368421,17.504162560582742
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-498_f2a2edec,1,"@Override
public boolean parent() {
    if (elements.isEmpty() || "".."".equals(elements.get(elements.size() - 1))) {
        elements.add("".."");
        return true;
    }
    elements.remove(elements.size() - 1);
    return true;
}",,"@Override
public boolean parent() {
    if (elements.isEmpty() || "".."".equals(elements.get(elements.size() - 1))) {
        elements.add("".."");
        return true;
    }
    elements.remove(elements.size() - 1);
    return true;
}",-0.22727272727272727,-0.01913875598086126,-0.4,-0.5,0.08333333333333333,-0.029761904761904788,0.2896405919661735,0.08333333333333333,-0.02631578947368421,-0.08658909769886412
camel,remotes/origin/bugs-dot-jar_CAMEL-7239_ae419224,1,"// Properties
// -----------------------------------------------------------------------
public Schema getSchema() throws IOException, SAXException {
    if (schema == null) {
        schema = createSchema();
    }
    return schema;
}",,"public Schema getSchema() throws IOException, SAXException {
    if (schema == null) {
        schema = createSchema();
    }
    return schema;
}",-0.36363636363636365,-0.11483253588516758,-0.4,-0.5,-0.25,-0.11706349206349208,0.6062015503875966,-0.4166666666666667,2.5789473684210527,-0.13982008148775665
wicket,remotes/origin/bugs-dot-jar_WICKET-5724_b92591f6,1,"/**
 *  Creates a new instance of auto component to be queued
 */
Component newComponent(ComponentTag tag);","/**
 *  Creates a new instance of auto component to be queued
 */
",Component newComponent(ComponentTag tag);,-0.5909090909090909,-1.4306220095693782,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,1.6116983791402395,-0.5,2.6052631578947367,-0.16279340490885932
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-2713_6138a80f,0,"public static CryptoModuleParameters fillParamsObjectFromConfiguration(CryptoModuleParameters params, AccumuloConfiguration conf) {
    // Get all the options from the configuration
    Map<String, String> cryptoOpts = conf.getAllPropertiesWithPrefix(Property.CRYPTO_PREFIX);
    cryptoOpts.putAll(conf.getAllPropertiesWithPrefix(Property.INSTANCE_PREFIX));
    cryptoOpts.put(Property.CRYPTO_BLOCK_STREAM_SIZE.getKey(), Integer.toString((int) conf.getMemoryInBytes(Property.CRYPTO_BLOCK_STREAM_SIZE)));
    return fillParamsObjectFromStringMap(params, cryptoOpts);
}",,"public static CryptoModuleParameters fillParamsObjectFromConfiguration(CryptoModuleParameters params, AccumuloConfiguration conf) {
        Map<String, String> cryptoOpts = conf.getAllPropertiesWithPrefix(Property.CRYPTO_PREFIX);
    cryptoOpts.putAll(conf.getAllPropertiesWithPrefix(Property.INSTANCE_PREFIX));
    cryptoOpts.put(Property.CRYPTO_BLOCK_STREAM_SIZE.getKey(), Integer.toString((int) conf.getMemoryInBytes(Property.CRYPTO_BLOCK_STREAM_SIZE)));
    return fillParamsObjectFromStringMap(params, cryptoOpts);
}",-0.36363636363636365,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.4085976039464412,0.16666666666666666,0.0,-0.16279340490885932
commons-math,remotes/origin/bugs-dot-jar_MATH-957_9aabf587,1,"/**
 * {@inheritDoc}
 */
@Override
protected double getSolverAbsoluteAccuracy() {
    return solverAbsoluteAccuracy;
}","/**
 * {@inheritDoc}
 */
","@Override
protected double getSolverAbsoluteAccuracy() {
    return solverAbsoluteAccuracy;
}",-0.45454545454545453,-0.6028708133971293,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,1.0332628611698378,-0.5,2.526315789473684,-0.16279340490885932
camel,remotes/origin/bugs-dot-jar_CAMEL-3545_050c542e,1,"@Override
public Expression createExpression(CamelContext camelContext) {
    if (beanType != null) {
        instance = ObjectHelper.newInstance(beanType);
        return new BeanExpression(instance, getMethod(), parameterType);
    } else if (instance != null) {
        return new BeanExpression(instance, getMethod(), parameterType);
    } else {
        String ref = beanName();
        // if its a ref then check that the ref exists
        BeanHolder holder = new RegistryBean(camelContext, ref);
        // get the bean which will check that it exists
        instance = holder.getBean();
        // only validate when it was a ref for a bean, so we can eager check
        // this on startup of Camel
        validateHasMethod(camelContext, instance, getMethod(), parameterType);
        return new BeanExpression(ref, getMethod(), parameterType);
    }
}",,"@Override
public Expression createExpression(CamelContext camelContext) {
    if (beanType != null) {
        instance = ObjectHelper.newInstance(beanType);
        return new BeanExpression(instance, getMethod(), parameterType);
    } else if (instance != null) {
        return new BeanExpression(instance, getMethod(), parameterType);
    } else {
        String ref = beanName();
                BeanHolder holder = new RegistryBean(camelContext, ref);
                instance = holder.getBean();
                        validateHasMethod(camelContext, instance, getMethod(), parameterType);
        return new BeanExpression(ref, getMethod(), parameterType);
    }
}",0.045454545454545456,0.08133971291866025,-0.2,0.0,-0.08333333333333333,0.013888888888888857,-0.0692036645525017,0.16666666666666666,-0.02631578947368421,0.03091002345510391
commons-math,remotes/origin/bugs-dot-jar_MATH-891_2b852d79,1,"/**
 * Computes the Spearman's rank correlation matrix for the columns of the
 * input matrix.
 *
 * @param matrix matrix with columns representing variables to correlate
 * @return correlation matrix
 */
public RealMatrix computeCorrelationMatrix(RealMatrix matrix) {
    RealMatrix matrixCopy = matrix.copy();
    rankTransform(matrixCopy);
    return new PearsonsCorrelation().computeCorrelationMatrix(matrixCopy);
}","/**
 * Computes the Spearman's rank correlation matrix for the columns of the
 * input matrix.
 *
 * @param matrix matrix with columns representing variables to correlate
 * @return correlation matrix
 */
","public RealMatrix computeCorrelationMatrix(RealMatrix matrix) {
    RealMatrix matrixCopy = matrix.copy();
    rankTransform(matrixCopy);
    return new PearsonsCorrelation().computeCorrelationMatrix(matrixCopy);
}",-0.4090909090909091,-0.49282296650717716,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.6701902748414377,-0.25,2.1842105263157894,-0.16279340490885932
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1429_c2f5ca6c,1,"@Override
public DocumentNodeState apply(String input) {
    return getNode(input, readRevision);
}",,"@Override
public DocumentNodeState apply(String input) {
    return getNode(input, readRevision);
}",-0.45454545454545453,-0.6028708133971293,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.8548273431994357,-0.4166666666666667,1.526315789473684,-0.16279340490885932
camel,remotes/origin/bugs-dot-jar_CAMEL-7795_19b2aa31,1,"public void done(boolean doneSync) {
    try {
        if (!doneSync) {
            // when done asynchronously then restore information from previous thread
            if (breadcrumbId != null) {
                MDC.put(MDC_BREADCRUMB_ID, breadcrumbId);
            }
            if (exchangeId != null) {
                MDC.put(MDC_EXCHANGE_ID, exchangeId);
            }
            if (messageId != null) {
                MDC.put(MDC_MESSAGE_ID, messageId);
            }
            if (correlationId != null) {
                MDC.put(MDC_CORRELATION_ID, correlationId);
            }
            if (routeId != null) {
                MDC.put(MDC_ROUTE_ID, routeId);
            }
            if (camelContextId != null) {
                MDC.put(MDC_CAMEL_CONTEXT_ID, camelContextId);
            }
        }
    } finally {
        // muse ensure delegate is invoked
        delegate.done(doneSync);
    }
}",,"public void done(boolean doneSync) {
    try {
        if (!doneSync) {
                        if (breadcrumbId != null) {
                MDC.put(MDC_BREADCRUMB_ID, breadcrumbId);
            }
            if (exchangeId != null) {
                MDC.put(MDC_EXCHANGE_ID, exchangeId);
            }
            if (messageId != null) {
                MDC.put(MDC_MESSAGE_ID, messageId);
            }
            if (correlationId != null) {
                MDC.put(MDC_CORRELATION_ID, correlationId);
            }
            if (routeId != null) {
                MDC.put(MDC_ROUTE_ID, routeId);
            }
            if (camelContextId != null) {
                MDC.put(MDC_CAMEL_CONTEXT_ID, camelContextId);
            }
        }
    } finally {
                delegate.done(doneSync);
    }
}",0.5454545454545454,0.8181818181818182,0.8,0.5,0.75,0.08333333333333327,-0.35250176180408715,0.08333333333333333,-0.02631578947368421,0.06635431614252862
Closure,98,1,"/**
 * @return Whether the variable is only assigned a value once for its
 *     lifetime.
 */
boolean isAssignedOnceInLifetime() {
    Reference ref = getOneAndOnlyAssignment();
    if (ref == null) {
        return false;
    }
    return true;
}","/**
 * @return Whether the variable is only assigned a value once for its
 *     lifetime.
 */
","boolean isAssignedOnceInLifetime() {
    Reference ref = getOneAndOnlyAssignment();
    if (ref == null) {
        return false;
    }
    return true;
}",-0.3181818181818182,-0.20574162679425848,-0.4,-0.5,-0.25,-0.14285714285714285,0.5484143763213529,-0.4166666666666667,2.5,-0.14384029782795363
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1287_14849e22,1,"public List<RecordId> getEntries() {
    if (size == 0) {
        return emptyList();
    } else if (size == 1) {
        return singletonList(getRecordId());
    } else {
        List<RecordId> list = newArrayListWithCapacity(size);
        Segment segment = getSegment();
        int offset = getOffset();
        for (int i = 0; i < size; i += bucketSize) {
            RecordId id = segment.readRecordId(offset);
            if (bucketSize == 1) {
                list.add(id);
            } else {
                ListRecord bucket = new ListRecord(segment, id, Math.min(bucketSize, size - offset));
                list.addAll(bucket.getEntries());
            }
            offset += Segment.RECORD_ID_BYTES;
        }
        return list;
    }
}",,"public List<RecordId> getEntries() {
    if (size == 0) {
        return emptyList();
    } else if (size == 1) {
        return singletonList(getRecordId());
    } else {
        List<RecordId> list = newArrayListWithCapacity(size);
        Segment segment = getSegment();
        int offset = getOffset();
        for (int i = 0; i < size; i += bucketSize) {
            RecordId id = segment.readRecordId(offset);
            if (bucketSize == 1) {
                list.add(id);
            } else {
                ListRecord bucket = new ListRecord(segment, id, Math.min(bucketSize, size - offset));
                list.addAll(bucket.getEntries());
            }
            offset += Segment.RECORD_ID_BYTES;
        }
        return list;
    }
}",0.36363636363636365,0.7511961722488036,0.2,1.0,0.16666666666666666,0.41468253968253965,-0.3220577871740661,0.4166666666666667,0.02631578947368421,0.45848216086628274
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-2494_0dc92ca1,1,"public double getAverage() {
    return ((double) sum) / count;
}",,"public double getAverage() {
    return ((double) sum) / count;
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,1.1099365750528538,-0.5,2.4473684210526314,-0.16279340490885932
commons-math,remotes/origin/bugs-dot-jar_MATH-1283_9e0c5ad4,3,"/**
 * Returns the value of Γ(x). Based on the <em>NSWC Library of
 * Mathematics Subroutines</em> double precision implementation,
 * {@code DGAMMA}.
 *
 * @param x Argument.
 * @return the value of {@code Gamma(x)}.
 * @since 3.1
 */
public static double gamma(final double x) {
    if ((x == FastMath.rint(x)) && (x <= 0.0)) {
        return Double.NaN;
    }
    final double ret;
    final double absX = FastMath.abs(x);
    if (absX <= 20.0) {
        if (x >= 1.0) {
            /*
                 * From the recurrence relation
                 * Gamma(x) = (x - 1) * ... * (x - n) * Gamma(x - n),
                 * then
                 * Gamma(t) = 1 / [1 + invGamma1pm1(t - 1)],
                 * where t = x - n. This means that t must satisfy
                 * -0.5 <= t - 1 <= 1.5.
                 */
            double prod = 1.0;
            double t = x;
            while (t > 2.5) {
                t -= 1.0;
                prod *= t;
            }
            ret = prod / (1.0 + invGamma1pm1(t - 1.0));
        } else {
            /*
                 * From the recurrence relation
                 * Gamma(x) = Gamma(x + n + 1) / [x * (x + 1) * ... * (x + n)]
                 * then
                 * Gamma(x + n + 1) = 1 / [1 + invGamma1pm1(x + n)],
                 * which requires -0.5 <= x + n <= 1.5.
                 */
            double prod = x;
            double t = x;
            while (t < -0.5) {
                t += 1.0;
                prod *= t;
            }
            ret = 1.0 / (prod * (1.0 + invGamma1pm1(t)));
        }
    } else {
        final double y = absX + LANCZOS_G + 0.5;
        final double gammaAbs = SQRT_TWO_PI / x * FastMath.pow(y, absX + 0.5) * FastMath.exp(-y) * lanczos(absX);
        if (x > 0.0) {
            ret = gammaAbs;
        } else {
            /*
                 * From the reflection formula
                 * Gamma(x) * Gamma(1 - x) * sin(pi * x) = pi,
                 * and the recurrence relation
                 * Gamma(1 - x) = -x * Gamma(-x),
                 * it is found
                 * Gamma(x) = -pi / [x * sin(pi * x) * Gamma(-x)].
                 */
            ret = -FastMath.PI / (x * FastMath.sin(FastMath.PI * x) * gammaAbs);
        }
    }
    return ret;
}","/**
 * Returns the value of Γ(x). Based on the <em>NSWC Library of
 * Mathematics Subroutines</em> double precision implementation,
 * {@code DGAMMA}.
 *
 * @param x Argument.
 * @return the value of {@code Gamma(x)}.
 * @since 3.1
 */
","public static double gamma(final double x) {
    if ((x == FastMath.rint(x)) && (x <= 0.0)) {
        return Double.NaN;
    }
    final double ret;
    final double absX = FastMath.abs(x);
    if (absX <= 20.0) {
        if (x >= 1.0) {
                        double prod = 1.0;
            double t = x;
            while (t > 2.5) {
                t -= 1.0;
                prod *= t;
            }
            ret = prod / (1.0 + invGamma1pm1(t - 1.0));
        } else {
                        double prod = x;
            double t = x;
            while (t < -0.5) {
                t += 1.0;
                prod *= t;
            }
            ret = 1.0 / (prod * (1.0 + invGamma1pm1(t)));
        }
    } else {
        final double y = absX + LANCZOS_G + 0.5;
        final double gammaAbs = SQRT_TWO_PI / x * FastMath.pow(y, absX + 0.5) * FastMath.exp(-y) * lanczos(absX);
        if (x > 0.0) {
            ret = gammaAbs;
        } else {
                        ret = -FastMath.PI / (x * FastMath.sin(FastMath.PI * x) * gammaAbs);
        }
    }
    return ret;
}",0.9545454545454546,0.6698564593301434,0.6,0.5,0.5,3.9563492063492065,-0.6451021846370684,0.16666666666666666,-0.02631578947368421,6.561133682566576
commons-math,remotes/origin/bugs-dot-jar_MATH-434_133cbc2d,1,"/**
 * {@inheritDoc}
 */
@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other instanceof SimplexTableau) {
        SimplexTableau rhs = (SimplexTableau) other;
        return (restrictToNonNegative == rhs.restrictToNonNegative) && (numDecisionVariables == rhs.numDecisionVariables) && (numSlackVariables == rhs.numSlackVariables) && (numArtificialVariables == rhs.numArtificialVariables) && (epsilon == rhs.epsilon) && f.equals(rhs.f) && constraints.equals(rhs.constraints) && tableau.equals(rhs.tableau);
    }
    return false;
}","/**
 * {@inheritDoc}
 */
","@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other instanceof SimplexTableau) {
        SimplexTableau rhs = (SimplexTableau) other;
        return (restrictToNonNegative == rhs.restrictToNonNegative) && (numDecisionVariables == rhs.numDecisionVariables) && (numSlackVariables == rhs.numSlackVariables) && (numArtificialVariables == rhs.numArtificialVariables) && (epsilon == rhs.epsilon) && f.equals(rhs.f) && constraints.equals(rhs.constraints) && tableau.equals(rhs.tableau);
    }
    return false;
}",-0.13636363636363635,-0.01913875598086126,-0.2,-0.5,-0.16666666666666666,0.11309523809523811,0.07822410147991557,-0.25,0.1842105263157895,0.07267970240256333
wicket,remotes/origin/bugs-dot-jar_WICKET-442_246d53c5,1,"/**
 *  @return True if this component has an error message
 */
public final boolean hasErrorMessage() {
    return getPage().getFeedbackMessages().hasErrorMessageFor(this);
}","/**
 *  @return True if this component has an error message
 */
","public final boolean hasErrorMessage() {
    return getPage().getFeedbackMessages().hasErrorMessageFor(this);
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,1.1099365750528538,-0.25,2.5789473684210527,-0.16279340490885932
wicket,remotes/origin/bugs-dot-jar_WICKET-4824_ad849602,1,"/**
 *  Creates a url for the handler. Modifies it with the correct {@link Scheme} if necessary.
 *
 *  @param handler
 *  @param request
 *  @return url
 */
final Url mapHandler(IRequestHandler handler, Request request) {
    Url url = delegate.mapHandler(handler);
    Scheme desired = getDesiredSchemeFor(handler);
    Scheme current = getSchemeOf(request);
    if (!desired.isCompatibleWith(current)) {
        // the generated url does not have the correct scheme, set it (which in turn will cause
        // the url to be rendered in its full representation)
        url.setProtocol(desired.urlName());
        if (url.getPort() != null || !desired.usesStandardPort(config)) {
            url.setPort(desired.getPort(config));
        }
    }
    return url;
}","/**
 *  Creates a url for the handler. Modifies it with the correct {@link Scheme} if necessary.
 *
 *  @param handler
 *  @param request
 *  @return url
 */
","final Url mapHandler(IRequestHandler handler, Request request) {
    Url url = delegate.mapHandler(handler);
    Scheme desired = getDesiredSchemeFor(handler);
    Scheme current = getSchemeOf(request);
    if (!desired.isCompatibleWith(current)) {
                        url.setProtocol(desired.urlName());
        if (url.getPort() != null || !desired.usesStandardPort(config)) {
            url.setPort(desired.getPort(config));
        }
    }
    return url;
}",-0.09090909090909091,0.1578947368421051,-0.2,0.0,0.25,0.33928571428571425,0.035377026074700356,0.3333333333333333,0.02631578947368421,0.19063524720065925
Math,83,1,"/**
 * Get the current solution.
 *
 * @return current solution
 */
protected RealPointValuePair getSolution() {
    double[] coefficients = new double[getOriginalNumDecisionVariables()];
    Integer negativeVarBasicRow = getBasicRow(getNegativeDecisionVariableOffset());
    double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());
    Set<Integer> basicRows = new HashSet<Integer>();
    for (int i = 0; i < coefficients.length; i++) {
        Integer basicRow = getBasicRow(getNumObjectiveFunctions() + i);
        if (basicRows.contains(basicRow)) {
            // if multiple variables can take a given value
            // then we choose the first and set the rest equal to 0
            coefficients[i] = 0;
        } else {
            basicRows.add(basicRow);
            coefficients[i] = (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) - (restrictToNonNegative ? 0 : mostNegative);
        }
    }
    return new RealPointValuePair(coefficients, f.getValue(coefficients));
}","/**
 * Get the current solution.
 *
 * @return current solution
 */
","protected RealPointValuePair getSolution() {
    double[] coefficients = new double[getOriginalNumDecisionVariables()];
    Integer negativeVarBasicRow = getBasicRow(getNegativeDecisionVariableOffset());
    double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());
    Set<Integer> basicRows = new HashSet<Integer>();
    for (int i = 0; i < coefficients.length; i++) {
        Integer basicRow = getBasicRow(getNumObjectiveFunctions() + i);
        if (basicRows.contains(basicRow)) {
                                    coefficients[i] = 0;
        } else {
            basicRows.add(basicRow);
            coefficients[i] = (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) - (restrictToNonNegative ? 0 : mostNegative);
        }
    }
    return new RealPointValuePair(coefficients, f.getValue(coefficients));
}",0.09090909090909091,0.35885167464114837,0.4,0.0,0.5,0.9404761904761905,-0.18816067653276944,0.5,0.15789473684210528,0.9136333511984001
camel,remotes/origin/bugs-dot-jar_CAMEL-9444_baece126,1,"private AggregationStrategy createAggregationStrategy(RouteContext routeContext) {
    AggregationStrategy strategy = getAggregationStrategy();
    if (strategy == null && strategyRef != null) {
        Object aggStrategy = routeContext.lookup(strategyRef, Object.class);
        if (aggStrategy instanceof AggregationStrategy) {
            strategy = (AggregationStrategy) aggStrategy;
        } else if (aggStrategy != null) {
            AggregationStrategyBeanAdapter adapter = new AggregationStrategyBeanAdapter(aggStrategy, getStrategyMethodName());
            if (getStrategyMethodAllowNull() != null) {
                adapter.setAllowNullNewExchange(getStrategyMethodAllowNull());
                adapter.setAllowNullOldExchange(getStrategyMethodAllowNull());
            }
            strategy = adapter;
        } else {
            throw new IllegalArgumentException(""Cannot find AggregationStrategy in Registry with name: "" + strategyRef);
        }
    }
    if (strategy != null && strategy instanceof CamelContextAware) {
        ((CamelContextAware) strategy).setCamelContext(routeContext.getCamelContext());
    }
    return strategy;
}",,"private AggregationStrategy createAggregationStrategy(RouteContext routeContext) {
    AggregationStrategy strategy = getAggregationStrategy();
    if (strategy == null && strategyRef != null) {
        Object aggStrategy = routeContext.lookup(strategyRef, Object.class);
        if (aggStrategy instanceof AggregationStrategy) {
            strategy = (AggregationStrategy) aggStrategy;
        } else if (aggStrategy != null) {
            AggregationStrategyBeanAdapter adapter = new AggregationStrategyBeanAdapter(aggStrategy, getStrategyMethodName());
            if (getStrategyMethodAllowNull() != null) {
                adapter.setAllowNullNewExchange(getStrategyMethodAllowNull());
                adapter.setAllowNullOldExchange(getStrategyMethodAllowNull());
            }
            strategy = adapter;
        } else {
            throw new IllegalArgumentException(""Cannot find AggregationStrategy in Registry with name: "" + strategyRef);
        }
    }
    if (strategy != null && strategy instanceof CamelContextAware) {
        ((CamelContextAware) strategy).setCamelContext(routeContext.getCamelContext());
    }
    return strategy;
}",0.36363636363636365,0.7272727272727271,0.6,1.0,0.5,0.5496031746031746,-0.32374911909795623,0.3333333333333333,-0.02631578947368421,0.5113627588273599
commons-math,remotes/origin/bugs-dot-jar_MATH-1058_4ebd967c,3,"/**
 * {@inheritDoc}
 *
 * Returns {@code 0} when {@code p == 0} and
 * {@code Double.POSITIVE_INFINITY} when {@code p == 1}.
 */
@Override
public double inverseCumulativeProbability(double p) {
    double ret;
    if (p < 0.0 || p > 1.0) {
        throw new OutOfRangeException(p, 0.0, 1.0);
    } else if (p == 0) {
        ret = 0.0;
    } else if (p == 1) {
        ret = Double.POSITIVE_INFINITY;
    } else {
        ret = scale * FastMath.pow(-FastMath.log(1.0 - p), 1.0 / shape);
    }
    return ret;
}","/**
 * {@inheritDoc}
 *
 * Returns {@code 0} when {@code p == 0} and
 * {@code Double.POSITIVE_INFINITY} when {@code p == 1}.
 */
","@Override
public double inverseCumulativeProbability(double p) {
    double ret;
    if (p < 0.0 || p > 1.0) {
        throw new OutOfRangeException(p, 0.0, 1.0);
    } else if (p == 0) {
        ret = 0.0;
    } else if (p == 1) {
        ret = Double.POSITIVE_INFINITY;
    } else {
        ret = scale * FastMath.pow(-FastMath.log(1.0 - p), 1.0 / shape);
    }
    return ret;
}",0.0,-0.08612440191387569,0.2,0.5,0.0,1.1746031746031746,-0.04298801973220593,-0.3333333333333333,0.2894736842105263,0.5852895581565555
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3156_786b3d76,0,"@Override
public IndexRow next() {
    final IndexRow pathRow = pathCursor.next();
    return new IndexRow() {

        @Override
        public boolean isVirtualRow() {
            return getPath() == null;
        }

        @Override
        public String getPath() {
            return pathRow.getPath();
        }

        @Override
        public PropertyValue getValue(String columnName) {
            // overlay the score
            if (QueryImpl.JCR_SCORE.equals(columnName)) {
                return PropertyValues.newDouble(currentRow.score);
            }
            if (QueryImpl.REP_SPELLCHECK.equals(columnName) || QueryImpl.REP_SUGGEST.equals(columnName)) {
                return PropertyValues.newString(Iterables.toString(currentRow.suggestWords));
            }
            return pathRow.getValue(columnName);
        }
    };
}",,"@Override
public IndexRow next() {
    final IndexRow pathRow = pathCursor.next();
    return new IndexRow() {

        @Override
        public boolean isVirtualRow() {
            return getPath() == null;
        }

        @Override
        public String getPath() {
            return pathRow.getPath();
        }

        @Override
        public PropertyValue getValue(String columnName) {
                        if (QueryImpl.JCR_SCORE.equals(columnName)) {
                return PropertyValues.newDouble(currentRow.score);
            }
            if (QueryImpl.REP_SPELLCHECK.equals(columnName) || QueryImpl.REP_SUGGEST.equals(columnName)) {
                return PropertyValues.newString(Iterables.toString(currentRow.suggestWords));
            }
            return pathRow.getValue(columnName);
        }
    };
}",0.45454545454545453,0.7033492822966506,-0.2,0.0,0.16666666666666666,0.0019841269841269858,-0.30119802677942215,0.3333333333333333,0.07894736842105263,0.04808353935789489
JxPath,16,3,"public static boolean testNode(NodePointer pointer, Object node, NodeTest test) {
    if (test == null) {
        return true;
    }
    if (test instanceof NodeNameTest) {
        if (!(node instanceof Element)) {
            return false;
        }
        NodeNameTest nodeNameTest = (NodeNameTest) test;
        QName testName = nodeNameTest.getNodeName();
        String namespaceURI = nodeNameTest.getNamespaceURI();
        boolean wildcard = nodeNameTest.isWildcard();
        String testPrefix = testName.getPrefix();
        if (wildcard && testPrefix == null) {
            return true;
        }
        if (wildcard || testName.getName().equals(JDOMNodePointer.getLocalName(node))) {
            String nodeNS = JDOMNodePointer.getNamespaceURI(node);
            return equalStrings(namespaceURI, nodeNS) || nodeNS == null && equalStrings(testPrefix, getPrefix(node));
        }
        return false;
    }
    if (test instanceof NodeTypeTest) {
        switch(((NodeTypeTest) test).getNodeType()) {
            case Compiler.NODE_TYPE_NODE:
                return (node instanceof Element) || (node instanceof Document);
            case Compiler.NODE_TYPE_TEXT:
                return (node instanceof Text) || (node instanceof CDATA);
            case Compiler.NODE_TYPE_COMMENT:
                return node instanceof Comment;
            case Compiler.NODE_TYPE_PI:
                return node instanceof ProcessingInstruction;
        }
        return false;
    }
    if (test instanceof ProcessingInstructionTest && node instanceof ProcessingInstruction) {
        String testPI = ((ProcessingInstructionTest) test).getTarget();
        String nodePI = ((ProcessingInstruction) node).getTarget();
        return testPI.equals(nodePI);
    }
    return false;
}",,"public static boolean testNode(NodePointer pointer, Object node, NodeTest test) {
    if (test == null) {
        return true;
    }
    if (test instanceof NodeNameTest) {
        if (!(node instanceof Element)) {
            return false;
        }
        NodeNameTest nodeNameTest = (NodeNameTest) test;
        QName testName = nodeNameTest.getNodeName();
        String namespaceURI = nodeNameTest.getNamespaceURI();
        boolean wildcard = nodeNameTest.isWildcard();
        String testPrefix = testName.getPrefix();
        if (wildcard && testPrefix == null) {
            return true;
        }
        if (wildcard || testName.getName().equals(JDOMNodePointer.getLocalName(node))) {
            String nodeNS = JDOMNodePointer.getNamespaceURI(node);
            return equalStrings(namespaceURI, nodeNS) || nodeNS == null && equalStrings(testPrefix, getPrefix(node));
        }
        return false;
    }
    if (test instanceof NodeTypeTest) {
        switch(((NodeTypeTest) test).getNodeType()) {
            case Compiler.NODE_TYPE_NODE:
                return (node instanceof Element) || (node instanceof Document);
            case Compiler.NODE_TYPE_TEXT:
                return (node instanceof Text) || (node instanceof CDATA);
            case Compiler.NODE_TYPE_COMMENT:
                return node instanceof Comment;
            case Compiler.NODE_TYPE_PI:
                return node instanceof ProcessingInstruction;
        }
        return false;
    }
    if (test instanceof ProcessingInstructionTest && node instanceof ProcessingInstruction) {
        String testPI = ((ProcessingInstructionTest) test).getTarget();
        String nodePI = ((ProcessingInstruction) node).getTarget();
        return testPI.equals(nodePI);
    }
    return false;
}",1.2727272727272727,0.4545454545454545,1.6,0.5,1.3333333333333333,0.5416666666666667,-0.7680056377730796,0.75,-0.02631578947368421,1.3176282106694788
Closure,38,2,"void addNumber(double x) {
    // This is not pretty printing. This is to prevent misparsing of x- -4 as
    // x--4 (which is a syntax error).
    char prev = getLastChar();
    boolean negativeZero = isNegativeZero(x);
    if (x < 0 && prev == '-') {
        add("" "");
    }
    if ((long) x == x && !negativeZero) {
        long value = (long) x;
        long mantissa = value;
        int exp = 0;
        if (Math.abs(x) >= 100) {
            while (mantissa / 10 * Math.pow(10, exp + 1) == value) {
                mantissa /= 10;
                exp++;
            }
        }
        if (exp > 2) {
            add(Long.toString(mantissa) + ""E"" + Integer.toString(exp));
        } else {
            add(Long.toString(value));
        }
    } else {
        add(String.valueOf(x));
    }
}",,"void addNumber(double x) {
            char prev = getLastChar();
    boolean negativeZero = isNegativeZero(x);
    if (x < 0 && prev == '-') {
        add("" "");
    }
    if ((long) x == x && !negativeZero) {
        long value = (long) x;
        long mantissa = value;
        int exp = 0;
        if (Math.abs(x) >= 100) {
            while (mantissa / 10 * Math.pow(10, exp + 1) == value) {
                mantissa /= 10;
                exp++;
            }
        }
        if (exp > 2) {
            add(Long.toString(mantissa) + ""E"" + Integer.toString(exp));
        } else {
            add(Long.toString(value));
        }
    } else {
        add(String.valueOf(x));
    }
}",0.5,0.5454545454545453,0.4,0.5,0.8333333333333334,2.1031746031746033,-0.4100070472163495,0.5,0.42105263157894735,2.1418324948277747
wicket,remotes/origin/bugs-dot-jar_WICKET-5085_581c7306,1,"/**
 *  {@link InlineEnclosure}s keep their own cache of their markup because Component#markup is
 *  detached and later during Ajax request it is hard to re-lookup {@link InlineEnclosure}'s
 *  markup from its parent.
 *
 *  @see org.apache.wicket.Component#getMarkup()
 */
@Override
public IMarkupFragment getMarkup() {
    IMarkupFragment enclosureMarkup = null;
    if (enclosureMarkupAsString == null) {
        IMarkupFragment markup = super.getMarkup();
        if (markup != null && markup != Markup.NO_MARKUP) {
            enclosureMarkup = markup;
            enclosureMarkupAsString = markup.toString(true);
        }
    } else {
        enclosureMarkup = Markup.of(enclosureMarkupAsString, getWicketNamespace());
    }
    return enclosureMarkup;
}","/**
 *  {@link InlineEnclosure}s keep their own cache of their markup because Component#markup is
 *  detached and later during Ajax request it is hard to re-lookup {@link InlineEnclosure}'s
 *  markup from its parent.
 *
 *  @see org.apache.wicket.Component#getMarkup()
 */
","@Override
public IMarkupFragment getMarkup() {
    IMarkupFragment enclosureMarkup = null;
    if (enclosureMarkupAsString == null) {
        IMarkupFragment markup = super.getMarkup();
        if (markup != null && markup != Markup.NO_MARKUP) {
            enclosureMarkup = markup;
            enclosureMarkupAsString = markup.toString(true);
        }
    } else {
        enclosureMarkup = Markup.of(enclosureMarkupAsString, getWicketNamespace());
    }
    return enclosureMarkup;
}",0.0,0.43062200956937796,-0.2,0.0,0.0,0.45634920634920634,0.010570824524312895,-0.16666666666666666,0.6578947368421053,0.13986157454631373
wicket,remotes/origin/bugs-dot-jar_WICKET-128_7e1000dd,1,"/**
 *  Adds or replaces the attribute with the given name and value.
 *
 *  @param name
 *             The name of the attribute
 *  @param value
 *             The value of the attribute
 */
protected final void setAttribute(String name, Object value) {
    RequestCycle cycle = RequestCycle.get();
    if (cycle == null) {
        throw new WicketRuntimeException(""Can not set the attribute. No RequestCycle available"");
    }
    ISessionStore store = getSessionStore();
    Request request = cycle.getRequest();
    // extra check on session binding event
    if (value == this) {
        Object current = store.getAttribute(request, name);
        if (current == null) {
            String id = store.getSessionId(request, false);
            if (id != null) {
                // this is a new instance. wherever it came from, bind the
                // session now
                store.bind(request, (Session) value);
            }
        }
    }
    String valueTypeName = (value != null ? value.getClass().getName() : ""null"");
    try {
        final ByteArrayOutputStream out = new ByteArrayOutputStream();
        new ObjectOutputStream(out).writeObject(value);
        log.debug(""Stored attribute "" + name + ""{ "" + valueTypeName + ""} with size: "" + Bytes.bytes(out.size()));
    } catch (Exception e) {
        throw new WicketRuntimeException(""Internal error cloning object. Make sure all dependent objects implement Serializable. Class: "" + valueTypeName, e);
    }
    // Set the actual attribute
    store.setAttribute(request, name, value);
}","/**
 *  Adds or replaces the attribute with the given name and value.
 *
 *  @param name
 *             The name of the attribute
 *  @param value
 *             The value of the attribute
 */
","protected final void setAttribute(String name, Object value) {
    RequestCycle cycle = RequestCycle.get();
    if (cycle == null) {
        throw new WicketRuntimeException(""Can not set the attribute. No RequestCycle available"");
    }
    ISessionStore store = getSessionStore();
    Request request = cycle.getRequest();
        if (value == this) {
        Object current = store.getAttribute(request, name);
        if (current == null) {
            String id = store.getSessionId(request, false);
            if (id != null) {
                                                store.bind(request, (Session) value);
            }
        }
    }
    String valueTypeName = (value != null ? value.getClass().getName() : ""null"");
    try {
        final ByteArrayOutputStream out = new ByteArrayOutputStream();
        new ObjectOutputStream(out).writeObject(value);
        log.debug(""Stored attribute "" + name + ""{ "" + valueTypeName + ""} with size: "" + Bytes.bytes(out.size()));
    } catch (Exception e) {
        throw new WicketRuntimeException(""Internal error cloning object. Make sure all dependent objects implement Serializable. Class: "" + valueTypeName, e);
    }
        store.setAttribute(request, name, value);
}",0.5454545454545454,0.3444976076555023,1.0,0.5,0.3333333333333333,0.373015873015873,-0.48583509513742057,0.5833333333333334,-0.02631578947368421,0.7329080294831232
Closure,47,2,"/**
 * Creates an ""OriginalMapping"" object for the given entry object.
 */
private OriginalMapping getOriginalMappingForEntry(Entry entry) {
    if (entry.getSourceFileId() == UNMAPPED) {
        return null;
    } else {
        // Adjust the line/column here to be start at 1.
        Builder x = OriginalMapping.newBuilder().setOriginalFile(sources[entry.getSourceFileId()]).setLineNumber(entry.getSourceLine()).setColumnPosition(entry.getSourceColumn());
        if (entry.getNameId() != UNMAPPED) {
            x.setIdentifier(names[entry.getNameId()]);
        }
        return x.build();
    }
}","/**
 * Creates an ""OriginalMapping"" object for the given entry object.
 */
","private OriginalMapping getOriginalMappingForEntry(Entry entry) {
    if (entry.getSourceFileId() == UNMAPPED) {
        return null;
    } else {
                Builder x = OriginalMapping.newBuilder().setOriginalFile(sources[entry.getSourceFileId()]).setLineNumber(entry.getSourceLine()).setColumnPosition(entry.getSourceColumn());
        if (entry.getNameId() != UNMAPPED) {
            x.setIdentifier(names[entry.getNameId()]);
        }
        return x.build();
    }
}",-0.13636363636363635,0.27272727272727265,-0.2,0.0,-0.08333333333333333,-0.053571428571428575,0.11458773784355171,0.5,0.02631578947368421,-0.04321041014735799
Math,6,1,"/**
 * {@inheritDoc}
 */
@Override
protected PointValuePair doOptimize() {
    // -------------------- Initialization --------------------------------
    isMinimize = getGoalType().equals(GoalType.MINIMIZE);
    final FitnessFunction fitfun = new FitnessFunction();
    final double[] guess = getStartPoint();
    // number of objective variables/problem dimension
    dimension = guess.length;
    initializeCMA(guess);
    iterations = 0;
    double bestValue = fitfun.value(guess);
    push(fitnessHistory, bestValue);
    PointValuePair optimum = new PointValuePair(getStartPoint(), isMinimize ? bestValue : -bestValue);
    PointValuePair lastResult = null;
    generationLoop: for (iterations = 1; iterations <= maxIterations; iterations++) {
        // Generate and evaluate lambda offspring
        final RealMatrix arz = randn1(dimension, lambda);
        final RealMatrix arx = zeros(dimension, lambda);
        final double[] fitness = new double[lambda];
        // generate random offspring
        for (int k = 0; k < lambda; k++) {
            RealMatrix arxk = null;
            for (int i = 0; i < checkFeasableCount + 1; i++) {
                if (diagonalOnly <= 0) {
                    arxk = xmean.add(BD.multiply(arz.getColumnMatrix(k)).scalarMultiply(// m + sig * Normal(0,C)
                    sigma));
                } else {
                    arxk = xmean.add(times(diagD, arz.getColumnMatrix(k)).scalarMultiply(sigma));
                }
                if (i >= checkFeasableCount || fitfun.isFeasible(arxk.getColumn(0))) {
                    break;
                }
                // regenerate random arguments for row
                arz.setColumn(k, randn(dimension));
            }
            copyColumn(arxk, 0, arx, k);
            try {
                // compute fitness
                fitness[k] = fitfun.value(arx.getColumn(k));
            } catch (TooManyEvaluationsException e) {
                break generationLoop;
            }
        }
        // Sort by fitness and compute weighted mean into xmean
        final int[] arindex = sortedIndices(fitness);
        // Calculate new xmean, this is selection and recombination
        // for speed up of Eq. (2) and (3)
        final RealMatrix xold = xmean;
        final RealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu));
        xmean = bestArx.multiply(weights);
        final RealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu));
        final RealMatrix zmean = bestArz.multiply(weights);
        final boolean hsig = updateEvolutionPaths(zmean, xold);
        if (diagonalOnly <= 0) {
            updateCovariance(hsig, bestArx, arz, arindex, xold);
        } else {
            updateCovarianceDiagonalOnly(hsig, bestArz);
        }
        // Adapt step size sigma - Eq. (5)
        sigma *= Math.exp(Math.min(1, (normps / chiN - 1) * cs / damps));
        final double bestFitness = fitness[arindex[0]];
        final double worstFitness = fitness[arindex[arindex.length - 1]];
        if (bestValue > bestFitness) {
            bestValue = bestFitness;
            lastResult = optimum;
            optimum = new PointValuePair(fitfun.repair(bestArx.getColumn(0)), isMinimize ? bestFitness : -bestFitness);
            if (getConvergenceChecker() != null && lastResult != null) {
                if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {
                    break generationLoop;
                }
            }
        }
        // Break, if fitness is good enough
        if (stopFitness != 0) {
            // only if stopFitness is defined
            if (bestFitness < (isMinimize ? stopFitness : -stopFitness)) {
                break generationLoop;
            }
        }
        final double[] sqrtDiagC = sqrt(diagC).getColumn(0);
        final double[] pcCol = pc.getColumn(0);
        for (int i = 0; i < dimension; i++) {
            if (sigma * Math.max(Math.abs(pcCol[i]), sqrtDiagC[i]) > stopTolX) {
                break;
            }
            if (i >= dimension - 1) {
                break generationLoop;
            }
        }
        for (int i = 0; i < dimension; i++) {
            if (sigma * sqrtDiagC[i] > stopTolUpX) {
                break generationLoop;
            }
        }
        final double historyBest = min(fitnessHistory);
        final double historyWorst = max(fitnessHistory);
        if (iterations > 2 && Math.max(historyWorst, worstFitness) - Math.min(historyBest, bestFitness) < stopTolFun) {
            break generationLoop;
        }
        if (iterations > fitnessHistory.length && historyWorst - historyBest < stopTolHistFun) {
            break generationLoop;
        }
        // condition number of the covariance matrix exceeds 1e14
        if (max(diagD) / min(diagD) > 1e7) {
            break generationLoop;
        }
        // user defined termination
        if (getConvergenceChecker() != null) {
            final PointValuePair current = new PointValuePair(bestArx.getColumn(0), isMinimize ? bestFitness : -bestFitness);
            if (lastResult != null && getConvergenceChecker().converged(iterations, current, lastResult)) {
                break generationLoop;
            }
            lastResult = current;
        }
        // Adjust step size in case of equal function values (flat fitness)
        if (bestValue == fitness[arindex[(int) (0.1 + lambda / 4.)]]) {
            sigma = sigma * Math.exp(0.2 + cs / damps);
        }
        if (iterations > 2 && Math.max(historyWorst, bestFitness) - Math.min(historyBest, bestFitness) == 0) {
            sigma = sigma * Math.exp(0.2 + cs / damps);
        }
        // store best in history
        push(fitnessHistory, bestFitness);
        fitfun.setValueRange(worstFitness - bestFitness);
        if (generateStatistics) {
            statisticsSigmaHistory.add(sigma);
            statisticsFitnessHistory.add(bestFitness);
            statisticsMeanHistory.add(xmean.transpose());
            statisticsDHistory.add(diagD.transpose().scalarMultiply(1E5));
        }
    }
    return optimum;
}","/**
 * {@inheritDoc}
 */
","@Override
protected PointValuePair doOptimize() {
        isMinimize = getGoalType().equals(GoalType.MINIMIZE);
    final FitnessFunction fitfun = new FitnessFunction();
    final double[] guess = getStartPoint();
        dimension = guess.length;
    initializeCMA(guess);
    iterations = 0;
    double bestValue = fitfun.value(guess);
    push(fitnessHistory, bestValue);
    PointValuePair optimum = new PointValuePair(getStartPoint(), isMinimize ? bestValue : -bestValue);
    PointValuePair lastResult = null;
    generationLoop: for (iterations = 1; iterations <= maxIterations; iterations++) {
                final RealMatrix arz = randn1(dimension, lambda);
        final RealMatrix arx = zeros(dimension, lambda);
        final double[] fitness = new double[lambda];
                for (int k = 0; k < lambda; k++) {
            RealMatrix arxk = null;
            for (int i = 0; i < checkFeasableCount + 1; i++) {
                if (diagonalOnly <= 0) {
                    arxk = xmean.add(BD.multiply(arz.getColumnMatrix(k)).scalarMultiply(                    sigma));
                } else {
                    arxk = xmean.add(times(diagD, arz.getColumnMatrix(k)).scalarMultiply(sigma));
                }
                if (i >= checkFeasableCount || fitfun.isFeasible(arxk.getColumn(0))) {
                    break;
                }
                                arz.setColumn(k, randn(dimension));
            }
            copyColumn(arxk, 0, arx, k);
            try {
                                fitness[k] = fitfun.value(arx.getColumn(k));
            } catch (TooManyEvaluationsException e) {
                break generationLoop;
            }
        }
                final int[] arindex = sortedIndices(fitness);
                        final RealMatrix xold = xmean;
        final RealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu));
        xmean = bestArx.multiply(weights);
        final RealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu));
        final RealMatrix zmean = bestArz.multiply(weights);
        final boolean hsig = updateEvolutionPaths(zmean, xold);
        if (diagonalOnly <= 0) {
            updateCovariance(hsig, bestArx, arz, arindex, xold);
        } else {
            updateCovarianceDiagonalOnly(hsig, bestArz);
        }
                sigma *= Math.exp(Math.min(1, (normps / chiN - 1) * cs / damps));
        final double bestFitness = fitness[arindex[0]];
        final double worstFitness = fitness[arindex[arindex.length - 1]];
        if (bestValue > bestFitness) {
            bestValue = bestFitness;
            lastResult = optimum;
            optimum = new PointValuePair(fitfun.repair(bestArx.getColumn(0)), isMinimize ? bestFitness : -bestFitness);
            if (getConvergenceChecker() != null && lastResult != null) {
                if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {
                    break generationLoop;
                }
            }
        }
                if (stopFitness != 0) {
                        if (bestFitness < (isMinimize ? stopFitness : -stopFitness)) {
                break generationLoop;
            }
        }
        final double[] sqrtDiagC = sqrt(diagC).getColumn(0);
        final double[] pcCol = pc.getColumn(0);
        for (int i = 0; i < dimension; i++) {
            if (sigma * Math.max(Math.abs(pcCol[i]), sqrtDiagC[i]) > stopTolX) {
                break;
            }
            if (i >= dimension - 1) {
                break generationLoop;
            }
        }
        for (int i = 0; i < dimension; i++) {
            if (sigma * sqrtDiagC[i] > stopTolUpX) {
                break generationLoop;
            }
        }
        final double historyBest = min(fitnessHistory);
        final double historyWorst = max(fitnessHistory);
        if (iterations > 2 && Math.max(historyWorst, worstFitness) - Math.min(historyBest, bestFitness) < stopTolFun) {
            break generationLoop;
        }
        if (iterations > fitnessHistory.length && historyWorst - historyBest < stopTolHistFun) {
            break generationLoop;
        }
                if (max(diagD) / min(diagD) > 1e7) {
            break generationLoop;
        }
                if (getConvergenceChecker() != null) {
            final PointValuePair current = new PointValuePair(bestArx.getColumn(0), isMinimize ? bestFitness : -bestFitness);
            if (lastResult != null && getConvergenceChecker().converged(iterations, current, lastResult)) {
                break generationLoop;
            }
            lastResult = current;
        }
                if (bestValue == fitness[arindex[(int) (0.1 + lambda / 4.)]]) {
            sigma = sigma * Math.exp(0.2 + cs / damps);
        }
        if (iterations > 2 && Math.max(historyWorst, bestFitness) - Math.min(historyBest, bestFitness) == 0) {
            sigma = sigma * Math.exp(0.2 + cs / damps);
        }
                push(fitnessHistory, bestFitness);
        fitfun.setValueRange(worstFitness - bestFitness);
        if (generateStatistics) {
            statisticsSigmaHistory.add(sigma);
            statisticsFitnessHistory.add(bestFitness);
            statisticsMeanHistory.add(xmean.transpose());
            statisticsDHistory.add(diagD.transpose().scalarMultiply(1E5));
        }
    }
    return optimum;
}",4.681818181818182,0.6124401913875596,7.4,1.0,5.583333333333333,4.2023809523809526,-1.649189570119802,5.25,-0.02631578947368421,34.56361404540032
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3021_494da6de,1,"@Override
public Validator childNodeChanged(String name, NodeState before, NodeState after) throws CommitFailedException {
    return new UserValidator(parentBefore.getChild(name), parentAfter.getChild(name), provider);
}",,"@Override
public Validator childNodeChanged(String name, NodeState before, NodeState after) throws CommitFailedException {
    return new UserValidator(parentBefore.getChild(name), parentAfter.getChild(name), provider);
}",-0.45454545454545453,-0.6028708133971293,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.7065539112050737,-0.3333333333333333,-0.02631578947368421,-0.16279340490885932
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-4036_f4324736,1,"private void initializeExtractedTextCache(BundleContext bundleContext, Map<String, ?> config) {
    int cacheSizeInMB = PropertiesUtil.toInteger(config.get(PROP_EXTRACTED_TEXT_CACHE_SIZE), PROP_EXTRACTED_TEXT_CACHE_SIZE_DEFAULT);
    int cacheExpiryInSecs = PropertiesUtil.toInteger(config.get(PROP_EXTRACTED_TEXT_CACHE_EXPIRY), PROP_EXTRACTED_TEXT_CACHE_EXPIRY_DEFAULT);
    extractedTextCache = new ExtractedTextCache(cacheSizeInMB * ONE_MB, cacheExpiryInSecs);
    CacheStats stats = extractedTextCache.getCacheStats();
    if (stats != null) {
        oakRegs.add(registerMBean(whiteboard, CacheStatsMBean.class, stats, CacheStatsMBean.TYPE, stats.getName()));
        log.info(""Extracted text caching enabled with maxSize {} MB, expiry time {} secs"", cacheSizeInMB, cacheExpiryInSecs);
    }
}",,"private void initializeExtractedTextCache(BundleContext bundleContext, Map<String, ?> config) {
    int cacheSizeInMB = PropertiesUtil.toInteger(config.get(PROP_EXTRACTED_TEXT_CACHE_SIZE), PROP_EXTRACTED_TEXT_CACHE_SIZE_DEFAULT);
    int cacheExpiryInSecs = PropertiesUtil.toInteger(config.get(PROP_EXTRACTED_TEXT_CACHE_EXPIRY), PROP_EXTRACTED_TEXT_CACHE_EXPIRY_DEFAULT);
    extractedTextCache = new ExtractedTextCache(cacheSizeInMB * ONE_MB, cacheExpiryInSecs);
    CacheStats stats = extractedTextCache.getCacheStats();
    if (stats != null) {
        oakRegs.add(registerMBean(whiteboard, CacheStatsMBean.class, stats, CacheStatsMBean.TYPE, stats.getName()));
        log.info(""Extracted text caching enabled with maxSize {} MB, expiry time {} secs"", cacheSizeInMB, cacheExpiryInSecs);
    }
}",-0.18181818181818182,-0.2200956937799045,-0.4,-0.5,-0.25,-0.08333333333333336,0.09034531360112749,0.25,-0.02631578947368421,0.017125107334474383
Closure,72,2,"/**
 * Rename or remove labels.
 * @param node  The label node.
 * @param parent The parent of the label node.
 */
private void visitLabel(Node node, Node parent) {
    Node nameNode = node.getFirstChild();
    Preconditions.checkState(nameNode != null);
    String name = nameNode.getString();
    LabelInfo li = getLabelInfo(name);
    // This is a label...
    if (li.referenced) {
        String newName = getNameForId(li.id);
        if (!name.equals(newName)) {
            // ... and it is used, give it the short name.
            nameNode.setString(newName);
            compiler.reportCodeChange();
        }
    } else {
        // ... and it is not referenced, just remove it.
        Node newChild = node.getLastChild();
        node.removeChild(newChild);
        parent.replaceChild(node, newChild);
        if (newChild.getType() == Token.BLOCK) {
            NodeUtil.tryMergeBlock(newChild);
        }
        compiler.reportCodeChange();
    }
    // Remove the label from the current stack of labels.
    namespaceStack.peek().renameMap.remove(name);
}","/**
 * Rename or remove labels.
 * @param node  The label node.
 * @param parent The parent of the label node.
 */
","private void visitLabel(Node node, Node parent) {
    Node nameNode = node.getFirstChild();
    Preconditions.checkState(nameNode != null);
    String name = nameNode.getString();
    LabelInfo li = getLabelInfo(name);
        if (li.referenced) {
        String newName = getNameForId(li.id);
        if (!name.equals(newName)) {
                        nameNode.setString(newName);
            compiler.reportCodeChange();
        }
    } else {
                Node newChild = node.getLastChild();
        node.removeChild(newChild);
        parent.replaceChild(node, newChild);
        if (newChild.getType() == Token.BLOCK) {
            NodeUtil.tryMergeBlock(newChild);
        }
        compiler.reportCodeChange();
    }
        namespaceStack.peek().renameMap.remove(name);
}",0.36363636363636365,0.16746411483253573,0.0,0.0,0.16666666666666666,0.2996031746031746,-0.3288231148696262,0.8333333333333334,-0.02631578947368421,0.4166571578407472
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1732_941e3cb1,3,"/**
 * Initialize a scanner over the given input split using this task attempt configuration.
 */
@Override
public void initialize(InputSplit inSplit, TaskAttemptContext attempt) throws IOException {
    Scanner scanner;
    split = (RangeInputSplit) inSplit;
    log.debug(""Initializing input split: "" + split.getRange());
    Instance instance = getInstance(attempt);
    String principal = getPrincipal(attempt);
    AuthenticationToken token = getAuthenticationToken(attempt);
    Authorizations authorizations = getScanAuthorizations(attempt);
    // in case the table name changed, we can still use the previous name for terms of configuration,
    // but the scanner will use the table id resolved at job setup time
    BatchScanConfig tableConfig = getBatchScanConfig(attempt, split.getTableName());
    try {
        log.debug(""Creating connector with user: "" + principal);
        log.debug(""Creating scanner for table: "" + split.getTableName());
        log.debug(""Authorizations are: "" + authorizations);
        if (tableConfig.isOfflineScan()) {
            scanner = new OfflineScanner(instance, new Credentials(principal, token), split.getTableId(), authorizations);
        } else {
            scanner = new ScannerImpl(instance, new Credentials(principal, token), split.getTableId(), authorizations);
        }
        if (tableConfig.shouldUseIsolatedScanners()) {
            log.info(""Creating isolated scanner"");
            scanner = new IsolatedScanner(scanner);
        }
        if (tableConfig.shouldUseLocalIterators()) {
            log.info(""Using local iterators"");
            scanner = new ClientSideIteratorScanner(scanner);
        }
        setupIterators(attempt, scanner, split.getTableId());
    } catch (Exception e) {
        throw new IOException(e);
    }
    // setup a scanner within the bounds of this split
    for (Pair<Text, Text> c : tableConfig.getFetchedColumns()) {
        if (c.getSecond() != null) {
            log.debug(""Fetching column "" + c.getFirst() + "":"" + c.getSecond());
            scanner.fetchColumn(c.getFirst(), c.getSecond());
        } else {
            log.debug(""Fetching column family "" + c.getFirst());
            scanner.fetchColumnFamily(c.getFirst());
        }
    }
    scanner.setRange(split.getRange());
    numKeysRead = 0;
    // do this last after setting all scanner options
    scannerIterator = scanner.iterator();
}","/**
 * Initialize a scanner over the given input split using this task attempt configuration.
 */
","@Override
public void initialize(InputSplit inSplit, TaskAttemptContext attempt) throws IOException {
    Scanner scanner;
    split = (RangeInputSplit) inSplit;
    log.debug(""Initializing input split: "" + split.getRange());
    Instance instance = getInstance(attempt);
    String principal = getPrincipal(attempt);
    AuthenticationToken token = getAuthenticationToken(attempt);
    Authorizations authorizations = getScanAuthorizations(attempt);
            BatchScanConfig tableConfig = getBatchScanConfig(attempt, split.getTableName());
    try {
        log.debug(""Creating connector with user: "" + principal);
        log.debug(""Creating scanner for table: "" + split.getTableName());
        log.debug(""Authorizations are: "" + authorizations);
        if (tableConfig.isOfflineScan()) {
            scanner = new OfflineScanner(instance, new Credentials(principal, token), split.getTableId(), authorizations);
        } else {
            scanner = new ScannerImpl(instance, new Credentials(principal, token), split.getTableId(), authorizations);
        }
        if (tableConfig.shouldUseIsolatedScanners()) {
            log.info(""Creating isolated scanner"");
            scanner = new IsolatedScanner(scanner);
        }
        if (tableConfig.shouldUseLocalIterators()) {
            log.info(""Using local iterators"");
            scanner = new ClientSideIteratorScanner(scanner);
        }
        setupIterators(attempt, scanner, split.getTableId());
    } catch (Exception e) {
        throw new IOException(e);
    }
        for (Pair<Text, Text> c : tableConfig.getFetchedColumns()) {
        if (c.getSecond() != null) {
            log.debug(""Fetching column "" + c.getFirst() + "":"" + c.getSecond());
            scanner.fetchColumn(c.getFirst(), c.getSecond());
        } else {
            log.debug(""Fetching column family "" + c.getFirst());
            scanner.fetchColumnFamily(c.getFirst());
        }
    }
    scanner.setRange(split.getRange());
    numKeysRead = 0;
        scannerIterator = scanner.iterator();
}",1.3636363636363635,0.26794258373205726,0.8,0.0,0.25,0.045634920634920584,-0.8102889358703311,2.5,-0.02631578947368421,0.7634791929600109
commons-math,remotes/origin/bugs-dot-jar_MATH-1096_faf99727,0,"/**
 * Find a ball enclosing a list of points.
 * @param points points to enclose
 * @return enclosing ball
 */
EnclosingBall<S, P> enclose(List<P> points);","/**
 * Find a ball enclosing a list of points.
 * @param points points to enclose
 * @return enclosing ball
 */
","EnclosingBall<S, P> enclose(List<P> points);",-0.5909090909090909,-1.4306220095693782,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,1.515010570824524,-0.5,2.6052631578947367,-0.16279340490885932
camel,remotes/origin/bugs-dot-jar_CAMEL-8626_d063f471,0,"@Override
public void init(ManagementStrategy strategy) {
    super.init(strategy);
    exchangesInFlightStartTimestamps.clear();
}",,"@Override
public void init(ManagementStrategy strategy) {
    super.init(strategy);
    exchangesInFlightStartTimestamps.clear();
}",-0.4090909090909091,-0.49282296650717716,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.7626497533474278,-0.3333333333333333,1.2368421052631577,-0.16279340490885932
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-464_484c865f,1,"private Node constructNode(final String name, final Node parent, final JsonNode jsonNode) {
    final PluginType<?> type = pluginManager.getPluginType(name);
    final Node node = new Node(parent, name, type);
    processAttributes(node, jsonNode);
    final Iterator<Map.Entry<String, JsonNode>> iter = jsonNode.fields();
    final List<Node> children = node.getChildren();
    while (iter.hasNext()) {
        final Map.Entry<String, JsonNode> entry = iter.next();
        final JsonNode n = entry.getValue();
        if (n.isArray() || n.isObject()) {
            if (type == null) {
                status.add(new Status(name, n, ErrorType.CLASS_NOT_FOUND));
            }
            if (n.isArray()) {
                LOGGER.debug(""Processing node for array "" + entry.getKey());
                for (int i = 0; i < n.size(); ++i) {
                    final String pluginType = getType(n.get(i), entry.getKey());
                    final PluginType<?> entryType = pluginManager.getPluginType(pluginType);
                    final Node item = new Node(node, entry.getKey(), entryType);
                    processAttributes(item, n.get(i));
                    if (pluginType.equals(entry.getKey())) {
                        LOGGER.debug(""Processing "" + entry.getKey() + ""["" + i + ""]"");
                    } else {
                        LOGGER.debug(""Processing "" + pluginType + "" "" + entry.getKey() + ""["" + i + ""]"");
                    }
                    final Iterator<Map.Entry<String, JsonNode>> itemIter = n.get(i).fields();
                    final List<Node> itemChildren = item.getChildren();
                    while (itemIter.hasNext()) {
                        final Map.Entry<String, JsonNode> itemEntry = itemIter.next();
                        if (itemEntry.getValue().isObject()) {
                            LOGGER.debug(""Processing node for object "" + itemEntry.getKey());
                            itemChildren.add(constructNode(itemEntry.getKey(), item, itemEntry.getValue()));
                        }
                    }
                    children.add(item);
                }
            } else {
                LOGGER.debug(""Processing node for object "" + entry.getKey());
                children.add(constructNode(entry.getKey(), node, n));
            }
        }
    }
    String t;
    if (type == null) {
        t = ""null"";
    } else {
        t = type.getElementName() + "":"" + type.getPluginClass();
    }
    final String p = node.getParent() == null ? ""null"" : node.getParent().getName() == null ? ""root"" : node.getParent().getName();
    LOGGER.debug(""Returning "" + node.getName() + "" with parent "" + p + "" of type "" + t);
    return node;
}",,"private Node constructNode(final String name, final Node parent, final JsonNode jsonNode) {
    final PluginType<?> type = pluginManager.getPluginType(name);
    final Node node = new Node(parent, name, type);
    processAttributes(node, jsonNode);
    final Iterator<Map.Entry<String, JsonNode>> iter = jsonNode.fields();
    final List<Node> children = node.getChildren();
    while (iter.hasNext()) {
        final Map.Entry<String, JsonNode> entry = iter.next();
        final JsonNode n = entry.getValue();
        if (n.isArray() || n.isObject()) {
            if (type == null) {
                status.add(new Status(name, n, ErrorType.CLASS_NOT_FOUND));
            }
            if (n.isArray()) {
                LOGGER.debug(""Processing node for array "" + entry.getKey());
                for (int i = 0; i < n.size(); ++i) {
                    final String pluginType = getType(n.get(i), entry.getKey());
                    final PluginType<?> entryType = pluginManager.getPluginType(pluginType);
                    final Node item = new Node(node, entry.getKey(), entryType);
                    processAttributes(item, n.get(i));
                    if (pluginType.equals(entry.getKey())) {
                        LOGGER.debug(""Processing "" + entry.getKey() + ""["" + i + ""]"");
                    } else {
                        LOGGER.debug(""Processing "" + pluginType + "" "" + entry.getKey() + ""["" + i + ""]"");
                    }
                    final Iterator<Map.Entry<String, JsonNode>> itemIter = n.get(i).fields();
                    final List<Node> itemChildren = item.getChildren();
                    while (itemIter.hasNext()) {
                        final Map.Entry<String, JsonNode> itemEntry = itemIter.next();
                        if (itemEntry.getValue().isObject()) {
                            LOGGER.debug(""Processing node for object "" + itemEntry.getKey());
                            itemChildren.add(constructNode(itemEntry.getKey(), item, itemEntry.getValue()));
                        }
                    }
                    children.add(item);
                }
            } else {
                LOGGER.debug(""Processing node for object "" + entry.getKey());
                children.add(constructNode(entry.getKey(), node, n));
            }
        }
    }
    String t;
    if (type == null) {
        t = ""null"";
    } else {
        t = type.getElementName() + "":"" + type.getPluginClass();
    }
    final String p = node.getParent() == null ? ""null"" : node.getParent().getName() == null ? ""root"" : node.getParent().getName();
    LOGGER.debug(""Returning "" + node.getName() + "" with parent "" + p + "" of type "" + t);
    return node;
}",1.7272727272727273,2.397129186602871,1.6,2.0,1.5833333333333333,1.5277777777777777,-0.9768851303735022,4.083333333333333,-0.02631578947368421,6.450891236320256
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3021_494da6de,1,"@Override
public Validator childNodeAdded(String name, NodeState after) throws CommitFailedException {
    Tree tree = checkNotNull(parentAfter.getChild(name));
    validateAuthorizable(tree, UserUtil.getType(tree));
    return new VisibleValidator(new UserValidator(null, tree, provider), true, true);
}",,"@Override
public Validator childNodeAdded(String name, NodeState after) throws CommitFailedException {
    Tree tree = checkNotNull(parentAfter.getChild(name));
    validateAuthorizable(tree, UserUtil.getType(tree));
    return new VisibleValidator(new UserValidator(null, tree, provider), true, true);
}",-0.36363636363636365,-0.47368421052631593,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.4432699083861872,-0.16666666666666666,-0.02631578947368421,-0.16279340490885932
wicket,remotes/origin/bugs-dot-jar_WICKET-3989_6a8fc1cc,1,"/**
 *  Search for the child's markup in the associated markup file.
 *
 *  @param parent
 *             The container expected to contain the markup for child
 *  @param child
 *             The child component to find the markup for
 *  @return The markup associated with the child
 */
@Override
public IMarkupFragment getMarkup(final MarkupContainer parent, final Component child) {
    Args.notNull(tagName, ""tagName"");
    IMarkupFragment associatedMarkup = parent.getAssociatedMarkup();
    if (associatedMarkup == null) {
        throw new MarkupNotFoundException(""Failed to find markup file associated. "" + parent.getClass().getSimpleName() + "": "" + parent.toString());
    }
    // Find <wicket:panel>
    IMarkupFragment markup = findStartTag(associatedMarkup);
    if (markup == null) {
        throw new MarkupNotFoundException(""Expected to find <wicket:"" + tagName + ""> in associated markup file. Markup: "" + associatedMarkup.toString());
    }
    // If child == null, than return the markup fragment starting with <wicket:panel>
    if (child == null) {
        return markup;
    }
    // Find the markup for the child component
    associatedMarkup = markup.find(child.getId());
    if (associatedMarkup != null) {
        return associatedMarkup;
    }
    return findMarkupInAssociatedFileHeader(parent, child);
}","/**
 *  Search for the child's markup in the associated markup file.
 *
 *  @param parent
 *             The container expected to contain the markup for child
 *  @param child
 *             The child component to find the markup for
 *  @return The markup associated with the child
 */
","@Override
public IMarkupFragment getMarkup(final MarkupContainer parent, final Component child) {
    Args.notNull(tagName, ""tagName"");
    IMarkupFragment associatedMarkup = parent.getAssociatedMarkup();
    if (associatedMarkup == null) {
        throw new MarkupNotFoundException(""Failed to find markup file associated. "" + parent.getClass().getSimpleName() + "": "" + parent.toString());
    }
        IMarkupFragment markup = findStartTag(associatedMarkup);
    if (markup == null) {
        throw new MarkupNotFoundException(""Expected to find <wicket:"" + tagName + ""> in associated markup file. Markup: "" + associatedMarkup.toString());
    }
        if (child == null) {
        return markup;
    }
        associatedMarkup = markup.find(child.getId());
    if (associatedMarkup != null) {
        return associatedMarkup;
    }
    return findMarkupInAssociatedFileHeader(parent, child);
}",0.2727272727272727,-0.3014354066985648,0.6,-0.5,0.16666666666666666,0.3988095238095238,-0.2730091613812544,0.3333333333333333,-0.02631578947368421,0.37387320412855923
commons-math,remotes/origin/bugs-dot-jar_MATH-949_f83bbc1d,1,"/**
 * {@inheritDoc}
 */
@Override
protected PointValuePair doOptimize() {
    checkParameters();
    final GoalType goal = getGoalType();
    final double[] guess = getStartPoint();
    final int n = guess.length;
    final double[][] direc = new double[n][n];
    for (int i = 0; i < n; i++) {
        direc[i][i] = 1;
    }
    final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();
    double[] x = guess;
    double fVal = computeObjectiveValue(x);
    double[] x1 = x.clone();
    int iter = 0;
    while (true) {
        ++iter;
        double fX = fVal;
        double fX2 = 0;
        double delta = 0;
        int bigInd = 0;
        double alphaMin = 0;
        for (int i = 0; i < n; i++) {
            final double[] d = MathArrays.copyOf(direc[i]);
            fX2 = fVal;
            final UnivariatePointValuePair optimum = line.search(x, d);
            fVal = optimum.getValue();
            alphaMin = optimum.getPoint();
            final double[][] result = newPointAndDirection(x, d, alphaMin);
            x = result[0];
            if ((fX2 - fVal) > delta) {
                delta = fX2 - fVal;
                bigInd = i;
            }
        }
        // Default convergence check.
        boolean stop = 2 * (fX - fVal) <= (relativeThreshold * (FastMath.abs(fX) + FastMath.abs(fVal)) + absoluteThreshold);
        final PointValuePair previous = new PointValuePair(x1, fX);
        final PointValuePair current = new PointValuePair(x, fVal);
        if (!stop) {
            // User-defined stopping criteria.
            if (checker != null) {
                stop = checker.converged(iter, previous, current);
            }
        }
        if (stop) {
            if (goal == GoalType.MINIMIZE) {
                return (fVal < fX) ? current : previous;
            } else {
                return (fVal > fX) ? current : previous;
            }
        }
        final double[] d = new double[n];
        final double[] x2 = new double[n];
        for (int i = 0; i < n; i++) {
            d[i] = x[i] - x1[i];
            x2[i] = 2 * x[i] - x1[i];
        }
        x1 = x.clone();
        fX2 = computeObjectiveValue(x2);
        if (fX > fX2) {
            double t = 2 * (fX + fX2 - 2 * fVal);
            double temp = fX - fVal - delta;
            t *= temp * temp;
            temp = fX - fX2;
            t -= delta * temp * temp;
            if (t < 0.0) {
                final UnivariatePointValuePair optimum = line.search(x, d);
                fVal = optimum.getValue();
                alphaMin = optimum.getPoint();
                final double[][] result = newPointAndDirection(x, d, alphaMin);
                x = result[0];
                final int lastInd = n - 1;
                direc[bigInd] = direc[lastInd];
                direc[lastInd] = result[1];
            }
        }
    }
}","/**
 * {@inheritDoc}
 */
","@Override
protected PointValuePair doOptimize() {
    checkParameters();
    final GoalType goal = getGoalType();
    final double[] guess = getStartPoint();
    final int n = guess.length;
    final double[][] direc = new double[n][n];
    for (int i = 0; i < n; i++) {
        direc[i][i] = 1;
    }
    final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();
    double[] x = guess;
    double fVal = computeObjectiveValue(x);
    double[] x1 = x.clone();
    int iter = 0;
    while (true) {
        ++iter;
        double fX = fVal;
        double fX2 = 0;
        double delta = 0;
        int bigInd = 0;
        double alphaMin = 0;
        for (int i = 0; i < n; i++) {
            final double[] d = MathArrays.copyOf(direc[i]);
            fX2 = fVal;
            final UnivariatePointValuePair optimum = line.search(x, d);
            fVal = optimum.getValue();
            alphaMin = optimum.getPoint();
            final double[][] result = newPointAndDirection(x, d, alphaMin);
            x = result[0];
            if ((fX2 - fVal) > delta) {
                delta = fX2 - fVal;
                bigInd = i;
            }
        }
                boolean stop = 2 * (fX - fVal) <= (relativeThreshold * (FastMath.abs(fX) + FastMath.abs(fVal)) + absoluteThreshold);
        final PointValuePair previous = new PointValuePair(x1, fX);
        final PointValuePair current = new PointValuePair(x, fVal);
        if (!stop) {
                        if (checker != null) {
                stop = checker.converged(iter, previous, current);
            }
        }
        if (stop) {
            if (goal == GoalType.MINIMIZE) {
                return (fVal < fX) ? current : previous;
            } else {
                return (fVal > fX) ? current : previous;
            }
        }
        final double[] d = new double[n];
        final double[] x2 = new double[n];
        for (int i = 0; i < n; i++) {
            d[i] = x[i] - x1[i];
            x2[i] = 2 * x[i] - x1[i];
        }
        x1 = x.clone();
        fX2 = computeObjectiveValue(x2);
        if (fX > fX2) {
            double t = 2 * (fX + fX2 - 2 * fVal);
            double temp = fX - fVal - delta;
            t *= temp * temp;
            temp = fX - fX2;
            t -= delta * temp * temp;
            if (t < 0.0) {
                final UnivariatePointValuePair optimum = line.search(x, d);
                fVal = optimum.getValue();
                alphaMin = optimum.getPoint();
                final double[][] result = newPointAndDirection(x, d, alphaMin);
                x = result[0];
                final int lastInd = n - 1;
                direc[bigInd] = direc[lastInd];
                direc[lastInd] = result[1];
            }
        }
    }
}",2.8636363636363638,0.6411483253588517,2.0,0.5,1.5,4.089285714285714,-1.2001409443269904,1.1666666666666667,-0.02631578947368421,19.058391106654444
camel,remotes/origin/bugs-dot-jar_CAMEL-6964_6b2ffb30,1,"/**
 * Strategy when the file was processed and a commit should be executed.
 *
 * @param processStrategy the strategy to perform the commit
 * @param exchange        the exchange
 * @param file            the file processed
 */
protected void processStrategyCommit(GenericFileProcessStrategy<T> processStrategy, Exchange exchange, GenericFile<T> file) {
    if (endpoint.isIdempotent()) {
        // use absolute file path as default key, but evaluate if an expression key was configured
        String key = absoluteFileName;
        if (endpoint.getIdempotentKey() != null) {
            Exchange dummy = endpoint.createExchange(file);
            key = endpoint.getIdempotentKey().evaluate(dummy, String.class);
        }
        // only add to idempotent repository if we could process the file
        if (key != null) {
            endpoint.getIdempotentRepository().add(key);
        }
    }
    // must be last in batch to delete the done file name
    // delete done file if used (and not noop=true)
    boolean complete = exchange.getProperty(Exchange.BATCH_COMPLETE, false, Boolean.class);
    if (endpoint.getDoneFileName() != null && !endpoint.isNoop()) {
        // done file must be in same path as the original input file
        String doneFileName = endpoint.createDoneFileName(absoluteFileName);
        ObjectHelper.notEmpty(doneFileName, ""doneFileName"", endpoint);
        // we should delete the dynamic done file
        if (endpoint.getDoneFileName().indexOf(""{file:name"") > 0 || complete) {
            try {
                // delete done file
                boolean deleted = operations.deleteFile(doneFileName);
                log.trace(""Done file: {} was deleted: {}"", doneFileName, deleted);
                if (!deleted) {
                    log.warn(""Done file: "" + doneFileName + "" could not be deleted"");
                }
            } catch (Exception e) {
                handleException(""Error deleting done file: "" + doneFileName, exchange, e);
            }
        }
    }
    try {
        log.trace(""Commit file strategy: {} for file: {}"", processStrategy, file);
        processStrategy.commit(operations, endpoint, exchange, file);
    } catch (Exception e) {
        handleException(""Error during commit"", exchange, e);
    }
}","/**
 * Strategy when the file was processed and a commit should be executed.
 *
 * @param processStrategy the strategy to perform the commit
 * @param exchange        the exchange
 * @param file            the file processed
 */
","protected void processStrategyCommit(GenericFileProcessStrategy<T> processStrategy, Exchange exchange, GenericFile<T> file) {
    if (endpoint.isIdempotent()) {
                String key = absoluteFileName;
        if (endpoint.getIdempotentKey() != null) {
            Exchange dummy = endpoint.createExchange(file);
            key = endpoint.getIdempotentKey().evaluate(dummy, String.class);
        }
                if (key != null) {
            endpoint.getIdempotentRepository().add(key);
        }
    }
            boolean complete = exchange.getProperty(Exchange.BATCH_COMPLETE, false, Boolean.class);
    if (endpoint.getDoneFileName() != null && !endpoint.isNoop()) {
                String doneFileName = endpoint.createDoneFileName(absoluteFileName);
        ObjectHelper.notEmpty(doneFileName, ""doneFileName"", endpoint);
                if (endpoint.getDoneFileName().indexOf(""{file:name"") > 0 || complete) {
            try {
                                boolean deleted = operations.deleteFile(doneFileName);
                log.trace(""Done file: {} was deleted: {}"", doneFileName, deleted);
                if (!deleted) {
                    log.warn(""Done file: "" + doneFileName + "" could not be deleted"");
                }
            } catch (Exception e) {
                handleException(""Error deleting done file: "" + doneFileName, exchange, e);
            }
        }
    }
    try {
        log.trace(""Commit file strategy: {} for file: {}"", processStrategy, file);
        processStrategy.commit(operations, endpoint, exchange, file);
    } catch (Exception e) {
        handleException(""Error during commit"", exchange, e);
    }
}",0.9090909090909091,0.8803827751196173,1.0,1.0,0.9166666666666666,0.8253968253968255,-0.6496124031007751,1.25,-0.02631578947368421,1.7493219918973273
wicket,remotes/origin/bugs-dot-jar_WICKET-2172_ea4a3f8a,3,"/**
 *  Generates a <code>String</code> representation of this object.
 *
 *  @return <code>String</code> representation of this <code>ValueMap</code> consistent with the
 *          tag-attribute style of markup elements. For example: <code>a=""x"" b=""y"" c=""z""</code>.
 */
@Override
public String toString() {
    final StringBuffer buffer = new StringBuffer();
    for (final Iterator iterator = entrySet().iterator(); iterator.hasNext(); ) {
        final Map.Entry entry = (Map.Entry) iterator.next();
        buffer.append(entry.getKey());
        buffer.append("" = \"""");
        final Object value = entry.getValue();
        if (value == null) {
            buffer.append(""null"");
        } else if (value.getClass().isArray()) {
            buffer.append(Arrays.asList((Object[]) value));
        } else {
            buffer.append(value);
        }
        buffer.append('\""');
        if (iterator.hasNext()) {
            buffer.append(' ');
        }
    }
    return buffer.toString();
}","/**
 *  Generates a <code>String</code> representation of this object.
 *
 *  @return <code>String</code> representation of this <code>ValueMap</code> consistent with the
 *          tag-attribute style of markup elements. For example: <code>a=""x"" b=""y"" c=""z""</code>.
 */
","@Override
public String toString() {
    final StringBuffer buffer = new StringBuffer();
    for (final Iterator iterator = entrySet().iterator(); iterator.hasNext(); ) {
        final Map.Entry entry = (Map.Entry) iterator.next();
        buffer.append(entry.getKey());
        buffer.append("" = \"""");
        final Object value = entry.getValue();
        if (value == null) {
            buffer.append(""null"");
        } else if (value.getClass().isArray()) {
            buffer.append(Arrays.asList((Object[]) value));
        } else {
            buffer.append(value);
        }
        buffer.append('\""');
        if (iterator.hasNext()) {
            buffer.append(' ');
        }
    }
    return buffer.toString();
}",0.36363636363636365,0.3157894736842104,0.2,0.5,0.16666666666666666,0.06150793650793648,-0.305426356589147,1.0,-0.02631578947368421,0.14031338785060193
wicket,remotes/origin/bugs-dot-jar_WICKET-1677_01a3dd66,1,"/**
 *  @see org.apache.wicket.Component#onComponentTagBody(org.apache.wicket.markup.MarkupStream,
 *       org.apache.wicket.markup.ComponentTag)
 */
@Override
protected final void onComponentTagBody(final MarkupStream markupStream, final ComponentTag openTag) {
    // Iterate through choices
    final List<? extends T> choices = getChoices();
    // Buffer to hold generated body
    final AppendingStringBuffer buffer = new AppendingStringBuffer(70 * (choices.size() + 1));
    // Value of this choice
    final String selected = getValue();
    // Loop through choices
    for (int index = 0; index < choices.size(); index++) {
        // Get next choice
        final T choice = choices.get(index);
        Object displayValue = getChoiceRenderer().getDisplayValue(choice);
        Class<?> objectClass = displayValue == null ? null : displayValue.getClass();
        // Get label for choice
        String label = """";
        if (objectClass != null && objectClass != String.class) {
            IConverter converter = getConverter(objectClass);
            label = converter.convertToString(displayValue, getLocale());
        } else if (displayValue != null) {
            label = displayValue.toString();
        }
        // location in the page markup!
        if (label != null) {
            // Append option suffix
            buffer.append(getPrefix());
            String id = getChoiceRenderer().getIdValue(choice, index);
            final String idAttr = getInputName() + ""_"" + id;
            // Add checkbox element
            buffer.append(""<input name=\"""").append(getInputName()).append(""\"""").append("" type=\""checkbox\"""").append((isSelected(choice, index, selected) ? "" checked=\""checked\"""" : """")).append((isEnabled() ? """" : "" disabled=\""disabled\"""")).append("" value=\"""").append(id).append(""\"" id=\"""").append(idAttr).append(""\""/>"");
            // Add label for checkbox
            String display = label;
            if (localizeDisplayValues()) {
                display = getLocalizer().getString(label, this, label);
            }
            CharSequence escaped;
            if (getEscapeModelStrings()) {
                escaped = Strings.escapeMarkup(display, false, true);
            } else {
                escaped = display;
            }
            buffer.append(""<label for=\"""");
            buffer.append(idAttr);
            buffer.append(""\"">"").append(escaped).append(""</label>"");
            // Append option suffix
            buffer.append(getSuffix());
        }
    }
    // Replace body
    replaceComponentTagBody(markupStream, openTag, buffer);
}","/**
 *  @see org.apache.wicket.Component#onComponentTagBody(org.apache.wicket.markup.MarkupStream,
 *       org.apache.wicket.markup.ComponentTag)
 */
","@Override
protected final void onComponentTagBody(final MarkupStream markupStream, final ComponentTag openTag) {
        final List<? extends T> choices = getChoices();
        final AppendingStringBuffer buffer = new AppendingStringBuffer(70 * (choices.size() + 1));
        final String selected = getValue();
        for (int index = 0; index < choices.size(); index++) {
                final T choice = choices.get(index);
        Object displayValue = getChoiceRenderer().getDisplayValue(choice);
        Class<?> objectClass = displayValue == null ? null : displayValue.getClass();
                String label = """";
        if (objectClass != null && objectClass != String.class) {
            IConverter converter = getConverter(objectClass);
            label = converter.convertToString(displayValue, getLocale());
        } else if (displayValue != null) {
            label = displayValue.toString();
        }
                if (label != null) {
                        buffer.append(getPrefix());
            String id = getChoiceRenderer().getIdValue(choice, index);
            final String idAttr = getInputName() + ""_"" + id;
                        buffer.append(""<input name=\"""").append(getInputName()).append(""\"""").append("" type=\""checkbox\"""").append((isSelected(choice, index, selected) ? "" checked=\""checked\"""" : """")).append((isEnabled() ? """" : "" disabled=\""disabled\"""")).append("" value=\"""").append(id).append(""\"" id=\"""").append(idAttr).append(""\""/>"");
                        String display = label;
            if (localizeDisplayValues()) {
                display = getLocalizer().getString(label, this, label);
            }
            CharSequence escaped;
            if (getEscapeModelStrings()) {
                escaped = Strings.escapeMarkup(display, false, true);
            } else {
                escaped = display;
            }
            buffer.append(""<label for=\"""");
            buffer.append(idAttr);
            buffer.append(""\"">"").append(escaped).append(""</label>"");
                        buffer.append(getSuffix());
        }
    }
        replaceComponentTagBody(markupStream, openTag, buffer);
}",1.1363636363636365,0.6076555023923443,1.2,0.5,1.3333333333333333,1.2996031746031746,-0.7908386187455951,3.1666666666666665,-0.02631578947368421,4.213839087613745
wicket,remotes/origin/bugs-dot-jar_WICKET-2624_ef880545,1,"/**
 *  @see org.apache.wicket.util.convert.IConverter#convertToObject(java.lang.String,
 *       java.util.Locale)
 */
public Object convertToObject(String value, Locale locale) {
    if (value == null) {
        return null;
    }
    Class<?> theType = type.get();
    if ("""".equals(value)) {
        if (theType.equals(String.class)) {
            return theType.cast("""");
        }
        return null;
    }
    try {
        Object converted = Objects.convertValue(value, theType);
        if (theType.isAssignableFrom(converted.getClass())) {
            return theType.cast(converted);
        } else {
            throw new ConversionException(""Could not convert value: "" + value + "" to type: "" + theType.getName() + ""(Could not find compatible converter)."").setSourceValue(value);
        }
    } catch (Exception e) {
        throw new ConversionException(e.getMessage(), e).setSourceValue(value);
    }
}","/**
 *  @see org.apache.wicket.util.convert.IConverter#convertToObject(java.lang.String,
 *       java.util.Locale)
 */
","public Object convertToObject(String value, Locale locale) {
    if (value == null) {
        return null;
    }
    Class<?> theType = type.get();
    if ("""".equals(value)) {
        if (theType.equals(String.class)) {
            return theType.cast("""");
        }
        return null;
    }
    try {
        Object converted = Objects.convertValue(value, theType);
        if (theType.isAssignableFrom(converted.getClass())) {
            return theType.cast(converted);
        } else {
            throw new ConversionException(""Could not convert value: "" + value + "" to type: "" + theType.getName() + ""(Could not find compatible converter)."").setSourceValue(value);
        }
    } catch (Exception e) {
        throw new ConversionException(e.getMessage(), e).setSourceValue(value);
    }
}",0.36363636363636365,0.16746411483253573,0.8,0.0,0.3333333333333333,0.0039682539682539715,-0.31698379140239613,0.5,-0.02631578947368421,0.08616494643361397
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-2659_019edb16,0,"@Override
protected void setupIterators(JobConf job, Scanner scanner, String tableName, org.apache.accumulo.core.client.mapred.RangeInputSplit split) {
    List<IteratorSetting> iterators = null;
    if (null == split) {
        iterators = getIterators(job);
    } else {
        iterators = split.getIterators();
    }
    setupIterators(iterators, scanner);
}",,"@Override
protected void setupIterators(JobConf job, Scanner scanner, String tableName, org.apache.accumulo.core.client.mapred.RangeInputSplit split) {
    List<IteratorSetting> iterators = null;
    if (null == split) {
        iterators = getIterators(job);
    } else {
        iterators = split.getIterators();
    }
    setupIterators(iterators, scanner);
}",-0.18181818181818182,-0.0909090909090911,-0.4,-0.5,-0.25,-0.07738095238095241,0.16476391825229028,-0.25,0.0,-0.05210375569809189
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-4358_74cbba24,1,"@Override
public Iterator<Revision> iterator() {
    final Iterator<NodeDocument> previousDocs = getPreviousDocLeaves();
    return new AbstractIterator<Revision>() {

        private NodeDocument nextDoc;

        private Revision nextRevision;

        @Override
        protected Revision computeNext() {
            if (stack.isEmpty()) {
                return endOfData();
            }
            Revision next = stack.first();
            stack.remove(next);
            fillStackIfNeeded();
            return next;
        }

        private void fillStackIfNeeded() {
            for (; ; ) {
                fetchNextDoc();
                // no more changes to compare with
                if (nextDoc == null) {
                    return;
                }
                // most recent revision of next document
                if (!stack.isEmpty()) {
                    Revision top = stack.first();
                    if (top.compareRevisionTimeThenClusterId(nextRevision) > 0) {
                        return;
                    }
                }
                // if we get here, we need to pull in changes
                // from nextDoc
                Iterables.addAll(stack, nextDoc.getAllChanges());
                nextDoc = null;
                nextRevision = null;
            }
        }

        /**
         * Fetch the next document if {@code nextDoc} is
         * {@code null} and there are more documents.
         */
        private void fetchNextDoc() {
            for (; ; ) {
                if (nextDoc != null) {
                    break;
                }
                if (!previousDocs.hasNext()) {
                    // no more previous docs
                    break;
                }
                nextDoc = previousDocs.next();
                Iterator<Revision> changes = nextDoc.getAllChanges().iterator();
                if (changes.hasNext()) {
                    nextRevision = changes.next();
                    break;
                } else {
                    // empty document, try next
                    nextDoc = null;
                }
            }
        }
    };
}","/**
 * Fetch the next document if {@code nextDoc} is
 * {@code null} and there are more documents.
 */
","@Override
public Iterator<Revision> iterator() {
    final Iterator<NodeDocument> previousDocs = getPreviousDocLeaves();
    return new AbstractIterator<Revision>() {

        private NodeDocument nextDoc;

        private Revision nextRevision;

        @Override
        protected Revision computeNext() {
            if (stack.isEmpty()) {
                return endOfData();
            }
            Revision next = stack.first();
            stack.remove(next);
            fillStackIfNeeded();
            return next;
        }

        private void fillStackIfNeeded() {
            for (; ; ) {
                fetchNextDoc();
                                if (nextDoc == null) {
                    return;
                }
                                if (!stack.isEmpty()) {
                    Revision top = stack.first();
                    if (top.compareRevisionTimeThenClusterId(nextRevision) > 0) {
                        return;
                    }
                }
                                                Iterables.addAll(stack, nextDoc.getAllChanges());
                nextDoc = null;
                nextRevision = null;
            }
        }

        /**
         * Fetch the next document if {@code nextDoc} is
         * {@code null} and there are more documents.
         */
        private void fetchNextDoc() {
            for (; ; ) {
                if (nextDoc != null) {
                    break;
                }
                if (!previousDocs.hasNext()) {
                                        break;
                }
                nextDoc = previousDocs.next();
                Iterator<Revision> changes = nextDoc.getAllChanges().iterator();
                if (changes.hasNext()) {
                    nextRevision = changes.next();
                    break;
                } else {
                                        nextDoc = null;
                }
            }
        }
    };
}",1.9545454545454546,1.2440191387559807,1.8,1.0,0.6666666666666666,0.6468253968253967,-0.8477801268498941,1.0,-0.02631578947368421,0.8905770416601833
maven,remotes/origin/bugs-dot-jar_MNG-1509_4e955c05,1,"public boolean isActive(Profile profile) {
    Activation activation = profile.getActivation();
    ActivationOS os = activation.getOs();
    boolean hasNonNull = ensureAtLeastOneNonNull(os);
    boolean isFamily = determineFamilyMatch(os.getFamily());
    boolean isName = determineNameMatch(os.getName());
    boolean isArch = determineArchMatch(os.getArch());
    boolean isVersion = determineVersionMatch(os.getVersion());
    return hasNonNull && isFamily && isName && isArch && isVersion;
}",,"public boolean isActive(Profile profile) {
    Activation activation = profile.getActivation();
    ActivationOS os = activation.getOs();
    boolean hasNonNull = ensureAtLeastOneNonNull(os);
    boolean isFamily = determineFamilyMatch(os.getFamily());
    boolean isName = determineNameMatch(os.getName());
    boolean isArch = determineArchMatch(os.getArch());
    boolean isVersion = determineVersionMatch(os.getVersion());
    return hasNonNull && isFamily && isName && isArch && isVersion;
}",-0.18181818181818182,-0.6650717703349284,-0.6,-1.0,-0.4166666666666667,-0.06746031746031747,0.13798449612403085,0.4166666666666667,0.6052631578947368,-0.019766832062608413
flink,remotes/origin/bugs-dot-jar_FLINK-2812_e494c279,3,"public static <X> KeySelector<X, Tuple> getSelectorForKeys(Keys<X> keys, TypeInformation<X> typeInfo, ExecutionConfig executionConfig) {
    if (!(typeInfo instanceof CompositeType)) {
        throw new InvalidTypesException(""This key operation requires a composite type such as Tuples, POJOs, or Case Classes."");
    }
    CompositeType<X> compositeType = (CompositeType<X>) typeInfo;
    int[] logicalKeyPositions = keys.computeLogicalKeyPositions();
    int numKeyFields = logicalKeyPositions.length;
    // use ascending order here, the code paths for that are usually a slight bit faster
    boolean[] orders = new boolean[numKeyFields];
    for (int i = 0; i < numKeyFields; i++) {
        orders[i] = true;
    }
    TypeComparator<X> comparator = compositeType.createComparator(logicalKeyPositions, orders, 0, executionConfig);
    return new ComparableKeySelector<X>(comparator, numKeyFields);
}",,"public static <X> KeySelector<X, Tuple> getSelectorForKeys(Keys<X> keys, TypeInformation<X> typeInfo, ExecutionConfig executionConfig) {
    if (!(typeInfo instanceof CompositeType)) {
        throw new InvalidTypesException(""This key operation requires a composite type such as Tuples, POJOs, or Case Classes."");
    }
    CompositeType<X> compositeType = (CompositeType<X>) typeInfo;
    int[] logicalKeyPositions = keys.computeLogicalKeyPositions();
    int numKeyFields = logicalKeyPositions.length;
        boolean[] orders = new boolean[numKeyFields];
    for (int i = 0; i < numKeyFields; i++) {
        orders[i] = true;
    }
    TypeComparator<X> comparator = compositeType.createComparator(logicalKeyPositions, orders, 0, executionConfig);
    return new ComparableKeySelector<X>(comparator, numKeyFields);
}",0.0,-0.4066985645933015,0.0,-0.5,0.0,0.41468253968253965,-0.09541930937279787,-0.3333333333333333,-0.02631578947368421,0.40212997700592995
Closure,30,2,"/**
 * Computes all the local variables that rValue reads from and store that
 * in the def's depends set.
 */
private void computeDependence(final Definition def, Node rValue) {
    NodeTraversal.traverse(compiler, rValue, new AbstractCfgNodeTraversalCallback() {

        @Override
        public void visit(NodeTraversal t, Node n, Node parent) {
            if (n.isName() && jsScope.isDeclared(n.getString(), true)) {
                Var dep = jsScope.getVar(n.getString());
                def.depends.add(dep);
            }
        }
    });
}","/**
 * Computes all the local variables that rValue reads from and store that
 * in the def's depends set.
 */
","private void computeDependence(final Definition def, Node rValue) {
    NodeTraversal.traverse(compiler, rValue, new AbstractCfgNodeTraversalCallback() {

        @Override
        public void visit(NodeTraversal t, Node n, Node parent) {
            if (n.isName() && jsScope.isDeclared(n.getString(), true)) {
                Var dep = jsScope.getVar(n.getString());
                def.depends.add(dep);
            }
        }
    });
}",-0.13636363636363635,1.1483253588516744,-0.4,0.0,0.0,-0.07936507936507939,0.1078224101479916,0.08333333333333333,0.5263157894736842,-0.04283697262034428
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-478_11763dee,1,"/**
 * This method takes a string which may contain JSON reserved chars and
 * escapes them.
 *
 * @param input The text to be converted.
 * @return The input string with the special characters replaced.
 */
public static String escapeJsonControlCharacters(final String input) {
    if (Strings.isEmpty(input) || (input.indexOf('""') == -1 && input.indexOf('\\') == -1 && input.indexOf('/') == -1 && input.indexOf('\b') == -1 && input.indexOf('\f') == -1 && input.indexOf('\n') == -1 && input.indexOf('\r') == -1 && input.indexOf('\t') == -1)) {
        return input;
    }
    final StringBuilder buf = new StringBuilder(input.length() + 6);
    final int len = input.length();
    for (int i = 0; i < len; i++) {
        final char ch = input.charAt(i);
        final String escBs = ""\\\\"";
        switch(ch) {
            case '""':
                buf.append(escBs);
                buf.append(ch);
                break;
            case '\\':
                buf.append(escBs);
                buf.append(ch);
                break;
            case '/':
                buf.append(escBs);
                buf.append(ch);
                break;
            case '\b':
                buf.append(escBs);
                buf.append('b');
                break;
            case '\f':
                buf.append(escBs);
                buf.append('f');
                break;
            case '\n':
                buf.append(escBs);
                buf.append('n');
                break;
            case '\r':
                buf.append(escBs);
                buf.append('r');
                break;
            case '\t':
                buf.append(escBs);
                buf.append('t');
                break;
            default:
                buf.append(ch);
        }
    }
    return buf.toString();
}","/**
 * This method takes a string which may contain JSON reserved chars and
 * escapes them.
 *
 * @param input The text to be converted.
 * @return The input string with the special characters replaced.
 */
","public static String escapeJsonControlCharacters(final String input) {
    if (Strings.isEmpty(input) || (input.indexOf('""') == -1 && input.indexOf('\\') == -1 && input.indexOf('/') == -1 && input.indexOf('\b') == -1 && input.indexOf('\f') == -1 && input.indexOf('\n') == -1 && input.indexOf('\r') == -1 && input.indexOf('\t') == -1)) {
        return input;
    }
    final StringBuilder buf = new StringBuilder(input.length() + 6);
    final int len = input.length();
    for (int i = 0; i < len; i++) {
        final char ch = input.charAt(i);
        final String escBs = ""\\\\"";
        switch(ch) {
            case '""':
                buf.append(escBs);
                buf.append(ch);
                break;
            case '\\':
                buf.append(escBs);
                buf.append(ch);
                break;
            case '/':
                buf.append(escBs);
                buf.append(ch);
                break;
            case '\b':
                buf.append(escBs);
                buf.append('b');
                break;
            case '\f':
                buf.append(escBs);
                buf.append('f');
                break;
            case '\n':
                buf.append(escBs);
                buf.append('n');
                break;
            case '\r':
                buf.append(escBs);
                buf.append('r');
                break;
            case '\t':
                buf.append(escBs);
                buf.append('t');
                break;
            default:
                buf.append(ch);
        }
    }
    return buf.toString();
}",1.5454545454545454,0.9760765550239235,3.2,0.5,2.1666666666666665,2.5297619047619047,-0.9069767441860462,2.0,-0.02631578947368421,5.494854284446442
wicket,remotes/origin/bugs-dot-jar_WICKET-1619_b154d12f,1,"/**
 *  Create a new pagenumber link. May be subclassed to make use of specialized links, e.g.
 *  Ajaxian links.
 *
 *  @param id
 *             the link id
 *  @param pageable
 *             the pageable to control
 *  @param pageNumber
 *             the page to jump to
 *  @return the pagenumber link
 */
protected Link<?> newPagingNavigationLink(String id, IPageable pageable, int pageNumber) {
    return new PagingNavigationLink<Void>(id, pageable, pageNumber) {

        private static final long serialVersionUID = 1L;

        @Override
        public boolean isEnabled() {
            return PagingNavigator.this.isEnabled() && PagingNavigator.this.isEnableAllowed();
        }
    };
}","/**
 *  Create a new pagenumber link. May be subclassed to make use of specialized links, e.g.
 *  Ajaxian links.
 *
 *  @param id
 *             the link id
 *  @param pageable
 *             the pageable to control
 *  @param pageNumber
 *             the page to jump to
 *  @return the pagenumber link
 */
","protected Link<?> newPagingNavigationLink(String id, IPageable pageable, int pageNumber) {
    return new PagingNavigationLink<Void>(id, pageable, pageNumber) {

        private static final long serialVersionUID = 1L;

        @Override
        public boolean isEnabled() {
            return PagingNavigator.this.isEnabled() && PagingNavigator.this.isEnableAllowed();
        }
    };
}",-0.22727272727272727,0.39712918660287067,-0.6,-0.5,-0.4166666666666667,-0.10515873015873016,0.29894291754756874,-0.3333333333333333,2.3421052631578947,-0.104758447007025
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1250_0c3b3306,1,"@Override
@CheckForNull
public synchronized NodeState retrieve(@Nonnull String checkpoint) {
    // TODO: Verify validity of the checkpoint
    RecordId id = RecordId.fromString(checkNotNull(checkpoint));
    SegmentNodeState root = new SegmentNodeState(store.getWriter().getDummySegment(), id);
    return root.getChildNode(ROOT);
}",,"@Override
@CheckForNull
public synchronized NodeState retrieve(@Nonnull String checkpoint) {
        RecordId id = RecordId.fromString(checkNotNull(checkpoint));
    SegmentNodeState root = new SegmentNodeState(store.getWriter().getDummySegment(), id);
    return root.getChildNode(ROOT);
}",-0.3181818181818182,-0.48325358851674655,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.390274841437632,-0.08333333333333333,1.263157894736842,-0.16279340490885932
Closure,79,1,"/**
 * Create a new variable in a synthetic script. This will prevent
 * subsequent compiler passes from crashing.
 */
private void createSynthesizedExternVar(String varName) {
    Node nameNode = Node.newString(Token.NAME, varName);
    // cases for this configuration though, and it makes them happier.
    if (compiler.getCodingConvention().isConstant(varName)) {
        nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);
    }
    getSynthesizedExternsRoot().addChildToBack(new Node(Token.VAR, nameNode));
    varsToDeclareInExterns.remove(varName);
}","/**
 * Create a new variable in a synthetic script. This will prevent
 * subsequent compiler passes from crashing.
 */
","private void createSynthesizedExternVar(String varName) {
    Node nameNode = Node.newString(Token.NAME, varName);
        if (compiler.getCodingConvention().isConstant(varName)) {
        nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);
    }
    getSynthesizedExternsRoot().addChildToBack(new Node(Token.VAR, nameNode));
    varsToDeclareInExterns.remove(varName);
}",-0.2727272727272727,-0.2822966507177035,-0.4,-0.5,-0.16666666666666666,-0.3650793650793651,0.299506694855532,0.08333333333333333,0.21052631578947367,-0.16279340490885932
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1348_ef0f6ddc,1,"public int start() throws IOException {
    if (configError)
        return 1;
    String input;
    if (isVerbose())
        printInfo();
    String home = System.getProperty(""HOME"");
    if (home == null)
        home = System.getenv(""HOME"");
    String configDir = home + ""/.accumulo"";
    String historyPath = configDir + ""/shell_history.txt"";
    File accumuloDir = new File(configDir);
    if (!accumuloDir.exists() && !accumuloDir.mkdirs())
        log.warn(""Unable to make directory for history at "" + accumuloDir);
    try {
        History history = new History();
        history.setHistoryFile(new File(historyPath));
        reader.setHistory(history);
    } catch (IOException e) {
        log.warn(""Unable to load history file at "" + historyPath);
    }
    ShellCompletor userCompletor = null;
    if (execFile != null) {
        java.util.Scanner scanner = new java.util.Scanner(new File(execFile));
        while (scanner.hasNextLine()) execCommand(scanner.nextLine(), true, isVerbose());
    } else if (execCommand != null) {
        for (String command : execCommand.split(""\n"")) {
            execCommand(command, true, isVerbose());
        }
        return exitCode;
    }
    while (true) {
        if (hasExited())
            return exitCode;
        // If tab completion is true we need to reset
        if (tabCompletion) {
            if (userCompletor != null)
                reader.removeCompletor(userCompletor);
            userCompletor = setupCompletion();
            reader.addCompletor(userCompletor);
        }
        reader.setDefaultPrompt(getDefaultPrompt());
        input = reader.readLine();
        if (input == null) {
            reader.printNewline();
            return exitCode;
        }
        // user canceled
        execCommand(input, disableAuthTimeout, false);
    }
}",,"public int start() throws IOException {
    if (configError)
        return 1;
    String input;
    if (isVerbose())
        printInfo();
    String home = System.getProperty(""HOME"");
    if (home == null)
        home = System.getenv(""HOME"");
    String configDir = home + ""/.accumulo"";
    String historyPath = configDir + ""/shell_history.txt"";
    File accumuloDir = new File(configDir);
    if (!accumuloDir.exists() && !accumuloDir.mkdirs())
        log.warn(""Unable to make directory for history at "" + accumuloDir);
    try {
        History history = new History();
        history.setHistoryFile(new File(historyPath));
        reader.setHistory(history);
    } catch (IOException e) {
        log.warn(""Unable to load history file at "" + historyPath);
    }
    ShellCompletor userCompletor = null;
    if (execFile != null) {
        java.util.Scanner scanner = new java.util.Scanner(new File(execFile));
        while (scanner.hasNextLine()) execCommand(scanner.nextLine(), true, isVerbose());
    } else if (execCommand != null) {
        for (String command : execCommand.split(""\n"")) {
            execCommand(command, true, isVerbose());
        }
        return exitCode;
    }
    while (true) {
        if (hasExited())
            return exitCode;
                if (tabCompletion) {
            if (userCompletor != null)
                reader.removeCompletor(userCompletor);
            userCompletor = setupCompletion();
            reader.addCompletor(userCompletor);
        }
        reader.setDefaultPrompt(getDefaultPrompt());
        input = reader.readLine();
        if (input == null) {
            reader.printNewline();
            return exitCode;
        }
                execCommand(input, disableAuthTimeout, false);
    }
}",1.5909090909090908,0.1531100478468899,2.2,0.5,1.6666666666666667,0.8253968253968255,-0.8844256518675121,1.6666666666666667,-0.02631578947368421,2.169480702846308
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2559_dfa87520,1,"private Map<String, PropertyDefinition> collectPropConfigs(NodeState config, List<NamePattern> patterns, List<Aggregate.Include> propAggregate, List<PropertyDefinition> nonExistentProperties) {
    Map<String, PropertyDefinition> propDefns = newHashMap();
    NodeState propNode = config.getChildNode(LuceneIndexConstants.PROP_NODE);
    if (!propNode.exists()) {
        return Collections.emptyMap();
    }
    if (!hasOrderableChildren(propNode)) {
        log.warn(""Properties node for [{}] does not have orderable "" + ""children in [{}]"", this, IndexDefinition.this);
    }
    // Include all immediate child nodes to 'properties' node by default
    Tree propTree = TreeFactory.createReadOnlyTree(propNode);
    for (Tree prop : propTree.getChildren()) {
        String propName = prop.getName();
        NodeState propDefnNode = propNode.getChildNode(propName);
        if (propDefnNode.exists() && !propDefns.containsKey(propName)) {
            PropertyDefinition pd = new PropertyDefinition(this, propName, propDefnNode);
            if (pd.isRegexp) {
                patterns.add(new NamePattern(pd.name, pd));
            } else {
                propDefns.put(pd.name, pd);
            }
            if (pd.relative) {
                propAggregate.add(new Aggregate.PropertyInclude(pd));
            }
            if (pd.nullCheckEnabled) {
                nonExistentProperties.add(pd);
            }
        }
    }
    return ImmutableMap.copyOf(propDefns);
}",,"private Map<String, PropertyDefinition> collectPropConfigs(NodeState config, List<NamePattern> patterns, List<Aggregate.Include> propAggregate, List<PropertyDefinition> nonExistentProperties) {
    Map<String, PropertyDefinition> propDefns = newHashMap();
    NodeState propNode = config.getChildNode(LuceneIndexConstants.PROP_NODE);
    if (!propNode.exists()) {
        return Collections.emptyMap();
    }
    if (!hasOrderableChildren(propNode)) {
        log.warn(""Properties node for [{}] does not have orderable "" + ""children in [{}]"", this, IndexDefinition.this);
    }
        Tree propTree = TreeFactory.createReadOnlyTree(propNode);
    for (Tree prop : propTree.getChildren()) {
        String propName = prop.getName();
        NodeState propDefnNode = propNode.getChildNode(propName);
        if (propDefnNode.exists() && !propDefns.containsKey(propName)) {
            PropertyDefinition pd = new PropertyDefinition(this, propName, propDefnNode);
            if (pd.isRegexp) {
                patterns.add(new NamePattern(pd.name, pd));
            } else {
                propDefns.put(pd.name, pd);
            }
            if (pd.relative) {
                propAggregate.add(new Aggregate.PropertyInclude(pd));
            }
            if (pd.nullCheckEnabled) {
                nonExistentProperties.add(pd);
            }
        }
    }
    return ImmutableMap.copyOf(propDefns);
}",0.7272727272727273,0.8325358851674642,0.8,0.5,0.9166666666666666,0.40476190476190477,-0.5670190274841435,0.9166666666666666,-0.02631578947368421,0.9226142932060878
commons-math,remotes/origin/bugs-dot-jar_MATH-939_49444ee6,1,"/**
 * Compute a covariance matrix from a matrix whose columns represent
 * covariates.
 * @param matrix input matrix (must have at least two columns and two rows)
 * @param biasCorrected determines whether or not covariance estimates are bias-corrected
 * @return covariance matrix
 * @throws MathIllegalArgumentException if the matrix does not contain sufficient data
 */
protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected) throws MathIllegalArgumentException {
    int dimension = matrix.getColumnDimension();
    Variance variance = new Variance(biasCorrected);
    RealMatrix outMatrix = new BlockRealMatrix(dimension, dimension);
    for (int i = 0; i < dimension; i++) {
        for (int j = 0; j < i; j++) {
            double cov = covariance(matrix.getColumn(i), matrix.getColumn(j), biasCorrected);
            outMatrix.setEntry(i, j, cov);
            outMatrix.setEntry(j, i, cov);
        }
        outMatrix.setEntry(i, i, variance.evaluate(matrix.getColumn(i)));
    }
    return outMatrix;
}","/**
 * Compute a covariance matrix from a matrix whose columns represent
 * covariates.
 * @param matrix input matrix (must have at least two columns and two rows)
 * @param biasCorrected determines whether or not covariance estimates are bias-corrected
 * @return covariance matrix
 * @throws MathIllegalArgumentException if the matrix does not contain sufficient data
 */
","protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected) throws MathIllegalArgumentException {
    int dimension = matrix.getColumnDimension();
    Variance variance = new Variance(biasCorrected);
    RealMatrix outMatrix = new BlockRealMatrix(dimension, dimension);
    for (int i = 0; i < dimension; i++) {
        for (int j = 0; j < i; j++) {
            double cov = covariance(matrix.getColumn(i), matrix.getColumn(j), biasCorrected);
            outMatrix.setEntry(i, j, cov);
            outMatrix.setEntry(j, i, cov);
        }
        outMatrix.setEntry(i, i, variance.evaluate(matrix.getColumn(i)));
    }
    return outMatrix;
}",0.0,0.44976076555023925,-0.2,0.0,0.0,0.2103174603174603,-0.08668076109936582,0.25,-0.02631578947368421,0.2484719604893875
wicket,remotes/origin/bugs-dot-jar_WICKET-5662_9aec4f33,1,"@Override
public Object getFieldValue(final Field field, final Object fieldOwner) {
    if (supportsField(field)) {
        String beanName = getBeanName(field);
        if (beanName == null) {
            return null;
        }
        SpringBeanLocator locator = new SpringBeanLocator(beanName, field.getType(), contextLocator);
        // only check the cache if the bean is a singleton
        Object cachedValue = cache.get(locator);
        if (cachedValue != null) {
            return cachedValue;
        }
        Object target;
        if (wrapInProxies) {
            target = LazyInitProxyFactory.createProxy(field.getType(), locator);
        } else {
            target = locator.locateProxyTarget();
        }
        // only put the proxy into the cache if the bean is a singleton
        if (locator.isSingletonBean()) {
            Object tmpTarget = cache.putIfAbsent(locator, target);
            if (tmpTarget != null) {
                target = tmpTarget;
            }
        }
        return target;
    }
    return null;
}",,"@Override
public Object getFieldValue(final Field field, final Object fieldOwner) {
    if (supportsField(field)) {
        String beanName = getBeanName(field);
        if (beanName == null) {
            return null;
        }
        SpringBeanLocator locator = new SpringBeanLocator(beanName, field.getType(), contextLocator);
                Object cachedValue = cache.get(locator);
        if (cachedValue != null) {
            return cachedValue;
        }
        Object target;
        if (wrapInProxies) {
            target = LazyInitProxyFactory.createProxy(field.getType(), locator);
        } else {
            target = locator.locateProxyTarget();
        }
                if (locator.isSingletonBean()) {
            Object tmpTarget = cache.putIfAbsent(locator, target);
            if (tmpTarget != null) {
                target = tmpTarget;
            }
        }
        return target;
    }
    return null;
}",0.6363636363636364,0.41148325358851673,0.6,0.5,0.6666666666666666,0.06150793650793648,-0.44101479915433384,0.25,-0.02631578947368421,0.16766192377955655
commons-math,remotes/origin/bugs-dot-jar_MATH-935_48dde378,3,"/**
 * Compute two arguments arc tangent of a derivative structure.
 * @param y array holding the first operand
 * @param yOffset offset of the first operand in its array
 * @param x array holding the second operand
 * @param xOffset offset of the second operand in its array
 * @param result array where result must be stored (for
 * two arguments arc tangent the result array <em>cannot</em>
 * be the input array)
 * @param resultOffset offset of the result in its array
 */
public void atan2(final double[] y, final int yOffset, final double[] x, final int xOffset, final double[] result, final int resultOffset) {
    // compute r = sqrt(x^2+y^2)
    double[] tmp1 = new double[getSize()];
    // x^2
    multiply(x, xOffset, x, xOffset, tmp1, 0);
    double[] tmp2 = new double[getSize()];
    // y^2
    multiply(y, yOffset, y, yOffset, tmp2, 0);
    // x^2 + y^2
    add(tmp1, 0, tmp2, 0, tmp2, 0);
    // r = sqrt(x^2 + y^2)
    rootN(tmp2, 0, 2, tmp1, 0);
    if (x[xOffset] >= 0) {
        // compute atan2(y, x) = 2 atan(y / (r + x))
        // r + x
        add(tmp1, 0, x, xOffset, tmp2, 0);
        // y /(r + x)
        divide(y, yOffset, tmp2, 0, tmp1, 0);
        // atan(y / (r + x))
        atan(tmp1, 0, tmp2, 0);
        for (int i = 0; i < tmp2.length; ++i) {
            // 2 * atan(y / (r + x))
            result[resultOffset + i] = 2 * tmp2[i];
        }
    } else {
        // compute atan2(y, x) = +/- pi - 2 atan(y / (r - x))
        // r - x
        subtract(tmp1, 0, x, xOffset, tmp2, 0);
        // y /(r - x)
        divide(y, yOffset, tmp2, 0, tmp1, 0);
        // atan(y / (r - x))
        atan(tmp1, 0, tmp2, 0);
        result[resultOffset] = // +/-pi - 2 * atan(y / (r - x))
        ((tmp2[0] <= 0) ? -FastMath.PI : FastMath.PI) - 2 * tmp2[0];
        for (int i = 1; i < tmp2.length; ++i) {
            // +/-pi - 2 * atan(y / (r - x))
            result[resultOffset + i] = -2 * tmp2[i];
        }
    }
}","/**
 * Compute two arguments arc tangent of a derivative structure.
 * @param y array holding the first operand
 * @param yOffset offset of the first operand in its array
 * @param x array holding the second operand
 * @param xOffset offset of the second operand in its array
 * @param result array where result must be stored (for
 * two arguments arc tangent the result array <em>cannot</em>
 * be the input array)
 * @param resultOffset offset of the result in its array
 */
","public void atan2(final double[] y, final int yOffset, final double[] x, final int xOffset, final double[] result, final int resultOffset) {
        double[] tmp1 = new double[getSize()];
        multiply(x, xOffset, x, xOffset, tmp1, 0);
    double[] tmp2 = new double[getSize()];
        multiply(y, yOffset, y, yOffset, tmp2, 0);
        add(tmp1, 0, tmp2, 0, tmp2, 0);
        rootN(tmp2, 0, 2, tmp1, 0);
    if (x[xOffset] >= 0) {
                        add(tmp1, 0, x, xOffset, tmp2, 0);
                divide(y, yOffset, tmp2, 0, tmp1, 0);
                atan(tmp1, 0, tmp2, 0);
        for (int i = 0; i < tmp2.length; ++i) {
                        result[resultOffset + i] = 2 * tmp2[i];
        }
    } else {
                        subtract(tmp1, 0, x, xOffset, tmp2, 0);
                divide(y, yOffset, tmp2, 0, tmp1, 0);
                atan(tmp1, 0, tmp2, 0);
        result[resultOffset] =         ((tmp2[0] <= 0) ? -FastMath.PI : FastMath.PI) - 2 * tmp2[0];
        for (int i = 1; i < tmp2.length; ++i) {
                        result[resultOffset + i] = -2 * tmp2[i];
        }
    }
}",0.5,0.009569377990430419,0.2,0.0,0.08333333333333333,3.470238095238095,-0.4818886539816771,0.5,-0.02631578947368421,5.942831785988024
Closure,157,2,"void add(Node n, Context context) {
    if (!cc.continueProcessing()) {
        return;
    }
    int type = n.getType();
    String opstr = NodeUtil.opToStr(type);
    int childCount = n.getChildCount();
    Node first = n.getFirstChild();
    Node last = n.getLastChild();
    // Handle all binary operators
    if (opstr != null && first != last) {
        Preconditions.checkState(childCount == 2, ""Bad binary operator \""%s\"": expected 2 arguments but got %s"", opstr, childCount);
        int p = NodeUtil.precedence(type);
        addLeftExpr(first, p, context);
        cc.addOp(opstr, true);
        // For right-hand-side of operations, only pass context if it's
        // the IN_FOR_INIT_CLAUSE one.
        Context rhsContext = getContextForNoInOperator(context);
        // we can simply generate a * b * c.
        if (last.getType() == type && NodeUtil.isAssociative(type)) {
            addExpr(last, p, rhsContext);
        } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {
            // Assignments are the only right-associative binary operators
            addExpr(last, p, rhsContext);
        } else {
            addExpr(last, p + 1, rhsContext);
        }
        return;
    }
    cc.startSourceMapping(n);
    switch(type) {
        case Token.TRY:
            {
                Preconditions.checkState(first.getNext().getType() == Token.BLOCK && !first.getNext().hasMoreThanOneChild());
                Preconditions.checkState(childCount >= 2 && childCount <= 3);
                add(""try"");
                add(first, Context.PRESERVE_BLOCK);
                // second child contains the catch block, or nothing if there
                // isn't a catch block
                Node catchblock = first.getNext().getFirstChild();
                if (catchblock != null) {
                    add(catchblock);
                }
                if (childCount == 3) {
                    add(""finally"");
                    add(last, Context.PRESERVE_BLOCK);
                }
                break;
            }
        case Token.CATCH:
            Preconditions.checkState(childCount == 2);
            add(""catch("");
            add(first);
            add("")"");
            add(last, Context.PRESERVE_BLOCK);
            break;
        case Token.THROW:
            Preconditions.checkState(childCount == 1);
            add(""throw"");
            add(first);
            // Must have a ';' after a throw statement, otherwise safari can't
            // parse this.
            cc.endStatement(true);
            break;
        case Token.RETURN:
            add(""return"");
            if (childCount == 1) {
                add(first);
            } else {
                Preconditions.checkState(childCount == 0);
            }
            cc.endStatement();
            break;
        case Token.VAR:
            if (first != null) {
                add(""var "");
                addList(first, false, getContextForNoInOperator(context));
            }
            break;
        case Token.LABEL_NAME:
            Preconditions.checkState(!n.getString().isEmpty());
            addIdentifier(n.getString());
            break;
        case Token.NAME:
            if (first == null || first.getType() == Token.EMPTY) {
                addIdentifier(n.getString());
            } else {
                Preconditions.checkState(childCount == 1);
                addIdentifier(n.getString());
                cc.addOp(""="", true);
                if (first.getType() == Token.COMMA) {
                    addExpr(first, NodeUtil.precedence(Token.ASSIGN));
                } else {
                    // Add expression, consider nearby code at lowest level of
                    // precedence.
                    addExpr(first, 0, getContextForNoInOperator(context));
                }
            }
            break;
        case Token.ARRAYLIT:
            add(""["");
            addArrayList(first);
            add(""]"");
            break;
        case Token.LP:
            add(""("");
            addList(first);
            add("")"");
            break;
        case Token.COMMA:
            Preconditions.checkState(childCount == 2);
            addList(first, false, context);
            break;
        case Token.NUMBER:
            Preconditions.checkState(childCount == ((n.getParent() != null && n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0));
            cc.addNumber(n.getDouble());
            break;
        case Token.TYPEOF:
        case Token.VOID:
        case Token.NOT:
        case Token.BITNOT:
        case Token.POS:
            {
                // All of these unary operators are right-associative
                Preconditions.checkState(childCount == 1);
                cc.addOp(NodeUtil.opToStrNoFail(type), false);
                addExpr(first, NodeUtil.precedence(type));
                break;
            }
        case Token.NEG:
            {
                Preconditions.checkState(childCount == 1);
                // NEG is a weird case because Rhino parses ""- -2"" as ""2"".
                if (n.getFirstChild().getType() == Token.NUMBER) {
                    cc.addNumber(-n.getFirstChild().getDouble());
                } else {
                    cc.addOp(NodeUtil.opToStrNoFail(type), false);
                    addExpr(first, NodeUtil.precedence(type));
                }
                break;
            }
        case Token.HOOK:
            {
                Preconditions.checkState(childCount == 3);
                int p = NodeUtil.precedence(type);
                addLeftExpr(first, p + 1, context);
                cc.addOp(""?"", true);
                addExpr(first.getNext(), 1);
                cc.addOp("":"", true);
                addExpr(last, 1);
                break;
            }
        case Token.REGEXP:
            if (first.getType() != Token.STRING || last.getType() != Token.STRING) {
                throw new Error(""Expected children to be strings"");
            }
            String regexp = regexpEscape(first.getString(), outputCharsetEncoder);
            // I only use one .add because whitespace matters
            if (childCount == 2) {
                add(regexp + last.getString());
            } else {
                Preconditions.checkState(childCount == 1);
                add(regexp);
            }
            break;
        case Token.GET_REF:
            add(first);
            break;
        case Token.REF_SPECIAL:
            Preconditions.checkState(childCount == 1);
            add(first);
            add(""."");
            add((String) n.getProp(Node.NAME_PROP));
            break;
        case Token.FUNCTION:
            if (n.getClass() != Node.class) {
                throw new Error(""Unexpected Node subclass."");
            }
            Preconditions.checkState(childCount == 3);
            boolean funcNeedsParens = (context == Context.START_OF_EXPR);
            if (funcNeedsParens) {
                add(""("");
            }
            add(""function"");
            add(first);
            add(first.getNext());
            add(last, Context.PRESERVE_BLOCK);
            cc.endFunction(context == Context.STATEMENT);
            if (funcNeedsParens) {
                add("")"");
            }
            break;
        case Token.GET:
        case Token.SET:
            Preconditions.checkState(n.getParent().getType() == Token.OBJECTLIT);
            Preconditions.checkState(childCount == 1);
            Preconditions.checkState(first.getType() == Token.FUNCTION);
            // Get methods are unnamed
            Preconditions.checkState(first.getFirstChild().getString().isEmpty());
            if (type == Token.GET) {
                // Get methods have no parameters.
                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());
                add(""get "");
            } else {
                // Set methods have one parameter.
                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());
                add(""set "");
            }
            // The name is on the GET or SET node.
            String name = n.getString();
            Node fn = first;
            Node parameters = fn.getChildAtIndex(1);
            Node body = fn.getLastChild();
            // Add the property name.
            if (TokenStream.isJSIdentifier(name) && // unicode escaped.
            NodeUtil.isLatin(name)) {
                add(name);
            } else {
                // Determine if the string is a simple number.
                add(jsString(n.getString(), outputCharsetEncoder));
            }
            add(parameters);
            add(body, Context.PRESERVE_BLOCK);
            break;
        case Token.SCRIPT:
        case Token.BLOCK:
            {
                if (n.getClass() != Node.class) {
                    throw new Error(""Unexpected Node subclass."");
                }
                boolean preserveBlock = context == Context.PRESERVE_BLOCK;
                if (preserveBlock) {
                    cc.beginBlock();
                }
                boolean preferLineBreaks = type == Token.SCRIPT || (type == Token.BLOCK && !preserveBlock && n.getParent() != null && n.getParent().getType() == Token.SCRIPT);
                for (Node c = first; c != null; c = c.getNext()) {
                    add(c, Context.STATEMENT);
                    // VAR doesn't include ';' since it gets used in expressions
                    if (c.getType() == Token.VAR) {
                        cc.endStatement();
                    }
                    if (c.getType() == Token.FUNCTION) {
                        cc.maybeLineBreak();
                    }
                    // because top level statements are more homogeneous.
                    if (preferLineBreaks) {
                        cc.notePreferredLineBreak();
                    }
                }
                if (preserveBlock) {
                    cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));
                }
                break;
            }
        case Token.FOR:
            if (childCount == 4) {
                add(""for("");
                if (first.getType() == Token.VAR) {
                    add(first, Context.IN_FOR_INIT_CLAUSE);
                } else {
                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);
                }
                add("";"");
                add(first.getNext());
                add("";"");
                add(first.getNext().getNext());
                add("")"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            } else {
                Preconditions.checkState(childCount == 3);
                add(""for("");
                add(first);
                add(""in"");
                add(first.getNext());
                add("")"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            }
            break;
        case Token.DO:
            Preconditions.checkState(childCount == 2);
            add(""do"");
            addNonEmptyStatement(first, Context.OTHER, false);
            add(""while("");
            add(last);
            add("")"");
            cc.endStatement();
            break;
        case Token.WHILE:
            Preconditions.checkState(childCount == 2);
            add(""while("");
            add(first);
            add("")"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            break;
        case Token.EMPTY:
            Preconditions.checkState(childCount == 0);
            break;
        case Token.GETPROP:
            {
                Preconditions.checkState(childCount == 2, ""Bad GETPROP: expected 2 children, but got %s"", childCount);
                Preconditions.checkState(last.getType() == Token.STRING, ""Bad GETPROP: RHS should be STRING"");
                boolean needsParens = (first.getType() == Token.NUMBER);
                if (needsParens) {
                    add(""("");
                }
                addLeftExpr(first, NodeUtil.precedence(type), context);
                if (needsParens) {
                    add("")"");
                }
                add(""."");
                addIdentifier(last.getString());
                break;
            }
        case Token.GETELEM:
            Preconditions.checkState(childCount == 2, ""Bad GETELEM: expected 2 children but got %s"", childCount);
            addLeftExpr(first, NodeUtil.precedence(type), context);
            add(""["");
            add(first.getNext());
            add(""]"");
            break;
        case Token.WITH:
            Preconditions.checkState(childCount == 2);
            add(""with("");
            add(first);
            add("")"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            break;
        case Token.INC:
        case Token.DEC:
            {
                Preconditions.checkState(childCount == 1);
                String o = type == Token.INC ? ""++"" : ""--"";
                int postProp = n.getIntProp(Node.INCRDECR_PROP);
                // is a pre-inc/dec.
                if (postProp != 0) {
                    addLeftExpr(first, NodeUtil.precedence(type), context);
                    cc.addOp(o, false);
                } else {
                    cc.addOp(o, false);
                    add(first);
                }
                break;
            }
        case Token.CALL:
            // that must be preserved.
            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {
                add(""(0,"");
                addExpr(first, NodeUtil.precedence(Token.COMMA));
                add("")"");
            } else {
                addLeftExpr(first, NodeUtil.precedence(type), context);
            }
            add(""("");
            addList(first.getNext());
            add("")"");
            break;
        case Token.IF:
            boolean hasElse = childCount == 3;
            boolean ambiguousElseClause = context == Context.BEFORE_DANGLING_ELSE && !hasElse;
            if (ambiguousElseClause) {
                cc.beginBlock();
            }
            add(""if("");
            add(first);
            add("")"");
            if (hasElse) {
                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);
                add(""else"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            } else {
                addNonEmptyStatement(first.getNext(), Context.OTHER, false);
                Preconditions.checkState(childCount == 2);
            }
            if (ambiguousElseClause) {
                cc.endBlock();
            }
            break;
        case Token.NULL:
        case Token.THIS:
        case Token.FALSE:
        case Token.TRUE:
            Preconditions.checkState(childCount == 0);
            add(Node.tokenToName(type));
            break;
        case Token.CONTINUE:
            Preconditions.checkState(childCount <= 1);
            add(""continue"");
            if (childCount == 1) {
                if (first.getType() != Token.LABEL_NAME) {
                    throw new Error(""Unexpected token type. Should be LABEL_NAME."");
                }
                add("" "");
                add(first);
            }
            cc.endStatement();
            break;
        case Token.DEBUGGER:
            Preconditions.checkState(childCount == 0);
            add(""debugger"");
            cc.endStatement();
            break;
        case Token.BREAK:
            Preconditions.checkState(childCount <= 1);
            add(""break"");
            if (childCount == 1) {
                if (first.getType() != Token.LABEL_NAME) {
                    throw new Error(""Unexpected token type. Should be LABEL_NAME."");
                }
                add("" "");
                add(first);
            }
            cc.endStatement();
            break;
        case Token.EXPR_VOID:
            throw new Error(""Unexpected EXPR_VOID. Should be EXPR_RESULT."");
        case Token.EXPR_RESULT:
            Preconditions.checkState(childCount == 1);
            add(first, Context.START_OF_EXPR);
            cc.endStatement();
            break;
        case Token.NEW:
            add(""new "");
            int precedence = NodeUtil.precedence(type);
            // first viable parentheses (don't traverse into functions).
            if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {
                precedence = NodeUtil.precedence(first.getType()) + 1;
            }
            addExpr(first, precedence);
            // '()' is optional when no arguments are present
            Node next = first.getNext();
            if (next != null) {
                add(""("");
                addList(next);
                add("")"");
            }
            break;
        case Token.STRING:
            if (childCount != ((n.getParent() != null && n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0)) {
                throw new IllegalStateException(""Unexpected String children: "" + n.getParent().toStringTree());
            }
            add(jsString(n.getString(), outputCharsetEncoder));
            break;
        case Token.DELPROP:
            Preconditions.checkState(childCount == 1);
            add(""delete "");
            add(first);
            break;
        case Token.OBJECTLIT:
            {
                boolean needsParens = (context == Context.START_OF_EXPR);
                if (needsParens) {
                    add(""("");
                }
                add(""{"");
                for (Node c = first; c != null; c = c.getNext()) {
                    if (c != first) {
                        cc.listSeparator();
                    }
                    if (c.getType() == Token.GET || c.getType() == Token.SET) {
                        add(c);
                    } else {
                        // are not JavaScript keywords
                        if (c.getType() == Token.STRING && !c.isQuotedString() && !TokenStream.isKeyword(c.getString()) && TokenStream.isJSIdentifier(c.getString()) && // were unicode escaped.
                        NodeUtil.isLatin(c.getString())) {
                            add(c.getString());
                        } else {
                            // Determine if the string is a simple number.
                            addExpr(c, 1);
                        }
                        add("":"");
                        addExpr(c.getFirstChild(), 1);
                    }
                }
                add(""}"");
                if (needsParens) {
                    add("")"");
                }
                break;
            }
        case Token.SWITCH:
            add(""switch("");
            add(first);
            add("")"");
            cc.beginBlock();
            addAllSiblings(first.getNext());
            cc.endBlock(context == Context.STATEMENT);
            break;
        case Token.CASE:
            Preconditions.checkState(childCount == 2);
            add(""case "");
            add(first);
            addCaseBody(last);
            break;
        case Token.DEFAULT:
            Preconditions.checkState(childCount == 1);
            add(""default"");
            addCaseBody(first);
            break;
        case Token.LABEL:
            Preconditions.checkState(childCount == 2);
            if (first.getType() != Token.LABEL_NAME) {
                throw new Error(""Unexpected token type. Should be LABEL_NAME."");
            }
            add(first);
            add("":"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);
            break;
        // ignored for our purposes.
        case Token.SETNAME:
            break;
        default:
            throw new Error(""Unknown type "" + type + ""\n"" + n.toStringTree());
    }
    cc.endSourceMapping(n);
}",,"void add(Node n, Context context) {
    if (!cc.continueProcessing()) {
        return;
    }
    int type = n.getType();
    String opstr = NodeUtil.opToStr(type);
    int childCount = n.getChildCount();
    Node first = n.getFirstChild();
    Node last = n.getLastChild();
        if (opstr != null && first != last) {
        Preconditions.checkState(childCount == 2, ""Bad binary operator \""%s\"": expected 2 arguments but got %s"", opstr, childCount);
        int p = NodeUtil.precedence(type);
        addLeftExpr(first, p, context);
        cc.addOp(opstr, true);
                        Context rhsContext = getContextForNoInOperator(context);
                if (last.getType() == type && NodeUtil.isAssociative(type)) {
            addExpr(last, p, rhsContext);
        } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {
                        addExpr(last, p, rhsContext);
        } else {
            addExpr(last, p + 1, rhsContext);
        }
        return;
    }
    cc.startSourceMapping(n);
    switch(type) {
        case Token.TRY:
            {
                Preconditions.checkState(first.getNext().getType() == Token.BLOCK && !first.getNext().hasMoreThanOneChild());
                Preconditions.checkState(childCount >= 2 && childCount <= 3);
                add(""try"");
                add(first, Context.PRESERVE_BLOCK);
                                                Node catchblock = first.getNext().getFirstChild();
                if (catchblock != null) {
                    add(catchblock);
                }
                if (childCount == 3) {
                    add(""finally"");
                    add(last, Context.PRESERVE_BLOCK);
                }
                break;
            }
        case Token.CATCH:
            Preconditions.checkState(childCount == 2);
            add(""catch("");
            add(first);
            add("")"");
            add(last, Context.PRESERVE_BLOCK);
            break;
        case Token.THROW:
            Preconditions.checkState(childCount == 1);
            add(""throw"");
            add(first);
                                    cc.endStatement(true);
            break;
        case Token.RETURN:
            add(""return"");
            if (childCount == 1) {
                add(first);
            } else {
                Preconditions.checkState(childCount == 0);
            }
            cc.endStatement();
            break;
        case Token.VAR:
            if (first != null) {
                add(""var "");
                addList(first, false, getContextForNoInOperator(context));
            }
            break;
        case Token.LABEL_NAME:
            Preconditions.checkState(!n.getString().isEmpty());
            addIdentifier(n.getString());
            break;
        case Token.NAME:
            if (first == null || first.getType() == Token.EMPTY) {
                addIdentifier(n.getString());
            } else {
                Preconditions.checkState(childCount == 1);
                addIdentifier(n.getString());
                cc.addOp(""="", true);
                if (first.getType() == Token.COMMA) {
                    addExpr(first, NodeUtil.precedence(Token.ASSIGN));
                } else {
                                                            addExpr(first, 0, getContextForNoInOperator(context));
                }
            }
            break;
        case Token.ARRAYLIT:
            add(""["");
            addArrayList(first);
            add(""]"");
            break;
        case Token.LP:
            add(""("");
            addList(first);
            add("")"");
            break;
        case Token.COMMA:
            Preconditions.checkState(childCount == 2);
            addList(first, false, context);
            break;
        case Token.NUMBER:
            Preconditions.checkState(childCount == ((n.getParent() != null && n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0));
            cc.addNumber(n.getDouble());
            break;
        case Token.TYPEOF:
        case Token.VOID:
        case Token.NOT:
        case Token.BITNOT:
        case Token.POS:
            {
                                Preconditions.checkState(childCount == 1);
                cc.addOp(NodeUtil.opToStrNoFail(type), false);
                addExpr(first, NodeUtil.precedence(type));
                break;
            }
        case Token.NEG:
            {
                Preconditions.checkState(childCount == 1);
                                if (n.getFirstChild().getType() == Token.NUMBER) {
                    cc.addNumber(-n.getFirstChild().getDouble());
                } else {
                    cc.addOp(NodeUtil.opToStrNoFail(type), false);
                    addExpr(first, NodeUtil.precedence(type));
                }
                break;
            }
        case Token.HOOK:
            {
                Preconditions.checkState(childCount == 3);
                int p = NodeUtil.precedence(type);
                addLeftExpr(first, p + 1, context);
                cc.addOp(""?"", true);
                addExpr(first.getNext(), 1);
                cc.addOp("":"", true);
                addExpr(last, 1);
                break;
            }
        case Token.REGEXP:
            if (first.getType() != Token.STRING || last.getType() != Token.STRING) {
                throw new Error(""Expected children to be strings"");
            }
            String regexp = regexpEscape(first.getString(), outputCharsetEncoder);
                        if (childCount == 2) {
                add(regexp + last.getString());
            } else {
                Preconditions.checkState(childCount == 1);
                add(regexp);
            }
            break;
        case Token.GET_REF:
            add(first);
            break;
        case Token.REF_SPECIAL:
            Preconditions.checkState(childCount == 1);
            add(first);
            add(""."");
            add((String) n.getProp(Node.NAME_PROP));
            break;
        case Token.FUNCTION:
            if (n.getClass() != Node.class) {
                throw new Error(""Unexpected Node subclass."");
            }
            Preconditions.checkState(childCount == 3);
            boolean funcNeedsParens = (context == Context.START_OF_EXPR);
            if (funcNeedsParens) {
                add(""("");
            }
            add(""function"");
            add(first);
            add(first.getNext());
            add(last, Context.PRESERVE_BLOCK);
            cc.endFunction(context == Context.STATEMENT);
            if (funcNeedsParens) {
                add("")"");
            }
            break;
        case Token.GET:
        case Token.SET:
            Preconditions.checkState(n.getParent().getType() == Token.OBJECTLIT);
            Preconditions.checkState(childCount == 1);
            Preconditions.checkState(first.getType() == Token.FUNCTION);
                        Preconditions.checkState(first.getFirstChild().getString().isEmpty());
            if (type == Token.GET) {
                                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());
                add(""get "");
            } else {
                                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());
                add(""set "");
            }
                        String name = n.getString();
            Node fn = first;
            Node parameters = fn.getChildAtIndex(1);
            Node body = fn.getLastChild();
                        if (TokenStream.isJSIdentifier(name) &&             NodeUtil.isLatin(name)) {
                add(name);
            } else {
                                add(jsString(n.getString(), outputCharsetEncoder));
            }
            add(parameters);
            add(body, Context.PRESERVE_BLOCK);
            break;
        case Token.SCRIPT:
        case Token.BLOCK:
            {
                if (n.getClass() != Node.class) {
                    throw new Error(""Unexpected Node subclass."");
                }
                boolean preserveBlock = context == Context.PRESERVE_BLOCK;
                if (preserveBlock) {
                    cc.beginBlock();
                }
                boolean preferLineBreaks = type == Token.SCRIPT || (type == Token.BLOCK && !preserveBlock && n.getParent() != null && n.getParent().getType() == Token.SCRIPT);
                for (Node c = first; c != null; c = c.getNext()) {
                    add(c, Context.STATEMENT);
                                        if (c.getType() == Token.VAR) {
                        cc.endStatement();
                    }
                    if (c.getType() == Token.FUNCTION) {
                        cc.maybeLineBreak();
                    }
                                        if (preferLineBreaks) {
                        cc.notePreferredLineBreak();
                    }
                }
                if (preserveBlock) {
                    cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));
                }
                break;
            }
        case Token.FOR:
            if (childCount == 4) {
                add(""for("");
                if (first.getType() == Token.VAR) {
                    add(first, Context.IN_FOR_INIT_CLAUSE);
                } else {
                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);
                }
                add("";"");
                add(first.getNext());
                add("";"");
                add(first.getNext().getNext());
                add("")"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            } else {
                Preconditions.checkState(childCount == 3);
                add(""for("");
                add(first);
                add(""in"");
                add(first.getNext());
                add("")"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            }
            break;
        case Token.DO:
            Preconditions.checkState(childCount == 2);
            add(""do"");
            addNonEmptyStatement(first, Context.OTHER, false);
            add(""while("");
            add(last);
            add("")"");
            cc.endStatement();
            break;
        case Token.WHILE:
            Preconditions.checkState(childCount == 2);
            add(""while("");
            add(first);
            add("")"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            break;
        case Token.EMPTY:
            Preconditions.checkState(childCount == 0);
            break;
        case Token.GETPROP:
            {
                Preconditions.checkState(childCount == 2, ""Bad GETPROP: expected 2 children, but got %s"", childCount);
                Preconditions.checkState(last.getType() == Token.STRING, ""Bad GETPROP: RHS should be STRING"");
                boolean needsParens = (first.getType() == Token.NUMBER);
                if (needsParens) {
                    add(""("");
                }
                addLeftExpr(first, NodeUtil.precedence(type), context);
                if (needsParens) {
                    add("")"");
                }
                add(""."");
                addIdentifier(last.getString());
                break;
            }
        case Token.GETELEM:
            Preconditions.checkState(childCount == 2, ""Bad GETELEM: expected 2 children but got %s"", childCount);
            addLeftExpr(first, NodeUtil.precedence(type), context);
            add(""["");
            add(first.getNext());
            add(""]"");
            break;
        case Token.WITH:
            Preconditions.checkState(childCount == 2);
            add(""with("");
            add(first);
            add("")"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            break;
        case Token.INC:
        case Token.DEC:
            {
                Preconditions.checkState(childCount == 1);
                String o = type == Token.INC ? ""++"" : ""--"";
                int postProp = n.getIntProp(Node.INCRDECR_PROP);
                                if (postProp != 0) {
                    addLeftExpr(first, NodeUtil.precedence(type), context);
                    cc.addOp(o, false);
                } else {
                    cc.addOp(o, false);
                    add(first);
                }
                break;
            }
        case Token.CALL:
                        if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {
                add(""(0,"");
                addExpr(first, NodeUtil.precedence(Token.COMMA));
                add("")"");
            } else {
                addLeftExpr(first, NodeUtil.precedence(type), context);
            }
            add(""("");
            addList(first.getNext());
            add("")"");
            break;
        case Token.IF:
            boolean hasElse = childCount == 3;
            boolean ambiguousElseClause = context == Context.BEFORE_DANGLING_ELSE && !hasElse;
            if (ambiguousElseClause) {
                cc.beginBlock();
            }
            add(""if("");
            add(first);
            add("")"");
            if (hasElse) {
                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);
                add(""else"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            } else {
                addNonEmptyStatement(first.getNext(), Context.OTHER, false);
                Preconditions.checkState(childCount == 2);
            }
            if (ambiguousElseClause) {
                cc.endBlock();
            }
            break;
        case Token.NULL:
        case Token.THIS:
        case Token.FALSE:
        case Token.TRUE:
            Preconditions.checkState(childCount == 0);
            add(Node.tokenToName(type));
            break;
        case Token.CONTINUE:
            Preconditions.checkState(childCount <= 1);
            add(""continue"");
            if (childCount == 1) {
                if (first.getType() != Token.LABEL_NAME) {
                    throw new Error(""Unexpected token type. Should be LABEL_NAME."");
                }
                add("" "");
                add(first);
            }
            cc.endStatement();
            break;
        case Token.DEBUGGER:
            Preconditions.checkState(childCount == 0);
            add(""debugger"");
            cc.endStatement();
            break;
        case Token.BREAK:
            Preconditions.checkState(childCount <= 1);
            add(""break"");
            if (childCount == 1) {
                if (first.getType() != Token.LABEL_NAME) {
                    throw new Error(""Unexpected token type. Should be LABEL_NAME."");
                }
                add("" "");
                add(first);
            }
            cc.endStatement();
            break;
        case Token.EXPR_VOID:
            throw new Error(""Unexpected EXPR_VOID. Should be EXPR_RESULT."");
        case Token.EXPR_RESULT:
            Preconditions.checkState(childCount == 1);
            add(first, Context.START_OF_EXPR);
            cc.endStatement();
            break;
        case Token.NEW:
            add(""new "");
            int precedence = NodeUtil.precedence(type);
                        if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {
                precedence = NodeUtil.precedence(first.getType()) + 1;
            }
            addExpr(first, precedence);
                        Node next = first.getNext();
            if (next != null) {
                add(""("");
                addList(next);
                add("")"");
            }
            break;
        case Token.STRING:
            if (childCount != ((n.getParent() != null && n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0)) {
                throw new IllegalStateException(""Unexpected String children: "" + n.getParent().toStringTree());
            }
            add(jsString(n.getString(), outputCharsetEncoder));
            break;
        case Token.DELPROP:
            Preconditions.checkState(childCount == 1);
            add(""delete "");
            add(first);
            break;
        case Token.OBJECTLIT:
            {
                boolean needsParens = (context == Context.START_OF_EXPR);
                if (needsParens) {
                    add(""("");
                }
                add(""{"");
                for (Node c = first; c != null; c = c.getNext()) {
                    if (c != first) {
                        cc.listSeparator();
                    }
                    if (c.getType() == Token.GET || c.getType() == Token.SET) {
                        add(c);
                    } else {
                                                if (c.getType() == Token.STRING && !c.isQuotedString() && !TokenStream.isKeyword(c.getString()) && TokenStream.isJSIdentifier(c.getString()) &&                         NodeUtil.isLatin(c.getString())) {
                            add(c.getString());
                        } else {
                                                        addExpr(c, 1);
                        }
                        add("":"");
                        addExpr(c.getFirstChild(), 1);
                    }
                }
                add(""}"");
                if (needsParens) {
                    add("")"");
                }
                break;
            }
        case Token.SWITCH:
            add(""switch("");
            add(first);
            add("")"");
            cc.beginBlock();
            addAllSiblings(first.getNext());
            cc.endBlock(context == Context.STATEMENT);
            break;
        case Token.CASE:
            Preconditions.checkState(childCount == 2);
            add(""case "");
            add(first);
            addCaseBody(last);
            break;
        case Token.DEFAULT:
            Preconditions.checkState(childCount == 1);
            add(""default"");
            addCaseBody(first);
            break;
        case Token.LABEL:
            Preconditions.checkState(childCount == 2);
            if (first.getType() != Token.LABEL_NAME) {
                throw new Error(""Unexpected token type. Should be LABEL_NAME."");
            }
            add(first);
            add("":"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);
            break;
                case Token.SETNAME:
            break;
        default:
            throw new Error(""Unknown type "" + type + ""\n"" + n.toStringTree());
    }
    cc.endSourceMapping(n);
}",21.454545454545453,0.5071770334928228,31.4,1.5,13.0,4.962301587301588,-3.247780126849894,28.666666666666668,-0.02631578947368421,129.28478414965164
commons-math,remotes/origin/bugs-dot-jar_MATH-373_bfe4623c,1,"/**
 * {@inheritDoc}
 */
@Override
public void increment(final double d) {
    if (n == 0) {
        value = d;
    } else {
        value *= d;
    }
    n++;
}","/**
 * {@inheritDoc}
 */
","@Override
public void increment(final double d) {
    if (n == 0) {
        value = d;
    } else {
        value *= d;
    }
    n++;
}",-0.22727272727272727,-0.01913875598086126,-0.4,-0.5,-0.25,0.25793650793650796,0.38238195912614503,-0.5,2.5789473684210527,-0.08760337246359272
wicket,remotes/origin/bugs-dot-jar_WICKET-5398_19e7c1cd,3,"/**
 *  Parse the given string.
 *  <p>
 *  Note: xml character encoding is NOT applied. It is assumed the input provided does have the
 *  correct encoding already.
 *
 *  @param string
 *             The input string
 *  @throws IOException
 *              Error while reading the resource
 */
@Override
public void parse(final CharSequence string) throws IOException {
    parse(new ByteArrayInputStream(string.toString().getBytes()), null);
}","/**
 *  Parse the given string.
 *  <p>
 *  Note: xml character encoding is NOT applied. It is assumed the input provided does have the
 *  correct encoding already.
 *
 *  @param string
 *             The input string
 *  @throws IOException
 *              Error while reading the resource
 */
","@Override
public void parse(final CharSequence string) throws IOException {
    parse(new ByteArrayInputStream(string.toString().getBytes()), null);
}",-0.45454545454545453,-0.6028708133971293,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.7978858350951374,-0.25,2.552631578947368,-0.16279340490885932
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-763_97203de8,1,"/**
 * Returns the object formatted using its toString method.
 * @return the String representation of the object.
 */
@Override
public String getFormat() {
    return obj.toString();
}","/**
 * Returns the object formatted using its toString method.
 * @return the String representation of the object.
 */
","@Override
public String getFormat() {
    return obj.toString();
}",-0.45454545454545453,-0.6028708133971293,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.9362931642001409,-0.4166666666666667,2.526315789473684,-0.16279340490885932
commons-math,remotes/origin/bugs-dot-jar_MATH-1067_aff82362,1,"/**
 * Returns the regularized beta function I(x, a, b).
 *
 * The implementation of this method is based on:
 * <ul>
 * <li>
 * <a href=""http://mathworld.wolfram.com/RegularizedBetaFunction.html"">
 * Regularized Beta Function</a>.</li>
 * <li>
 * <a href=""http://functions.wolfram.com/06.21.10.0001.01"">
 * Regularized Beta Function</a>.</li>
 * </ul>
 *
 * @param x the value.
 * @param a Parameter {@code a}.
 * @param b Parameter {@code b}.
 * @param epsilon When the absolute value of the nth item in the
 * series is less than epsilon the approximation ceases to calculate
 * further elements in the series.
 * @param maxIterations Maximum number of ""iterations"" to complete.
 * @return the regularized beta function I(x, a, b)
 * @throws org.apache.commons.math3.exception.MaxCountExceededException
 * if the algorithm fails to converge.
 */
public static double regularizedBeta(double x, final double a, final double b, double epsilon, int maxIterations) {
    double ret;
    if (Double.isNaN(x) || Double.isNaN(a) || Double.isNaN(b) || x < 0 || x > 1 || a <= 0.0 || b <= 0.0) {
        ret = Double.NaN;
    } else if (x > (a + 1.0) / (a + b + 2.0)) {
        ret = 1.0 - regularizedBeta(1.0 - x, b, a, epsilon, maxIterations);
    } else {
        ContinuedFraction fraction = new ContinuedFraction() {

            @Override
            protected double getB(int n, double x) {
                double ret;
                double m;
                if (n % 2 == 0) {
                    // even
                    m = n / 2.0;
                    ret = (m * (b - m) * x) / ((a + (2 * m) - 1) * (a + (2 * m)));
                } else {
                    m = (n - 1.0) / 2.0;
                    ret = -((a + m) * (a + b + m) * x) / ((a + (2 * m)) * (a + (2 * m) + 1.0));
                }
                return ret;
            }

            @Override
            protected double getA(int n, double x) {
                return 1.0;
            }
        };
        ret = FastMath.exp((a * FastMath.log(x)) + (b * FastMath.log1p(-x)) - FastMath.log(a) - logBeta(a, b)) * 1.0 / fraction.evaluate(x, epsilon, maxIterations);
    }
    return ret;
}","/**
 * Returns the regularized beta function I(x, a, b).
 *
 * The implementation of this method is based on:
 * <ul>
 * <li>
 * <a href=""http://mathworld.wolfram.com/RegularizedBetaFunction.html"">
 * Regularized Beta Function</a>.</li>
 * <li>
 * <a href=""http://functions.wolfram.com/06.21.10.0001.01"">
 * Regularized Beta Function</a>.</li>
 * </ul>
 *
 * @param x the value.
 * @param a Parameter {@code a}.
 * @param b Parameter {@code b}.
 * @param epsilon When the absolute value of the nth item in the
 * series is less than epsilon the approximation ceases to calculate
 * further elements in the series.
 * @param maxIterations Maximum number of ""iterations"" to complete.
 * @return the regularized beta function I(x, a, b)
 * @throws org.apache.commons.math3.exception.MaxCountExceededException
 * if the algorithm fails to converge.
 */
","public static double regularizedBeta(double x, final double a, final double b, double epsilon, int maxIterations) {
    double ret;
    if (Double.isNaN(x) || Double.isNaN(a) || Double.isNaN(b) || x < 0 || x > 1 || a <= 0.0 || b <= 0.0) {
        ret = Double.NaN;
    } else if (x > (a + 1.0) / (a + b + 2.0)) {
        ret = 1.0 - regularizedBeta(1.0 - x, b, a, epsilon, maxIterations);
    } else {
        ContinuedFraction fraction = new ContinuedFraction() {

            @Override
            protected double getB(int n, double x) {
                double ret;
                double m;
                if (n % 2 == 0) {
                                        m = n / 2.0;
                    ret = (m * (b - m) * x) / ((a + (2 * m) - 1) * (a + (2 * m)));
                } else {
                    m = (n - 1.0) / 2.0;
                    ret = -((a + m) * (a + b + m) * x) / ((a + (2 * m)) * (a + (2 * m) + 1.0));
                }
                return ret;
            }

            @Override
            protected double getA(int n, double x) {
                return 1.0;
            }
        };
        ret = FastMath.exp((a * FastMath.log(x)) + (b * FastMath.log1p(-x)) - FastMath.log(a) - logBeta(a, b)) * 1.0 / fraction.evaluate(x, epsilon, maxIterations);
    }
    return ret;
}",0.7272727272727273,1.449760765550239,0.0,1.0,0.9166666666666666,3.537698412698413,-0.6019732205778717,0.3333333333333333,-0.02631578947368421,8.192437890077972
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-4138_eb0f9b41,1,"@Override
public Options getOptions() {
    final Options o = new Options();
    scanOptAuths = new Option(""s"", ""scan-authorizations"", true, ""scan authorizations (all user auths are used if this argument is not specified)"");
    optStartRowExclusive = new Option(""be"", ""begin-exclusive"", false, ""make start row exclusive (by default it's inclusive)"");
    optStartRowExclusive.setArgName(""begin-exclusive"");
    optEndRowExclusive = new Option(""ee"", ""end-exclusive"", false, ""make end row exclusive (by default it's inclusive)"");
    optEndRowExclusive.setArgName(""end-exclusive"");
    scanOptRow = new Option(""r"", ""row"", true, ""row to scan"");
    scanOptColumns = new Option(""c"", ""columns"", true, ""comma-separated columns"");
    timestampOpt = new Option(""st"", ""show-timestamps"", false, ""display timestamps"");
    disablePaginationOpt = new Option(""np"", ""no-pagination"", false, ""disable pagination of output"");
    showFewOpt = new Option(""f"", ""show-few"", true, ""show only a specified number of characters"");
    formatterOpt = new Option(""fm"", ""formatter"", true, ""fully qualified name of the formatter class to use"");
    interpreterOpt = new Option(""i"", ""interpreter"", true, ""fully qualified name of the interpreter class to use"");
    formatterInterpeterOpt = new Option(""fi"", ""fmt-interpreter"", true, ""fully qualified name of a class that is a formatter and interpreter"");
    timeoutOption = new Option(null, ""timeout"", true, ""time before scan should fail if no data is returned. If no unit is given assumes seconds.  Units d,h,m,s,and ms are supported.  e.g. 30s or 100ms"");
    outputFileOpt = new Option(""o"", ""output"", true, ""local file to write the scan output to"");
    scanOptAuths.setArgName(""comma-separated-authorizations"");
    scanOptRow.setArgName(""row"");
    scanOptColumns.setArgName(""<columnfamily>[:<columnqualifier>]{,<columnfamily>[:<columnqualifier>]}"");
    showFewOpt.setRequired(false);
    showFewOpt.setArgName(""int"");
    formatterOpt.setArgName(""className"");
    timeoutOption.setArgName(""timeout"");
    outputFileOpt.setArgName(""file"");
    profileOpt = new Option(""pn"", ""profile"", true, ""iterator profile name"");
    profileOpt.setArgName(""profile"");
    o.addOption(scanOptAuths);
    o.addOption(scanOptRow);
    o.addOption(OptUtil.startRowOpt());
    o.addOption(OptUtil.endRowOpt());
    o.addOption(optStartRowExclusive);
    o.addOption(optEndRowExclusive);
    o.addOption(scanOptColumns);
    o.addOption(timestampOpt);
    o.addOption(disablePaginationOpt);
    o.addOption(OptUtil.tableOpt(""table to be scanned""));
    o.addOption(showFewOpt);
    o.addOption(formatterOpt);
    o.addOption(interpreterOpt);
    o.addOption(formatterInterpeterOpt);
    o.addOption(timeoutOption);
    o.addOption(outputFileOpt);
    o.addOption(profileOpt);
    return o;
}",,"@Override
public Options getOptions() {
    final Options o = new Options();
    scanOptAuths = new Option(""s"", ""scan-authorizations"", true, ""scan authorizations (all user auths are used if this argument is not specified)"");
    optStartRowExclusive = new Option(""be"", ""begin-exclusive"", false, ""make start row exclusive (by default it's inclusive)"");
    optStartRowExclusive.setArgName(""begin-exclusive"");
    optEndRowExclusive = new Option(""ee"", ""end-exclusive"", false, ""make end row exclusive (by default it's inclusive)"");
    optEndRowExclusive.setArgName(""end-exclusive"");
    scanOptRow = new Option(""r"", ""row"", true, ""row to scan"");
    scanOptColumns = new Option(""c"", ""columns"", true, ""comma-separated columns"");
    timestampOpt = new Option(""st"", ""show-timestamps"", false, ""display timestamps"");
    disablePaginationOpt = new Option(""np"", ""no-pagination"", false, ""disable pagination of output"");
    showFewOpt = new Option(""f"", ""show-few"", true, ""show only a specified number of characters"");
    formatterOpt = new Option(""fm"", ""formatter"", true, ""fully qualified name of the formatter class to use"");
    interpreterOpt = new Option(""i"", ""interpreter"", true, ""fully qualified name of the interpreter class to use"");
    formatterInterpeterOpt = new Option(""fi"", ""fmt-interpreter"", true, ""fully qualified name of a class that is a formatter and interpreter"");
    timeoutOption = new Option(null, ""timeout"", true, ""time before scan should fail if no data is returned. If no unit is given assumes seconds.  Units d,h,m,s,and ms are supported.  e.g. 30s or 100ms"");
    outputFileOpt = new Option(""o"", ""output"", true, ""local file to write the scan output to"");
    scanOptAuths.setArgName(""comma-separated-authorizations"");
    scanOptRow.setArgName(""row"");
    scanOptColumns.setArgName(""<columnfamily>[:<columnqualifier>]{,<columnfamily>[:<columnqualifier>]}"");
    showFewOpt.setRequired(false);
    showFewOpt.setArgName(""int"");
    formatterOpt.setArgName(""className"");
    timeoutOption.setArgName(""timeout"");
    outputFileOpt.setArgName(""file"");
    profileOpt = new Option(""pn"", ""profile"", true, ""iterator profile name"");
    profileOpt.setArgName(""profile"");
    o.addOption(scanOptAuths);
    o.addOption(scanOptRow);
    o.addOption(OptUtil.startRowOpt());
    o.addOption(OptUtil.endRowOpt());
    o.addOption(optStartRowExclusive);
    o.addOption(optEndRowExclusive);
    o.addOption(scanOptColumns);
    o.addOption(timestampOpt);
    o.addOption(disablePaginationOpt);
    o.addOption(OptUtil.tableOpt(""table to be scanned""));
    o.addOption(showFewOpt);
    o.addOption(formatterOpt);
    o.addOption(interpreterOpt);
    o.addOption(formatterInterpeterOpt);
    o.addOption(timeoutOption);
    o.addOption(outputFileOpt);
    o.addOption(profileOpt);
    return o;
}",1.5,-0.9617224880382776,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,-0.8291754756871031,2.0833333333333335,-0.02631578947368421,-0.16279340490885932
Compress,47,1,"/**
 * Whether this class is able to read the given entry.
 *
 * <p>May return false if it is set up to use encryption or a
 * compression method that hasn't been implemented yet.</p>
 * @since 1.1
 */
@Override
public boolean canReadEntryData(final ArchiveEntry ae) {
    if (ae instanceof ZipArchiveEntry) {
        final ZipArchiveEntry ze = (ZipArchiveEntry) ae;
        return ZipUtil.canHandleEntryData(ze) && supportsDataDescriptorFor(ze);
    }
    return false;
}","/**
 * Whether this class is able to read the given entry.
 *
 * <p>May return false if it is set up to use encryption or a
 * compression method that hasn't been implemented yet.</p>
 * @since 1.1
 */
","@Override
public boolean canReadEntryData(final ArchiveEntry ae) {
    if (ae instanceof ZipArchiveEntry) {
        final ZipArchiveEntry ze = (ZipArchiveEntry) ae;
        return ZipUtil.canHandleEntryData(ze) && supportsDataDescriptorFor(ze);
    }
    return false;
}",-0.2727272727272727,0.06220095693779899,-0.4,-0.5,-0.25,-0.05753968253968254,0.3916842847075403,-0.3333333333333333,2.4736842105263155,-0.11269745221094608
camel,remotes/origin/bugs-dot-jar_CAMEL-5707_3f70d612,3,"@Override
public boolean onExchangeCompleted(Exchange exchange) {
    if (exchange.getExchangeId().equals(id)) {
        done.set(false);
    }
    return true;
}",,"@Override
public boolean onExchangeCompleted(Exchange exchange) {
    if (exchange.getExchangeId().equals(id)) {
        done.set(false);
    }
    return true;
}",-0.3181818181818182,-0.0909090909090911,-0.4,-0.5,-0.16666666666666666,-0.3650793650793651,0.5128964059196618,-0.25,1.0526315789473684,-0.16279340490885932
Closure,54,2,"/**
 * Declare the symbol for a qualified name in the global scope.
 *
 * @param info The doc info for this property.
 * @param n A top-level GETPROP node (it should not be contained inside
 *     another GETPROP).
 * @param parent The parent of {@code n}.
 * @param rhsValue The node that {@code n} is being initialized to,
 *     or {@code null} if this is a stub declaration.
 */
void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {
    Node ownerNode = n.getFirstChild();
    String ownerName = ownerNode.getQualifiedName();
    String qName = n.getQualifiedName();
    String propName = n.getLastChild().getString();
    Preconditions.checkArgument(qName != null && ownerName != null);
    // Precedence of type information on GETPROPs:
    // 1) @type annnotation / @enum annotation
    // 2) ASSIGN to FUNCTION literal
    // 3) @param/@return annotation (with no function literal)
    // 4) ASSIGN to something marked @const
    // 5) ASSIGN to anything else
    //
    // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff
    // the function has jsdoc or has not been declared before.
    //
    // FUNCTION literals are special because TypedScopeCreator is very smart
    // about getting as much type information as possible for them.
    // Determining type for #1 + #2 + #3 + #4
    JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);
    if (valueType == null && rhsValue != null) {
        // Determining type for #5
        valueType = rhsValue.getJSType();
    }
    // allow F.prototype to be redefined arbitrarily.
    if (""prototype"".equals(propName)) {
        Var qVar = scope.getVar(qName);
        if (qVar != null) {
            // the @extends tag.
            if (!qVar.isTypeInferred()) {
                // what props are going to be on that prototype.
                return;
            }
            if (qVar.getScope() == scope) {
                scope.undeclare(qVar);
            }
        }
    }
    if (valueType == null) {
        if (parent.getType() == Token.EXPR_RESULT) {
            stubDeclarations.add(new StubDeclaration(n, t.getInput() != null && t.getInput().isExtern(), ownerName));
        }
        return;
    }
    boolean inferred = true;
    if (info != null) {
        // Determining declaration for #1 + #3 + #4
        inferred = !(info.hasType() || info.hasEnumParameterType() || (info.isConstant() && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));
    }
    if (inferred) {
        // Determining declaration for #2
        inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && (info != null || !scope.isDeclared(qName, false)));
    }
    if (!inferred) {
        ObjectType ownerType = getObjectSlot(ownerName);
        if (ownerType != null) {
            // Only declare this as an official property if it has not been
            // declared yet.
            boolean isExtern = t.getInput() != null && t.getInput().isExtern();
            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) && ((isExtern && !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {
                // If the property is undeclared or inferred, declare it now.
                ownerType.defineDeclaredProperty(propName, valueType, n);
            }
        }
        // If the property is already declared, the error will be
        // caught when we try to declare it in the current scope.
        defineSlot(n, parent, valueType, inferred);
    } else if (rhsValue != null && rhsValue.getType() == Token.TRUE) {
        // We declare these for delegate proxy method properties.
        FunctionType ownerType = JSType.toMaybeFunctionType(getObjectSlot(ownerName));
        if (ownerType != null) {
            JSType ownerTypeOfThis = ownerType.getTypeOfThis();
            String delegateName = codingConvention.getDelegateSuperclassName();
            JSType delegateType = delegateName == null ? null : typeRegistry.getType(delegateName);
            if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) {
                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);
            }
        }
    }
}","/**
 * Declare the symbol for a qualified name in the global scope.
 *
 * @param info The doc info for this property.
 * @param n A top-level GETPROP node (it should not be contained inside
 *     another GETPROP).
 * @param parent The parent of {@code n}.
 * @param rhsValue The node that {@code n} is being initialized to,
 *     or {@code null} if this is a stub declaration.
 */
","void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {
    Node ownerNode = n.getFirstChild();
    String ownerName = ownerNode.getQualifiedName();
    String qName = n.getQualifiedName();
    String propName = n.getLastChild().getString();
    Preconditions.checkArgument(qName != null && ownerName != null);
                                                        JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);
    if (valueType == null && rhsValue != null) {
                valueType = rhsValue.getJSType();
    }
        if (""prototype"".equals(propName)) {
        Var qVar = scope.getVar(qName);
        if (qVar != null) {
                        if (!qVar.isTypeInferred()) {
                                return;
            }
            if (qVar.getScope() == scope) {
                scope.undeclare(qVar);
            }
        }
    }
    if (valueType == null) {
        if (parent.getType() == Token.EXPR_RESULT) {
            stubDeclarations.add(new StubDeclaration(n, t.getInput() != null && t.getInput().isExtern(), ownerName));
        }
        return;
    }
    boolean inferred = true;
    if (info != null) {
                inferred = !(info.hasType() || info.hasEnumParameterType() || (info.isConstant() && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));
    }
    if (inferred) {
                inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && (info != null || !scope.isDeclared(qName, false)));
    }
    if (!inferred) {
        ObjectType ownerType = getObjectSlot(ownerName);
        if (ownerType != null) {
                                    boolean isExtern = t.getInput() != null && t.getInput().isExtern();
            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) && ((isExtern && !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {
                                ownerType.defineDeclaredProperty(propName, valueType, n);
            }
        }
                        defineSlot(n, parent, valueType, inferred);
    } else if (rhsValue != null && rhsValue.getType() == Token.TRUE) {
                FunctionType ownerType = JSType.toMaybeFunctionType(getObjectSlot(ownerName));
        if (ownerType != null) {
            JSType ownerTypeOfThis = ownerType.getTypeOfThis();
            String delegateName = codingConvention.getDelegateSuperclassName();
            JSType delegateType = delegateName == null ? null : typeRegistry.getType(delegateName);
            if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) {
                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);
            }
        }
    }
}",1.8636363636363635,0.5167464114832536,2.6,1.0,3.25,1.126984126984127,-1.0465116279069764,3.25,-0.02631578947368421,5.472853742731511
camel,remotes/origin/bugs-dot-jar_CAMEL-5140_8898d491,3,"public boolean process(Exchange exchange, AsyncCallback callback) {
    // do we have an explicit method name we always should invoke (either configured on endpoint or as a header)
    String explicitMethodName = exchange.getIn().getHeader(Exchange.BEAN_METHOD_NAME, method, String.class);
    Object bean;
    BeanInfo beanInfo;
    try {
        bean = beanHolder.getBean();
        beanInfo = beanHolder.getBeanInfo();
    } catch (Throwable e) {
        exchange.setException(e);
        callback.done(true);
        return true;
    }
    // do we have a custom adapter for this POJO to a Processor
    // should not be invoked if an explicit method has been set
    Processor processor = getProcessor();
    if (explicitMethodName == null && processor != null) {
        LOG.trace(""Using a custom adapter as bean invocation: {}"", processor);
        try {
            processor.process(exchange);
        } catch (Throwable e) {
            exchange.setException(e);
        }
        callback.done(true);
        return true;
    }
    Message in = exchange.getIn();
    // is the message proxied using a BeanInvocation?
    BeanInvocation beanInvoke = null;
    if (in.getBody() != null && in.getBody() instanceof BeanInvocation) {
        // BeanInvocation would be stored directly as the message body
        // do not force any type conversion attempts as it would just be unnecessary and cost a bit performance
        // so a regular instanceof check is sufficient
        beanInvoke = (BeanInvocation) in.getBody();
    }
    if (beanInvoke != null) {
        // Now it gets a bit complicated as ProxyHelper can proxy beans which we later
        // intend to invoke (for example to proxy and invoke using spring remoting).
        // and therefore the message body contains a BeanInvocation object.
        // However this can causes problem if we in a Camel route invokes another bean,
        // so we must test whether BeanHolder and BeanInvocation is the same bean or not
        LOG.trace(""Exchange IN body is a BeanInvocation instance: {}"", beanInvoke);
        Class<?> clazz = beanInvoke.getMethod().getDeclaringClass();
        boolean sameBean = clazz.isInstance(bean);
        if (LOG.isDebugEnabled()) {
            LOG.debug(""BeanHolder bean: {} and beanInvocation bean: {} is same instance: {}"", new Object[] { bean.getClass(), clazz, sameBean });
        }
        if (sameBean) {
            beanInvoke.invoke(bean, exchange);
            // propagate headers
            exchange.getOut().getHeaders().putAll(exchange.getIn().getHeaders());
            callback.done(true);
            return true;
        }
    }
    // set temporary header which is a hint for the bean info that introspect the bean
    if (in.getHeader(Exchange.BEAN_MULTI_PARAMETER_ARRAY) == null) {
        in.setHeader(Exchange.BEAN_MULTI_PARAMETER_ARRAY, isMultiParameterArray());
    }
    MethodInvocation invocation;
    // set explicit method name to invoke as a header, which is how BeanInfo can detect it
    if (explicitMethodName != null) {
        in.setHeader(Exchange.BEAN_METHOD_NAME, explicitMethodName);
    }
    try {
        invocation = beanInfo.createInvocation(bean, exchange);
    } catch (Throwable e) {
        exchange.setException(e);
        callback.done(true);
        return true;
    } finally {
        // must remove headers as they were provisional
        in.removeHeader(Exchange.BEAN_MULTI_PARAMETER_ARRAY);
        in.removeHeader(Exchange.BEAN_METHOD_NAME);
    }
    if (invocation == null) {
        throw new IllegalStateException(""No method invocation could be created, no matching method could be found on: "" + bean);
    }
    Object value;
    try {
        AtomicBoolean sync = new AtomicBoolean(true);
        value = invocation.proceed(callback, sync);
        if (!sync.get()) {
            LOG.trace(""Processing exchangeId: {} is continued being processed asynchronously"", exchange.getExchangeId());
            // so we break out now, then the callback will be invoked which then continue routing from where we left here
            return false;
        }
        LOG.trace(""Processing exchangeId: {} is continued being processed synchronously"", exchange.getExchangeId());
    } catch (InvocationTargetException e) {
        // let's unwrap the exception when it's an invocation target exception
        exchange.setException(e.getCause());
        callback.done(true);
        return true;
    } catch (Throwable e) {
        exchange.setException(e);
        callback.done(true);
        return true;
    }
    // if the method returns something then set the value returned on the Exchange
    if (!invocation.getMethod().getReturnType().equals(Void.TYPE) && value != Void.TYPE) {
        if (exchange.getPattern().isOutCapable()) {
            // force out creating if not already created (as its lazy)
            LOG.debug(""Setting bean invocation result on the OUT message: {}"", value);
            exchange.getOut().setBody(value);
            // propagate headers
            exchange.getOut().getHeaders().putAll(exchange.getIn().getHeaders());
        } else {
            // if not out then set it on the in
            LOG.debug(""Setting bean invocation result on the IN message: {}"", value);
            exchange.getIn().setBody(value);
        }
    }
    callback.done(true);
    return true;
}",,"public boolean process(Exchange exchange, AsyncCallback callback) {
        String explicitMethodName = exchange.getIn().getHeader(Exchange.BEAN_METHOD_NAME, method, String.class);
    Object bean;
    BeanInfo beanInfo;
    try {
        bean = beanHolder.getBean();
        beanInfo = beanHolder.getBeanInfo();
    } catch (Throwable e) {
        exchange.setException(e);
        callback.done(true);
        return true;
    }
            Processor processor = getProcessor();
    if (explicitMethodName == null && processor != null) {
        LOG.trace(""Using a custom adapter as bean invocation: {}"", processor);
        try {
            processor.process(exchange);
        } catch (Throwable e) {
            exchange.setException(e);
        }
        callback.done(true);
        return true;
    }
    Message in = exchange.getIn();
        BeanInvocation beanInvoke = null;
    if (in.getBody() != null && in.getBody() instanceof BeanInvocation) {
                                beanInvoke = (BeanInvocation) in.getBody();
    }
    if (beanInvoke != null) {
                                                LOG.trace(""Exchange IN body is a BeanInvocation instance: {}"", beanInvoke);
        Class<?> clazz = beanInvoke.getMethod().getDeclaringClass();
        boolean sameBean = clazz.isInstance(bean);
        if (LOG.isDebugEnabled()) {
            LOG.debug(""BeanHolder bean: {} and beanInvocation bean: {} is same instance: {}"", new Object[] { bean.getClass(), clazz, sameBean });
        }
        if (sameBean) {
            beanInvoke.invoke(bean, exchange);
                        exchange.getOut().getHeaders().putAll(exchange.getIn().getHeaders());
            callback.done(true);
            return true;
        }
    }
        if (in.getHeader(Exchange.BEAN_MULTI_PARAMETER_ARRAY) == null) {
        in.setHeader(Exchange.BEAN_MULTI_PARAMETER_ARRAY, isMultiParameterArray());
    }
    MethodInvocation invocation;
        if (explicitMethodName != null) {
        in.setHeader(Exchange.BEAN_METHOD_NAME, explicitMethodName);
    }
    try {
        invocation = beanInfo.createInvocation(bean, exchange);
    } catch (Throwable e) {
        exchange.setException(e);
        callback.done(true);
        return true;
    } finally {
                in.removeHeader(Exchange.BEAN_MULTI_PARAMETER_ARRAY);
        in.removeHeader(Exchange.BEAN_METHOD_NAME);
    }
    if (invocation == null) {
        throw new IllegalStateException(""No method invocation could be created, no matching method could be found on: "" + bean);
    }
    Object value;
    try {
        AtomicBoolean sync = new AtomicBoolean(true);
        value = invocation.proceed(callback, sync);
        if (!sync.get()) {
            LOG.trace(""Processing exchangeId: {} is continued being processed asynchronously"", exchange.getExchangeId());
                        return false;
        }
        LOG.trace(""Processing exchangeId: {} is continued being processed synchronously"", exchange.getExchangeId());
    } catch (InvocationTargetException e) {
                exchange.setException(e.getCause());
        callback.done(true);
        return true;
    } catch (Throwable e) {
        exchange.setException(e);
        callback.done(true);
        return true;
    }
        if (!invocation.getMethod().getReturnType().equals(Void.TYPE) && value != Void.TYPE) {
        if (exchange.getPattern().isOutCapable()) {
                        LOG.debug(""Setting bean invocation result on the OUT message: {}"", value);
            exchange.getOut().setBody(value);
                        exchange.getOut().getHeaders().putAll(exchange.getIn().getHeaders());
        } else {
                        LOG.debug(""Setting bean invocation result on the IN message: {}"", value);
            exchange.getIn().setBody(value);
        }
    }
    callback.done(true);
    return true;
}",3.590909090909091,-0.023923444976076683,2.8,0.0,1.75,1.4424603174603174,-1.3016208597603942,5.0,-0.02631578947368421,7.099625986180505
camel,remotes/origin/bugs-dot-jar_CAMEL-9700_4d03e9de,1,"/**
 * Strategy method for adding the exchange to the queue.
 * <p>
 * Will perform a blocking ""put"" if blockWhenFull is true, otherwise it will
 * simply add which will throw exception if the queue is full
 *
 * @param exchange the exchange to add to the queue
 */
protected void addToQueue(Exchange exchange) throws SedaConsumerNotAvailableException {
    BlockingQueue<Exchange> queue = null;
    QueueReference queueReference = endpoint.getQueueReference();
    if (queueReference != null) {
        queue = queueReference.getQueue();
    }
    if (queue == null) {
        throw new SedaConsumerNotAvailableException(""No queue available on endpoint: "" + endpoint, exchange);
    }
    boolean empty = !queueReference.hasConsumers();
    if (empty) {
        if (endpoint.isFailIfNoConsumers()) {
            throw new SedaConsumerNotAvailableException(""No consumers available on endpoint: "" + endpoint, exchange);
        } else if (endpoint.isDiscardIfNoConsumers()) {
            log.debug(""Discard message as no active consumers on endpoint: "" + endpoint);
            return;
        }
    }
    if (blockWhenFull) {
        try {
            queue.put(exchange);
        } catch (InterruptedException e) {
            // ignore
            log.debug(""Put interrupted, are we stopping? {}"", isStopping() || isStopped());
        }
    } else {
        queue.add(exchange);
    }
}","/**
 * Strategy method for adding the exchange to the queue.
 * <p>
 * Will perform a blocking ""put"" if blockWhenFull is true, otherwise it will
 * simply add which will throw exception if the queue is full
 *
 * @param exchange the exchange to add to the queue
 */
","protected void addToQueue(Exchange exchange) throws SedaConsumerNotAvailableException {
    BlockingQueue<Exchange> queue = null;
    QueueReference queueReference = endpoint.getQueueReference();
    if (queueReference != null) {
        queue = queueReference.getQueue();
    }
    if (queue == null) {
        throw new SedaConsumerNotAvailableException(""No queue available on endpoint: "" + endpoint, exchange);
    }
    boolean empty = !queueReference.hasConsumers();
    if (empty) {
        if (endpoint.isFailIfNoConsumers()) {
            throw new SedaConsumerNotAvailableException(""No consumers available on endpoint: "" + endpoint, exchange);
        } else if (endpoint.isDiscardIfNoConsumers()) {
            log.debug(""Discard message as no active consumers on endpoint: "" + endpoint);
            return;
        }
    }
    if (blockWhenFull) {
        try {
            queue.put(exchange);
        } catch (InterruptedException e) {
                        log.debug(""Put interrupted, are we stopping? {}"", isStopping() || isStopped());
        }
    } else {
        queue.add(exchange);
    }
}",0.6363636363636364,0.21531100478468887,1.2,0.5,0.5833333333333334,0.7063492063492064,-0.4615926708949964,0.4166666666666667,-0.02631578947368421,0.6738173037580032
wicket,remotes/origin/bugs-dot-jar_WICKET-3861_d1e0e411,3,"@Override
public void onComponentTag(final Component component, final ComponentTag tag) {
    tag.put(""xmlns:wicket"", ""http://wicket.apache.org"");
}",,"@Override
public void onComponentTag(final Component component, final ComponentTag tag) {
    tag.put(""xmlns:wicket"", ""http://wicket.apache.org"");
}",-0.45454545454545453,-0.6028708133971293,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.8105708245243126,-0.4166666666666667,0.10526315789473684,-0.16279340490885932
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-3077_17654199,0,"private int write(final Collection<CommitSession> sessions, boolean mincFinish, Writer writer) throws IOException {
    // Work very hard not to lock this during calls to the outside world
    int currentLogSet = logSetId.get();
    int seq = -1;
    int attempt = 1;
    boolean success = false;
    while (!success) {
        try {
            // get a reference to the loggers that no other thread can touch
            ArrayList<DfsLogger> copy = new ArrayList<DfsLogger>();
            currentLogSet = initializeLoggers(copy);
            if (currentLogSet == logSetId.get()) {
                for (CommitSession commitSession : sessions) {
                    if (commitSession.beginUpdatingLogsUsed(copy, mincFinish)) {
                        try {
                            // Scribble out a tablet definition and then write to the metadata table
                            defineTablet(commitSession);
                            if (currentLogSet == logSetId.get())
                                tserver.addLoggersToMetadata(copy, commitSession.getExtent(), commitSession.getLogId());
                        } finally {
                            commitSession.finishUpdatingLogsUsed();
                        }
                        // Need to release
                        KeyExtent extent = commitSession.getExtent();
                        if (ReplicationConfigurationUtil.isEnabled(extent, tserver.getTableConfiguration(extent))) {
                            Set<String> logs = new HashSet<String>();
                            for (DfsLogger logger : copy) {
                                logs.add(logger.getFileName());
                            }
                            Status status = StatusUtil.fileCreated(System.currentTimeMillis());
                            log.debug(""Writing "" + ProtobufUtil.toString(status) + "" to replication table for "" + logs);
                            // Got some new WALs, note this in the replication table
                            ReplicationTableUtil.updateFiles(SystemCredentials.get(), commitSession.getExtent(), logs, status);
                        }
                    }
                }
            }
            // Make sure that the logs haven't changed out from underneath our copy
            if (currentLogSet == logSetId.get()) {
                // write the mutation to the logs
                seq = seqGen.incrementAndGet();
                if (seq < 0)
                    throw new RuntimeException(""Logger sequence generator wrapped!  Onos!!!11!eleven"");
                ArrayList<LoggerOperation> queuedOperations = new ArrayList<LoggerOperation>(copy.size());
                for (DfsLogger wal : copy) {
                    LoggerOperation lop = writer.write(wal, seq);
                    if (lop != null)
                        queuedOperations.add(lop);
                }
                for (LoggerOperation lop : queuedOperations) {
                    lop.await();
                }
                // double-check: did the log set change?
                success = (currentLogSet == logSetId.get());
            }
        } catch (DfsLogger.LogClosedException ex) {
            log.debug(""Logs closed while writing, retrying "" + attempt);
        } catch (Exception t) {
            if (attempt != 1) {
                log.error(""Unexpected error writing to log, retrying attempt "" + attempt, t);
            }
            UtilWaitThread.sleep(100);
        } finally {
            attempt++;
        }
        // Some sort of write failure occurred. Grab the write lock and reset the logs.
        // But since multiple threads will attempt it, only attempt the reset when
        // the logs haven't changed.
        final int finalCurrent = currentLogSet;
        if (!success) {
            testLockAndRun(logSetLock, new TestCallWithWriteLock() {

                @Override
                boolean test() {
                    return finalCurrent == logSetId.get();
                }

                @Override
                void withWriteLock() throws IOException {
                    close();
                    closeForReplication(sessions);
                }
            });
        }
    }
    // if the log gets too big, reset it .. grab the write lock first
    // event, tid, seq overhead
    logSizeEstimate.addAndGet(4 * 3);
    testLockAndRun(logSetLock, new TestCallWithWriteLock() {

        @Override
        boolean test() {
            return logSizeEstimate.get() > maxSize;
        }

        @Override
        void withWriteLock() throws IOException {
            close();
            closeForReplication(sessions);
        }
    });
    return seq;
}",,"private int write(final Collection<CommitSession> sessions, boolean mincFinish, Writer writer) throws IOException {
        int currentLogSet = logSetId.get();
    int seq = -1;
    int attempt = 1;
    boolean success = false;
    while (!success) {
        try {
                        ArrayList<DfsLogger> copy = new ArrayList<DfsLogger>();
            currentLogSet = initializeLoggers(copy);
            if (currentLogSet == logSetId.get()) {
                for (CommitSession commitSession : sessions) {
                    if (commitSession.beginUpdatingLogsUsed(copy, mincFinish)) {
                        try {
                                                        defineTablet(commitSession);
                            if (currentLogSet == logSetId.get())
                                tserver.addLoggersToMetadata(copy, commitSession.getExtent(), commitSession.getLogId());
                        } finally {
                            commitSession.finishUpdatingLogsUsed();
                        }
                                                KeyExtent extent = commitSession.getExtent();
                        if (ReplicationConfigurationUtil.isEnabled(extent, tserver.getTableConfiguration(extent))) {
                            Set<String> logs = new HashSet<String>();
                            for (DfsLogger logger : copy) {
                                logs.add(logger.getFileName());
                            }
                            Status status = StatusUtil.fileCreated(System.currentTimeMillis());
                            log.debug(""Writing "" + ProtobufUtil.toString(status) + "" to replication table for "" + logs);
                                                        ReplicationTableUtil.updateFiles(SystemCredentials.get(), commitSession.getExtent(), logs, status);
                        }
                    }
                }
            }
                        if (currentLogSet == logSetId.get()) {
                                seq = seqGen.incrementAndGet();
                if (seq < 0)
                    throw new RuntimeException(""Logger sequence generator wrapped!  Onos!!!11!eleven"");
                ArrayList<LoggerOperation> queuedOperations = new ArrayList<LoggerOperation>(copy.size());
                for (DfsLogger wal : copy) {
                    LoggerOperation lop = writer.write(wal, seq);
                    if (lop != null)
                        queuedOperations.add(lop);
                }
                for (LoggerOperation lop : queuedOperations) {
                    lop.await();
                }
                                success = (currentLogSet == logSetId.get());
            }
        } catch (DfsLogger.LogClosedException ex) {
            log.debug(""Logs closed while writing, retrying "" + attempt);
        } catch (Exception t) {
            if (attempt != 1) {
                log.error(""Unexpected error writing to log, retrying attempt "" + attempt, t);
            }
            UtilWaitThread.sleep(100);
        } finally {
            attempt++;
        }
                                final int finalCurrent = currentLogSet;
        if (!success) {
            testLockAndRun(logSetLock, new TestCallWithWriteLock() {

                @Override
                boolean test() {
                    return finalCurrent == logSetId.get();
                }

                @Override
                void withWriteLock() throws IOException {
                    close();
                    closeForReplication(sessions);
                }
            });
        }
    }
            logSizeEstimate.addAndGet(4 * 3);
    testLockAndRun(logSetLock, new TestCallWithWriteLock() {

        @Override
        boolean test() {
            return logSizeEstimate.get() > maxSize;
        }

        @Override
        void withWriteLock() throws IOException {
            close();
            closeForReplication(sessions);
        }
    });
    return seq;
}",3.272727272727273,2.3588516746411483,2.8,2.5,1.4166666666666667,1.6944444444444446,-1.2432699083861871,2.9166666666666665,-0.02631578947368421,6.926208053111114
Closure,162,2,"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    if (isCallToScopeMethod(n)) {
        validateScopeCall(t, n, n.getParent());
    }
    // Validate the top level of the goog.scope block.
    if (t.getScopeDepth() == 2) {
        int type = n.getType();
        if (type == Token.NAME && parent.getType() == Token.VAR) {
            if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {
                String name = n.getString();
                Var aliasVar = t.getScope().getVar(name);
                aliases.put(name, aliasVar);
                aliasDefinitionsInOrder.add(n);
                String qualifiedName = aliasVar.getInitialValue().getQualifiedName();
                transformation.addAlias(name, qualifiedName);
                // twice.
                return;
            } else {
                report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());
            }
        }
        if (type == Token.NAME && NodeUtil.isAssignmentOp(parent) && n == parent.getFirstChild()) {
            report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());
        }
        if (type == Token.RETURN) {
            report(t, n, GOOG_SCOPE_USES_RETURN);
        } else if (type == Token.THIS) {
            report(t, n, GOOG_SCOPE_REFERENCES_THIS);
        } else if (type == Token.THROW) {
            report(t, n, GOOG_SCOPE_USES_THROW);
        }
    }
    // Validate all descendent scopes of the goog.scope block.
    if (t.getScopeDepth() >= 2) {
        // Check if this name points to an alias.
        if (n.getType() == Token.NAME) {
            String name = n.getString();
            Var aliasVar = aliases.get(name);
            if (aliasVar != null && t.getScope().getVar(name) == aliasVar) {
                // Note, to support the transitive case, it's important we don't
                // clone aliasedNode here.  For example,
                // var g = goog; var d = g.dom; d.createElement('DIV');
                // The node in aliasedNode (which is ""g"") will be replaced in the
                // changes pass above with ""goog"".  If we cloned here, we'd end up
                // with <code>g.dom.createElement('DIV')</code>.
                Node aliasedNode = aliasVar.getInitialValue();
                aliasUsages.add(new AliasedNode(n, aliasedNode));
            }
        }
        JSDocInfo info = n.getJSDocInfo();
        if (info != null) {
            for (Node node : info.getTypeNodes()) {
                fixTypeNode(node);
            }
        }
    // TODO(robbyw): Error for goog.scope not at root.
    }
}",,"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    if (isCallToScopeMethod(n)) {
        validateScopeCall(t, n, n.getParent());
    }
        if (t.getScopeDepth() == 2) {
        int type = n.getType();
        if (type == Token.NAME && parent.getType() == Token.VAR) {
            if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {
                String name = n.getString();
                Var aliasVar = t.getScope().getVar(name);
                aliases.put(name, aliasVar);
                aliasDefinitionsInOrder.add(n);
                String qualifiedName = aliasVar.getInitialValue().getQualifiedName();
                transformation.addAlias(name, qualifiedName);
                                return;
            } else {
                report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());
            }
        }
        if (type == Token.NAME && NodeUtil.isAssignmentOp(parent) && n == parent.getFirstChild()) {
            report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());
        }
        if (type == Token.RETURN) {
            report(t, n, GOOG_SCOPE_USES_RETURN);
        } else if (type == Token.THIS) {
            report(t, n, GOOG_SCOPE_REFERENCES_THIS);
        } else if (type == Token.THROW) {
            report(t, n, GOOG_SCOPE_USES_THROW);
        }
    }
        if (t.getScopeDepth() >= 2) {
                if (n.getType() == Token.NAME) {
            String name = n.getString();
            Var aliasVar = aliases.get(name);
            if (aliasVar != null && t.getScope().getVar(name) == aliasVar) {
                                                                                                                Node aliasedNode = aliasVar.getInitialValue();
                aliasUsages.add(new AliasedNode(n, aliasedNode));
            }
        }
        JSDocInfo info = n.getJSDocInfo();
        if (info != null) {
            for (Node node : info.getTypeNodes()) {
                fixTypeNode(node);
            }
        }
        }
}",1.5454545454545454,0.7799043062200957,2.0,1.0,2.25,0.6170634920634921,-0.8982381959126141,2.5833333333333335,-0.02631578947368421,2.191951499224886
wicket,remotes/origin/bugs-dot-jar_WICKET-4072_7d5b8645,1,"/**
 *  render full representation of url (including protocol, host and port)
 *  into string representation
 *
 *  @param charset
 *
 *  @return see toStringRepresentation
 */
public String toAbsoluteString(final Charset charset) {
    StringBuilder result = new StringBuilder();
    // output scheme://host:port if specified
    if (protocol != null && Strings.isEmpty(host) == false) {
        result.append(protocol);
        result.append(""://"");
        result.append(host);
        if (port != null && port.equals(getDefaultPortForProtocol(protocol)) == false) {
            result.append(':');
            result.append(port);
        }
    }
    // append relative part
    result.append(this.toString());
    // return url string
    return result.toString();
}","/**
 *  render full representation of url (including protocol, host and port)
 *  into string representation
 *
 *  @param charset
 *
 *  @return see toStringRepresentation
 */
","public String toAbsoluteString(final Charset charset) {
    StringBuilder result = new StringBuilder();
        if (protocol != null && Strings.isEmpty(host) == false) {
        result.append(protocol);
        result.append(""://"");
        result.append(host);
        if (port != null && port.equals(getDefaultPortForProtocol(protocol)) == false) {
            result.append(':');
            result.append(port);
        }
    }
        result.append(this.toString());
        return result.toString();
}",0.0,0.3062200956937798,-0.2,0.0,0.4166666666666667,0.4484126984126984,-0.037632135306553724,0.4166666666666667,0.8157894736842105,0.2532067795047342
Compress,2,1,"public int read() throws IOException {
    final int ret = input.read();
    offset += (ret > 0 ? 1 : 0);
    return ret;
}",,"public int read() throws IOException {
    final int ret = input.read();
    offset += (ret > 0 ? 1 : 0);
    return ret;
}",-0.4090909090909091,-0.49282296650717716,-0.4,-1.0,-0.25,-0.06746031746031747,0.650739957716702,-0.4166666666666667,1.5789473684210527,-0.12690651959682575
commons-math,remotes/origin/bugs-dot-jar_MATH-757_76b7413d,1,"/**
 * Notice the package scope on this method.   This method is simply here
 * for the JUnit test, it allows us check if the expansion is working
 * properly after a number of expansions.  This is not meant to be a part
 * of the public interface of this class.
 *
 * @return the length of the internal storage array.
 * @deprecated As of 3.1. Please use {@link #getCapacity()} instead.
 */
@Deprecated
synchronized int getInternalLength() {
    return internalArray.length;
}","/**
 * Notice the package scope on this method.   This method is simply here
 * for the JUnit test, it allows us check if the expansion is working
 * properly after a number of expansions.  This is not meant to be a part
 * of the public interface of this class.
 *
 * @return the length of the internal storage array.
 * @deprecated As of 3.1. Please use {@link #getCapacity()} instead.
 */
","@Deprecated
synchronized int getInternalLength() {
    return internalArray.length;
}",-0.45454545454545453,-0.6028708133971293,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.9785764622973924,-0.5,1.894736842105263,-0.16279340490885932
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-492_a759d8ae,3,"/**
 * Either returns the specified name as is, or returns a quoted value
 * containing the specified name with the special characters (comma, equals,
 * colon, quote, asterisk, or question mark) preceded with a backslash.
 *
 * @param name
 *            the name to escape so it can be used as a value in an
 *            {@link ObjectName}.
 * @return the escaped name
 */
public static String escape(final String name) {
    final StringBuilder sb = new StringBuilder(name.length() * 2);
    boolean needsQuotes = false;
    for (int i = 0; i < name.length(); i++) {
        final char c = name.charAt(i);
        switch(c) {
            case ',':
            case '=':
            case ':':
            case '\\':
            case '*':
            case '?':
                sb.append('\\');
                needsQuotes = true;
        }
        sb.append(c);
    }
    if (needsQuotes) {
        sb.insert(0, '\""');
        sb.append('\""');
    }
    return sb.toString();
}","/**
 * Either returns the specified name as is, or returns a quoted value
 * containing the specified name with the special characters (comma, equals,
 * colon, quote, asterisk, or question mark) preceded with a backslash.
 *
 * @param name
 *            the name to escape so it can be used as a value in an
 *            {@link ObjectName}.
 * @return the escaped name
 */
","public static String escape(final String name) {
    final StringBuilder sb = new StringBuilder(name.length() * 2);
    boolean needsQuotes = false;
    for (int i = 0; i < name.length(); i++) {
        final char c = name.charAt(i);
        switch(c) {
            case ',':
            case '=':
            case ':':
            case '\\':
            case '*':
            case '?':
                sb.append('\\');
                needsQuotes = true;
        }
        sb.append(c);
    }
    if (needsQuotes) {
        sb.insert(0, '\""');
        sb.append('\""');
    }
    return sb.toString();
}",0.4090909090909091,0.7177033492822967,1.0,0.5,0.5833333333333334,0.3968253968253968,-0.3344608879492598,0.16666666666666666,0.0,0.3188303567826743
commons-math,remotes/origin/bugs-dot-jar_MATH-949_f83bbc1d,1,"/**
 * {@inheritDoc}
 */
@Override
protected PointVectorValuePair doOptimize() {
    checkParameters();
    // Number of observed data.
    final int nR = getTarget().length;
    final double[] currentPoint = getStartPoint();
    // Number of parameters.
    final int nC = currentPoint.length;
    // arrays shared with the other private methods
    solvedCols = FastMath.min(nR, nC);
    diagR = new double[nC];
    jacNorm = new double[nC];
    beta = new double[nC];
    permutation = new int[nC];
    lmDir = new double[nC];
    // local point
    double delta = 0;
    double xNorm = 0;
    double[] diag = new double[nC];
    double[] oldX = new double[nC];
    double[] oldRes = new double[nR];
    double[] oldObj = new double[nR];
    double[] qtf = new double[nR];
    double[] work1 = new double[nC];
    double[] work2 = new double[nC];
    double[] work3 = new double[nC];
    final RealMatrix weightMatrixSqrt = getWeightSquareRoot();
    // Evaluate the function at the starting point and calculate its norm.
    double[] currentObjective = computeObjectiveValue(currentPoint);
    double[] currentResiduals = computeResiduals(currentObjective);
    PointVectorValuePair current = new PointVectorValuePair(currentPoint, currentObjective);
    double currentCost = computeCost(currentResiduals);
    // Outer loop.
    lmPar = 0;
    boolean firstIteration = true;
    int iter = 0;
    final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker();
    while (true) {
        ++iter;
        final PointVectorValuePair previous = current;
        // QR decomposition of the jacobian matrix
        qrDecomposition(computeWeightedJacobian(currentPoint));
        weightedResidual = weightMatrixSqrt.operate(currentResiduals);
        for (int i = 0; i < nR; i++) {
            qtf[i] = weightedResidual[i];
        }
        // compute Qt.res
        qTy(qtf);
        // so let jacobian contain the R matrix with its diagonal elements
        for (int k = 0; k < solvedCols; ++k) {
            int pk = permutation[k];
            weightedJacobian[k][pk] = diagR[pk];
        }
        if (firstIteration) {
            // scale the point according to the norms of the columns
            // of the initial jacobian
            xNorm = 0;
            for (int k = 0; k < nC; ++k) {
                double dk = jacNorm[k];
                if (dk == 0) {
                    dk = 1.0;
                }
                double xk = dk * currentPoint[k];
                xNorm += xk * xk;
                diag[k] = dk;
            }
            xNorm = FastMath.sqrt(xNorm);
            // initialize the step bound delta
            delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);
        }
        // check orthogonality between function vector and jacobian columns
        double maxCosine = 0;
        if (currentCost != 0) {
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                double s = jacNorm[pj];
                if (s != 0) {
                    double sum = 0;
                    for (int i = 0; i <= j; ++i) {
                        sum += weightedJacobian[i][pj] * qtf[i];
                    }
                    maxCosine = FastMath.max(maxCosine, FastMath.abs(sum) / (s * currentCost));
                }
            }
        }
        if (maxCosine <= orthoTolerance) {
            // Convergence has been reached.
            setCost(currentCost);
            return current;
        }
        // rescale if necessary
        for (int j = 0; j < nC; ++j) {
            diag[j] = FastMath.max(diag[j], jacNorm[j]);
        }
        // Inner loop.
        for (double ratio = 0; ratio < 1.0e-4; ) {
            // save the state
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                oldX[pj] = currentPoint[pj];
            }
            final double previousCost = currentCost;
            double[] tmpVec = weightedResidual;
            weightedResidual = oldRes;
            oldRes = tmpVec;
            tmpVec = currentObjective;
            currentObjective = oldObj;
            oldObj = tmpVec;
            // determine the Levenberg-Marquardt parameter
            determineLMParameter(qtf, delta, diag, work1, work2, work3);
            // compute the new point and the norm of the evolution direction
            double lmNorm = 0;
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                lmDir[pj] = -lmDir[pj];
                currentPoint[pj] = oldX[pj] + lmDir[pj];
                double s = diag[pj] * lmDir[pj];
                lmNorm += s * s;
            }
            lmNorm = FastMath.sqrt(lmNorm);
            // on the first iteration, adjust the initial step bound.
            if (firstIteration) {
                delta = FastMath.min(delta, lmNorm);
            }
            // Evaluate the function at x + p and calculate its norm.
            currentObjective = computeObjectiveValue(currentPoint);
            currentResiduals = computeResiduals(currentObjective);
            current = new PointVectorValuePair(currentPoint, currentObjective);
            currentCost = computeCost(currentResiduals);
            // compute the scaled actual reduction
            double actRed = -1.0;
            if (0.1 * currentCost < previousCost) {
                double r = currentCost / previousCost;
                actRed = 1.0 - r * r;
            }
            // and the scaled directional derivative
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                double dirJ = lmDir[pj];
                work1[j] = 0;
                for (int i = 0; i <= j; ++i) {
                    work1[i] += weightedJacobian[i][pj] * dirJ;
                }
            }
            double coeff1 = 0;
            for (int j = 0; j < solvedCols; ++j) {
                coeff1 += work1[j] * work1[j];
            }
            double pc2 = previousCost * previousCost;
            coeff1 = coeff1 / pc2;
            double coeff2 = lmPar * lmNorm * lmNorm / pc2;
            double preRed = coeff1 + 2 * coeff2;
            double dirDer = -(coeff1 + coeff2);
            // ratio of the actual to the predicted reduction
            ratio = (preRed == 0) ? 0 : (actRed / preRed);
            // update the step bound
            if (ratio <= 0.25) {
                double tmp = (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;
                if ((0.1 * currentCost >= previousCost) || (tmp < 0.1)) {
                    tmp = 0.1;
                }
                delta = tmp * FastMath.min(delta, 10.0 * lmNorm);
                lmPar /= tmp;
            } else if ((lmPar == 0) || (ratio >= 0.75)) {
                delta = 2 * lmNorm;
                lmPar *= 0.5;
            }
            // test for successful iteration.
            if (ratio >= 1.0e-4) {
                // successful iteration, update the norm
                firstIteration = false;
                xNorm = 0;
                for (int k = 0; k < nC; ++k) {
                    double xK = diag[k] * currentPoint[k];
                    xNorm += xK * xK;
                }
                xNorm = FastMath.sqrt(xNorm);
                // tests for convergence.
                if (checker != null) {
                    // we use the vectorial convergence checker
                    if (checker.converged(iter, previous, current)) {
                        setCost(currentCost);
                        return current;
                    }
                }
            } else {
                // failed iteration, reset the previous values
                currentCost = previousCost;
                for (int j = 0; j < solvedCols; ++j) {
                    int pj = permutation[j];
                    currentPoint[pj] = oldX[pj];
                }
                tmpVec = weightedResidual;
                weightedResidual = oldRes;
                oldRes = tmpVec;
                tmpVec = currentObjective;
                currentObjective = oldObj;
                oldObj = tmpVec;
                // Reset ""current"" to previous values.
                current = new PointVectorValuePair(currentPoint, currentObjective);
            }
            // Default convergence criteria.
            if ((FastMath.abs(actRed) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0) || delta <= parRelativeTolerance * xNorm) {
                setCost(currentCost);
                return current;
            }
            // (2.2204e-16 is the machine epsilon for IEEE754)
            if ((FastMath.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {
                throw new ConvergenceException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance);
            } else if (delta <= 2.2204e-16 * xNorm) {
                throw new ConvergenceException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance);
            } else if (maxCosine <= 2.2204e-16) {
                throw new ConvergenceException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance);
            }
        }
    }
}","/**
 * {@inheritDoc}
 */
","@Override
protected PointVectorValuePair doOptimize() {
    checkParameters();
        final int nR = getTarget().length;
    final double[] currentPoint = getStartPoint();
        final int nC = currentPoint.length;
        solvedCols = FastMath.min(nR, nC);
    diagR = new double[nC];
    jacNorm = new double[nC];
    beta = new double[nC];
    permutation = new int[nC];
    lmDir = new double[nC];
        double delta = 0;
    double xNorm = 0;
    double[] diag = new double[nC];
    double[] oldX = new double[nC];
    double[] oldRes = new double[nR];
    double[] oldObj = new double[nR];
    double[] qtf = new double[nR];
    double[] work1 = new double[nC];
    double[] work2 = new double[nC];
    double[] work3 = new double[nC];
    final RealMatrix weightMatrixSqrt = getWeightSquareRoot();
        double[] currentObjective = computeObjectiveValue(currentPoint);
    double[] currentResiduals = computeResiduals(currentObjective);
    PointVectorValuePair current = new PointVectorValuePair(currentPoint, currentObjective);
    double currentCost = computeCost(currentResiduals);
        lmPar = 0;
    boolean firstIteration = true;
    int iter = 0;
    final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker();
    while (true) {
        ++iter;
        final PointVectorValuePair previous = current;
                qrDecomposition(computeWeightedJacobian(currentPoint));
        weightedResidual = weightMatrixSqrt.operate(currentResiduals);
        for (int i = 0; i < nR; i++) {
            qtf[i] = weightedResidual[i];
        }
                qTy(qtf);
                for (int k = 0; k < solvedCols; ++k) {
            int pk = permutation[k];
            weightedJacobian[k][pk] = diagR[pk];
        }
        if (firstIteration) {
                                    xNorm = 0;
            for (int k = 0; k < nC; ++k) {
                double dk = jacNorm[k];
                if (dk == 0) {
                    dk = 1.0;
                }
                double xk = dk * currentPoint[k];
                xNorm += xk * xk;
                diag[k] = dk;
            }
            xNorm = FastMath.sqrt(xNorm);
                        delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);
        }
                double maxCosine = 0;
        if (currentCost != 0) {
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                double s = jacNorm[pj];
                if (s != 0) {
                    double sum = 0;
                    for (int i = 0; i <= j; ++i) {
                        sum += weightedJacobian[i][pj] * qtf[i];
                    }
                    maxCosine = FastMath.max(maxCosine, FastMath.abs(sum) / (s * currentCost));
                }
            }
        }
        if (maxCosine <= orthoTolerance) {
                        setCost(currentCost);
            return current;
        }
                for (int j = 0; j < nC; ++j) {
            diag[j] = FastMath.max(diag[j], jacNorm[j]);
        }
                for (double ratio = 0; ratio < 1.0e-4; ) {
                        for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                oldX[pj] = currentPoint[pj];
            }
            final double previousCost = currentCost;
            double[] tmpVec = weightedResidual;
            weightedResidual = oldRes;
            oldRes = tmpVec;
            tmpVec = currentObjective;
            currentObjective = oldObj;
            oldObj = tmpVec;
                        determineLMParameter(qtf, delta, diag, work1, work2, work3);
                        double lmNorm = 0;
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                lmDir[pj] = -lmDir[pj];
                currentPoint[pj] = oldX[pj] + lmDir[pj];
                double s = diag[pj] * lmDir[pj];
                lmNorm += s * s;
            }
            lmNorm = FastMath.sqrt(lmNorm);
                        if (firstIteration) {
                delta = FastMath.min(delta, lmNorm);
            }
                        currentObjective = computeObjectiveValue(currentPoint);
            currentResiduals = computeResiduals(currentObjective);
            current = new PointVectorValuePair(currentPoint, currentObjective);
            currentCost = computeCost(currentResiduals);
                        double actRed = -1.0;
            if (0.1 * currentCost < previousCost) {
                double r = currentCost / previousCost;
                actRed = 1.0 - r * r;
            }
                        for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                double dirJ = lmDir[pj];
                work1[j] = 0;
                for (int i = 0; i <= j; ++i) {
                    work1[i] += weightedJacobian[i][pj] * dirJ;
                }
            }
            double coeff1 = 0;
            for (int j = 0; j < solvedCols; ++j) {
                coeff1 += work1[j] * work1[j];
            }
            double pc2 = previousCost * previousCost;
            coeff1 = coeff1 / pc2;
            double coeff2 = lmPar * lmNorm * lmNorm / pc2;
            double preRed = coeff1 + 2 * coeff2;
            double dirDer = -(coeff1 + coeff2);
                        ratio = (preRed == 0) ? 0 : (actRed / preRed);
                        if (ratio <= 0.25) {
                double tmp = (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;
                if ((0.1 * currentCost >= previousCost) || (tmp < 0.1)) {
                    tmp = 0.1;
                }
                delta = tmp * FastMath.min(delta, 10.0 * lmNorm);
                lmPar /= tmp;
            } else if ((lmPar == 0) || (ratio >= 0.75)) {
                delta = 2 * lmNorm;
                lmPar *= 0.5;
            }
                        if (ratio >= 1.0e-4) {
                                firstIteration = false;
                xNorm = 0;
                for (int k = 0; k < nC; ++k) {
                    double xK = diag[k] * currentPoint[k];
                    xNorm += xK * xK;
                }
                xNorm = FastMath.sqrt(xNorm);
                                if (checker != null) {
                                        if (checker.converged(iter, previous, current)) {
                        setCost(currentCost);
                        return current;
                    }
                }
            } else {
                                currentCost = previousCost;
                for (int j = 0; j < solvedCols; ++j) {
                    int pj = permutation[j];
                    currentPoint[pj] = oldX[pj];
                }
                tmpVec = weightedResidual;
                weightedResidual = oldRes;
                oldRes = tmpVec;
                tmpVec = currentObjective;
                currentObjective = oldObj;
                oldObj = tmpVec;
                                current = new PointVectorValuePair(currentPoint, currentObjective);
            }
                        if ((FastMath.abs(actRed) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0) || delta <= parRelativeTolerance * xNorm) {
                setCost(currentCost);
                return current;
            }
                        if ((FastMath.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {
                throw new ConvergenceException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance);
            } else if (delta <= 2.2204e-16 * xNorm) {
                throw new ConvergenceException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance);
            } else if (maxCosine <= 2.2204e-16) {
                throw new ConvergenceException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance);
            }
        }
    }
}",7.7272727272727275,1.0334928229665072,7.0,1.5,5.416666666666667,7.224206349206349,-1.9040169133192384,2.0833333333333335,-0.02631578947368421,87.31367484425694
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-217_46f62443,1,"@Override
public void offline(String tableName) throws AccumuloSecurityException, AccumuloException {
}",,"@Override
public void offline(String tableName) throws AccumuloSecurityException, AccumuloException {
}",-0.5,-1.4306220095693782,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,1.0329809725158563,-0.5,1.6578947368421053,-0.16279340490885932
Math,49,1,"/**
 * {@inheritDoc}
 */
public OpenMapRealVector ebeMultiply(RealVector v) {
    checkVectorDimensions(v.getDimension());
    OpenMapRealVector res = new OpenMapRealVector(this);
    Iterator iter = res.entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));
    }
    return res;
}","/**
 * {@inheritDoc}
 */
","public OpenMapRealVector ebeMultiply(RealVector v) {
    checkVectorDimensions(v.getDimension());
    OpenMapRealVector res = new OpenMapRealVector(this);
    Iterator iter = res.entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));
    }
    return res;
}",-0.18181818181818182,-0.2200956937799045,-0.4,-0.5,-0.25,-0.02380952380952383,0.18167723749119113,0.3333333333333333,0.13157894736842105,-0.04611953458619319
commons-math,remotes/origin/bugs-dot-jar_MATH-1148_4080feff,1,"public int compare(final Vector2D o1, final Vector2D o2) {
    final int diff = (int) FastMath.signum(o1.getX() - o2.getX());
    if (diff == 0) {
        return (int) FastMath.signum(o1.getY() - o2.getY());
    } else {
        return diff;
    }
}",,"public int compare(final Vector2D o1, final Vector2D o2) {
    final int diff = (int) FastMath.signum(o1.getX() - o2.getX());
    if (diff == 0) {
        return (int) FastMath.signum(o1.getY() - o2.getY());
    } else {
        return diff;
    }
}",-0.2727272727272727,-0.07655502392344504,-0.4,-0.5,-0.25,0.03174603174603173,0.34150810429880174,0.0,0.21052631578947367,-0.07151789676296515
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-678_6c54045d,1,"/**
 * Determine whether this child exists at its direct parent.
 * @return  {@code true} iff this child exists at its direct parent.
 */
private boolean exists() {
    // retrieved from the base state.
    return isRoot() || parent.writeState == null || parent.writeState.hasChildNode(name);
}","/**
 * Determine whether this child exists at its direct parent.
 * @return  {@code true} iff this child exists at its direct parent.
 */
","private boolean exists() {
        return isRoot() || parent.writeState == null || parent.writeState.hasChildNode(name);
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.11706349206349208,0.917406624383368,-0.3333333333333333,2.552631578947368,-0.13790679045429133
Chart,2,3,"/**
 * Iterates over the data items of the xy dataset to find
 * the range bounds.
 *
 * @param dataset  the dataset (<code>null</code> not permitted).
 * @param includeInterval  a flag that determines, for an
 *          {@link IntervalXYDataset}, whether the y-interval or just the
 *          y-value is used to determine the overall range.
 *
 * @return The range (possibly <code>null</code>).
 *
 * @since 1.0.10
 */
public static Range iterateRangeBounds(XYDataset dataset, boolean includeInterval) {
    double minimum = Double.POSITIVE_INFINITY;
    double maximum = Double.NEGATIVE_INFINITY;
    int seriesCount = dataset.getSeriesCount();
    // handle three cases by dataset type
    if (includeInterval && dataset instanceof IntervalXYDataset) {
        // handle special case of IntervalXYDataset
        IntervalXYDataset ixyd = (IntervalXYDataset) dataset;
        for (int series = 0; series < seriesCount; series++) {
            int itemCount = dataset.getItemCount(series);
            for (int item = 0; item < itemCount; item++) {
                double lvalue = ixyd.getStartYValue(series, item);
                double uvalue = ixyd.getEndYValue(series, item);
                if (!Double.isNaN(lvalue)) {
                    minimum = Math.min(minimum, lvalue);
                }
                if (!Double.isNaN(uvalue)) {
                    maximum = Math.max(maximum, uvalue);
                }
            }
        }
    } else if (includeInterval && dataset instanceof OHLCDataset) {
        // handle special case of OHLCDataset
        OHLCDataset ohlc = (OHLCDataset) dataset;
        for (int series = 0; series < seriesCount; series++) {
            int itemCount = dataset.getItemCount(series);
            for (int item = 0; item < itemCount; item++) {
                double lvalue = ohlc.getLowValue(series, item);
                double uvalue = ohlc.getHighValue(series, item);
                if (!Double.isNaN(lvalue)) {
                    minimum = Math.min(minimum, lvalue);
                }
                if (!Double.isNaN(uvalue)) {
                    maximum = Math.max(maximum, uvalue);
                }
            }
        }
    } else {
        // standard case - plain XYDataset
        for (int series = 0; series < seriesCount; series++) {
            int itemCount = dataset.getItemCount(series);
            for (int item = 0; item < itemCount; item++) {
                double value = dataset.getYValue(series, item);
                if (!Double.isNaN(value)) {
                    minimum = Math.min(minimum, value);
                    maximum = Math.max(maximum, value);
                }
            }
        }
    }
    if (minimum == Double.POSITIVE_INFINITY) {
        return null;
    } else {
        return new Range(minimum, maximum);
    }
}","/**
 * Iterates over the data items of the xy dataset to find
 * the range bounds.
 *
 * @param dataset  the dataset (<code>null</code> not permitted).
 * @param includeInterval  a flag that determines, for an
 *          {@link IntervalXYDataset}, whether the y-interval or just the
 *          y-value is used to determine the overall range.
 *
 * @return The range (possibly <code>null</code>).
 *
 * @since 1.0.10
 */
","public static Range iterateRangeBounds(XYDataset dataset, boolean includeInterval) {
    double minimum = Double.POSITIVE_INFINITY;
    double maximum = Double.NEGATIVE_INFINITY;
    int seriesCount = dataset.getSeriesCount();
        if (includeInterval && dataset instanceof IntervalXYDataset) {
                IntervalXYDataset ixyd = (IntervalXYDataset) dataset;
        for (int series = 0; series < seriesCount; series++) {
            int itemCount = dataset.getItemCount(series);
            for (int item = 0; item < itemCount; item++) {
                double lvalue = ixyd.getStartYValue(series, item);
                double uvalue = ixyd.getEndYValue(series, item);
                if (!Double.isNaN(lvalue)) {
                    minimum = Math.min(minimum, lvalue);
                }
                if (!Double.isNaN(uvalue)) {
                    maximum = Math.max(maximum, uvalue);
                }
            }
        }
    } else if (includeInterval && dataset instanceof OHLCDataset) {
                OHLCDataset ohlc = (OHLCDataset) dataset;
        for (int series = 0; series < seriesCount; series++) {
            int itemCount = dataset.getItemCount(series);
            for (int item = 0; item < itemCount; item++) {
                double lvalue = ohlc.getLowValue(series, item);
                double uvalue = ohlc.getHighValue(series, item);
                if (!Double.isNaN(lvalue)) {
                    minimum = Math.min(minimum, lvalue);
                }
                if (!Double.isNaN(uvalue)) {
                    maximum = Math.max(maximum, uvalue);
                }
            }
        }
    } else {
                for (int series = 0; series < seriesCount; series++) {
            int itemCount = dataset.getItemCount(series);
            for (int item = 0; item < itemCount; item++) {
                double value = dataset.getYValue(series, item);
                if (!Double.isNaN(value)) {
                    minimum = Math.min(minimum, value);
                    maximum = Math.max(maximum, value);
                }
            }
        }
    }
    if (minimum == Double.POSITIVE_INFINITY) {
        return null;
    } else {
        return new Range(minimum, maximum);
    }
}",1.7272727272727273,1.2966507177033493,2.2,1.5,2.0,2.1527777777777777,-0.9413671599718108,1.1666666666666667,-0.02631578947368421,5.88464468687148
wicket,remotes/origin/bugs-dot-jar_WICKET-1619_b154d12f,1,"@Override
public boolean isEnabled() {
    return PagingNavigator.this.isEnabled() && PagingNavigator.this.isEnableAllowed();
}",,"@Override
public boolean isEnabled() {
    return PagingNavigator.this.isEnabled() && PagingNavigator.this.isEnableAllowed();
}",-0.45454545454545453,-0.6028708133971293,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.8940098661028892,-0.3333333333333333,0.2631578947368421,-0.16279340490885932
flink,remotes/origin/bugs-dot-jar_FLINK-2800_b654e989,1,"@Override
public void serialize(T record, DataOutputView target) throws IOException {
    checkKryoInitialized();
    if (target != previousOut) {
        DataOutputViewStream outputStream = new DataOutputViewStream(target);
        output = new Output(outputStream);
        previousOut = target;
    }
    try {
        kryo.writeClassAndObject(output, record);
        output.flush();
    } catch (KryoException ke) {
        Throwable cause = ke.getCause();
        if (cause instanceof EOFException) {
            throw (EOFException) cause;
        } else {
            throw ke;
        }
    }
}",,"@Override
public void serialize(T record, DataOutputView target) throws IOException {
    checkKryoInitialized();
    if (target != previousOut) {
        DataOutputViewStream outputStream = new DataOutputViewStream(target);
        output = new Output(outputStream);
        previousOut = target;
    }
    try {
        kryo.writeClassAndObject(output, record);
        output.flush();
    } catch (KryoException ke) {
        Throwable cause = ke.getCause();
        if (cause instanceof EOFException) {
            throw (EOFException) cause;
        } else {
            throw ke;
        }
    }
}",0.2727272727272727,0.22488038277511951,0.4,0.0,0.0,-0.04563492063492063,-0.2022551092318533,-0.16666666666666666,0.2368421052631579,-0.018139382099202996
commons-math,remotes/origin/bugs-dot-jar_MATH-1257_03178c8b,3,"/**
 * {@inheritDoc}
 *
 * If {@code x} is more than 40 standard deviations from the mean, 0 or 1
 * is returned, as in these cases the actual value is within
 * {@code Double.MIN_VALUE} of 0 or 1.
 */
@Override
public double cumulativeProbability(double x) {
    final double dev = x - mean;
    if (FastMath.abs(dev) > 40 * standardDeviation) {
        return dev < 0 ? 0.0d : 1.0d;
    }
    return 0.5 * (1 + Erf.erf(dev / (standardDeviation * SQRT2)));
}","/**
 * {@inheritDoc}
 *
 * If {@code x} is more than 40 standard deviations from the mean, 0 or 1
 * is returned, as in these cases the actual value is within
 * {@code Double.MIN_VALUE} of 0 or 1.
 */
","@Override
public double cumulativeProbability(double x) {
    final double dev = x - mean;
    if (FastMath.abs(dev) > 40 * standardDeviation) {
        return dev < 0 ? 0.0d : 1.0d;
    }
    return 0.5 * (1 + Erf.erf(dev / (standardDeviation * SQRT2)));
}",-0.2727272727272727,-0.16267942583732073,-0.2,-0.5,0.0,0.3948412698412698,0.2755461592670896,-0.3333333333333333,1.631578947368421,0.0998346040582516
wicket,remotes/origin/bugs-dot-jar_WICKET-5072_381b90fd,1,"/**
 *  Checks whether two cookies are equal.
 *  See http://www.ietf.org/rfc/rfc2109.txt, p.4.3.3
 *
 *  @param c1
 *       the first cookie
 *  @param c2
 *       the second cookie
 *  @return {@code true} only if the cookies have the same name, path and domain
 */
public static boolean isEqual(Cookie c1, Cookie c2) {
    Args.notNull(c1, ""c1"");
    Args.notNull(c2, ""c2"");
    return c1.getName().equals(c2.getName()) && ((c1.getPath() == null && c2.getPath() == null) || (c1.getPath().equals(c2.getPath()))) && ((c1.getDomain() == null && c2.getDomain() == null) || (c1.getDomain().equals(c2.getDomain())));
}","/**
 *  Checks whether two cookies are equal.
 *  See http://www.ietf.org/rfc/rfc2109.txt, p.4.3.3
 *
 *  @param c1
 *       the first cookie
 *  @param c2
 *       the second cookie
 *  @return {@code true} only if the cookies have the same name, path and domain
 */
","public static boolean isEqual(Cookie c1, Cookie c2) {
    Args.notNull(c1, ""c1"");
    Args.notNull(c2, ""c2"");
    return c1.getName().equals(c2.getName()) && ((c1.getPath() == null && c2.getPath() == null) || (c1.getPath().equals(c2.getPath()))) && ((c1.getDomain() == null && c2.getDomain() == null) || (c1.getDomain().equals(c2.getDomain())));
}",-0.4090909090909091,-0.49282296650717716,-0.6,-1.0,-0.4166666666666667,0.31349206349206343,0.46300211416490467,0.75,0.02631578947368421,0.14491450701059796
Time,25,2,"/**
 * Gets the millisecond offset to subtract from local time to get UTC time.
 * This offset can be used to undo adding the offset obtained by getOffset.
 *
 * <pre>
 * millisLocal == millisUTC   + getOffset(millisUTC)
 * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)
 * </pre>
 *
 * NOTE: After calculating millisLocal, some error may be introduced. At
 * offset transitions (due to DST or other historical changes), ranges of
 * local times may map to different UTC times.
 * <p>
 * This method will return an offset suitable for calculating an instant
 * after any DST gap. For example, consider a zone with a cutover
 * from 01:00 to 01:59:<br />
 * Input: 00:00  Output: 00:00<br />
 * Input: 00:30  Output: 00:30<br />
 * Input: 01:00  Output: 02:00<br />
 * Input: 01:30  Output: 02:30<br />
 * Input: 02:00  Output: 02:00<br />
 * Input: 02:30  Output: 02:30<br />
 * <p>
 * During a DST overlap (where the local time is ambiguous) this method will return
 * the earlier instant. The combination of these two rules is to always favour
 * daylight (summer) time over standard (winter) time.
 * <p>
 * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.
 * Prior to v1.5, the DST gap behaviour was also not defined.
 *
 * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for
 * @return the millisecond offset to subtract from local time to get UTC time
 */
public int getOffsetFromLocal(long instantLocal) {
    // get the offset at instantLocal (first estimate)
    final int offsetLocal = getOffset(instantLocal);
    // adjust instantLocal using the estimate and recalc the offset
    final long instantAdjusted = instantLocal - offsetLocal;
    final int offsetAdjusted = getOffset(instantAdjusted);
    // if the offsets differ, we must be near a DST boundary
    if (offsetLocal != offsetAdjusted) {
        // this happens naturally for positive offsets, but not for negative
        if ((offsetLocal - offsetAdjusted) < 0) {
            // if we just return offsetAdjusted then the time is pushed
            // back before the transition, whereas it should be
            // on or after the transition
            long nextLocal = nextTransition(instantAdjusted);
            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);
            if (nextLocal != nextAdjusted) {
                return offsetLocal;
            }
        }
    }
    return offsetAdjusted;
}","/**
 * Gets the millisecond offset to subtract from local time to get UTC time.
 * This offset can be used to undo adding the offset obtained by getOffset.
 *
 * <pre>
 * millisLocal == millisUTC   + getOffset(millisUTC)
 * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)
 * </pre>
 *
 * NOTE: After calculating millisLocal, some error may be introduced. At
 * offset transitions (due to DST or other historical changes), ranges of
 * local times may map to different UTC times.
 * <p>
 * This method will return an offset suitable for calculating an instant
 * after any DST gap. For example, consider a zone with a cutover
 * from 01:00 to 01:59:<br />
 * Input: 00:00  Output: 00:00<br />
 * Input: 00:30  Output: 00:30<br />
 * Input: 01:00  Output: 02:00<br />
 * Input: 01:30  Output: 02:30<br />
 * Input: 02:00  Output: 02:00<br />
 * Input: 02:30  Output: 02:30<br />
 * <p>
 * During a DST overlap (where the local time is ambiguous) this method will return
 * the earlier instant. The combination of these two rules is to always favour
 * daylight (summer) time over standard (winter) time.
 * <p>
 * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.
 * Prior to v1.5, the DST gap behaviour was also not defined.
 *
 * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for
 * @return the millisecond offset to subtract from local time to get UTC time
 */
","public int getOffsetFromLocal(long instantLocal) {
        final int offsetLocal = getOffset(instantLocal);
        final long instantAdjusted = instantLocal - offsetLocal;
    final int offsetAdjusted = getOffset(instantAdjusted);
        if (offsetLocal != offsetAdjusted) {
                if ((offsetLocal - offsetAdjusted) < 0) {
                                                long nextLocal = nextTransition(instantAdjusted);
            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);
            if (nextLocal != nextAdjusted) {
                return offsetLocal;
            }
        }
    }
    return offsetAdjusted;
}",0.045454545454545456,0.8325358851674642,0.0,0.5,0.16666666666666666,0.6448412698412699,-0.02184637068358014,-0.16666666666666666,-0.02631578947368421,0.1948306564547639
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-43_668f08f2,1,"void apply() throws Exception {
    setProperty(nodePath, propName, propValue);
}",,"void apply() throws Exception {
    setProperty(nodePath, propName, propValue);
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,1.0329809725158563,-0.4166666666666667,0.5263157894736842,-0.16279340490885932
Compress,20,1,"private CpioArchiveEntry readOldAsciiEntry() throws IOException {
    CpioArchiveEntry ret = new CpioArchiveEntry(FORMAT_OLD_ASCII);
    ret.setDevice(readAsciiLong(6, 8));
    ret.setInode(readAsciiLong(6, 8));
    final long mode = readAsciiLong(6, 8);
    if (mode != 0) {
        ret.setMode(mode);
    }
    ret.setUID(readAsciiLong(6, 8));
    ret.setGID(readAsciiLong(6, 8));
    ret.setNumberOfLinks(readAsciiLong(6, 8));
    ret.setRemoteDevice(readAsciiLong(6, 8));
    ret.setTime(readAsciiLong(11, 8));
    long namesize = readAsciiLong(6, 8);
    ret.setSize(readAsciiLong(11, 8));
    final String name = readCString((int) namesize);
    ret.setName(name);
    if (mode == 0 && !name.equals(CPIO_TRAILER)) {
        throw new IOException(""Mode 0 only allowed in the trailer. Found entry: "" + name + "" Occured at byte: "" + getBytesRead());
    }
    return ret;
}",,"private CpioArchiveEntry readOldAsciiEntry() throws IOException {
    CpioArchiveEntry ret = new CpioArchiveEntry(FORMAT_OLD_ASCII);
    ret.setDevice(readAsciiLong(6, 8));
    ret.setInode(readAsciiLong(6, 8));
    final long mode = readAsciiLong(6, 8);
    if (mode != 0) {
        ret.setMode(mode);
    }
    ret.setUID(readAsciiLong(6, 8));
    ret.setGID(readAsciiLong(6, 8));
    ret.setNumberOfLinks(readAsciiLong(6, 8));
    ret.setRemoteDevice(readAsciiLong(6, 8));
    ret.setTime(readAsciiLong(11, 8));
    long namesize = readAsciiLong(6, 8);
    ret.setSize(readAsciiLong(11, 8));
    final String name = readCString((int) namesize);
    ret.setName(name);
    if (mode == 0 && !name.equals(CPIO_TRAILER)) {
        throw new IOException(""Mode 0 only allowed in the trailer. Found entry: "" + name + "" Occured at byte: "" + getBytesRead());
    }
    return ret;
}",0.36363636363636365,-0.61244019138756,0.0,-0.5,0.0,1.152777777777778,-0.3581395348837208,1.4166666666666667,-0.02631578947368421,1.4530338917607462
commons-math,remotes/origin/bugs-dot-jar_MATH-848_ad252a8c,1,"/**
 * Perform a double QR step involving rows l:idx and columns m:n
 *
 * @param l the index of the small sub-diagonal element
 * @param m the start index for the QR step
 * @param idx the current eigenvalue index
 * @param shift shift information holder
 * @param hVec the initial houseHolder vector
 */
private void performDoubleQRStep(final int l, final int m, final int idx, final ShiftInfo shift, final double[] hVec) {
    final int n = matrixT.length;
    double p = hVec[0];
    double q = hVec[1];
    double r = hVec[2];
    for (int k = m; k <= idx - 1; k++) {
        boolean notlast = k != idx - 1;
        if (k != m) {
            p = matrixT[k][k - 1];
            q = matrixT[k + 1][k - 1];
            r = notlast ? matrixT[k + 2][k - 1] : 0.0;
            shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);
            if (!Precision.equals(shift.x, 0.0, epsilon)) {
                p = p / shift.x;
                q = q / shift.x;
                r = r / shift.x;
            }
        }
        if (Precision.equals(shift.x, 0.0, epsilon)) {
            break;
        }
        double s = FastMath.sqrt(p * p + q * q + r * r);
        if (p < 0.0) {
            s = -s;
        }
        if (!Precision.equals(s, 0.0, epsilon)) {
            if (k != m) {
                matrixT[k][k - 1] = -s * shift.x;
            } else if (l != m) {
                matrixT[k][k - 1] = -matrixT[k][k - 1];
            }
            p = p + s;
            shift.x = p / s;
            shift.y = q / s;
            double z = r / s;
            q = q / p;
            r = r / p;
            // Row modification
            for (int j = k; j < n; j++) {
                p = matrixT[k][j] + q * matrixT[k + 1][j];
                if (notlast) {
                    p = p + r * matrixT[k + 2][j];
                    matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;
                }
                matrixT[k][j] = matrixT[k][j] - p * shift.x;
                matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;
            }
            // Column modification
            for (int i = 0; i <= FastMath.min(idx, k + 3); i++) {
                p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];
                if (notlast) {
                    p = p + z * matrixT[i][k + 2];
                    matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;
                }
                matrixT[i][k] = matrixT[i][k] - p;
                matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;
            }
            // Accumulate transformations
            final int high = matrixT.length - 1;
            for (int i = 0; i <= high; i++) {
                p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];
                if (notlast) {
                    p = p + z * matrixP[i][k + 2];
                    matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;
                }
                matrixP[i][k] = matrixP[i][k] - p;
                matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;
            }
        }
    // (s != 0)
    }
    // clean up pollution due to round-off errors
    for (int i = m + 2; i <= idx; i++) {
        matrixT[i][i - 2] = 0.0;
        if (i > m + 2) {
            matrixT[i][i - 3] = 0.0;
        }
    }
}","/**
 * Perform a double QR step involving rows l:idx and columns m:n
 *
 * @param l the index of the small sub-diagonal element
 * @param m the start index for the QR step
 * @param idx the current eigenvalue index
 * @param shift shift information holder
 * @param hVec the initial houseHolder vector
 */
","private void performDoubleQRStep(final int l, final int m, final int idx, final ShiftInfo shift, final double[] hVec) {
    final int n = matrixT.length;
    double p = hVec[0];
    double q = hVec[1];
    double r = hVec[2];
    for (int k = m; k <= idx - 1; k++) {
        boolean notlast = k != idx - 1;
        if (k != m) {
            p = matrixT[k][k - 1];
            q = matrixT[k + 1][k - 1];
            r = notlast ? matrixT[k + 2][k - 1] : 0.0;
            shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);
            if (!Precision.equals(shift.x, 0.0, epsilon)) {
                p = p / shift.x;
                q = q / shift.x;
                r = r / shift.x;
            }
        }
        if (Precision.equals(shift.x, 0.0, epsilon)) {
            break;
        }
        double s = FastMath.sqrt(p * p + q * q + r * r);
        if (p < 0.0) {
            s = -s;
        }
        if (!Precision.equals(s, 0.0, epsilon)) {
            if (k != m) {
                matrixT[k][k - 1] = -s * shift.x;
            } else if (l != m) {
                matrixT[k][k - 1] = -matrixT[k][k - 1];
            }
            p = p + s;
            shift.x = p / s;
            shift.y = q / s;
            double z = r / s;
            q = q / p;
            r = r / p;
                        for (int j = k; j < n; j++) {
                p = matrixT[k][j] + q * matrixT[k + 1][j];
                if (notlast) {
                    p = p + r * matrixT[k + 2][j];
                    matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;
                }
                matrixT[k][j] = matrixT[k][j] - p * shift.x;
                matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;
            }
                        for (int i = 0; i <= FastMath.min(idx, k + 3); i++) {
                p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];
                if (notlast) {
                    p = p + z * matrixT[i][k + 2];
                    matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;
                }
                matrixT[i][k] = matrixT[i][k] - p;
                matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;
            }
                        final int high = matrixT.length - 1;
            for (int i = 0; i <= high; i++) {
                p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];
                if (notlast) {
                    p = p + z * matrixP[i][k + 2];
                    matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;
                }
                matrixP[i][k] = matrixP[i][k] - p;
                matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;
            }
        }
        }
        for (int i = m + 2; i <= idx; i++) {
        matrixT[i][i - 2] = 0.0;
        if (i > m + 2) {
            matrixT[i][i - 3] = 0.0;
        }
    }
}",2.727272727272727,0.8708133971291864,3.0,1.0,2.3333333333333335,8.619047619047619,-1.2649753347427763,0.16666666666666666,-0.02631578947368421,54.56550889507442
Closure,53,2,"/**
 * Replaces an assignment like x = {...} with t1=a,t2=b,t3=c,true.
 * Note that the resulting expression will always evaluate to
 * true, as would the x = {...} expression.
 */
private void replaceAssignmentExpression(Var v, Reference ref, Map<String, String> varmap) {
    // Compute all of the assignments necessary
    List<Node> nodes = Lists.newArrayList();
    Node val = ref.getAssignedValue();
    blacklistVarReferencesInTree(val, v.scope);
    Preconditions.checkState(val.getType() == Token.OBJECTLIT);
    Set<String> all = Sets.newLinkedHashSet(varmap.keySet());
    for (Node key = val.getFirstChild(); key != null; key = key.getNext()) {
        String var = key.getString();
        Node value = key.removeFirstChild();
        // TODO(user): Copy type information.
        nodes.add(new Node(Token.ASSIGN, Node.newString(Token.NAME, varmap.get(var)), value));
        all.remove(var);
    }
    // TODO(user): Better source information.
    for (String var : all) {
        nodes.add(new Node(Token.ASSIGN, Node.newString(Token.NAME, varmap.get(var)), NodeUtil.newUndefinedNode(null)));
    }
    Node replacement;
    // All assignments evaluate to true, so make sure that the
    // expr statement evaluates to true in case it matters.
    nodes.add(new Node(Token.TRUE));
    // Join these using COMMA.  A COMMA node must have 2 children, so we
    // create a tree. In the tree the first child be the COMMA to match
    // the parser, otherwise tree equality tests fail.
    nodes = Lists.reverse(nodes);
    replacement = new Node(Token.COMMA);
    Node cur = replacement;
    int i;
    for (i = 0; i < nodes.size() - 2; i++) {
        cur.addChildToFront(nodes.get(i));
        Node t = new Node(Token.COMMA);
        cur.addChildToFront(t);
        cur = t;
    }
    cur.addChildToFront(nodes.get(i));
    cur.addChildToFront(nodes.get(i + 1));
    Node replace = ref.getParent();
    replacement.copyInformationFromForTree(replace);
    if (replace.getType() == Token.VAR) {
        replace.getParent().replaceChild(replace, NodeUtil.newExpr(replacement));
    } else {
        replace.getParent().replaceChild(replace, replacement);
    }
}","/**
 * Replaces an assignment like x = {...} with t1=a,t2=b,t3=c,true.
 * Note that the resulting expression will always evaluate to
 * true, as would the x = {...} expression.
 */
","private void replaceAssignmentExpression(Var v, Reference ref, Map<String, String> varmap) {
        List<Node> nodes = Lists.newArrayList();
    Node val = ref.getAssignedValue();
    blacklistVarReferencesInTree(val, v.scope);
    Preconditions.checkState(val.getType() == Token.OBJECTLIT);
    Set<String> all = Sets.newLinkedHashSet(varmap.keySet());
    for (Node key = val.getFirstChild(); key != null; key = key.getNext()) {
        String var = key.getString();
        Node value = key.removeFirstChild();
                nodes.add(new Node(Token.ASSIGN, Node.newString(Token.NAME, varmap.get(var)), value));
        all.remove(var);
    }
        for (String var : all) {
        nodes.add(new Node(Token.ASSIGN, Node.newString(Token.NAME, varmap.get(var)), NodeUtil.newUndefinedNode(null)));
    }
    Node replacement;
            nodes.add(new Node(Token.TRUE));
                nodes = Lists.reverse(nodes);
    replacement = new Node(Token.COMMA);
    Node cur = replacement;
    int i;
    for (i = 0; i < nodes.size() - 2; i++) {
        cur.addChildToFront(nodes.get(i));
        Node t = new Node(Token.COMMA);
        cur.addChildToFront(t);
        cur = t;
    }
    cur.addChildToFront(nodes.get(i));
    cur.addChildToFront(nodes.get(i + 1));
    Node replace = ref.getParent();
    replacement.copyInformationFromForTree(replace);
    if (replace.getType() == Token.VAR) {
        replace.getParent().replaceChild(replace, NodeUtil.newExpr(replacement));
    } else {
        replace.getParent().replaceChild(replace, replacement);
    }
}",1.0454545454545454,-0.3971291866028709,0.2,-0.5,0.16666666666666666,1.1904761904761905,-0.73276955602537,2.5833333333333335,-0.02631578947368421,3.877053762325455
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3110_d10362c0,1,"@Override
public IndexOutput createOutput(String name, IOContext context) throws IOException {
    COWFileReference ref = fileMap.remove(name);
    if (ref != null) {
        ref.delete();
    }
    ref = new COWLocalFileReference(name);
    fileMap.put(name, ref);
    return ref.createOutput(context);
}",,"@Override
public IndexOutput createOutput(String name, IOContext context) throws IOException {
    COWFileReference ref = fileMap.remove(name);
    if (ref != null) {
        ref.delete();
    }
    ref = new COWLocalFileReference(name);
    fileMap.put(name, ref);
    return ref.createOutput(context);
}",-0.18181818181818182,-0.2822966507177035,-0.4,-0.5,-0.25,-0.03769841269841273,0.19774489076814655,-0.16666666666666666,0.02631578947368421,-0.0627997441261389
camel,remotes/origin/bugs-dot-jar_CAMEL-3395_8433e6db,3,"@SuppressWarnings(""unchecked"")
private Iterable<ProcessorExchangePair> createProcessorExchangePairsIterable(final Exchange exchange, final Object value) {
    final Iterator iterator = ObjectHelper.createIterator(value);
    return new Iterable() {

        public Iterator iterator() {
            return new Iterator() {

                private int index;

                private boolean closed;

                public boolean hasNext() {
                    if (closed) {
                        return false;
                    }
                    boolean answer = iterator.hasNext();
                    if (!answer) {
                        // we are now closed
                        closed = true;
                        // nothing more so we need to close the expression value in case it needs to be
                        if (value instanceof Closeable) {
                            IOHelper.close((Closeable) value, value.getClass().getName(), LOG);
                        } else if (value instanceof Scanner) {
                            // special for Scanner as it does not implement Closeable
                            ((Scanner) value).close();
                        }
                    }
                    return answer;
                }

                public Object next() {
                    Object part = iterator.next();
                    Exchange newExchange = exchange.copy();
                    if (part instanceof Message) {
                        newExchange.setIn((Message) part);
                    } else {
                        Message in = newExchange.getIn();
                        in.setBody(part);
                    }
                    return createProcessorExchangePair(index++, getProcessors().iterator().next(), newExchange);
                }

                public void remove() {
                    throw new UnsupportedOperationException(""Remove is not supported by this iterator"");
                }
            };
        }
    };
}",,"@SuppressWarnings(""unchecked"")
private Iterable<ProcessorExchangePair> createProcessorExchangePairsIterable(final Exchange exchange, final Object value) {
    final Iterator iterator = ObjectHelper.createIterator(value);
    return new Iterable() {

        public Iterator iterator() {
            return new Iterator() {

                private int index;

                private boolean closed;

                public boolean hasNext() {
                    if (closed) {
                        return false;
                    }
                    boolean answer = iterator.hasNext();
                    if (!answer) {
                                                closed = true;
                                                if (value instanceof Closeable) {
                            IOHelper.close((Closeable) value, value.getClass().getName(), LOG);
                        } else if (value instanceof Scanner) {
                                                        ((Scanner) value).close();
                        }
                    }
                    return answer;
                }

                public Object next() {
                    Object part = iterator.next();
                    Exchange newExchange = exchange.copy();
                    if (part instanceof Message) {
                        newExchange.setIn((Message) part);
                    } else {
                        Message in = newExchange.getIn();
                        in.setBody(part);
                    }
                    return createProcessorExchangePair(index++, getProcessors().iterator().next(), newExchange);
                }

                public void remove() {
                    throw new UnsupportedOperationException(""Remove is not supported by this iterator"");
                }
            };
        }
    };
}",1.2272727272727273,2.186602870813397,0.6,1.5,0.3333333333333333,0.011904761904761871,-0.665398167723749,0.75,-0.02631578947368421,0.24901137025062955
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1364_b481a14c,1,"/**
 * Try to find an entry in the map.
 *
 * @param key the key
 * @param hash the hash
 * @return the entry (might be a non-resident)
 */
Entry<K, V> find(Object key, int hash) {
    int index = hash & mask;
    Entry<K, V> e = entries[index];
    while (e != null && !e.key.equals(key)) {
        e = e.mapNext;
    }
    return e;
}","/**
 * Try to find an entry in the map.
 *
 * @param key the key
 * @param hash the hash
 * @return the entry (might be a non-resident)
 */
","Entry<K, V> find(Object key, int hash) {
    int index = hash & mask;
    Entry<K, V> e = entries[index];
    while (e != null && !e.key.equals(key)) {
        e = e.mapNext;
    }
    return e;
}",-0.2727272727272727,-0.2822966507177035,-0.4,-0.5,0.0,0.3492063492063492,0.2834390415785766,-0.4166666666666667,1.8421052631578947,0.08109357260997099
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-1058_c8fd3c53,3,"@Override
public boolean contains(final org.slf4j.Marker marker) {
    return this.marker.isInstanceOf(marker.getName());
}",,"@Override
public boolean contains(final org.slf4j.Marker marker) {
    return this.marker.isInstanceOf(marker.getName());
}",-0.45454545454545453,-0.6028708133971293,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.8173361522198731,-0.3333333333333333,0.13157894736842105,-0.16279340490885932
wicket,remotes/origin/bugs-dot-jar_WICKET-172_99e22ce4,1,"/**
 *  Get a child component by looking it up with the given path.
 *
 *  @param path
 *             Path to component
 *  @return The component at the path
 */
@Override
public final Component get(final String path) {
    // Reference to this container
    if (path == null || path.trim().equals("""")) {
        return this;
    }
    // Get child's id, if any
    final String id = Strings.firstPathComponent(path, Component.PATH_SEPARATOR);
    // Get child by id
    Component child = children_get(id);
    // optimization.
    if ((child == null) && isTransparentResolver() && (getParent() != null)) {
        // IComponentResolver if they want to be transparent.
        if (path.startsWith(""_"") == false) {
            child = getParent().get(path);
        }
    }
    // Found child?
    final String path2 = Strings.afterFirstPathComponent(path, Component.PATH_SEPARATOR);
    if (child != null) {
        // Recurse on latter part of path
        return child.get(path2);
    }
    return child;
}","/**
 *  Get a child component by looking it up with the given path.
 *
 *  @param path
 *             Path to component
 *  @return The component at the path
 */
","@Override
public final Component get(final String path) {
        if (path == null || path.trim().equals("""")) {
        return this;
    }
        final String id = Strings.firstPathComponent(path, Component.PATH_SEPARATOR);
        Component child = children_get(id);
        if ((child == null) && isTransparentResolver() && (getParent() != null)) {
                if (path.startsWith(""_"") == false) {
            child = getParent().get(path);
        }
    }
        final String path2 = Strings.afterFirstPathComponent(path, Component.PATH_SEPARATOR);
    if (child != null) {
                return child.get(path2);
    }
    return child;
}",0.18181818181818182,0.0334928229665071,0.2,0.0,0.6666666666666666,0.4801587301587301,-0.2050739957716703,0.4166666666666667,0.05263157894736841,0.40382197172709083
wicket,remotes/origin/bugs-dot-jar_WICKET-172_99e22ce4,1,"/**
 *  Traverses all child components of the given class in this container,
 *  calling the visitor's visit method at each one.
 *
 *  @param clazz
 *             The class of child to visit, or null to visit all children
 *  @param visitor
 *             The visitor to call back to
 *  @return The return value from a visitor which halted the traversal, or
 *          null if the entire traversal occurred
 */
public final Object visitChildren(final Class clazz, final IVisitor visitor) {
    if (visitor == null) {
        throw new IllegalArgumentException(""argument visitor may not be null"");
    }
    // Iterate through children of this container
    for (int i = 0; i < children_size(); i++) {
        // Get next child component
        final Component child = children_get(i);
        Object value = null;
        // Is the child of the correct class (or was no class specified)?
        if (clazz == null || clazz.isInstance(child)) {
            // Call visitor
            value = visitor.component(child);
            // If visitor returns a non-null value, it halts the traversal
            if ((value != IVisitor.CONTINUE_TRAVERSAL) && (value != IVisitor.CONTINUE_TRAVERSAL_BUT_DONT_GO_DEEPER)) {
                return value;
            }
        }
        // If child is a container
        if ((child instanceof MarkupContainer) && (value != IVisitor.CONTINUE_TRAVERSAL_BUT_DONT_GO_DEEPER)) {
            // visit the children in the container
            value = ((MarkupContainer<?>) child).visitChildren(clazz, visitor);
            // If visitor returns a non-null value, it halts the traversal
            if ((value != IVisitor.CONTINUE_TRAVERSAL) && (value != IVisitor.CONTINUE_TRAVERSAL_BUT_DONT_GO_DEEPER)) {
                return value;
            }
        }
    }
    return null;
}","/**
 *  Traverses all child components of the given class in this container,
 *  calling the visitor's visit method at each one.
 *
 *  @param clazz
 *             The class of child to visit, or null to visit all children
 *  @param visitor
 *             The visitor to call back to
 *  @return The return value from a visitor which halted the traversal, or
 *          null if the entire traversal occurred
 */
","public final Object visitChildren(final Class clazz, final IVisitor visitor) {
    if (visitor == null) {
        throw new IllegalArgumentException(""argument visitor may not be null"");
    }
        for (int i = 0; i < children_size(); i++) {
                final Component child = children_get(i);
        Object value = null;
                if (clazz == null || clazz.isInstance(child)) {
                        value = visitor.component(child);
                        if ((value != IVisitor.CONTINUE_TRAVERSAL) && (value != IVisitor.CONTINUE_TRAVERSAL_BUT_DONT_GO_DEEPER)) {
                return value;
            }
        }
                if ((child instanceof MarkupContainer) && (value != IVisitor.CONTINUE_TRAVERSAL_BUT_DONT_GO_DEEPER)) {
                        value = ((MarkupContainer<?>) child).visitChildren(clazz, visitor);
                        if ((value != IVisitor.CONTINUE_TRAVERSAL) && (value != IVisitor.CONTINUE_TRAVERSAL_BUT_DONT_GO_DEEPER)) {
                return value;
            }
        }
    }
    return null;
}",0.36363636363636365,0.6889952153110046,0.8,0.5,1.0,1.2043650793650793,-0.3522198731501058,-0.08333333333333333,-0.02631578947368421,1.1834673213349238
Closure,69,2,"/**
 * Visits a CALL node.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 */
private void visitCall(NodeTraversal t, Node n) {
    Node child = n.getFirstChild();
    JSType childType = getJSType(child).restrictByNotNullOrUndefined();
    if (!childType.canBeCalled()) {
        report(t, n, NOT_CALLABLE, childType.toString());
        ensureTyped(t, n);
        return;
    }
    // If it is a function type, then validate parameters.
    if (childType instanceof FunctionType) {
        FunctionType functionType = (FunctionType) childType;
        boolean isExtern = false;
        JSDocInfo functionJSDocInfo = functionType.getJSDocInfo();
        if (functionJSDocInfo != null) {
            String sourceName = functionJSDocInfo.getSourceName();
            CompilerInput functionSource = compiler.getInput(sourceName);
            isExtern = functionSource.isExtern();
        }
        // in an extern.
        if (functionType.isConstructor() && !functionType.isNativeObjectType() && (functionType.getReturnType().isUnknownType() || functionType.getReturnType().isVoidType() || !isExtern)) {
            report(t, n, CONSTRUCTOR_NOT_CALLABLE, childType.toString());
        }
        // Functions with explcit 'this' types must be called in a GETPROP
        // or GETELEM.
        visitParameterList(t, n, functionType);
        ensureTyped(t, n, functionType.getReturnType());
    } else {
        ensureTyped(t, n);
    }
// TODO: Add something to check for calls of RegExp objects, which is not
// supported by IE.  Either say something about the return type or warn
// about the non-portability of the call or both.
}","/**
 * Visits a CALL node.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 */
","private void visitCall(NodeTraversal t, Node n) {
    Node child = n.getFirstChild();
    JSType childType = getJSType(child).restrictByNotNullOrUndefined();
    if (!childType.canBeCalled()) {
        report(t, n, NOT_CALLABLE, childType.toString());
        ensureTyped(t, n);
        return;
    }
        if (childType instanceof FunctionType) {
        FunctionType functionType = (FunctionType) childType;
        boolean isExtern = false;
        JSDocInfo functionJSDocInfo = functionType.getJSDocInfo();
        if (functionJSDocInfo != null) {
            String sourceName = functionJSDocInfo.getSourceName();
            CompilerInput functionSource = compiler.getInput(sourceName);
            isExtern = functionSource.isExtern();
        }
                if (functionType.isConstructor() && !functionType.isNativeObjectType() && (functionType.getReturnType().isUnknownType() || functionType.getReturnType().isVoidType() || !isExtern)) {
            report(t, n, CONSTRUCTOR_NOT_CALLABLE, childType.toString());
        }
                        visitParameterList(t, n, functionType);
        ensureTyped(t, n, functionType.getReturnType());
    } else {
        ensureTyped(t, n);
    }
}",0.5454545454545454,0.12440191387559799,0.2,0.0,0.9166666666666666,0.4583333333333334,-0.45905567300916117,1.4166666666666667,-0.02631578947368421,0.8304489894711363
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2389_8079f7b5,1,"/**
 * Escape a string into the target buffer.
 *
 * @param s      the string to escape
 * @param length the number of characters.
 * @param buff   the target buffer
 */
private static void escape(String s, int length, StringBuilder buff) {
    for (int i = 0; i < length; i++) {
        char c = s.charAt(i);
        switch(c) {
            case '""':
                // quotation mark
                buff.append(""\\\"""");
                break;
            case '\\':
                // backslash
                buff.append(""\\\\"");
                break;
            case '\b':
                // backspace
                buff.append(""\\b"");
                break;
            case '\f':
                // formfeed
                buff.append(""\\f"");
                break;
            case '\n':
                // newline
                buff.append(""\\n"");
                break;
            case '\r':
                // carriage return
                buff.append(""\\r"");
                break;
            case '\t':
                // horizontal tab
                buff.append(""\\t"");
                break;
            default:
                if (c < ' ') {
                    buff.append(""\\u00"");
                    // guaranteed to be 1 or 2 hex digits only
                    buff.append(Character.forDigit(c >>> 4, 16));
                    buff.append(Character.forDigit(c & 15, 16));
                } else {
                    buff.append(c);
                }
        }
    }
}","/**
 * Escape a string into the target buffer.
 *
 * @param s      the string to escape
 * @param length the number of characters.
 * @param buff   the target buffer
 */
","private static void escape(String s, int length, StringBuilder buff) {
    for (int i = 0; i < length; i++) {
        char c = s.charAt(i);
        switch(c) {
            case '""':
                                buff.append(""\\\"""");
                break;
            case '\\':
                                buff.append(""\\\\"");
                break;
            case '\b':
                                buff.append(""\\b"");
                break;
            case '\f':
                                buff.append(""\\f"");
                break;
            case '\n':
                                buff.append(""\\n"");
                break;
            case '\r':
                                buff.append(""\\r"");
                break;
            case '\t':
                                buff.append(""\\t"");
                break;
            default:
                if (c < ' ') {
                    buff.append(""\\u00"");
                                        buff.append(Character.forDigit(c >>> 4, 16));
                    buff.append(Character.forDigit(c & 15, 16));
                } else {
                    buff.append(c);
                }
        }
    }
}",1.0,1.0,2.8,1.0,0.5833333333333334,0.4404761904761904,-0.6493305144467932,0.6666666666666666,-0.02631578947368421,0.5642203050892388
camel,remotes/origin/bugs-dot-jar_CAMEL-4211_4efddb3f,1,"public static Map<String, Object> parseQuery(String uri) throws URISyntaxException {
    // must check for trailing & as the uri.split(""&"") will ignore those
    if (uri != null && uri.endsWith(""&"")) {
        throw new URISyntaxException(uri, ""Invalid uri syntax: Trailing & marker found. "" + ""Check the uri and remove the trailing & marker."");
    }
    try {
        // use a linked map so the parameters is in the same order
        Map<String, Object> rc = new LinkedHashMap<String, Object>();
        if (uri != null) {
            String[] parameters = uri.split(""&"");
            for (String parameter : parameters) {
                int p = parameter.indexOf(""="");
                if (p >= 0) {
                    String name = URLDecoder.decode(parameter.substring(0, p), CHARSET);
                    String value = URLDecoder.decode(parameter.substring(p + 1), CHARSET);
                    rc.put(name, value);
                } else {
                    rc.put(parameter, null);
                }
            }
        }
        return rc;
    } catch (UnsupportedEncodingException e) {
        URISyntaxException se = new URISyntaxException(e.toString(), ""Invalid encoding"");
        se.initCause(e);
        throw se;
    }
}",,"public static Map<String, Object> parseQuery(String uri) throws URISyntaxException {
        if (uri != null && uri.endsWith(""&"")) {
        throw new URISyntaxException(uri, ""Invalid uri syntax: Trailing & marker found. "" + ""Check the uri and remove the trailing & marker."");
    }
    try {
                Map<String, Object> rc = new LinkedHashMap<String, Object>();
        if (uri != null) {
            String[] parameters = uri.split(""&"");
            for (String parameter : parameters) {
                int p = parameter.indexOf(""="");
                if (p >= 0) {
                    String name = URLDecoder.decode(parameter.substring(0, p), CHARSET);
                    String value = URLDecoder.decode(parameter.substring(p + 1), CHARSET);
                    rc.put(name, value);
                } else {
                    rc.put(parameter, null);
                }
            }
        }
        return rc;
    } catch (UnsupportedEncodingException e) {
        URISyntaxException se = new URISyntaxException(e.toString(), ""Invalid encoding"");
        se.initCause(e);
        throw se;
    }
}",0.5454545454545454,1.4880382775119616,0.8,1.0,0.16666666666666666,0.5297619047619048,-0.4683579985905565,0.4166666666666667,-0.02631578947368421,0.8451421425401818
wicket,remotes/origin/bugs-dot-jar_WICKET-3511_4a875f46,1,"/**
 *  Make a copy before returning an item from the cache as resource streams are not thread-safe.
 *
 *  @param key
 *             the cache key
 *  @return the cached File or Url resource stream
 */
private IResourceStream getCopyFromCache(Key key) {
    final IResourceStreamReference orig = cache.get(key);
    if (NullResourceStreamReference.INSTANCE == orig) {
        return null;
    }
    if (orig instanceof UrlResourceStreamReference) {
        UrlResourceStreamReference resourceStreamReference = (UrlResourceStreamReference) orig;
        String url = resourceStreamReference.getReference();
        try {
            return new UrlResourceStream(new URL(url));
        } catch (MalformedURLException e) {
            return null;
        }
    }
    if (orig instanceof FileResourceStreamReference) {
        FileResourceStreamReference resourceStreamReference = (FileResourceStreamReference) orig;
        String absolutePath = resourceStreamReference.getReference();
        return new FileResourceStream(new File(absolutePath));
    }
    return null;
}","/**
 *  Make a copy before returning an item from the cache as resource streams are not thread-safe.
 *
 *  @param key
 *             the cache key
 *  @return the cached File or Url resource stream
 */
","private IResourceStream getCopyFromCache(Key key) {
    final IResourceStreamReference orig = cache.get(key);
    if (NullResourceStreamReference.INSTANCE == orig) {
        return null;
    }
    if (orig instanceof UrlResourceStreamReference) {
        UrlResourceStreamReference resourceStreamReference = (UrlResourceStreamReference) orig;
        String url = resourceStreamReference.getReference();
        try {
            return new UrlResourceStream(new URL(url));
        } catch (MalformedURLException e) {
            return null;
        }
    }
    if (orig instanceof FileResourceStreamReference) {
        FileResourceStreamReference resourceStreamReference = (FileResourceStreamReference) orig;
        String absolutePath = resourceStreamReference.getReference();
        return new FileResourceStream(new File(absolutePath));
    }
    return null;
}",0.3181818181818182,0.09090909090909088,0.2,0.0,-0.08333333333333333,-0.015873015873015886,-0.24707540521494006,-0.25,-0.02631578947368421,0.03011704500267975
camel,remotes/origin/bugs-dot-jar_CAMEL-4474_06a8489a,1,"public FileConsumer createConsumer(Processor processor) throws Exception {
    ObjectHelper.notNull(operations, ""operations"");
    ObjectHelper.notNull(file, ""file"");
    // we assume its a file if the name has a dot in it (eg foo.txt)
    boolean isDirectory = file.isDirectory();
    if (!isDirectory && file.getName().contains(""."")) {
        throw new IllegalArgumentException(""Only directory is supported. Endpoint must be configured with a valid starting directory: "" + file);
    }
    // auto create starting directory if needed
    if (!file.exists() && !isDirectory) {
        if (isAutoCreate()) {
            log.debug(""Creating non existing starting directory: {}"", file);
            boolean absolute = FileUtil.isAbsolute(file);
            operations.buildDirectory(file.getPath(), absolute);
        } else if (isStartingDirectoryMustExist()) {
            throw new FileNotFoundException(""Starting directory does not exist: "" + file);
        }
    }
    FileConsumer result = new FileConsumer(this, processor, operations);
    if (isDelete() && getMove() != null) {
        throw new IllegalArgumentException(""You cannot set both delete=true and move options"");
    }
    // if noop=true then idempotent should also be configured
    if (isNoop() && !isIdempotentSet()) {
        log.info(""Endpoint is configured with noop=true so forcing endpoint to be idempotent as well"");
        setIdempotent(true);
    }
    // if idempotent and no repository set then create a default one
    if (isIdempotentSet() && isIdempotent() && idempotentRepository == null) {
        log.info(""Using default memory based idempotent repository with cache max size: "" + DEFAULT_IDEMPOTENT_CACHE_SIZE);
        idempotentRepository = MemoryIdempotentRepository.memoryIdempotentRepository(DEFAULT_IDEMPOTENT_CACHE_SIZE);
    }
    // set max messages per poll
    result.setMaxMessagesPerPoll(getMaxMessagesPerPoll());
    configureConsumer(result);
    return result;
}",,"public FileConsumer createConsumer(Processor processor) throws Exception {
    ObjectHelper.notNull(operations, ""operations"");
    ObjectHelper.notNull(file, ""file"");
        boolean isDirectory = file.isDirectory();
    if (!isDirectory && file.getName().contains(""."")) {
        throw new IllegalArgumentException(""Only directory is supported. Endpoint must be configured with a valid starting directory: "" + file);
    }
        if (!file.exists() && !isDirectory) {
        if (isAutoCreate()) {
            log.debug(""Creating non existing starting directory: {}"", file);
            boolean absolute = FileUtil.isAbsolute(file);
            operations.buildDirectory(file.getPath(), absolute);
        } else if (isStartingDirectoryMustExist()) {
            throw new FileNotFoundException(""Starting directory does not exist: "" + file);
        }
    }
    FileConsumer result = new FileConsumer(this, processor, operations);
    if (isDelete() && getMove() != null) {
        throw new IllegalArgumentException(""You cannot set both delete=true and move options"");
    }
        if (isNoop() && !isIdempotentSet()) {
        log.info(""Endpoint is configured with noop=true so forcing endpoint to be idempotent as well"");
        setIdempotent(true);
    }
        if (isIdempotentSet() && isIdempotent() && idempotentRepository == null) {
        log.info(""Using default memory based idempotent repository with cache max size: "" + DEFAULT_IDEMPOTENT_CACHE_SIZE);
        idempotentRepository = MemoryIdempotentRepository.memoryIdempotentRepository(DEFAULT_IDEMPOTENT_CACHE_SIZE);
    }
        result.setMaxMessagesPerPoll(getMaxMessagesPerPoll());
    configureConsumer(result);
    return result;
}",0.8181818181818182,0.08133971291866025,1.4,0.5,1.5833333333333333,0.6190476190476191,-0.6070472163495417,1.5833333333333333,-0.02631578947368421,1.1458100655244547
Lang,36,3,"// -----------------------------------------------------------------------
// must handle Long, Float, Integer, Float, Short,
// BigDecimal, BigInteger and Byte
// useful methods:
// Byte.decode(String)
// Byte.valueOf(String,int radix)
// Byte.valueOf(String)
// Double.valueOf(String)
// Float.valueOf(String)
// new Float(String)
// Integer.valueOf(String,int radix)
// Integer.valueOf(String)
// Integer.decode(String)
// Integer.getInteger(String)
// Integer.getInteger(String,int val)
// Integer.getInteger(String,Integer val)
// new Integer(String)
// new Double(String)
// new Byte(String)
// new Long(String)
// Long.getLong(String)
// Long.getLong(String,int)
// Long.getLong(String,Integer)
// Long.valueOf(String,int)
// Long.valueOf(String)
// new Short(String)
// Short.decode(String)
// Short.valueOf(String,int)
// Short.valueOf(String)
// new BigDecimal(String)
// new BigInteger(String)
// new BigInteger(String,int radix)
// Possible inputs:
// 45 45.5 45E7 4.5E7 Hex Oct Binary xxxF xxxD xxxf xxxd
// plus minus everything. Prolly more. A lot are not separable.
/**
 * <p>Turns a string value into a java.lang.Number.</p>
 *
 * <p>First, the value is examined for a type qualifier on the end
 * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts
 * trying to create successively larger types from the type specified
 * until one is found that can represent the value.</p>
 *
 * <p>If a type specifier is not found, it will check for a decimal point
 * and then try successively larger types from <code>Integer</code> to
 * <code>BigInteger</code> and from <code>Float</code> to
 * <code>BigDecimal</code>.</p>
 *
 * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it
 * will be interpreted as a hexadecimal integer.  Values with leading
 * <code>0</code>'s will not be interpreted as octal.</p>
 *
 * <p>Returns <code>null</code> if the string is <code>null</code>.</p>
 *
 * <p>This method does not trim the input string, i.e., strings with leading
 * or trailing spaces will generate NumberFormatExceptions.</p>
 *
 * @param str  String containing a number, may be null
 * @return Number created from the string
 * @throws NumberFormatException if the value cannot be converted
 */
public static Number createNumber(String str) throws NumberFormatException {
    if (str == null) {
        return null;
    }
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }
    if (str.startsWith(""--"")) {
        // a wrong value.
        return null;
    }
    if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
        return createInteger(str);
    }
    char lastChar = str.charAt(str.length() - 1);
    String mant;
    String dec;
    String exp;
    int decPos = str.indexOf('.');
    int expPos = str.indexOf('e') + str.indexOf('E') + 1;
    if (decPos > -1) {
        if (expPos > -1) {
            if (expPos < decPos) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            dec = str.substring(decPos + 1, expPos);
        } else {
            dec = str.substring(decPos + 1);
        }
        mant = str.substring(0, decPos);
    } else {
        if (expPos > -1) {
            mant = str.substring(0, expPos);
        } else {
            mant = str;
        }
        dec = null;
    }
    if (!Character.isDigit(lastChar)) {
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length() - 1);
        } else {
            exp = null;
        }
        // Requesting a specific type..
        String numeric = str.substring(0, str.length() - 1);
        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
        switch(lastChar) {
            case 'l':
            case 'L':
                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                    try {
                        return createLong(numeric);
                    } catch (NumberFormatException nfe) {
                    // Too big for a long
                    }
                    return createBigInteger(numeric);
                }
                throw new NumberFormatException(str + "" is not a valid number."");
            case 'f':
            case 'F':
                try {
                    Float f = NumberUtils.createFloat(numeric);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        // has non-zeros in it, then float does not have the precision we want
                        return f;
                    }
                } catch (NumberFormatException nfe) {
                // ignore the bad number
                }
            // $FALL-THROUGH$
            case 'd':
            case 'D':
                try {
                    Double d = NumberUtils.createDouble(numeric);
                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                // ignore the bad number
                }
                try {
                    return createBigDecimal(numeric);
                } catch (NumberFormatException e) {
                // ignore the bad number
                }
            // $FALL-THROUGH$
            default:
                throw new NumberFormatException(str + "" is not a valid number."");
        }
    } else {
        // small and go from there...
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length());
        } else {
            exp = null;
        }
        if (dec == null && exp == null) {
            // Must be an int,long,bigint
            try {
                return createInteger(str);
            } catch (NumberFormatException nfe) {
            // ignore the bad number
            }
            try {
                return createLong(str);
            } catch (NumberFormatException nfe) {
            // ignore the bad number
            }
            return createBigInteger(str);
        } else {
            // Must be a float,double,BigDec
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            try {
                Float f = createFloat(str);
                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                    return f;
                }
            } catch (NumberFormatException nfe) {
            // ignore the bad number
            }
            try {
                Double d = createDouble(str);
                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                    return d;
                }
            } catch (NumberFormatException nfe) {
            // ignore the bad number
            }
            return createBigDecimal(str);
        }
    }
}","/**
 * <p>Turns a string value into a java.lang.Number.</p>
 *
 * <p>First, the value is examined for a type qualifier on the end
 * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts
 * trying to create successively larger types from the type specified
 * until one is found that can represent the value.</p>
 *
 * <p>If a type specifier is not found, it will check for a decimal point
 * and then try successively larger types from <code>Integer</code> to
 * <code>BigInteger</code> and from <code>Float</code> to
 * <code>BigDecimal</code>.</p>
 *
 * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it
 * will be interpreted as a hexadecimal integer.  Values with leading
 * <code>0</code>'s will not be interpreted as octal.</p>
 *
 * <p>Returns <code>null</code> if the string is <code>null</code>.</p>
 *
 * <p>This method does not trim the input string, i.e., strings with leading
 * or trailing spaces will generate NumberFormatExceptions.</p>
 *
 * @param str  String containing a number, may be null
 * @return Number created from the string
 * @throws NumberFormatException if the value cannot be converted
 */
","public static Number createNumber(String str) throws NumberFormatException {
    if (str == null) {
        return null;
    }
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }
    if (str.startsWith(""--"")) {
                return null;
    }
    if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
        return createInteger(str);
    }
    char lastChar = str.charAt(str.length() - 1);
    String mant;
    String dec;
    String exp;
    int decPos = str.indexOf('.');
    int expPos = str.indexOf('e') + str.indexOf('E') + 1;
    if (decPos > -1) {
        if (expPos > -1) {
            if (expPos < decPos) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            dec = str.substring(decPos + 1, expPos);
        } else {
            dec = str.substring(decPos + 1);
        }
        mant = str.substring(0, decPos);
    } else {
        if (expPos > -1) {
            mant = str.substring(0, expPos);
        } else {
            mant = str;
        }
        dec = null;
    }
    if (!Character.isDigit(lastChar)) {
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length() - 1);
        } else {
            exp = null;
        }
                String numeric = str.substring(0, str.length() - 1);
        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
        switch(lastChar) {
            case 'l':
            case 'L':
                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                    try {
                        return createLong(numeric);
                    } catch (NumberFormatException nfe) {
                                        }
                    return createBigInteger(numeric);
                }
                throw new NumberFormatException(str + "" is not a valid number."");
            case 'f':
            case 'F':
                try {
                    Float f = NumberUtils.createFloat(numeric);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                                                return f;
                    }
                } catch (NumberFormatException nfe) {
                                }
                        case 'd':
            case 'D':
                try {
                    Double d = NumberUtils.createDouble(numeric);
                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                                }
                try {
                    return createBigDecimal(numeric);
                } catch (NumberFormatException e) {
                                }
                        default:
                throw new NumberFormatException(str + "" is not a valid number."");
        }
    } else {
                if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length());
        } else {
            exp = null;
        }
        if (dec == null && exp == null) {
                        try {
                return createInteger(str);
            } catch (NumberFormatException nfe) {
                        }
            try {
                return createLong(str);
            } catch (NumberFormatException nfe) {
                        }
            return createBigInteger(str);
        } else {
                        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            try {
                Float f = createFloat(str);
                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                    return f;
                }
            } catch (NumberFormatException nfe) {
                        }
            try {
                Double d = createDouble(str);
                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                    return d;
                }
            } catch (NumberFormatException nfe) {
                        }
            return createBigDecimal(str);
        }
    }
}",4.681818181818182,1.2057416267942582,6.6,1.5,4.75,2.9880952380952377,-1.550528541226215,3.6666666666666665,-0.02631578947368421,15.336560571221103
wicket,remotes/origin/bugs-dot-jar_WICKET-4610_b19a3d69,1,"/**
 *  Indicate sending of a redirectLocation to a particular named resource. This implementation
 *  just keeps hold of the redirectLocation info and makes it available for query.
 *
 *  @param location
 *             The location to redirectLocation to
 *  @throws IOException
 *              Not used
 */
@Override
public void sendRedirect(String location) throws IOException {
    redirectLocation = location;
}","/**
 *  Indicate sending of a redirectLocation to a particular named resource. This implementation
 *  just keeps hold of the redirectLocation info and makes it available for query.
 *
 *  @param location
 *             The location to redirectLocation to
 *  @throws IOException
 *              Not used
 */
","@Override
public void sendRedirect(String location) throws IOException {
    redirectLocation = location;
}",-0.45454545454545453,-0.6028708133971293,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.8548273431994357,-0.5,2.6052631578947367,-0.16279340490885932
commons-math,remotes/origin/bugs-dot-jar_MATH-309_0596e314,3,"/**
 * Returns a random value from an Exponential distribution with the given
 * mean.
 * <p>
 * <strong>Algorithm Description</strong>: Uses the <a
 * href=""http://www.jesus.ox.ac.uk/~clifford/a5/chap1/node5.html""> Inversion
 * Method</a> to generate exponentially distributed random values from
 * uniform deviates.
 * </p>
 *
 * @param mean
 *            the mean of the distribution
 * @return the random Exponential value
 */
public double nextExponential(double mean) {
    if (mean < 0.0) {
        throw MathRuntimeException.createIllegalArgumentException(""mean must be positive ({0})"", mean);
    }
    final RandomGenerator generator = getRan();
    double unif = generator.nextDouble();
    while (unif == 0.0d) {
        unif = generator.nextDouble();
    }
    return -mean * Math.log(unif);
}","/**
 * Returns a random value from an Exponential distribution with the given
 * mean.
 * <p>
 * <strong>Algorithm Description</strong>: Uses the <a
 * href=""http://www.jesus.ox.ac.uk/~clifford/a5/chap1/node5.html""> Inversion
 * Method</a> to generate exponentially distributed random values from
 * uniform deviates.
 * </p>
 *
 * @param mean
 *            the mean of the distribution
 * @return the random Exponential value
 */
","public double nextExponential(double mean) {
    if (mean < 0.0) {
        throw MathRuntimeException.createIllegalArgumentException(""mean must be positive ({0})"", mean);
    }
    final RandomGenerator generator = getRan();
    double unif = generator.nextDouble();
    while (unif == 0.0d) {
        unif = generator.nextDouble();
    }
    return -mean * Math.log(unif);
}",-0.13636363636363635,-0.2775119617224881,0.0,-0.5,-0.08333333333333333,0.2698412698412699,0.13883016208597593,-0.08333333333333333,0.2631578947368421,0.03487030537738512
camel,remotes/origin/bugs-dot-jar_CAMEL-4011_cbffff59,3,"/**
 * Returns the converted value, or null if the value is null
 */
@Converter
public static Short toShort(Object value) {
    if (value instanceof Short) {
        return (Short) value;
    } else if (value instanceof Number) {
        Number number = (Number) value;
        return number.shortValue();
    } else if (value instanceof String) {
        return Short.valueOf((String) value);
    } else {
        return null;
    }
}","/**
 * Returns the converted value, or null if the value is null
 */
","@Converter
public static Short toShort(Object value) {
    if (value instanceof Short) {
        return (Short) value;
    } else if (value instanceof Number) {
        Number number = (Number) value;
        return number.shortValue();
    } else if (value instanceof String) {
        return Short.valueOf((String) value);
    } else {
        return null;
    }
}",-0.045454545454545456,0.04306220095693773,0.0,0.5,-0.08333333333333333,-0.3650793650793651,0.11092318534179003,-0.3333333333333333,0.2368421052631579,-0.16279340490885932
wicket,remotes/origin/bugs-dot-jar_WICKET-3065_b293b75c,1,"public IRequestHandler mapRequest(Request request) {
    final Url url = request.getUrl();
    if (url.getSegments().size() == 0) {
        final Class<? extends IRequestablePage> homePageClass = getContext().getHomePageClass();
        final PageProvider pageProvider;
        if (url.getQueryParameters().size() > 0) {
            PageParameters pageParameters = extractPageParameters(request, 0, pageParametersEncoder);
            pageProvider = new PageProvider(homePageClass, pageParameters);
        } else {
            pageProvider = new PageProvider(homePageClass);
        }
        return new RenderPageRequestHandler(pageProvider);
    } else {
        return null;
    }
}",,"public IRequestHandler mapRequest(Request request) {
    final Url url = request.getUrl();
    if (url.getSegments().size() == 0) {
        final Class<? extends IRequestablePage> homePageClass = getContext().getHomePageClass();
        final PageProvider pageProvider;
        if (url.getQueryParameters().size() > 0) {
            PageParameters pageParameters = extractPageParameters(request, 0, pageParametersEncoder);
            pageProvider = new PageProvider(homePageClass, pageParameters);
        } else {
            pageProvider = new PageProvider(homePageClass);
        }
        return new RenderPageRequestHandler(pageProvider);
    } else {
        return null;
    }
}",0.09090909090909091,0.325358851674641,-0.2,0.0,-0.08333333333333333,-0.047619047619047616,-0.1024665257223398,0.16666666666666666,-0.02631578947368421,0.0038749906352471873
Math,23,3,"/**
 * {@inheritDoc}
 */
@Override
protected UnivariatePointValuePair doOptimize() {
    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
    final double lo = getMin();
    final double mid = getStartValue();
    final double hi = getMax();
    // Optional additional convergence criteria.
    final ConvergenceChecker<UnivariatePointValuePair> checker = getConvergenceChecker();
    double a;
    double b;
    if (lo < hi) {
        a = lo;
        b = hi;
    } else {
        a = hi;
        b = lo;
    }
    double x = mid;
    double v = x;
    double w = x;
    double d = 0;
    double e = 0;
    double fx = computeObjectiveValue(x);
    if (!isMinim) {
        fx = -fx;
    }
    double fv = fx;
    double fw = fx;
    UnivariatePointValuePair previous = null;
    UnivariatePointValuePair current = new UnivariatePointValuePair(x, isMinim ? fx : -fx);
    // Best point encountered so far (which is the initial guess).
    int iter = 0;
    while (true) {
        final double m = 0.5 * (a + b);
        final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;
        final double tol2 = 2 * tol1;
        // Default stopping criterion.
        final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);
        if (!stop) {
            double p = 0;
            double q = 0;
            double r = 0;
            double u = 0;
            if (FastMath.abs(e) > tol1) {
                // Fit parabola.
                r = (x - w) * (fx - fv);
                q = (x - v) * (fx - fw);
                p = (x - v) * q - (x - w) * r;
                q = 2 * (q - r);
                if (q > 0) {
                    p = -p;
                } else {
                    q = -q;
                }
                r = e;
                e = d;
                if (p > q * (a - x) && p < q * (b - x) && FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {
                    // Parabolic interpolation step.
                    d = p / q;
                    u = x + d;
                    // f must not be evaluated too close to a or b.
                    if (u - a < tol2 || b - u < tol2) {
                        if (x <= m) {
                            d = tol1;
                        } else {
                            d = -tol1;
                        }
                    }
                } else {
                    // Golden section step.
                    if (x < m) {
                        e = b - x;
                    } else {
                        e = a - x;
                    }
                    d = GOLDEN_SECTION * e;
                }
            } else {
                // Golden section step.
                if (x < m) {
                    e = b - x;
                } else {
                    e = a - x;
                }
                d = GOLDEN_SECTION * e;
            }
            // Update by at least ""tol1"".
            if (FastMath.abs(d) < tol1) {
                if (d >= 0) {
                    u = x + tol1;
                } else {
                    u = x - tol1;
                }
            } else {
                u = x + d;
            }
            double fu = computeObjectiveValue(u);
            if (!isMinim) {
                fu = -fu;
            }
            // User-defined convergence checker.
            previous = current;
            current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);
            if (checker != null) {
                if (checker.converged(iter, previous, current)) {
                    return best(current, previous, isMinim);
                }
            }
            // Update a, b, v, w and x.
            if (fu <= fx) {
                if (u < x) {
                    b = x;
                } else {
                    a = x;
                }
                v = w;
                fv = fw;
                w = x;
                fw = fx;
                x = u;
                fx = fu;
            } else {
                if (u < x) {
                    a = u;
                } else {
                    b = u;
                }
                if (fu <= fw || Precision.equals(w, x)) {
                    v = w;
                    fv = fw;
                    w = u;
                    fw = fu;
                } else if (fu <= fv || Precision.equals(v, x) || Precision.equals(v, w)) {
                    v = u;
                    fv = fu;
                }
            }
        } else {
            // Default termination (Brent's criterion).
            return best(current, previous, isMinim);
        }
        ++iter;
    }
}","/**
 * {@inheritDoc}
 */
","@Override
protected UnivariatePointValuePair doOptimize() {
    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
    final double lo = getMin();
    final double mid = getStartValue();
    final double hi = getMax();
        final ConvergenceChecker<UnivariatePointValuePair> checker = getConvergenceChecker();
    double a;
    double b;
    if (lo < hi) {
        a = lo;
        b = hi;
    } else {
        a = hi;
        b = lo;
    }
    double x = mid;
    double v = x;
    double w = x;
    double d = 0;
    double e = 0;
    double fx = computeObjectiveValue(x);
    if (!isMinim) {
        fx = -fx;
    }
    double fv = fx;
    double fw = fx;
    UnivariatePointValuePair previous = null;
    UnivariatePointValuePair current = new UnivariatePointValuePair(x, isMinim ? fx : -fx);
        int iter = 0;
    while (true) {
        final double m = 0.5 * (a + b);
        final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;
        final double tol2 = 2 * tol1;
                final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);
        if (!stop) {
            double p = 0;
            double q = 0;
            double r = 0;
            double u = 0;
            if (FastMath.abs(e) > tol1) {
                                r = (x - w) * (fx - fv);
                q = (x - v) * (fx - fw);
                p = (x - v) * q - (x - w) * r;
                q = 2 * (q - r);
                if (q > 0) {
                    p = -p;
                } else {
                    q = -q;
                }
                r = e;
                e = d;
                if (p > q * (a - x) && p < q * (b - x) && FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {
                                        d = p / q;
                    u = x + d;
                                        if (u - a < tol2 || b - u < tol2) {
                        if (x <= m) {
                            d = tol1;
                        } else {
                            d = -tol1;
                        }
                    }
                } else {
                                        if (x < m) {
                        e = b - x;
                    } else {
                        e = a - x;
                    }
                    d = GOLDEN_SECTION * e;
                }
            } else {
                                if (x < m) {
                    e = b - x;
                } else {
                    e = a - x;
                }
                d = GOLDEN_SECTION * e;
            }
                        if (FastMath.abs(d) < tol1) {
                if (d >= 0) {
                    u = x + tol1;
                } else {
                    u = x - tol1;
                }
            } else {
                u = x + d;
            }
            double fu = computeObjectiveValue(u);
            if (!isMinim) {
                fu = -fu;
            }
                        previous = current;
            current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);
            if (checker != null) {
                if (checker.converged(iter, previous, current)) {
                    return best(current, previous, isMinim);
                }
            }
                        if (fu <= fx) {
                if (u < x) {
                    b = x;
                } else {
                    a = x;
                }
                v = w;
                fv = fw;
                w = x;
                fw = fx;
                x = u;
                fx = fu;
            } else {
                if (u < x) {
                    a = u;
                } else {
                    b = u;
                }
                if (fu <= fw || Precision.equals(w, x)) {
                    v = w;
                    fv = fw;
                    w = u;
                    fw = fu;
                } else if (fu <= fv || Precision.equals(v, x) || Precision.equals(v, w)) {
                    v = u;
                    fv = fu;
                }
            }
        } else {
                        return best(current, previous, isMinim);
        }
        ++iter;
    }
}",5.363636363636363,1.6555023923444978,4.0,2.0,4.833333333333333,6.938492063492063,-1.5626497533474275,1.0833333333333333,-0.02631578947368421,44.626644306518436
wicket,remotes/origin/bugs-dot-jar_WICKET-3511_4a875f46,1,String getReference();,,String getReference();,-0.5909090909090909,-1.4306220095693782,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,1.7424947145877374,-0.5,2.3684210526315788,-0.16279340490885932
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-537_a8493efc,3,"/**
 * Searches for a given value within this index.
 *
 * @param name the property name
 * @param value the property value (null to check for property existence)
 * @return the set of matched paths
 */
public Set<String> find(String name, PropertyValue value) {
    Set<String> paths = Sets.newHashSet();
    NodeState state = getIndexDefinitionNode(name);
    if (state != null && state.getChildNode("":index"") != null) {
        state = state.getChildNode("":index"");
        if (value == null) {
            paths.addAll(store.find(state, null));
        } else {
            paths.addAll(store.find(state, Property2Index.encode(value)));
        }
    } else {
        // No index available, so first check this node for a match
        PropertyState property = root.getProperty(name);
        if (property != null) {
            if (value == null || value.isArray()) {
                // let query engine handle property existence and
                // multi-valued look ups;
                // simply return all nodes that have this property
                paths.add("""");
            } else {
                // does it match any of the values of this property?
                for (int i = 0; i < property.count(); i++) {
                    if (property.getValue(value.getType(), i).equals(value.getValue(value.getType()))) {
                        paths.add("""");
                        // no need to check for more matches in this property
                        break;
                    }
                }
            }
        }
        // ... and then recursively look up from the rest of the tree
        for (ChildNodeEntry entry : root.getChildNodeEntries()) {
            String base = entry.getName();
            Property2IndexLookup lookup = new Property2IndexLookup(entry.getNodeState());
            for (String path : lookup.find(name, value)) {
                if (path.isEmpty()) {
                    paths.add(base);
                } else {
                    paths.add(base + ""/"" + path);
                }
            }
        }
    }
    return paths;
}","/**
 * Searches for a given value within this index.
 *
 * @param name the property name
 * @param value the property value (null to check for property existence)
 * @return the set of matched paths
 */
","public Set<String> find(String name, PropertyValue value) {
    Set<String> paths = Sets.newHashSet();
    NodeState state = getIndexDefinitionNode(name);
    if (state != null && state.getChildNode("":index"") != null) {
        state = state.getChildNode("":index"");
        if (value == null) {
            paths.addAll(store.find(state, null));
        } else {
            paths.addAll(store.find(state, Property2Index.encode(value)));
        }
    } else {
                PropertyState property = root.getProperty(name);
        if (property != null) {
            if (value == null || value.isArray()) {
                                                                paths.add("""");
            } else {
                                for (int i = 0; i < property.count(); i++) {
                    if (property.getValue(value.getType(), i).equals(value.getValue(value.getType()))) {
                        paths.add("""");
                                                break;
                    }
                }
            }
        }
                for (ChildNodeEntry entry : root.getChildNodeEntries()) {
            String base = entry.getName();
            Property2IndexLookup lookup = new Property2IndexLookup(entry.getNodeState());
            for (String path : lookup.find(name, value)) {
                if (path.isEmpty()) {
                    paths.add(base);
                } else {
                    paths.add(base + ""/"" + path);
                }
            }
        }
    }
    return paths;
}",1.0909090909090908,1.5119617224880384,1.4,1.5,1.25,1.5476190476190477,-0.7152924594785058,1.6666666666666667,-0.02631578947368421,2.9522195904865636
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1035_b2ca8baa,1,"@Override
public long count(NodeState indexMeta, Set<String> values, int max) {
    NodeState index = indexMeta.getChildNode(INDEX_CONTENT_NODE_NAME);
    int count = 0;
    if (values == null) {
        PropertyState ec = indexMeta.getProperty(ENTRY_COUNT_PROPERTY_NAME);
        if (ec != null) {
            return ec.getValue(Type.LONG);
        }
        CountingNodeVisitor v = new CountingNodeVisitor(max);
        v.visit(index);
        count = v.getEstimatedCount();
        // ""is not null"" queries typically read more data
        count *= 10;
    } else {
        int size = values.size();
        if (size == 0) {
            return 0;
        }
        max = Math.max(10, max / size);
        int i = 0;
        for (String p : values) {
            if (count > max && i > 3) {
                count = count / size / i;
                break;
            }
            NodeState s = index.getChildNode(p);
            if (s.exists()) {
                CountingNodeVisitor v = new CountingNodeVisitor(max);
                v.visit(s);
                count += v.getEstimatedCount();
            }
            i++;
        }
    }
    return count;
}",,"@Override
public long count(NodeState indexMeta, Set<String> values, int max) {
    NodeState index = indexMeta.getChildNode(INDEX_CONTENT_NODE_NAME);
    int count = 0;
    if (values == null) {
        PropertyState ec = indexMeta.getProperty(ENTRY_COUNT_PROPERTY_NAME);
        if (ec != null) {
            return ec.getValue(Type.LONG);
        }
        CountingNodeVisitor v = new CountingNodeVisitor(max);
        v.visit(index);
        count = v.getEstimatedCount();
                count *= 10;
    } else {
        int size = values.size();
        if (size == 0) {
            return 0;
        }
        max = Math.max(10, max / size);
        int i = 0;
        for (String p : values) {
            if (count > max && i > 3) {
                count = count / size / i;
                break;
            }
            NodeState s = index.getChildNode(p);
            if (s.exists()) {
                CountingNodeVisitor v = new CountingNodeVisitor(max);
                v.visit(s);
                count += v.getEstimatedCount();
            }
            i++;
        }
    }
    return count;
}",1.0,0.7081339712918658,0.8,0.5,0.6666666666666666,1.6785714285714288,-0.6425651867512332,0.4166666666666667,-0.02631578947368421,2.577878436864277
commons-math,remotes/origin/bugs-dot-jar_MATH-618_2123f780,1,"/**
 * Return the sum of this complex number and the given complex number.
 * <p>
 * Uses the definitional formula
 * <pre>
 * (a + bi) + (c + di) = (a+c) + (b+d)i
 * </pre></p>
 * <p>
 * If either this or <code>rhs</code> has a NaN value in either part,
 * {@link #NaN} is returned; otherwise Infinite and NaN values are
 * returned in the parts of the result according to the rules for
 * {@link java.lang.Double} arithmetic.</p>
 *
 * @param rhs the other complex number
 * @return the complex number sum
 * @throws NullArgumentException if <code>rhs</code> is null
 */
public Complex add(Complex rhs) throws NullArgumentException {
    MathUtils.checkNotNull(rhs);
    return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary());
}","/**
 * Return the sum of this complex number and the given complex number.
 * <p>
 * Uses the definitional formula
 * <pre>
 * (a + bi) + (c + di) = (a+c) + (b+d)i
 * </pre></p>
 * <p>
 * If either this or <code>rhs</code> has a NaN value in either part,
 * {@link #NaN} is returned; otherwise Infinite and NaN values are
 * returned in the parts of the result according to the rules for
 * {@link java.lang.Double} arithmetic.</p>
 *
 * @param rhs the other complex number
 * @return the complex number sum
 * @throws NullArgumentException if <code>rhs</code> is null
 */
","public Complex add(Complex rhs) throws NullArgumentException {
    MathUtils.checkNotNull(rhs);
    return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary());
}",-0.45454545454545453,-0.47368421052631593,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.7226215644820295,-0.16666666666666666,1.1578947368421053,-0.16279340490885932
