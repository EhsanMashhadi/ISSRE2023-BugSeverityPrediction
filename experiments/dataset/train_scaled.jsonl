{"project_name": "Closure", "project_version": 144, "label": 2, "code": "/**\n * Builds the function type, and puts it in the registry.\n */\nFunctionType buildAndRegister() {\n    if (returnType == null) {\n        returnType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n    }\n    if (parametersNode == null) {\n        throw new IllegalStateException(\"All Function types must have params and a return type\");\n    }\n    FunctionType fnType;\n    if (isConstructor) {\n        fnType = getOrCreateConstructor();\n    } else if (isInterface) {\n        fnType = typeRegistry.createInterfaceType(fnName, sourceNode);\n        if (scope.isGlobal() && !fnName.isEmpty()) {\n            typeRegistry.declareType(fnName, fnType.getInstanceType());\n        }\n        maybeSetBaseType(fnType);\n    } else {\n        fnType = new FunctionBuilder(typeRegistry).withName(fnName).withSourceNode(sourceNode).withParamsNode(parametersNode).withReturnType(returnType).withTypeOfThis(thisType).withTemplateName(templateTypeName).build();\n        maybeSetBaseType(fnType);\n    }\n    if (implementedInterfaces != null) {\n        fnType.setImplementedInterfaces(implementedInterfaces);\n    }\n    typeRegistry.clearTemplateTypeName();\n    return fnType;\n}", "code_comment": "/**\n * Builds the function type, and puts it in the registry.\n */\n", "code_no_comment": "FunctionType buildAndRegister() {\n    if (returnType == null) {\n        returnType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n    }\n    if (parametersNode == null) {\n        throw new IllegalStateException(\"All Function types must have params and a return type\");\n    }\n    FunctionType fnType;\n    if (isConstructor) {\n        fnType = getOrCreateConstructor();\n    } else if (isInterface) {\n        fnType = typeRegistry.createInterfaceType(fnName, sourceNode);\n        if (scope.isGlobal() && !fnName.isEmpty()) {\n            typeRegistry.declareType(fnName, fnType.getInstanceType());\n        }\n        maybeSetBaseType(fnType);\n    } else {\n        fnType = new FunctionBuilder(typeRegistry).withName(fnName).withSourceNode(sourceNode).withParamsNode(parametersNode).withReturnType(returnType).withTypeOfThis(thisType).withTemplateName(templateTypeName).build();\n        maybeSetBaseType(fnType);\n    }\n    if (implementedInterfaces != null) {\n        fnType.setImplementedInterfaces(implementedInterfaces);\n    }\n    typeRegistry.clearTemplateTypeName();\n    return fnType;\n}", "lc": 0.5454545454545454, "pi": -0.12440191387559821, "ma": 0.8, "nbd": 0.5, "ml": 0.75, "d": 0.28968253968253965, "mi": -0.43199436222692034, "fo": 1.0, "r": -0.02631578947368421, "e": 0.4110141018769845}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3764_48454f4d", "label": 1, "code": "/**\n *  Returns whether or not this behavior is stateless. Most behaviors should either not override\n *  this method or return {@code false} because most behavior are not stateless.\n *\n *  A small subset of behaviors are made specifically to be stateless and as such should override\n *  this method and return {@code true}. One sideeffect of this method is that the behavior id\n *  will be generated eagerly when the behavior is added to the component instead of before\n *  render when a method to create the url is called - this allows for stateless callback urls.\n *\n *  @param component\n *  @return whether or not this behavior is stateless\n */\npublic boolean isStateless(Component component) {\n    return false;\n}", "code_comment": "/**\n *  Returns whether or not this behavior is stateless. Most behaviors should either not override\n *  this method or return {@code false} because most behavior are not stateless.\n *\n *  A small subset of behaviors are made specifically to be stateless and as such should override\n *  this method and return {@code true}. One sideeffect of this method is that the behavior id\n *  will be generated eagerly when the behavior is added to the component instead of before\n *  render when a method to create the url is called - this allows for stateless callback urls.\n *\n *  @param component\n *  @return whether or not this behavior is stateless\n */\n", "code_no_comment": "public boolean isStateless(Component component) {\n    return false;\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.1099365750528538, "fo": -0.5, "r": 2.1052631578947367, "e": -0.16279340490885932}
{"project_name": "Lang", "project_version": 22, "label": 3, "code": "/**\n * <p>Gets the greatest common divisor of the absolute value of\n * two numbers, using the \"binary gcd\" method which avoids\n * division and modulo operations.  See Knuth 4.5.2 algorithm B.\n * This algorithm is due to Josef Stein (1961).</p>\n *\n * @param u  a non-zero number\n * @param v  a non-zero number\n * @return the greatest common divisor, never zero\n */\nprivate static int greatestCommonDivisor(int u, int v) {\n    // if either operand is abs 1, return 1:\n    if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n        return 1;\n    }\n    // make u negative\n    if (u > 0) {\n        u = -u;\n    }\n    // make v negative\n    if (v > 0) {\n        v = -v;\n    }\n    // B1. [Find power of 2]\n    int k = 0;\n    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {\n        // while u and v are both even...\n        // cast out twos.\n        u /= 2;\n        // cast out twos.\n        v /= 2;\n        // cast out twos.\n        k++;\n    }\n    if (k == 31) {\n        throw new ArithmeticException(\"overflow: gcd is 2^31\");\n    }\n    // B2. Initialize: u and v have been divided by 2^k and at least\n    // one is odd.\n    int t = ((u & 1) == 1) ? v : -(u / 2);\n    // t positive: u was even, v is odd (t replaces u)\n    do {\n        // B4/B3: cast out twos from t.\n        while ((t & 1) == 0) {\n            // while t is even..\n            // cast out twos\n            t /= 2;\n        }\n        // B5 [reset max(u,v)]\n        if (t > 0) {\n            u = -t;\n        } else {\n            v = t;\n        }\n        // B6/B3. at this point both u and v should be odd.\n        t = (v - u) / 2;\n    // |u| larger: t positive (replace u)\n    // |v| larger: t negative (replace v)\n    } while (t != 0);\n    // gcd is u*2^k\n    return -u * (1 << k);\n}", "code_comment": "/**\n * <p>Gets the greatest common divisor of the absolute value of\n * two numbers, using the \"binary gcd\" method which avoids\n * division and modulo operations.  See Knuth 4.5.2 algorithm B.\n * This algorithm is due to Josef Stein (1961).</p>\n *\n * @param u  a non-zero number\n * @param v  a non-zero number\n * @return the greatest common divisor, never zero\n */\n", "code_no_comment": "private static int greatestCommonDivisor(int u, int v) {\n        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n        return 1;\n    }\n        if (u > 0) {\n        u = -u;\n    }\n        if (v > 0) {\n        v = -v;\n    }\n        int k = 0;\n    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {\n                        u /= 2;\n                v /= 2;\n                k++;\n    }\n    if (k == 31) {\n        throw new ArithmeticException(\"overflow: gcd is 2^31\");\n    }\n            int t = ((u & 1) == 1) ? v : -(u / 2);\n        do {\n                while ((t & 1) == 0) {\n                                    t /= 2;\n        }\n                if (t > 0) {\n            u = -t;\n        } else {\n            v = t;\n        }\n                t = (v - u) / 2;\n            } while (t != 0);\n        return -u * (1 << k);\n}", "lc": 0.8636363636363636, "pi": -0.00956937799043063, "ma": 1.4, "nbd": 0.0, "ml": 1.0833333333333333, "d": 6.281746031746032, "mi": -0.6070472163495417, "fo": -0.3333333333333333, "r": 0.05263157894736841, "e": 7.865389602531075}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4841_ce172da8", "label": 1, "code": "/**\n *  Returns base url without context or filter mapping.\n *  <p>\n *  Example: if current url is\n *\n *  <pre>\n *  http://localhost:8080/context/filter/mapping/wicket/bookmarkable/com.foo.Page?1&id=2\n *  </pre>\n *\n *  the base url is <em>wicket/bookmarkable/com.foo.Page</em>\n *  </p>\n *\n *  @see org.apache.wicket.request.Request#getClientUrl()\n */\n@Override\npublic Url getClientUrl() {\n    if (errorAttributes != null && !Strings.isEmpty(errorAttributes.getRequestUri())) {\n        String problematicURI = Url.parse(errorAttributes.getRequestUri(), getCharset()).toString();\n        return getContextRelativeUrl(problematicURI, filterPrefix);\n    } else if (forwardAttributes != null && !Strings.isEmpty(forwardAttributes.getRequestUri())) {\n        String forwardURI = Url.parse(forwardAttributes.getRequestUri(), getCharset()).toString();\n        return getContextRelativeUrl(forwardURI, filterPrefix);\n    } else if (!isAjax()) {\n        return getContextRelativeUrl(httpServletRequest.getRequestURI(), filterPrefix);\n    } else {\n        String base = getHeader(HEADER_AJAX_BASE_URL);\n        if (base == null) {\n            base = getRequestParameters().getParameterValue(PARAM_AJAX_BASE_URL).toString(null);\n        }\n        Checks.notNull(base, \"Current ajax request is missing the base url header or parameter\");\n        return setParameters(Url.parse(base, getCharset()));\n    }\n}", "code_comment": "/**\n *  Returns base url without context or filter mapping.\n *  <p>\n *  Example: if current url is\n *\n *  <pre>\n *  http://localhost:8080/context/filter/mapping/wicket/bookmarkable/com.foo.Page?1&id=2\n *  </pre>\n *\n *  the base url is <em>wicket/bookmarkable/com.foo.Page</em>\n *  </p>\n *\n *  @see org.apache.wicket.request.Request#getClientUrl()\n */\n", "code_no_comment": "@Override\npublic Url getClientUrl() {\n    if (errorAttributes != null && !Strings.isEmpty(errorAttributes.getRequestUri())) {\n        String problematicURI = Url.parse(errorAttributes.getRequestUri(), getCharset()).toString();\n        return getContextRelativeUrl(problematicURI, filterPrefix);\n    } else if (forwardAttributes != null && !Strings.isEmpty(forwardAttributes.getRequestUri())) {\n        String forwardURI = Url.parse(forwardAttributes.getRequestUri(), getCharset()).toString();\n        return getContextRelativeUrl(forwardURI, filterPrefix);\n    } else if (!isAjax()) {\n        return getContextRelativeUrl(httpServletRequest.getRequestURI(), filterPrefix);\n    } else {\n        String base = getHeader(HEADER_AJAX_BASE_URL);\n        if (base == null) {\n            base = getRequestParameters().getParameterValue(PARAM_AJAX_BASE_URL).toString(null);\n        }\n        Checks.notNull(base, \"Current ajax request is missing the base url header or parameter\");\n        return setParameters(Url.parse(base, getCharset()));\n    }\n}", "lc": 0.22727272727272727, "pi": 0.13875598086124383, "ma": 0.2, "nbd": 1.0, "ml": 0.75, "d": 0.45436507936507936, "mi": -0.27498238195912594, "fo": 1.5833333333333333, "r": -0.02631578947368421, "e": 0.5851696893207239}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1977_4bfbfcdd", "label": 1, "code": "@Override\npublic Iterator<String> iterator() {\n    PathIterator it = new PathIterator(filter, indexName);\n    if (values == null) {\n        it.setPathContainsValue(true);\n        it.enqueue(getChildNodeEntries(index).iterator());\n    } else {\n        for (String p : values) {\n            NodeState property = index.getChildNode(p);\n            if (property.exists()) {\n                // we have an entry for this value, so use it\n                it.enqueue(Iterators.singletonIterator(new MemoryChildNodeEntry(\"\", property)));\n            }\n        }\n    }\n    return it;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic Iterator<String> iterator() {\n    PathIterator it = new PathIterator(filter, indexName);\n    if (values == null) {\n        it.setPathContainsValue(true);\n        it.enqueue(getChildNodeEntries(index).iterator());\n    } else {\n        for (String p : values) {\n            NodeState property = index.getChildNode(p);\n            if (property.exists()) {\n                                it.enqueue(Iterators.singletonIterator(new MemoryChildNodeEntry(\"\", property)));\n            }\n        }\n    }\n    return it;\n}", "lc": 0.09090909090909091, "pi": 0.799043062200957, "ma": 0.0, "nbd": 0.5, "ml": -0.08333333333333333, "d": -0.0634920634920635, "mi": -0.08724453840732906, "fo": 0.16666666666666666, "r": 0.0, "e": -0.02617981477959695}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-1897_8ee095bf", "label": 1, "code": "/**\n *  @return The component path.\n */\npublic String getComponentPath() {\n    return componentPath;\n}", "code_comment": "/**\n *  @return The component path.\n */\n", "code_no_comment": "public String getComponentPath() {\n    return componentPath;\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.1646229739252991, "fo": -0.5, "r": 2.6052631578947367, "e": -0.16279340490885932}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1977_4bfbfcdd", "label": 1, "code": "@Override\npublic String next() {\n    if (closed) {\n        throw new IllegalStateException(\"This iterator is closed\");\n    }\n    if (!init) {\n        fetchNext();\n        init = true;\n    }\n    String result = currentPath;\n    fetchNext();\n    return result;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic String next() {\n    if (closed) {\n        throw new IllegalStateException(\"This iterator is closed\");\n    }\n    if (!init) {\n        fetchNext();\n        init = true;\n    }\n    String result = currentPath;\n    fetchNext();\n    return result;\n}", "lc": -0.045454545454545456, "pi": -0.1291866028708134, "ma": 0.0, "nbd": -0.5, "ml": -0.08333333333333333, "d": -0.10119047619047619, "mi": 0.15264270613107836, "fo": -0.3333333333333333, "r": 2.0526315789473686, "e": -0.1183266771551898}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-757_76b7413d", "label": 1, "code": "/**\n * Returns the internal storage array.  Note that this method returns\n * a reference to the internal storage array, not a copy, and to correctly\n * address elements of the array, the <code>startIndex</code> is\n * required (available via the {@link #start} method).  This method should\n * only be used in cases where copying the internal array is not practical.\n * The {@link #getElements} method should be used in all other cases.\n *\n * @return the internal storage array used by this object\n * @since 2.0\n * @deprecated As of 3.1.\n */\n@Deprecated\npublic synchronized double[] getInternalValues() {\n    return internalArray;\n}", "code_comment": "/**\n * Returns the internal storage array.  Note that this method returns\n * a reference to the internal storage array, not a copy, and to correctly\n * address elements of the array, the <code>startIndex</code> is\n * required (available via the {@link #start} method).  This method should\n * only be used in cases where copying the internal array is not practical.\n * The {@link #getElements} method should be used in all other cases.\n *\n * @return the internal storage array used by this object\n * @since 2.0\n * @deprecated As of 3.1.\n */\n", "code_no_comment": "@Deprecated\npublic synchronized double[] getInternalValues() {\n    return internalArray;\n}", "lc": -0.45454545454545453, "pi": -0.6028708133971293, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.0332628611698378, "fo": -0.5, "r": 1.1052631578947367, "e": -0.16279340490885932}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-3433_e76d23b0", "label": 3, "code": "@Override\npublic String toString() {\n    return \"\" + expression + \".convertToEvaluatedType(\" + type + \")\";\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic String toString() {\n    return \"\" + expression + \".convertToEvaluatedType(\" + type + \")\";\n}", "lc": -0.45454545454545453, "pi": -0.6028708133971293, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.8246652572233965, "fo": -0.5, "r": 2.3684210526315788, "e": -0.16279340490885932}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5505_6cceff44", "label": 3, "code": "@Override\npublic Property resolveProperty(FormComponent<?> component) {\n    IModel<?> model = component.getModel();\n    while (true) {\n        if (model == null) {\n            return null;\n        }\n        if (model instanceof IPropertyReflectionAwareModel) {\n            break;\n        }\n        if (model instanceof IWrapModel<?>) {\n            model = ((IWrapModel<?>) model).getWrappedModel();\n            continue;\n        }\n        return null;\n    }\n    IPropertyReflectionAwareModel<?> delegate = (IPropertyReflectionAwareModel<?>) model;\n    Field field = delegate.getPropertyField();\n    if (field != null) {\n        return new Property(field.getDeclaringClass(), field.getName());\n    }\n    Method getter = delegate.getPropertyGetter();\n    if (getter != null) {\n        String name = getter.getName().substring(3, 4).toLowerCase() + getter.getName().substring(4);\n        return new Property(getter.getDeclaringClass(), name);\n    }\n    return null;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic Property resolveProperty(FormComponent<?> component) {\n    IModel<?> model = component.getModel();\n    while (true) {\n        if (model == null) {\n            return null;\n        }\n        if (model instanceof IPropertyReflectionAwareModel) {\n            break;\n        }\n        if (model instanceof IWrapModel<?>) {\n            model = ((IWrapModel<?>) model).getWrappedModel();\n            continue;\n        }\n        return null;\n    }\n    IPropertyReflectionAwareModel<?> delegate = (IPropertyReflectionAwareModel<?>) model;\n    Field field = delegate.getPropertyField();\n    if (field != null) {\n        return new Property(field.getDeclaringClass(), field.getName());\n    }\n    Method getter = delegate.getPropertyGetter();\n    if (getter != null) {\n        String name = getter.getName().substring(3, 4).toLowerCase() + getter.getName().substring(4);\n        return new Property(getter.getDeclaringClass(), name);\n    }\n    return null;\n}", "lc": 0.6363636363636364, "pi": 0.22488038277511951, "ma": 1.0, "nbd": 0.0, "ml": 0.3333333333333333, "d": 0.47023809523809523, "mi": -0.464411557434813, "fo": 0.5, "r": -0.02631578947368421, "e": 0.5318511090748776}
{"project_name": "maven", "project_version": "remotes/origin/bugs-dot-jar_MNG-1797_5d99b35c", "label": 1, "code": "/**\n * @todo desperately needs refactoring. It's just here because it's implementation is maven-project specific\n */\npublic static Set createArtifacts(ArtifactFactory artifactFactory, List dependencies, String inheritedScope, ArtifactFilter dependencyFilter, MavenProject project) throws InvalidDependencyVersionException {\n    Set projectArtifacts = new LinkedHashSet(dependencies.size());\n    for (Iterator i = dependencies.iterator(); i.hasNext(); ) {\n        Dependency d = (Dependency) i.next();\n        String scope = d.getScope();\n        if (StringUtils.isEmpty(scope)) {\n            scope = Artifact.SCOPE_COMPILE;\n            d.setScope(scope);\n        }\n        VersionRange versionRange;\n        try {\n            versionRange = VersionRange.createFromVersionSpec(d.getVersion());\n        } catch (InvalidVersionSpecificationException e) {\n            throw new InvalidDependencyVersionException(\"Unable to parse version '\" + d.getVersion() + \"' for dependency '\" + d.getManagementKey() + \"': \" + e.getMessage(), e);\n        }\n        Artifact artifact = artifactFactory.createDependencyArtifact(d.getGroupId(), d.getArtifactId(), versionRange, d.getType(), d.getClassifier(), scope, inheritedScope, d.isOptional());\n        if (Artifact.SCOPE_SYSTEM.equals(scope)) {\n            artifact.setFile(new File(d.getSystemPath()));\n        }\n        if (artifact != null && (dependencyFilter == null || dependencyFilter.include(artifact))) {\n            if (d.getExclusions() != null && !d.getExclusions().isEmpty()) {\n                List exclusions = new ArrayList();\n                for (Iterator j = d.getExclusions().iterator(); j.hasNext(); ) {\n                    Exclusion e = (Exclusion) j.next();\n                    exclusions.add(e.getGroupId() + \":\" + e.getArtifactId());\n                }\n                ArtifactFilter newFilter = new ExcludesArtifactFilter(exclusions);\n                if (dependencyFilter != null) {\n                    AndArtifactFilter filter = new AndArtifactFilter();\n                    filter.add(dependencyFilter);\n                    filter.add(newFilter);\n                    dependencyFilter = filter;\n                } else {\n                    dependencyFilter = newFilter;\n                }\n            }\n            artifact.setDependencyFilter(dependencyFilter);\n            if (project != null) {\n                artifact = project.replaceWithActiveArtifact(artifact);\n            }\n            projectArtifacts.add(artifact);\n        }\n    }\n    return projectArtifacts;\n}", "code_comment": "/**\n * @todo desperately needs refactoring. It's just here because it's implementation is maven-project specific\n */\n", "code_no_comment": "public static Set createArtifacts(ArtifactFactory artifactFactory, List dependencies, String inheritedScope, ArtifactFilter dependencyFilter, MavenProject project) throws InvalidDependencyVersionException {\n    Set projectArtifacts = new LinkedHashSet(dependencies.size());\n    for (Iterator i = dependencies.iterator(); i.hasNext(); ) {\n        Dependency d = (Dependency) i.next();\n        String scope = d.getScope();\n        if (StringUtils.isEmpty(scope)) {\n            scope = Artifact.SCOPE_COMPILE;\n            d.setScope(scope);\n        }\n        VersionRange versionRange;\n        try {\n            versionRange = VersionRange.createFromVersionSpec(d.getVersion());\n        } catch (InvalidVersionSpecificationException e) {\n            throw new InvalidDependencyVersionException(\"Unable to parse version '\" + d.getVersion() + \"' for dependency '\" + d.getManagementKey() + \"': \" + e.getMessage(), e);\n        }\n        Artifact artifact = artifactFactory.createDependencyArtifact(d.getGroupId(), d.getArtifactId(), versionRange, d.getType(), d.getClassifier(), scope, inheritedScope, d.isOptional());\n        if (Artifact.SCOPE_SYSTEM.equals(scope)) {\n            artifact.setFile(new File(d.getSystemPath()));\n        }\n        if (artifact != null && (dependencyFilter == null || dependencyFilter.include(artifact))) {\n            if (d.getExclusions() != null && !d.getExclusions().isEmpty()) {\n                List exclusions = new ArrayList();\n                for (Iterator j = d.getExclusions().iterator(); j.hasNext(); ) {\n                    Exclusion e = (Exclusion) j.next();\n                    exclusions.add(e.getGroupId() + \":\" + e.getArtifactId());\n                }\n                ArtifactFilter newFilter = new ExcludesArtifactFilter(exclusions);\n                if (dependencyFilter != null) {\n                    AndArtifactFilter filter = new AndArtifactFilter();\n                    filter.add(dependencyFilter);\n                    filter.add(newFilter);\n                    dependencyFilter = filter;\n                } else {\n                    dependencyFilter = newFilter;\n                }\n            }\n            artifact.setDependencyFilter(dependencyFilter);\n            if (project != null) {\n                artifact = project.replaceWithActiveArtifact(artifact);\n            }\n            projectArtifacts.add(artifact);\n        }\n    }\n    return projectArtifacts;\n}", "lc": 1.4090909090909092, "pi": 1.1578947368421053, "ma": 1.4, "nbd": 1.0, "ml": 1.4166666666666667, "d": 0.9801587301587302, "mi": -0.8635658914728681, "fo": 2.5833333333333335, "r": -0.02631578947368421, "e": 3.393004961878252}
{"project_name": "Math", "project_version": 62, "label": 1, "code": "/**\n * {@inheritDoc}\n */\npublic UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal, final double min, final double max, final double startValue) throws FunctionEvaluationException {\n    optima = new UnivariateRealPointValuePair[starts];\n    totalEvaluations = 0;\n    // Multi-start loop.\n    for (int i = 0; i < starts; ++i) {\n        try {\n            final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);\n            final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min);\n            optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2));\n        } catch (FunctionEvaluationException fee) {\n            optima[i] = null;\n        } catch (ConvergenceException ce) {\n            optima[i] = null;\n        }\n        final int usedEvaluations = optimizer.getEvaluations();\n        optimizer.setMaxEvaluations(optimizer.getMaxEvaluations() - usedEvaluations);\n        totalEvaluations += usedEvaluations;\n    }\n    sortPairs(goal);\n    if (optima[0] == null) {\n        throw new ConvergenceException(LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT, starts);\n    }\n    // Return the point with the best objective function value.\n    return optima[0];\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal, final double min, final double max, final double startValue) throws FunctionEvaluationException {\n    optima = new UnivariateRealPointValuePair[starts];\n    totalEvaluations = 0;\n        for (int i = 0; i < starts; ++i) {\n        try {\n            final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);\n            final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min);\n            optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2));\n        } catch (FunctionEvaluationException fee) {\n            optima[i] = null;\n        } catch (ConvergenceException ce) {\n            optima[i] = null;\n        }\n        final int usedEvaluations = optimizer.getEvaluations();\n        optimizer.setMaxEvaluations(optimizer.getMaxEvaluations() - usedEvaluations);\n        totalEvaluations += usedEvaluations;\n    }\n    sortPairs(goal);\n    if (optima[0] == null) {\n        throw new ConvergenceException(LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT, starts);\n    }\n        return optima[0];\n}", "lc": 0.4090909090909091, "pi": 0.30143540669856456, "ma": 0.8, "nbd": 0.0, "ml": 0.08333333333333333, "d": 1.6547619047619047, "mi": -0.435658914728682, "fo": 0.25, "r": -0.02631578947368421, "e": 2.503024959227307}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3309_debca73b", "label": 1, "code": "/**\n *  @see javax.swing.event.TreeModelListener#treeNodesInserted(javax.swing.event.TreeModelEvent)\n */\npublic final void treeNodesInserted(TreeModelEvent e) {\n    if (dirtyAll) {\n        return;\n    }\n    // get the parent node of inserted nodes\n    Object parentNode = e.getTreePath().getLastPathComponent();\n    TreeItem parentItem = nodeToItemMap.get(parentNode);\n    if (parentItem != null && isNodeVisible(parentNode)) {\n        List<?> eventChildren = Arrays.asList(e.getChildren());\n        // parentNode was a leaf before this insertion event only if every one of\n        // its current children is in the event's list of children\n        boolean wasLeaf = true;\n        int nodeChildCount = getChildCount(parentNode);\n        for (int i = 0; wasLeaf && i < nodeChildCount; i++) {\n            wasLeaf = eventChildren.contains(getChildAt(parentNode, i));\n        }\n        if (wasLeaf) {\n            // parentNode now has children for the first time, so we need to invalidate\n            // grandparent so that parentNode's junctionLink gets rebuilt with a plus/minus link\n            Object grandparentNode = getParentNode(parentNode);\n            invalidateNodeWithChildren(grandparentNode);\n            getTreeState().expandNode(parentNode);\n        } else {\n            if (isNodeExpanded(parentNode)) {\n                List<TreeItem> itemChildren = parentItem.getChildren();\n                int childLevel = parentItem.getLevel() + 1;\n                final int[] childIndices = e.getChildIndices();\n                for (int i = 0; i < eventChildren.size(); ++i) {\n                    TreeItem item = newTreeItem(parentItem, eventChildren.get(i), childLevel);\n                    itemContainer.add(item);\n                    if (itemChildren != null) {\n                        itemChildren.add(childIndices[i], item);\n                        markTheLastButOneChildDirty(parentItem, item);\n                    }\n                    if (!dirtyItems.contains(item)) {\n                        dirtyItems.add(item);\n                    }\n                    if (!dirtyItemsCreateDOM.contains(item) && !item.hasParentWithChildrenMarkedToRecreation()) {\n                        dirtyItemsCreateDOM.add(item);\n                    }\n                }\n            }\n        }\n    }\n}", "code_comment": "/**\n *  @see javax.swing.event.TreeModelListener#treeNodesInserted(javax.swing.event.TreeModelEvent)\n */\n", "code_no_comment": "public final void treeNodesInserted(TreeModelEvent e) {\n    if (dirtyAll) {\n        return;\n    }\n        Object parentNode = e.getTreePath().getLastPathComponent();\n    TreeItem parentItem = nodeToItemMap.get(parentNode);\n    if (parentItem != null && isNodeVisible(parentNode)) {\n        List<?> eventChildren = Arrays.asList(e.getChildren());\n                        boolean wasLeaf = true;\n        int nodeChildCount = getChildCount(parentNode);\n        for (int i = 0; wasLeaf && i < nodeChildCount; i++) {\n            wasLeaf = eventChildren.contains(getChildAt(parentNode, i));\n        }\n        if (wasLeaf) {\n                                    Object grandparentNode = getParentNode(parentNode);\n            invalidateNodeWithChildren(grandparentNode);\n            getTreeState().expandNode(parentNode);\n        } else {\n            if (isNodeExpanded(parentNode)) {\n                List<TreeItem> itemChildren = parentItem.getChildren();\n                int childLevel = parentItem.getLevel() + 1;\n                final int[] childIndices = e.getChildIndices();\n                for (int i = 0; i < eventChildren.size(); ++i) {\n                    TreeItem item = newTreeItem(parentItem, eventChildren.get(i), childLevel);\n                    itemContainer.add(item);\n                    if (itemChildren != null) {\n                        itemChildren.add(childIndices[i], item);\n                        markTheLastButOneChildDirty(parentItem, item);\n                    }\n                    if (!dirtyItems.contains(item)) {\n                        dirtyItems.add(item);\n                    }\n                    if (!dirtyItemsCreateDOM.contains(item) && !item.hasParentWithChildrenMarkedToRecreation()) {\n                        dirtyItemsCreateDOM.add(item);\n                    }\n                }\n            }\n        }\n    }\n}", "lc": 1.1818181818181819, "pi": 1.92822966507177, "ma": 1.2, "nbd": 1.5, "ml": 1.75, "d": 0.9345238095238095, "mi": -0.746582100070472, "fo": 1.8333333333333333, "r": -0.02631578947368421, "e": 2.169978619548993}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-2962_023be574", "label": 0, "code": "@Override\npublic void readFields(DataInput in) throws IOException {\n    range.readFields(in);\n    int numLocs = in.readInt();\n    locations = new String[numLocs];\n    for (int i = 0; i < numLocs; ++i) locations[i] = in.readUTF();\n    if (in.readBoolean()) {\n        isolatedScan = in.readBoolean();\n    }\n    if (in.readBoolean()) {\n        offline = in.readBoolean();\n    }\n    if (in.readBoolean()) {\n        localIterators = in.readBoolean();\n    }\n    if (in.readBoolean()) {\n        mockInstance = in.readBoolean();\n    }\n    if (in.readBoolean()) {\n        int numColumns = in.readInt();\n        List<String> columns = new ArrayList<String>(numColumns);\n        for (int i = 0; i < numColumns; i++) {\n            columns.add(in.readUTF());\n        }\n        fetchedColumns = InputConfigurator.deserializeFetchedColumns(columns);\n    }\n    if (in.readBoolean()) {\n        String strAuths = in.readUTF();\n        auths = new Authorizations(strAuths.getBytes(Charset.forName(\"UTF-8\")));\n    }\n    if (in.readBoolean()) {\n        principal = in.readUTF();\n    }\n    if (in.readBoolean()) {\n        String tokenClass = in.readUTF();\n        byte[] base64TokenBytes = in.readUTF().getBytes(Charset.forName(\"UTF-8\"));\n        byte[] tokenBytes = Base64.decodeBase64(base64TokenBytes);\n        try {\n            token = CredentialHelper.extractToken(tokenClass, tokenBytes);\n        } catch (AccumuloSecurityException e) {\n            throw new IOException(e);\n        }\n    }\n    if (in.readBoolean()) {\n        instanceName = in.readUTF();\n    }\n    if (in.readBoolean()) {\n        zooKeepers = in.readUTF();\n    }\n    if (in.readBoolean()) {\n        level = Level.toLevel(in.readInt());\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void readFields(DataInput in) throws IOException {\n    range.readFields(in);\n    int numLocs = in.readInt();\n    locations = new String[numLocs];\n    for (int i = 0; i < numLocs; ++i) locations[i] = in.readUTF();\n    if (in.readBoolean()) {\n        isolatedScan = in.readBoolean();\n    }\n    if (in.readBoolean()) {\n        offline = in.readBoolean();\n    }\n    if (in.readBoolean()) {\n        localIterators = in.readBoolean();\n    }\n    if (in.readBoolean()) {\n        mockInstance = in.readBoolean();\n    }\n    if (in.readBoolean()) {\n        int numColumns = in.readInt();\n        List<String> columns = new ArrayList<String>(numColumns);\n        for (int i = 0; i < numColumns; i++) {\n            columns.add(in.readUTF());\n        }\n        fetchedColumns = InputConfigurator.deserializeFetchedColumns(columns);\n    }\n    if (in.readBoolean()) {\n        String strAuths = in.readUTF();\n        auths = new Authorizations(strAuths.getBytes(Charset.forName(\"UTF-8\")));\n    }\n    if (in.readBoolean()) {\n        principal = in.readUTF();\n    }\n    if (in.readBoolean()) {\n        String tokenClass = in.readUTF();\n        byte[] base64TokenBytes = in.readUTF().getBytes(Charset.forName(\"UTF-8\"));\n        byte[] tokenBytes = Base64.decodeBase64(base64TokenBytes);\n        try {\n            token = CredentialHelper.extractToken(tokenClass, tokenBytes);\n        } catch (AccumuloSecurityException e) {\n            throw new IOException(e);\n        }\n    }\n    if (in.readBoolean()) {\n        instanceName = in.readUTF();\n    }\n    if (in.readBoolean()) {\n        zooKeepers = in.readUTF();\n    }\n    if (in.readBoolean()) {\n        level = Level.toLevel(in.readInt());\n    }\n}", "lc": 1.7727272727272727, "pi": -0.11483253588516758, "ma": 2.4, "nbd": 0.0, "ml": 1.0, "d": 0.14682539682539683, "mi": -0.9343199436222689, "fo": 2.5, "r": -0.02631578947368421, "e": 0.8932510387671949}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-757_76b7413d", "label": 1, "code": "/**\n * Expands the internal storage array to the specified size.\n *\n * @param size Size of the new internal storage array.\n */\nprivate synchronized void expandTo(int size) {\n    final double[] tempArray = new double[size];\n    // Copy and swap\n    System.arraycopy(internalArray, 0, tempArray, 0, internalArray.length);\n    internalArray = tempArray;\n}", "code_comment": "/**\n * Expands the internal storage array to the specified size.\n *\n * @param size Size of the new internal storage array.\n */\n", "code_no_comment": "private synchronized void expandTo(int size) {\n    final double[] tempArray = new double[size];\n        System.arraycopy(internalArray, 0, tempArray, 0, internalArray.length);\n    internalArray = tempArray;\n}", "lc": -0.4090909090909091, "pi": -0.49282296650717716, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.6448202959830865, "fo": -0.4166666666666667, "r": 2.263157894736842, "e": -0.16279340490885932}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-4138_50db442b", "label": 1, "code": "/**\n * Starts a full major compaction of the tablets in the range (start, end]. The compaction is preformed even for tablets that have only one file.\n *\n * @param tableName\n *          the table to compact\n * @param start\n *          first tablet to be compacted contains the row after this row, null means the first tablet in table\n * @param end\n *          last tablet to be merged contains this row, null means the last tablet in table\n * @param flush\n *          when true, table memory is flushed before compaction starts\n * @param wait\n *          when true, the call will not return until compactions are finished\n */\nvoid compact(String tableName, Text start, Text end, boolean flush, boolean wait) throws AccumuloSecurityException, TableNotFoundException, AccumuloException;", "code_comment": "/**\n * Starts a full major compaction of the tablets in the range (start, end]. The compaction is preformed even for tablets that have only one file.\n *\n * @param tableName\n *          the table to compact\n * @param start\n *          first tablet to be compacted contains the row after this row, null means the first tablet in table\n * @param end\n *          last tablet to be merged contains this row, null means the last tablet in table\n * @param flush\n *          when true, table memory is flushed before compaction starts\n * @param wait\n *          when true, the call will not return until compactions are finished\n */\n", "code_no_comment": "void compact(String tableName, Text start, Text end, boolean flush, boolean wait) throws AccumuloSecurityException, TableNotFoundException, AccumuloException;", "lc": -0.5909090909090909, "pi": -1.4306220095693782, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.4078928823114865, "fo": -0.5, "r": 0.8421052631578947, "e": -0.16279340490885932}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2047_a0a495f0", "label": 0, "code": "@SuppressWarnings(\"deprecation\")\nprivate void copyPrivileges(NodeBuilder root) throws RepositoryException {\n    PrivilegeRegistry registry = source.getPrivilegeRegistry();\n    NodeBuilder privileges = root.child(JCR_SYSTEM).child(REP_PRIVILEGES);\n    privileges.setProperty(JCR_PRIMARYTYPE, NT_REP_PRIVILEGES, NAME);\n    PrivilegeBits next = PrivilegeBits.NEXT_AFTER_BUILT_INS;\n    logger.info(\"Copying registered privileges\");\n    for (Privilege privilege : registry.getRegisteredPrivileges()) {\n        String name = privilege.getName();\n        NodeBuilder def = privileges.child(name);\n        def.setProperty(JCR_PRIMARYTYPE, NT_REP_PRIVILEGE, NAME);\n        if (privilege.isAbstract()) {\n            def.setProperty(REP_IS_ABSTRACT, true);\n        }\n        Privilege[] aggregate = privilege.getDeclaredAggregatePrivileges();\n        if (aggregate.length > 0) {\n            List<String> names = newArrayListWithCapacity(aggregate.length);\n            for (Privilege p : aggregate) {\n                names.add(p.getName());\n            }\n            def.setProperty(REP_AGGREGATES, names, NAMES);\n        }\n        PrivilegeBits bits = PrivilegeBits.BUILT_IN.get(name);\n        if (bits != null) {\n            def.setProperty(bits.asPropertyState(REP_BITS));\n        } else if (aggregate.length == 0) {\n            bits = next;\n            next = next.nextBits();\n            def.setProperty(bits.asPropertyState(REP_BITS));\n        }\n    }\n    privileges.setProperty(next.asPropertyState(REP_NEXT));\n    // resolve privilege bits also for all aggregates\n    for (String name : privileges.getChildNodeNames()) {\n        resolvePrivilegeBits(privileges, name);\n    }\n}", "code_comment": NaN, "code_no_comment": "@SuppressWarnings(\"deprecation\")\nprivate void copyPrivileges(NodeBuilder root) throws RepositoryException {\n    PrivilegeRegistry registry = source.getPrivilegeRegistry();\n    NodeBuilder privileges = root.child(JCR_SYSTEM).child(REP_PRIVILEGES);\n    privileges.setProperty(JCR_PRIMARYTYPE, NT_REP_PRIVILEGES, NAME);\n    PrivilegeBits next = PrivilegeBits.NEXT_AFTER_BUILT_INS;\n    logger.info(\"Copying registered privileges\");\n    for (Privilege privilege : registry.getRegisteredPrivileges()) {\n        String name = privilege.getName();\n        NodeBuilder def = privileges.child(name);\n        def.setProperty(JCR_PRIMARYTYPE, NT_REP_PRIVILEGE, NAME);\n        if (privilege.isAbstract()) {\n            def.setProperty(REP_IS_ABSTRACT, true);\n        }\n        Privilege[] aggregate = privilege.getDeclaredAggregatePrivileges();\n        if (aggregate.length > 0) {\n            List<String> names = newArrayListWithCapacity(aggregate.length);\n            for (Privilege p : aggregate) {\n                names.add(p.getName());\n            }\n            def.setProperty(REP_AGGREGATES, names, NAMES);\n        }\n        PrivilegeBits bits = PrivilegeBits.BUILT_IN.get(name);\n        if (bits != null) {\n            def.setProperty(bits.asPropertyState(REP_BITS));\n        } else if (aggregate.length == 0) {\n            bits = next;\n            next = next.nextBits();\n            def.setProperty(bits.asPropertyState(REP_BITS));\n        }\n    }\n    privileges.setProperty(next.asPropertyState(REP_NEXT));\n        for (String name : privileges.getChildNodeNames()) {\n        resolvePrivilegeBits(privileges, name);\n    }\n}", "lc": 1.0, "pi": 0.4354066985645932, "ma": 0.8, "nbd": 0.5, "ml": 0.16666666666666666, "d": 0.45039682539682546, "mi": -0.6851303735024662, "fo": 1.6666666666666667, "r": -0.02631578947368421, "e": 1.29644369910617}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-3052_8dc70f2e", "label": 1, "code": "@Override\nprotected List<OperatorDescriptorSingle> getPossibleProperties() {\n    return this.operator;\n}", "code_comment": NaN, "code_no_comment": "@Override\nprotected List<OperatorDescriptorSingle> getPossibleProperties() {\n    return this.operator;\n}", "lc": -0.45454545454545453, "pi": -0.6028708133971293, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.9362931642001409, "fo": -0.5, "r": 0.9210526315789473, "e": -0.16279340490885932}
{"project_name": "Cli", "project_version": 29, "label": 1, "code": "/**\n * Remove the leading and trailing quotes from <code>str</code>.\n * E.g. if str is '\"one two\"', then 'one two' is returned.\n *\n * @param str The string from which the leading and trailing quotes\n * should be removed.\n *\n * @return The string without the leading and trailing quotes.\n */\nstatic String stripLeadingAndTrailingQuotes(String str) {\n    if (str.startsWith(\"\\\"\")) {\n        str = str.substring(1, str.length());\n    }\n    int length = str.length();\n    if (str.endsWith(\"\\\"\")) {\n        str = str.substring(0, length - 1);\n    }\n    return str;\n}", "code_comment": "/**\n * Remove the leading and trailing quotes from <code>str</code>.\n * E.g. if str is '\"one two\"', then 'one two' is returned.\n *\n * @param str The string from which the leading and trailing quotes\n * should be removed.\n *\n * @return The string without the leading and trailing quotes.\n */\n", "code_no_comment": "static String stripLeadingAndTrailingQuotes(String str) {\n    if (str.startsWith(\"\\\"\")) {\n        str = str.substring(1, str.length());\n    }\n    int length = str.length();\n    if (str.endsWith(\"\\\"\")) {\n        str = str.substring(0, length - 1);\n    }\n    return str;\n}", "lc": -0.18181818181818182, "pi": -0.2200956937799045, "ma": -0.2, "nbd": -0.5, "ml": -0.08333333333333333, "d": 0.12103174603174605, "mi": 0.2115574348132486, "fo": 0.0, "r": 0.0, "e": -0.03298006604311821}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1199_813109d7", "label": 3, "code": "public void recv_setTableProperty() throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException {\n    setTableProperty_result result = new setTableProperty_result();\n    receiveBase(result, \"setTableProperty\");\n    if (result.ouch1 != null) {\n        throw result.ouch1;\n    }\n    if (result.ouch2 != null) {\n        throw result.ouch2;\n    }\n    return;\n}", "code_comment": NaN, "code_no_comment": "public void recv_setTableProperty() throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException {\n    setTableProperty_result result = new setTableProperty_result();\n    receiveBase(result, \"setTableProperty\");\n    if (result.ouch1 != null) {\n        throw result.ouch1;\n    }\n    if (result.ouch2 != null) {\n        throw result.ouch2;\n    }\n    return;\n}", "lc": -0.13636363636363635, "pi": -0.2775119617224881, "ma": 0.2, "nbd": -0.5, "ml": -0.08333333333333333, "d": -0.047619047619047616, "mi": 0.16053558844256535, "fo": -0.4166666666666667, "r": -0.02631578947368421, "e": -0.08138402401987055}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-4388_f39bc60d", "label": 1, "code": "@Override\npublic boolean process(Exchange exchange, AsyncCallback callback) {\n    String msg = expression.evaluate(exchange, String.class);\n    logger.log(msg);\n    return true;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean process(Exchange exchange, AsyncCallback callback) {\n    String msg = expression.evaluate(exchange, String.class);\n    logger.log(msg);\n    return true;\n}", "lc": -0.36363636363636365, "pi": -0.47368421052631593, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.5295278365045805, "fo": -0.3333333333333333, "r": 0.42105263157894735, "e": -0.16279340490885932}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4290_e1953357", "label": 1, "code": "@Override\npublic Url mapHandler(IRequestHandler requestHandler) {\n    Url url = super.mapHandler(requestHandler);\n    if (url == null && requestHandler instanceof ListenerInterfaceRequestHandler) {\n        ListenerInterfaceRequestHandler handler = (ListenerInterfaceRequestHandler) requestHandler;\n        IRequestablePage page = handler.getPage();\n        if (checkPageInstance(page)) {\n            String componentPath = handler.getComponentPath();\n            RequestListenerInterface listenerInterface = handler.getListenerInterface();\n            Integer renderCount = null;\n            if (listenerInterface.isIncludeRenderCount()) {\n                renderCount = page.getRenderCount();\n            }\n            PageInfo pageInfo = new PageInfo(page.getPageId());\n            ComponentInfo componentInfo = new ComponentInfo(renderCount, requestListenerInterfaceToString(listenerInterface), componentPath, handler.getBehaviorIndex());\n            PageComponentInfo pageComponentInfo = new PageComponentInfo(pageInfo, componentInfo);\n            UrlInfo urlInfo = new UrlInfo(pageComponentInfo, page.getClass(), handler.getPageParameters());\n            url = buildUrl(urlInfo);\n        }\n    }\n    return url;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic Url mapHandler(IRequestHandler requestHandler) {\n    Url url = super.mapHandler(requestHandler);\n    if (url == null && requestHandler instanceof ListenerInterfaceRequestHandler) {\n        ListenerInterfaceRequestHandler handler = (ListenerInterfaceRequestHandler) requestHandler;\n        IRequestablePage page = handler.getPage();\n        if (checkPageInstance(page)) {\n            String componentPath = handler.getComponentPath();\n            RequestListenerInterface listenerInterface = handler.getListenerInterface();\n            Integer renderCount = null;\n            if (listenerInterface.isIncludeRenderCount()) {\n                renderCount = page.getRenderCount();\n            }\n            PageInfo pageInfo = new PageInfo(page.getPageId());\n            ComponentInfo componentInfo = new ComponentInfo(renderCount, requestListenerInterfaceToString(listenerInterface), componentPath, handler.getBehaviorIndex());\n            PageComponentInfo pageComponentInfo = new PageComponentInfo(pageInfo, componentInfo);\n            UrlInfo urlInfo = new UrlInfo(pageComponentInfo, page.getClass(), handler.getPageParameters());\n            url = buildUrl(urlInfo);\n        }\n    }\n    return url;\n}", "lc": 0.36363636363636365, "pi": 0.799043062200957, "ma": 0.0, "nbd": 0.5, "ml": 0.3333333333333333, "d": 0.005952380952380957, "mi": -0.3570119802677939, "fo": 0.5833333333333334, "r": -0.02631578947368421, "e": 0.22948197068976442}
{"project_name": "Math", "project_version": 76, "label": 1, "code": "/**\n * {@inheritDoc}\n */\npublic RealMatrix getU() throws InvalidMatrixException {\n    if (cachedU == null) {\n        final int p = singularValues.length;\n        if (m >= n) {\n            // the tridiagonal matrix is Bt.B, where B is upper bidiagonal\n            final RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);\n            final double[][] eData = e.getData();\n            final double[][] wData = new double[m][p];\n            double[] ei1 = eData[0];\n            for (int i = 0; i < p - 1; ++i) {\n                // compute W = B.E.S^(-1) where E is the eigenvectors matrix\n                final double mi = mainBidiagonal[i];\n                final double[] ei0 = ei1;\n                final double[] wi = wData[i];\n                ei1 = eData[i + 1];\n                final double si = secondaryBidiagonal[i];\n                for (int j = 0; j < p; ++j) {\n                    wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n                }\n            }\n            for (int j = 0; j < p; ++j) {\n                wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];\n            }\n            for (int i = p; i < m; ++i) {\n                wData[i] = new double[p];\n            }\n            cachedU = transformer.getU().multiply(MatrixUtils.createRealMatrix(wData));\n        } else {\n            // the tridiagonal matrix is B.Bt, where B is lower bidiagonal\n            final RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);\n            cachedU = transformer.getU().multiply(e);\n        }\n    }\n    // return the cached matrix\n    return cachedU;\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "public RealMatrix getU() throws InvalidMatrixException {\n    if (cachedU == null) {\n        final int p = singularValues.length;\n        if (m >= n) {\n                        final RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);\n            final double[][] eData = e.getData();\n            final double[][] wData = new double[m][p];\n            double[] ei1 = eData[0];\n            for (int i = 0; i < p - 1; ++i) {\n                                final double mi = mainBidiagonal[i];\n                final double[] ei0 = ei1;\n                final double[] wi = wData[i];\n                ei1 = eData[i + 1];\n                final double si = secondaryBidiagonal[i];\n                for (int j = 0; j < p; ++j) {\n                    wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n                }\n            }\n            for (int j = 0; j < p; ++j) {\n                wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];\n            }\n            for (int i = p; i < m; ++i) {\n                wData[i] = new double[p];\n            }\n            cachedU = transformer.getU().multiply(MatrixUtils.createRealMatrix(wData));\n        } else {\n                        final RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);\n            cachedU = transformer.getU().multiply(e);\n        }\n    }\n        return cachedU;\n}", "lc": 0.8181818181818182, "pi": 0.8708133971291864, "ma": 0.6, "nbd": 1.0, "ml": 0.5833333333333334, "d": 2.4007936507936507, "mi": -0.6405919661733612, "fo": 0.3333333333333333, "r": -0.02631578947368421, "e": 5.347180489041798}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1789_07646fba", "label": 1, "code": "private void fixFrozenUuid() {\n    // OAK-1789: Convert the jcr:frozenUuid of a non-referenceable\n    // frozen node from UUID to a path identifier\n    PropertyState frozenUuid = properties.get(JCR_FROZENUUID);\n    if (frozenUuid != null && frozenUuid.getType() == STRING && isFrozenNode.apply(this)) {\n        String frozenPrimary = NT_BASE;\n        Set<String> frozenMixins = newHashSet();\n        PropertyState property = properties.get(JCR_FROZENPRIMARYTYPE);\n        if (property != null && property.getType() == NAME) {\n            frozenPrimary = property.getValue(NAME);\n        }\n        property = properties.get(JCR_FROZENMIXINTYPES);\n        if (property != null && property.getType() == NAMES) {\n            addAll(frozenMixins, property.getValue(NAMES));\n        }\n        if (!isReferenceable.apply(frozenPrimary, frozenMixins)) {\n            frozenUuid = PropertyStates.createProperty(JCR_FROZENUUID, parent.getString(JCR_FROZENUUID) + \"/\" + name);\n            properties.put(JCR_FROZENUUID, frozenUuid);\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "private void fixFrozenUuid() {\n            PropertyState frozenUuid = properties.get(JCR_FROZENUUID);\n    if (frozenUuid != null && frozenUuid.getType() == STRING && isFrozenNode.apply(this)) {\n        String frozenPrimary = NT_BASE;\n        Set<String> frozenMixins = newHashSet();\n        PropertyState property = properties.get(JCR_FROZENPRIMARYTYPE);\n        if (property != null && property.getType() == NAME) {\n            frozenPrimary = property.getValue(NAME);\n        }\n        property = properties.get(JCR_FROZENMIXINTYPES);\n        if (property != null && property.getType() == NAMES) {\n            addAll(frozenMixins, property.getValue(NAMES));\n        }\n        if (!isReferenceable.apply(frozenPrimary, frozenMixins)) {\n            frozenUuid = PropertyStates.createProperty(JCR_FROZENUUID, parent.getString(JCR_FROZENUUID) + \"/\" + name);\n            properties.put(JCR_FROZENUUID, frozenUuid);\n        }\n    }\n}", "lc": 0.22727272727272727, "pi": 0.24401913875598077, "ma": 0.2, "nbd": 0.0, "ml": 0.9166666666666666, "d": 0.8253968253968255, "mi": -0.2947145877378434, "fo": 0.75, "r": -0.02631578947368421, "e": 1.0799513609146911}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-3727_ff2713d1", "label": 1, "code": "/**\n * Sends the given exchange to the recipient list\n */\npublic boolean sendToRecipientList(Exchange exchange, Object recipientList, AsyncCallback callback) {\n    Iterator<Object> iter = ObjectHelper.createIterator(recipientList, delimiter);\n    RecipientListProcessor rlp = new RecipientListProcessor(exchange.getContext(), producerCache, iter, getAggregationStrategy(), isParallelProcessing(), getExecutorService(), isStreaming(), isStopOnException(), getTimeout());\n    rlp.setIgnoreInvalidEndpoints(isIgnoreInvalidEndpoints());\n    // start the service\n    try {\n        ServiceHelper.startService(rlp);\n    } catch (Exception e) {\n        exchange.setException(e);\n        callback.done(true);\n        return true;\n    }\n    // now let the multicast process the exchange\n    return AsyncProcessorHelper.process(rlp, exchange, callback);\n}", "code_comment": "/**\n * Sends the given exchange to the recipient list\n */\n", "code_no_comment": "public boolean sendToRecipientList(Exchange exchange, Object recipientList, AsyncCallback callback) {\n    Iterator<Object> iter = ObjectHelper.createIterator(recipientList, delimiter);\n    RecipientListProcessor rlp = new RecipientListProcessor(exchange.getContext(), producerCache, iter, getAggregationStrategy(), isParallelProcessing(), getExecutorService(), isStreaming(), isStopOnException(), getTimeout());\n    rlp.setIgnoreInvalidEndpoints(isIgnoreInvalidEndpoints());\n        try {\n        ServiceHelper.startService(rlp);\n    } catch (Exception e) {\n        exchange.setException(e);\n        callback.done(true);\n        return true;\n    }\n        return AsyncProcessorHelper.process(rlp, exchange, callback);\n}", "lc": -0.045454545454545456, "pi": -0.16267942583732073, "ma": -0.4, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": -0.01987315010570819, "fo": 0.6666666666666666, "r": -0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "Closure", "project_version": 40, "label": 2, "code": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    // Record global variable and function declarations\n    if (t.inGlobalScope()) {\n        if (NodeUtil.isVarDeclaration(n)) {\n            NameInformation ns = createNameInformation(t, n, parent);\n            Preconditions.checkNotNull(ns);\n            recordSet(ns.name, n);\n        } else if (NodeUtil.isFunctionDeclaration(n)) {\n            Node nameNode = n.getFirstChild();\n            NameInformation ns = createNameInformation(t, nameNode, n);\n            if (ns != null) {\n                JsName nameInfo = getName(nameNode.getString(), true);\n                recordSet(nameInfo.name, nameNode);\n            }\n        } else if (NodeUtil.isObjectLitKey(n, parent)) {\n            NameInformation ns = createNameInformation(t, n, parent);\n            if (ns != null) {\n                recordSet(ns.name, n);\n            }\n        }\n    }\n    // Record assignments and call sites\n    if (n.isAssign()) {\n        Node nameNode = n.getFirstChild();\n        NameInformation ns = createNameInformation(t, nameNode, n);\n        if (ns != null) {\n            if (ns.isPrototype) {\n                recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n            } else {\n                recordSet(ns.name, nameNode);\n            }\n        }\n    } else if (n.isCall()) {\n        Node nameNode = n.getFirstChild();\n        NameInformation ns = createNameInformation(t, nameNode, n);\n        if (ns != null && ns.onlyAffectsClassDef) {\n            JsName name = getName(ns.name, false);\n            if (name != null) {\n                refNodes.add(new ClassDefiningFunctionNode(name, n, parent, parent.getParent()));\n            }\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n        if (t.inGlobalScope()) {\n        if (NodeUtil.isVarDeclaration(n)) {\n            NameInformation ns = createNameInformation(t, n, parent);\n            Preconditions.checkNotNull(ns);\n            recordSet(ns.name, n);\n        } else if (NodeUtil.isFunctionDeclaration(n)) {\n            Node nameNode = n.getFirstChild();\n            NameInformation ns = createNameInformation(t, nameNode, n);\n            if (ns != null) {\n                JsName nameInfo = getName(nameNode.getString(), true);\n                recordSet(nameInfo.name, nameNode);\n            }\n        } else if (NodeUtil.isObjectLitKey(n, parent)) {\n            NameInformation ns = createNameInformation(t, n, parent);\n            if (ns != null) {\n                recordSet(ns.name, n);\n            }\n        }\n    }\n        if (n.isAssign()) {\n        Node nameNode = n.getFirstChild();\n        NameInformation ns = createNameInformation(t, nameNode, n);\n        if (ns != null) {\n            if (ns.isPrototype) {\n                recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n            } else {\n                recordSet(ns.name, nameNode);\n            }\n        }\n    } else if (n.isCall()) {\n        Node nameNode = n.getFirstChild();\n        NameInformation ns = createNameInformation(t, nameNode, n);\n        if (ns != null && ns.onlyAffectsClassDef) {\n            JsName name = getName(ns.name, false);\n            if (name != null) {\n                refNodes.add(new ClassDefiningFunctionNode(name, n, parent, parent.getParent()));\n            }\n        }\n    }\n}", "lc": 1.2727272727272727, "pi": 0.6602870813397129, "ma": 1.8, "nbd": 1.5, "ml": 1.6666666666666667, "d": 0.2599206349206349, "mi": -0.7880197322057785, "fo": 1.5833333333333333, "r": -0.02631578947368421, "e": 0.9562144499576424}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-217_46f62443", "label": 1, "code": "@Override\npublic void clearLocatorCache(String tableName) throws TableNotFoundException {\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void clearLocatorCache(String tableName) throws TableNotFoundException {\n}", "lc": -0.5, "pi": -1.4306220095693782, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.0676532769556022, "fo": -0.5, "r": 2.263157894736842, "e": -0.16279340490885932}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-7429_43956f93", "label": 1, "code": "private String createPlaceholderPart(String key, Properties properties, List<String> replaced, String prefixToken, String suffixToken) {\n    // keep track of which parts we have replaced\n    replaced.add(key);\n    String propertyValue = System.getProperty(key);\n    if (propertyValue != null) {\n        log.debug(\"Found a JVM system property: {} with value: {} to be used.\", key, propertyValue);\n    } else if (properties != null) {\n        propertyValue = properties.getProperty(key);\n    }\n    // we need to check if the propertyValue is nested\n    // we need to check if there is cycle dependency of the nested properties\n    List<String> visited = new ArrayList<String>();\n    while (isNestProperty(propertyValue, prefixToken, suffixToken)) {\n        visited.add(key);\n        // need to take off the token first\n        String value = takeOffNestTokes(propertyValue, prefixToken, suffixToken);\n        key = parseUri(value, properties, prefixToken, suffixToken);\n        if (visited.contains(key)) {\n            throw new IllegalArgumentException(\"Circular reference detected with key [\" + key + \"] from text: \" + propertyValue);\n        }\n        propertyValue = System.getProperty(key);\n        if (propertyValue != null) {\n            log.debug(\"Found a JVM system property: {} with value: {} to be used.\", key, propertyValue);\n        } else if (properties != null) {\n            propertyValue = properties.getProperty(key);\n        }\n    }\n    return parseProperty(key, propertyValue, properties);\n}", "code_comment": NaN, "code_no_comment": "private String createPlaceholderPart(String key, Properties properties, List<String> replaced, String prefixToken, String suffixToken) {\n        replaced.add(key);\n    String propertyValue = System.getProperty(key);\n    if (propertyValue != null) {\n        log.debug(\"Found a JVM system property: {} with value: {} to be used.\", key, propertyValue);\n    } else if (properties != null) {\n        propertyValue = properties.getProperty(key);\n    }\n            List<String> visited = new ArrayList<String>();\n    while (isNestProperty(propertyValue, prefixToken, suffixToken)) {\n        visited.add(key);\n                String value = takeOffNestTokes(propertyValue, prefixToken, suffixToken);\n        key = parseUri(value, properties, prefixToken, suffixToken);\n        if (visited.contains(key)) {\n            throw new IllegalArgumentException(\"Circular reference detected with key [\" + key + \"] from text: \" + propertyValue);\n        }\n        propertyValue = System.getProperty(key);\n        if (propertyValue != null) {\n            log.debug(\"Found a JVM system property: {} with value: {} to be used.\", key, propertyValue);\n        } else if (properties != null) {\n            propertyValue = properties.getProperty(key);\n        }\n    }\n    return parseProperty(key, propertyValue, properties);\n}", "lc": 0.5, "pi": 0.10047846889952151, "ma": 0.8, "nbd": 0.5, "ml": 0.6666666666666666, "d": 0.23611111111111105, "mi": -0.4551092318534177, "fo": 0.5833333333333334, "r": -0.02631578947368421, "e": 0.5367057969260558}
{"project_name": "JxPath", "project_version": 14, "label": 1, "code": "protected Object functionRound(EvalContext context) {\n    assertArgCount(1);\n    double v = InfoSetUtil.doubleValue(getArg1().computeValue(context));\n    return new Double(Math.round(v));\n}", "code_comment": NaN, "code_no_comment": "protected Object functionRound(EvalContext context) {\n    assertArgCount(1);\n    double v = InfoSetUtil.doubleValue(getArg1().computeValue(context));\n    return new Double(Math.round(v));\n}", "lc": -0.4090909090909091, "pi": -0.49282296650717716, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.6093023255813951, "fo": -0.08333333333333333, "r": 1.2105263157894737, "e": -0.16279340490885932}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2330_408a566e", "label": 3, "code": "@Override\npublic void onResult(Aggregate.PropertyIncludeResult result) throws CommitFailedException {\n    boolean dirty = false;\n    if (result.pd.ordered) {\n        dirty |= addTypedOrderedFields(fields, result.propertyState, result.propertyPath, result.pd);\n    }\n    dirty |= indexProperty(path, fields, state, result.propertyState, result.propertyPath, true, result.pd);\n    if (dirty) {\n        dirtyFlag.set(true);\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void onResult(Aggregate.PropertyIncludeResult result) throws CommitFailedException {\n    boolean dirty = false;\n    if (result.pd.ordered) {\n        dirty |= addTypedOrderedFields(fields, result.propertyState, result.propertyPath, result.pd);\n    }\n    dirty |= indexProperty(path, fields, state, result.propertyState, result.propertyPath, true, result.pd);\n    if (dirty) {\n        dirtyFlag.set(true);\n    }\n}", "lc": -0.13636363636363635, "pi": -0.15311004784689008, "ma": -0.2, "nbd": -0.5, "ml": -0.08333333333333333, "d": -0.015873015873015886, "mi": 0.10105708245243149, "fo": -0.25, "r": -0.02631578947368421, "e": -0.01581577082000657}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3903_690fb9f4", "label": 1, "code": "/**\n * Updates a commit root document.\n *\n * @param commit the updates to apply on the commit root document.\n * @return the document before the update was applied or <code>null</code>\n *          if the update failed because of a collision.\n * @throws DocumentStoreException if the update fails with an error.\n */\n@CheckForNull\nNodeDocument updateCommitRoot(UpdateOp commit) throws DocumentStoreException {\n    // use batch commit when there are only revision and modified updates\n    boolean batch = true;\n    for (Map.Entry<Key, Operation> op : commit.getChanges().entrySet()) {\n        String name = op.getKey().getName();\n        if (NodeDocument.isRevisionsEntry(name) || NodeDocument.MODIFIED_IN_SECS.equals(name)) {\n            continue;\n        }\n        batch = false;\n        break;\n    }\n    if (batch) {\n        return batchUpdateCommitRoot(commit);\n    } else {\n        return store.findAndUpdate(NODES, commit);\n    }\n}", "code_comment": "/**\n * Updates a commit root document.\n *\n * @param commit the updates to apply on the commit root document.\n * @return the document before the update was applied or <code>null</code>\n *          if the update failed because of a collision.\n * @throws DocumentStoreException if the update fails with an error.\n */\n", "code_no_comment": "@CheckForNull\nNodeDocument updateCommitRoot(UpdateOp commit) throws DocumentStoreException {\n        boolean batch = true;\n    for (Map.Entry<Key, Operation> op : commit.getChanges().entrySet()) {\n        String name = op.getKey().getName();\n        if (NodeDocument.isRevisionsEntry(name) || NodeDocument.MODIFIED_IN_SECS.equals(name)) {\n            continue;\n        }\n        batch = false;\n        break;\n    }\n    if (batch) {\n        return batchUpdateCommitRoot(commit);\n    } else {\n        return store.findAndUpdate(NODES, commit);\n    }\n}", "lc": 0.13636363636363635, "pi": 0.16746411483253573, "ma": 0.4, "nbd": 0.0, "ml": 0.16666666666666666, "d": -0.09523809523809523, "mi": -0.13629316420014073, "fo": 0.16666666666666666, "r": 0.02631578947368421, "e": -0.03384680993297719}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-209_397f86f6", "label": 1, "code": "private boolean matches(Matcher matcher, ByteSequence bs) {\n    if (matcher != null) {\n        babcs.set(bs);\n        matcher.reset(babcs);\n        return matcher.matches();\n    }\n    return !orFields;\n}", "code_comment": NaN, "code_no_comment": "private boolean matches(Matcher matcher, ByteSequence bs) {\n    if (matcher != null) {\n        babcs.set(bs);\n        matcher.reset(babcs);\n        return matcher.matches();\n    }\n    return !orFields;\n}", "lc": -0.2727272727272727, "pi": 0.06220095693779899, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": -0.05753968253968254, "mi": 0.3916842847075403, "fo": -0.25, "r": 0.5, "e": -0.11269745221094608}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-1008_0c20bfd8", "label": 1, "code": "/**\n * Finds matching classes within a jar files that contains a folder structure\n * matching the package structure.  If the File is not a JarFile or does not exist a warning\n * will be logged, but no error will be raised.\n *\n * @param test a Test used to filter the classes that are discovered\n * @param parent the parent package under which classes must be in order to be considered\n * @param stream The jar InputStream\n */\nprivate void loadImplementationsInJar(final Test test, final String parent, final String path, final JarInputStream stream) {\n    try {\n        JarEntry entry;\n        while ((entry = stream.getNextJarEntry()) != null) {\n            final String name = entry.getName();\n            if (!entry.isDirectory() && name.startsWith(parent) && isTestApplicable(test, name)) {\n                addIfMatching(test, name);\n            }\n        }\n    } catch (final IOException ioe) {\n        LOGGER.error(\"Could not search jar file '\" + path + \"' for classes matching criteria: \" + test + \" due to an IOException\", ioe);\n    }\n}", "code_comment": "/**\n * Finds matching classes within a jar files that contains a folder structure\n * matching the package structure.  If the File is not a JarFile or does not exist a warning\n * will be logged, but no error will be raised.\n *\n * @param test a Test used to filter the classes that are discovered\n * @param parent the parent package under which classes must be in order to be considered\n * @param stream The jar InputStream\n */\n", "code_no_comment": "private void loadImplementationsInJar(final Test test, final String parent, final String path, final JarInputStream stream) {\n    try {\n        JarEntry entry;\n        while ((entry = stream.getNextJarEntry()) != null) {\n            final String name = entry.getName();\n            if (!entry.isDirectory() && name.startsWith(parent) && isTestApplicable(test, name)) {\n                addIfMatching(test, name);\n            }\n        }\n    } catch (final IOException ioe) {\n        LOGGER.error(\"Could not search jar file '\" + path + \"' for classes matching criteria: \" + test + \" due to an IOException\", ioe);\n    }\n}", "lc": -0.045454545454545456, "pi": 0.8038277511961721, "ma": 0.0, "nbd": 0.5, "ml": 0.4166666666666667, "d": 0.2599206349206349, "mi": -0.018463706835799888, "fo": 0.08333333333333333, "r": 0.10526315789473684, "e": 0.17577151155754567}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1199_813109d7", "label": 3, "code": "public boolean equals(removeConstraint_result that) {\n    if (that == null)\n        return false;\n    boolean this_present_ouch1 = true && this.isSetOuch1();\n    boolean that_present_ouch1 = true && that.isSetOuch1();\n    if (this_present_ouch1 || that_present_ouch1) {\n        if (!(this_present_ouch1 && that_present_ouch1))\n            return false;\n        if (!this.ouch1.equals(that.ouch1))\n            return false;\n    }\n    boolean this_present_ouch2 = true && this.isSetOuch2();\n    boolean that_present_ouch2 = true && that.isSetOuch2();\n    if (this_present_ouch2 || that_present_ouch2) {\n        if (!(this_present_ouch2 && that_present_ouch2))\n            return false;\n        if (!this.ouch2.equals(that.ouch2))\n            return false;\n    }\n    return true;\n}", "code_comment": NaN, "code_no_comment": "public boolean equals(removeConstraint_result that) {\n    if (that == null)\n        return false;\n    boolean this_present_ouch1 = true && this.isSetOuch1();\n    boolean that_present_ouch1 = true && that.isSetOuch1();\n    if (this_present_ouch1 || that_present_ouch1) {\n        if (!(this_present_ouch1 && that_present_ouch1))\n            return false;\n        if (!this.ouch1.equals(that.ouch1))\n            return false;\n    }\n    boolean this_present_ouch2 = true && this.isSetOuch2();\n    boolean that_present_ouch2 = true && that.isSetOuch2();\n    if (this_present_ouch2 || that_present_ouch2) {\n        if (!(this_present_ouch2 && that_present_ouch2))\n            return false;\n        if (!this.ouch2.equals(that.ouch2))\n            return false;\n    }\n    return true;\n}", "lc": 0.3181818181818182, "pi": 0.30143540669856456, "ma": 0.8, "nbd": -0.5, "ml": 1.25, "d": 0.7460317460317459, "mi": -0.2769556025369979, "fo": 0.0, "r": -0.02631578947368421, "e": 0.49554929317727325}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5176_34634266", "label": 3, "code": "/**\n *  @see org.apache.wicket.model.IDetachable#detach()\n */\n@Override\nprotected final void onDetach() {\n    super.onDetach();\n    // detach any model\n    if (model != null) {\n        model.detach();\n    }\n    // some parameters can be detachable\n    if (parameters != null) {\n        for (Object parameter : parameters) {\n            if (parameter instanceof IDetachable) {\n                ((IDetachable) parameter).detach();\n            }\n        }\n    }\n    if (defaultValue != null) {\n        defaultValue.detach();\n    }\n}", "code_comment": "/**\n *  @see org.apache.wicket.model.IDetachable#detach()\n */\n", "code_no_comment": "@Override\nprotected final void onDetach() {\n    super.onDetach();\n        if (model != null) {\n        model.detach();\n    }\n        if (parameters != null) {\n        for (Object parameter : parameters) {\n            if (parameter instanceof IDetachable) {\n                ((IDetachable) parameter).detach();\n            }\n        }\n    }\n    if (defaultValue != null) {\n        defaultValue.detach();\n    }\n}", "lc": 0.13636363636363635, "pi": 0.6555023923444977, "ma": 0.4, "nbd": 0.5, "ml": 0.25, "d": -0.3650793650793651, "mi": -0.014235377026074568, "fo": -0.16666666666666666, "r": 0.5789473684210527, "e": -0.16279340490885932}
{"project_name": "Lang", "project_version": 17, "label": 1, "code": "/**\n * Translate an input onto a Writer. This is intentionally final as its algorithm is\n * tightly coupled with the abstract method of this class.\n *\n * @param input CharSequence that is being translated\n * @param out Writer to translate the text to\n * @throws IOException if and only if the Writer produces an IOException\n */\npublic final void translate(CharSequence input, Writer out) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (input == null) {\n        return;\n    }\n    int pos = 0;\n    int len = Character.codePointCount(input, 0, input.length());\n    while (pos < len) {\n        int consumed = translate(input, pos, out);\n        if (consumed == 0) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n        } else {\n            // // and they just took care of a surrogate pair\n            for (int pt = 0; pt < consumed; pt++) {\n                if (pos < len - 2) {\n                    pos += Character.charCount(Character.codePointAt(input, pos));\n                } else {\n                    pos++;\n                }\n            }\n            pos--;\n        }\n        pos++;\n    }\n}", "code_comment": "/**\n * Translate an input onto a Writer. This is intentionally final as its algorithm is\n * tightly coupled with the abstract method of this class.\n *\n * @param input CharSequence that is being translated\n * @param out Writer to translate the text to\n * @throws IOException if and only if the Writer produces an IOException\n */\n", "code_no_comment": "public final void translate(CharSequence input, Writer out) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (input == null) {\n        return;\n    }\n    int pos = 0;\n    int len = Character.codePointCount(input, 0, input.length());\n    while (pos < len) {\n        int consumed = translate(input, pos, out);\n        if (consumed == 0) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n        } else {\n                        for (int pt = 0; pt < consumed; pt++) {\n                if (pos < len - 2) {\n                    pos += Character.charCount(Character.codePointAt(input, pos));\n                } else {\n                    pos++;\n                }\n            }\n            pos--;\n        }\n        pos++;\n    }\n}", "lc": 0.5909090909090909, "pi": 1.1770334928229667, "ma": 0.8, "nbd": 1.0, "ml": 0.5833333333333334, "d": 1.0992063492063493, "mi": -0.448625792811839, "fo": 0.16666666666666666, "r": -0.02631578947368421, "e": 1.1174195927917334}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-6447_020c451a", "label": 1, "code": "public boolean process(Exchange exchange, AsyncCallback callback) {\n    Iterator<Processor> processors = next().iterator();\n    exchange.setProperty(Exchange.FILTER_MATCHED, false);\n    while (continueRouting(processors, exchange)) {\n        // get the next processor\n        Processor processor = processors.next();\n        AsyncProcessor async = AsyncProcessorConverterHelper.convert(processor);\n        boolean sync = process(exchange, callback, processors, async);\n        // continue as long its being processed synchronously\n        if (!sync) {\n            LOG.trace(\"Processing exchangeId: {} is continued being processed asynchronously\", exchange.getExchangeId());\n            // so we break out now, then the callback will be invoked which then continue routing from where we left here\n            return false;\n        }\n        LOG.trace(\"Processing exchangeId: {} is continued being processed synchronously\", exchange.getExchangeId());\n        // check for error if so we should break out\n        if (!continueProcessing(exchange, \"so breaking out of content based router\", LOG)) {\n            break;\n        }\n    }\n    LOG.trace(\"Processing complete for exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\n    callback.done(true);\n    return true;\n}", "code_comment": NaN, "code_no_comment": "public boolean process(Exchange exchange, AsyncCallback callback) {\n    Iterator<Processor> processors = next().iterator();\n    exchange.setProperty(Exchange.FILTER_MATCHED, false);\n    while (continueRouting(processors, exchange)) {\n                Processor processor = processors.next();\n        AsyncProcessor async = AsyncProcessorConverterHelper.convert(processor);\n        boolean sync = process(exchange, callback, processors, async);\n                if (!sync) {\n            LOG.trace(\"Processing exchangeId: {} is continued being processed asynchronously\", exchange.getExchangeId());\n                        return false;\n        }\n        LOG.trace(\"Processing exchangeId: {} is continued being processed synchronously\", exchange.getExchangeId());\n                if (!continueProcessing(exchange, \"so breaking out of content based router\", LOG)) {\n            break;\n        }\n    }\n    LOG.trace(\"Processing complete for exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\n    callback.done(true);\n    return true;\n}", "lc": 0.2727272727272727, "pi": 0.21531100478468887, "ma": 0.2, "nbd": 0.0, "ml": 0.25, "d": 0.019841269841269816, "mi": -0.27413671599718087, "fo": 0.75, "r": -0.02631578947368421, "e": 0.1342876736801461}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-8964_ea8ee025", "label": 1, "code": "/**\n * Suspends the given {@code service}.\n * <p/>\n * If {@code service} is a {@link org.apache.camel.SuspendableService} then\n * it's {@link org.apache.camel.SuspendableService#suspend()} is called but\n * <b>only</b> if {@code service} is <b>not</b> already\n * {@link #isSuspended(Object) suspended}.\n * <p/>\n * If {@code service} is <b>not</b> a\n * {@link org.apache.camel.SuspendableService} then it's\n * {@link org.apache.camel.Service#stop()} is called.\n * <p/>\n * Calling this method has no effect if {@code service} is {@code null}.\n *\n * @param service the service\n * @return <tt>true</tt> if either the <tt>suspend</tt> method or\n *         {@link #stopService(Object)} was called, <tt>false</tt>\n *         otherwise.\n * @throws Exception is thrown if error occurred\n * @see #stopService(Object)\n */\npublic static boolean suspendService(Service service) throws Exception {\n    if (service instanceof SuspendableService) {\n        SuspendableService ss = (SuspendableService) service;\n        if (!ss.isSuspended()) {\n            LOG.trace(\"Suspending service {}\", service);\n            ss.suspend();\n            return true;\n        } else {\n            return false;\n        }\n    } else {\n        stopService(service);\n        return true;\n    }\n}", "code_comment": "/**\n * Suspends the given {@code service}.\n * <p/>\n * If {@code service} is a {@link org.apache.camel.SuspendableService} then\n * it's {@link org.apache.camel.SuspendableService#suspend()} is called but\n * <b>only</b> if {@code service} is <b>not</b> already\n * {@link #isSuspended(Object) suspended}.\n * <p/>\n * If {@code service} is <b>not</b> a\n * {@link org.apache.camel.SuspendableService} then it's\n * {@link org.apache.camel.Service#stop()} is called.\n * <p/>\n * Calling this method has no effect if {@code service} is {@code null}.\n *\n * @param service the service\n * @return <tt>true</tt> if either the <tt>suspend</tt> method or\n *         {@link #stopService(Object)} was called, <tt>false</tt>\n *         otherwise.\n * @throws Exception is thrown if error occurred\n * @see #stopService(Object)\n */\n", "code_no_comment": "public static boolean suspendService(Service service) throws Exception {\n    if (service instanceof SuspendableService) {\n        SuspendableService ss = (SuspendableService) service;\n        if (!ss.isSuspended()) {\n            LOG.trace(\"Suspending service {}\", service);\n            ss.suspend();\n            return true;\n        } else {\n            return false;\n        }\n    } else {\n        stopService(service);\n        return true;\n    }\n}", "lc": 0.045454545454545456, "pi": 0.4449760765550238, "ma": -0.2, "nbd": 0.0, "ml": -0.08333333333333333, "d": -0.047619047619047616, "mi": 0.037632135306554126, "fo": -0.16666666666666666, "r": -0.02631578947368421, "e": -0.0843991862750183}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-1051_bda25b40", "label": 1, "code": "/**\n * Perform a double QR step involving rows l:idx and columns m:n\n *\n * @param il the index of the small sub-diagonal element\n * @param im the start index for the QR step\n * @param iu the current eigenvalue index\n * @param shift shift information holder\n * @param hVec the initial houseHolder vector\n */\nprivate void performDoubleQRStep(final int il, final int im, final int iu, final ShiftInfo shift, final double[] hVec) {\n    final int n = matrixT.length;\n    double p = hVec[0];\n    double q = hVec[1];\n    double r = hVec[2];\n    for (int k = im; k <= iu - 1; k++) {\n        boolean notlast = k != (iu - 1);\n        if (k != im) {\n            p = matrixT[k][k - 1];\n            q = matrixT[k + 1][k - 1];\n            r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n            shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n            if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                p = p / shift.x;\n                q = q / shift.x;\n                r = r / shift.x;\n            }\n        }\n        if (shift.x == 0.0) {\n            break;\n        }\n        double s = FastMath.sqrt(p * p + q * q + r * r);\n        if (p < 0.0) {\n            s = -s;\n        }\n        if (s != 0.0) {\n            if (k != im) {\n                matrixT[k][k - 1] = -s * shift.x;\n            } else if (il != im) {\n                matrixT[k][k - 1] = -matrixT[k][k - 1];\n            }\n            p = p + s;\n            shift.x = p / s;\n            shift.y = q / s;\n            double z = r / s;\n            q = q / p;\n            r = r / p;\n            // Row modification\n            for (int j = k; j < n; j++) {\n                p = matrixT[k][j] + q * matrixT[k + 1][j];\n                if (notlast) {\n                    p = p + r * matrixT[k + 2][j];\n                    matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                }\n                matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n            }\n            // Column modification\n            for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                if (notlast) {\n                    p = p + z * matrixT[i][k + 2];\n                    matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                }\n                matrixT[i][k] = matrixT[i][k] - p;\n                matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n            }\n            // Accumulate transformations\n            final int high = matrixT.length - 1;\n            for (int i = 0; i <= high; i++) {\n                p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                if (notlast) {\n                    p = p + z * matrixP[i][k + 2];\n                    matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                }\n                matrixP[i][k] = matrixP[i][k] - p;\n                matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n            }\n        }\n    // (s != 0)\n    }\n    // clean up pollution due to round-off errors\n    for (int i = im + 2; i <= iu; i++) {\n        matrixT[i][i - 2] = 0.0;\n        if (i > im + 2) {\n            matrixT[i][i - 3] = 0.0;\n        }\n    }\n}", "code_comment": "/**\n * Perform a double QR step involving rows l:idx and columns m:n\n *\n * @param il the index of the small sub-diagonal element\n * @param im the start index for the QR step\n * @param iu the current eigenvalue index\n * @param shift shift information holder\n * @param hVec the initial houseHolder vector\n */\n", "code_no_comment": "private void performDoubleQRStep(final int il, final int im, final int iu, final ShiftInfo shift, final double[] hVec) {\n    final int n = matrixT.length;\n    double p = hVec[0];\n    double q = hVec[1];\n    double r = hVec[2];\n    for (int k = im; k <= iu - 1; k++) {\n        boolean notlast = k != (iu - 1);\n        if (k != im) {\n            p = matrixT[k][k - 1];\n            q = matrixT[k + 1][k - 1];\n            r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n            shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n            if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                p = p / shift.x;\n                q = q / shift.x;\n                r = r / shift.x;\n            }\n        }\n        if (shift.x == 0.0) {\n            break;\n        }\n        double s = FastMath.sqrt(p * p + q * q + r * r);\n        if (p < 0.0) {\n            s = -s;\n        }\n        if (s != 0.0) {\n            if (k != im) {\n                matrixT[k][k - 1] = -s * shift.x;\n            } else if (il != im) {\n                matrixT[k][k - 1] = -matrixT[k][k - 1];\n            }\n            p = p + s;\n            shift.x = p / s;\n            shift.y = q / s;\n            double z = r / s;\n            q = q / p;\n            r = r / p;\n                        for (int j = k; j < n; j++) {\n                p = matrixT[k][j] + q * matrixT[k + 1][j];\n                if (notlast) {\n                    p = p + r * matrixT[k + 2][j];\n                    matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                }\n                matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n            }\n                        for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                if (notlast) {\n                    p = p + z * matrixT[i][k + 2];\n                    matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                }\n                matrixT[i][k] = matrixT[i][k] - p;\n                matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n            }\n                        final int high = matrixT.length - 1;\n            for (int i = 0; i <= high; i++) {\n                p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                if (notlast) {\n                    p = p + z * matrixP[i][k + 2];\n                    matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                }\n                matrixP[i][k] = matrixP[i][k] - p;\n                matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n            }\n        }\n        }\n        for (int i = im + 2; i <= iu; i++) {\n        matrixT[i][i - 2] = 0.0;\n        if (i > im + 2) {\n            matrixT[i][i - 3] = 0.0;\n        }\n    }\n}", "lc": 2.727272727272727, "pi": 0.8708133971291864, "ma": 3.0, "nbd": 1.0, "ml": 2.25, "d": 10.21626984126984, "mi": -1.2641296687808312, "fo": 0.0, "r": -0.02631578947368421, "e": 63.968324660131486}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4259_1f128536", "label": 3, "code": "/**\n *  get a model that accesses the parent model lazily. this is required since we eventually\n *  request the parents model before the component is added to the parent.\n *\n *  @return model\n */\nprivate IModel<T> getDelegatingParentModel() {\n    return new IModel<T>() {\n\n        private static final long serialVersionUID = 1L;\n\n        public T getObject() {\n            return getParentModel().getObject();\n        }\n\n        public void setObject(final T object) {\n            getParentModel().setObject(object);\n        }\n\n        public void detach() {\n            getParentModel().detach();\n        }\n    };\n}", "code_comment": "/**\n *  get a model that accesses the parent model lazily. this is required since we eventually\n *  request the parents model before the component is added to the parent.\n *\n *  @return model\n */\n", "code_no_comment": "private IModel<T> getDelegatingParentModel() {\n    return new IModel<T>() {\n\n        private static final long serialVersionUID = 1L;\n\n        public T getObject() {\n            return getParentModel().getObject();\n        }\n\n        public void setObject(final T object) {\n            getParentModel().setObject(object);\n        }\n\n        public void detach() {\n            getParentModel().detach();\n        }\n    };\n}", "lc": 0.0, "pi": 0.36842105263157876, "ma": -0.6, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.12558139534883714, "fo": 0.0, "r": 1.9473684210526316, "e": -0.16279340490885932}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-1133_27e40205", "label": 1, "code": "// for (Rich)Functions\n@SuppressWarnings(\"unchecked\")\nprivate <IN1, IN2, OUT> TypeInformation<OUT> privateCreateTypeInfo(Class<?> baseClass, Class<?> clazz, int returnParamPos, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {\n    ArrayList<Type> typeHierarchy = new ArrayList<Type>();\n    Type returnType = getParameterType(baseClass, typeHierarchy, clazz, returnParamPos);\n    TypeInformation<OUT> typeInfo = null;\n    // return type is a variable -> try to get the type info from the input directly\n    if (returnType instanceof TypeVariable<?>) {\n        typeInfo = (TypeInformation<OUT>) createTypeInfoFromInput((TypeVariable<?>) returnType, typeHierarchy, in1Type, in2Type);\n        if (typeInfo != null) {\n            return typeInfo;\n        }\n    }\n    // get info from hierarchy\n    return (TypeInformation<OUT>) createTypeInfoWithTypeHierarchy(typeHierarchy, returnType, in1Type, in2Type);\n}", "code_comment": NaN, "code_no_comment": "@SuppressWarnings(\"unchecked\")\nprivate <IN1, IN2, OUT> TypeInformation<OUT> privateCreateTypeInfo(Class<?> baseClass, Class<?> clazz, int returnParamPos, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {\n    ArrayList<Type> typeHierarchy = new ArrayList<Type>();\n    Type returnType = getParameterType(baseClass, typeHierarchy, clazz, returnParamPos);\n    TypeInformation<OUT> typeInfo = null;\n        if (returnType instanceof TypeVariable<?>) {\n        typeInfo = (TypeInformation<OUT>) createTypeInfoFromInput((TypeVariable<?>) returnType, typeHierarchy, in1Type, in2Type);\n        if (typeInfo != null) {\n            return typeInfo;\n        }\n    }\n        return (TypeInformation<OUT>) createTypeInfoWithTypeHierarchy(typeHierarchy, returnType, in1Type, in2Type);\n}", "lc": -0.045454545454545456, "pi": 0.22009569377990432, "ma": -0.2, "nbd": 0.0, "ml": -0.08333333333333333, "d": 0.10714285714285711, "mi": -0.04496124031007748, "fo": -0.25, "r": -0.02631578947368421, "e": 0.15630665675443597}
{"project_name": "Closure", "project_version": 141, "label": 2, "code": "/**\n * @param knownConstants A set of names known to be constant value at\n * node 'n' (such as locals that are last written before n can execute).\n * @return Whether the tree can be affected by side-effects or\n * has side-effects.\n */\nstatic boolean canBeSideEffected(Node n, Set<String> knownConstants) {\n    switch(n.getType()) {\n        case Token.CALL:\n        case Token.NEW:\n            // are unaffected by side effects.\n            return true;\n        case Token.NAME:\n            // Non-constant names values may have been changed.\n            return !NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString());\n        // Properties on constant NAMEs can still be side-effected.\n        case Token.GETPROP:\n        case Token.GETELEM:\n            return true;\n    }\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n        if (canBeSideEffected(c, knownConstants)) {\n            return true;\n        }\n    }\n    return false;\n}", "code_comment": "/**\n * @param knownConstants A set of names known to be constant value at\n * node 'n' (such as locals that are last written before n can execute).\n * @return Whether the tree can be affected by side-effects or\n * has side-effects.\n */\n", "code_no_comment": "static boolean canBeSideEffected(Node n, Set<String> knownConstants) {\n    switch(n.getType()) {\n        case Token.CALL:\n        case Token.NEW:\n                        return true;\n        case Token.NAME:\n                        return !NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString());\n                case Token.GETPROP:\n        case Token.GETELEM:\n            return true;\n    }\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n        if (canBeSideEffected(c, knownConstants)) {\n            return true;\n        }\n    }\n    return false;\n}", "lc": 0.18181818181818182, "pi": 0.3540669856459329, "ma": 0.8, "nbd": 0.0, "ml": 0.5, "d": 0.32936507936507936, "mi": -0.19182522903453111, "fo": 0.08333333333333333, "r": 0.02631578947368421, "e": 0.2095560819026872}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3110_d10362c0", "label": 1, "code": "public Directory wrapForRead(String indexPath, IndexDefinition definition, Directory remote) throws IOException {\n    Directory local = createLocalDirForIndexReader(indexPath, definition);\n    return new CopyOnReadDirectory(remote, local, prefetchEnabled, indexPath);\n}", "code_comment": NaN, "code_no_comment": "public Directory wrapForRead(String indexPath, IndexDefinition definition, Directory remote) throws IOException {\n    Directory local = createLocalDirForIndexReader(indexPath, definition);\n    return new CopyOnReadDirectory(remote, local, prefetchEnabled, indexPath);\n}", "lc": -0.45454545454545453, "pi": -0.47368421052631593, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.6958421423537702, "fo": -0.4166666666666667, "r": 0.0, "e": -0.16279340490885932}
{"project_name": "Closure", "project_version": 130, "label": 2, "code": "/**\n * For each qualified name N in the global scope, we check if:\n * (a) No ancestor of N is ever aliased or assigned an unknown value type.\n *     (If N = \"a.b.c\", \"a\" and \"a.b\" are never aliased).\n * (b) N has exactly one write, and it lives in the global scope.\n * (c) N is aliased in a local scope.\n *\n * If (a) is true, then GlobalNamespace must know all the writes to N.\n * If (a) and (b) are true, then N cannot change during the execution of\n *    a local scope.\n * If (a) and (b) and (c) are true, then the alias can be inlined if the\n *    alias obeys the usual rules for how we decide whether a variable is\n *    inlineable.\n * @see InlineVariables\n */\nprivate void inlineAliases(GlobalNamespace namespace) {\n    // Invariant: All the names in the worklist meet condition (a).\n    Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n    while (!workList.isEmpty()) {\n        Name name = workList.pop();\n        // Don't attempt to inline a getter or setter property as a variable.\n        if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n            continue;\n        }\n        if (name.globalSets == 1 && name.localSets == 0 && name.aliasingGets > 0) {\n            // {@code name} meets condition (b). Find all of its local aliases\n            // and try to inline them.\n            List<Ref> refs = Lists.newArrayList(name.getRefs());\n            for (Ref ref : refs) {\n                if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n                    // {@code name} meets condition (c). Try to inline it.\n                    if (inlineAliasIfPossible(ref, namespace)) {\n                        name.removeRef(ref);\n                    }\n                }\n            }\n        }\n        // local-alias-inlining above.\n        if ((name.type == Name.Type.OBJECTLIT || name.type == Name.Type.FUNCTION) && name.aliasingGets == 0 && name.props != null) {\n            // All of {@code name}'s children meet condition (a), so they can be\n            // added to the worklist.\n            workList.addAll(name.props);\n        }\n    }\n}", "code_comment": "/**\n * For each qualified name N in the global scope, we check if:\n * (a) No ancestor of N is ever aliased or assigned an unknown value type.\n *     (If N = \"a.b.c\", \"a\" and \"a.b\" are never aliased).\n * (b) N has exactly one write, and it lives in the global scope.\n * (c) N is aliased in a local scope.\n *\n * If (a) is true, then GlobalNamespace must know all the writes to N.\n * If (a) and (b) are true, then N cannot change during the execution of\n *    a local scope.\n * If (a) and (b) and (c) are true, then the alias can be inlined if the\n *    alias obeys the usual rules for how we decide whether a variable is\n *    inlineable.\n * @see InlineVariables\n */\n", "code_no_comment": "private void inlineAliases(GlobalNamespace namespace) {\n        Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n    while (!workList.isEmpty()) {\n        Name name = workList.pop();\n                if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n            continue;\n        }\n        if (name.globalSets == 1 && name.localSets == 0 && name.aliasingGets > 0) {\n                                    List<Ref> refs = Lists.newArrayList(name.getRefs());\n            for (Ref ref : refs) {\n                if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n                                        if (inlineAliasIfPossible(ref, namespace)) {\n                        name.removeRef(ref);\n                    }\n                }\n            }\n        }\n                if ((name.type == Name.Type.OBJECTLIT || name.type == Name.Type.FUNCTION) && name.aliasingGets == 0 && name.props != null) {\n                                    workList.addAll(name.props);\n        }\n    }\n}", "lc": 0.36363636363636365, "pi": 1.4976076555023925, "ma": 1.0, "nbd": 1.5, "ml": 1.5833333333333333, "d": 0.8730158730158731, "mi": -0.4170542635658914, "fo": 0.25, "r": -0.02631578947368421, "e": 1.41633097629709}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1190_e29dc4f5", "label": 3, "code": "@Override\npublic void write(org.apache.thrift.protocol.TProtocol prot, update_result struct) throws org.apache.thrift.TException {\n    TTupleProtocol oprot = (TTupleProtocol) prot;\n    BitSet optionals = new BitSet();\n    if (struct.isSetOuch1()) {\n        optionals.set(0);\n    }\n    if (struct.isSetOuch2()) {\n        optionals.set(1);\n    }\n    oprot.writeBitSet(optionals, 2);\n    if (struct.isSetOuch1()) {\n        struct.ouch1.write(oprot);\n    }\n    if (struct.isSetOuch2()) {\n        struct.ouch2.write(oprot);\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void write(org.apache.thrift.protocol.TProtocol prot, update_result struct) throws org.apache.thrift.TException {\n    TTupleProtocol oprot = (TTupleProtocol) prot;\n    BitSet optionals = new BitSet();\n    if (struct.isSetOuch1()) {\n        optionals.set(0);\n    }\n    if (struct.isSetOuch2()) {\n        optionals.set(1);\n    }\n    oprot.writeBitSet(optionals, 2);\n    if (struct.isSetOuch1()) {\n        struct.ouch1.write(oprot);\n    }\n    if (struct.isSetOuch2()) {\n        struct.ouch2.write(oprot);\n    }\n}", "lc": 0.18181818181818182, "pi": -0.244019138755981, "ma": 0.2, "nbd": -0.5, "ml": 0.08333333333333333, "d": -0.3650793650793651, "mi": -0.17491190979563065, "fo": 0.25, "r": -0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3280_295e73bd", "label": 1, "code": "/**\n *  Processes components added to the target. This involves attaching components, rendering\n *  markup into a client side xml envelope, and detaching them\n *\n *  @param response\n */\nprivate void respondComponents(WebResponse response) {\n    // process component markup\n    for (Map.Entry<String, Component> stringComponentEntry : markupIdToComponent.entrySet()) {\n        final Component component = stringComponentEntry.getValue();\n        if (!containsAncestorFor(component)) {\n            respondComponent(response, getAjaxRegionMarkupId(component), component);\n        }\n    }\n    if (header != null) {\n        // some header responses buffer all calls to render*** until close is called.\n        // when they are closed, they do something (i.e. aggregate all JS resource urls to a\n        // single url), and then \"flush\" (by writing to the real response) before closing.\n        // to support this, we need to allow header contributions to be written in the close\n        // tag, which we do here:\n        headerRendering = true;\n        // save old response, set new\n        Response oldResponse = RequestCycle.get().setResponse(encodingHeaderResponse);\n        encodingHeaderResponse.reset();\n        // now, close the response (which may render things)\n        header.getHeaderResponse().close();\n        // revert to old response\n        RequestCycle.get().setResponse(oldResponse);\n        // write the XML tags and we're done\n        writeHeaderContribution(response);\n        headerRendering = false;\n    }\n}", "code_comment": "/**\n *  Processes components added to the target. This involves attaching components, rendering\n *  markup into a client side xml envelope, and detaching them\n *\n *  @param response\n */\n", "code_no_comment": "private void respondComponents(WebResponse response) {\n        for (Map.Entry<String, Component> stringComponentEntry : markupIdToComponent.entrySet()) {\n        final Component component = stringComponentEntry.getValue();\n        if (!containsAncestorFor(component)) {\n            respondComponent(response, getAjaxRegionMarkupId(component), component);\n        }\n    }\n    if (header != null) {\n                                                headerRendering = true;\n                Response oldResponse = RequestCycle.get().setResponse(encodingHeaderResponse);\n        encodingHeaderResponse.reset();\n                header.getHeaderResponse().close();\n                RequestCycle.get().setResponse(oldResponse);\n                writeHeaderContribution(response);\n        headerRendering = false;\n    }\n}", "lc": 0.13636363636363635, "pi": 0.04784688995215294, "ma": 0.0, "nbd": 0.0, "ml": 0.0, "d": -0.07738095238095241, "mi": -0.1568710359408033, "fo": 0.5833333333333334, "r": -0.02631578947368421, "e": 0.010850434812676113}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1190_e29dc4f5", "label": 3, "code": "public void update(String writer, Map<ByteBuffer, List<ColumnUpdate>> cells) throws UnknownWriter, MutationsRejectedException, org.apache.thrift.TException {\n    send_update(writer, cells);\n    recv_update();\n}", "code_comment": NaN, "code_no_comment": "public void update(String writer, Map<ByteBuffer, List<ColumnUpdate>> cells) throws UnknownWriter, MutationsRejectedException, org.apache.thrift.TException {\n    send_update(writer, cells);\n    recv_update();\n}", "lc": -0.45454545454545453, "pi": -0.47368421052631593, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.7000704721634955, "fo": -0.3333333333333333, "r": -0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "maven", "project_version": "remotes/origin/bugs-dot-jar_MNG-5687_3d2d8619", "label": 1, "code": "public List<MavenProject> getUpstreamProjects(MavenProject project, boolean transitive) {\n    if (project == null) {\n        throw new IllegalArgumentException(\"project missing\");\n    }\n    Collection<String> projectIds = new HashSet<String>();\n    getUpstreamProjects(ProjectSorter.getId(project), projectIds, transitive);\n    return getProjects(projectIds);\n}", "code_comment": NaN, "code_no_comment": "public List<MavenProject> getUpstreamProjects(MavenProject project, boolean transitive) {\n    if (project == null) {\n        throw new IllegalArgumentException(\"project missing\");\n    }\n    Collection<String> projectIds = new HashSet<String>();\n    getUpstreamProjects(ProjectSorter.getId(project), projectIds, transitive);\n    return getProjects(projectIds);\n}", "lc": -0.2727272727272727, "pi": -0.2822966507177035, "ma": -0.2, "nbd": -0.5, "ml": -0.25, "d": -0.06746031746031747, "mi": 0.32177589852008465, "fo": -0.25, "r": 0.10526315789473684, "e": -0.08781544809621779}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-1619_b154d12f", "label": 1, "code": "/**\n *  Create a new PagingNavigation. May be subclassed to make us of specialized PagingNavigation.\n *\n *  @param pageable\n *             the pageable component\n *  @param labelProvider\n *             The label provider for the link text.\n *  @return the navigation object\n */\nprotected PagingNavigation newNavigation(final IPageable pageable, final IPagingLabelProvider labelProvider) {\n    return new PagingNavigation(\"navigation\", pageable, labelProvider) {\n\n        private static final long serialVersionUID = 1L;\n\n        @Override\n        public boolean isEnabled() {\n            return PagingNavigator.this.isEnabled() && PagingNavigator.this.isEnableAllowed();\n        }\n    };\n}", "code_comment": "/**\n *  Create a new PagingNavigation. May be subclassed to make us of specialized PagingNavigation.\n *\n *  @param pageable\n *             the pageable component\n *  @param labelProvider\n *             The label provider for the link text.\n *  @return the navigation object\n */\n", "code_no_comment": "protected PagingNavigation newNavigation(final IPageable pageable, final IPagingLabelProvider labelProvider) {\n    return new PagingNavigation(\"navigation\", pageable, labelProvider) {\n\n        private static final long serialVersionUID = 1L;\n\n        @Override\n        public boolean isEnabled() {\n            return PagingNavigator.this.isEnabled() && PagingNavigator.this.isEnableAllowed();\n        }\n    };\n}", "lc": -0.22727272727272727, "pi": 0.39712918660287067, "ma": -0.6, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.09523809523809523, "mi": 0.3181113460183226, "fo": -0.3333333333333333, "r": 2.131578947368421, "e": -0.11023553073655941}
{"project_name": "Lang", "project_version": 52, "label": 3, "code": "/**\n * <p>Worker method for the {@link #escapeJavaScript(String)} method.</p>\n *\n * @param out write to receieve the escaped string\n * @param str String to escape values in, may be null\n * @param escapeSingleQuote escapes single quotes if <code>true</code>\n * @throws IOException if an IOException occurs\n */\nprivate static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (str == null) {\n        return;\n    }\n    int sz;\n    sz = str.length();\n    for (int i = 0; i < sz; i++) {\n        char ch = str.charAt(i);\n        // handle unicode\n        if (ch > 0xfff) {\n            out.write(\"\\\\u\" + hex(ch));\n        } else if (ch > 0xff) {\n            out.write(\"\\\\u0\" + hex(ch));\n        } else if (ch > 0x7f) {\n            out.write(\"\\\\u00\" + hex(ch));\n        } else if (ch < 32) {\n            switch(ch) {\n                case '\\b':\n                    out.write('\\\\');\n                    out.write('b');\n                    break;\n                case '\\n':\n                    out.write('\\\\');\n                    out.write('n');\n                    break;\n                case '\\t':\n                    out.write('\\\\');\n                    out.write('t');\n                    break;\n                case '\\f':\n                    out.write('\\\\');\n                    out.write('f');\n                    break;\n                case '\\r':\n                    out.write('\\\\');\n                    out.write('r');\n                    break;\n                default:\n                    if (ch > 0xf) {\n                        out.write(\"\\\\u00\" + hex(ch));\n                    } else {\n                        out.write(\"\\\\u000\" + hex(ch));\n                    }\n                    break;\n            }\n        } else {\n            switch(ch) {\n                case '\\'':\n                    if (escapeSingleQuote) {\n                        out.write('\\\\');\n                    }\n                    out.write('\\'');\n                    break;\n                case '\"':\n                    out.write('\\\\');\n                    out.write('\"');\n                    break;\n                case '\\\\':\n                    out.write('\\\\');\n                    out.write('\\\\');\n                    break;\n                default:\n                    out.write(ch);\n                    break;\n            }\n        }\n    }\n}", "code_comment": "/**\n * <p>Worker method for the {@link #escapeJavaScript(String)} method.</p>\n *\n * @param out write to receieve the escaped string\n * @param str String to escape values in, may be null\n * @param escapeSingleQuote escapes single quotes if <code>true</code>\n * @throws IOException if an IOException occurs\n */\n", "code_no_comment": "private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (str == null) {\n        return;\n    }\n    int sz;\n    sz = str.length();\n    for (int i = 0; i < sz; i++) {\n        char ch = str.charAt(i);\n                if (ch > 0xfff) {\n            out.write(\"\\\\u\" + hex(ch));\n        } else if (ch > 0xff) {\n            out.write(\"\\\\u0\" + hex(ch));\n        } else if (ch > 0x7f) {\n            out.write(\"\\\\u00\" + hex(ch));\n        } else if (ch < 32) {\n            switch(ch) {\n                case '\\b':\n                    out.write('\\\\');\n                    out.write('b');\n                    break;\n                case '\\n':\n                    out.write('\\\\');\n                    out.write('n');\n                    break;\n                case '\\t':\n                    out.write('\\\\');\n                    out.write('t');\n                    break;\n                case '\\f':\n                    out.write('\\\\');\n                    out.write('f');\n                    break;\n                case '\\r':\n                    out.write('\\\\');\n                    out.write('r');\n                    break;\n                default:\n                    if (ch > 0xf) {\n                        out.write(\"\\\\u00\" + hex(ch));\n                    } else {\n                        out.write(\"\\\\u000\" + hex(ch));\n                    }\n                    break;\n            }\n        } else {\n            switch(ch) {\n                case '\\'':\n                    if (escapeSingleQuote) {\n                        out.write('\\\\');\n                    }\n                    out.write('\\'');\n                    break;\n                case '\"':\n                    out.write('\\\\');\n                    out.write('\"');\n                    break;\n                case '\\\\':\n                    out.write('\\\\');\n                    out.write('\\\\');\n                    break;\n                default:\n                    out.write(ch);\n                    break;\n            }\n        }\n    }\n}", "lc": 2.5454545454545454, "pi": 1.674641148325359, "ma": 5.4, "nbd": 3.0, "ml": 1.5, "d": 1.4345238095238095, "mi": -1.140380549682875, "fo": 1.9166666666666667, "r": -0.02631578947368421, "e": 3.11335096788322}