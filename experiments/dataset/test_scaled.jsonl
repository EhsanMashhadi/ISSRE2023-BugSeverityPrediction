{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-3260_6968a57a", "label": 0, "code": "public void cancel() {\n    // successful atomic state transition\n    while (true) {\n        ExecutionState current = this.state;\n        if (current == CANCELING || current == CANCELED) {\n            // already taken care of, no need to cancel again\n            return;\n        } else // these two are the common cases where we need to send a cancel call\n        if (current == RUNNING || current == DEPLOYING) {\n            // try to transition to canceling, if successful, send the cancel call\n            if (transitionState(current, CANCELING)) {\n                sendCancelRpcCall();\n                return;\n            }\n        // else: fall through the loop\n        } else if (current == FINISHED || current == FAILED) {\n            // nothing to do any more. finished failed before it could be cancelled.\n            // in any case, the task is removed from the TaskManager already\n            sendFailIntermediateResultPartitionsRpcCall();\n            return;\n        } else if (current == CREATED || current == SCHEDULED) {\n            // from here, we can directly switch to cancelled, because the no task has been deployed\n            if (transitionState(current, CANCELED)) {\n                // we skip the canceling state. set the timestamp, for a consistent appearance\n                markTimestamp(CANCELING, getStateTimestamp(CANCELED));\n                try {\n                    vertex.getExecutionGraph().deregisterExecution(this);\n                    if (assignedResource != null) {\n                        assignedResource.releaseSlot();\n                    }\n                } finally {\n                    vertex.executionCanceled();\n                }\n                return;\n            }\n        // else: fall through the loop\n        } else {\n            throw new IllegalStateException(current.name());\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "public void cancel() {\n        while (true) {\n        ExecutionState current = this.state;\n        if (current == CANCELING || current == CANCELED) {\n                        return;\n        } else         if (current == RUNNING || current == DEPLOYING) {\n                        if (transitionState(current, CANCELING)) {\n                sendCancelRpcCall();\n                return;\n            }\n                } else if (current == FINISHED || current == FAILED) {\n                                    sendFailIntermediateResultPartitionsRpcCall();\n            return;\n        } else if (current == CREATED || current == SCHEDULED) {\n                        if (transitionState(current, CANCELED)) {\n                                markTimestamp(CANCELING, getStateTimestamp(CANCELED));\n                try {\n                    vertex.getExecutionGraph().deregisterExecution(this);\n                    if (assignedResource != null) {\n                        assignedResource.releaseSlot();\n                    }\n                } finally {\n                    vertex.executionCanceled();\n                }\n                return;\n            }\n                } else {\n            throw new IllegalStateException(current.name());\n        }\n    }\n}", "lc": 0.8181818181818182, "pi": 1.3157894736842106, "ma": 1.2, "nbd": 3.0, "ml": 0.9166666666666666, "d": 0.2876984126984127, "mi": -0.5058491895701195, "fo": 0.4166666666666667, "r": -0.02631578947368421, "e": 0.29165240342778764}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-172_99e22ce4", "label": 1, "code": "private final Component children_remove(Component<?> component) {\n    int index = children_indexOf(component);\n    if (index != -1) {\n        return children_remove(index);\n    }\n    return null;\n}", "code_comment": NaN, "code_no_comment": "private final Component children_remove(Component<?> component) {\n    int index = children_indexOf(component);\n    if (index != -1) {\n        return children_remove(index);\n    }\n    return null;\n}", "lc": -0.3181818181818182, "pi": -0.20574162679425848, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": -0.04365079365079365, "mi": 0.48780831571529254, "fo": -0.3333333333333333, "r": 1.6052631578947367, "e": -0.12132339805097883}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-639_a5a1f1a2", "label": 1, "code": "@Override\npublic void logMessage(final String fqcn, final Level level, final Marker marker, final Message message, final Throwable thrown) {\n    Info info = threadlocalInfo.get();\n    if (info == null) {\n        info = new Info(new RingBufferLogEventTranslator(), Thread.currentThread().getName(), false);\n        threadlocalInfo.set(info);\n    }\n    // being logged calls Logger.log() from its toString() method\n    if (info.isAppenderThread && disruptor.getRingBuffer().remainingCapacity() == 0) {\n        // bypass RingBuffer and invoke Appender directly\n        config.loggerConfig.log(getName(), fqcn, marker, level, message, thrown);\n        return;\n    }\n    final boolean includeLocation = config.loggerConfig.isIncludeLocation();\n    // \n    info.translator.setValues(// \n    this, // \n    getName(), // \n    marker, // \n    fqcn, // \n    level, // \n    message, // \n    thrown, // \n    ThreadContext.getImmutableContext(), // \n    ThreadContext.getImmutableStack(), // LOG4J2-467\n    THREAD_NAME_STRATEGY.getThreadName(info), // exclude if not specified or if \"false\" was specified.\n    includeLocation ? location(fqcn) : null, // CachedClock: 10% faster than system clock, smaller gaps\n    clock.currentTimeMillis());\n    disruptor.publishEvent(info.translator);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void logMessage(final String fqcn, final Level level, final Marker marker, final Message message, final Throwable thrown) {\n    Info info = threadlocalInfo.get();\n    if (info == null) {\n        info = new Info(new RingBufferLogEventTranslator(), Thread.currentThread().getName(), false);\n        threadlocalInfo.set(info);\n    }\n        if (info.isAppenderThread && disruptor.getRingBuffer().remainingCapacity() == 0) {\n                config.loggerConfig.log(getName(), fqcn, marker, level, message, thrown);\n        return;\n    }\n    final boolean includeLocation = config.loggerConfig.isIncludeLocation();\n        info.translator.setValues(    this,     getName(),     marker,     fqcn,     level,     message,     thrown,     ThreadContext.getImmutableContext(),     ThreadContext.getImmutableStack(),     THREAD_NAME_STRATEGY.getThreadName(info),     includeLocation ? location(fqcn) : null,     clock.currentTimeMillis());\n    disruptor.publishEvent(info.translator);\n}", "lc": 0.5909090909090909, "pi": -0.4593301435406701, "ma": 0.0, "nbd": -0.5, "ml": 0.25, "d": -0.039682539682539715, "mi": -0.4477801268498943, "fo": 0.9166666666666666, "r": -0.02631578947368421, "e": 0.17594209413161366}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4301_50b52742", "label": 3, "code": "@Override\nprotected ResourceResponse newResourceResponse(final Attributes attributes) {\n    final ResourceResponse response = new ResourceResponse();\n    if (lastModifiedTime != null) {\n        response.setLastModified(lastModifiedTime);\n    } else {\n        response.setLastModified(Time.now());\n    }\n    if (response.dataNeedsToBeWritten(attributes)) {\n        response.setContentType(\"image/\" + getFormat());\n        response.setContentDisposition(ContentDisposition.INLINE);\n        final byte[] imageData = getImageData(attributes);\n        if (imageData == null) {\n            response.setError(HttpServletResponse.SC_NOT_FOUND);\n        } else {\n            response.setWriteCallback(new WriteCallback() {\n\n                @Override\n                public void writeData(final Attributes attributes) {\n                    attributes.getResponse().write(imageData);\n                }\n            });\n        }\n        configureResponse(response, attributes);\n    }\n    return response;\n}", "code_comment": NaN, "code_no_comment": "@Override\nprotected ResourceResponse newResourceResponse(final Attributes attributes) {\n    final ResourceResponse response = new ResourceResponse();\n    if (lastModifiedTime != null) {\n        response.setLastModified(lastModifiedTime);\n    } else {\n        response.setLastModified(Time.now());\n    }\n    if (response.dataNeedsToBeWritten(attributes)) {\n        response.setContentType(\"image/\" + getFormat());\n        response.setContentDisposition(ContentDisposition.INLINE);\n        final byte[] imageData = getImageData(attributes);\n        if (imageData == null) {\n            response.setError(HttpServletResponse.SC_NOT_FOUND);\n        } else {\n            response.setWriteCallback(new WriteCallback() {\n\n                @Override\n                public void writeData(final Attributes attributes) {\n                    attributes.getResponse().write(imageData);\n                }\n            });\n        }\n        configureResponse(response, attributes);\n    }\n    return response;\n}", "lc": 0.5454545454545454, "pi": 1.0287081339712916, "ma": 0.0, "nbd": 0.5, "ml": 0.16666666666666666, "d": 0.33531746031746024, "mi": -0.36969696969696947, "fo": 0.5833333333333334, "r": -0.02631578947368421, "e": 0.31787601643586144}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-639_a5a1f1a2", "label": 1, "code": "/**\n * If possible, delegates the invocation to {@code callAppenders} to another\n * thread and returns {@code true}. If this is not possible (if it detects\n * that delegating to another thread would cause deadlock because the\n * current call to Logger.log() originated from the appender thread and the\n * ringbuffer is full) then this method does nothing and returns {@code false}.\n * It is the responsibility of the caller to process the event when this\n * method returns {@code false}.\n *\n * @param event the event to delegate to another thread\n * @return {@code true} if delegation was successful, {@code false} if the\n *          calling thread needs to process the event itself\n */\npublic boolean callAppendersFromAnotherThread(final LogEvent event) {\n    // being logged calls Logger.log() from its toString() method\n    if (// \n    isAppenderThread.get() == Boolean.TRUE && disruptor.getRingBuffer().remainingCapacity() == 0) {\n        // bypass RingBuffer and invoke Appender directly\n        return false;\n    }\n    disruptor.getRingBuffer().publishEvent(translator, event, asyncLoggerConfig);\n    return true;\n}", "code_comment": "/**\n * If possible, delegates the invocation to {@code callAppenders} to another\n * thread and returns {@code true}. If this is not possible (if it detects\n * that delegating to another thread would cause deadlock because the\n * current call to Logger.log() originated from the appender thread and the\n * ringbuffer is full) then this method does nothing and returns {@code false}.\n * It is the responsibility of the caller to process the event when this\n * method returns {@code false}.\n *\n * @param event the event to delegate to another thread\n * @return {@code true} if delegation was successful, {@code false} if the\n *          calling thread needs to process the event itself\n */\n", "code_no_comment": "public boolean callAppendersFromAnotherThread(final LogEvent event) {\n        if (    isAppenderThread.get() == Boolean.TRUE && disruptor.getRingBuffer().remainingCapacity() == 0) {\n                return false;\n    }\n    disruptor.getRingBuffer().publishEvent(translator, event, asyncLoggerConfig);\n    return true;\n}", "lc": -0.2727272727272727, "pi": -0.2822966507177035, "ma": -0.4, "nbd": -0.5, "ml": -0.08333333333333333, "d": -0.130952380952381, "mi": 0.3434813248766737, "fo": -0.08333333333333333, "r": 0.02631578947368421, "e": -0.10980215879162993}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-3229_891584fb", "label": 1, "code": "public void printVerboseInfo() throws IOException {\n    StringBuilder sb = new StringBuilder(\"-\\n\");\n    sb.append(\"- Current user: \").append(connector.whoami()).append(\"\\n\");\n    if (execFile != null)\n        sb.append(\"- Executing commands from: \").append(execFile).append(\"\\n\");\n    if (disableAuthTimeout)\n        sb.append(\"- Authorization timeout: disabled\\n\");\n    else\n        sb.append(\"- Authorization timeout: \").append(String.format(\"%.2fs%n\", TimeUnit.NANOSECONDS.toSeconds(authTimeout)));\n    sb.append(\"- Debug: \").append(isDebuggingEnabled() ? \"on\" : \"off\").append(\"\\n\");\n    if (!scanIteratorOptions.isEmpty()) {\n        for (Entry<String, List<IteratorSetting>> entry : scanIteratorOptions.entrySet()) {\n            sb.append(\"- Session scan iterators for table \").append(entry.getKey()).append(\":\\n\");\n            for (IteratorSetting setting : entry.getValue()) {\n                sb.append(\"-    Iterator \").append(setting.getName()).append(\" options:\\n\");\n                sb.append(\"-        \").append(\"iteratorPriority\").append(\" = \").append(setting.getPriority()).append(\"\\n\");\n                sb.append(\"-        \").append(\"iteratorClassName\").append(\" = \").append(setting.getIteratorClass()).append(\"\\n\");\n                for (Entry<String, String> optEntry : setting.getOptions().entrySet()) {\n                    sb.append(\"-        \").append(optEntry.getKey()).append(\" = \").append(optEntry.getValue()).append(\"\\n\");\n                }\n            }\n        }\n    }\n    sb.append(\"-\\n\");\n    reader.printString(sb.toString());\n}", "code_comment": NaN, "code_no_comment": "public void printVerboseInfo() throws IOException {\n    StringBuilder sb = new StringBuilder(\"-\\n\");\n    sb.append(\"- Current user: \").append(connector.whoami()).append(\"\\n\");\n    if (execFile != null)\n        sb.append(\"- Executing commands from: \").append(execFile).append(\"\\n\");\n    if (disableAuthTimeout)\n        sb.append(\"- Authorization timeout: disabled\\n\");\n    else\n        sb.append(\"- Authorization timeout: \").append(String.format(\"%.2fs%n\", TimeUnit.NANOSECONDS.toSeconds(authTimeout)));\n    sb.append(\"- Debug: \").append(isDebuggingEnabled() ? \"on\" : \"off\").append(\"\\n\");\n    if (!scanIteratorOptions.isEmpty()) {\n        for (Entry<String, List<IteratorSetting>> entry : scanIteratorOptions.entrySet()) {\n            sb.append(\"- Session scan iterators for table \").append(entry.getKey()).append(\":\\n\");\n            for (IteratorSetting setting : entry.getValue()) {\n                sb.append(\"-    Iterator \").append(setting.getName()).append(\" options:\\n\");\n                sb.append(\"-        \").append(\"iteratorPriority\").append(\" = \").append(setting.getPriority()).append(\"\\n\");\n                sb.append(\"-        \").append(\"iteratorClassName\").append(\" = \").append(setting.getIteratorClass()).append(\"\\n\");\n                for (Entry<String, String> optEntry : setting.getOptions().entrySet()) {\n                    sb.append(\"-        \").append(optEntry.getKey()).append(\" = \").append(optEntry.getValue()).append(\"\\n\");\n                }\n            }\n        }\n    }\n    sb.append(\"-\\n\");\n    reader.printString(sb.toString());\n}", "lc": 0.5454545454545454, "pi": 1.2200956937799043, "ma": 0.8, "nbd": 1.0, "ml": 0.25, "d": 0.10515873015873016, "mi": -0.5351656095842141, "fo": 3.75, "r": -0.02631578947368421, "e": 0.6722405675328341}
{"project_name": "Math", "project_version": 84, "label": 0, "code": "/**\n * {@inheritDoc}\n */\n@Override\nprotected void iterateSimplex(final Comparator<RealPointValuePair> comparator) throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n    while (true) {\n        incrementIterationsCounter();\n        // save the original vertex\n        final RealPointValuePair[] original = simplex;\n        final RealPointValuePair best = original[0];\n        // perform a reflection step\n        final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n        if (comparator.compare(reflected, best) < 0) {\n            // compute the expanded simplex\n            final RealPointValuePair[] reflectedSimplex = simplex;\n            final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n            if (comparator.compare(reflected, expanded) <= 0) {\n                // accept the reflected simplex\n                simplex = reflectedSimplex;\n            }\n            return;\n        }\n        // compute the contracted simplex\n        final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n        if (comparator.compare(contracted, best) < 0) {\n            // check convergence\n            return;\n        }\n    }\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "@Override\nprotected void iterateSimplex(final Comparator<RealPointValuePair> comparator) throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n    while (true) {\n        incrementIterationsCounter();\n                final RealPointValuePair[] original = simplex;\n        final RealPointValuePair best = original[0];\n                final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n        if (comparator.compare(reflected, best) < 0) {\n                        final RealPointValuePair[] reflectedSimplex = simplex;\n            final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n            if (comparator.compare(reflected, expanded) <= 0) {\n                                simplex = reflectedSimplex;\n            }\n            return;\n        }\n                final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n        if (comparator.compare(contracted, best) < 0) {\n                        return;\n        }\n    }\n}", "lc": 0.3181818181818182, "pi": 0.6172248803827752, "ma": 0.2, "nbd": 0.5, "ml": 0.5, "d": 0.09722222222222222, "mi": -0.28794926004228333, "fo": 0.08333333333333333, "r": -0.02631578947368421, "e": 0.17479872985137412}
{"project_name": "Closure", "project_version": 148, "label": 2, "code": "/**\n * Folds 'typeof(foo)' if foo is a literal, e.g.\n * typeof(\"bar\") --> \"string\"\n * typeof(6) --> \"number\"\n */\nprivate Node tryFoldTypeof(Node originalTypeofNode) {\n    Preconditions.checkArgument(originalTypeofNode.getType() == Token.TYPEOF);\n    Node argumentNode = originalTypeofNode.getFirstChild();\n    if (argumentNode == null || !NodeUtil.isLiteralValue(argumentNode)) {\n        return originalTypeofNode;\n    }\n    String typeNameString = null;\n    switch(argumentNode.getType()) {\n        case Token.STRING:\n            typeNameString = \"string\";\n            break;\n        case Token.NUMBER:\n            typeNameString = \"number\";\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            typeNameString = \"boolean\";\n            break;\n        case Token.NULL:\n        case Token.OBJECTLIT:\n        case Token.ARRAYLIT:\n            typeNameString = \"object\";\n            break;\n        case Token.NAME:\n            // keyword undefined to something other than the value undefined.\n            if (\"undefined\".equals(argumentNode.getString())) {\n                typeNameString = \"undefined\";\n            }\n            break;\n    }\n    if (typeNameString != null) {\n        Node newNode = Node.newString(typeNameString);\n        originalTypeofNode.getParent().replaceChild(originalTypeofNode, newNode);\n        reportCodeChange();\n        return newNode;\n    }\n    return originalTypeofNode;\n}", "code_comment": "/**\n * Folds 'typeof(foo)' if foo is a literal, e.g.\n * typeof(\"bar\") --> \"string\"\n * typeof(6) --> \"number\"\n */\n", "code_no_comment": "private Node tryFoldTypeof(Node originalTypeofNode) {\n    Preconditions.checkArgument(originalTypeofNode.getType() == Token.TYPEOF);\n    Node argumentNode = originalTypeofNode.getFirstChild();\n    if (argumentNode == null || !NodeUtil.isLiteralValue(argumentNode)) {\n        return originalTypeofNode;\n    }\n    String typeNameString = null;\n    switch(argumentNode.getType()) {\n        case Token.STRING:\n            typeNameString = \"string\";\n            break;\n        case Token.NUMBER:\n            typeNameString = \"number\";\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            typeNameString = \"boolean\";\n            break;\n        case Token.NULL:\n        case Token.OBJECTLIT:\n        case Token.ARRAYLIT:\n            typeNameString = \"object\";\n            break;\n        case Token.NAME:\n                        if (\"undefined\".equals(argumentNode.getString())) {\n                typeNameString = \"undefined\";\n            }\n            break;\n    }\n    if (typeNameString != null) {\n        Node newNode = Node.newString(typeNameString);\n        originalTypeofNode.getParent().replaceChild(originalTypeofNode, newNode);\n        reportCodeChange();\n        return newNode;\n    }\n    return originalTypeofNode;\n}", "lc": 1.0454545454545454, "pi": 0.3779904306220094, "ma": 2.6, "nbd": 0.5, "ml": 1.0833333333333333, "d": 0.4166666666666666, "mi": -0.6772374911909795, "fo": 0.4166666666666667, "r": -0.02631578947368421, "e": 0.6556064613912852}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4839_8b294488", "label": 1, "code": "/**\n *  Gets the type converter that is registered for class c.\n *\n *  @param <C>\n *             The object to convert from and to String\n *  @param c\n *             The class to get the type converter for\n *  @return The type converter that is registered for class c or null if no type converter was\n *          registered for class c\n */\npublic final <C> IConverter<C> get(Class<C> c) {\n    @SuppressWarnings(\"unchecked\")\n    final IConverter<C> converter;\n    // a new instance should be created for each usage\n    if (Date.class.equals(c)) {\n        converter = (IConverter<C>) new DateConverter();\n    } else if (java.sql.Date.class.equals(c)) {\n        converter = (IConverter<C>) new SqlDateConverter();\n    } else if (java.sql.Time.class.equals(c)) {\n        converter = (IConverter<C>) new SqlTimeConverter();\n    } else if (java.sql.Timestamp.class.equals(c)) {\n        converter = (IConverter<C>) new SqlTimestampConverter();\n    } else if (Calendar.class.equals(c)) {\n        converter = (IConverter<C>) new CalendarConverter();\n    } else {\n        converter = (IConverter<C>) classToConverter.get(c.getName());\n    }\n    return converter;\n}", "code_comment": "/**\n *  Gets the type converter that is registered for class c.\n *\n *  @param <C>\n *             The object to convert from and to String\n *  @param c\n *             The class to get the type converter for\n *  @return The type converter that is registered for class c or null if no type converter was\n *          registered for class c\n */\n", "code_no_comment": "public final <C> IConverter<C> get(Class<C> c) {\n    @SuppressWarnings(\"unchecked\")\n    final IConverter<C> converter;\n        if (Date.class.equals(c)) {\n        converter = (IConverter<C>) new DateConverter();\n    } else if (java.sql.Date.class.equals(c)) {\n        converter = (IConverter<C>) new SqlDateConverter();\n    } else if (java.sql.Time.class.equals(c)) {\n        converter = (IConverter<C>) new SqlTimeConverter();\n    } else if (java.sql.Timestamp.class.equals(c)) {\n        converter = (IConverter<C>) new SqlTimestampConverter();\n    } else if (Calendar.class.equals(c)) {\n        converter = (IConverter<C>) new CalendarConverter();\n    } else {\n        converter = (IConverter<C>) classToConverter.get(c.getName());\n    }\n    return converter;\n}", "lc": 0.18181818181818182, "pi": -0.22966507177033516, "ma": 0.4, "nbd": 1.5, "ml": 0.5, "d": -0.3650793650793651, "mi": -0.22283298097251583, "fo": 0.08333333333333333, "r": -0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "Cli", "project_version": 22, "label": 1, "code": "/**\n * <p>If an {@link Option} exists for <code>token</code> then\n * add the token to the processed list.</p>\n *\n * <p>If an {@link Option} does not exist and <code>stopAtNonOption</code>\n * is set then add the remaining tokens to the processed tokens list\n * directly.</p>\n *\n * @param token The current option token\n * @param stopAtNonOption Specifies whether flattening should halt\n * at the first non option.\n */\nprivate void processOptionToken(String token, boolean stopAtNonOption) {\n    if (stopAtNonOption && !options.hasOption(token)) {\n        eatTheRest = true;\n    }\n    tokens.add(token);\n}", "code_comment": "/**\n * <p>If an {@link Option} exists for <code>token</code> then\n * add the token to the processed list.</p>\n *\n * <p>If an {@link Option} does not exist and <code>stopAtNonOption</code>\n * is set then add the remaining tokens to the processed tokens list\n * directly.</p>\n *\n * @param token The current option token\n * @param stopAtNonOption Specifies whether flattening should halt\n * at the first non option.\n */\n", "code_no_comment": "private void processOptionToken(String token, boolean stopAtNonOption) {\n    if (stopAtNonOption && !options.hasOption(token)) {\n        eatTheRest = true;\n    }\n    tokens.add(token);\n}", "lc": -0.36363636363636365, "pi": -0.11483253588516758, "ma": -0.4, "nbd": -0.5, "ml": 0.0, "d": -0.11309523809523811, "mi": 0.5351656095842141, "fo": -0.3333333333333333, "r": 1.2105263157894737, "e": -0.12481342530961312}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-5515_b3bb8670", "label": 1, "code": "/**\n * Continues processing the {@link org.apache.camel.Exchange} using asynchronous routing engine.\n *\n * @param poolSize the core pool size\n * @return the builder\n */\npublic ThreadsDefinition threads(int poolSize) {\n    ThreadsDefinition answer = threads();\n    answer.setPoolSize(poolSize);\n    addOutput(answer);\n    return answer;\n}", "code_comment": "/**\n * Continues processing the {@link org.apache.camel.Exchange} using asynchronous routing engine.\n *\n * @param poolSize the core pool size\n * @return the builder\n */\n", "code_no_comment": "public ThreadsDefinition threads(int poolSize) {\n    ThreadsDefinition answer = threads();\n    answer.setPoolSize(poolSize);\n    addOutput(answer);\n    return answer;\n}", "lc": -0.36363636363636365, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.6050739957716701, "fo": -0.25, "r": 2.5, "e": -0.16279340490885932}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-9238_169b981e", "label": 1, "code": "/**\n * Changes the name of this remote file. This method alters the absolute and\n * relative names as well.\n *\n * @param newName the new name\n */\npublic void changeFileName(String newName) {\n    LOG.trace(\"Changing name to: {}\", newName);\n    // Make sure the names is normalized.\n    String newFileName = FileUtil.normalizePath(newName);\n    String newEndpointPath = FileUtil.normalizePath(endpointPath);\n    LOG.trace(\"Normalized endpointPath: {}\", newEndpointPath);\n    LOG.trace(\"Normalized newFileName: ()\", newFileName);\n    File file = new File(newFileName);\n    if (!absolute) {\n        // for relative then we should avoid having the endpoint path duplicated so clip it\n        if (ObjectHelper.isNotEmpty(newEndpointPath) && newFileName.startsWith(newEndpointPath)) {\n            // in this logic here\n            if (newEndpointPath.endsWith(\"\" + File.separatorChar)) {\n                newFileName = ObjectHelper.after(newFileName, newEndpointPath);\n            } else {\n                newFileName = ObjectHelper.after(newFileName, newEndpointPath + File.separatorChar);\n            }\n            // reconstruct file with clipped name\n            file = new File(newFileName);\n        }\n    }\n    // store the file name only\n    setFileNameOnly(file.getName());\n    setFileName(file.getName());\n    // relative path\n    if (file.getParent() != null) {\n        setRelativeFilePath(file.getParent() + getFileSeparator() + file.getName());\n    } else {\n        setRelativeFilePath(file.getName());\n    }\n    // absolute path\n    if (isAbsolute(newFileName)) {\n        setAbsolute(true);\n        setAbsoluteFilePath(newFileName);\n    } else {\n        setAbsolute(false);\n        // construct a pseudo absolute filename that the file operations uses even for relative only\n        String path = ObjectHelper.isEmpty(endpointPath) ? \"\" : endpointPath + getFileSeparator();\n        setAbsoluteFilePath(path + getRelativeFilePath());\n    }\n    if (LOG.isTraceEnabled()) {\n        LOG.trace(\"FileNameOnly: {}\", getFileNameOnly());\n        LOG.trace(\"FileName: {}\", getFileName());\n        LOG.trace(\"Absolute: {}\", isAbsolute());\n        LOG.trace(\"Relative path: {}\", getRelativeFilePath());\n        LOG.trace(\"Absolute path: {}\", getAbsoluteFilePath());\n        LOG.trace(\"Name changed to: {}\", this);\n    }\n}", "code_comment": "/**\n * Changes the name of this remote file. This method alters the absolute and\n * relative names as well.\n *\n * @param newName the new name\n */\n", "code_no_comment": "public void changeFileName(String newName) {\n    LOG.trace(\"Changing name to: {}\", newName);\n        String newFileName = FileUtil.normalizePath(newName);\n    String newEndpointPath = FileUtil.normalizePath(endpointPath);\n    LOG.trace(\"Normalized endpointPath: {}\", newEndpointPath);\n    LOG.trace(\"Normalized newFileName: ()\", newFileName);\n    File file = new File(newFileName);\n    if (!absolute) {\n                if (ObjectHelper.isNotEmpty(newEndpointPath) && newFileName.startsWith(newEndpointPath)) {\n                        if (newEndpointPath.endsWith(\"\" + File.separatorChar)) {\n                newFileName = ObjectHelper.after(newFileName, newEndpointPath);\n            } else {\n                newFileName = ObjectHelper.after(newFileName, newEndpointPath + File.separatorChar);\n            }\n                        file = new File(newFileName);\n        }\n    }\n        setFileNameOnly(file.getName());\n    setFileName(file.getName());\n        if (file.getParent() != null) {\n        setRelativeFilePath(file.getParent() + getFileSeparator() + file.getName());\n    } else {\n        setRelativeFilePath(file.getName());\n    }\n        if (isAbsolute(newFileName)) {\n        setAbsolute(true);\n        setAbsoluteFilePath(newFileName);\n    } else {\n        setAbsolute(false);\n                String path = ObjectHelper.isEmpty(endpointPath) ? \"\" : endpointPath + getFileSeparator();\n        setAbsoluteFilePath(path + getRelativeFilePath());\n    }\n    if (LOG.isTraceEnabled()) {\n        LOG.trace(\"FileNameOnly: {}\", getFileNameOnly());\n        LOG.trace(\"FileName: {}\", getFileName());\n        LOG.trace(\"Absolute: {}\", isAbsolute());\n        LOG.trace(\"Relative path: {}\", getRelativeFilePath());\n        LOG.trace(\"Absolute path: {}\", getAbsoluteFilePath());\n        LOG.trace(\"Name changed to: {}\", this);\n    }\n}", "lc": 1.2272727272727273, "pi": 0.29186602870813394, "ma": 0.8, "nbd": 0.5, "ml": 1.25, "d": 0.5992063492063493, "mi": -0.7446088794926, "fo": 2.9166666666666665, "r": -0.02631578947368421, "e": 1.5640600957798099}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1977_4bfbfcdd", "label": 1, "code": "@Override\npublic PropertyValue getValue(String columnName) {\n    return r.getValue(columnName);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic PropertyValue getValue(String columnName) {\n    return r.getValue(columnName);\n}", "lc": -0.45454545454545453, "pi": -0.6028708133971293, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.8646934460887951, "fo": -0.4166666666666667, "r": 1.7631578947368423, "e": -0.16279340490885932}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-606_f0fbacab", "label": 1, "code": "/**\n * Determine whether this item is stale\n * @return  {@code true} iff stale\n */\npublic boolean isStale() {\n    Status status = getLocationOrNull().getStatus();\n    return status == Status.DISCONNECTED || status == null;\n}", "code_comment": "/**\n * Determine whether this item is stale\n * @return  {@code true} iff stale\n */\n", "code_no_comment": "public boolean isStale() {\n    Status status = getLocationOrNull().getStatus();\n    return status == Status.DISCONNECTED || status == null;\n}", "lc": -0.45454545454545453, "pi": -0.47368421052631593, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.0912698412698413, "mi": 0.7592670894996475, "fo": -0.3333333333333333, "r": 2.6052631578947367, "e": -0.1298986301527751}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-428_d906576c", "label": 3, "code": "/**\n *  @see java.util.Map#keySet()\n */\npublic Set keySet() {\n    return new AbstractSet() {\n\n        public Iterator iterator() {\n            return new Iterator() {\n\n                public boolean hasNext() {\n                    return index < MicroMap.this.size();\n                }\n\n                public Object next() {\n                    index++;\n                    return key;\n                }\n\n                public void remove() {\n                    MicroMap.this.clear();\n                }\n\n                int index;\n            };\n        }\n\n        public int size() {\n            return MicroMap.this.size();\n        }\n    };\n}", "code_comment": "/**\n *  @see java.util.Map#keySet()\n */\n", "code_no_comment": "public Set keySet() {\n    return new AbstractSet() {\n\n        public Iterator iterator() {\n            return new Iterator() {\n\n                public boolean hasNext() {\n                    return index < MicroMap.this.size();\n                }\n\n                public Object next() {\n                    index++;\n                    return key;\n                }\n\n                public void remove() {\n                    MicroMap.this.clear();\n                }\n\n                int index;\n            };\n        }\n\n        public int size() {\n            return MicroMap.this.size();\n        }\n    };\n}", "lc": 0.36363636363636365, "pi": 1.5406698564593302, "ma": -0.6, "nbd": 0.0, "ml": -0.4166666666666667, "d": -0.07341269841269843, "mi": -0.11261451726568016, "fo": -0.25, "r": 1.6842105263157894, "e": -0.09645983529560923}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-3791_52106681", "label": 1, "code": "/**\n * All redelivery attempts failed so move the exchange to the dead letter queue\n */\nprotected boolean deliverToFailureProcessor(final Processor processor, final Exchange exchange, final RedeliveryData data, final AsyncCallback callback) {\n    boolean sync = true;\n    Exception caught = exchange.getException();\n    // we did not success with the redelivery so now we let the failure processor handle it\n    // clear exception as we let the failure processor handle it\n    exchange.setException(null);\n    boolean handled = false;\n    // regard both handled or continued as being handled\n    if (shouldHandled(exchange, data) || shouldContinue(exchange, data)) {\n        // its handled then remove traces of redelivery attempted\n        exchange.getIn().removeHeader(Exchange.REDELIVERED);\n        exchange.getIn().removeHeader(Exchange.REDELIVERY_COUNTER);\n        exchange.getIn().removeHeader(Exchange.REDELIVERY_MAX_COUNTER);\n        handled = true;\n    } else {\n        // must decrement the redelivery counter as we didn't process the redelivery but is\n        // handling by the failure handler. So we must -1 to not let the counter be out-of-sync\n        decrementRedeliveryCounter(exchange);\n    }\n    // is the a failure processor to process the Exchange\n    if (processor != null) {\n        // reset cached streams so they can be read again\n        MessageHelper.resetStreamCache(exchange.getIn());\n        // prepare original IN body if it should be moved instead of current body\n        if (data.useOriginalInMessage) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Using the original IN message instead of current\");\n            }\n            Message original = exchange.getUnitOfWork().getOriginalInMessage();\n            exchange.setIn(original);\n        }\n        if (log.isTraceEnabled()) {\n            log.trace(\"Failure processor \" + processor + \" is processing Exchange: \" + exchange);\n        }\n        // store the last to endpoint as the failure endpoint\n        exchange.setProperty(Exchange.FAILURE_ENDPOINT, exchange.getProperty(Exchange.TO_ENDPOINT));\n        // the failure processor could also be asynchronous\n        AsyncProcessor afp = AsyncProcessorTypeConverter.convert(processor);\n        sync = AsyncProcessorHelper.process(afp, exchange, new AsyncCallback() {\n\n            public void done(boolean sync) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Failure processor done: \" + processor + \" processing Exchange: \" + exchange);\n                }\n                try {\n                    prepareExchangeAfterFailure(exchange, data);\n                    // fire event as we had a failure processor to handle it, which there is a event for\n                    boolean deadLetterChannel = processor == data.deadLetterProcessor && data.deadLetterProcessor != null;\n                    EventHelper.notifyExchangeFailureHandled(exchange.getContext(), exchange, processor, deadLetterChannel);\n                } finally {\n                    // if the fault was handled asynchronously, this should be reflected in the callback as well\n                    data.sync &= sync;\n                    callback.done(data.sync);\n                }\n            }\n        });\n    } else {\n        try {\n            // no processor but we need to prepare after failure as well\n            prepareExchangeAfterFailure(exchange, data);\n        } finally {\n            // callback we are done\n            callback.done(data.sync);\n        }\n    }\n    // create log message\n    String msg = \"Failed delivery for exchangeId: \" + exchange.getExchangeId();\n    msg = msg + \". Exhausted after delivery attempt: \" + data.redeliveryCounter + \" caught: \" + caught;\n    if (processor != null) {\n        msg = msg + \". Processed by failure processor: \" + processor;\n    }\n    // log that we failed delivery as we are exhausted\n    logFailedDelivery(false, handled, false, exchange, msg, data, null);\n    return sync;\n}", "code_comment": "/**\n * All redelivery attempts failed so move the exchange to the dead letter queue\n */\n", "code_no_comment": "protected boolean deliverToFailureProcessor(final Processor processor, final Exchange exchange, final RedeliveryData data, final AsyncCallback callback) {\n    boolean sync = true;\n    Exception caught = exchange.getException();\n            exchange.setException(null);\n    boolean handled = false;\n        if (shouldHandled(exchange, data) || shouldContinue(exchange, data)) {\n                exchange.getIn().removeHeader(Exchange.REDELIVERED);\n        exchange.getIn().removeHeader(Exchange.REDELIVERY_COUNTER);\n        exchange.getIn().removeHeader(Exchange.REDELIVERY_MAX_COUNTER);\n        handled = true;\n    } else {\n                        decrementRedeliveryCounter(exchange);\n    }\n        if (processor != null) {\n                MessageHelper.resetStreamCache(exchange.getIn());\n                if (data.useOriginalInMessage) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Using the original IN message instead of current\");\n            }\n            Message original = exchange.getUnitOfWork().getOriginalInMessage();\n            exchange.setIn(original);\n        }\n        if (log.isTraceEnabled()) {\n            log.trace(\"Failure processor \" + processor + \" is processing Exchange: \" + exchange);\n        }\n                exchange.setProperty(Exchange.FAILURE_ENDPOINT, exchange.getProperty(Exchange.TO_ENDPOINT));\n                AsyncProcessor afp = AsyncProcessorTypeConverter.convert(processor);\n        sync = AsyncProcessorHelper.process(afp, exchange, new AsyncCallback() {\n\n            public void done(boolean sync) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Failure processor done: \" + processor + \" processing Exchange: \" + exchange);\n                }\n                try {\n                    prepareExchangeAfterFailure(exchange, data);\n                                        boolean deadLetterChannel = processor == data.deadLetterProcessor && data.deadLetterProcessor != null;\n                    EventHelper.notifyExchangeFailureHandled(exchange.getContext(), exchange, processor, deadLetterChannel);\n                } finally {\n                                        data.sync &= sync;\n                    callback.done(data.sync);\n                }\n            }\n        });\n    } else {\n        try {\n                        prepareExchangeAfterFailure(exchange, data);\n        } finally {\n                        callback.done(data.sync);\n        }\n    }\n        String msg = \"Failed delivery for exchangeId: \" + exchange.getExchangeId();\n    msg = msg + \". Exhausted after delivery attempt: \" + data.redeliveryCounter + \" caught: \" + caught;\n    if (processor != null) {\n        msg = msg + \". Processed by failure processor: \" + processor;\n    }\n        logFailedDelivery(false, handled, false, exchange, msg, data, null);\n    return sync;\n}", "lc": 1.9545454545454546, "pi": 1.1626794258373205, "ma": 0.8, "nbd": 0.5, "ml": 0.8333333333333334, "d": 1.0317460317460319, "mi": -0.9543340380549682, "fo": 2.3333333333333335, "r": -0.02631578947368421, "e": 3.590631789445779}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-4113_27300d81", "label": 0, "code": "public static List<byte[]> toBytesList(Collection<ByteBuffer> bytesList) {\n    if (bytesList == null)\n        return null;\n    ArrayList<byte[]> result = new ArrayList<byte[]>();\n    for (ByteBuffer bytes : bytesList) {\n        result.add(toBytes(bytes));\n    }\n    return result;\n}", "code_comment": NaN, "code_no_comment": "public static List<byte[]> toBytesList(Collection<ByteBuffer> bytesList) {\n    if (bytesList == null)\n        return null;\n    ArrayList<byte[]> result = new ArrayList<byte[]>();\n    for (ByteBuffer bytes : bytesList) {\n        result.add(toBytes(bytes));\n    }\n    return result;\n}", "lc": -0.22727272727272727, "pi": -0.15311004784689008, "ma": -0.2, "nbd": -0.5, "ml": -0.25, "d": -0.03373015873015876, "mi": 0.30570824524312884, "fo": -0.3333333333333333, "r": 0.31578947368421056, "e": -0.0984330607469903}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4932_f20b2d70", "label": 1, "code": "/**\n *  Cleans the original parameters from entries used by Wicket internals.\n *\n *  @param originalParameters\n *             the current request's non-modified parameters\n *  @return all parameters but Wicket internal ones\n */\nprivate PageParameters cleanPageParameters(final PageParameters originalParameters) {\n    PageParameters cleanParameters = null;\n    if (originalParameters != null) {\n        cleanParameters = new PageParameters(originalParameters);\n        // WICKET-4038: Ajax related parameters are set by wicket-ajax.js when needed.\n        // They shouldn't be propagated to the next requests\n        cleanParameters.remove(WebRequest.PARAM_AJAX);\n        cleanParameters.remove(WebRequest.PARAM_AJAX_BASE_URL);\n        cleanParameters.remove(WebRequest.PARAM_AJAX_REQUEST_ANTI_CACHE);\n        if (cleanParameters.isEmpty()) {\n            cleanParameters = null;\n        }\n    }\n    return cleanParameters;\n}", "code_comment": "/**\n *  Cleans the original parameters from entries used by Wicket internals.\n *\n *  @param originalParameters\n *             the current request's non-modified parameters\n *  @return all parameters but Wicket internal ones\n */\n", "code_no_comment": "private PageParameters cleanPageParameters(final PageParameters originalParameters) {\n    PageParameters cleanParameters = null;\n    if (originalParameters != null) {\n        cleanParameters = new PageParameters(originalParameters);\n                        cleanParameters.remove(WebRequest.PARAM_AJAX);\n        cleanParameters.remove(WebRequest.PARAM_AJAX_BASE_URL);\n        cleanParameters.remove(WebRequest.PARAM_AJAX_REQUEST_ANTI_CACHE);\n        if (cleanParameters.isEmpty()) {\n            cleanParameters = null;\n        }\n    }\n    return cleanParameters;\n}", "lc": -0.045454545454545456, "pi": 0.18181818181818177, "ma": -0.2, "nbd": 0.0, "ml": -0.08333333333333333, "d": 0.13095238095238093, "mi": 0.07399577167019025, "fo": -0.16666666666666666, "r": 0.05263157894736841, "e": -0.013588976677443344}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-1068_b12610d3", "label": 3, "code": "/**\n * Computes the Kendall's Tau rank correlation coefficient between the two arrays.\n *\n * @param xArray first data array\n * @param yArray second data array\n * @return Returns Kendall's Tau rank correlation coefficient for the two arrays\n * @throws DimensionMismatchException if the arrays lengths do not match\n */\npublic double correlation(final double[] xArray, final double[] yArray) throws DimensionMismatchException {\n    if (xArray.length != yArray.length) {\n        throw new DimensionMismatchException(xArray.length, yArray.length);\n    }\n    final int n = xArray.length;\n    final int numPairs = n * (n - 1) / 2;\n    @SuppressWarnings(\"unchecked\")\n    Pair<Double, Double>[] pairs = new Pair[n];\n    for (int i = 0; i < n; i++) {\n        pairs[i] = new Pair<Double, Double>(xArray[i], yArray[i]);\n    }\n    Arrays.sort(pairs, new Comparator<Pair<Double, Double>>() {\n\n        public int compare(Pair<Double, Double> pair1, Pair<Double, Double> pair2) {\n            int compareFirst = pair1.getFirst().compareTo(pair2.getFirst());\n            return compareFirst != 0 ? compareFirst : pair1.getSecond().compareTo(pair2.getSecond());\n        }\n    });\n    int tiedXPairs = 0;\n    int tiedXYPairs = 0;\n    int consecutiveXTies = 1;\n    int consecutiveXYTies = 1;\n    Pair<Double, Double> prev = pairs[0];\n    for (int i = 1; i < n; i++) {\n        final Pair<Double, Double> curr = pairs[i];\n        if (curr.getFirst().equals(prev.getFirst())) {\n            consecutiveXTies++;\n            if (curr.getSecond().equals(prev.getSecond())) {\n                consecutiveXYTies++;\n            } else {\n                tiedXYPairs += consecutiveXYTies * (consecutiveXYTies - 1) / 2;\n                consecutiveXYTies = 1;\n            }\n        } else {\n            tiedXPairs += consecutiveXTies * (consecutiveXTies - 1) / 2;\n            consecutiveXTies = 1;\n            tiedXYPairs += consecutiveXYTies * (consecutiveXYTies - 1) / 2;\n            consecutiveXYTies = 1;\n        }\n        prev = curr;\n    }\n    tiedXPairs += consecutiveXTies * (consecutiveXTies - 1) / 2;\n    tiedXYPairs += consecutiveXYTies * (consecutiveXYTies - 1) / 2;\n    int swaps = 0;\n    @SuppressWarnings(\"unchecked\")\n    Pair<Double, Double>[] pairsDestination = new Pair[n];\n    for (int segmentSize = 1; segmentSize < n; segmentSize <<= 1) {\n        for (int offset = 0; offset < n; offset += 2 * segmentSize) {\n            int i = offset;\n            final int iEnd = FastMath.min(i + segmentSize, n);\n            int j = iEnd;\n            final int jEnd = FastMath.min(j + segmentSize, n);\n            int copyLocation = offset;\n            while (i < iEnd || j < jEnd) {\n                if (i < iEnd) {\n                    if (j < jEnd) {\n                        if (pairs[i].getSecond().compareTo(pairs[j].getSecond()) <= 0) {\n                            pairsDestination[copyLocation] = pairs[i];\n                            i++;\n                        } else {\n                            pairsDestination[copyLocation] = pairs[j];\n                            j++;\n                            swaps += iEnd - i;\n                        }\n                    } else {\n                        pairsDestination[copyLocation] = pairs[i];\n                        i++;\n                    }\n                } else {\n                    pairsDestination[copyLocation] = pairs[j];\n                    j++;\n                }\n                copyLocation++;\n            }\n        }\n        final Pair<Double, Double>[] pairsTemp = pairs;\n        pairs = pairsDestination;\n        pairsDestination = pairsTemp;\n    }\n    int tiedYPairs = 0;\n    int consecutiveYTies = 1;\n    prev = pairs[0];\n    for (int i = 1; i < n; i++) {\n        final Pair<Double, Double> curr = pairs[i];\n        if (curr.getSecond().equals(prev.getSecond())) {\n            consecutiveYTies++;\n        } else {\n            tiedYPairs += consecutiveYTies * (consecutiveYTies - 1) / 2;\n            consecutiveYTies = 1;\n        }\n        prev = curr;\n    }\n    tiedYPairs += consecutiveYTies * (consecutiveYTies - 1) / 2;\n    int concordantMinusDiscordant = numPairs - tiedXPairs - tiedYPairs + tiedXYPairs - 2 * swaps;\n    return concordantMinusDiscordant / FastMath.sqrt((numPairs - tiedXPairs) * (numPairs - tiedYPairs));\n}", "code_comment": "/**\n * Computes the Kendall's Tau rank correlation coefficient between the two arrays.\n *\n * @param xArray first data array\n * @param yArray second data array\n * @return Returns Kendall's Tau rank correlation coefficient for the two arrays\n * @throws DimensionMismatchException if the arrays lengths do not match\n */\n", "code_no_comment": "public double correlation(final double[] xArray, final double[] yArray) throws DimensionMismatchException {\n    if (xArray.length != yArray.length) {\n        throw new DimensionMismatchException(xArray.length, yArray.length);\n    }\n    final int n = xArray.length;\n    final int numPairs = n * (n - 1) / 2;\n    @SuppressWarnings(\"unchecked\")\n    Pair<Double, Double>[] pairs = new Pair[n];\n    for (int i = 0; i < n; i++) {\n        pairs[i] = new Pair<Double, Double>(xArray[i], yArray[i]);\n    }\n    Arrays.sort(pairs, new Comparator<Pair<Double, Double>>() {\n\n        public int compare(Pair<Double, Double> pair1, Pair<Double, Double> pair2) {\n            int compareFirst = pair1.getFirst().compareTo(pair2.getFirst());\n            return compareFirst != 0 ? compareFirst : pair1.getSecond().compareTo(pair2.getSecond());\n        }\n    });\n    int tiedXPairs = 0;\n    int tiedXYPairs = 0;\n    int consecutiveXTies = 1;\n    int consecutiveXYTies = 1;\n    Pair<Double, Double> prev = pairs[0];\n    for (int i = 1; i < n; i++) {\n        final Pair<Double, Double> curr = pairs[i];\n        if (curr.getFirst().equals(prev.getFirst())) {\n            consecutiveXTies++;\n            if (curr.getSecond().equals(prev.getSecond())) {\n                consecutiveXYTies++;\n            } else {\n                tiedXYPairs += consecutiveXYTies * (consecutiveXYTies - 1) / 2;\n                consecutiveXYTies = 1;\n            }\n        } else {\n            tiedXPairs += consecutiveXTies * (consecutiveXTies - 1) / 2;\n            consecutiveXTies = 1;\n            tiedXYPairs += consecutiveXYTies * (consecutiveXYTies - 1) / 2;\n            consecutiveXYTies = 1;\n        }\n        prev = curr;\n    }\n    tiedXPairs += consecutiveXTies * (consecutiveXTies - 1) / 2;\n    tiedXYPairs += consecutiveXYTies * (consecutiveXYTies - 1) / 2;\n    int swaps = 0;\n    @SuppressWarnings(\"unchecked\")\n    Pair<Double, Double>[] pairsDestination = new Pair[n];\n    for (int segmentSize = 1; segmentSize < n; segmentSize <<= 1) {\n        for (int offset = 0; offset < n; offset += 2 * segmentSize) {\n            int i = offset;\n            final int iEnd = FastMath.min(i + segmentSize, n);\n            int j = iEnd;\n            final int jEnd = FastMath.min(j + segmentSize, n);\n            int copyLocation = offset;\n            while (i < iEnd || j < jEnd) {\n                if (i < iEnd) {\n                    if (j < jEnd) {\n                        if (pairs[i].getSecond().compareTo(pairs[j].getSecond()) <= 0) {\n                            pairsDestination[copyLocation] = pairs[i];\n                            i++;\n                        } else {\n                            pairsDestination[copyLocation] = pairs[j];\n                            j++;\n                            swaps += iEnd - i;\n                        }\n                    } else {\n                        pairsDestination[copyLocation] = pairs[i];\n                        i++;\n                    }\n                } else {\n                    pairsDestination[copyLocation] = pairs[j];\n                    j++;\n                }\n                copyLocation++;\n            }\n        }\n        final Pair<Double, Double>[] pairsTemp = pairs;\n        pairs = pairsDestination;\n        pairsDestination = pairsTemp;\n    }\n    int tiedYPairs = 0;\n    int consecutiveYTies = 1;\n    prev = pairs[0];\n    for (int i = 1; i < n; i++) {\n        final Pair<Double, Double> curr = pairs[i];\n        if (curr.getSecond().equals(prev.getSecond())) {\n            consecutiveYTies++;\n        } else {\n            tiedYPairs += consecutiveYTies * (consecutiveYTies - 1) / 2;\n            consecutiveYTies = 1;\n        }\n        prev = curr;\n    }\n    tiedYPairs += consecutiveYTies * (consecutiveYTies - 1) / 2;\n    int concordantMinusDiscordant = numPairs - tiedXPairs - tiedYPairs + tiedXYPairs - 2 * swaps;\n    return concordantMinusDiscordant / FastMath.sqrt((numPairs - tiedXPairs) * (numPairs - tiedYPairs));\n}", "lc": 3.6818181818181817, "pi": 1.9856459330143539, "ma": 2.4, "nbd": 2.0, "ml": 2.1666666666666665, "d": 6.583333333333333, "mi": -1.3439041578576458, "fo": 1.3333333333333333, "r": -0.02631578947368421, "e": 37.852063415224485}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-3634_9339ecf8", "label": 3, "code": "private int updateAuthKeys(String path) throws KeeperException, InterruptedException {\n    int keysAdded = 0;\n    for (String child : zk.getChildren(path, this)) {\n        String childPath = path + \"/\" + child;\n        // Get the node data and reset the watcher\n        AuthenticationKey key = deserializeKey(zk.getData(childPath, this, null));\n        secretManager.addKey(key);\n        keysAdded++;\n    }\n    return keysAdded;\n}", "code_comment": NaN, "code_no_comment": "private int updateAuthKeys(String path) throws KeeperException, InterruptedException {\n    int keysAdded = 0;\n    for (String child : zk.getChildren(path, this)) {\n        String childPath = path + \"/\" + child;\n                AuthenticationKey key = deserializeKey(zk.getData(childPath, this, null));\n        secretManager.addKey(key);\n        keysAdded++;\n    }\n    return keysAdded;\n}", "lc": -0.18181818181818182, "pi": 0.0, "ma": -0.4, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.06746031746031747, "mi": 0.17068357998590572, "fo": -0.16666666666666666, "r": 0.34210526315789475, "e": -0.0533024440564075}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3879_4faf31e3", "label": 1, "code": "/**\n * Following logic is taken from org.apache.jackrabbit.core.query.lucene.JackrabbitQueryParser#parse(java.lang.String)\n */\nstatic String rewriteQueryText(String textsearch) {\n    // replace escaped ' with just '\n    StringBuilder rewritten = new StringBuilder();\n    // the default lucene query parser recognizes 'AND' and 'NOT' as\n    // keywords.\n    textsearch = textsearch.replaceAll(\"AND\", \"and\");\n    textsearch = textsearch.replaceAll(\"NOT\", \"not\");\n    boolean escaped = false;\n    for (int i = 0; i < textsearch.length(); i++) {\n        char c = textsearch.charAt(i);\n        if (c == '\\\\') {\n            if (escaped) {\n                rewritten.append(\"\\\\\\\\\");\n                escaped = false;\n            } else {\n                escaped = true;\n            }\n        } else if (c == '\\'') {\n            if (escaped) {\n                escaped = false;\n            }\n            rewritten.append(c);\n        } else if (c == ':' || c == '/') {\n            // TODO Some other chars are also considered special See OAK-3769 for details\n            // ':' fields as known in lucene are not supported\n            // '/' its a special char used for regex search in Lucene\n            rewritten.append('\\\\').append(c);\n        } else {\n            if (escaped) {\n                rewritten.append('\\\\');\n                escaped = false;\n            }\n            rewritten.append(c);\n        }\n    }\n    return rewritten.toString();\n}", "code_comment": "/**\n * Following logic is taken from org.apache.jackrabbit.core.query.lucene.JackrabbitQueryParser#parse(java.lang.String)\n */\n", "code_no_comment": "static String rewriteQueryText(String textsearch) {\n        StringBuilder rewritten = new StringBuilder();\n            textsearch = textsearch.replaceAll(\"AND\", \"and\");\n    textsearch = textsearch.replaceAll(\"NOT\", \"not\");\n    boolean escaped = false;\n    for (int i = 0; i < textsearch.length(); i++) {\n        char c = textsearch.charAt(i);\n        if (c == '\\\\') {\n            if (escaped) {\n                rewritten.append(\"\\\\\\\\\");\n                escaped = false;\n            } else {\n                escaped = true;\n            }\n        } else if (c == '\\'') {\n            if (escaped) {\n                escaped = false;\n            }\n            rewritten.append(c);\n        } else if (c == ':' || c == '/') {\n                                                rewritten.append('\\\\').append(c);\n        } else {\n            if (escaped) {\n                rewritten.append('\\\\');\n                escaped = false;\n            }\n            rewritten.append(c);\n        }\n    }\n    return rewritten.toString();\n}", "lc": 0.7727272727272727, "pi": 0.875598086124402, "ma": 0.8, "nbd": 1.5, "ml": 0.5833333333333334, "d": 0.6726190476190477, "mi": -0.5281183932346721, "fo": 0.4166666666666667, "r": -0.02631578947368421, "e": 0.8527307619162876}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1199_813109d7", "label": 3, "code": "public void getResult() throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException {\n    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {\n        throw new IllegalStateException(\"Method call not finished!\");\n    }\n    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());\n    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);\n    (new Client(prot)).recv_removeConstraint();\n}", "code_comment": NaN, "code_no_comment": "public void getResult() throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException {\n    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {\n        throw new IllegalStateException(\"Method call not finished!\");\n    }\n    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());\n    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);\n    (new Client(prot)).recv_removeConstraint();\n}", "lc": -0.2727272727272727, "pi": -0.2822966507177035, "ma": -0.2, "nbd": -0.5, "ml": -0.25, "d": -0.053571428571428575, "mi": 0.21099365750528534, "fo": 0.0, "r": -0.02631578947368421, "e": 0.004289921220817992}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3428_ffc0cae9", "label": 1, "code": "/**\n *  Convenience method that processes the request and detaches the {@link RequestCycle}.\n *\n *  @return <code>true</code> if the request resolved to a Wicket request, <code>false</code>\n *          otherwise.\n */\npublic boolean processRequestAndDetach() {\n    boolean result;\n    try {\n        listeners.onBeginRequest(this);\n        onBeginRequest();\n        result = processRequest();\n    } finally {\n        detach();\n    }\n    return result;\n}", "code_comment": "/**\n *  Convenience method that processes the request and detaches the {@link RequestCycle}.\n *\n *  @return <code>true</code> if the request resolved to a Wicket request, <code>false</code>\n *          otherwise.\n */\n", "code_no_comment": "public boolean processRequestAndDetach() {\n    boolean result;\n    try {\n        listeners.onBeginRequest(this);\n        onBeginRequest();\n        result = processRequest();\n    } finally {\n        detach();\n    }\n    return result;\n}", "lc": -0.13636363636363635, "pi": -0.06220095693779921, "ma": -0.6, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.3634954193093726, "fo": -0.16666666666666666, "r": 1.4999999999999998, "e": -0.16279340490885932}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-3690_2a3f3392", "label": 3, "code": "public void addService(Object object) throws Exception {\n    if (object instanceof Service) {\n        Service service = (Service) object;\n        for (LifecycleStrategy strategy : lifecycleStrategies) {\n            if (service instanceof Endpoint) {\n                // use specialized endpoint add\n                strategy.onEndpointAdd((Endpoint) service);\n            } else {\n                strategy.onServiceAdd(this, service, null);\n            }\n        }\n        // only add to services to close if its a singleton\n        // otherwise we could for example end up with a lot of prototype scope endpoints\n        // assume singleton by default\n        boolean singleton = true;\n        if (service instanceof IsSingleton) {\n            singleton = ((IsSingleton) service).isSingleton();\n        }\n        if (singleton) {\n            servicesToClose.add(service);\n        }\n    }\n    startServices(object);\n}", "code_comment": NaN, "code_no_comment": "public void addService(Object object) throws Exception {\n    if (object instanceof Service) {\n        Service service = (Service) object;\n        for (LifecycleStrategy strategy : lifecycleStrategies) {\n            if (service instanceof Endpoint) {\n                                strategy.onEndpointAdd((Endpoint) service);\n            } else {\n                strategy.onServiceAdd(this, service, null);\n            }\n        }\n                                boolean singleton = true;\n        if (service instanceof IsSingleton) {\n            singleton = ((IsSingleton) service).isSingleton();\n        }\n        if (singleton) {\n            servicesToClose.add(service);\n        }\n    }\n    startServices(object);\n}", "lc": 0.2727272727272727, "pi": 0.6555023923444977, "ma": 0.4, "nbd": 0.5, "ml": 0.16666666666666666, "d": -0.3650793650793651, "mi": -0.19295278365045798, "fo": -0.08333333333333333, "r": 0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1178_f2bb1a17", "label": 1, "code": "/**\n * Internal method for checking whether this node exists and is visible\n * (i.e. not hidden).\n *\n * @return {@true} if the node is visible, {@code false} if not\n */\nprivate boolean isVisible() {\n    return !isHidden(name) && nodeBuilder.exists();\n}", "code_comment": "/**\n * Internal method for checking whether this node exists and is visible\n * (i.e. not hidden).\n *\n * @return {@true} if the node is visible, {@code false} if not\n */\n", "code_no_comment": "private boolean isVisible() {\n    return !isHidden(name) && nodeBuilder.exists();\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.16666666666666669, "mi": 1.0036645525017613, "fo": -0.3333333333333333, "r": 2.5789473684210527, "e": -0.15172858929363828}
{"project_name": "Closure", "project_version": 87, "label": 2, "code": "/**\n * @return Whether the node is a block with a single statement that is\n *     an expression.\n */\nprivate boolean isFoldableExpressBlock(Node n) {\n    if (n.getType() == Token.BLOCK) {\n        if (n.hasOneChild()) {\n            Node maybeExpr = n.getFirstChild();\n            return NodeUtil.isExpressionNode(maybeExpr);\n        }\n    }\n    return false;\n}", "code_comment": "/**\n * @return Whether the node is a block with a single statement that is\n *     an expression.\n */\n", "code_no_comment": "private boolean isFoldableExpressBlock(Node n) {\n    if (n.getType() == Token.BLOCK) {\n        if (n.hasOneChild()) {\n            Node maybeExpr = n.getFirstChild();\n            return NodeUtil.isExpressionNode(maybeExpr);\n        }\n    }\n    return false;\n}", "lc": -0.22727272727272727, "pi": 0.6076555023923443, "ma": -0.2, "nbd": 0.0, "ml": -0.08333333333333333, "d": -0.0912698412698413, "mi": 0.31585623678646924, "fo": -0.16666666666666666, "r": 2.3684210526315788, "e": -0.11291413818341084}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-2065_9da430fb", "label": 1, "code": "protected void appendParameters(AppendingStringBuffer url, Map parameters) {\n    int i = 0;\n    while (parameters.containsKey(String.valueOf(i))) {\n        String value = (String) parameters.get(String.valueOf(i));\n        if (!url.endsWith(\"/\")) {\n            url.append(\"/\");\n        }\n        url.append(urlEncodePathComponent(value)).append(\"/\");\n        i++;\n    }\n    String pageMap = (String) parameters.get(WebRequestCodingStrategy.PAGEMAP);\n    if (pageMap != null) {\n        i++;\n        pageMap = WebRequestCodingStrategy.encodePageMapName(pageMap);\n        if (!url.endsWith(\"/\")) {\n            url.append(\"/\");\n        }\n        url.append(WebRequestCodingStrategy.PAGEMAP).append(\"/\").append(urlEncodePathComponent(pageMap)).append(\"/\");\n    }\n    if (i != parameters.size()) {\n        throw new WicketRuntimeException(\"Not all parameters were encoded. Make sure all parameter names are integers in consecutive order starting with zero. Current parameter names are: \" + parameters.keySet().toString());\n    }\n}", "code_comment": NaN, "code_no_comment": "protected void appendParameters(AppendingStringBuffer url, Map parameters) {\n    int i = 0;\n    while (parameters.containsKey(String.valueOf(i))) {\n        String value = (String) parameters.get(String.valueOf(i));\n        if (!url.endsWith(\"/\")) {\n            url.append(\"/\");\n        }\n        url.append(urlEncodePathComponent(value)).append(\"/\");\n        i++;\n    }\n    String pageMap = (String) parameters.get(WebRequestCodingStrategy.PAGEMAP);\n    if (pageMap != null) {\n        i++;\n        pageMap = WebRequestCodingStrategy.encodePageMapName(pageMap);\n        if (!url.endsWith(\"/\")) {\n            url.append(\"/\");\n        }\n        url.append(WebRequestCodingStrategy.PAGEMAP).append(\"/\").append(urlEncodePathComponent(pageMap)).append(\"/\");\n    }\n    if (i != parameters.size()) {\n        throw new WicketRuntimeException(\"Not all parameters were encoded. Make sure all parameter names are integers in consecutive order starting with zero. Current parameter names are: \" + parameters.keySet().toString());\n    }\n}", "lc": 0.4090909090909091, "pi": 0.04306220095693773, "ma": 0.6, "nbd": 0.0, "ml": 0.5, "d": 0.7083333333333334, "mi": -0.3849189570119802, "fo": 1.25, "r": -0.02631578947368421, "e": 0.8842654864196676}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4102_e743fd7e", "label": 1, "code": "@Override\npublic void onComponentTagBody(final MarkupStream markupStream, final ComponentTag openTag) {\n    boolean storeLabelText = false;\n    // try and find some form of label content...\n    String labelText = null;\n    if (labeled instanceof ILabelProvider) {\n        ILabelProvider<String> provider = (ILabelProvider<String>) labeled;\n        if (provider.getLabel() != null) {\n            String text = provider.getLabel().getObject();\n            if (!Strings.isEmpty(text)) {\n                labelText = text;\n            }\n        }\n    }\n    if (labelText == null && labeled instanceof FormComponent) {\n        String text = ((FormComponent<?>) labeled).getDefaultLabel(\"wicket:unknown\");\n        if (!\"wicket:unknown\".equals(text) && !Strings.isEmpty(text)) {\n            labelText = text;\n        }\n    }\n    // check if wicket:label tag has a message key\n    if (labelText == null && openTag.getAttribute(\"key\") != null) {\n        String text = labeled.getString(openTag.getAttribute(\"key\"));\n        if (!Strings.isEmpty(text)) {\n            labelText = text;\n            storeLabelText = true;\n        }\n    }\n    // as last resort use the tag body\n    if (labelText == null) {\n        String text = new ResponseBufferZone(RequestCycle.get(), markupStream) {\n\n            @Override\n            protected void executeInsideBufferedZone() {\n                TextLabel.super.onComponentTagBody(markupStream, openTag);\n            }\n        }.execute().toString();\n        if (!Strings.isEmpty(text)) {\n            labelText = text;\n            storeLabelText = true;\n        }\n    }\n    // print the label text\n    replaceComponentTagBody(markupStream, openTag, labelText);\n    // store the label text in FormComponent's label model so its available to errors\n    if (labeled instanceof FormComponent) {\n        FormComponent<?> fc = (FormComponent<?>) labeled;\n        fc.setLabel(Model.of(labelText));\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void onComponentTagBody(final MarkupStream markupStream, final ComponentTag openTag) {\n    boolean storeLabelText = false;\n        String labelText = null;\n    if (labeled instanceof ILabelProvider) {\n        ILabelProvider<String> provider = (ILabelProvider<String>) labeled;\n        if (provider.getLabel() != null) {\n            String text = provider.getLabel().getObject();\n            if (!Strings.isEmpty(text)) {\n                labelText = text;\n            }\n        }\n    }\n    if (labelText == null && labeled instanceof FormComponent) {\n        String text = ((FormComponent<?>) labeled).getDefaultLabel(\"wicket:unknown\");\n        if (!\"wicket:unknown\".equals(text) && !Strings.isEmpty(text)) {\n            labelText = text;\n        }\n    }\n        if (labelText == null && openTag.getAttribute(\"key\") != null) {\n        String text = labeled.getString(openTag.getAttribute(\"key\"));\n        if (!Strings.isEmpty(text)) {\n            labelText = text;\n            storeLabelText = true;\n        }\n    }\n        if (labelText == null) {\n        String text = new ResponseBufferZone(RequestCycle.get(), markupStream) {\n\n            @Override\n            protected void executeInsideBufferedZone() {\n                TextLabel.super.onComponentTagBody(markupStream, openTag);\n            }\n        }.execute().toString();\n        if (!Strings.isEmpty(text)) {\n            labelText = text;\n            storeLabelText = true;\n        }\n    }\n        replaceComponentTagBody(markupStream, openTag, labelText);\n        if (labeled instanceof FormComponent) {\n        FormComponent<?> fc = (FormComponent<?>) labeled;\n        fc.setLabel(Model.of(labelText));\n    }\n}", "lc": 1.3636363636363635, "pi": 0.4736842105263157, "ma": 1.4, "nbd": 0.5, "ml": 1.25, "d": 0.7162698412698413, "mi": -0.7916842847075402, "fo": 1.0833333333333333, "r": -0.02631578947368421, "e": 1.713873088870063}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-3740_f2f5bd5b", "label": 1, "code": "private void processTriggersFor(Watermark mark) throws Exception {\n    boolean fire;\n    do {\n        Timer<K, W> timer = watermarkTimersQueue.peek();\n        if (timer != null && timer.timestamp <= mark.getTimestamp()) {\n            fire = true;\n            watermarkTimers.remove(timer);\n            watermarkTimersQueue.remove();\n            context.key = timer.key;\n            context.window = timer.window;\n            setKeyContext(timer.key);\n            TriggerResult triggerResult = context.onEventTime(timer.timestamp);\n            processTriggerResult(triggerResult, context.key, context.window);\n        } else {\n            fire = false;\n        }\n    } while (fire);\n}", "code_comment": NaN, "code_no_comment": "private void processTriggersFor(Watermark mark) throws Exception {\n    boolean fire;\n    do {\n        Timer<K, W> timer = watermarkTimersQueue.peek();\n        if (timer != null && timer.timestamp <= mark.getTimestamp()) {\n            fire = true;\n            watermarkTimers.remove(timer);\n            watermarkTimersQueue.remove();\n            context.key = timer.key;\n            context.window = timer.window;\n            setKeyContext(timer.key);\n            TriggerResult triggerResult = context.onEventTime(timer.timestamp);\n            processTriggerResult(triggerResult, context.key, context.window);\n        } else {\n            fire = false;\n        }\n    } while (fire);\n}", "lc": 0.18181818181818182, "pi": 0.5741626794258374, "ma": -0.2, "nbd": 0.0, "ml": 0.16666666666666666, "d": 0.3849206349206349, "mi": -0.19661733615221966, "fo": 0.08333333333333333, "r": -0.02631578947368421, "e": 0.35492470738749327}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-366_db4a291f", "label": 1, "code": "void initiateClose(boolean saveState, boolean queueMinC, boolean disableWrites) {\n    if (!saveState && queueMinC) {\n        throw new IllegalArgumentException(\"Not saving state on close and requesting minor compactions queue does not make sense\");\n    }\n    log.debug(\"initiateClose(saveState=\" + saveState + \" queueMinC=\" + queueMinC + \" disableWrites=\" + disableWrites + \") \" + getExtent());\n    MinorCompactionTask mct = null;\n    synchronized (this) {\n        if (closed || closing || closeComplete) {\n            String msg = \"Tablet \" + getExtent() + \" already\";\n            if (closed)\n                msg += \" closed\";\n            if (closing)\n                msg += \" closing\";\n            if (closeComplete)\n                msg += \" closeComplete\";\n            throw new IllegalStateException(msg);\n        }\n        // enter the closing state, no splits, minor, or major compactions can start\n        // should cause running major compactions to stop\n        closing = true;\n        this.notifyAll();\n        // determines if inserts and queries can still continue while minor compacting\n        closed = disableWrites;\n        // true should cause any running major compactions to abort\n        while (majorCompactionInProgress) {\n            try {\n                this.wait(50);\n            } catch (InterruptedException e) {\n                log.error(e.toString());\n            }\n        }\n        if (!saveState || tabletMemory.getMemTable().getNumEntries() == 0) {\n            return;\n        }\n        tabletMemory.waitForMinC();\n        mct = prepareForMinC(getFlushID());\n        if (queueMinC) {\n            tabletResources.executeMinorCompaction(mct);\n            return;\n        }\n    }\n    // do minor compaction outside of synch block so that tablet can be read and written to while\n    // compaction runs\n    mct.run();\n}", "code_comment": NaN, "code_no_comment": "void initiateClose(boolean saveState, boolean queueMinC, boolean disableWrites) {\n    if (!saveState && queueMinC) {\n        throw new IllegalArgumentException(\"Not saving state on close and requesting minor compactions queue does not make sense\");\n    }\n    log.debug(\"initiateClose(saveState=\" + saveState + \" queueMinC=\" + queueMinC + \" disableWrites=\" + disableWrites + \") \" + getExtent());\n    MinorCompactionTask mct = null;\n    synchronized (this) {\n        if (closed || closing || closeComplete) {\n            String msg = \"Tablet \" + getExtent() + \" already\";\n            if (closed)\n                msg += \" closed\";\n            if (closing)\n                msg += \" closing\";\n            if (closeComplete)\n                msg += \" closeComplete\";\n            throw new IllegalStateException(msg);\n        }\n                        closing = true;\n        this.notifyAll();\n                closed = disableWrites;\n                while (majorCompactionInProgress) {\n            try {\n                this.wait(50);\n            } catch (InterruptedException e) {\n                log.error(e.toString());\n            }\n        }\n        if (!saveState || tabletMemory.getMemTable().getNumEntries() == 0) {\n            return;\n        }\n        tabletMemory.waitForMinC();\n        mct = prepareForMinC(getFlushID());\n        if (queueMinC) {\n            tabletResources.executeMinorCompaction(mct);\n            return;\n        }\n    }\n            mct.run();\n}", "lc": 1.1363636363636365, "pi": 0.5885167464114831, "ma": 1.6, "nbd": 0.5, "ml": 1.1666666666666667, "d": 0.5337301587301588, "mi": -0.6842847075405215, "fo": 0.6666666666666666, "r": -0.02631578947368421, "e": 0.8833019253931754}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-1931_986848f7", "label": 1, "code": "@Override\npublic int read() {\n    return -1;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic int read() {\n    return -1;\n}", "lc": -0.45454545454545453, "pi": -0.6028708133971293, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.9785764622973924, "fo": -0.5, "r": 2.289473684210526, "e": -0.16279340490885932}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1505_b082fc1e", "label": 1, "code": "@Override\npublic void addMutations(Iterable<Mutation> iterable) throws MutationsRejectedException {\n    for (Mutation m : iterable) {\n        acu.addMutation(tablename, m);\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void addMutations(Iterable<Mutation> iterable) throws MutationsRejectedException {\n    for (Mutation m : iterable) {\n        acu.addMutation(tablename, m);\n    }\n}", "lc": -0.36363636363636365, "pi": -0.004784688995215422, "ma": -0.4, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.5777307963354474, "fo": -0.4166666666666667, "r": 0.5, "e": -0.16279340490885932}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-320_c06cc933", "label": 1, "code": "/**\n * {@inheritDoc}\n */\npublic RealMatrix getU() throws InvalidMatrixException {\n    if (cachedU == null) {\n        if (m >= n) {\n            // the tridiagonal matrix is Bt.B, where B is upper bidiagonal\n            final double[][] eData = eigenDecomposition.getV().getData();\n            final double[][] iData = new double[m][];\n            double[] ei1 = eData[0];\n            iData[0] = ei1;\n            for (int i = 0; i < n - 1; ++i) {\n                // compute B.E.S^(-1) where E is the eigenvectors matrix\n                // we reuse the array from matrix E to store the result\n                final double mi = mainBidiagonal[i];\n                final double si = secondaryBidiagonal[i];\n                final double[] ei0 = ei1;\n                ei1 = eData[i + 1];\n                iData[i + 1] = ei1;\n                for (int j = 0; j < n; ++j) {\n                    ei0[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n                }\n            }\n            // last row\n            final double lastMain = mainBidiagonal[n - 1];\n            for (int j = 0; j < n; ++j) {\n                ei1[j] *= lastMain / singularValues[j];\n            }\n            for (int i = n; i < m; ++i) {\n                iData[i] = new double[n];\n            }\n            cachedU = transformer.getU().multiply(MatrixUtils.createRealMatrix(iData));\n        } else {\n            // the tridiagonal matrix is B.Bt, where B is lower bidiagonal\n            cachedU = transformer.getU().multiply(eigenDecomposition.getV());\n        }\n    }\n    // return the cached matrix\n    return cachedU;\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "public RealMatrix getU() throws InvalidMatrixException {\n    if (cachedU == null) {\n        if (m >= n) {\n                        final double[][] eData = eigenDecomposition.getV().getData();\n            final double[][] iData = new double[m][];\n            double[] ei1 = eData[0];\n            iData[0] = ei1;\n            for (int i = 0; i < n - 1; ++i) {\n                                                final double mi = mainBidiagonal[i];\n                final double si = secondaryBidiagonal[i];\n                final double[] ei0 = ei1;\n                ei1 = eData[i + 1];\n                iData[i + 1] = ei1;\n                for (int j = 0; j < n; ++j) {\n                    ei0[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n                }\n            }\n                        final double lastMain = mainBidiagonal[n - 1];\n            for (int j = 0; j < n; ++j) {\n                ei1[j] *= lastMain / singularValues[j];\n            }\n            for (int i = n; i < m; ++i) {\n                iData[i] = new double[n];\n            }\n            cachedU = transformer.getU().multiply(MatrixUtils.createRealMatrix(iData));\n        } else {\n                        cachedU = transformer.getU().multiply(eigenDecomposition.getV());\n        }\n    }\n        return cachedU;\n}", "lc": 0.7727272727272727, "pi": 0.8899521531100476, "ma": 0.6, "nbd": 1.0, "ml": 0.5, "d": 2.8154761904761907, "mi": -0.5946441155743479, "fo": 0.16666666666666666, "r": -0.02631578947368421, "e": 4.955642767817522}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-579_7d72e6ed", "label": 3, "code": "public QueryIndex getBestIndex(Query query, NodeState rootState, Filter filter) {\n    QueryIndex best = null;\n    if (LOG.isDebugEnabled()) {\n        LOG.debug(\"cost using filter \" + filter);\n    }\n    double bestCost = Double.POSITIVE_INFINITY;\n    for (QueryIndex index : getIndexes(rootState)) {\n        double cost = index.getCost(filter, rootState);\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"cost for \" + index.getIndexName() + \" is \" + cost);\n        }\n        if (cost < bestCost) {\n            bestCost = cost;\n            best = index;\n        }\n    }\n    if (best == null) {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"no indexes found - using TraversingIndex; indexProvider: \" + indexProvider);\n        }\n        best = new TraversingIndex();\n    }\n    return best;\n}", "code_comment": NaN, "code_no_comment": "public QueryIndex getBestIndex(Query query, NodeState rootState, Filter filter) {\n    QueryIndex best = null;\n    if (LOG.isDebugEnabled()) {\n        LOG.debug(\"cost using filter \" + filter);\n    }\n    double bestCost = Double.POSITIVE_INFINITY;\n    for (QueryIndex index : getIndexes(rootState)) {\n        double cost = index.getCost(filter, rootState);\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"cost for \" + index.getIndexName() + \" is \" + cost);\n        }\n        if (cost < bestCost) {\n            bestCost = cost;\n            best = index;\n        }\n    }\n    if (best == null) {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"no indexes found - using TraversingIndex; indexProvider: \" + indexProvider);\n        }\n        best = new TraversingIndex();\n    }\n    return best;\n}", "lc": 0.45454545454545453, "pi": 0.21052631578947367, "ma": 0.6, "nbd": 0.0, "ml": 0.3333333333333333, "d": 0.4285714285714286, "mi": -0.3713883016208596, "fo": 0.25, "r": 0.0, "e": 0.45499213360764845}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3324_5f863af6", "label": 1, "code": "@Override\npublic boolean isGranted(long repositoryPermissions) {\n    return hasPermissions(getEntryIterator(new EntryPredicate()), repositoryPermissions, null);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean isGranted(long repositoryPermissions) {\n    return hasPermissions(getEntryIterator(new EntryPredicate()), repositoryPermissions, null);\n}", "lc": -0.45454545454545453, "pi": -0.6028708133971293, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.8548273431994357, "fo": -0.3333333333333333, "r": 0.31578947368421056, "e": -0.16279340490885932}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-371_bb005b56", "label": 1, "code": "/**\n * Returns a matrix of p-values associated with the (two-sided) null\n * hypothesis that the corresponding correlation coefficient is zero.\n * <p><code>getCorrelationPValues().getEntry(i,j)</code> is the probability\n * that a random variable distributed as <code>t<sub>n-2</sub></code> takes\n * a value with absolute value greater than or equal to <br>\n * <code>|r|((n - 2) / (1 - r<sup>2</sup>))<sup>1/2</sup></code></p>\n * <p>The values in the matrix are sometimes referred to as the\n * <i>significance</i> of the corresponding correlation coefficients.</p>\n *\n * @return matrix of p-values\n * @throws MathException if an error occurs estimating probabilities\n */\npublic RealMatrix getCorrelationPValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double r = correlationMatrix.getEntry(i, j);\n                double t = Math.abs(r * Math.sqrt((nObs - 2) / (1 - r * r)));\n                out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n            }\n        }\n    }\n    return new BlockRealMatrix(out);\n}", "code_comment": "/**\n * Returns a matrix of p-values associated with the (two-sided) null\n * hypothesis that the corresponding correlation coefficient is zero.\n * <p><code>getCorrelationPValues().getEntry(i,j)</code> is the probability\n * that a random variable distributed as <code>t<sub>n-2</sub></code> takes\n * a value with absolute value greater than or equal to <br>\n * <code>|r|((n - 2) / (1 - r<sup>2</sup>))<sup>1/2</sup></code></p>\n * <p>The values in the matrix are sometimes referred to as the\n * <i>significance</i> of the corresponding correlation coefficients.</p>\n *\n * @return matrix of p-values\n * @throws MathException if an error occurs estimating probabilities\n */\n", "code_no_comment": "public RealMatrix getCorrelationPValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double r = correlationMatrix.getEntry(i, j);\n                double t = Math.abs(r * Math.sqrt((nObs - 2) / (1 - r * r)));\n                out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n            }\n        }\n    }\n    return new BlockRealMatrix(out);\n}", "lc": 0.13636363636363635, "pi": 1.2344497607655505, "ma": 0.0, "nbd": 0.5, "ml": 0.08333333333333333, "d": 0.9404761904761905, "mi": -0.2197322057787174, "fo": -0.08333333333333333, "r": 0.02631578947368421, "e": 1.0455536153708727}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-3011_5a86a0a1", "label": 0, "code": "public void cancel() {\n    while (true) {\n        JobStatus current = state;\n        if (current == JobStatus.RUNNING || current == JobStatus.CREATED) {\n            if (transitionState(current, JobStatus.CANCELLING)) {\n                for (ExecutionJobVertex ejv : verticesInCreationOrder) {\n                    ejv.cancel();\n                }\n                return;\n            }\n        } else {\n            // no need to treat other states\n            return;\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "public void cancel() {\n    while (true) {\n        JobStatus current = state;\n        if (current == JobStatus.RUNNING || current == JobStatus.CREATED) {\n            if (transitionState(current, JobStatus.CANCELLING)) {\n                for (ExecutionJobVertex ejv : verticesInCreationOrder) {\n                    ejv.cancel();\n                }\n                return;\n            }\n        } else {\n                        return;\n        }\n    }\n}", "lc": 0.045454545454545456, "pi": 1.3492822966507174, "ma": 0.2, "nbd": 1.0, "ml": 0.08333333333333333, "d": -0.04365079365079365, "mi": 0.03340380549682881, "fo": -0.3333333333333333, "r": 0.5263157894736842, "e": -0.08831797513874241}
{"project_name": "Cli", "project_version": 27, "label": 1, "code": "/**\n * Set the selected option of this group to <code>name</code>.\n *\n * @param option the option that is selected\n * @throws AlreadySelectedException if an option from this group has\n * already been selected.\n */\npublic void setSelected(Option option) throws AlreadySelectedException {\n    if (option == null) {\n        // reset the option previously selected\n        selected = null;\n        return;\n    }\n    // selected member variable\n    if (selected == null || selected.equals(option.getOpt())) {\n        selected = option.getOpt();\n    } else {\n        throw new AlreadySelectedException(this, option);\n    }\n}", "code_comment": "/**\n * Set the selected option of this group to <code>name</code>.\n *\n * @param option the option that is selected\n * @throws AlreadySelectedException if an option from this group has\n * already been selected.\n */\n", "code_no_comment": "public void setSelected(Option option) throws AlreadySelectedException {\n    if (option == null) {\n                selected = null;\n        return;\n    }\n        if (selected == null || selected.equals(option.getOpt())) {\n        selected = option.getOpt();\n    } else {\n        throw new AlreadySelectedException(this, option);\n    }\n}", "lc": -0.13636363636363635, "pi": -0.06220095693779921, "ma": 0.0, "nbd": -0.5, "ml": 0.16666666666666666, "d": 0.07539682539682542, "mi": 0.19774489076814655, "fo": -0.25, "r": 0.21052631578947367, "e": -0.07097387666188344}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-6779_f412d744", "label": 1, "code": "@Converter\npublic XMLStreamReader createXMLStreamReader(InputStream in, Exchange exchange) throws XMLStreamException {\n    XMLInputFactory factory = getInputFactory();\n    try {\n        return factory.createXMLStreamReader(IOHelper.buffered(in), IOHelper.getCharsetName(exchange));\n    } finally {\n        returnXMLInputFactory(factory);\n    }\n}", "code_comment": NaN, "code_no_comment": "@Converter\npublic XMLStreamReader createXMLStreamReader(InputStream in, Exchange exchange) throws XMLStreamException {\n    XMLInputFactory factory = getInputFactory();\n    try {\n        return factory.createXMLStreamReader(IOHelper.buffered(in), IOHelper.getCharsetName(exchange));\n    } finally {\n        returnXMLInputFactory(factory);\n    }\n}", "lc": -0.22727272727272727, "pi": -0.01913875598086126, "ma": -0.6, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.30176180408738534, "fo": -0.08333333333333333, "r": 0.2894736842105263, "e": -0.16279340490885932}
{"project_name": "Closure", "project_version": 4, "label": 2, "code": "/**\n * Resolve the referenced type within the enclosing scope.\n */\n@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {\n    // TODO(user): Investigate whether it is really necessary to keep two\n    // different mechanisms for resolving named types, and if so, which order\n    // makes more sense. Now, resolution via registry is first in order to\n    // avoid triggering the warnings built into the resolution via properties.\n    boolean resolved = resolveViaRegistry(t, enclosing);\n    if (detectImplicitPrototypeCycle()) {\n        handleTypeCycle(t);\n    }\n    if (resolved) {\n        super.resolveInternal(t, enclosing);\n        finishPropertyContinuations();\n        return registry.isLastGeneration() ? getReferencedType() : this;\n    }\n    resolveViaProperties(t, enclosing);\n    if (detectImplicitPrototypeCycle()) {\n        handleTypeCycle(t);\n    }\n    super.resolveInternal(t, enclosing);\n    if (isResolved()) {\n        finishPropertyContinuations();\n    }\n    return registry.isLastGeneration() ? getReferencedType() : this;\n}", "code_comment": "/**\n * Resolve the referenced type within the enclosing scope.\n */\n", "code_no_comment": "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {\n                    boolean resolved = resolveViaRegistry(t, enclosing);\n    if (detectImplicitPrototypeCycle()) {\n        handleTypeCycle(t);\n    }\n    if (resolved) {\n        super.resolveInternal(t, enclosing);\n        finishPropertyContinuations();\n        return registry.isLastGeneration() ? getReferencedType() : this;\n    }\n    resolveViaProperties(t, enclosing);\n    if (detectImplicitPrototypeCycle()) {\n        handleTypeCycle(t);\n    }\n    super.resolveInternal(t, enclosing);\n    if (isResolved()) {\n        finishPropertyContinuations();\n    }\n    return registry.isLastGeneration() ? getReferencedType() : this;\n}", "lc": 0.3181818181818182, "pi": -0.20574162679425848, "ma": 0.6, "nbd": -0.5, "ml": 0.4166666666666667, "d": -0.3650793650793651, "mi": -0.20704721634954185, "fo": 0.75, "r": -0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "Math", "project_version": 50, "label": 1, "code": "/**\n * {@inheritDoc}\n */\nprotected final double doSolve() {\n    // Get initial solution\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    // regardless of the allowed solutions.\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    // Verify bracketing of initial solution.\n    verifyBracketing(x0, x1);\n    // Get accuracies.\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    // Keep track of inverted intervals, meaning that the left bound is\n    // larger than the right bound.\n    boolean inverted = false;\n    // Keep finding better approximations.\n    while (true) {\n        // Calculate the next approximation.\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        // we can return it regardless of the allowed solutions.\n        if (fx == 0.0) {\n            return x;\n        }\n        // Update the bounds with the new approximation.\n        if (f1 * fx < 0) {\n            // The value of x1 has switched to the other bound, thus inverting\n            // the interval.\n            x0 = x1;\n            f0 = f1;\n            inverted = !inverted;\n        } else {\n            switch(method) {\n                case ILLINOIS:\n                    f0 *= 0.5;\n                    break;\n                case PEGASUS:\n                    f0 *= f1 / (f1 + fx);\n                    break;\n                case REGULA_FALSI:\n                    // Nothing.\n                    if (x == x1) {\n                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                        f0 = computeObjectiveValue(x0);\n                    }\n                    break;\n                default:\n                    // Should never happen.\n                    throw new MathInternalError();\n            }\n        }\n        // Update from [x0, x1] to [x0, x].\n        x1 = x;\n        f1 = fx;\n        // the root than we already are.\n        if (FastMath.abs(f1) <= ftol) {\n            switch(allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                case BELOW_SIDE:\n                    if (f1 <= 0) {\n                        return x1;\n                    }\n                    break;\n                case ABOVE_SIDE:\n                    if (f1 >= 0) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n        // are satisfied with the current approximation.\n        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {\n            switch(allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                case BELOW_SIDE:\n                    return (f1 <= 0) ? x1 : x0;\n                case ABOVE_SIDE:\n                    return (f1 >= 0) ? x1 : x0;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n    }\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "protected final double doSolve() {\n        double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n        if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n        verifyBracketing(x0, x1);\n        final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n            boolean inverted = false;\n        while (true) {\n                final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n                if (fx == 0.0) {\n            return x;\n        }\n                if (f1 * fx < 0) {\n                                    x0 = x1;\n            f0 = f1;\n            inverted = !inverted;\n        } else {\n            switch(method) {\n                case ILLINOIS:\n                    f0 *= 0.5;\n                    break;\n                case PEGASUS:\n                    f0 *= f1 / (f1 + fx);\n                    break;\n                case REGULA_FALSI:\n                                        if (x == x1) {\n                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                        f0 = computeObjectiveValue(x0);\n                    }\n                    break;\n                default:\n                                        throw new MathInternalError();\n            }\n        }\n                x1 = x;\n        f1 = fx;\n                if (FastMath.abs(f1) <= ftol) {\n            switch(allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                case BELOW_SIDE:\n                    if (f1 <= 0) {\n                        return x1;\n                    }\n                    break;\n                case ABOVE_SIDE:\n                    if (f1 >= 0) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n                if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {\n            switch(allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                case BELOW_SIDE:\n                    return (f1 <= 0) ? x1 : x0;\n                case ABOVE_SIDE:\n                    return (f1 >= 0) ? x1 : x0;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n    }\n}", "lc": 3.5454545454545454, "pi": 1.7751196172248804, "ma": 7.8, "nbd": 1.5, "ml": 3.3333333333333335, "d": 3.238095238095238, "mi": -1.3833685694150806, "fo": 0.8333333333333334, "r": -0.02631578947368421, "e": 8.485761541697642}
{"project_name": "Compress", "project_version": 32, "label": 3, "code": "private void applyPaxHeadersToCurrentEntry(Map<String, String> headers) {\n    /*\n         * The following headers are defined for Pax.\n         * atime, ctime, charset: cannot use these without changing TarArchiveEntry fields\n         * mtime\n         * comment\n         * gid, gname\n         * linkpath\n         * size\n         * uid,uname\n         * SCHILY.devminor, SCHILY.devmajor: don't have setters/getters for those\n         */\n    for (Entry<String, String> ent : headers.entrySet()) {\n        String key = ent.getKey();\n        String val = ent.getValue();\n        if (\"path\".equals(key)) {\n            currEntry.setName(val);\n        } else if (\"linkpath\".equals(key)) {\n            currEntry.setLinkName(val);\n        } else if (\"gid\".equals(key)) {\n            currEntry.setGroupId(Integer.parseInt(val));\n        } else if (\"gname\".equals(key)) {\n            currEntry.setGroupName(val);\n        } else if (\"uid\".equals(key)) {\n            currEntry.setUserId(Integer.parseInt(val));\n        } else if (\"uname\".equals(key)) {\n            currEntry.setUserName(val);\n        } else if (\"size\".equals(key)) {\n            currEntry.setSize(Long.parseLong(val));\n        } else if (\"mtime\".equals(key)) {\n            currEntry.setModTime((long) (Double.parseDouble(val) * 1000));\n        } else if (\"SCHILY.devminor\".equals(key)) {\n            currEntry.setDevMinor(Integer.parseInt(val));\n        } else if (\"SCHILY.devmajor\".equals(key)) {\n            currEntry.setDevMajor(Integer.parseInt(val));\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "private void applyPaxHeadersToCurrentEntry(Map<String, String> headers) {\n        for (Entry<String, String> ent : headers.entrySet()) {\n        String key = ent.getKey();\n        String val = ent.getValue();\n        if (\"path\".equals(key)) {\n            currEntry.setName(val);\n        } else if (\"linkpath\".equals(key)) {\n            currEntry.setLinkName(val);\n        } else if (\"gid\".equals(key)) {\n            currEntry.setGroupId(Integer.parseInt(val));\n        } else if (\"gname\".equals(key)) {\n            currEntry.setGroupName(val);\n        } else if (\"uid\".equals(key)) {\n            currEntry.setUserId(Integer.parseInt(val));\n        } else if (\"uname\".equals(key)) {\n            currEntry.setUserName(val);\n        } else if (\"size\".equals(key)) {\n            currEntry.setSize(Long.parseLong(val));\n        } else if (\"mtime\".equals(key)) {\n            currEntry.setModTime((long) (Double.parseDouble(val) * 1000));\n        } else if (\"SCHILY.devminor\".equals(key)) {\n            currEntry.setDevMinor(Integer.parseInt(val));\n        } else if (\"SCHILY.devmajor\".equals(key)) {\n            currEntry.setDevMajor(Integer.parseInt(val));\n        }\n    }\n}", "lc": 0.5909090909090909, "pi": 0.1913875598086124, "ma": 1.6, "nbd": 4.5, "ml": 1.3333333333333333, "d": 0.0853174603174603, "mi": -0.5221987315010571, "fo": 1.9166666666666667, "r": -0.02631578947368421, "e": 0.3819643505471896}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-343_f6dd42b4", "label": 0, "code": "/**\n * Find a zero in the given interval with an initial guess.\n * <p>Throws <code>IllegalArgumentException</code> if the values of the\n * function at the three points have the same sign (note that it is\n * allowed to have endpoints with the same sign if the initial point has\n * opposite sign function-wise).</p>\n *\n * @param f function to solve.\n * @param min the lower bound for the interval.\n * @param max the upper bound for the interval.\n * @param initial the start value to use (must be set to min if no\n * initial point is known).\n * @return the value where the function is zero\n * @throws MaxIterationsExceededException the maximum iteration count\n * is exceeded\n * @throws FunctionEvaluationException if an error occurs evaluating\n *  the function\n * @throws IllegalArgumentException if initial is not between min and max\n * (even if it <em>is</em> a root)\n */\npublic double solve(final UnivariateRealFunction f, final double min, final double max, final double initial) throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifySequence(min, initial, max);\n    // return the initial guess if it is good enough\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n    // return the first endpoint if it is good enough\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(yMin, 0);\n        return result;\n    }\n    // reduce interval if min and initial bracket the root\n    if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n    // return the second endpoint if it is good enough\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(yMax, 0);\n        return result;\n    }\n    // reduce interval if initial and max bracket the root\n    if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }\n    // full Brent algorithm starting with provided initial guess\n    return solve(f, min, yMin, max, yMax, initial, yInitial);\n}", "code_comment": "/**\n * Find a zero in the given interval with an initial guess.\n * <p>Throws <code>IllegalArgumentException</code> if the values of the\n * function at the three points have the same sign (note that it is\n * allowed to have endpoints with the same sign if the initial point has\n * opposite sign function-wise).</p>\n *\n * @param f function to solve.\n * @param min the lower bound for the interval.\n * @param max the upper bound for the interval.\n * @param initial the start value to use (must be set to min if no\n * initial point is known).\n * @return the value where the function is zero\n * @throws MaxIterationsExceededException the maximum iteration count\n * is exceeded\n * @throws FunctionEvaluationException if an error occurs evaluating\n *  the function\n * @throws IllegalArgumentException if initial is not between min and max\n * (even if it <em>is</em> a root)\n */\n", "code_no_comment": "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial) throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifySequence(min, initial, max);\n        double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n        double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(yMin, 0);\n        return result;\n    }\n        if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n        double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(yMax, 0);\n        return result;\n    }\n        if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }\n        return solve(f, min, yMin, max, yMax, initial, yInitial);\n}", "lc": 0.5454545454545454, "pi": -0.3301435406698567, "ma": 0.4, "nbd": -0.5, "ml": 0.5833333333333334, "d": 1.146825396825397, "mi": -0.4339675828047919, "fo": 0.6666666666666666, "r": -0.02631578947368421, "e": 1.3053047722780264}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-258_7b38965d", "label": 1, "code": "/**\n * Create an HTML Layout.\n * @param locationInfo If \"true\", location information will be included. The default is false.\n * @param title The title to include in the file header. If none is specified the default title will be used.\n * @param contentType The content type. Defaults to \"text/html\".\n * @param charsetName The character set to use. If not specified, the default will be used.\n * @param fontSize The font size of the text.\n * @param font The font to use for the text.\n * @return An HTML Layout.\n */\n@PluginFactory\npublic static HTMLLayout createLayout(@PluginAttr(\"locationInfo\") final String locationInfo, @PluginAttr(\"title\") String title, @PluginAttr(\"contentType\") String contentType, @PluginAttr(\"charset\") final String charsetName, @PluginAttr(\"fontSize\") String fontSize, @PluginAttr(\"fontName\") String font) {\n    final Charset charset = Charsets.getSupportedCharset(charsetName);\n    if (font == null) {\n        font = \"arial,sans-serif\";\n    }\n    final FontSize fs = FontSize.getFontSize(fontSize);\n    fontSize = fs.getFontSize();\n    final String headerSize = fs.larger().getFontSize();\n    final boolean info = locationInfo == null ? false : Boolean.valueOf(locationInfo);\n    if (title == null) {\n        title = DEFAULT_TITLE;\n    }\n    if (contentType == null) {\n        contentType = DEFAULT_CONTENT_TYPE;\n    }\n    return new HTMLLayout(info, title, contentType, charset, font, fontSize, headerSize);\n}", "code_comment": "/**\n * Create an HTML Layout.\n * @param locationInfo If \"true\", location information will be included. The default is false.\n * @param title The title to include in the file header. If none is specified the default title will be used.\n * @param contentType The content type. Defaults to \"text/html\".\n * @param charsetName The character set to use. If not specified, the default will be used.\n * @param fontSize The font size of the text.\n * @param font The font to use for the text.\n * @return An HTML Layout.\n */\n", "code_no_comment": "@PluginFactory\npublic static HTMLLayout createLayout(@PluginAttr(\"locationInfo\") final String locationInfo, @PluginAttr(\"title\") String title, @PluginAttr(\"contentType\") String contentType, @PluginAttr(\"charset\") final String charsetName, @PluginAttr(\"fontSize\") String fontSize, @PluginAttr(\"fontName\") String font) {\n    final Charset charset = Charsets.getSupportedCharset(charsetName);\n    if (font == null) {\n        font = \"arial,sans-serif\";\n    }\n    final FontSize fs = FontSize.getFontSize(fontSize);\n    fontSize = fs.getFontSize();\n    final String headerSize = fs.larger().getFontSize();\n    final boolean info = locationInfo == null ? false : Boolean.valueOf(locationInfo);\n    if (title == null) {\n        title = DEFAULT_TITLE;\n    }\n    if (contentType == null) {\n        contentType = DEFAULT_CONTENT_TYPE;\n    }\n    return new HTMLLayout(info, title, contentType, charset, font, fontSize, headerSize);\n}", "lc": 0.18181818181818182, "pi": -0.32535885167464124, "ma": 0.2, "nbd": -0.5, "ml": 0.25, "d": 0.11706349206349208, "mi": -0.2617336152219872, "fo": 0.0, "r": -0.02631578947368421, "e": 0.3139941102908548}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1199_813109d7", "label": 3, "code": "public int compareTo(setTableProperty_result other) {\n    if (!getClass().equals(other.getClass())) {\n        return getClass().getName().compareTo(other.getClass().getName());\n    }\n    int lastComparison = 0;\n    setTableProperty_result typedOther = (setTableProperty_result) other;\n    lastComparison = Boolean.valueOf(isSetOuch1()).compareTo(typedOther.isSetOuch1());\n    if (lastComparison != 0) {\n        return lastComparison;\n    }\n    if (isSetOuch1()) {\n        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.ouch1, typedOther.ouch1);\n        if (lastComparison != 0) {\n            return lastComparison;\n        }\n    }\n    lastComparison = Boolean.valueOf(isSetOuch2()).compareTo(typedOther.isSetOuch2());\n    if (lastComparison != 0) {\n        return lastComparison;\n    }\n    if (isSetOuch2()) {\n        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.ouch2, typedOther.ouch2);\n        if (lastComparison != 0) {\n            return lastComparison;\n        }\n    }\n    return 0;\n}", "code_comment": NaN, "code_no_comment": "public int compareTo(setTableProperty_result other) {\n    if (!getClass().equals(other.getClass())) {\n        return getClass().getName().compareTo(other.getClass().getName());\n    }\n    int lastComparison = 0;\n    setTableProperty_result typedOther = (setTableProperty_result) other;\n    lastComparison = Boolean.valueOf(isSetOuch1()).compareTo(typedOther.isSetOuch1());\n    if (lastComparison != 0) {\n        return lastComparison;\n    }\n    if (isSetOuch1()) {\n        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.ouch1, typedOther.ouch1);\n        if (lastComparison != 0) {\n            return lastComparison;\n        }\n    }\n    lastComparison = Boolean.valueOf(isSetOuch2()).compareTo(typedOther.isSetOuch2());\n    if (lastComparison != 0) {\n        return lastComparison;\n    }\n    if (isSetOuch2()) {\n        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.ouch2, typedOther.ouch2);\n        if (lastComparison != 0) {\n            return lastComparison;\n        }\n    }\n    return 0;\n}", "lc": 0.6363636363636364, "pi": -0.04306220095693795, "ma": 0.8, "nbd": 0.0, "ml": 0.5833333333333334, "d": 0.2996031746031746, "mi": -0.4556730091613809, "fo": 1.1666666666666667, "r": -0.02631578947368421, "e": 0.3821533744806163}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-217_add180fb", "label": 1, "code": "@Override\npublic void rename(String oldTableName, String newTableName) throws AccumuloSecurityException, TableNotFoundException, AccumuloException, TableExistsException {\n    MockTable t = acu.tables.remove(oldTableName);\n    acu.tables.put(newTableName, t);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void rename(String oldTableName, String newTableName) throws AccumuloSecurityException, TableNotFoundException, AccumuloException, TableExistsException {\n    MockTable t = acu.tables.remove(oldTableName);\n    acu.tables.put(newTableName, t);\n}", "lc": -0.4090909090909091, "pi": -0.49282296650717716, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.5701198026779419, "fo": -0.3333333333333333, "r": -0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3082_29e5b734", "label": 3, "code": "@Nonnull\n@Override\npublic AccessControlPolicy[] getEffectivePolicies(@Nonnull Set<Principal> principals) throws RepositoryException {\n    Util.checkValidPrincipals(principals, principalManager);\n    Root r = getLatestRoot();\n    Result aceResult = searchAces(principals, r);\n    List<AccessControlPolicy> effective = new ArrayList<AccessControlPolicy>();\n    for (ResultRow row : aceResult.getRows()) {\n        String acePath = row.getPath();\n        String aclName = Text.getName(Text.getRelativeParent(acePath, 1));\n        Tree accessControlledTree = r.getTree(Text.getRelativeParent(acePath, 2));\n        if (aclName.isEmpty() || !accessControlledTree.exists()) {\n            log.debug(\"Isolated access control entry -> ignore query result at \" + acePath);\n            continue;\n        }\n        String path = (REP_REPO_POLICY.equals(aclName)) ? null : accessControlledTree.getPath();\n        AccessControlPolicy policy = createACL(path, accessControlledTree, true);\n        if (policy != null) {\n            effective.add(policy);\n        }\n    }\n    return effective.toArray(new AccessControlPolicy[effective.size()]);\n}", "code_comment": NaN, "code_no_comment": "@Nonnull\n@Override\npublic AccessControlPolicy[] getEffectivePolicies(@Nonnull Set<Principal> principals) throws RepositoryException {\n    Util.checkValidPrincipals(principals, principalManager);\n    Root r = getLatestRoot();\n    Result aceResult = searchAces(principals, r);\n    List<AccessControlPolicy> effective = new ArrayList<AccessControlPolicy>();\n    for (ResultRow row : aceResult.getRows()) {\n        String acePath = row.getPath();\n        String aclName = Text.getName(Text.getRelativeParent(acePath, 1));\n        Tree accessControlledTree = r.getTree(Text.getRelativeParent(acePath, 2));\n        if (aclName.isEmpty() || !accessControlledTree.exists()) {\n            log.debug(\"Isolated access control entry -> ignore query result at \" + acePath);\n            continue;\n        }\n        String path = (REP_REPO_POLICY.equals(aclName)) ? null : accessControlledTree.getPath();\n        AccessControlPolicy policy = createACL(path, accessControlledTree, true);\n        if (policy != null) {\n            effective.add(policy);\n        }\n    }\n    return effective.toArray(new AccessControlPolicy[effective.size()]);\n}", "lc": 0.4090909090909091, "pi": 0.3444976076555023, "ma": 0.4, "nbd": 0.0, "ml": 0.3333333333333333, "d": 0.27976190476190477, "mi": -0.41846370683579975, "fo": 1.0, "r": -0.02631578947368421, "e": 0.6650991511211769}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5359_61122bab", "label": 3, "code": "/**\n *  Convert to character, returning default value if text is inconvertible.\n *\n *  @param defaultValue\n *             the default value\n *  @return the converted text as a primitive char or the default value if text is not a single character\n */\npublic final char toChar(final char defaultValue) {\n    if (text != null) {\n        try {\n            return toChar();\n        } catch (StringValueConversionException x) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(String.format(\"An error occurred while converting '%s' to a character: %s\", text, x.getMessage()), x);\n            }\n        }\n    }\n    return defaultValue;\n}", "code_comment": "/**\n *  Convert to character, returning default value if text is inconvertible.\n *\n *  @param defaultValue\n *             the default value\n *  @return the converted text as a primitive char or the default value if text is not a single character\n */\n", "code_no_comment": "public final char toChar(final char defaultValue) {\n    if (text != null) {\n        try {\n            return toChar();\n        } catch (StringValueConversionException x) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(String.format(\"An error occurred while converting '%s' to a character: %s\", text, x.getMessage()), x);\n            }\n        }\n    }\n    return defaultValue;\n}", "lc": -0.09090909090909091, "pi": 0.8899521531100476, "ma": 0.0, "nbd": 0.5, "ml": -0.08333333333333333, "d": -0.3650793650793651, "mi": 0.17096546863988715, "fo": -0.08333333333333333, "r": 1.0789473684210527, "e": -0.16279340490885932}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-1820_39d526e6", "label": 0, "code": "@Override\npublic int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, Integer reusable) {\n    long val = 0;\n    boolean neg = false;\n    final int delimLimit = limit - delimiter.length + 1;\n    if (bytes[startPos] == '-') {\n        neg = true;\n        startPos++;\n        // check for empty field with only the sign\n        if (startPos == limit || (startPos < delimLimit && delimiterNext(bytes, startPos, delimiter))) {\n            setErrorState(ParseErrorState.NUMERIC_VALUE_ORPHAN_SIGN);\n            return -1;\n        }\n    }\n    for (int i = startPos; i < limit; i++) {\n        if (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\n            this.result = (int) (neg ? -val : val);\n            return i + delimiter.length;\n        }\n        if (bytes[i] < 48 || bytes[i] > 57) {\n            setErrorState(ParseErrorState.NUMERIC_VALUE_ILLEGAL_CHARACTER);\n            return -1;\n        }\n        val *= 10;\n        val += bytes[i] - 48;\n        if (val > OVERFLOW_BOUND && (!neg || val > UNDERFLOW_BOUND)) {\n            setErrorState(ParseErrorState.NUMERIC_VALUE_OVERFLOW_UNDERFLOW);\n            return -1;\n        }\n    }\n    this.result = (int) (neg ? -val : val);\n    return limit;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, Integer reusable) {\n    long val = 0;\n    boolean neg = false;\n    final int delimLimit = limit - delimiter.length + 1;\n    if (bytes[startPos] == '-') {\n        neg = true;\n        startPos++;\n                if (startPos == limit || (startPos < delimLimit && delimiterNext(bytes, startPos, delimiter))) {\n            setErrorState(ParseErrorState.NUMERIC_VALUE_ORPHAN_SIGN);\n            return -1;\n        }\n    }\n    for (int i = startPos; i < limit; i++) {\n        if (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\n            this.result = (int) (neg ? -val : val);\n            return i + delimiter.length;\n        }\n        if (bytes[i] < 48 || bytes[i] > 57) {\n            setErrorState(ParseErrorState.NUMERIC_VALUE_ILLEGAL_CHARACTER);\n            return -1;\n        }\n        val *= 10;\n        val += bytes[i] - 48;\n        if (val > OVERFLOW_BOUND && (!neg || val > UNDERFLOW_BOUND)) {\n            setErrorState(ParseErrorState.NUMERIC_VALUE_OVERFLOW_UNDERFLOW);\n            return -1;\n        }\n    }\n    this.result = (int) (neg ? -val : val);\n    return limit;\n}", "lc": 0.8181818181818182, "pi": 0.3444976076555023, "ma": 1.0, "nbd": 0.0, "ml": 1.5833333333333333, "d": 2.8611111111111116, "mi": -0.6129668780831571, "fo": -0.08333333333333333, "r": -0.02631578947368421, "e": 4.717929035344017}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-2734_8b40bb7a", "label": 0, "code": "@Override\npublic Tuple getKey(IN value) throws Exception {\n    key = (Tuple) tupleClasses[keyLength - 1].newInstance();\n    comparator.extractKeys(value, keyArray, 0);\n    for (int i = 0; i < keyLength; i++) {\n        key.setField(keyArray[i], i);\n    }\n    return key;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic Tuple getKey(IN value) throws Exception {\n    key = (Tuple) tupleClasses[keyLength - 1].newInstance();\n    comparator.extractKeys(value, keyArray, 0);\n    for (int i = 0; i < keyLength; i++) {\n        key.setField(keyArray[i], i);\n    }\n    return key;\n}", "lc": -0.22727272727272727, "pi": -0.22966507177033516, "ma": -0.4, "nbd": -0.5, "ml": -0.16666666666666666, "d": 0.27380952380952384, "mi": 0.2250880902043692, "fo": -0.25, "r": 0.05263157894736841, "e": 0.06244935829832355}