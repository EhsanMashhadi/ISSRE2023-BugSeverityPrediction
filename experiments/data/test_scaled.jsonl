{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-3260_6968a57a", "label": 0, "code": "public void cancel() {\n    // successful atomic state transition\n    while (true) {\n        ExecutionState current = this.state;\n        if (current == CANCELING || current == CANCELED) {\n            // already taken care of, no need to cancel again\n            return;\n        } else // these two are the common cases where we need to send a cancel call\n        if (current == RUNNING || current == DEPLOYING) {\n            // try to transition to canceling, if successful, send the cancel call\n            if (transitionState(current, CANCELING)) {\n                sendCancelRpcCall();\n                return;\n            }\n        // else: fall through the loop\n        } else if (current == FINISHED || current == FAILED) {\n            // nothing to do any more. finished failed before it could be cancelled.\n            // in any case, the task is removed from the TaskManager already\n            sendFailIntermediateResultPartitionsRpcCall();\n            return;\n        } else if (current == CREATED || current == SCHEDULED) {\n            // from here, we can directly switch to cancelled, because the no task has been deployed\n            if (transitionState(current, CANCELED)) {\n                // we skip the canceling state. set the timestamp, for a consistent appearance\n                markTimestamp(CANCELING, getStateTimestamp(CANCELED));\n                try {\n                    vertex.getExecutionGraph().deregisterExecution(this);\n                    if (assignedResource != null) {\n                        assignedResource.releaseSlot();\n                    }\n                } finally {\n                    vertex.executionCanceled();\n                }\n                return;\n            }\n        // else: fall through the loop\n        } else {\n            throw new IllegalStateException(current.name());\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "public void cancel() {\n        while (true) {\n        ExecutionState current = this.state;\n        if (current == CANCELING || current == CANCELED) {\n                        return;\n        } else         if (current == RUNNING || current == DEPLOYING) {\n                        if (transitionState(current, CANCELING)) {\n                sendCancelRpcCall();\n                return;\n            }\n                } else if (current == FINISHED || current == FAILED) {\n                                    sendFailIntermediateResultPartitionsRpcCall();\n            return;\n        } else if (current == CREATED || current == SCHEDULED) {\n                        if (transitionState(current, CANCELED)) {\n                                markTimestamp(CANCELING, getStateTimestamp(CANCELED));\n                try {\n                    vertex.getExecutionGraph().deregisterExecution(this);\n                    if (assignedResource != null) {\n                        assignedResource.releaseSlot();\n                    }\n                } finally {\n                    vertex.executionCanceled();\n                }\n                return;\n            }\n                } else {\n            throw new IllegalStateException(current.name());\n        }\n    }\n}", "lc": 0.8181818181818182, "pi": 1.3157894736842106, "ma": 1.2, "nbd": 3.0, "ml": 0.9166666666666666, "d": 0.2876984126984127, "mi": -0.5058491895701195, "fo": 0.4166666666666667, "r": -0.02631578947368421, "e": 0.29165240342778764}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-172_99e22ce4", "label": 1, "code": "private final Component children_remove(Component<?> component) {\n    int index = children_indexOf(component);\n    if (index != -1) {\n        return children_remove(index);\n    }\n    return null;\n}", "code_comment": NaN, "code_no_comment": "private final Component children_remove(Component<?> component) {\n    int index = children_indexOf(component);\n    if (index != -1) {\n        return children_remove(index);\n    }\n    return null;\n}", "lc": -0.3181818181818182, "pi": -0.20574162679425848, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": -0.04365079365079365, "mi": 0.48780831571529254, "fo": -0.3333333333333333, "r": 1.6052631578947367, "e": -0.12132339805097883}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-639_a5a1f1a2", "label": 1, "code": "@Override\npublic void logMessage(final String fqcn, final Level level, final Marker marker, final Message message, final Throwable thrown) {\n    Info info = threadlocalInfo.get();\n    if (info == null) {\n        info = new Info(new RingBufferLogEventTranslator(), Thread.currentThread().getName(), false);\n        threadlocalInfo.set(info);\n    }\n    // being logged calls Logger.log() from its toString() method\n    if (info.isAppenderThread && disruptor.getRingBuffer().remainingCapacity() == 0) {\n        // bypass RingBuffer and invoke Appender directly\n        config.loggerConfig.log(getName(), fqcn, marker, level, message, thrown);\n        return;\n    }\n    final boolean includeLocation = config.loggerConfig.isIncludeLocation();\n    // \n    info.translator.setValues(// \n    this, // \n    getName(), // \n    marker, // \n    fqcn, // \n    level, // \n    message, // \n    thrown, // \n    ThreadContext.getImmutableContext(), // \n    ThreadContext.getImmutableStack(), // LOG4J2-467\n    THREAD_NAME_STRATEGY.getThreadName(info), // exclude if not specified or if \"false\" was specified.\n    includeLocation ? location(fqcn) : null, // CachedClock: 10% faster than system clock, smaller gaps\n    clock.currentTimeMillis());\n    disruptor.publishEvent(info.translator);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void logMessage(final String fqcn, final Level level, final Marker marker, final Message message, final Throwable thrown) {\n    Info info = threadlocalInfo.get();\n    if (info == null) {\n        info = new Info(new RingBufferLogEventTranslator(), Thread.currentThread().getName(), false);\n        threadlocalInfo.set(info);\n    }\n        if (info.isAppenderThread && disruptor.getRingBuffer().remainingCapacity() == 0) {\n                config.loggerConfig.log(getName(), fqcn, marker, level, message, thrown);\n        return;\n    }\n    final boolean includeLocation = config.loggerConfig.isIncludeLocation();\n        info.translator.setValues(    this,     getName(),     marker,     fqcn,     level,     message,     thrown,     ThreadContext.getImmutableContext(),     ThreadContext.getImmutableStack(),     THREAD_NAME_STRATEGY.getThreadName(info),     includeLocation ? location(fqcn) : null,     clock.currentTimeMillis());\n    disruptor.publishEvent(info.translator);\n}", "lc": 0.5909090909090909, "pi": -0.4593301435406701, "ma": 0.0, "nbd": -0.5, "ml": 0.25, "d": -0.039682539682539715, "mi": -0.4477801268498943, "fo": 0.9166666666666666, "r": -0.02631578947368421, "e": 0.17594209413161366}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4301_50b52742", "label": 3, "code": "@Override\nprotected ResourceResponse newResourceResponse(final Attributes attributes) {\n    final ResourceResponse response = new ResourceResponse();\n    if (lastModifiedTime != null) {\n        response.setLastModified(lastModifiedTime);\n    } else {\n        response.setLastModified(Time.now());\n    }\n    if (response.dataNeedsToBeWritten(attributes)) {\n        response.setContentType(\"image/\" + getFormat());\n        response.setContentDisposition(ContentDisposition.INLINE);\n        final byte[] imageData = getImageData(attributes);\n        if (imageData == null) {\n            response.setError(HttpServletResponse.SC_NOT_FOUND);\n        } else {\n            response.setWriteCallback(new WriteCallback() {\n\n                @Override\n                public void writeData(final Attributes attributes) {\n                    attributes.getResponse().write(imageData);\n                }\n            });\n        }\n        configureResponse(response, attributes);\n    }\n    return response;\n}", "code_comment": NaN, "code_no_comment": "@Override\nprotected ResourceResponse newResourceResponse(final Attributes attributes) {\n    final ResourceResponse response = new ResourceResponse();\n    if (lastModifiedTime != null) {\n        response.setLastModified(lastModifiedTime);\n    } else {\n        response.setLastModified(Time.now());\n    }\n    if (response.dataNeedsToBeWritten(attributes)) {\n        response.setContentType(\"image/\" + getFormat());\n        response.setContentDisposition(ContentDisposition.INLINE);\n        final byte[] imageData = getImageData(attributes);\n        if (imageData == null) {\n            response.setError(HttpServletResponse.SC_NOT_FOUND);\n        } else {\n            response.setWriteCallback(new WriteCallback() {\n\n                @Override\n                public void writeData(final Attributes attributes) {\n                    attributes.getResponse().write(imageData);\n                }\n            });\n        }\n        configureResponse(response, attributes);\n    }\n    return response;\n}", "lc": 0.5454545454545454, "pi": 1.0287081339712916, "ma": 0.0, "nbd": 0.5, "ml": 0.16666666666666666, "d": 0.33531746031746024, "mi": -0.36969696969696947, "fo": 0.5833333333333334, "r": -0.02631578947368421, "e": 0.31787601643586144}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-639_a5a1f1a2", "label": 1, "code": "/**\n * If possible, delegates the invocation to {@code callAppenders} to another\n * thread and returns {@code true}. If this is not possible (if it detects\n * that delegating to another thread would cause deadlock because the\n * current call to Logger.log() originated from the appender thread and the\n * ringbuffer is full) then this method does nothing and returns {@code false}.\n * It is the responsibility of the caller to process the event when this\n * method returns {@code false}.\n *\n * @param event the event to delegate to another thread\n * @return {@code true} if delegation was successful, {@code false} if the\n *          calling thread needs to process the event itself\n */\npublic boolean callAppendersFromAnotherThread(final LogEvent event) {\n    // being logged calls Logger.log() from its toString() method\n    if (// \n    isAppenderThread.get() == Boolean.TRUE && disruptor.getRingBuffer().remainingCapacity() == 0) {\n        // bypass RingBuffer and invoke Appender directly\n        return false;\n    }\n    disruptor.getRingBuffer().publishEvent(translator, event, asyncLoggerConfig);\n    return true;\n}", "code_comment": "/**\n * If possible, delegates the invocation to {@code callAppenders} to another\n * thread and returns {@code true}. If this is not possible (if it detects\n * that delegating to another thread would cause deadlock because the\n * current call to Logger.log() originated from the appender thread and the\n * ringbuffer is full) then this method does nothing and returns {@code false}.\n * It is the responsibility of the caller to process the event when this\n * method returns {@code false}.\n *\n * @param event the event to delegate to another thread\n * @return {@code true} if delegation was successful, {@code false} if the\n *          calling thread needs to process the event itself\n */\n", "code_no_comment": "public boolean callAppendersFromAnotherThread(final LogEvent event) {\n        if (    isAppenderThread.get() == Boolean.TRUE && disruptor.getRingBuffer().remainingCapacity() == 0) {\n                return false;\n    }\n    disruptor.getRingBuffer().publishEvent(translator, event, asyncLoggerConfig);\n    return true;\n}", "lc": -0.2727272727272727, "pi": -0.2822966507177035, "ma": -0.4, "nbd": -0.5, "ml": -0.08333333333333333, "d": -0.130952380952381, "mi": 0.3434813248766737, "fo": -0.08333333333333333, "r": 0.02631578947368421, "e": -0.10980215879162993}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-3229_891584fb", "label": 1, "code": "public void printVerboseInfo() throws IOException {\n    StringBuilder sb = new StringBuilder(\"-\\n\");\n    sb.append(\"- Current user: \").append(connector.whoami()).append(\"\\n\");\n    if (execFile != null)\n        sb.append(\"- Executing commands from: \").append(execFile).append(\"\\n\");\n    if (disableAuthTimeout)\n        sb.append(\"- Authorization timeout: disabled\\n\");\n    else\n        sb.append(\"- Authorization timeout: \").append(String.format(\"%.2fs%n\", TimeUnit.NANOSECONDS.toSeconds(authTimeout)));\n    sb.append(\"- Debug: \").append(isDebuggingEnabled() ? \"on\" : \"off\").append(\"\\n\");\n    if (!scanIteratorOptions.isEmpty()) {\n        for (Entry<String, List<IteratorSetting>> entry : scanIteratorOptions.entrySet()) {\n            sb.append(\"- Session scan iterators for table \").append(entry.getKey()).append(\":\\n\");\n            for (IteratorSetting setting : entry.getValue()) {\n                sb.append(\"-    Iterator \").append(setting.getName()).append(\" options:\\n\");\n                sb.append(\"-        \").append(\"iteratorPriority\").append(\" = \").append(setting.getPriority()).append(\"\\n\");\n                sb.append(\"-        \").append(\"iteratorClassName\").append(\" = \").append(setting.getIteratorClass()).append(\"\\n\");\n                for (Entry<String, String> optEntry : setting.getOptions().entrySet()) {\n                    sb.append(\"-        \").append(optEntry.getKey()).append(\" = \").append(optEntry.getValue()).append(\"\\n\");\n                }\n            }\n        }\n    }\n    sb.append(\"-\\n\");\n    reader.printString(sb.toString());\n}", "code_comment": NaN, "code_no_comment": "public void printVerboseInfo() throws IOException {\n    StringBuilder sb = new StringBuilder(\"-\\n\");\n    sb.append(\"- Current user: \").append(connector.whoami()).append(\"\\n\");\n    if (execFile != null)\n        sb.append(\"- Executing commands from: \").append(execFile).append(\"\\n\");\n    if (disableAuthTimeout)\n        sb.append(\"- Authorization timeout: disabled\\n\");\n    else\n        sb.append(\"- Authorization timeout: \").append(String.format(\"%.2fs%n\", TimeUnit.NANOSECONDS.toSeconds(authTimeout)));\n    sb.append(\"- Debug: \").append(isDebuggingEnabled() ? \"on\" : \"off\").append(\"\\n\");\n    if (!scanIteratorOptions.isEmpty()) {\n        for (Entry<String, List<IteratorSetting>> entry : scanIteratorOptions.entrySet()) {\n            sb.append(\"- Session scan iterators for table \").append(entry.getKey()).append(\":\\n\");\n            for (IteratorSetting setting : entry.getValue()) {\n                sb.append(\"-    Iterator \").append(setting.getName()).append(\" options:\\n\");\n                sb.append(\"-        \").append(\"iteratorPriority\").append(\" = \").append(setting.getPriority()).append(\"\\n\");\n                sb.append(\"-        \").append(\"iteratorClassName\").append(\" = \").append(setting.getIteratorClass()).append(\"\\n\");\n                for (Entry<String, String> optEntry : setting.getOptions().entrySet()) {\n                    sb.append(\"-        \").append(optEntry.getKey()).append(\" = \").append(optEntry.getValue()).append(\"\\n\");\n                }\n            }\n        }\n    }\n    sb.append(\"-\\n\");\n    reader.printString(sb.toString());\n}", "lc": 0.5454545454545454, "pi": 1.2200956937799043, "ma": 0.8, "nbd": 1.0, "ml": 0.25, "d": 0.10515873015873016, "mi": -0.5351656095842141, "fo": 3.75, "r": -0.02631578947368421, "e": 0.6722405675328341}
{"project_name": "Math", "project_version": 84, "label": 0, "code": "/**\n * {@inheritDoc}\n */\n@Override\nprotected void iterateSimplex(final Comparator<RealPointValuePair> comparator) throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n    while (true) {\n        incrementIterationsCounter();\n        // save the original vertex\n        final RealPointValuePair[] original = simplex;\n        final RealPointValuePair best = original[0];\n        // perform a reflection step\n        final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n        if (comparator.compare(reflected, best) < 0) {\n            // compute the expanded simplex\n            final RealPointValuePair[] reflectedSimplex = simplex;\n            final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n            if (comparator.compare(reflected, expanded) <= 0) {\n                // accept the reflected simplex\n                simplex = reflectedSimplex;\n            }\n            return;\n        }\n        // compute the contracted simplex\n        final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n        if (comparator.compare(contracted, best) < 0) {\n            // check convergence\n            return;\n        }\n    }\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "@Override\nprotected void iterateSimplex(final Comparator<RealPointValuePair> comparator) throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n    while (true) {\n        incrementIterationsCounter();\n                final RealPointValuePair[] original = simplex;\n        final RealPointValuePair best = original[0];\n                final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n        if (comparator.compare(reflected, best) < 0) {\n                        final RealPointValuePair[] reflectedSimplex = simplex;\n            final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n            if (comparator.compare(reflected, expanded) <= 0) {\n                                simplex = reflectedSimplex;\n            }\n            return;\n        }\n                final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n        if (comparator.compare(contracted, best) < 0) {\n                        return;\n        }\n    }\n}", "lc": 0.3181818181818182, "pi": 0.6172248803827752, "ma": 0.2, "nbd": 0.5, "ml": 0.5, "d": 0.09722222222222222, "mi": -0.28794926004228333, "fo": 0.08333333333333333, "r": -0.02631578947368421, "e": 0.17479872985137412}
{"project_name": "Closure", "project_version": 148, "label": 2, "code": "/**\n * Folds 'typeof(foo)' if foo is a literal, e.g.\n * typeof(\"bar\") --> \"string\"\n * typeof(6) --> \"number\"\n */\nprivate Node tryFoldTypeof(Node originalTypeofNode) {\n    Preconditions.checkArgument(originalTypeofNode.getType() == Token.TYPEOF);\n    Node argumentNode = originalTypeofNode.getFirstChild();\n    if (argumentNode == null || !NodeUtil.isLiteralValue(argumentNode)) {\n        return originalTypeofNode;\n    }\n    String typeNameString = null;\n    switch(argumentNode.getType()) {\n        case Token.STRING:\n            typeNameString = \"string\";\n            break;\n        case Token.NUMBER:\n            typeNameString = \"number\";\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            typeNameString = \"boolean\";\n            break;\n        case Token.NULL:\n        case Token.OBJECTLIT:\n        case Token.ARRAYLIT:\n            typeNameString = \"object\";\n            break;\n        case Token.NAME:\n            // keyword undefined to something other than the value undefined.\n            if (\"undefined\".equals(argumentNode.getString())) {\n                typeNameString = \"undefined\";\n            }\n            break;\n    }\n    if (typeNameString != null) {\n        Node newNode = Node.newString(typeNameString);\n        originalTypeofNode.getParent().replaceChild(originalTypeofNode, newNode);\n        reportCodeChange();\n        return newNode;\n    }\n    return originalTypeofNode;\n}", "code_comment": "/**\n * Folds 'typeof(foo)' if foo is a literal, e.g.\n * typeof(\"bar\") --> \"string\"\n * typeof(6) --> \"number\"\n */\n", "code_no_comment": "private Node tryFoldTypeof(Node originalTypeofNode) {\n    Preconditions.checkArgument(originalTypeofNode.getType() == Token.TYPEOF);\n    Node argumentNode = originalTypeofNode.getFirstChild();\n    if (argumentNode == null || !NodeUtil.isLiteralValue(argumentNode)) {\n        return originalTypeofNode;\n    }\n    String typeNameString = null;\n    switch(argumentNode.getType()) {\n        case Token.STRING:\n            typeNameString = \"string\";\n            break;\n        case Token.NUMBER:\n            typeNameString = \"number\";\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            typeNameString = \"boolean\";\n            break;\n        case Token.NULL:\n        case Token.OBJECTLIT:\n        case Token.ARRAYLIT:\n            typeNameString = \"object\";\n            break;\n        case Token.NAME:\n                        if (\"undefined\".equals(argumentNode.getString())) {\n                typeNameString = \"undefined\";\n            }\n            break;\n    }\n    if (typeNameString != null) {\n        Node newNode = Node.newString(typeNameString);\n        originalTypeofNode.getParent().replaceChild(originalTypeofNode, newNode);\n        reportCodeChange();\n        return newNode;\n    }\n    return originalTypeofNode;\n}", "lc": 1.0454545454545454, "pi": 0.3779904306220094, "ma": 2.6, "nbd": 0.5, "ml": 1.0833333333333333, "d": 0.4166666666666666, "mi": -0.6772374911909795, "fo": 0.4166666666666667, "r": -0.02631578947368421, "e": 0.6556064613912852}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4839_8b294488", "label": 1, "code": "/**\n *  Gets the type converter that is registered for class c.\n *\n *  @param <C>\n *             The object to convert from and to String\n *  @param c\n *             The class to get the type converter for\n *  @return The type converter that is registered for class c or null if no type converter was\n *          registered for class c\n */\npublic final <C> IConverter<C> get(Class<C> c) {\n    @SuppressWarnings(\"unchecked\")\n    final IConverter<C> converter;\n    // a new instance should be created for each usage\n    if (Date.class.equals(c)) {\n        converter = (IConverter<C>) new DateConverter();\n    } else if (java.sql.Date.class.equals(c)) {\n        converter = (IConverter<C>) new SqlDateConverter();\n    } else if (java.sql.Time.class.equals(c)) {\n        converter = (IConverter<C>) new SqlTimeConverter();\n    } else if (java.sql.Timestamp.class.equals(c)) {\n        converter = (IConverter<C>) new SqlTimestampConverter();\n    } else if (Calendar.class.equals(c)) {\n        converter = (IConverter<C>) new CalendarConverter();\n    } else {\n        converter = (IConverter<C>) classToConverter.get(c.getName());\n    }\n    return converter;\n}", "code_comment": "/**\n *  Gets the type converter that is registered for class c.\n *\n *  @param <C>\n *             The object to convert from and to String\n *  @param c\n *             The class to get the type converter for\n *  @return The type converter that is registered for class c or null if no type converter was\n *          registered for class c\n */\n", "code_no_comment": "public final <C> IConverter<C> get(Class<C> c) {\n    @SuppressWarnings(\"unchecked\")\n    final IConverter<C> converter;\n        if (Date.class.equals(c)) {\n        converter = (IConverter<C>) new DateConverter();\n    } else if (java.sql.Date.class.equals(c)) {\n        converter = (IConverter<C>) new SqlDateConverter();\n    } else if (java.sql.Time.class.equals(c)) {\n        converter = (IConverter<C>) new SqlTimeConverter();\n    } else if (java.sql.Timestamp.class.equals(c)) {\n        converter = (IConverter<C>) new SqlTimestampConverter();\n    } else if (Calendar.class.equals(c)) {\n        converter = (IConverter<C>) new CalendarConverter();\n    } else {\n        converter = (IConverter<C>) classToConverter.get(c.getName());\n    }\n    return converter;\n}", "lc": 0.18181818181818182, "pi": -0.22966507177033516, "ma": 0.4, "nbd": 1.5, "ml": 0.5, "d": -0.3650793650793651, "mi": -0.22283298097251583, "fo": 0.08333333333333333, "r": -0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "Cli", "project_version": 22, "label": 1, "code": "/**\n * <p>If an {@link Option} exists for <code>token</code> then\n * add the token to the processed list.</p>\n *\n * <p>If an {@link Option} does not exist and <code>stopAtNonOption</code>\n * is set then add the remaining tokens to the processed tokens list\n * directly.</p>\n *\n * @param token The current option token\n * @param stopAtNonOption Specifies whether flattening should halt\n * at the first non option.\n */\nprivate void processOptionToken(String token, boolean stopAtNonOption) {\n    if (stopAtNonOption && !options.hasOption(token)) {\n        eatTheRest = true;\n    }\n    tokens.add(token);\n}", "code_comment": "/**\n * <p>If an {@link Option} exists for <code>token</code> then\n * add the token to the processed list.</p>\n *\n * <p>If an {@link Option} does not exist and <code>stopAtNonOption</code>\n * is set then add the remaining tokens to the processed tokens list\n * directly.</p>\n *\n * @param token The current option token\n * @param stopAtNonOption Specifies whether flattening should halt\n * at the first non option.\n */\n", "code_no_comment": "private void processOptionToken(String token, boolean stopAtNonOption) {\n    if (stopAtNonOption && !options.hasOption(token)) {\n        eatTheRest = true;\n    }\n    tokens.add(token);\n}", "lc": -0.36363636363636365, "pi": -0.11483253588516758, "ma": -0.4, "nbd": -0.5, "ml": 0.0, "d": -0.11309523809523811, "mi": 0.5351656095842141, "fo": -0.3333333333333333, "r": 1.2105263157894737, "e": -0.12481342530961312}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-5515_b3bb8670", "label": 1, "code": "/**\n * Continues processing the {@link org.apache.camel.Exchange} using asynchronous routing engine.\n *\n * @param poolSize the core pool size\n * @return the builder\n */\npublic ThreadsDefinition threads(int poolSize) {\n    ThreadsDefinition answer = threads();\n    answer.setPoolSize(poolSize);\n    addOutput(answer);\n    return answer;\n}", "code_comment": "/**\n * Continues processing the {@link org.apache.camel.Exchange} using asynchronous routing engine.\n *\n * @param poolSize the core pool size\n * @return the builder\n */\n", "code_no_comment": "public ThreadsDefinition threads(int poolSize) {\n    ThreadsDefinition answer = threads();\n    answer.setPoolSize(poolSize);\n    addOutput(answer);\n    return answer;\n}", "lc": -0.36363636363636365, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.6050739957716701, "fo": -0.25, "r": 2.5, "e": -0.16279340490885932}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-9238_169b981e", "label": 1, "code": "/**\n * Changes the name of this remote file. This method alters the absolute and\n * relative names as well.\n *\n * @param newName the new name\n */\npublic void changeFileName(String newName) {\n    LOG.trace(\"Changing name to: {}\", newName);\n    // Make sure the names is normalized.\n    String newFileName = FileUtil.normalizePath(newName);\n    String newEndpointPath = FileUtil.normalizePath(endpointPath);\n    LOG.trace(\"Normalized endpointPath: {}\", newEndpointPath);\n    LOG.trace(\"Normalized newFileName: ()\", newFileName);\n    File file = new File(newFileName);\n    if (!absolute) {\n        // for relative then we should avoid having the endpoint path duplicated so clip it\n        if (ObjectHelper.isNotEmpty(newEndpointPath) && newFileName.startsWith(newEndpointPath)) {\n            // in this logic here\n            if (newEndpointPath.endsWith(\"\" + File.separatorChar)) {\n                newFileName = ObjectHelper.after(newFileName, newEndpointPath);\n            } else {\n                newFileName = ObjectHelper.after(newFileName, newEndpointPath + File.separatorChar);\n            }\n            // reconstruct file with clipped name\n            file = new File(newFileName);\n        }\n    }\n    // store the file name only\n    setFileNameOnly(file.getName());\n    setFileName(file.getName());\n    // relative path\n    if (file.getParent() != null) {\n        setRelativeFilePath(file.getParent() + getFileSeparator() + file.getName());\n    } else {\n        setRelativeFilePath(file.getName());\n    }\n    // absolute path\n    if (isAbsolute(newFileName)) {\n        setAbsolute(true);\n        setAbsoluteFilePath(newFileName);\n    } else {\n        setAbsolute(false);\n        // construct a pseudo absolute filename that the file operations uses even for relative only\n        String path = ObjectHelper.isEmpty(endpointPath) ? \"\" : endpointPath + getFileSeparator();\n        setAbsoluteFilePath(path + getRelativeFilePath());\n    }\n    if (LOG.isTraceEnabled()) {\n        LOG.trace(\"FileNameOnly: {}\", getFileNameOnly());\n        LOG.trace(\"FileName: {}\", getFileName());\n        LOG.trace(\"Absolute: {}\", isAbsolute());\n        LOG.trace(\"Relative path: {}\", getRelativeFilePath());\n        LOG.trace(\"Absolute path: {}\", getAbsoluteFilePath());\n        LOG.trace(\"Name changed to: {}\", this);\n    }\n}", "code_comment": "/**\n * Changes the name of this remote file. This method alters the absolute and\n * relative names as well.\n *\n * @param newName the new name\n */\n", "code_no_comment": "public void changeFileName(String newName) {\n    LOG.trace(\"Changing name to: {}\", newName);\n        String newFileName = FileUtil.normalizePath(newName);\n    String newEndpointPath = FileUtil.normalizePath(endpointPath);\n    LOG.trace(\"Normalized endpointPath: {}\", newEndpointPath);\n    LOG.trace(\"Normalized newFileName: ()\", newFileName);\n    File file = new File(newFileName);\n    if (!absolute) {\n                if (ObjectHelper.isNotEmpty(newEndpointPath) && newFileName.startsWith(newEndpointPath)) {\n                        if (newEndpointPath.endsWith(\"\" + File.separatorChar)) {\n                newFileName = ObjectHelper.after(newFileName, newEndpointPath);\n            } else {\n                newFileName = ObjectHelper.after(newFileName, newEndpointPath + File.separatorChar);\n            }\n                        file = new File(newFileName);\n        }\n    }\n        setFileNameOnly(file.getName());\n    setFileName(file.getName());\n        if (file.getParent() != null) {\n        setRelativeFilePath(file.getParent() + getFileSeparator() + file.getName());\n    } else {\n        setRelativeFilePath(file.getName());\n    }\n        if (isAbsolute(newFileName)) {\n        setAbsolute(true);\n        setAbsoluteFilePath(newFileName);\n    } else {\n        setAbsolute(false);\n                String path = ObjectHelper.isEmpty(endpointPath) ? \"\" : endpointPath + getFileSeparator();\n        setAbsoluteFilePath(path + getRelativeFilePath());\n    }\n    if (LOG.isTraceEnabled()) {\n        LOG.trace(\"FileNameOnly: {}\", getFileNameOnly());\n        LOG.trace(\"FileName: {}\", getFileName());\n        LOG.trace(\"Absolute: {}\", isAbsolute());\n        LOG.trace(\"Relative path: {}\", getRelativeFilePath());\n        LOG.trace(\"Absolute path: {}\", getAbsoluteFilePath());\n        LOG.trace(\"Name changed to: {}\", this);\n    }\n}", "lc": 1.2272727272727273, "pi": 0.29186602870813394, "ma": 0.8, "nbd": 0.5, "ml": 1.25, "d": 0.5992063492063493, "mi": -0.7446088794926, "fo": 2.9166666666666665, "r": -0.02631578947368421, "e": 1.5640600957798099}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1977_4bfbfcdd", "label": 1, "code": "@Override\npublic PropertyValue getValue(String columnName) {\n    return r.getValue(columnName);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic PropertyValue getValue(String columnName) {\n    return r.getValue(columnName);\n}", "lc": -0.45454545454545453, "pi": -0.6028708133971293, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.8646934460887951, "fo": -0.4166666666666667, "r": 1.7631578947368423, "e": -0.16279340490885932}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-606_f0fbacab", "label": 1, "code": "/**\n * Determine whether this item is stale\n * @return  {@code true} iff stale\n */\npublic boolean isStale() {\n    Status status = getLocationOrNull().getStatus();\n    return status == Status.DISCONNECTED || status == null;\n}", "code_comment": "/**\n * Determine whether this item is stale\n * @return  {@code true} iff stale\n */\n", "code_no_comment": "public boolean isStale() {\n    Status status = getLocationOrNull().getStatus();\n    return status == Status.DISCONNECTED || status == null;\n}", "lc": -0.45454545454545453, "pi": -0.47368421052631593, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.0912698412698413, "mi": 0.7592670894996475, "fo": -0.3333333333333333, "r": 2.6052631578947367, "e": -0.1298986301527751}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-428_d906576c", "label": 3, "code": "/**\n *  @see java.util.Map#keySet()\n */\npublic Set keySet() {\n    return new AbstractSet() {\n\n        public Iterator iterator() {\n            return new Iterator() {\n\n                public boolean hasNext() {\n                    return index < MicroMap.this.size();\n                }\n\n                public Object next() {\n                    index++;\n                    return key;\n                }\n\n                public void remove() {\n                    MicroMap.this.clear();\n                }\n\n                int index;\n            };\n        }\n\n        public int size() {\n            return MicroMap.this.size();\n        }\n    };\n}", "code_comment": "/**\n *  @see java.util.Map#keySet()\n */\n", "code_no_comment": "public Set keySet() {\n    return new AbstractSet() {\n\n        public Iterator iterator() {\n            return new Iterator() {\n\n                public boolean hasNext() {\n                    return index < MicroMap.this.size();\n                }\n\n                public Object next() {\n                    index++;\n                    return key;\n                }\n\n                public void remove() {\n                    MicroMap.this.clear();\n                }\n\n                int index;\n            };\n        }\n\n        public int size() {\n            return MicroMap.this.size();\n        }\n    };\n}", "lc": 0.36363636363636365, "pi": 1.5406698564593302, "ma": -0.6, "nbd": 0.0, "ml": -0.4166666666666667, "d": -0.07341269841269843, "mi": -0.11261451726568016, "fo": -0.25, "r": 1.6842105263157894, "e": -0.09645983529560923}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-3791_52106681", "label": 1, "code": "/**\n * All redelivery attempts failed so move the exchange to the dead letter queue\n */\nprotected boolean deliverToFailureProcessor(final Processor processor, final Exchange exchange, final RedeliveryData data, final AsyncCallback callback) {\n    boolean sync = true;\n    Exception caught = exchange.getException();\n    // we did not success with the redelivery so now we let the failure processor handle it\n    // clear exception as we let the failure processor handle it\n    exchange.setException(null);\n    boolean handled = false;\n    // regard both handled or continued as being handled\n    if (shouldHandled(exchange, data) || shouldContinue(exchange, data)) {\n        // its handled then remove traces of redelivery attempted\n        exchange.getIn().removeHeader(Exchange.REDELIVERED);\n        exchange.getIn().removeHeader(Exchange.REDELIVERY_COUNTER);\n        exchange.getIn().removeHeader(Exchange.REDELIVERY_MAX_COUNTER);\n        handled = true;\n    } else {\n        // must decrement the redelivery counter as we didn't process the redelivery but is\n        // handling by the failure handler. So we must -1 to not let the counter be out-of-sync\n        decrementRedeliveryCounter(exchange);\n    }\n    // is the a failure processor to process the Exchange\n    if (processor != null) {\n        // reset cached streams so they can be read again\n        MessageHelper.resetStreamCache(exchange.getIn());\n        // prepare original IN body if it should be moved instead of current body\n        if (data.useOriginalInMessage) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Using the original IN message instead of current\");\n            }\n            Message original = exchange.getUnitOfWork().getOriginalInMessage();\n            exchange.setIn(original);\n        }\n        if (log.isTraceEnabled()) {\n            log.trace(\"Failure processor \" + processor + \" is processing Exchange: \" + exchange);\n        }\n        // store the last to endpoint as the failure endpoint\n        exchange.setProperty(Exchange.FAILURE_ENDPOINT, exchange.getProperty(Exchange.TO_ENDPOINT));\n        // the failure processor could also be asynchronous\n        AsyncProcessor afp = AsyncProcessorTypeConverter.convert(processor);\n        sync = AsyncProcessorHelper.process(afp, exchange, new AsyncCallback() {\n\n            public void done(boolean sync) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Failure processor done: \" + processor + \" processing Exchange: \" + exchange);\n                }\n                try {\n                    prepareExchangeAfterFailure(exchange, data);\n                    // fire event as we had a failure processor to handle it, which there is a event for\n                    boolean deadLetterChannel = processor == data.deadLetterProcessor && data.deadLetterProcessor != null;\n                    EventHelper.notifyExchangeFailureHandled(exchange.getContext(), exchange, processor, deadLetterChannel);\n                } finally {\n                    // if the fault was handled asynchronously, this should be reflected in the callback as well\n                    data.sync &= sync;\n                    callback.done(data.sync);\n                }\n            }\n        });\n    } else {\n        try {\n            // no processor but we need to prepare after failure as well\n            prepareExchangeAfterFailure(exchange, data);\n        } finally {\n            // callback we are done\n            callback.done(data.sync);\n        }\n    }\n    // create log message\n    String msg = \"Failed delivery for exchangeId: \" + exchange.getExchangeId();\n    msg = msg + \". Exhausted after delivery attempt: \" + data.redeliveryCounter + \" caught: \" + caught;\n    if (processor != null) {\n        msg = msg + \". Processed by failure processor: \" + processor;\n    }\n    // log that we failed delivery as we are exhausted\n    logFailedDelivery(false, handled, false, exchange, msg, data, null);\n    return sync;\n}", "code_comment": "/**\n * All redelivery attempts failed so move the exchange to the dead letter queue\n */\n", "code_no_comment": "protected boolean deliverToFailureProcessor(final Processor processor, final Exchange exchange, final RedeliveryData data, final AsyncCallback callback) {\n    boolean sync = true;\n    Exception caught = exchange.getException();\n            exchange.setException(null);\n    boolean handled = false;\n        if (shouldHandled(exchange, data) || shouldContinue(exchange, data)) {\n                exchange.getIn().removeHeader(Exchange.REDELIVERED);\n        exchange.getIn().removeHeader(Exchange.REDELIVERY_COUNTER);\n        exchange.getIn().removeHeader(Exchange.REDELIVERY_MAX_COUNTER);\n        handled = true;\n    } else {\n                        decrementRedeliveryCounter(exchange);\n    }\n        if (processor != null) {\n                MessageHelper.resetStreamCache(exchange.getIn());\n                if (data.useOriginalInMessage) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Using the original IN message instead of current\");\n            }\n            Message original = exchange.getUnitOfWork().getOriginalInMessage();\n            exchange.setIn(original);\n        }\n        if (log.isTraceEnabled()) {\n            log.trace(\"Failure processor \" + processor + \" is processing Exchange: \" + exchange);\n        }\n                exchange.setProperty(Exchange.FAILURE_ENDPOINT, exchange.getProperty(Exchange.TO_ENDPOINT));\n                AsyncProcessor afp = AsyncProcessorTypeConverter.convert(processor);\n        sync = AsyncProcessorHelper.process(afp, exchange, new AsyncCallback() {\n\n            public void done(boolean sync) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Failure processor done: \" + processor + \" processing Exchange: \" + exchange);\n                }\n                try {\n                    prepareExchangeAfterFailure(exchange, data);\n                                        boolean deadLetterChannel = processor == data.deadLetterProcessor && data.deadLetterProcessor != null;\n                    EventHelper.notifyExchangeFailureHandled(exchange.getContext(), exchange, processor, deadLetterChannel);\n                } finally {\n                                        data.sync &= sync;\n                    callback.done(data.sync);\n                }\n            }\n        });\n    } else {\n        try {\n                        prepareExchangeAfterFailure(exchange, data);\n        } finally {\n                        callback.done(data.sync);\n        }\n    }\n        String msg = \"Failed delivery for exchangeId: \" + exchange.getExchangeId();\n    msg = msg + \". Exhausted after delivery attempt: \" + data.redeliveryCounter + \" caught: \" + caught;\n    if (processor != null) {\n        msg = msg + \". Processed by failure processor: \" + processor;\n    }\n        logFailedDelivery(false, handled, false, exchange, msg, data, null);\n    return sync;\n}", "lc": 1.9545454545454546, "pi": 1.1626794258373205, "ma": 0.8, "nbd": 0.5, "ml": 0.8333333333333334, "d": 1.0317460317460319, "mi": -0.9543340380549682, "fo": 2.3333333333333335, "r": -0.02631578947368421, "e": 3.590631789445779}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-4113_27300d81", "label": 0, "code": "public static List<byte[]> toBytesList(Collection<ByteBuffer> bytesList) {\n    if (bytesList == null)\n        return null;\n    ArrayList<byte[]> result = new ArrayList<byte[]>();\n    for (ByteBuffer bytes : bytesList) {\n        result.add(toBytes(bytes));\n    }\n    return result;\n}", "code_comment": NaN, "code_no_comment": "public static List<byte[]> toBytesList(Collection<ByteBuffer> bytesList) {\n    if (bytesList == null)\n        return null;\n    ArrayList<byte[]> result = new ArrayList<byte[]>();\n    for (ByteBuffer bytes : bytesList) {\n        result.add(toBytes(bytes));\n    }\n    return result;\n}", "lc": -0.22727272727272727, "pi": -0.15311004784689008, "ma": -0.2, "nbd": -0.5, "ml": -0.25, "d": -0.03373015873015876, "mi": 0.30570824524312884, "fo": -0.3333333333333333, "r": 0.31578947368421056, "e": -0.0984330607469903}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4932_f20b2d70", "label": 1, "code": "/**\n *  Cleans the original parameters from entries used by Wicket internals.\n *\n *  @param originalParameters\n *             the current request's non-modified parameters\n *  @return all parameters but Wicket internal ones\n */\nprivate PageParameters cleanPageParameters(final PageParameters originalParameters) {\n    PageParameters cleanParameters = null;\n    if (originalParameters != null) {\n        cleanParameters = new PageParameters(originalParameters);\n        // WICKET-4038: Ajax related parameters are set by wicket-ajax.js when needed.\n        // They shouldn't be propagated to the next requests\n        cleanParameters.remove(WebRequest.PARAM_AJAX);\n        cleanParameters.remove(WebRequest.PARAM_AJAX_BASE_URL);\n        cleanParameters.remove(WebRequest.PARAM_AJAX_REQUEST_ANTI_CACHE);\n        if (cleanParameters.isEmpty()) {\n            cleanParameters = null;\n        }\n    }\n    return cleanParameters;\n}", "code_comment": "/**\n *  Cleans the original parameters from entries used by Wicket internals.\n *\n *  @param originalParameters\n *             the current request's non-modified parameters\n *  @return all parameters but Wicket internal ones\n */\n", "code_no_comment": "private PageParameters cleanPageParameters(final PageParameters originalParameters) {\n    PageParameters cleanParameters = null;\n    if (originalParameters != null) {\n        cleanParameters = new PageParameters(originalParameters);\n                        cleanParameters.remove(WebRequest.PARAM_AJAX);\n        cleanParameters.remove(WebRequest.PARAM_AJAX_BASE_URL);\n        cleanParameters.remove(WebRequest.PARAM_AJAX_REQUEST_ANTI_CACHE);\n        if (cleanParameters.isEmpty()) {\n            cleanParameters = null;\n        }\n    }\n    return cleanParameters;\n}", "lc": -0.045454545454545456, "pi": 0.18181818181818177, "ma": -0.2, "nbd": 0.0, "ml": -0.08333333333333333, "d": 0.13095238095238093, "mi": 0.07399577167019025, "fo": -0.16666666666666666, "r": 0.05263157894736841, "e": -0.013588976677443344}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-1068_b12610d3", "label": 3, "code": "/**\n * Computes the Kendall's Tau rank correlation coefficient between the two arrays.\n *\n * @param xArray first data array\n * @param yArray second data array\n * @return Returns Kendall's Tau rank correlation coefficient for the two arrays\n * @throws DimensionMismatchException if the arrays lengths do not match\n */\npublic double correlation(final double[] xArray, final double[] yArray) throws DimensionMismatchException {\n    if (xArray.length != yArray.length) {\n        throw new DimensionMismatchException(xArray.length, yArray.length);\n    }\n    final int n = xArray.length;\n    final int numPairs = n * (n - 1) / 2;\n    @SuppressWarnings(\"unchecked\")\n    Pair<Double, Double>[] pairs = new Pair[n];\n    for (int i = 0; i < n; i++) {\n        pairs[i] = new Pair<Double, Double>(xArray[i], yArray[i]);\n    }\n    Arrays.sort(pairs, new Comparator<Pair<Double, Double>>() {\n\n        public int compare(Pair<Double, Double> pair1, Pair<Double, Double> pair2) {\n            int compareFirst = pair1.getFirst().compareTo(pair2.getFirst());\n            return compareFirst != 0 ? compareFirst : pair1.getSecond().compareTo(pair2.getSecond());\n        }\n    });\n    int tiedXPairs = 0;\n    int tiedXYPairs = 0;\n    int consecutiveXTies = 1;\n    int consecutiveXYTies = 1;\n    Pair<Double, Double> prev = pairs[0];\n    for (int i = 1; i < n; i++) {\n        final Pair<Double, Double> curr = pairs[i];\n        if (curr.getFirst().equals(prev.getFirst())) {\n            consecutiveXTies++;\n            if (curr.getSecond().equals(prev.getSecond())) {\n                consecutiveXYTies++;\n            } else {\n                tiedXYPairs += consecutiveXYTies * (consecutiveXYTies - 1) / 2;\n                consecutiveXYTies = 1;\n            }\n        } else {\n            tiedXPairs += consecutiveXTies * (consecutiveXTies - 1) / 2;\n            consecutiveXTies = 1;\n            tiedXYPairs += consecutiveXYTies * (consecutiveXYTies - 1) / 2;\n            consecutiveXYTies = 1;\n        }\n        prev = curr;\n    }\n    tiedXPairs += consecutiveXTies * (consecutiveXTies - 1) / 2;\n    tiedXYPairs += consecutiveXYTies * (consecutiveXYTies - 1) / 2;\n    int swaps = 0;\n    @SuppressWarnings(\"unchecked\")\n    Pair<Double, Double>[] pairsDestination = new Pair[n];\n    for (int segmentSize = 1; segmentSize < n; segmentSize <<= 1) {\n        for (int offset = 0; offset < n; offset += 2 * segmentSize) {\n            int i = offset;\n            final int iEnd = FastMath.min(i + segmentSize, n);\n            int j = iEnd;\n            final int jEnd = FastMath.min(j + segmentSize, n);\n            int copyLocation = offset;\n            while (i < iEnd || j < jEnd) {\n                if (i < iEnd) {\n                    if (j < jEnd) {\n                        if (pairs[i].getSecond().compareTo(pairs[j].getSecond()) <= 0) {\n                            pairsDestination[copyLocation] = pairs[i];\n                            i++;\n                        } else {\n                            pairsDestination[copyLocation] = pairs[j];\n                            j++;\n                            swaps += iEnd - i;\n                        }\n                    } else {\n                        pairsDestination[copyLocation] = pairs[i];\n                        i++;\n                    }\n                } else {\n                    pairsDestination[copyLocation] = pairs[j];\n                    j++;\n                }\n                copyLocation++;\n            }\n        }\n        final Pair<Double, Double>[] pairsTemp = pairs;\n        pairs = pairsDestination;\n        pairsDestination = pairsTemp;\n    }\n    int tiedYPairs = 0;\n    int consecutiveYTies = 1;\n    prev = pairs[0];\n    for (int i = 1; i < n; i++) {\n        final Pair<Double, Double> curr = pairs[i];\n        if (curr.getSecond().equals(prev.getSecond())) {\n            consecutiveYTies++;\n        } else {\n            tiedYPairs += consecutiveYTies * (consecutiveYTies - 1) / 2;\n            consecutiveYTies = 1;\n        }\n        prev = curr;\n    }\n    tiedYPairs += consecutiveYTies * (consecutiveYTies - 1) / 2;\n    int concordantMinusDiscordant = numPairs - tiedXPairs - tiedYPairs + tiedXYPairs - 2 * swaps;\n    return concordantMinusDiscordant / FastMath.sqrt((numPairs - tiedXPairs) * (numPairs - tiedYPairs));\n}", "code_comment": "/**\n * Computes the Kendall's Tau rank correlation coefficient between the two arrays.\n *\n * @param xArray first data array\n * @param yArray second data array\n * @return Returns Kendall's Tau rank correlation coefficient for the two arrays\n * @throws DimensionMismatchException if the arrays lengths do not match\n */\n", "code_no_comment": "public double correlation(final double[] xArray, final double[] yArray) throws DimensionMismatchException {\n    if (xArray.length != yArray.length) {\n        throw new DimensionMismatchException(xArray.length, yArray.length);\n    }\n    final int n = xArray.length;\n    final int numPairs = n * (n - 1) / 2;\n    @SuppressWarnings(\"unchecked\")\n    Pair<Double, Double>[] pairs = new Pair[n];\n    for (int i = 0; i < n; i++) {\n        pairs[i] = new Pair<Double, Double>(xArray[i], yArray[i]);\n    }\n    Arrays.sort(pairs, new Comparator<Pair<Double, Double>>() {\n\n        public int compare(Pair<Double, Double> pair1, Pair<Double, Double> pair2) {\n            int compareFirst = pair1.getFirst().compareTo(pair2.getFirst());\n            return compareFirst != 0 ? compareFirst : pair1.getSecond().compareTo(pair2.getSecond());\n        }\n    });\n    int tiedXPairs = 0;\n    int tiedXYPairs = 0;\n    int consecutiveXTies = 1;\n    int consecutiveXYTies = 1;\n    Pair<Double, Double> prev = pairs[0];\n    for (int i = 1; i < n; i++) {\n        final Pair<Double, Double> curr = pairs[i];\n        if (curr.getFirst().equals(prev.getFirst())) {\n            consecutiveXTies++;\n            if (curr.getSecond().equals(prev.getSecond())) {\n                consecutiveXYTies++;\n            } else {\n                tiedXYPairs += consecutiveXYTies * (consecutiveXYTies - 1) / 2;\n                consecutiveXYTies = 1;\n            }\n        } else {\n            tiedXPairs += consecutiveXTies * (consecutiveXTies - 1) / 2;\n            consecutiveXTies = 1;\n            tiedXYPairs += consecutiveXYTies * (consecutiveXYTies - 1) / 2;\n            consecutiveXYTies = 1;\n        }\n        prev = curr;\n    }\n    tiedXPairs += consecutiveXTies * (consecutiveXTies - 1) / 2;\n    tiedXYPairs += consecutiveXYTies * (consecutiveXYTies - 1) / 2;\n    int swaps = 0;\n    @SuppressWarnings(\"unchecked\")\n    Pair<Double, Double>[] pairsDestination = new Pair[n];\n    for (int segmentSize = 1; segmentSize < n; segmentSize <<= 1) {\n        for (int offset = 0; offset < n; offset += 2 * segmentSize) {\n            int i = offset;\n            final int iEnd = FastMath.min(i + segmentSize, n);\n            int j = iEnd;\n            final int jEnd = FastMath.min(j + segmentSize, n);\n            int copyLocation = offset;\n            while (i < iEnd || j < jEnd) {\n                if (i < iEnd) {\n                    if (j < jEnd) {\n                        if (pairs[i].getSecond().compareTo(pairs[j].getSecond()) <= 0) {\n                            pairsDestination[copyLocation] = pairs[i];\n                            i++;\n                        } else {\n                            pairsDestination[copyLocation] = pairs[j];\n                            j++;\n                            swaps += iEnd - i;\n                        }\n                    } else {\n                        pairsDestination[copyLocation] = pairs[i];\n                        i++;\n                    }\n                } else {\n                    pairsDestination[copyLocation] = pairs[j];\n                    j++;\n                }\n                copyLocation++;\n            }\n        }\n        final Pair<Double, Double>[] pairsTemp = pairs;\n        pairs = pairsDestination;\n        pairsDestination = pairsTemp;\n    }\n    int tiedYPairs = 0;\n    int consecutiveYTies = 1;\n    prev = pairs[0];\n    for (int i = 1; i < n; i++) {\n        final Pair<Double, Double> curr = pairs[i];\n        if (curr.getSecond().equals(prev.getSecond())) {\n            consecutiveYTies++;\n        } else {\n            tiedYPairs += consecutiveYTies * (consecutiveYTies - 1) / 2;\n            consecutiveYTies = 1;\n        }\n        prev = curr;\n    }\n    tiedYPairs += consecutiveYTies * (consecutiveYTies - 1) / 2;\n    int concordantMinusDiscordant = numPairs - tiedXPairs - tiedYPairs + tiedXYPairs - 2 * swaps;\n    return concordantMinusDiscordant / FastMath.sqrt((numPairs - tiedXPairs) * (numPairs - tiedYPairs));\n}", "lc": 3.6818181818181817, "pi": 1.9856459330143539, "ma": 2.4, "nbd": 2.0, "ml": 2.1666666666666665, "d": 6.583333333333333, "mi": -1.3439041578576458, "fo": 1.3333333333333333, "r": -0.02631578947368421, "e": 37.852063415224485}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-3634_9339ecf8", "label": 3, "code": "private int updateAuthKeys(String path) throws KeeperException, InterruptedException {\n    int keysAdded = 0;\n    for (String child : zk.getChildren(path, this)) {\n        String childPath = path + \"/\" + child;\n        // Get the node data and reset the watcher\n        AuthenticationKey key = deserializeKey(zk.getData(childPath, this, null));\n        secretManager.addKey(key);\n        keysAdded++;\n    }\n    return keysAdded;\n}", "code_comment": NaN, "code_no_comment": "private int updateAuthKeys(String path) throws KeeperException, InterruptedException {\n    int keysAdded = 0;\n    for (String child : zk.getChildren(path, this)) {\n        String childPath = path + \"/\" + child;\n                AuthenticationKey key = deserializeKey(zk.getData(childPath, this, null));\n        secretManager.addKey(key);\n        keysAdded++;\n    }\n    return keysAdded;\n}", "lc": -0.18181818181818182, "pi": 0.0, "ma": -0.4, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.06746031746031747, "mi": 0.17068357998590572, "fo": -0.16666666666666666, "r": 0.34210526315789475, "e": -0.0533024440564075}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3879_4faf31e3", "label": 1, "code": "/**\n * Following logic is taken from org.apache.jackrabbit.core.query.lucene.JackrabbitQueryParser#parse(java.lang.String)\n */\nstatic String rewriteQueryText(String textsearch) {\n    // replace escaped ' with just '\n    StringBuilder rewritten = new StringBuilder();\n    // the default lucene query parser recognizes 'AND' and 'NOT' as\n    // keywords.\n    textsearch = textsearch.replaceAll(\"AND\", \"and\");\n    textsearch = textsearch.replaceAll(\"NOT\", \"not\");\n    boolean escaped = false;\n    for (int i = 0; i < textsearch.length(); i++) {\n        char c = textsearch.charAt(i);\n        if (c == '\\\\') {\n            if (escaped) {\n                rewritten.append(\"\\\\\\\\\");\n                escaped = false;\n            } else {\n                escaped = true;\n            }\n        } else if (c == '\\'') {\n            if (escaped) {\n                escaped = false;\n            }\n            rewritten.append(c);\n        } else if (c == ':' || c == '/') {\n            // TODO Some other chars are also considered special See OAK-3769 for details\n            // ':' fields as known in lucene are not supported\n            // '/' its a special char used for regex search in Lucene\n            rewritten.append('\\\\').append(c);\n        } else {\n            if (escaped) {\n                rewritten.append('\\\\');\n                escaped = false;\n            }\n            rewritten.append(c);\n        }\n    }\n    return rewritten.toString();\n}", "code_comment": "/**\n * Following logic is taken from org.apache.jackrabbit.core.query.lucene.JackrabbitQueryParser#parse(java.lang.String)\n */\n", "code_no_comment": "static String rewriteQueryText(String textsearch) {\n        StringBuilder rewritten = new StringBuilder();\n            textsearch = textsearch.replaceAll(\"AND\", \"and\");\n    textsearch = textsearch.replaceAll(\"NOT\", \"not\");\n    boolean escaped = false;\n    for (int i = 0; i < textsearch.length(); i++) {\n        char c = textsearch.charAt(i);\n        if (c == '\\\\') {\n            if (escaped) {\n                rewritten.append(\"\\\\\\\\\");\n                escaped = false;\n            } else {\n                escaped = true;\n            }\n        } else if (c == '\\'') {\n            if (escaped) {\n                escaped = false;\n            }\n            rewritten.append(c);\n        } else if (c == ':' || c == '/') {\n                                                rewritten.append('\\\\').append(c);\n        } else {\n            if (escaped) {\n                rewritten.append('\\\\');\n                escaped = false;\n            }\n            rewritten.append(c);\n        }\n    }\n    return rewritten.toString();\n}", "lc": 0.7727272727272727, "pi": 0.875598086124402, "ma": 0.8, "nbd": 1.5, "ml": 0.5833333333333334, "d": 0.6726190476190477, "mi": -0.5281183932346721, "fo": 0.4166666666666667, "r": -0.02631578947368421, "e": 0.8527307619162876}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1199_813109d7", "label": 3, "code": "public void getResult() throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException {\n    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {\n        throw new IllegalStateException(\"Method call not finished!\");\n    }\n    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());\n    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);\n    (new Client(prot)).recv_removeConstraint();\n}", "code_comment": NaN, "code_no_comment": "public void getResult() throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException {\n    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {\n        throw new IllegalStateException(\"Method call not finished!\");\n    }\n    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());\n    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);\n    (new Client(prot)).recv_removeConstraint();\n}", "lc": -0.2727272727272727, "pi": -0.2822966507177035, "ma": -0.2, "nbd": -0.5, "ml": -0.25, "d": -0.053571428571428575, "mi": 0.21099365750528534, "fo": 0.0, "r": -0.02631578947368421, "e": 0.004289921220817992}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3428_ffc0cae9", "label": 1, "code": "/**\n *  Convenience method that processes the request and detaches the {@link RequestCycle}.\n *\n *  @return <code>true</code> if the request resolved to a Wicket request, <code>false</code>\n *          otherwise.\n */\npublic boolean processRequestAndDetach() {\n    boolean result;\n    try {\n        listeners.onBeginRequest(this);\n        onBeginRequest();\n        result = processRequest();\n    } finally {\n        detach();\n    }\n    return result;\n}", "code_comment": "/**\n *  Convenience method that processes the request and detaches the {@link RequestCycle}.\n *\n *  @return <code>true</code> if the request resolved to a Wicket request, <code>false</code>\n *          otherwise.\n */\n", "code_no_comment": "public boolean processRequestAndDetach() {\n    boolean result;\n    try {\n        listeners.onBeginRequest(this);\n        onBeginRequest();\n        result = processRequest();\n    } finally {\n        detach();\n    }\n    return result;\n}", "lc": -0.13636363636363635, "pi": -0.06220095693779921, "ma": -0.6, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.3634954193093726, "fo": -0.16666666666666666, "r": 1.4999999999999998, "e": -0.16279340490885932}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-3690_2a3f3392", "label": 3, "code": "public void addService(Object object) throws Exception {\n    if (object instanceof Service) {\n        Service service = (Service) object;\n        for (LifecycleStrategy strategy : lifecycleStrategies) {\n            if (service instanceof Endpoint) {\n                // use specialized endpoint add\n                strategy.onEndpointAdd((Endpoint) service);\n            } else {\n                strategy.onServiceAdd(this, service, null);\n            }\n        }\n        // only add to services to close if its a singleton\n        // otherwise we could for example end up with a lot of prototype scope endpoints\n        // assume singleton by default\n        boolean singleton = true;\n        if (service instanceof IsSingleton) {\n            singleton = ((IsSingleton) service).isSingleton();\n        }\n        if (singleton) {\n            servicesToClose.add(service);\n        }\n    }\n    startServices(object);\n}", "code_comment": NaN, "code_no_comment": "public void addService(Object object) throws Exception {\n    if (object instanceof Service) {\n        Service service = (Service) object;\n        for (LifecycleStrategy strategy : lifecycleStrategies) {\n            if (service instanceof Endpoint) {\n                                strategy.onEndpointAdd((Endpoint) service);\n            } else {\n                strategy.onServiceAdd(this, service, null);\n            }\n        }\n                                boolean singleton = true;\n        if (service instanceof IsSingleton) {\n            singleton = ((IsSingleton) service).isSingleton();\n        }\n        if (singleton) {\n            servicesToClose.add(service);\n        }\n    }\n    startServices(object);\n}", "lc": 0.2727272727272727, "pi": 0.6555023923444977, "ma": 0.4, "nbd": 0.5, "ml": 0.16666666666666666, "d": -0.3650793650793651, "mi": -0.19295278365045798, "fo": -0.08333333333333333, "r": 0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1178_f2bb1a17", "label": 1, "code": "/**\n * Internal method for checking whether this node exists and is visible\n * (i.e. not hidden).\n *\n * @return {@true} if the node is visible, {@code false} if not\n */\nprivate boolean isVisible() {\n    return !isHidden(name) && nodeBuilder.exists();\n}", "code_comment": "/**\n * Internal method for checking whether this node exists and is visible\n * (i.e. not hidden).\n *\n * @return {@true} if the node is visible, {@code false} if not\n */\n", "code_no_comment": "private boolean isVisible() {\n    return !isHidden(name) && nodeBuilder.exists();\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.16666666666666669, "mi": 1.0036645525017613, "fo": -0.3333333333333333, "r": 2.5789473684210527, "e": -0.15172858929363828}
{"project_name": "Closure", "project_version": 87, "label": 2, "code": "/**\n * @return Whether the node is a block with a single statement that is\n *     an expression.\n */\nprivate boolean isFoldableExpressBlock(Node n) {\n    if (n.getType() == Token.BLOCK) {\n        if (n.hasOneChild()) {\n            Node maybeExpr = n.getFirstChild();\n            return NodeUtil.isExpressionNode(maybeExpr);\n        }\n    }\n    return false;\n}", "code_comment": "/**\n * @return Whether the node is a block with a single statement that is\n *     an expression.\n */\n", "code_no_comment": "private boolean isFoldableExpressBlock(Node n) {\n    if (n.getType() == Token.BLOCK) {\n        if (n.hasOneChild()) {\n            Node maybeExpr = n.getFirstChild();\n            return NodeUtil.isExpressionNode(maybeExpr);\n        }\n    }\n    return false;\n}", "lc": -0.22727272727272727, "pi": 0.6076555023923443, "ma": -0.2, "nbd": 0.0, "ml": -0.08333333333333333, "d": -0.0912698412698413, "mi": 0.31585623678646924, "fo": -0.16666666666666666, "r": 2.3684210526315788, "e": -0.11291413818341084}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-2065_9da430fb", "label": 1, "code": "protected void appendParameters(AppendingStringBuffer url, Map parameters) {\n    int i = 0;\n    while (parameters.containsKey(String.valueOf(i))) {\n        String value = (String) parameters.get(String.valueOf(i));\n        if (!url.endsWith(\"/\")) {\n            url.append(\"/\");\n        }\n        url.append(urlEncodePathComponent(value)).append(\"/\");\n        i++;\n    }\n    String pageMap = (String) parameters.get(WebRequestCodingStrategy.PAGEMAP);\n    if (pageMap != null) {\n        i++;\n        pageMap = WebRequestCodingStrategy.encodePageMapName(pageMap);\n        if (!url.endsWith(\"/\")) {\n            url.append(\"/\");\n        }\n        url.append(WebRequestCodingStrategy.PAGEMAP).append(\"/\").append(urlEncodePathComponent(pageMap)).append(\"/\");\n    }\n    if (i != parameters.size()) {\n        throw new WicketRuntimeException(\"Not all parameters were encoded. Make sure all parameter names are integers in consecutive order starting with zero. Current parameter names are: \" + parameters.keySet().toString());\n    }\n}", "code_comment": NaN, "code_no_comment": "protected void appendParameters(AppendingStringBuffer url, Map parameters) {\n    int i = 0;\n    while (parameters.containsKey(String.valueOf(i))) {\n        String value = (String) parameters.get(String.valueOf(i));\n        if (!url.endsWith(\"/\")) {\n            url.append(\"/\");\n        }\n        url.append(urlEncodePathComponent(value)).append(\"/\");\n        i++;\n    }\n    String pageMap = (String) parameters.get(WebRequestCodingStrategy.PAGEMAP);\n    if (pageMap != null) {\n        i++;\n        pageMap = WebRequestCodingStrategy.encodePageMapName(pageMap);\n        if (!url.endsWith(\"/\")) {\n            url.append(\"/\");\n        }\n        url.append(WebRequestCodingStrategy.PAGEMAP).append(\"/\").append(urlEncodePathComponent(pageMap)).append(\"/\");\n    }\n    if (i != parameters.size()) {\n        throw new WicketRuntimeException(\"Not all parameters were encoded. Make sure all parameter names are integers in consecutive order starting with zero. Current parameter names are: \" + parameters.keySet().toString());\n    }\n}", "lc": 0.4090909090909091, "pi": 0.04306220095693773, "ma": 0.6, "nbd": 0.0, "ml": 0.5, "d": 0.7083333333333334, "mi": -0.3849189570119802, "fo": 1.25, "r": -0.02631578947368421, "e": 0.8842654864196676}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4102_e743fd7e", "label": 1, "code": "@Override\npublic void onComponentTagBody(final MarkupStream markupStream, final ComponentTag openTag) {\n    boolean storeLabelText = false;\n    // try and find some form of label content...\n    String labelText = null;\n    if (labeled instanceof ILabelProvider) {\n        ILabelProvider<String> provider = (ILabelProvider<String>) labeled;\n        if (provider.getLabel() != null) {\n            String text = provider.getLabel().getObject();\n            if (!Strings.isEmpty(text)) {\n                labelText = text;\n            }\n        }\n    }\n    if (labelText == null && labeled instanceof FormComponent) {\n        String text = ((FormComponent<?>) labeled).getDefaultLabel(\"wicket:unknown\");\n        if (!\"wicket:unknown\".equals(text) && !Strings.isEmpty(text)) {\n            labelText = text;\n        }\n    }\n    // check if wicket:label tag has a message key\n    if (labelText == null && openTag.getAttribute(\"key\") != null) {\n        String text = labeled.getString(openTag.getAttribute(\"key\"));\n        if (!Strings.isEmpty(text)) {\n            labelText = text;\n            storeLabelText = true;\n        }\n    }\n    // as last resort use the tag body\n    if (labelText == null) {\n        String text = new ResponseBufferZone(RequestCycle.get(), markupStream) {\n\n            @Override\n            protected void executeInsideBufferedZone() {\n                TextLabel.super.onComponentTagBody(markupStream, openTag);\n            }\n        }.execute().toString();\n        if (!Strings.isEmpty(text)) {\n            labelText = text;\n            storeLabelText = true;\n        }\n    }\n    // print the label text\n    replaceComponentTagBody(markupStream, openTag, labelText);\n    // store the label text in FormComponent's label model so its available to errors\n    if (labeled instanceof FormComponent) {\n        FormComponent<?> fc = (FormComponent<?>) labeled;\n        fc.setLabel(Model.of(labelText));\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void onComponentTagBody(final MarkupStream markupStream, final ComponentTag openTag) {\n    boolean storeLabelText = false;\n        String labelText = null;\n    if (labeled instanceof ILabelProvider) {\n        ILabelProvider<String> provider = (ILabelProvider<String>) labeled;\n        if (provider.getLabel() != null) {\n            String text = provider.getLabel().getObject();\n            if (!Strings.isEmpty(text)) {\n                labelText = text;\n            }\n        }\n    }\n    if (labelText == null && labeled instanceof FormComponent) {\n        String text = ((FormComponent<?>) labeled).getDefaultLabel(\"wicket:unknown\");\n        if (!\"wicket:unknown\".equals(text) && !Strings.isEmpty(text)) {\n            labelText = text;\n        }\n    }\n        if (labelText == null && openTag.getAttribute(\"key\") != null) {\n        String text = labeled.getString(openTag.getAttribute(\"key\"));\n        if (!Strings.isEmpty(text)) {\n            labelText = text;\n            storeLabelText = true;\n        }\n    }\n        if (labelText == null) {\n        String text = new ResponseBufferZone(RequestCycle.get(), markupStream) {\n\n            @Override\n            protected void executeInsideBufferedZone() {\n                TextLabel.super.onComponentTagBody(markupStream, openTag);\n            }\n        }.execute().toString();\n        if (!Strings.isEmpty(text)) {\n            labelText = text;\n            storeLabelText = true;\n        }\n    }\n        replaceComponentTagBody(markupStream, openTag, labelText);\n        if (labeled instanceof FormComponent) {\n        FormComponent<?> fc = (FormComponent<?>) labeled;\n        fc.setLabel(Model.of(labelText));\n    }\n}", "lc": 1.3636363636363635, "pi": 0.4736842105263157, "ma": 1.4, "nbd": 0.5, "ml": 1.25, "d": 0.7162698412698413, "mi": -0.7916842847075402, "fo": 1.0833333333333333, "r": -0.02631578947368421, "e": 1.713873088870063}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-3740_f2f5bd5b", "label": 1, "code": "private void processTriggersFor(Watermark mark) throws Exception {\n    boolean fire;\n    do {\n        Timer<K, W> timer = watermarkTimersQueue.peek();\n        if (timer != null && timer.timestamp <= mark.getTimestamp()) {\n            fire = true;\n            watermarkTimers.remove(timer);\n            watermarkTimersQueue.remove();\n            context.key = timer.key;\n            context.window = timer.window;\n            setKeyContext(timer.key);\n            TriggerResult triggerResult = context.onEventTime(timer.timestamp);\n            processTriggerResult(triggerResult, context.key, context.window);\n        } else {\n            fire = false;\n        }\n    } while (fire);\n}", "code_comment": NaN, "code_no_comment": "private void processTriggersFor(Watermark mark) throws Exception {\n    boolean fire;\n    do {\n        Timer<K, W> timer = watermarkTimersQueue.peek();\n        if (timer != null && timer.timestamp <= mark.getTimestamp()) {\n            fire = true;\n            watermarkTimers.remove(timer);\n            watermarkTimersQueue.remove();\n            context.key = timer.key;\n            context.window = timer.window;\n            setKeyContext(timer.key);\n            TriggerResult triggerResult = context.onEventTime(timer.timestamp);\n            processTriggerResult(triggerResult, context.key, context.window);\n        } else {\n            fire = false;\n        }\n    } while (fire);\n}", "lc": 0.18181818181818182, "pi": 0.5741626794258374, "ma": -0.2, "nbd": 0.0, "ml": 0.16666666666666666, "d": 0.3849206349206349, "mi": -0.19661733615221966, "fo": 0.08333333333333333, "r": -0.02631578947368421, "e": 0.35492470738749327}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-366_db4a291f", "label": 1, "code": "void initiateClose(boolean saveState, boolean queueMinC, boolean disableWrites) {\n    if (!saveState && queueMinC) {\n        throw new IllegalArgumentException(\"Not saving state on close and requesting minor compactions queue does not make sense\");\n    }\n    log.debug(\"initiateClose(saveState=\" + saveState + \" queueMinC=\" + queueMinC + \" disableWrites=\" + disableWrites + \") \" + getExtent());\n    MinorCompactionTask mct = null;\n    synchronized (this) {\n        if (closed || closing || closeComplete) {\n            String msg = \"Tablet \" + getExtent() + \" already\";\n            if (closed)\n                msg += \" closed\";\n            if (closing)\n                msg += \" closing\";\n            if (closeComplete)\n                msg += \" closeComplete\";\n            throw new IllegalStateException(msg);\n        }\n        // enter the closing state, no splits, minor, or major compactions can start\n        // should cause running major compactions to stop\n        closing = true;\n        this.notifyAll();\n        // determines if inserts and queries can still continue while minor compacting\n        closed = disableWrites;\n        // true should cause any running major compactions to abort\n        while (majorCompactionInProgress) {\n            try {\n                this.wait(50);\n            } catch (InterruptedException e) {\n                log.error(e.toString());\n            }\n        }\n        if (!saveState || tabletMemory.getMemTable().getNumEntries() == 0) {\n            return;\n        }\n        tabletMemory.waitForMinC();\n        mct = prepareForMinC(getFlushID());\n        if (queueMinC) {\n            tabletResources.executeMinorCompaction(mct);\n            return;\n        }\n    }\n    // do minor compaction outside of synch block so that tablet can be read and written to while\n    // compaction runs\n    mct.run();\n}", "code_comment": NaN, "code_no_comment": "void initiateClose(boolean saveState, boolean queueMinC, boolean disableWrites) {\n    if (!saveState && queueMinC) {\n        throw new IllegalArgumentException(\"Not saving state on close and requesting minor compactions queue does not make sense\");\n    }\n    log.debug(\"initiateClose(saveState=\" + saveState + \" queueMinC=\" + queueMinC + \" disableWrites=\" + disableWrites + \") \" + getExtent());\n    MinorCompactionTask mct = null;\n    synchronized (this) {\n        if (closed || closing || closeComplete) {\n            String msg = \"Tablet \" + getExtent() + \" already\";\n            if (closed)\n                msg += \" closed\";\n            if (closing)\n                msg += \" closing\";\n            if (closeComplete)\n                msg += \" closeComplete\";\n            throw new IllegalStateException(msg);\n        }\n                        closing = true;\n        this.notifyAll();\n                closed = disableWrites;\n                while (majorCompactionInProgress) {\n            try {\n                this.wait(50);\n            } catch (InterruptedException e) {\n                log.error(e.toString());\n            }\n        }\n        if (!saveState || tabletMemory.getMemTable().getNumEntries() == 0) {\n            return;\n        }\n        tabletMemory.waitForMinC();\n        mct = prepareForMinC(getFlushID());\n        if (queueMinC) {\n            tabletResources.executeMinorCompaction(mct);\n            return;\n        }\n    }\n            mct.run();\n}", "lc": 1.1363636363636365, "pi": 0.5885167464114831, "ma": 1.6, "nbd": 0.5, "ml": 1.1666666666666667, "d": 0.5337301587301588, "mi": -0.6842847075405215, "fo": 0.6666666666666666, "r": -0.02631578947368421, "e": 0.8833019253931754}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-1931_986848f7", "label": 1, "code": "@Override\npublic int read() {\n    return -1;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic int read() {\n    return -1;\n}", "lc": -0.45454545454545453, "pi": -0.6028708133971293, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.9785764622973924, "fo": -0.5, "r": 2.289473684210526, "e": -0.16279340490885932}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1505_b082fc1e", "label": 1, "code": "@Override\npublic void addMutations(Iterable<Mutation> iterable) throws MutationsRejectedException {\n    for (Mutation m : iterable) {\n        acu.addMutation(tablename, m);\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void addMutations(Iterable<Mutation> iterable) throws MutationsRejectedException {\n    for (Mutation m : iterable) {\n        acu.addMutation(tablename, m);\n    }\n}", "lc": -0.36363636363636365, "pi": -0.004784688995215422, "ma": -0.4, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.5777307963354474, "fo": -0.4166666666666667, "r": 0.5, "e": -0.16279340490885932}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-320_c06cc933", "label": 1, "code": "/**\n * {@inheritDoc}\n */\npublic RealMatrix getU() throws InvalidMatrixException {\n    if (cachedU == null) {\n        if (m >= n) {\n            // the tridiagonal matrix is Bt.B, where B is upper bidiagonal\n            final double[][] eData = eigenDecomposition.getV().getData();\n            final double[][] iData = new double[m][];\n            double[] ei1 = eData[0];\n            iData[0] = ei1;\n            for (int i = 0; i < n - 1; ++i) {\n                // compute B.E.S^(-1) where E is the eigenvectors matrix\n                // we reuse the array from matrix E to store the result\n                final double mi = mainBidiagonal[i];\n                final double si = secondaryBidiagonal[i];\n                final double[] ei0 = ei1;\n                ei1 = eData[i + 1];\n                iData[i + 1] = ei1;\n                for (int j = 0; j < n; ++j) {\n                    ei0[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n                }\n            }\n            // last row\n            final double lastMain = mainBidiagonal[n - 1];\n            for (int j = 0; j < n; ++j) {\n                ei1[j] *= lastMain / singularValues[j];\n            }\n            for (int i = n; i < m; ++i) {\n                iData[i] = new double[n];\n            }\n            cachedU = transformer.getU().multiply(MatrixUtils.createRealMatrix(iData));\n        } else {\n            // the tridiagonal matrix is B.Bt, where B is lower bidiagonal\n            cachedU = transformer.getU().multiply(eigenDecomposition.getV());\n        }\n    }\n    // return the cached matrix\n    return cachedU;\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "public RealMatrix getU() throws InvalidMatrixException {\n    if (cachedU == null) {\n        if (m >= n) {\n                        final double[][] eData = eigenDecomposition.getV().getData();\n            final double[][] iData = new double[m][];\n            double[] ei1 = eData[0];\n            iData[0] = ei1;\n            for (int i = 0; i < n - 1; ++i) {\n                                                final double mi = mainBidiagonal[i];\n                final double si = secondaryBidiagonal[i];\n                final double[] ei0 = ei1;\n                ei1 = eData[i + 1];\n                iData[i + 1] = ei1;\n                for (int j = 0; j < n; ++j) {\n                    ei0[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n                }\n            }\n                        final double lastMain = mainBidiagonal[n - 1];\n            for (int j = 0; j < n; ++j) {\n                ei1[j] *= lastMain / singularValues[j];\n            }\n            for (int i = n; i < m; ++i) {\n                iData[i] = new double[n];\n            }\n            cachedU = transformer.getU().multiply(MatrixUtils.createRealMatrix(iData));\n        } else {\n                        cachedU = transformer.getU().multiply(eigenDecomposition.getV());\n        }\n    }\n        return cachedU;\n}", "lc": 0.7727272727272727, "pi": 0.8899521531100476, "ma": 0.6, "nbd": 1.0, "ml": 0.5, "d": 2.8154761904761907, "mi": -0.5946441155743479, "fo": 0.16666666666666666, "r": -0.02631578947368421, "e": 4.955642767817522}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-579_7d72e6ed", "label": 3, "code": "public QueryIndex getBestIndex(Query query, NodeState rootState, Filter filter) {\n    QueryIndex best = null;\n    if (LOG.isDebugEnabled()) {\n        LOG.debug(\"cost using filter \" + filter);\n    }\n    double bestCost = Double.POSITIVE_INFINITY;\n    for (QueryIndex index : getIndexes(rootState)) {\n        double cost = index.getCost(filter, rootState);\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"cost for \" + index.getIndexName() + \" is \" + cost);\n        }\n        if (cost < bestCost) {\n            bestCost = cost;\n            best = index;\n        }\n    }\n    if (best == null) {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"no indexes found - using TraversingIndex; indexProvider: \" + indexProvider);\n        }\n        best = new TraversingIndex();\n    }\n    return best;\n}", "code_comment": NaN, "code_no_comment": "public QueryIndex getBestIndex(Query query, NodeState rootState, Filter filter) {\n    QueryIndex best = null;\n    if (LOG.isDebugEnabled()) {\n        LOG.debug(\"cost using filter \" + filter);\n    }\n    double bestCost = Double.POSITIVE_INFINITY;\n    for (QueryIndex index : getIndexes(rootState)) {\n        double cost = index.getCost(filter, rootState);\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"cost for \" + index.getIndexName() + \" is \" + cost);\n        }\n        if (cost < bestCost) {\n            bestCost = cost;\n            best = index;\n        }\n    }\n    if (best == null) {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"no indexes found - using TraversingIndex; indexProvider: \" + indexProvider);\n        }\n        best = new TraversingIndex();\n    }\n    return best;\n}", "lc": 0.45454545454545453, "pi": 0.21052631578947367, "ma": 0.6, "nbd": 0.0, "ml": 0.3333333333333333, "d": 0.4285714285714286, "mi": -0.3713883016208596, "fo": 0.25, "r": 0.0, "e": 0.45499213360764845}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3324_5f863af6", "label": 1, "code": "@Override\npublic boolean isGranted(long repositoryPermissions) {\n    return hasPermissions(getEntryIterator(new EntryPredicate()), repositoryPermissions, null);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean isGranted(long repositoryPermissions) {\n    return hasPermissions(getEntryIterator(new EntryPredicate()), repositoryPermissions, null);\n}", "lc": -0.45454545454545453, "pi": -0.6028708133971293, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.8548273431994357, "fo": -0.3333333333333333, "r": 0.31578947368421056, "e": -0.16279340490885932}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-371_bb005b56", "label": 1, "code": "/**\n * Returns a matrix of p-values associated with the (two-sided) null\n * hypothesis that the corresponding correlation coefficient is zero.\n * <p><code>getCorrelationPValues().getEntry(i,j)</code> is the probability\n * that a random variable distributed as <code>t<sub>n-2</sub></code> takes\n * a value with absolute value greater than or equal to <br>\n * <code>|r|((n - 2) / (1 - r<sup>2</sup>))<sup>1/2</sup></code></p>\n * <p>The values in the matrix are sometimes referred to as the\n * <i>significance</i> of the corresponding correlation coefficients.</p>\n *\n * @return matrix of p-values\n * @throws MathException if an error occurs estimating probabilities\n */\npublic RealMatrix getCorrelationPValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double r = correlationMatrix.getEntry(i, j);\n                double t = Math.abs(r * Math.sqrt((nObs - 2) / (1 - r * r)));\n                out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n            }\n        }\n    }\n    return new BlockRealMatrix(out);\n}", "code_comment": "/**\n * Returns a matrix of p-values associated with the (two-sided) null\n * hypothesis that the corresponding correlation coefficient is zero.\n * <p><code>getCorrelationPValues().getEntry(i,j)</code> is the probability\n * that a random variable distributed as <code>t<sub>n-2</sub></code> takes\n * a value with absolute value greater than or equal to <br>\n * <code>|r|((n - 2) / (1 - r<sup>2</sup>))<sup>1/2</sup></code></p>\n * <p>The values in the matrix are sometimes referred to as the\n * <i>significance</i> of the corresponding correlation coefficients.</p>\n *\n * @return matrix of p-values\n * @throws MathException if an error occurs estimating probabilities\n */\n", "code_no_comment": "public RealMatrix getCorrelationPValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double r = correlationMatrix.getEntry(i, j);\n                double t = Math.abs(r * Math.sqrt((nObs - 2) / (1 - r * r)));\n                out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n            }\n        }\n    }\n    return new BlockRealMatrix(out);\n}", "lc": 0.13636363636363635, "pi": 1.2344497607655505, "ma": 0.0, "nbd": 0.5, "ml": 0.08333333333333333, "d": 0.9404761904761905, "mi": -0.2197322057787174, "fo": -0.08333333333333333, "r": 0.02631578947368421, "e": 1.0455536153708727}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-3011_5a86a0a1", "label": 0, "code": "public void cancel() {\n    while (true) {\n        JobStatus current = state;\n        if (current == JobStatus.RUNNING || current == JobStatus.CREATED) {\n            if (transitionState(current, JobStatus.CANCELLING)) {\n                for (ExecutionJobVertex ejv : verticesInCreationOrder) {\n                    ejv.cancel();\n                }\n                return;\n            }\n        } else {\n            // no need to treat other states\n            return;\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "public void cancel() {\n    while (true) {\n        JobStatus current = state;\n        if (current == JobStatus.RUNNING || current == JobStatus.CREATED) {\n            if (transitionState(current, JobStatus.CANCELLING)) {\n                for (ExecutionJobVertex ejv : verticesInCreationOrder) {\n                    ejv.cancel();\n                }\n                return;\n            }\n        } else {\n                        return;\n        }\n    }\n}", "lc": 0.045454545454545456, "pi": 1.3492822966507174, "ma": 0.2, "nbd": 1.0, "ml": 0.08333333333333333, "d": -0.04365079365079365, "mi": 0.03340380549682881, "fo": -0.3333333333333333, "r": 0.5263157894736842, "e": -0.08831797513874241}
{"project_name": "Cli", "project_version": 27, "label": 1, "code": "/**\n * Set the selected option of this group to <code>name</code>.\n *\n * @param option the option that is selected\n * @throws AlreadySelectedException if an option from this group has\n * already been selected.\n */\npublic void setSelected(Option option) throws AlreadySelectedException {\n    if (option == null) {\n        // reset the option previously selected\n        selected = null;\n        return;\n    }\n    // selected member variable\n    if (selected == null || selected.equals(option.getOpt())) {\n        selected = option.getOpt();\n    } else {\n        throw new AlreadySelectedException(this, option);\n    }\n}", "code_comment": "/**\n * Set the selected option of this group to <code>name</code>.\n *\n * @param option the option that is selected\n * @throws AlreadySelectedException if an option from this group has\n * already been selected.\n */\n", "code_no_comment": "public void setSelected(Option option) throws AlreadySelectedException {\n    if (option == null) {\n                selected = null;\n        return;\n    }\n        if (selected == null || selected.equals(option.getOpt())) {\n        selected = option.getOpt();\n    } else {\n        throw new AlreadySelectedException(this, option);\n    }\n}", "lc": -0.13636363636363635, "pi": -0.06220095693779921, "ma": 0.0, "nbd": -0.5, "ml": 0.16666666666666666, "d": 0.07539682539682542, "mi": 0.19774489076814655, "fo": -0.25, "r": 0.21052631578947367, "e": -0.07097387666188344}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-6779_f412d744", "label": 1, "code": "@Converter\npublic XMLStreamReader createXMLStreamReader(InputStream in, Exchange exchange) throws XMLStreamException {\n    XMLInputFactory factory = getInputFactory();\n    try {\n        return factory.createXMLStreamReader(IOHelper.buffered(in), IOHelper.getCharsetName(exchange));\n    } finally {\n        returnXMLInputFactory(factory);\n    }\n}", "code_comment": NaN, "code_no_comment": "@Converter\npublic XMLStreamReader createXMLStreamReader(InputStream in, Exchange exchange) throws XMLStreamException {\n    XMLInputFactory factory = getInputFactory();\n    try {\n        return factory.createXMLStreamReader(IOHelper.buffered(in), IOHelper.getCharsetName(exchange));\n    } finally {\n        returnXMLInputFactory(factory);\n    }\n}", "lc": -0.22727272727272727, "pi": -0.01913875598086126, "ma": -0.6, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.30176180408738534, "fo": -0.08333333333333333, "r": 0.2894736842105263, "e": -0.16279340490885932}
{"project_name": "Closure", "project_version": 4, "label": 2, "code": "/**\n * Resolve the referenced type within the enclosing scope.\n */\n@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {\n    // TODO(user): Investigate whether it is really necessary to keep two\n    // different mechanisms for resolving named types, and if so, which order\n    // makes more sense. Now, resolution via registry is first in order to\n    // avoid triggering the warnings built into the resolution via properties.\n    boolean resolved = resolveViaRegistry(t, enclosing);\n    if (detectImplicitPrototypeCycle()) {\n        handleTypeCycle(t);\n    }\n    if (resolved) {\n        super.resolveInternal(t, enclosing);\n        finishPropertyContinuations();\n        return registry.isLastGeneration() ? getReferencedType() : this;\n    }\n    resolveViaProperties(t, enclosing);\n    if (detectImplicitPrototypeCycle()) {\n        handleTypeCycle(t);\n    }\n    super.resolveInternal(t, enclosing);\n    if (isResolved()) {\n        finishPropertyContinuations();\n    }\n    return registry.isLastGeneration() ? getReferencedType() : this;\n}", "code_comment": "/**\n * Resolve the referenced type within the enclosing scope.\n */\n", "code_no_comment": "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {\n                    boolean resolved = resolveViaRegistry(t, enclosing);\n    if (detectImplicitPrototypeCycle()) {\n        handleTypeCycle(t);\n    }\n    if (resolved) {\n        super.resolveInternal(t, enclosing);\n        finishPropertyContinuations();\n        return registry.isLastGeneration() ? getReferencedType() : this;\n    }\n    resolveViaProperties(t, enclosing);\n    if (detectImplicitPrototypeCycle()) {\n        handleTypeCycle(t);\n    }\n    super.resolveInternal(t, enclosing);\n    if (isResolved()) {\n        finishPropertyContinuations();\n    }\n    return registry.isLastGeneration() ? getReferencedType() : this;\n}", "lc": 0.3181818181818182, "pi": -0.20574162679425848, "ma": 0.6, "nbd": -0.5, "ml": 0.4166666666666667, "d": -0.3650793650793651, "mi": -0.20704721634954185, "fo": 0.75, "r": -0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "Math", "project_version": 50, "label": 1, "code": "/**\n * {@inheritDoc}\n */\nprotected final double doSolve() {\n    // Get initial solution\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    // regardless of the allowed solutions.\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    // Verify bracketing of initial solution.\n    verifyBracketing(x0, x1);\n    // Get accuracies.\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    // Keep track of inverted intervals, meaning that the left bound is\n    // larger than the right bound.\n    boolean inverted = false;\n    // Keep finding better approximations.\n    while (true) {\n        // Calculate the next approximation.\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        // we can return it regardless of the allowed solutions.\n        if (fx == 0.0) {\n            return x;\n        }\n        // Update the bounds with the new approximation.\n        if (f1 * fx < 0) {\n            // The value of x1 has switched to the other bound, thus inverting\n            // the interval.\n            x0 = x1;\n            f0 = f1;\n            inverted = !inverted;\n        } else {\n            switch(method) {\n                case ILLINOIS:\n                    f0 *= 0.5;\n                    break;\n                case PEGASUS:\n                    f0 *= f1 / (f1 + fx);\n                    break;\n                case REGULA_FALSI:\n                    // Nothing.\n                    if (x == x1) {\n                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                        f0 = computeObjectiveValue(x0);\n                    }\n                    break;\n                default:\n                    // Should never happen.\n                    throw new MathInternalError();\n            }\n        }\n        // Update from [x0, x1] to [x0, x].\n        x1 = x;\n        f1 = fx;\n        // the root than we already are.\n        if (FastMath.abs(f1) <= ftol) {\n            switch(allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                case BELOW_SIDE:\n                    if (f1 <= 0) {\n                        return x1;\n                    }\n                    break;\n                case ABOVE_SIDE:\n                    if (f1 >= 0) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n        // are satisfied with the current approximation.\n        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {\n            switch(allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                case BELOW_SIDE:\n                    return (f1 <= 0) ? x1 : x0;\n                case ABOVE_SIDE:\n                    return (f1 >= 0) ? x1 : x0;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n    }\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "protected final double doSolve() {\n        double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n        if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n        verifyBracketing(x0, x1);\n        final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n            boolean inverted = false;\n        while (true) {\n                final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n                if (fx == 0.0) {\n            return x;\n        }\n                if (f1 * fx < 0) {\n                                    x0 = x1;\n            f0 = f1;\n            inverted = !inverted;\n        } else {\n            switch(method) {\n                case ILLINOIS:\n                    f0 *= 0.5;\n                    break;\n                case PEGASUS:\n                    f0 *= f1 / (f1 + fx);\n                    break;\n                case REGULA_FALSI:\n                                        if (x == x1) {\n                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                        f0 = computeObjectiveValue(x0);\n                    }\n                    break;\n                default:\n                                        throw new MathInternalError();\n            }\n        }\n                x1 = x;\n        f1 = fx;\n                if (FastMath.abs(f1) <= ftol) {\n            switch(allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                case BELOW_SIDE:\n                    if (f1 <= 0) {\n                        return x1;\n                    }\n                    break;\n                case ABOVE_SIDE:\n                    if (f1 >= 0) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n                if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {\n            switch(allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                case BELOW_SIDE:\n                    return (f1 <= 0) ? x1 : x0;\n                case ABOVE_SIDE:\n                    return (f1 >= 0) ? x1 : x0;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n    }\n}", "lc": 3.5454545454545454, "pi": 1.7751196172248804, "ma": 7.8, "nbd": 1.5, "ml": 3.3333333333333335, "d": 3.238095238095238, "mi": -1.3833685694150806, "fo": 0.8333333333333334, "r": -0.02631578947368421, "e": 8.485761541697642}
{"project_name": "Compress", "project_version": 32, "label": 3, "code": "private void applyPaxHeadersToCurrentEntry(Map<String, String> headers) {\n    /*\n         * The following headers are defined for Pax.\n         * atime, ctime, charset: cannot use these without changing TarArchiveEntry fields\n         * mtime\n         * comment\n         * gid, gname\n         * linkpath\n         * size\n         * uid,uname\n         * SCHILY.devminor, SCHILY.devmajor: don't have setters/getters for those\n         */\n    for (Entry<String, String> ent : headers.entrySet()) {\n        String key = ent.getKey();\n        String val = ent.getValue();\n        if (\"path\".equals(key)) {\n            currEntry.setName(val);\n        } else if (\"linkpath\".equals(key)) {\n            currEntry.setLinkName(val);\n        } else if (\"gid\".equals(key)) {\n            currEntry.setGroupId(Integer.parseInt(val));\n        } else if (\"gname\".equals(key)) {\n            currEntry.setGroupName(val);\n        } else if (\"uid\".equals(key)) {\n            currEntry.setUserId(Integer.parseInt(val));\n        } else if (\"uname\".equals(key)) {\n            currEntry.setUserName(val);\n        } else if (\"size\".equals(key)) {\n            currEntry.setSize(Long.parseLong(val));\n        } else if (\"mtime\".equals(key)) {\n            currEntry.setModTime((long) (Double.parseDouble(val) * 1000));\n        } else if (\"SCHILY.devminor\".equals(key)) {\n            currEntry.setDevMinor(Integer.parseInt(val));\n        } else if (\"SCHILY.devmajor\".equals(key)) {\n            currEntry.setDevMajor(Integer.parseInt(val));\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "private void applyPaxHeadersToCurrentEntry(Map<String, String> headers) {\n        for (Entry<String, String> ent : headers.entrySet()) {\n        String key = ent.getKey();\n        String val = ent.getValue();\n        if (\"path\".equals(key)) {\n            currEntry.setName(val);\n        } else if (\"linkpath\".equals(key)) {\n            currEntry.setLinkName(val);\n        } else if (\"gid\".equals(key)) {\n            currEntry.setGroupId(Integer.parseInt(val));\n        } else if (\"gname\".equals(key)) {\n            currEntry.setGroupName(val);\n        } else if (\"uid\".equals(key)) {\n            currEntry.setUserId(Integer.parseInt(val));\n        } else if (\"uname\".equals(key)) {\n            currEntry.setUserName(val);\n        } else if (\"size\".equals(key)) {\n            currEntry.setSize(Long.parseLong(val));\n        } else if (\"mtime\".equals(key)) {\n            currEntry.setModTime((long) (Double.parseDouble(val) * 1000));\n        } else if (\"SCHILY.devminor\".equals(key)) {\n            currEntry.setDevMinor(Integer.parseInt(val));\n        } else if (\"SCHILY.devmajor\".equals(key)) {\n            currEntry.setDevMajor(Integer.parseInt(val));\n        }\n    }\n}", "lc": 0.5909090909090909, "pi": 0.1913875598086124, "ma": 1.6, "nbd": 4.5, "ml": 1.3333333333333333, "d": 0.0853174603174603, "mi": -0.5221987315010571, "fo": 1.9166666666666667, "r": -0.02631578947368421, "e": 0.3819643505471896}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-343_f6dd42b4", "label": 0, "code": "/**\n * Find a zero in the given interval with an initial guess.\n * <p>Throws <code>IllegalArgumentException</code> if the values of the\n * function at the three points have the same sign (note that it is\n * allowed to have endpoints with the same sign if the initial point has\n * opposite sign function-wise).</p>\n *\n * @param f function to solve.\n * @param min the lower bound for the interval.\n * @param max the upper bound for the interval.\n * @param initial the start value to use (must be set to min if no\n * initial point is known).\n * @return the value where the function is zero\n * @throws MaxIterationsExceededException the maximum iteration count\n * is exceeded\n * @throws FunctionEvaluationException if an error occurs evaluating\n *  the function\n * @throws IllegalArgumentException if initial is not between min and max\n * (even if it <em>is</em> a root)\n */\npublic double solve(final UnivariateRealFunction f, final double min, final double max, final double initial) throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifySequence(min, initial, max);\n    // return the initial guess if it is good enough\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n    // return the first endpoint if it is good enough\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(yMin, 0);\n        return result;\n    }\n    // reduce interval if min and initial bracket the root\n    if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n    // return the second endpoint if it is good enough\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(yMax, 0);\n        return result;\n    }\n    // reduce interval if initial and max bracket the root\n    if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }\n    // full Brent algorithm starting with provided initial guess\n    return solve(f, min, yMin, max, yMax, initial, yInitial);\n}", "code_comment": "/**\n * Find a zero in the given interval with an initial guess.\n * <p>Throws <code>IllegalArgumentException</code> if the values of the\n * function at the three points have the same sign (note that it is\n * allowed to have endpoints with the same sign if the initial point has\n * opposite sign function-wise).</p>\n *\n * @param f function to solve.\n * @param min the lower bound for the interval.\n * @param max the upper bound for the interval.\n * @param initial the start value to use (must be set to min if no\n * initial point is known).\n * @return the value where the function is zero\n * @throws MaxIterationsExceededException the maximum iteration count\n * is exceeded\n * @throws FunctionEvaluationException if an error occurs evaluating\n *  the function\n * @throws IllegalArgumentException if initial is not between min and max\n * (even if it <em>is</em> a root)\n */\n", "code_no_comment": "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial) throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifySequence(min, initial, max);\n        double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n        double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(yMin, 0);\n        return result;\n    }\n        if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n        double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(yMax, 0);\n        return result;\n    }\n        if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }\n        return solve(f, min, yMin, max, yMax, initial, yInitial);\n}", "lc": 0.5454545454545454, "pi": -0.3301435406698567, "ma": 0.4, "nbd": -0.5, "ml": 0.5833333333333334, "d": 1.146825396825397, "mi": -0.4339675828047919, "fo": 0.6666666666666666, "r": -0.02631578947368421, "e": 1.3053047722780264}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-258_7b38965d", "label": 1, "code": "/**\n * Create an HTML Layout.\n * @param locationInfo If \"true\", location information will be included. The default is false.\n * @param title The title to include in the file header. If none is specified the default title will be used.\n * @param contentType The content type. Defaults to \"text/html\".\n * @param charsetName The character set to use. If not specified, the default will be used.\n * @param fontSize The font size of the text.\n * @param font The font to use for the text.\n * @return An HTML Layout.\n */\n@PluginFactory\npublic static HTMLLayout createLayout(@PluginAttr(\"locationInfo\") final String locationInfo, @PluginAttr(\"title\") String title, @PluginAttr(\"contentType\") String contentType, @PluginAttr(\"charset\") final String charsetName, @PluginAttr(\"fontSize\") String fontSize, @PluginAttr(\"fontName\") String font) {\n    final Charset charset = Charsets.getSupportedCharset(charsetName);\n    if (font == null) {\n        font = \"arial,sans-serif\";\n    }\n    final FontSize fs = FontSize.getFontSize(fontSize);\n    fontSize = fs.getFontSize();\n    final String headerSize = fs.larger().getFontSize();\n    final boolean info = locationInfo == null ? false : Boolean.valueOf(locationInfo);\n    if (title == null) {\n        title = DEFAULT_TITLE;\n    }\n    if (contentType == null) {\n        contentType = DEFAULT_CONTENT_TYPE;\n    }\n    return new HTMLLayout(info, title, contentType, charset, font, fontSize, headerSize);\n}", "code_comment": "/**\n * Create an HTML Layout.\n * @param locationInfo If \"true\", location information will be included. The default is false.\n * @param title The title to include in the file header. If none is specified the default title will be used.\n * @param contentType The content type. Defaults to \"text/html\".\n * @param charsetName The character set to use. If not specified, the default will be used.\n * @param fontSize The font size of the text.\n * @param font The font to use for the text.\n * @return An HTML Layout.\n */\n", "code_no_comment": "@PluginFactory\npublic static HTMLLayout createLayout(@PluginAttr(\"locationInfo\") final String locationInfo, @PluginAttr(\"title\") String title, @PluginAttr(\"contentType\") String contentType, @PluginAttr(\"charset\") final String charsetName, @PluginAttr(\"fontSize\") String fontSize, @PluginAttr(\"fontName\") String font) {\n    final Charset charset = Charsets.getSupportedCharset(charsetName);\n    if (font == null) {\n        font = \"arial,sans-serif\";\n    }\n    final FontSize fs = FontSize.getFontSize(fontSize);\n    fontSize = fs.getFontSize();\n    final String headerSize = fs.larger().getFontSize();\n    final boolean info = locationInfo == null ? false : Boolean.valueOf(locationInfo);\n    if (title == null) {\n        title = DEFAULT_TITLE;\n    }\n    if (contentType == null) {\n        contentType = DEFAULT_CONTENT_TYPE;\n    }\n    return new HTMLLayout(info, title, contentType, charset, font, fontSize, headerSize);\n}", "lc": 0.18181818181818182, "pi": -0.32535885167464124, "ma": 0.2, "nbd": -0.5, "ml": 0.25, "d": 0.11706349206349208, "mi": -0.2617336152219872, "fo": 0.0, "r": -0.02631578947368421, "e": 0.3139941102908548}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1199_813109d7", "label": 3, "code": "public int compareTo(setTableProperty_result other) {\n    if (!getClass().equals(other.getClass())) {\n        return getClass().getName().compareTo(other.getClass().getName());\n    }\n    int lastComparison = 0;\n    setTableProperty_result typedOther = (setTableProperty_result) other;\n    lastComparison = Boolean.valueOf(isSetOuch1()).compareTo(typedOther.isSetOuch1());\n    if (lastComparison != 0) {\n        return lastComparison;\n    }\n    if (isSetOuch1()) {\n        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.ouch1, typedOther.ouch1);\n        if (lastComparison != 0) {\n            return lastComparison;\n        }\n    }\n    lastComparison = Boolean.valueOf(isSetOuch2()).compareTo(typedOther.isSetOuch2());\n    if (lastComparison != 0) {\n        return lastComparison;\n    }\n    if (isSetOuch2()) {\n        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.ouch2, typedOther.ouch2);\n        if (lastComparison != 0) {\n            return lastComparison;\n        }\n    }\n    return 0;\n}", "code_comment": NaN, "code_no_comment": "public int compareTo(setTableProperty_result other) {\n    if (!getClass().equals(other.getClass())) {\n        return getClass().getName().compareTo(other.getClass().getName());\n    }\n    int lastComparison = 0;\n    setTableProperty_result typedOther = (setTableProperty_result) other;\n    lastComparison = Boolean.valueOf(isSetOuch1()).compareTo(typedOther.isSetOuch1());\n    if (lastComparison != 0) {\n        return lastComparison;\n    }\n    if (isSetOuch1()) {\n        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.ouch1, typedOther.ouch1);\n        if (lastComparison != 0) {\n            return lastComparison;\n        }\n    }\n    lastComparison = Boolean.valueOf(isSetOuch2()).compareTo(typedOther.isSetOuch2());\n    if (lastComparison != 0) {\n        return lastComparison;\n    }\n    if (isSetOuch2()) {\n        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.ouch2, typedOther.ouch2);\n        if (lastComparison != 0) {\n            return lastComparison;\n        }\n    }\n    return 0;\n}", "lc": 0.6363636363636364, "pi": -0.04306220095693795, "ma": 0.8, "nbd": 0.0, "ml": 0.5833333333333334, "d": 0.2996031746031746, "mi": -0.4556730091613809, "fo": 1.1666666666666667, "r": -0.02631578947368421, "e": 0.3821533744806163}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-217_add180fb", "label": 1, "code": "@Override\npublic void rename(String oldTableName, String newTableName) throws AccumuloSecurityException, TableNotFoundException, AccumuloException, TableExistsException {\n    MockTable t = acu.tables.remove(oldTableName);\n    acu.tables.put(newTableName, t);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void rename(String oldTableName, String newTableName) throws AccumuloSecurityException, TableNotFoundException, AccumuloException, TableExistsException {\n    MockTable t = acu.tables.remove(oldTableName);\n    acu.tables.put(newTableName, t);\n}", "lc": -0.4090909090909091, "pi": -0.49282296650717716, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.5701198026779419, "fo": -0.3333333333333333, "r": -0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3082_29e5b734", "label": 3, "code": "@Nonnull\n@Override\npublic AccessControlPolicy[] getEffectivePolicies(@Nonnull Set<Principal> principals) throws RepositoryException {\n    Util.checkValidPrincipals(principals, principalManager);\n    Root r = getLatestRoot();\n    Result aceResult = searchAces(principals, r);\n    List<AccessControlPolicy> effective = new ArrayList<AccessControlPolicy>();\n    for (ResultRow row : aceResult.getRows()) {\n        String acePath = row.getPath();\n        String aclName = Text.getName(Text.getRelativeParent(acePath, 1));\n        Tree accessControlledTree = r.getTree(Text.getRelativeParent(acePath, 2));\n        if (aclName.isEmpty() || !accessControlledTree.exists()) {\n            log.debug(\"Isolated access control entry -> ignore query result at \" + acePath);\n            continue;\n        }\n        String path = (REP_REPO_POLICY.equals(aclName)) ? null : accessControlledTree.getPath();\n        AccessControlPolicy policy = createACL(path, accessControlledTree, true);\n        if (policy != null) {\n            effective.add(policy);\n        }\n    }\n    return effective.toArray(new AccessControlPolicy[effective.size()]);\n}", "code_comment": NaN, "code_no_comment": "@Nonnull\n@Override\npublic AccessControlPolicy[] getEffectivePolicies(@Nonnull Set<Principal> principals) throws RepositoryException {\n    Util.checkValidPrincipals(principals, principalManager);\n    Root r = getLatestRoot();\n    Result aceResult = searchAces(principals, r);\n    List<AccessControlPolicy> effective = new ArrayList<AccessControlPolicy>();\n    for (ResultRow row : aceResult.getRows()) {\n        String acePath = row.getPath();\n        String aclName = Text.getName(Text.getRelativeParent(acePath, 1));\n        Tree accessControlledTree = r.getTree(Text.getRelativeParent(acePath, 2));\n        if (aclName.isEmpty() || !accessControlledTree.exists()) {\n            log.debug(\"Isolated access control entry -> ignore query result at \" + acePath);\n            continue;\n        }\n        String path = (REP_REPO_POLICY.equals(aclName)) ? null : accessControlledTree.getPath();\n        AccessControlPolicy policy = createACL(path, accessControlledTree, true);\n        if (policy != null) {\n            effective.add(policy);\n        }\n    }\n    return effective.toArray(new AccessControlPolicy[effective.size()]);\n}", "lc": 0.4090909090909091, "pi": 0.3444976076555023, "ma": 0.4, "nbd": 0.0, "ml": 0.3333333333333333, "d": 0.27976190476190477, "mi": -0.41846370683579975, "fo": 1.0, "r": -0.02631578947368421, "e": 0.6650991511211769}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5359_61122bab", "label": 3, "code": "/**\n *  Convert to character, returning default value if text is inconvertible.\n *\n *  @param defaultValue\n *             the default value\n *  @return the converted text as a primitive char or the default value if text is not a single character\n */\npublic final char toChar(final char defaultValue) {\n    if (text != null) {\n        try {\n            return toChar();\n        } catch (StringValueConversionException x) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(String.format(\"An error occurred while converting '%s' to a character: %s\", text, x.getMessage()), x);\n            }\n        }\n    }\n    return defaultValue;\n}", "code_comment": "/**\n *  Convert to character, returning default value if text is inconvertible.\n *\n *  @param defaultValue\n *             the default value\n *  @return the converted text as a primitive char or the default value if text is not a single character\n */\n", "code_no_comment": "public final char toChar(final char defaultValue) {\n    if (text != null) {\n        try {\n            return toChar();\n        } catch (StringValueConversionException x) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(String.format(\"An error occurred while converting '%s' to a character: %s\", text, x.getMessage()), x);\n            }\n        }\n    }\n    return defaultValue;\n}", "lc": -0.09090909090909091, "pi": 0.8899521531100476, "ma": 0.0, "nbd": 0.5, "ml": -0.08333333333333333, "d": -0.3650793650793651, "mi": 0.17096546863988715, "fo": -0.08333333333333333, "r": 1.0789473684210527, "e": -0.16279340490885932}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-1820_39d526e6", "label": 0, "code": "@Override\npublic int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, Integer reusable) {\n    long val = 0;\n    boolean neg = false;\n    final int delimLimit = limit - delimiter.length + 1;\n    if (bytes[startPos] == '-') {\n        neg = true;\n        startPos++;\n        // check for empty field with only the sign\n        if (startPos == limit || (startPos < delimLimit && delimiterNext(bytes, startPos, delimiter))) {\n            setErrorState(ParseErrorState.NUMERIC_VALUE_ORPHAN_SIGN);\n            return -1;\n        }\n    }\n    for (int i = startPos; i < limit; i++) {\n        if (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\n            this.result = (int) (neg ? -val : val);\n            return i + delimiter.length;\n        }\n        if (bytes[i] < 48 || bytes[i] > 57) {\n            setErrorState(ParseErrorState.NUMERIC_VALUE_ILLEGAL_CHARACTER);\n            return -1;\n        }\n        val *= 10;\n        val += bytes[i] - 48;\n        if (val > OVERFLOW_BOUND && (!neg || val > UNDERFLOW_BOUND)) {\n            setErrorState(ParseErrorState.NUMERIC_VALUE_OVERFLOW_UNDERFLOW);\n            return -1;\n        }\n    }\n    this.result = (int) (neg ? -val : val);\n    return limit;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, Integer reusable) {\n    long val = 0;\n    boolean neg = false;\n    final int delimLimit = limit - delimiter.length + 1;\n    if (bytes[startPos] == '-') {\n        neg = true;\n        startPos++;\n                if (startPos == limit || (startPos < delimLimit && delimiterNext(bytes, startPos, delimiter))) {\n            setErrorState(ParseErrorState.NUMERIC_VALUE_ORPHAN_SIGN);\n            return -1;\n        }\n    }\n    for (int i = startPos; i < limit; i++) {\n        if (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\n            this.result = (int) (neg ? -val : val);\n            return i + delimiter.length;\n        }\n        if (bytes[i] < 48 || bytes[i] > 57) {\n            setErrorState(ParseErrorState.NUMERIC_VALUE_ILLEGAL_CHARACTER);\n            return -1;\n        }\n        val *= 10;\n        val += bytes[i] - 48;\n        if (val > OVERFLOW_BOUND && (!neg || val > UNDERFLOW_BOUND)) {\n            setErrorState(ParseErrorState.NUMERIC_VALUE_OVERFLOW_UNDERFLOW);\n            return -1;\n        }\n    }\n    this.result = (int) (neg ? -val : val);\n    return limit;\n}", "lc": 0.8181818181818182, "pi": 0.3444976076555023, "ma": 1.0, "nbd": 0.0, "ml": 1.5833333333333333, "d": 2.8611111111111116, "mi": -0.6129668780831571, "fo": -0.08333333333333333, "r": -0.02631578947368421, "e": 4.717929035344017}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-2734_8b40bb7a", "label": 0, "code": "@Override\npublic Tuple getKey(IN value) throws Exception {\n    key = (Tuple) tupleClasses[keyLength - 1].newInstance();\n    comparator.extractKeys(value, keyArray, 0);\n    for (int i = 0; i < keyLength; i++) {\n        key.setField(keyArray[i], i);\n    }\n    return key;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic Tuple getKey(IN value) throws Exception {\n    key = (Tuple) tupleClasses[keyLength - 1].newInstance();\n    comparator.extractKeys(value, keyArray, 0);\n    for (int i = 0; i < keyLength; i++) {\n        key.setField(keyArray[i], i);\n    }\n    return key;\n}", "lc": -0.22727272727272727, "pi": -0.22966507177033516, "ma": -0.4, "nbd": -0.5, "ml": -0.16666666666666666, "d": 0.27380952380952384, "mi": 0.2250880902043692, "fo": -0.25, "r": 0.05263157894736841, "e": 0.06244935829832355}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-3052_8dc70f2e", "label": 1, "code": "@Override\nprotected void instantiateCandidate(OperatorDescriptorSingle dps, Channel in, List<Set<? extends NamedChannel>> broadcastPlanChannels, List<PlanNode> target, CostEstimator estimator, RequestedGlobalProperties globPropsReq, RequestedLocalProperties locPropsReq) {\n    // NOTES ON THE ENUMERATION OF THE STEP FUNCTION PLANS:\n    // Whenever we instantiate the iteration, we enumerate new candidates for the step function.\n    // That way, we make sure we have an appropriate plan for each candidate for the initial partial solution,\n    // we have a fitting candidate for the step function (often, work is pushed out of the step function).\n    // Among the candidates of the step function, we keep only those that meet the requested properties of the\n    // current candidate initial partial solution. That makes sure these properties exist at the beginning of\n    // the successive iteration.\n    // 1) Because we enumerate multiple times, we may need to clean the cached plans\n    // before starting another enumeration\n    this.nextPartialSolution.accept(PlanCacheCleaner.INSTANCE);\n    if (this.terminationCriterion != null) {\n        this.terminationCriterion.accept(PlanCacheCleaner.INSTANCE);\n    }\n    // 2) Give the partial solution the properties of the current candidate for the initial partial solution\n    this.partialSolution.setCandidateProperties(in.getGlobalProperties(), in.getLocalProperties(), in);\n    final BulkPartialSolutionPlanNode pspn = this.partialSolution.getCurrentPartialSolutionPlanNode();\n    // 3) Get the alternative plans\n    List<PlanNode> candidates = this.nextPartialSolution.getAlternativePlans(estimator);\n    // 4) Make sure that the beginning of the step function does not assume properties that\n    // are not also produced by the end of the step function.\n    {\n        List<PlanNode> newCandidates = new ArrayList<PlanNode>();\n        for (Iterator<PlanNode> planDeleter = candidates.iterator(); planDeleter.hasNext(); ) {\n            PlanNode candidate = planDeleter.next();\n            GlobalProperties atEndGlobal = candidate.getGlobalProperties();\n            LocalProperties atEndLocal = candidate.getLocalProperties();\n            FeedbackPropertiesMeetRequirementsReport report = candidate.checkPartialSolutionPropertiesMet(pspn, atEndGlobal, atEndLocal);\n            if (report == FeedbackPropertiesMeetRequirementsReport.NO_PARTIAL_SOLUTION) {\n                // depends only through broadcast variable on the partial solution\n                ;\n            } else if (report == FeedbackPropertiesMeetRequirementsReport.NOT_MET) {\n                // attach a no-op node through which we create the properties of the original input\n                Channel toNoOp = new Channel(candidate);\n                globPropsReq.parameterizeChannel(toNoOp, false, rootConnection.getDataExchangeMode(), false);\n                locPropsReq.parameterizeChannel(toNoOp);\n                UnaryOperatorNode rebuildPropertiesNode = new UnaryOperatorNode(\"Rebuild Partial Solution Properties\", FieldList.EMPTY_LIST);\n                rebuildPropertiesNode.setParallelism(candidate.getParallelism());\n                SingleInputPlanNode rebuildPropertiesPlanNode = new SingleInputPlanNode(rebuildPropertiesNode, \"Rebuild Partial Solution Properties\", toNoOp, DriverStrategy.UNARY_NO_OP);\n                rebuildPropertiesPlanNode.initProperties(toNoOp.getGlobalProperties(), toNoOp.getLocalProperties());\n                estimator.costOperator(rebuildPropertiesPlanNode);\n                GlobalProperties atEndGlobalModified = rebuildPropertiesPlanNode.getGlobalProperties();\n                LocalProperties atEndLocalModified = rebuildPropertiesPlanNode.getLocalProperties();\n                if (!(atEndGlobalModified.equals(atEndGlobal) && atEndLocalModified.equals(atEndLocal))) {\n                    FeedbackPropertiesMeetRequirementsReport report2 = candidate.checkPartialSolutionPropertiesMet(pspn, atEndGlobalModified, atEndLocalModified);\n                    if (report2 != FeedbackPropertiesMeetRequirementsReport.NOT_MET) {\n                        newCandidates.add(rebuildPropertiesPlanNode);\n                    }\n                }\n                planDeleter.remove();\n            }\n        }\n    }\n    if (candidates.isEmpty()) {\n        return;\n    }\n    // 5) Create a candidate for the Iteration Node for every remaining plan of the step function.\n    if (terminationCriterion == null) {\n        for (PlanNode candidate : candidates) {\n            BulkIterationPlanNode node = new BulkIterationPlanNode(this, this.getOperator().getName(), in, pspn, candidate);\n            GlobalProperties gProps = candidate.getGlobalProperties().clone();\n            LocalProperties lProps = candidate.getLocalProperties().clone();\n            node.initProperties(gProps, lProps);\n            target.add(node);\n        }\n    } else if (candidates.size() > 0) {\n        List<PlanNode> terminationCriterionCandidates = this.terminationCriterion.getAlternativePlans(estimator);\n        SingleRootJoiner singleRoot = (SingleRootJoiner) this.singleRoot;\n        for (PlanNode candidate : candidates) {\n            for (PlanNode terminationCandidate : terminationCriterionCandidates) {\n                if (singleRoot.areBranchCompatible(candidate, terminationCandidate)) {\n                    BulkIterationPlanNode node = new BulkIterationPlanNode(this, \"BulkIteration (\" + this.getOperator().getName() + \")\", in, pspn, candidate, terminationCandidate);\n                    GlobalProperties gProps = candidate.getGlobalProperties().clone();\n                    LocalProperties lProps = candidate.getLocalProperties().clone();\n                    node.initProperties(gProps, lProps);\n                    target.add(node);\n                }\n            }\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\nprotected void instantiateCandidate(OperatorDescriptorSingle dps, Channel in, List<Set<? extends NamedChannel>> broadcastPlanChannels, List<PlanNode> target, CostEstimator estimator, RequestedGlobalProperties globPropsReq, RequestedLocalProperties locPropsReq) {\n                                        this.nextPartialSolution.accept(PlanCacheCleaner.INSTANCE);\n    if (this.terminationCriterion != null) {\n        this.terminationCriterion.accept(PlanCacheCleaner.INSTANCE);\n    }\n        this.partialSolution.setCandidateProperties(in.getGlobalProperties(), in.getLocalProperties(), in);\n    final BulkPartialSolutionPlanNode pspn = this.partialSolution.getCurrentPartialSolutionPlanNode();\n        List<PlanNode> candidates = this.nextPartialSolution.getAlternativePlans(estimator);\n            {\n        List<PlanNode> newCandidates = new ArrayList<PlanNode>();\n        for (Iterator<PlanNode> planDeleter = candidates.iterator(); planDeleter.hasNext(); ) {\n            PlanNode candidate = planDeleter.next();\n            GlobalProperties atEndGlobal = candidate.getGlobalProperties();\n            LocalProperties atEndLocal = candidate.getLocalProperties();\n            FeedbackPropertiesMeetRequirementsReport report = candidate.checkPartialSolutionPropertiesMet(pspn, atEndGlobal, atEndLocal);\n            if (report == FeedbackPropertiesMeetRequirementsReport.NO_PARTIAL_SOLUTION) {\n                                ;\n            } else if (report == FeedbackPropertiesMeetRequirementsReport.NOT_MET) {\n                                Channel toNoOp = new Channel(candidate);\n                globPropsReq.parameterizeChannel(toNoOp, false, rootConnection.getDataExchangeMode(), false);\n                locPropsReq.parameterizeChannel(toNoOp);\n                UnaryOperatorNode rebuildPropertiesNode = new UnaryOperatorNode(\"Rebuild Partial Solution Properties\", FieldList.EMPTY_LIST);\n                rebuildPropertiesNode.setParallelism(candidate.getParallelism());\n                SingleInputPlanNode rebuildPropertiesPlanNode = new SingleInputPlanNode(rebuildPropertiesNode, \"Rebuild Partial Solution Properties\", toNoOp, DriverStrategy.UNARY_NO_OP);\n                rebuildPropertiesPlanNode.initProperties(toNoOp.getGlobalProperties(), toNoOp.getLocalProperties());\n                estimator.costOperator(rebuildPropertiesPlanNode);\n                GlobalProperties atEndGlobalModified = rebuildPropertiesPlanNode.getGlobalProperties();\n                LocalProperties atEndLocalModified = rebuildPropertiesPlanNode.getLocalProperties();\n                if (!(atEndGlobalModified.equals(atEndGlobal) && atEndLocalModified.equals(atEndLocal))) {\n                    FeedbackPropertiesMeetRequirementsReport report2 = candidate.checkPartialSolutionPropertiesMet(pspn, atEndGlobalModified, atEndLocalModified);\n                    if (report2 != FeedbackPropertiesMeetRequirementsReport.NOT_MET) {\n                        newCandidates.add(rebuildPropertiesPlanNode);\n                    }\n                }\n                planDeleter.remove();\n            }\n        }\n    }\n    if (candidates.isEmpty()) {\n        return;\n    }\n        if (terminationCriterion == null) {\n        for (PlanNode candidate : candidates) {\n            BulkIterationPlanNode node = new BulkIterationPlanNode(this, this.getOperator().getName(), in, pspn, candidate);\n            GlobalProperties gProps = candidate.getGlobalProperties().clone();\n            LocalProperties lProps = candidate.getLocalProperties().clone();\n            node.initProperties(gProps, lProps);\n            target.add(node);\n        }\n    } else if (candidates.size() > 0) {\n        List<PlanNode> terminationCriterionCandidates = this.terminationCriterion.getAlternativePlans(estimator);\n        SingleRootJoiner singleRoot = (SingleRootJoiner) this.singleRoot;\n        for (PlanNode candidate : candidates) {\n            for (PlanNode terminationCandidate : terminationCriterionCandidates) {\n                if (singleRoot.areBranchCompatible(candidate, terminationCandidate)) {\n                    BulkIterationPlanNode node = new BulkIterationPlanNode(this, \"BulkIteration (\" + this.getOperator().getName() + \")\", in, pspn, candidate, terminationCandidate);\n                    GlobalProperties gProps = candidate.getGlobalProperties().clone();\n                    LocalProperties lProps = candidate.getLocalProperties().clone();\n                    node.initProperties(gProps, lProps);\n                    target.add(node);\n                }\n            }\n        }\n    }\n}", "lc": 2.3636363636363638, "pi": 1.4066985645933012, "ma": 2.0, "nbd": 1.5, "ml": 1.6666666666666667, "d": 1.1686507936507937, "mi": -1.1231853417899926, "fo": 3.5833333333333335, "r": -0.02631578947368421, "e": 6.1674567636566895}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-3740_f2f5bd5b", "label": 1, "code": "// ------------------------------------------------------------------------\n// Checkpointing\n// ------------------------------------------------------------------------\n@Override\npublic StreamTaskState snapshotOperatorState(long checkpointId, long timestamp) throws Exception {\n    StreamTaskState taskState = super.snapshotOperatorState(checkpointId, timestamp);\n    AbstractStateBackend.CheckpointStateOutputView out = getStateBackend().createCheckpointStateOutputView(checkpointId, timestamp);\n    out.writeInt(watermarkTimersQueue.size());\n    for (Timer<K, W> timer : watermarkTimersQueue) {\n        keySerializer.serialize(timer.key, out);\n        windowSerializer.serialize(timer.window, out);\n        out.writeLong(timer.timestamp);\n    }\n    out.writeInt(processingTimeTimers.size());\n    for (Timer<K, W> timer : processingTimeTimersQueue) {\n        keySerializer.serialize(timer.key, out);\n        windowSerializer.serialize(timer.window, out);\n        out.writeLong(timer.timestamp);\n    }\n    taskState.setOperatorState(out.closeAndGetHandle());\n    return taskState;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic StreamTaskState snapshotOperatorState(long checkpointId, long timestamp) throws Exception {\n    StreamTaskState taskState = super.snapshotOperatorState(checkpointId, timestamp);\n    AbstractStateBackend.CheckpointStateOutputView out = getStateBackend().createCheckpointStateOutputView(checkpointId, timestamp);\n    out.writeInt(watermarkTimersQueue.size());\n    for (Timer<K, W> timer : watermarkTimersQueue) {\n        keySerializer.serialize(timer.key, out);\n        windowSerializer.serialize(timer.window, out);\n        out.writeLong(timer.timestamp);\n    }\n    out.writeInt(processingTimeTimers.size());\n    for (Timer<K, W> timer : processingTimeTimersQueue) {\n        keySerializer.serialize(timer.key, out);\n        windowSerializer.serialize(timer.window, out);\n        out.writeLong(timer.timestamp);\n    }\n    taskState.setOperatorState(out.closeAndGetHandle());\n    return taskState;\n}", "lc": 0.22727272727272727, "pi": -0.14832535885167467, "ma": -0.2, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": -0.2479210711768851, "fo": 0.75, "r": -0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-1922_ccd574a4", "label": 1, "code": "@Override\npublic InputSplit getNextInputSplit() {\n    try {\n        final Future<Object> response = Patterns.ask(jobManager, new JobManagerMessages.RequestNextInputSplit(jobId, vertexId, executionID), timeout);\n        final Object result = Await.result(response, timeout.duration());\n        if (result == null) {\n            return null;\n        }\n        if (!(result instanceof JobManagerMessages.NextInputSplit)) {\n            throw new RuntimeException(\"RequestNextInputSplit requires a response of type \" + \"NextInputSplit. Instead response is of type \" + result.getClass() + \".\");\n        } else {\n            final JobManagerMessages.NextInputSplit nextInputSplit = (JobManagerMessages.NextInputSplit) result;\n            byte[] serializedData = nextInputSplit.splitData();\n            Object deserialized = InstantiationUtil.deserializeObject(serializedData, usercodeClassLoader);\n            return (InputSplit) deserialized;\n        }\n    } catch (Exception e) {\n        throw new RuntimeException(\"Requesting the next InputSplit failed.\", e);\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic InputSplit getNextInputSplit() {\n    try {\n        final Future<Object> response = Patterns.ask(jobManager, new JobManagerMessages.RequestNextInputSplit(jobId, vertexId, executionID), timeout);\n        final Object result = Await.result(response, timeout.duration());\n        if (result == null) {\n            return null;\n        }\n        if (!(result instanceof JobManagerMessages.NextInputSplit)) {\n            throw new RuntimeException(\"RequestNextInputSplit requires a response of type \" + \"NextInputSplit. Instead response is of type \" + result.getClass() + \".\");\n        } else {\n            final JobManagerMessages.NextInputSplit nextInputSplit = (JobManagerMessages.NextInputSplit) result;\n            byte[] serializedData = nextInputSplit.splitData();\n            Object deserialized = InstantiationUtil.deserializeObject(serializedData, usercodeClassLoader);\n            return (InputSplit) deserialized;\n        }\n    } catch (Exception e) {\n        throw new RuntimeException(\"Requesting the next InputSplit failed.\", e);\n    }\n}", "lc": 0.2727272727272727, "pi": 0.5071770334928228, "ma": 0.4, "nbd": 0.0, "ml": -0.16666666666666666, "d": 0.26388888888888884, "mi": -0.2885130373502466, "fo": 0.0, "r": -0.02631578947368421, "e": 0.35000547477855953}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4105_64656c98", "label": 1, "code": "/**\n *  Create a new response object which is used to store the markup generated by the child\n *  objects.\n *\n *  @param originalResponse\n *\n *  @return Response object. Must not be null\n */\nprotected BufferedWebResponse newResponse(final WebResponse originalResponse) {\n    return new BufferedWebResponse(originalResponse);\n}", "code_comment": "/**\n *  Create a new response object which is used to store the markup generated by the child\n *  objects.\n *\n *  @param originalResponse\n *\n *  @return Response object. Must not be null\n */\n", "code_no_comment": "protected BufferedWebResponse newResponse(final WebResponse originalResponse) {\n    return new BufferedWebResponse(originalResponse);\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.0606060606060603, "fo": -0.5, "r": 2.6052631578947367, "e": -0.16279340490885932}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-412_5594b2e0", "label": 1, "code": "private List<List<String>> groupFiles(List<String> files, int groups) {\n    List<List<String>> result = new ArrayList<List<String>>();\n    Iterator<String> iter = files.iterator();\n    for (int i = 0; i < groups && iter.hasNext(); i++) {\n        List<String> group = new ArrayList<String>();\n        for (int j = 0; j < Math.ceil(files.size() / (double) groups) && iter.hasNext(); j++) {\n            group.add(iter.next());\n        }\n        result.add(group);\n    }\n    return result;\n}", "code_comment": NaN, "code_no_comment": "private List<List<String>> groupFiles(List<String> files, int groups) {\n    List<List<String>> result = new ArrayList<List<String>>();\n    Iterator<String> iter = files.iterator();\n    for (int i = 0; i < groups && iter.hasNext(); i++) {\n        List<String> group = new ArrayList<String>();\n        for (int j = 0; j < Math.ceil(files.size() / (double) groups) && iter.hasNext(); j++) {\n            group.add(iter.next());\n        }\n        result.add(group);\n    }\n    return result;\n}", "lc": -0.09090909090909091, "pi": 0.1961722488038276, "ma": -0.2, "nbd": 0.0, "ml": 0.4166666666666667, "d": 0.6170634920634921, "mi": -0.013107822410148084, "fo": 0.16666666666666666, "r": -0.02631578947368421, "e": 0.5240642450856657}
{"project_name": "Closure", "project_version": 29, "label": 1, "code": "/**\n * Counts the number of direct (full) references to an object.\n * Specifically we check for references of the following type:\n * <pre>\n *   x;\n *   x.fn();\n * </pre>\n */\nprivate boolean isInlinableObject(List<Reference> refs) {\n    boolean ret = false;\n    for (Reference ref : refs) {\n        Node name = ref.getNode();\n        Node parent = ref.getParent();\n        Node gramps = ref.getGrandparent();\n        // \n        if (parent.isGetProp()) {\n            Preconditions.checkState(parent.getFirstChild() == name);\n            // A call target maybe using the object as a 'this' value.\n            if (gramps.isCall() && gramps.getFirstChild() == parent) {\n                return false;\n            }\n            // isn't a perfect algorithm, but it should catch most cases.\n            continue;\n        }\n        // Only rewrite VAR declarations or simple assignment statements\n        if (!isVarOrAssignExprLhs(name)) {\n            return false;\n        }\n        Node val = ref.getAssignedValue();\n        if (val == null) {\n            // A var with no assignment.\n            continue;\n        }\n        // We're looking for object literal assignments only.\n        if (!val.isObjectLit()) {\n            return false;\n        }\n        // Also, ES5 getters/setters aren't handled by this pass.\n        for (Node child = val.getFirstChild(); child != null; child = child.getNext()) {\n            if (child.isGetterDef() || child.isSetterDef()) {\n                // ES5 get/set not supported.\n                return false;\n            }\n            Node childVal = child.getFirstChild();\n            // will happen.\n            for (Reference t : refs) {\n                Node refNode = t.getParent();\n                while (!NodeUtil.isStatementBlock(refNode)) {\n                    if (refNode == childVal) {\n                        // There's a self-referential assignment\n                        return false;\n                    }\n                    refNode = refNode.getParent();\n                }\n            }\n        }\n        // We have found an acceptable object literal assignment. As\n        // long as there are no other assignments that mess things up,\n        // we can inline.\n        ret = true;\n    }\n    return ret;\n}", "code_comment": "/**\n * Counts the number of direct (full) references to an object.\n * Specifically we check for references of the following type:\n * <pre>\n *   x;\n *   x.fn();\n * </pre>\n */\n", "code_no_comment": "private boolean isInlinableObject(List<Reference> refs) {\n    boolean ret = false;\n    for (Reference ref : refs) {\n        Node name = ref.getNode();\n        Node parent = ref.getParent();\n        Node gramps = ref.getGrandparent();\n                if (parent.isGetProp()) {\n            Preconditions.checkState(parent.getFirstChild() == name);\n                        if (gramps.isCall() && gramps.getFirstChild() == parent) {\n                return false;\n            }\n                        continue;\n        }\n                if (!isVarOrAssignExprLhs(name)) {\n            return false;\n        }\n        Node val = ref.getAssignedValue();\n        if (val == null) {\n                        continue;\n        }\n                if (!val.isObjectLit()) {\n            return false;\n        }\n                for (Node child = val.getFirstChild(); child != null; child = child.getNext()) {\n            if (child.isGetterDef() || child.isSetterDef()) {\n                                return false;\n            }\n            Node childVal = child.getFirstChild();\n                        for (Reference t : refs) {\n                Node refNode = t.getParent();\n                while (!NodeUtil.isStatementBlock(refNode)) {\n                    if (refNode == childVal) {\n                                                return false;\n                    }\n                    refNode = refNode.getParent();\n                }\n            }\n        }\n                                ret = true;\n    }\n    return ret;\n}", "lc": 1.2727272727272727, "pi": 1.0334928229665072, "ma": 2.0, "nbd": 1.5, "ml": 1.6666666666666667, "d": 1.0634920634920635, "mi": -0.7482734319943621, "fo": 1.0833333333333333, "r": -0.02631578947368421, "e": 1.7045371506947202}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-738_f64b6a90", "label": 1, "code": "/**\n * Returns the natural logarithm of the beta function B(a, b).\n *\n * The implementation of this method is based on:\n * <ul>\n * <li><a href=\"http://mathworld.wolfram.com/BetaFunction.html\">\n * Beta Function</a>, equation (1).</li>\n * </ul>\n *\n * @param a Parameter {@code a}.\n * @param b Parameter {@code b}.\n * @param epsilon When the absolute value of the nth item in the\n * series is less than epsilon the approximation ceases to calculate\n * further elements in the series.\n * @param maxIterations Maximum number of \"iterations\" to complete.\n * @return log(B(a, b)).\n */\npublic static double logBeta(double a, double b, double epsilon, int maxIterations) {\n    double ret;\n    if (Double.isNaN(a) || Double.isNaN(b) || a <= 0.0 || b <= 0.0) {\n        ret = Double.NaN;\n    } else {\n        ret = Gamma.logGamma(a) + Gamma.logGamma(b) - Gamma.logGamma(a + b);\n    }\n    return ret;\n}", "code_comment": "/**\n * Returns the natural logarithm of the beta function B(a, b).\n *\n * The implementation of this method is based on:\n * <ul>\n * <li><a href=\"http://mathworld.wolfram.com/BetaFunction.html\">\n * Beta Function</a>, equation (1).</li>\n * </ul>\n *\n * @param a Parameter {@code a}.\n * @param b Parameter {@code b}.\n * @param epsilon When the absolute value of the nth item in the\n * series is less than epsilon the approximation ceases to calculate\n * further elements in the series.\n * @param maxIterations Maximum number of \"iterations\" to complete.\n * @return log(B(a, b)).\n */\n", "code_no_comment": "public static double logBeta(double a, double b, double epsilon, int maxIterations) {\n    double ret;\n    if (Double.isNaN(a) || Double.isNaN(b) || a <= 0.0 || b <= 0.0) {\n        ret = Double.NaN;\n    } else {\n        ret = Gamma.logGamma(a) + Gamma.logGamma(b) - Gamma.logGamma(a + b);\n    }\n    return ret;\n}", "lc": -0.22727272727272727, "pi": -0.15311004784689008, "ma": -0.4, "nbd": -0.5, "ml": 0.25, "d": 0.6111111111111112, "mi": 0.2076109936575051, "fo": -0.08333333333333333, "r": 0.21052631578947367, "e": 0.22524967871694235}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-217_46f62443", "label": 1, "code": "@Override\npublic void removeIterator(String tableName, String name, EnumSet<IteratorScope> scopes) throws AccumuloSecurityException, AccumuloException, TableNotFoundException {\n    Map<String, String> copy = new TreeMap<String, String>();\n    for (Entry<String, String> property : this.getProperties(tableName)) {\n        copy.put(property.getKey(), property.getValue());\n    }\n    for (IteratorScope scope : scopes) {\n        String root = String.format(\"%s%s.%s\", Property.TABLE_ITERATOR_PREFIX, scope.name().toLowerCase(), name);\n        for (Entry<String, String> property : copy.entrySet()) {\n            if (property.getKey().equals(root) || property.getKey().startsWith(root + \".opt.\"))\n                this.removeProperty(tableName, property.getKey());\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void removeIterator(String tableName, String name, EnumSet<IteratorScope> scopes) throws AccumuloSecurityException, AccumuloException, TableNotFoundException {\n    Map<String, String> copy = new TreeMap<String, String>();\n    for (Entry<String, String> property : this.getProperties(tableName)) {\n        copy.put(property.getKey(), property.getValue());\n    }\n    for (IteratorScope scope : scopes) {\n        String root = String.format(\"%s%s.%s\", Property.TABLE_ITERATOR_PREFIX, scope.name().toLowerCase(), name);\n        for (Entry<String, String> property : copy.entrySet()) {\n            if (property.getKey().equals(root) || property.getKey().startsWith(root + \".opt.\"))\n                this.removeProperty(tableName, property.getKey());\n        }\n    }\n}", "lc": 0.0, "pi": 0.7033492822966506, "ma": 0.2, "nbd": 0.0, "ml": 0.0, "d": 0.02579365079365077, "mi": -0.1213530655391118, "fo": 0.6666666666666666, "r": -0.02631578947368421, "e": 0.16114751358609516}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-2899_31aea2ad", "label": 0, "code": "// given a wal path, transform it to a recovery path\npublic static Path getRecoveryPath(VolumeManager fs, Path walPath) throws IOException {\n    if (walPath.depth() >= 3 && walPath.toUri().getScheme() != null) {\n        // its a fully qualified path\n        String uuid = walPath.getName();\n        // drop uuid\n        walPath = walPath.getParent();\n        // drop server\n        walPath = walPath.getParent();\n        if (!walPath.getName().equals(FileType.WAL.getDirectory()))\n            throw new IllegalArgumentException(\"Bad path \" + walPath);\n        // drop wal\n        walPath = walPath.getParent();\n        walPath = new Path(walPath, FileType.RECOVERY.getDirectory());\n        walPath = new Path(walPath, uuid);\n        return walPath;\n    }\n    throw new IllegalArgumentException(\"Bad path \" + walPath);\n}", "code_comment": NaN, "code_no_comment": "public static Path getRecoveryPath(VolumeManager fs, Path walPath) throws IOException {\n    if (walPath.depth() >= 3 && walPath.toUri().getScheme() != null) {\n                String uuid = walPath.getName();\n                walPath = walPath.getParent();\n                walPath = walPath.getParent();\n        if (!walPath.getName().equals(FileType.WAL.getDirectory()))\n            throw new IllegalArgumentException(\"Bad path \" + walPath);\n                walPath = walPath.getParent();\n        walPath = new Path(walPath, FileType.RECOVERY.getDirectory());\n        walPath = new Path(walPath, uuid);\n        return walPath;\n    }\n    throw new IllegalArgumentException(\"Bad path \" + walPath);\n}", "lc": 0.0, "pi": 0.13875598086124383, "ma": 0.2, "nbd": -0.5, "ml": 0.16666666666666666, "d": 0.9543650793650794, "mi": -0.09908386187455955, "fo": 0.4166666666666667, "r": -0.02631578947368421, "e": 0.7758349037303411}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-94_d8af1c93", "label": 1, "code": "/**\n * Resolves the specified variable. This implementation will try to extract\n * a variable prefix from the given variable name (the first colon (':') is\n * used as prefix separator). It then passes the name of the variable with\n * the prefix stripped to the lookup object registered for this prefix. If\n * no prefix can be found or if the associated lookup object cannot resolve\n * this variable, the default lookup object will be used.\n *\n * @param event The current LogEvent or null.\n * @param var the name of the variable whose value is to be looked up\n * @return the value of this variable or <b>null</b> if it cannot be\n * resolved\n */\npublic String lookup(LogEvent event, String var) {\n    if (var == null) {\n        return null;\n    }\n    int prefixPos = var.indexOf(PREFIX_SEPARATOR);\n    if (prefixPos >= 0) {\n        String prefix = var.substring(0, prefixPos);\n        String name = var.substring(prefixPos + 1);\n        StrLookup lookup = lookups.get(prefix);\n        String value = null;\n        if (lookup != null) {\n            value = event == null ? lookup.lookup(name) : lookup.lookup(event, name);\n        }\n        if (value != null) {\n            return value;\n        }\n        var = var.substring(prefixPos);\n    }\n    if (defaultLookup != null) {\n        return event == null ? defaultLookup.lookup(var) : defaultLookup.lookup(event, var);\n    }\n    return null;\n}", "code_comment": "/**\n * Resolves the specified variable. This implementation will try to extract\n * a variable prefix from the given variable name (the first colon (':') is\n * used as prefix separator). It then passes the name of the variable with\n * the prefix stripped to the lookup object registered for this prefix. If\n * no prefix can be found or if the associated lookup object cannot resolve\n * this variable, the default lookup object will be used.\n *\n * @param event The current LogEvent or null.\n * @param var the name of the variable whose value is to be looked up\n * @return the value of this variable or <b>null</b> if it cannot be\n * resolved\n */\n", "code_no_comment": "public String lookup(LogEvent event, String var) {\n    if (var == null) {\n        return null;\n    }\n    int prefixPos = var.indexOf(PREFIX_SEPARATOR);\n    if (prefixPos >= 0) {\n        String prefix = var.substring(0, prefixPos);\n        String name = var.substring(prefixPos + 1);\n        StrLookup lookup = lookups.get(prefix);\n        String value = null;\n        if (lookup != null) {\n            value = event == null ? lookup.lookup(name) : lookup.lookup(event, name);\n        }\n        if (value != null) {\n            return value;\n        }\n        var = var.substring(prefixPos);\n    }\n    if (defaultLookup != null) {\n        return event == null ? defaultLookup.lookup(var) : defaultLookup.lookup(event, var);\n    }\n    return null;\n}", "lc": 0.4090909090909091, "pi": 0.04306220095693773, "ma": 0.8, "nbd": 0.0, "ml": 0.6666666666666666, "d": 0.9642857142857143, "mi": -0.3770260747004932, "fo": 0.25, "r": -0.02631578947368421, "e": 1.0134564294070525}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-209_397f86f6", "label": 1, "code": "private boolean matches(Matcher matcher, byte[] data, int offset, int len) {\n    if (matcher != null) {\n        babcs.set(data, offset, len);\n        matcher.reset(babcs);\n        return matcher.matches();\n    }\n    return !orFields;\n}", "code_comment": NaN, "code_no_comment": "private boolean matches(Matcher matcher, byte[] data, int offset, int len) {\n    if (matcher != null) {\n        babcs.set(data, offset, len);\n        matcher.reset(babcs);\n        return matcher.matches();\n    }\n    return !orFields;\n}", "lc": -0.2727272727272727, "pi": 0.06220095693779899, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": -0.03373015873015876, "mi": 0.3660324171952078, "fo": -0.25, "r": 0.0, "e": -0.0984330607469903}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4251_53bcb78d", "label": 1, "code": "public static void set() {\n    Session session = Session.get();\n    session.bind();\n    InterceptData data = new InterceptData();\n    Request request = RequestCycle.get().getRequest();\n    data.originalUrl = request.getOriginalUrl();\n    data.postParameters = new HashMap<String, List<StringValue>>();\n    for (String s : request.getPostParameters().getParameterNames()) {\n        data.postParameters.put(s, new ArrayList<StringValue>(request.getPostParameters().getParameterValues(s)));\n    }\n    data.continueOk = false;\n    session.setMetaData(key, data);\n}", "code_comment": NaN, "code_no_comment": "public static void set() {\n    Session session = Session.get();\n    session.bind();\n    InterceptData data = new InterceptData();\n    Request request = RequestCycle.get().getRequest();\n    data.originalUrl = request.getOriginalUrl();\n    data.postParameters = new HashMap<String, List<StringValue>>();\n    for (String s : request.getPostParameters().getParameterNames()) {\n        data.postParameters.put(s, new ArrayList<StringValue>(request.getPostParameters().getParameterValues(s)));\n    }\n    data.continueOk = false;\n    session.setMetaData(key, data);\n}", "lc": -0.045454545454545456, "pi": -0.5215311004784691, "ma": -0.4, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": -0.024665257223396752, "fo": 0.4166666666666667, "r": -0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1044_9396979b", "label": 0, "code": "public String getViolationDescription(short violationCode) {\n    switch(violationCode) {\n        case 1:\n            return \"data file size must be a non-negative integer\";\n        case 2:\n            return \"Invalid column name given.\";\n        case 3:\n            return \"Prev end row is greater than or equal to end row.\";\n        case 4:\n            return \"Invalid metadata row format\";\n        case 5:\n            return \"Row can not be less than \" + Constants.METADATA_TABLE_ID;\n        case 6:\n            return \"Empty values are not allowed for any \" + Constants.METADATA_TABLE_NAME + \" column\";\n        case 7:\n            return \"Lock not held in zookeeper by writer\";\n    }\n    return null;\n}", "code_comment": NaN, "code_no_comment": "public String getViolationDescription(short violationCode) {\n    switch(violationCode) {\n        case 1:\n            return \"data file size must be a non-negative integer\";\n        case 2:\n            return \"Invalid column name given.\";\n        case 3:\n            return \"Prev end row is greater than or equal to end row.\";\n        case 4:\n            return \"Invalid metadata row format\";\n        case 5:\n            return \"Row can not be less than \" + Constants.METADATA_TABLE_ID;\n        case 6:\n            return \"Empty values are not allowed for any \" + Constants.METADATA_TABLE_NAME + \" column\";\n        case 7:\n            return \"Lock not held in zookeeper by writer\";\n    }\n    return null;\n}", "lc": 0.22727272727272727, "pi": 0.43062200956937796, "ma": 0.8, "nbd": 0.0, "ml": 0.25, "d": -0.3650793650793651, "mi": -0.12529950669485532, "fo": -0.5, "r": 0.0, "e": -0.16279340490885932}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4777_eccb3b11", "label": 3, "code": "/**\n *  Write a reference to a javascript file to the response object\n *\n *  @param response\n *             The HTTP response\n *  @param url\n *             The javascript file URL\n *  @param id\n *             Unique identifier of element\n *  @param defer\n *             specifies that the execution of a script should be deferred (delayed) until after\n *             the page has been loaded.\n *  @param charset\n *             a non null value specifies the charset attribute of the script tag\n */\npublic static void writeJavaScriptUrl(final Response response, final CharSequence url, final String id, boolean defer, String charset) {\n    response.write(\"<script type=\\\"text/javascript\\\" \");\n    if (id != null) {\n        response.write(\"id=\\\"\" + Strings.escapeMarkup(id) + \"\\\" \");\n    }\n    if (defer) {\n        response.write(\"defer=\\\"defer\\\" \");\n    }\n    if (charset != null) {\n        response.write(\"charset=\\\"\" + Strings.escapeMarkup(charset) + \"\\\" \");\n    }\n    response.write(\"src=\\\"\");\n    response.write(Strings.escapeMarkup(url));\n    response.write(\"\\\"></script>\");\n    response.write(\"\\n\");\n}", "code_comment": "/**\n *  Write a reference to a javascript file to the response object\n *\n *  @param response\n *             The HTTP response\n *  @param url\n *             The javascript file URL\n *  @param id\n *             Unique identifier of element\n *  @param defer\n *             specifies that the execution of a script should be deferred (delayed) until after\n *             the page has been loaded.\n *  @param charset\n *             a non null value specifies the charset attribute of the script tag\n */\n", "code_no_comment": "public static void writeJavaScriptUrl(final Response response, final CharSequence url, final String id, boolean defer, String charset) {\n    response.write(\"<script type=\\\"text/javascript\\\" \");\n    if (id != null) {\n        response.write(\"id=\\\"\" + Strings.escapeMarkup(id) + \"\\\" \");\n    }\n    if (defer) {\n        response.write(\"defer=\\\"defer\\\" \");\n    }\n    if (charset != null) {\n        response.write(\"charset=\\\"\" + Strings.escapeMarkup(charset) + \"\\\" \");\n    }\n    response.write(\"src=\\\"\");\n    response.write(Strings.escapeMarkup(url));\n    response.write(\"\\\"></script>\");\n    response.write(\"\\n\");\n}", "lc": 0.09090909090909091, "pi": -0.368421052631579, "ma": 0.0, "nbd": -0.5, "ml": 0.08333333333333333, "d": 0.0853174603174603, "mi": -0.1224806201550387, "fo": 0.4166666666666667, "r": -0.02631578947368421, "e": 0.09663041786967722}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-2437_a41bc8cc", "label": 3, "code": "/**\n *  Checks if the given field is a valid pojo field:\n *  - it is public\n *  OR\n *   - there are getter and setter methods for the field.\n *\n *  @param f field to check\n *  @param clazz class of field\n *  @param typeHierarchy type hierarchy for materializing generic types\n */\nprivate boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy) {\n    if (Modifier.isPublic(f.getModifiers())) {\n        return true;\n    } else {\n        boolean hasGetter = false, hasSetter = false;\n        final String fieldNameLow = f.getName().toLowerCase();\n        Type fieldType = f.getGenericType();\n        TypeVariable<?> fieldTypeGeneric = null;\n        if (fieldType instanceof TypeVariable) {\n            fieldTypeGeneric = (TypeVariable<?>) fieldType;\n            fieldType = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) fieldType);\n        }\n        for (Method m : clazz.getMethods()) {\n            // check for getter\n            if (// The name should be \"get<FieldName>\" or \"<fieldName>\" (for scala) or \"is<fieldName>\" for boolean fields.\n            (m.getName().toLowerCase().equals(\"get\" + fieldNameLow) || m.getName().toLowerCase().equals(\"is\" + fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow)) && // no arguments for the getter\n            m.getParameterTypes().length == 0 && // return type is same as field type (or the generic variant of it)\n            (m.getGenericReturnType().equals(fieldType) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)))) {\n                if (hasGetter) {\n                    throw new IllegalStateException(\"Detected more than one getter\");\n                }\n                hasGetter = true;\n            }\n            // check for setters (<FieldName>_$eq for scala)\n            if ((m.getName().toLowerCase().equals(\"set\" + fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow + \"_$eq\")) && // one parameter of the field's type\n            m.getParameterTypes().length == 1 && (m.getGenericParameterTypes()[0].equals(fieldType) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric))) && // return type is void.\n            m.getReturnType().equals(Void.TYPE)) {\n                if (hasSetter) {\n                    throw new IllegalStateException(\"Detected more than one setter\");\n                }\n                hasSetter = true;\n            }\n        }\n        if (hasGetter && hasSetter) {\n            return true;\n        } else {\n            if (!hasGetter) {\n                LOG.debug(\"Class \" + clazz + \" does not contain a getter for field \" + f.getName());\n            }\n            if (!hasSetter) {\n                LOG.debug(\"Class \" + clazz + \" does not contain a setter for field \" + f.getName());\n            }\n            return false;\n        }\n    }\n}", "code_comment": "/**\n *  Checks if the given field is a valid pojo field:\n *  - it is public\n *  OR\n *   - there are getter and setter methods for the field.\n *\n *  @param f field to check\n *  @param clazz class of field\n *  @param typeHierarchy type hierarchy for materializing generic types\n */\n", "code_no_comment": "private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy) {\n    if (Modifier.isPublic(f.getModifiers())) {\n        return true;\n    } else {\n        boolean hasGetter = false, hasSetter = false;\n        final String fieldNameLow = f.getName().toLowerCase();\n        Type fieldType = f.getGenericType();\n        TypeVariable<?> fieldTypeGeneric = null;\n        if (fieldType instanceof TypeVariable) {\n            fieldTypeGeneric = (TypeVariable<?>) fieldType;\n            fieldType = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) fieldType);\n        }\n        for (Method m : clazz.getMethods()) {\n                        if (            (m.getName().toLowerCase().equals(\"get\" + fieldNameLow) || m.getName().toLowerCase().equals(\"is\" + fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow)) &&             m.getParameterTypes().length == 0 &&             (m.getGenericReturnType().equals(fieldType) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)))) {\n                if (hasGetter) {\n                    throw new IllegalStateException(\"Detected more than one getter\");\n                }\n                hasGetter = true;\n            }\n                        if ((m.getName().toLowerCase().equals(\"set\" + fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow + \"_$eq\")) &&             m.getParameterTypes().length == 1 && (m.getGenericParameterTypes()[0].equals(fieldType) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric))) &&             m.getReturnType().equals(Void.TYPE)) {\n                if (hasSetter) {\n                    throw new IllegalStateException(\"Detected more than one setter\");\n                }\n                hasSetter = true;\n            }\n        }\n        if (hasGetter && hasSetter) {\n            return true;\n        } else {\n            if (!hasGetter) {\n                LOG.debug(\"Class \" + clazz + \" does not contain a getter for field \" + f.getName());\n            }\n            if (!hasSetter) {\n                LOG.debug(\"Class \" + clazz + \" does not contain a setter for field \" + f.getName());\n            }\n            return false;\n        }\n    }\n}", "lc": 1.3636363636363635, "pi": 0.7033492822966506, "ma": 1.8, "nbd": 1.0, "ml": 2.9166666666666665, "d": 1.2460317460317458, "mi": -0.8474982381959123, "fo": 2.6666666666666665, "r": -0.02631578947368421, "e": 3.5861367081020954}
{"project_name": "Math", "project_version": 6, "label": 1, "code": "/**\n * {@inheritDoc}\n */\n@Override\nprotected PointValuePair doOptimize() {\n    checkParameters();\n    // Indirect call to \"computeObjectiveValue\" in order to update the\n    // evaluations counter.\n    final MultivariateFunction evalFunc = new MultivariateFunction() {\n\n        public double value(double[] point) {\n            return computeObjectiveValue(point);\n        }\n    };\n    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n    final Comparator<PointValuePair> comparator = new Comparator<PointValuePair>() {\n\n        public int compare(final PointValuePair o1, final PointValuePair o2) {\n            final double v1 = o1.getValue();\n            final double v2 = o2.getValue();\n            return isMinim ? Double.compare(v1, v2) : Double.compare(v2, v1);\n        }\n    };\n    // Initialize search.\n    simplex.build(getStartPoint());\n    simplex.evaluate(evalFunc, comparator);\n    PointValuePair[] previous = null;\n    int iteration = 0;\n    final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();\n    while (true) {\n        if (iteration > 0) {\n            boolean converged = true;\n            for (int i = 0; i < simplex.getSize(); i++) {\n                PointValuePair prev = previous[i];\n                converged = converged && checker.converged(iteration, prev, simplex.getPoint(i));\n            }\n            if (converged) {\n                // We have found an optimum.\n                return simplex.getPoint(0);\n            }\n        }\n        // We still need to search.\n        previous = simplex.getPoints();\n        simplex.iterate(evalFunc, comparator);\n        ++iteration;\n    }\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "@Override\nprotected PointValuePair doOptimize() {\n    checkParameters();\n            final MultivariateFunction evalFunc = new MultivariateFunction() {\n\n        public double value(double[] point) {\n            return computeObjectiveValue(point);\n        }\n    };\n    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n    final Comparator<PointValuePair> comparator = new Comparator<PointValuePair>() {\n\n        public int compare(final PointValuePair o1, final PointValuePair o2) {\n            final double v1 = o1.getValue();\n            final double v2 = o2.getValue();\n            return isMinim ? Double.compare(v1, v2) : Double.compare(v2, v1);\n        }\n    };\n        simplex.build(getStartPoint());\n    simplex.evaluate(evalFunc, comparator);\n    PointValuePair[] previous = null;\n    int iteration = 0;\n    final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();\n    while (true) {\n        if (iteration > 0) {\n            boolean converged = true;\n            for (int i = 0; i < simplex.getSize(); i++) {\n                PointValuePair prev = previous[i];\n                converged = converged && checker.converged(iteration, prev, simplex.getPoint(i));\n            }\n            if (converged) {\n                                return simplex.getPoint(0);\n            }\n        }\n                previous = simplex.getPoints();\n        simplex.iterate(evalFunc, comparator);\n        ++iteration;\n    }\n}", "lc": 1.0454545454545454, "pi": 0.6937799043062203, "ma": 0.4, "nbd": 0.5, "ml": 0.4166666666666667, "d": 0.9523809523809523, "mi": -0.6541226215644819, "fo": 0.9166666666666666, "r": -0.02631578947368421, "e": 1.7528996156129155}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1883_9c2421ed", "label": 1, "code": "public void releaseRecoveryLock(int clusterId) {\n    UpdateOp update = new UpdateOp(Integer.toString(clusterId), true);\n    update.set(ClusterNodeInfo.REV_RECOVERY_LOCK, null);\n    store.createOrUpdate(Collection.CLUSTER_NODES, update);\n}", "code_comment": NaN, "code_no_comment": "public void releaseRecoveryLock(int clusterId) {\n    UpdateOp update = new UpdateOp(Integer.toString(clusterId), true);\n    update.set(ClusterNodeInfo.REV_RECOVERY_LOCK, null);\n    store.createOrUpdate(Collection.CLUSTER_NODES, update);\n}", "lc": -0.4090909090909091, "pi": -0.49282296650717716, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.5833685694150811, "fo": -0.25, "r": 0.0, "e": -0.16279340490885932}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1977_4bfbfcdd", "label": 1, "code": "// ------------------------------------------------------------< Object >--\npublic String toString() {\n    StringBuilder buffer = new StringBuilder(\"property \");\n    buffer.append(name);\n    if (values == null) {\n        buffer.append(\" IS NOT NULL\");\n    } else if (values.isEmpty()) {\n        buffer.append(\" NOT APPLICABLE\");\n    } else if (values.size() == 1) {\n        buffer.append(\" = \");\n        buffer.append(values.iterator().next());\n    } else {\n        buffer.append(\" IN (\");\n        boolean comma = false;\n        for (String value : values) {\n            if (comma) {\n                buffer.append(\", \");\n            }\n            buffer.append(value);\n            comma = true;\n        }\n        buffer.append(\")\");\n    }\n    return buffer.toString();\n}", "code_comment": NaN, "code_no_comment": "public String toString() {\n    StringBuilder buffer = new StringBuilder(\"property \");\n    buffer.append(name);\n    if (values == null) {\n        buffer.append(\" IS NOT NULL\");\n    } else if (values.isEmpty()) {\n        buffer.append(\" NOT APPLICABLE\");\n    } else if (values.size() == 1) {\n        buffer.append(\" = \");\n        buffer.append(values.iterator().next());\n    } else {\n        buffer.append(\" IN (\");\n        boolean comma = false;\n        for (String value : values) {\n            if (comma) {\n                buffer.append(\", \");\n            }\n            buffer.append(value);\n            comma = true;\n        }\n        buffer.append(\")\");\n    }\n    return buffer.toString();\n}", "lc": 0.45454545454545453, "pi": 0.42105263157894735, "ma": 0.4, "nbd": 1.5, "ml": 0.25, "d": 0.05555555555555556, "mi": -0.3364341085271318, "fo": 0.6666666666666666, "r": -0.02631578947368421, "e": 0.10675472415760442}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-3424_27d4ee21", "label": 1, "code": "// Not for client use\npublic boolean config(String... args) {\n    ShellOptionsJC options = new ShellOptionsJC();\n    JCommander jc = new JCommander();\n    jc.setProgramName(\"accumulo shell\");\n    jc.addObject(options);\n    try {\n        jc.parse(args);\n    } catch (ParameterException e) {\n        configError = true;\n    }\n    if (options.isHelpEnabled()) {\n        configError = true;\n    }\n    if (!configError && options.getUnrecognizedOptions() != null) {\n        configError = true;\n        logError(\"Unrecognized Options: \" + options.getUnrecognizedOptions().toString());\n    }\n    if (configError) {\n        jc.usage();\n        return true;\n    }\n    setDebugging(options.isDebugEnabled());\n    authTimeout = TimeUnit.MINUTES.toNanos(options.getAuthTimeout());\n    disableAuthTimeout = options.isAuthTimeoutDisabled();\n    // get the options that were parsed\n    String user = options.getUsername();\n    String password = options.getPassword();\n    tabCompletion = !options.isTabCompletionDisabled();\n    // Use a fake (Mock), ZK, or HdfsZK Accumulo instance\n    setInstance(options);\n    // AuthenticationToken options\n    token = options.getAuthenticationToken();\n    Map<String, String> loginOptions = options.getTokenProperties();\n    // process default parameters if unspecified\n    try {\n        boolean hasToken = (token != null);\n        boolean hasTokenOptions = !loginOptions.isEmpty();\n        if (hasToken && password != null) {\n            throw new ParameterException(\"Can not supply '--pass' option with '--tokenClass' option\");\n        }\n        Runtime.getRuntime().addShutdownHook(new Thread() {\n\n            @Override\n            public void run() {\n                reader.getTerminal().setEchoEnabled(true);\n            }\n        });\n        // Need either both a token and options, or neither, but not just one.\n        if (hasToken != hasTokenOptions) {\n            throw new ParameterException(\"Must supply either both or neither of '--tokenClass' and '--tokenProperty'\");\n        } else if (hasToken) {\n            // implied hasTokenOptions\n            // Fully qualified name so we don't shadow java.util.Properties\n            org.apache.accumulo.core.client.security.tokens.AuthenticationToken.Properties props;\n            // and line wrap it because the package name is so long\n            props = new org.apache.accumulo.core.client.security.tokens.AuthenticationToken.Properties();\n            props.putAllStrings(loginOptions);\n            token.init(props);\n        } else {\n            // Read password if the user explicitly asked for it, or didn't specify anything at all\n            if (\"stdin\".equals(password) || password == null) {\n                password = reader.readLine(\"Password: \", '*');\n            }\n            if (password == null) {\n                // User cancel, e.g. Ctrl-D pressed\n                throw new ParameterException(\"No password or token option supplied\");\n            } else {\n                this.token = new PasswordToken(password);\n            }\n        }\n        if (!options.isFake()) {\n            ZooReader zr = new ZooReader(instance.getZooKeepers(), instance.getZooKeepersSessionTimeOut());\n            DistributedTrace.enable(instance, zr, \"shell\", InetAddress.getLocalHost().getHostName());\n        }\n        this.setTableName(\"\");\n        this.principal = user;\n        connector = instance.getConnector(this.principal, token);\n    } catch (Exception e) {\n        printException(e);\n        configError = true;\n    }\n    // decide whether to execute commands from a file and quit\n    if (options.getExecFile() != null) {\n        execFile = options.getExecFile();\n        verbose = false;\n    } else if (options.getExecFileVerbose() != null) {\n        execFile = options.getExecFileVerbose();\n        verbose = true;\n    }\n    execCommand = options.getExecCommand();\n    if (execCommand != null) {\n        verbose = false;\n    }\n    rootToken = new Token();\n    Command[] dataCommands = { new DeleteCommand(), new DeleteManyCommand(), new DeleteRowsCommand(), new EGrepCommand(), new FormatterCommand(), new InterpreterCommand(), new GrepCommand(), new ImportDirectoryCommand(), new InsertCommand(), new MaxRowCommand(), new ScanCommand() };\n    Command[] debuggingCommands = { new ClasspathCommand(), new DebugCommand(), new ListScansCommand(), new ListCompactionsCommand(), new TraceCommand(), new PingCommand() };\n    Command[] execCommands = { new ExecfileCommand(), new HistoryCommand(), new ExtensionCommand(), new ScriptCommand() };\n    Command[] exitCommands = { new ByeCommand(), new ExitCommand(), new QuitCommand() };\n    Command[] helpCommands = { new AboutCommand(), new HelpCommand(), new InfoCommand(), new QuestionCommand() };\n    Command[] iteratorCommands = { new DeleteIterCommand(), new DeleteScanIterCommand(), new ListIterCommand(), new SetIterCommand(), new SetScanIterCommand(), new SetShellIterCommand(), new ListShellIterCommand(), new DeleteShellIterCommand() };\n    Command[] otherCommands = { new HiddenCommand() };\n    Command[] permissionsCommands = { new GrantCommand(), new RevokeCommand(), new SystemPermissionsCommand(), new TablePermissionsCommand(), new UserPermissionsCommand(), new NamespacePermissionsCommand() };\n    Command[] stateCommands = { new AuthenticateCommand(), new ClsCommand(), new ClearCommand(), new FateCommand(), new NoTableCommand(), new SleepCommand(), new TableCommand(), new UserCommand(), new WhoAmICommand() };\n    Command[] tableCommands = { new CloneTableCommand(), new ConfigCommand(), new CreateTableCommand(), new DeleteTableCommand(), new DropTableCommand(), new DUCommand(), new ExportTableCommand(), new ImportTableCommand(), new OfflineCommand(), new OnlineCommand(), new RenameTableCommand(), new TablesCommand(), new NamespacesCommand(), new CreateNamespaceCommand(), new DeleteNamespaceCommand(), new RenameNamespaceCommand() };\n    Command[] tableControlCommands = { new AddSplitsCommand(), new CompactCommand(), new ConstraintCommand(), new FlushCommand(), new GetGroupsCommand(), new GetSplitsCommand(), new MergeCommand(), new SetGroupsCommand() };\n    Command[] userCommands = { new AddAuthsCommand(), new CreateUserCommand(), new DeleteUserCommand(), new DropUserCommand(), new GetAuthsCommand(), new PasswdCommand(), new SetAuthsCommand(), new UsersCommand() };\n    commandGrouping.put(\"-- Writing, Reading, and Removing Data --\", dataCommands);\n    commandGrouping.put(\"-- Debugging Commands -------------------\", debuggingCommands);\n    commandGrouping.put(\"-- Shell Execution Commands -------------\", execCommands);\n    commandGrouping.put(\"-- Exiting Commands ---------------------\", exitCommands);\n    commandGrouping.put(\"-- Help Commands ------------------------\", helpCommands);\n    commandGrouping.put(\"-- Iterator Configuration ---------------\", iteratorCommands);\n    commandGrouping.put(\"-- Permissions Administration Commands --\", permissionsCommands);\n    commandGrouping.put(\"-- Shell State Commands -----------------\", stateCommands);\n    commandGrouping.put(\"-- Table Administration Commands --------\", tableCommands);\n    commandGrouping.put(\"-- Table Control Commands ---------------\", tableControlCommands);\n    commandGrouping.put(\"-- User Administration Commands ---------\", userCommands);\n    for (Command[] cmds : commandGrouping.values()) {\n        for (Command cmd : cmds) commandFactory.put(cmd.getName(), cmd);\n    }\n    for (Command cmd : otherCommands) {\n        commandFactory.put(cmd.getName(), cmd);\n    }\n    return configError;\n}", "code_comment": NaN, "code_no_comment": "public boolean config(String... args) {\n    ShellOptionsJC options = new ShellOptionsJC();\n    JCommander jc = new JCommander();\n    jc.setProgramName(\"accumulo shell\");\n    jc.addObject(options);\n    try {\n        jc.parse(args);\n    } catch (ParameterException e) {\n        configError = true;\n    }\n    if (options.isHelpEnabled()) {\n        configError = true;\n    }\n    if (!configError && options.getUnrecognizedOptions() != null) {\n        configError = true;\n        logError(\"Unrecognized Options: \" + options.getUnrecognizedOptions().toString());\n    }\n    if (configError) {\n        jc.usage();\n        return true;\n    }\n    setDebugging(options.isDebugEnabled());\n    authTimeout = TimeUnit.MINUTES.toNanos(options.getAuthTimeout());\n    disableAuthTimeout = options.isAuthTimeoutDisabled();\n        String user = options.getUsername();\n    String password = options.getPassword();\n    tabCompletion = !options.isTabCompletionDisabled();\n        setInstance(options);\n        token = options.getAuthenticationToken();\n    Map<String, String> loginOptions = options.getTokenProperties();\n        try {\n        boolean hasToken = (token != null);\n        boolean hasTokenOptions = !loginOptions.isEmpty();\n        if (hasToken && password != null) {\n            throw new ParameterException(\"Can not supply '--pass' option with '--tokenClass' option\");\n        }\n        Runtime.getRuntime().addShutdownHook(new Thread() {\n\n            @Override\n            public void run() {\n                reader.getTerminal().setEchoEnabled(true);\n            }\n        });\n                if (hasToken != hasTokenOptions) {\n            throw new ParameterException(\"Must supply either both or neither of '--tokenClass' and '--tokenProperty'\");\n        } else if (hasToken) {\n                                    org.apache.accumulo.core.client.security.tokens.AuthenticationToken.Properties props;\n                        props = new org.apache.accumulo.core.client.security.tokens.AuthenticationToken.Properties();\n            props.putAllStrings(loginOptions);\n            token.init(props);\n        } else {\n                        if (\"stdin\".equals(password) || password == null) {\n                password = reader.readLine(\"Password: \", '*');\n            }\n            if (password == null) {\n                                throw new ParameterException(\"No password or token option supplied\");\n            } else {\n                this.token = new PasswordToken(password);\n            }\n        }\n        if (!options.isFake()) {\n            ZooReader zr = new ZooReader(instance.getZooKeepers(), instance.getZooKeepersSessionTimeOut());\n            DistributedTrace.enable(instance, zr, \"shell\", InetAddress.getLocalHost().getHostName());\n        }\n        this.setTableName(\"\");\n        this.principal = user;\n        connector = instance.getConnector(this.principal, token);\n    } catch (Exception e) {\n        printException(e);\n        configError = true;\n    }\n        if (options.getExecFile() != null) {\n        execFile = options.getExecFile();\n        verbose = false;\n    } else if (options.getExecFileVerbose() != null) {\n        execFile = options.getExecFileVerbose();\n        verbose = true;\n    }\n    execCommand = options.getExecCommand();\n    if (execCommand != null) {\n        verbose = false;\n    }\n    rootToken = new Token();\n    Command[] dataCommands = { new DeleteCommand(), new DeleteManyCommand(), new DeleteRowsCommand(), new EGrepCommand(), new FormatterCommand(), new InterpreterCommand(), new GrepCommand(), new ImportDirectoryCommand(), new InsertCommand(), new MaxRowCommand(), new ScanCommand() };\n    Command[] debuggingCommands = { new ClasspathCommand(), new DebugCommand(), new ListScansCommand(), new ListCompactionsCommand(), new TraceCommand(), new PingCommand() };\n    Command[] execCommands = { new ExecfileCommand(), new HistoryCommand(), new ExtensionCommand(), new ScriptCommand() };\n    Command[] exitCommands = { new ByeCommand(), new ExitCommand(), new QuitCommand() };\n    Command[] helpCommands = { new AboutCommand(), new HelpCommand(), new InfoCommand(), new QuestionCommand() };\n    Command[] iteratorCommands = { new DeleteIterCommand(), new DeleteScanIterCommand(), new ListIterCommand(), new SetIterCommand(), new SetScanIterCommand(), new SetShellIterCommand(), new ListShellIterCommand(), new DeleteShellIterCommand() };\n    Command[] otherCommands = { new HiddenCommand() };\n    Command[] permissionsCommands = { new GrantCommand(), new RevokeCommand(), new SystemPermissionsCommand(), new TablePermissionsCommand(), new UserPermissionsCommand(), new NamespacePermissionsCommand() };\n    Command[] stateCommands = { new AuthenticateCommand(), new ClsCommand(), new ClearCommand(), new FateCommand(), new NoTableCommand(), new SleepCommand(), new TableCommand(), new UserCommand(), new WhoAmICommand() };\n    Command[] tableCommands = { new CloneTableCommand(), new ConfigCommand(), new CreateTableCommand(), new DeleteTableCommand(), new DropTableCommand(), new DUCommand(), new ExportTableCommand(), new ImportTableCommand(), new OfflineCommand(), new OnlineCommand(), new RenameTableCommand(), new TablesCommand(), new NamespacesCommand(), new CreateNamespaceCommand(), new DeleteNamespaceCommand(), new RenameNamespaceCommand() };\n    Command[] tableControlCommands = { new AddSplitsCommand(), new CompactCommand(), new ConstraintCommand(), new FlushCommand(), new GetGroupsCommand(), new GetSplitsCommand(), new MergeCommand(), new SetGroupsCommand() };\n    Command[] userCommands = { new AddAuthsCommand(), new CreateUserCommand(), new DeleteUserCommand(), new DropUserCommand(), new GetAuthsCommand(), new PasswdCommand(), new SetAuthsCommand(), new UsersCommand() };\n    commandGrouping.put(\"-- Writing, Reading, and Removing Data --\", dataCommands);\n    commandGrouping.put(\"-- Debugging Commands -------------------\", debuggingCommands);\n    commandGrouping.put(\"-- Shell Execution Commands -------------\", execCommands);\n    commandGrouping.put(\"-- Exiting Commands ---------------------\", exitCommands);\n    commandGrouping.put(\"-- Help Commands ------------------------\", helpCommands);\n    commandGrouping.put(\"-- Iterator Configuration ---------------\", iteratorCommands);\n    commandGrouping.put(\"-- Permissions Administration Commands --\", permissionsCommands);\n    commandGrouping.put(\"-- Shell State Commands -----------------\", stateCommands);\n    commandGrouping.put(\"-- Table Administration Commands --------\", tableCommands);\n    commandGrouping.put(\"-- Table Control Commands ---------------\", tableControlCommands);\n    commandGrouping.put(\"-- User Administration Commands ---------\", userCommands);\n    for (Command[] cmds : commandGrouping.values()) {\n        for (Command cmd : cmds) commandFactory.put(cmd.getName(), cmd);\n    }\n    for (Command cmd : otherCommands) {\n        commandFactory.put(cmd.getName(), cmd);\n    }\n    return configError;\n}", "lc": 4.5, "pi": 0.23923444976076558, "ma": 3.4, "nbd": 1.0, "ml": 1.75, "d": 0.648809523809524, "mi": -1.5085271317829454, "fo": 4.416666666666667, "r": -0.02631578947368421, "e": 7.808281322937017}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4686_89184b79", "label": 1, "code": "private void resolvePageInstance(Integer pageId, Class<? extends IRequestablePage> pageClass, PageParameters pageParameters, Integer renderCount) {\n    IRequestablePage page = null;\n    boolean freshCreated = false;\n    if (pageId != null) {\n        page = getStoredPage(pageId);\n        if (page == null) {\n            // WICKET-4594 - ignore the parsed parameters for stateful pages\n            pageParameters = null;\n        }\n    }\n    if (page == null) {\n        if (pageClass != null) {\n            page = getPageSource().newPageInstance(pageClass, pageParameters);\n            freshCreated = true;\n        }\n    }\n    if (page != null && !freshCreated) {\n        if (renderCount != null && page.getRenderCount() != renderCount) {\n            throw new StalePageException(page);\n        }\n    }\n    pageInstanceIsFresh = freshCreated;\n    pageInstance = page;\n}", "code_comment": NaN, "code_no_comment": "private void resolvePageInstance(Integer pageId, Class<? extends IRequestablePage> pageClass, PageParameters pageParameters, Integer renderCount) {\n    IRequestablePage page = null;\n    boolean freshCreated = false;\n    if (pageId != null) {\n        page = getStoredPage(pageId);\n        if (page == null) {\n                        pageParameters = null;\n        }\n    }\n    if (page == null) {\n        if (pageClass != null) {\n            page = getPageSource().newPageInstance(pageClass, pageParameters);\n            freshCreated = true;\n        }\n    }\n    if (page != null && !freshCreated) {\n        if (renderCount != null && page.getRenderCount() != renderCount) {\n            throw new StalePageException(page);\n        }\n    }\n    pageInstanceIsFresh = freshCreated;\n    pageInstance = page;\n}", "lc": 0.4090909090909091, "pi": 0.24401913875598077, "ma": 0.8, "nbd": 0.0, "ml": 0.75, "d": 0.5376984126984127, "mi": -0.3530655391120508, "fo": -0.16666666666666666, "r": -0.02631578947368421, "e": 0.5147836309883992}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-926_e1ae968c", "label": 1, "code": "@Override\n@Nonnull\nprotected Map<?, ?> transformAndSeal(@Nonnull Map<Object, Object> map, @Nullable String key, int level) {\n    if (level == 1) {\n        if (PREVIOUS.equals(key)) {\n            SortedMap<Revision, Range> transformed = new TreeMap<Revision, Range>(new Comparator<Revision>() {\n\n                @Override\n                public int compare(Revision o1, Revision o2) {\n                    // in reverse order!\n                    int c = o2.compareRevisionTime(o1);\n                    if (c == 0) {\n                        c = o1.getClusterId() < o2.getClusterId() ? -1 : (o1.getClusterId() == o2.getClusterId() ? 0 : 1);\n                    }\n                    return c;\n                }\n            });\n            for (Map.Entry<Object, Object> entry : map.entrySet()) {\n                Revision high = Revision.fromString(entry.getKey().toString());\n                Revision low = Revision.fromString(entry.getValue().toString());\n                transformed.put(high, new Range(high, low));\n            }\n            return Collections.unmodifiableSortedMap(transformed);\n        }\n    }\n    return super.transformAndSeal(map, key, level);\n}", "code_comment": NaN, "code_no_comment": "@Override\n@Nonnull\nprotected Map<?, ?> transformAndSeal(@Nonnull Map<Object, Object> map, @Nullable String key, int level) {\n    if (level == 1) {\n        if (PREVIOUS.equals(key)) {\n            SortedMap<Revision, Range> transformed = new TreeMap<Revision, Range>(new Comparator<Revision>() {\n\n                @Override\n                public int compare(Revision o1, Revision o2) {\n                                        int c = o2.compareRevisionTime(o1);\n                    if (c == 0) {\n                        c = o1.getClusterId() < o2.getClusterId() ? -1 : (o1.getClusterId() == o2.getClusterId() ? 0 : 1);\n                    }\n                    return c;\n                }\n            });\n            for (Map.Entry<Object, Object> entry : map.entrySet()) {\n                Revision high = Revision.fromString(entry.getKey().toString());\n                Revision low = Revision.fromString(entry.getValue().toString());\n                transformed.put(high, new Range(high, low));\n            }\n            return Collections.unmodifiableSortedMap(transformed);\n        }\n    }\n    return super.transformAndSeal(map, key, level);\n}", "lc": 0.5, "pi": 2.004784688995215, "ma": 0.6, "nbd": 1.0, "ml": 0.5, "d": 0.5198412698412699, "mi": -0.45623678646934457, "fo": 0.8333333333333334, "r": -0.02631578947368421, "e": 0.9198619203218016}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-7275_44cad623", "label": 1, "code": "protected boolean process(final Exchange exchange, final AsyncCallback callback, final Iterator<Processor> processors, final AsyncProcessor processor, final Object lastHandled) {\n    // this does the actual processing so log at trace level\n    LOG.trace(\"Processing exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\n    // implement asynchronous routing logic in callback so we can have the callback being\n    // triggered and then continue routing where we left\n    boolean sync = processor.process(exchange, new AsyncCallback() {\n\n        public void done(boolean doneSync) {\n            // we only have to handle async completion of the pipeline\n            if (doneSync) {\n                return;\n            }\n            // continue processing the try .. catch .. finally asynchronously\n            while (continueRouting(processors, exchange)) {\n                ExchangeHelper.prepareOutToIn(exchange);\n                // process the next processor\n                AsyncProcessor processor = AsyncProcessorConverterHelper.convert(processors.next());\n                doneSync = process(exchange, callback, processors, processor, lastHandled);\n                if (!doneSync) {\n                    LOG.trace(\"Processing exchangeId: {} is continued being processed asynchronously\", exchange.getExchangeId());\n                    // so we break out now, then the callback will be invoked which then continue routing from where we left here\n                    return;\n                }\n            }\n            ExchangeHelper.prepareOutToIn(exchange);\n            exchange.setProperty(Exchange.EXCEPTION_HANDLED, lastHandled);\n            LOG.trace(\"Processing complete for exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\n            callback.done(false);\n        }\n    });\n    return sync;\n}", "code_comment": NaN, "code_no_comment": "protected boolean process(final Exchange exchange, final AsyncCallback callback, final Iterator<Processor> processors, final AsyncProcessor processor, final Object lastHandled) {\n        LOG.trace(\"Processing exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\n            boolean sync = processor.process(exchange, new AsyncCallback() {\n\n        public void done(boolean doneSync) {\n                        if (doneSync) {\n                return;\n            }\n                        while (continueRouting(processors, exchange)) {\n                ExchangeHelper.prepareOutToIn(exchange);\n                                AsyncProcessor processor = AsyncProcessorConverterHelper.convert(processors.next());\n                doneSync = process(exchange, callback, processors, processor, lastHandled);\n                if (!doneSync) {\n                    LOG.trace(\"Processing exchangeId: {} is continued being processed asynchronously\", exchange.getExchangeId());\n                                        return;\n                }\n            }\n            ExchangeHelper.prepareOutToIn(exchange);\n            exchange.setProperty(Exchange.EXCEPTION_HANDLED, lastHandled);\n            LOG.trace(\"Processing complete for exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\n            callback.done(false);\n        }\n    });\n    return sync;\n}", "lc": 0.45454545454545453, "pi": 1.291866028708134, "ma": 0.0, "nbd": 0.5, "ml": 0.16666666666666666, "d": 0.08333333333333327, "mi": -0.36772374911909794, "fo": 0.75, "r": -0.02631578947368421, "e": 0.22581214017738277}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3310_4416a9f8", "label": 1, "code": "@Override\npublic void remove() throws RepositoryException {\n    sessionDelegate.performVoid(new ItemWriteOperation(\"remove\") {\n\n        @Override\n        public void performVoid() {\n            dlg.remove();\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"Removing property [%s/%s] \", dlg.getPath(), dlg.getName());\n        }\n    });\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void remove() throws RepositoryException {\n    sessionDelegate.performVoid(new ItemWriteOperation(\"remove\") {\n\n        @Override\n        public void performVoid() {\n            dlg.remove();\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"Removing property [%s/%s] \", dlg.getPath(), dlg.getName());\n        }\n    });\n}", "lc": -0.045454545454545456, "pi": 0.5023923444976076, "ma": -0.6, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.15066948555320642, "fo": -0.08333333333333333, "r": 0.47368421052631576, "e": -0.16279340490885932}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-2334_96330447", "label": 1, "code": "private static List<IDebugBarContributor> getContributors() {\n    List<IDebugBarContributor> list = Application.get().getMetaData(CONTRIBS_META_KEY);\n    return list == null ? new ArrayList<IDebugBarContributor>() : list;\n}", "code_comment": NaN, "code_no_comment": "private static List<IDebugBarContributor> getContributors() {\n    List<IDebugBarContributor> list = Application.get().getMetaData(CONTRIBS_META_KEY);\n    return list == null ? new ArrayList<IDebugBarContributor>() : list;\n}", "lc": -0.45454545454545453, "pi": -0.47368421052631593, "ma": -0.4, "nbd": -1.0, "ml": -0.25, "d": -0.07738095238095241, "mi": 0.7161381254404509, "fo": -0.3333333333333333, "r": 0.7368421052631579, "e": -0.11812843254208374}
{"project_name": "Cli", "project_version": 32, "label": 0, "code": "/**\n * Finds the next text wrap position after <code>startPos</code> for the\n * text in <code>text</code> with the column width <code>width</code>.\n * The wrap point is the last position before startPos+width having a\n * whitespace character (space, \\n, \\r). If there is no whitespace character\n * before startPos+width, it will return startPos+width.\n *\n * @param text The text being searched for the wrap position\n * @param width width of the wrapped text\n * @param startPos position from which to start the lookup whitespace\n * character\n * @return postion on which the text must be wrapped or -1 if the wrap\n * position is at the end of the text\n */\nprotected int findWrapPos(String text, int width, int startPos) {\n    int pos;\n    // the line ends before the max wrap pos or a new line char found\n    if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width) || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width)) {\n        return pos + 1;\n    } else if (startPos + width >= text.length()) {\n        return -1;\n    }\n    // look for the last whitespace character before startPos+width\n    pos = startPos + width;\n    char c;\n    while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ') && (c != '\\n') && (c != '\\r')) {\n        --pos;\n    }\n    // if we found it - just return\n    if (pos > startPos) {\n        return pos;\n    }\n    // if we didn't find one, simply chop at startPos+width\n    pos = startPos + width;\n    while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ') && (c != '\\n') && (c != '\\r')) {\n        ++pos;\n    }\n    return pos == text.length() ? -1 : pos;\n}", "code_comment": "/**\n * Finds the next text wrap position after <code>startPos</code> for the\n * text in <code>text</code> with the column width <code>width</code>.\n * The wrap point is the last position before startPos+width having a\n * whitespace character (space, \\n, \\r). If there is no whitespace character\n * before startPos+width, it will return startPos+width.\n *\n * @param text The text being searched for the wrap position\n * @param width width of the wrapped text\n * @param startPos position from which to start the lookup whitespace\n * character\n * @return postion on which the text must be wrapped or -1 if the wrap\n * position is at the end of the text\n */\n", "code_no_comment": "protected int findWrapPos(String text, int width, int startPos) {\n    int pos;\n        if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width) || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width)) {\n        return pos + 1;\n    } else if (startPos + width >= text.length()) {\n        return -1;\n    }\n        pos = startPos + width;\n    char c;\n    while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ') && (c != '\\n') && (c != '\\r')) {\n        --pos;\n    }\n        if (pos > startPos) {\n        return pos;\n    }\n        pos = startPos + width;\n    while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ') && (c != '\\n') && (c != '\\r')) {\n        ++pos;\n    }\n    return pos == text.length() ? -1 : pos;\n}", "lc": 0.3181818181818182, "pi": -0.35885167464114837, "ma": 0.6, "nbd": 0.0, "ml": 1.25, "d": 4.843253968253968, "mi": -0.3719520789288228, "fo": 0.08333333333333333, "r": -0.02631578947368421, "e": 6.004213850613462}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-1761_380ef878", "label": 1, "code": "private void notifyAllChannelsOfErrorAndClose(Throwable cause) {\n    if (channelError.compareAndSet(false, true)) {\n        for (RemoteInputChannel inputChannel : inputChannels.values()) {\n            inputChannel.onError(cause);\n        }\n        inputChannels.clear();\n        ctx.close();\n    }\n}", "code_comment": NaN, "code_no_comment": "private void notifyAllChannelsOfErrorAndClose(Throwable cause) {\n    if (channelError.compareAndSet(false, true)) {\n        for (RemoteInputChannel inputChannel : inputChannels.values()) {\n            inputChannel.onError(cause);\n        }\n        inputChannels.clear();\n        ctx.close();\n    }\n}", "lc": -0.22727272727272727, "pi": 0.39712918660287067, "ma": -0.2, "nbd": 0.0, "ml": -0.25, "d": -0.3650793650793651, "mi": 0.32008456659619455, "fo": -0.08333333333333333, "r": 0.2368421052631579, "e": -0.16279340490885932}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-1820_39d526e6", "label": 0, "code": "/**\n *  Static utility to parse a field of type byte from a byte sequence that represents text characters\n *  (such as when read from a file stream).\n *\n *  @param bytes The bytes containing the text data that should be parsed.\n *  @param startPos The offset to start the parsing.\n *  @param length The length of the byte sequence (counting from the offset).\n *  @param delimiter The delimiter that terminates the field.\n *\n *  @return The parsed value.\n *\n *  @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\n */\npublic static final byte parseField(byte[] bytes, int startPos, int length, char delimiter) {\n    if (length <= 0) {\n        throw new NumberFormatException(\"Invalid input: Empty string\");\n    }\n    long val = 0;\n    boolean neg = false;\n    if (bytes[startPos] == '-') {\n        neg = true;\n        startPos++;\n        length--;\n        if (length == 0 || bytes[startPos] == delimiter) {\n            throw new NumberFormatException(\"Orphaned minus sign.\");\n        }\n    }\n    for (; length > 0; startPos++, length--) {\n        if (bytes[startPos] == delimiter) {\n            return (byte) (neg ? -val : val);\n        }\n        if (bytes[startPos] < 48 || bytes[startPos] > 57) {\n            throw new NumberFormatException(\"Invalid character.\");\n        }\n        val *= 10;\n        val += bytes[startPos] - 48;\n        if (val > Byte.MAX_VALUE && (!neg || val > -Byte.MIN_VALUE)) {\n            throw new NumberFormatException(\"Value overflow/underflow\");\n        }\n    }\n    return (byte) (neg ? -val : val);\n}", "code_comment": "/**\n *  Static utility to parse a field of type byte from a byte sequence that represents text characters\n *  (such as when read from a file stream).\n *\n *  @param bytes The bytes containing the text data that should be parsed.\n *  @param startPos The offset to start the parsing.\n *  @param length The length of the byte sequence (counting from the offset).\n *  @param delimiter The delimiter that terminates the field.\n *\n *  @return The parsed value.\n *\n *  @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\n */\n", "code_no_comment": "public static final byte parseField(byte[] bytes, int startPos, int length, char delimiter) {\n    if (length <= 0) {\n        throw new NumberFormatException(\"Invalid input: Empty string\");\n    }\n    long val = 0;\n    boolean neg = false;\n    if (bytes[startPos] == '-') {\n        neg = true;\n        startPos++;\n        length--;\n        if (length == 0 || bytes[startPos] == delimiter) {\n            throw new NumberFormatException(\"Orphaned minus sign.\");\n        }\n    }\n    for (; length > 0; startPos++, length--) {\n        if (bytes[startPos] == delimiter) {\n            return (byte) (neg ? -val : val);\n        }\n        if (bytes[startPos] < 48 || bytes[startPos] > 57) {\n            throw new NumberFormatException(\"Invalid character.\");\n        }\n        val *= 10;\n        val += bytes[startPos] - 48;\n        if (val > Byte.MAX_VALUE && (!neg || val > -Byte.MIN_VALUE)) {\n            throw new NumberFormatException(\"Value overflow/underflow\");\n        }\n    }\n    return (byte) (neg ? -val : val);\n}", "lc": 0.6818181818181818, "pi": 0.08612440191387546, "ma": 2.0, "nbd": 0.0, "ml": 1.0, "d": 2.948412698412698, "mi": -0.5546159267089498, "fo": -0.5, "r": -0.02631578947368421, "e": 3.498277461777401}
{"project_name": "Closure", "project_version": 153, "label": 2, "code": "/**\n * Remove duplicate VAR declarations encountered discovered during\n * scope creation.\n */\n@Override\npublic void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n    Preconditions.checkState(n.getType() == Token.NAME);\n    Var v = s.getVar(name);\n    // If name is \"arguments\", Var maybe null.\n    if (v != null && v.getParentNode().getType() == Token.CATCH) {\n        // Redeclaration of a catch expression variable is hard to model\n        // without support for \"with\" expressions.\n        // The EcmaScript spec (section 12.14), declares that a catch\n        // \"catch (e) {}\" is handled like \"with ({'e': e}) {}\" so that\n        // \"var e\" would refer to the scope variable, but any following\n        // reference would still refer to \"e\" of the catch expression.\n        // Until we have support for this disallow it.\n        // Currently the Scope object adds the catch expression to the\n        // function scope, which is technically not true but a good\n        // approximation for most uses.\n        // TODO(johnlenz): Consider improving how scope handles catch\n        // expression.\n        // Use the name of the var before it was made unique.\n        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);\n        compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));\n    } else if (v != null && parent.getType() == Token.FUNCTION) {\n        if (v.getParentNode().getType() == Token.VAR) {\n            s.undeclare(v);\n            s.declare(name, n, n.getJSType(), v.input);\n            replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());\n        }\n    } else if (parent.getType() == Token.VAR) {\n        Preconditions.checkState(parent.hasOneChild());\n        replaceVarWithAssignment(n, parent, gramps);\n    }\n}", "code_comment": "/**\n * Remove duplicate VAR declarations encountered discovered during\n * scope creation.\n */\n", "code_no_comment": "@Override\npublic void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n    Preconditions.checkState(n.getType() == Token.NAME);\n    Var v = s.getVar(name);\n        if (v != null && v.getParentNode().getType() == Token.CATCH) {\n                                                                                                                name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);\n        compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));\n    } else if (v != null && parent.getType() == Token.FUNCTION) {\n        if (v.getParentNode().getType() == Token.VAR) {\n            s.undeclare(v);\n            s.declare(name, n, n.getJSType(), v.input);\n            replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());\n        }\n    } else if (parent.getType() == Token.VAR) {\n        Preconditions.checkState(parent.hasOneChild());\n        replaceVarWithAssignment(n, parent, gramps);\n    }\n}", "lc": 0.18181818181818182, "pi": 0.40191387559808606, "ma": 0.2, "nbd": 0.5, "ml": 0.3333333333333333, "d": 0.4662698412698414, "mi": -0.3026074700493304, "fo": 1.5, "r": -0.02631578947368421, "e": 0.9199126340600379}
{"project_name": "Compress", "project_version": 38, "label": 1, "code": "/**\n * Return whether or not this entry represents a directory.\n *\n * @return True if this entry is a directory.\n */\n@Override\npublic boolean isDirectory() {\n    if (file != null) {\n        return file.isDirectory();\n    }\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n    if (getName().endsWith(\"/\")) {\n        return true;\n    }\n    return false;\n}", "code_comment": "/**\n * Return whether or not this entry represents a directory.\n *\n * @return True if this entry is a directory.\n */\n", "code_no_comment": "@Override\npublic boolean isDirectory() {\n    if (file != null) {\n        return file.isDirectory();\n    }\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n    if (getName().endsWith(\"/\")) {\n        return true;\n    }\n    return false;\n}", "lc": -0.045454545454545456, "pi": -0.1291866028708134, "ma": 0.0, "nbd": -0.5, "ml": 0.08333333333333333, "d": -0.11706349206349208, "mi": 0.1689922480620156, "fo": -0.25, "r": 2.0, "e": -0.12549114526604543}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-1135_a7363a2a", "label": 3, "code": "/**\n * Update the partial hull with the current point.\n *\n * @param point the current point\n * @param hull the partial hull\n */\nprivate void updateHull(final Vector2D point, final List<Vector2D> hull) {\n    final double tolerance = getTolerance();\n    if (hull.size() == 1) {\n        // ensure that we do not add an identical point\n        final Vector2D p1 = hull.get(0);\n        if (p1.distance(point) < tolerance) {\n            return;\n        }\n    }\n    while (hull.size() >= 2) {\n        final int size = hull.size();\n        final Vector2D p1 = hull.get(size - 2);\n        final Vector2D p2 = hull.get(size - 1);\n        final double offset = new Line(p1, p2, tolerance).getOffset(point);\n        if (FastMath.abs(offset) < tolerance) {\n            // the point is collinear to the line (p1, p2)\n            final double distanceToCurrent = p1.distance(point);\n            if (distanceToCurrent < tolerance || p2.distance(point) < tolerance) {\n                // the point is assumed to be identical to either p1 or p2\n                return;\n            }\n            final double distanceToLast = p1.distance(p2);\n            if (isIncludeCollinearPoints()) {\n                final int index = distanceToCurrent < distanceToLast ? size - 1 : size;\n                hull.add(index, point);\n            } else {\n                if (distanceToCurrent > distanceToLast) {\n                    hull.remove(size - 1);\n                }\n                hull.add(point);\n            }\n            return;\n        } else if (offset > 0) {\n            hull.remove(size - 1);\n        } else {\n            break;\n        }\n    }\n    hull.add(point);\n}", "code_comment": "/**\n * Update the partial hull with the current point.\n *\n * @param point the current point\n * @param hull the partial hull\n */\n", "code_no_comment": "private void updateHull(final Vector2D point, final List<Vector2D> hull) {\n    final double tolerance = getTolerance();\n    if (hull.size() == 1) {\n                final Vector2D p1 = hull.get(0);\n        if (p1.distance(point) < tolerance) {\n            return;\n        }\n    }\n    while (hull.size() >= 2) {\n        final int size = hull.size();\n        final Vector2D p1 = hull.get(size - 2);\n        final Vector2D p2 = hull.get(size - 1);\n        final double offset = new Line(p1, p2, tolerance).getOffset(point);\n        if (FastMath.abs(offset) < tolerance) {\n                        final double distanceToCurrent = p1.distance(point);\n            if (distanceToCurrent < tolerance || p2.distance(point) < tolerance) {\n                                return;\n            }\n            final double distanceToLast = p1.distance(p2);\n            if (isIncludeCollinearPoints()) {\n                final int index = distanceToCurrent < distanceToLast ? size - 1 : size;\n                hull.add(index, point);\n            } else {\n                if (distanceToCurrent > distanceToLast) {\n                    hull.remove(size - 1);\n                }\n                hull.add(point);\n            }\n            return;\n        } else if (offset > 0) {\n            hull.remove(size - 1);\n        } else {\n            break;\n        }\n    }\n    hull.add(point);\n}", "lc": 1.0454545454545454, "pi": 0.8181818181818182, "ma": 1.4, "nbd": 1.0, "ml": 1.25, "d": 1.6845238095238095, "mi": -0.6792107117688511, "fo": 1.0833333333333333, "r": -0.02631578947368421, "e": 2.672906761639667}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-395_962315ba", "label": 1, "code": "/**\n * {@inheritDoc}\n */\npublic double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max, final double startValue) throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    return localMin(f, goalType, min, startValue, max, getRelativeAccuracy(), getAbsoluteAccuracy());\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max, final double startValue) throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    return localMin(f, goalType, min, startValue, max, getRelativeAccuracy(), getAbsoluteAccuracy());\n}", "lc": -0.45454545454545453, "pi": -0.47368421052631593, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.6992248062015504, "fo": -0.16666666666666666, "r": 0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5570_57d8f051", "label": 1, "code": "/**\n *  @return the name of the handle that is used to stop any scheduled timer\n */\nprivate String getTimeoutHandle() {\n    return \"Wicket.TimerHandles['\" + getComponent().getMarkupId() + \"']\";\n}", "code_comment": "/**\n *  @return the name of the handle that is used to stop any scheduled timer\n */\n", "code_no_comment": "private String getTimeoutHandle() {\n    return \"Wicket.TimerHandles['\" + getComponent().getMarkupId() + \"']\";\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.0036645525017613, "fo": -0.3333333333333333, "r": 2.6052631578947367, "e": -0.16279340490885932}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-9673_7944093f", "label": 3, "code": "@Override\npublic boolean process(final Exchange exchange, final AsyncCallback callback) {\n    // clear exception so finally block can be executed\n    final Exception e = exchange.getException();\n    exchange.setException(null);\n    // but store the caught exception as a property\n    if (e != null) {\n        exchange.setProperty(Exchange.EXCEPTION_CAUGHT, e);\n    }\n    // store the last to endpoint as the failure endpoint\n    if (exchange.getProperty(Exchange.FAILURE_ENDPOINT) == null) {\n        exchange.setProperty(Exchange.FAILURE_ENDPOINT, exchange.getProperty(Exchange.TO_ENDPOINT));\n    }\n    boolean sync = processor.process(exchange, new AsyncCallback() {\n\n        public void done(boolean doneSync) {\n            if (e == null) {\n                exchange.removeProperty(Exchange.FAILURE_ENDPOINT);\n            } else {\n                // set exception back on exchange\n                exchange.setException(e);\n                exchange.setProperty(Exchange.EXCEPTION_CAUGHT, e);\n            }\n            if (!doneSync) {\n                // signal callback to continue routing async\n                ExchangeHelper.prepareOutToIn(exchange);\n                LOG.trace(\"Processing complete for exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\n            }\n            callback.done(doneSync);\n        }\n    });\n    return sync;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean process(final Exchange exchange, final AsyncCallback callback) {\n        final Exception e = exchange.getException();\n    exchange.setException(null);\n        if (e != null) {\n        exchange.setProperty(Exchange.EXCEPTION_CAUGHT, e);\n    }\n        if (exchange.getProperty(Exchange.FAILURE_ENDPOINT) == null) {\n        exchange.setProperty(Exchange.FAILURE_ENDPOINT, exchange.getProperty(Exchange.TO_ENDPOINT));\n    }\n    boolean sync = processor.process(exchange, new AsyncCallback() {\n\n        public void done(boolean doneSync) {\n            if (e == null) {\n                exchange.removeProperty(Exchange.FAILURE_ENDPOINT);\n            } else {\n                                exchange.setException(e);\n                exchange.setProperty(Exchange.EXCEPTION_CAUGHT, e);\n            }\n            if (!doneSync) {\n                                ExchangeHelper.prepareOutToIn(exchange);\n                LOG.trace(\"Processing complete for exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\n            }\n            callback.done(doneSync);\n        }\n    });\n    return sync;\n}", "lc": 0.5909090909090909, "pi": 1.0956937799043063, "ma": 0.2, "nbd": 0.0, "ml": 0.16666666666666666, "d": 0.613095238095238, "mi": -0.4286116983791401, "fo": 0.6666666666666666, "r": -0.02631578947368421, "e": 0.6892942145997936}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5734_71674df5", "label": 3, "code": "/**\n *  Creates a {@code IRequestHandler} that processes a hybrid request. When the page identified\n *  by {@code pageInfo} was not available, the request should be treated as a bookmarkable\n *  request.\n *\n *  @param pageInfo\n *  @param pageClass\n *  @param pageParameters\n *  @param renderCount\n *  @return a {@code IRequestHandler} capable of processing the hybrid request.\n */\nprotected IRequestHandler processHybrid(PageInfo pageInfo, Class<? extends IRequestablePage> pageClass, PageParameters pageParameters, Integer renderCount) {\n    PageProvider provider = new PageProvider(pageInfo.getPageId(), pageClass, pageParameters, renderCount);\n    provider.setPageSource(getContext());\n    if (provider.isNewPageInstance() && !getRecreateMountedPagesAfterExpiry()) {\n        throw new PageExpiredException(String.format(\"Bookmarkable page id '%d' has expired.\", pageInfo.getPageId()));\n    } else {\n        PageParameters constructionPageParameters = provider.getPageInstance().getPageParameters();\n        if (PageParameters.equals(constructionPageParameters, pageParameters) == false) {\n            // when the resolved page by id has been created\n            return new RenderPageRequestHandler(new PageProvider(pageClass, pageParameters));\n        }\n        return new RenderPageRequestHandler(provider);\n    }\n}", "code_comment": "/**\n *  Creates a {@code IRequestHandler} that processes a hybrid request. When the page identified\n *  by {@code pageInfo} was not available, the request should be treated as a bookmarkable\n *  request.\n *\n *  @param pageInfo\n *  @param pageClass\n *  @param pageParameters\n *  @param renderCount\n *  @return a {@code IRequestHandler} capable of processing the hybrid request.\n */\n", "code_no_comment": "protected IRequestHandler processHybrid(PageInfo pageInfo, Class<? extends IRequestablePage> pageClass, PageParameters pageParameters, Integer renderCount) {\n    PageProvider provider = new PageProvider(pageInfo.getPageId(), pageClass, pageParameters, renderCount);\n    provider.setPageSource(getContext());\n    if (provider.isNewPageInstance() && !getRecreateMountedPagesAfterExpiry()) {\n        throw new PageExpiredException(String.format(\"Bookmarkable page id '%d' has expired.\", pageInfo.getPageId()));\n    } else {\n        PageParameters constructionPageParameters = provider.getPageInstance().getPageParameters();\n        if (PageParameters.equals(constructionPageParameters, pageParameters) == false) {\n                        return new RenderPageRequestHandler(new PageProvider(pageClass, pageParameters));\n        }\n        return new RenderPageRequestHandler(provider);\n    }\n}", "lc": -0.045454545454545456, "pi": 0.16746411483253573, "ma": 0.0, "nbd": 0.0, "ml": 0.25, "d": 0.2916666666666667, "mi": -0.03875968992248061, "fo": 0.3333333333333333, "r": -0.02631578947368421, "e": 0.24523550192193536}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1364_05c89637", "label": 1, "code": "synchronized V get(K key, int hash, CacheLoader<K, V> loader) throws ExecutionException {\n    V value = get(key, hash);\n    if (value == null) {\n        long start = System.nanoTime();\n        try {\n            value = loader.load(key);\n            loadSuccessCount++;\n        } catch (Exception e) {\n            loadExceptionCount++;\n            throw new ExecutionException(e);\n        } finally {\n            long time = System.nanoTime() - start;\n            totalLoadTime += time;\n        }\n        put(key, hash, value, cache.sizeOf(key, value));\n    }\n    return value;\n}", "code_comment": NaN, "code_no_comment": "synchronized V get(K key, int hash, CacheLoader<K, V> loader) throws ExecutionException {\n    V value = get(key, hash);\n    if (value == null) {\n        long start = System.nanoTime();\n        try {\n            value = loader.load(key);\n            loadSuccessCount++;\n        } catch (Exception e) {\n            loadExceptionCount++;\n            throw new ExecutionException(e);\n        } finally {\n            long time = System.nanoTime() - start;\n            totalLoadTime += time;\n        }\n        put(key, hash, value, cache.sizeOf(key, value));\n    }\n    return value;\n}", "lc": 0.18181818181818182, "pi": 0.4736842105263157, "ma": 0.0, "nbd": 0.0, "ml": -0.25, "d": 0.3948412698412698, "mi": -0.18731501057082436, "fo": 0.0, "r": 0.02631578947368421, "e": 0.30940682215037774}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-2742_1f7dd2d5", "label": 1, "code": "@SuppressWarnings(\"unchecked\")\n@Override\npublic int execute(final String fullCommand, final CommandLine cl, final Shell shellState) throws IOException {\n    if (cl.hasOption(clearHist.getOpt())) {\n        shellState.getReader().getHistory().clear();\n    } else {\n        ListIterator<Entry> it = shellState.getReader().getHistory().entries();\n        shellState.printLines(new HistoryLineIterator(it), !cl.hasOption(disablePaginationOpt.getOpt()));\n    }\n    return 0;\n}", "code_comment": NaN, "code_no_comment": "@SuppressWarnings(\"unchecked\")\n@Override\npublic int execute(final String fullCommand, final CommandLine cl, final Shell shellState) throws IOException {\n    if (cl.hasOption(clearHist.getOpt())) {\n        shellState.getReader().getHistory().clear();\n    } else {\n        ListIterator<Entry> it = shellState.getReader().getHistory().entries();\n        shellState.printLines(new HistoryLineIterator(it), !cl.hasOption(disablePaginationOpt.getOpt()));\n    }\n    return 0;\n}", "lc": -0.13636363636363635, "pi": 0.08612440191387546, "ma": -0.4, "nbd": -0.5, "ml": -0.16666666666666666, "d": -0.0912698412698413, "mi": 0.10613107822410148, "fo": 0.4166666666666667, "r": -0.02631578947368421, "e": -0.046179469004108964}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-744_8a83581e", "label": 1, "code": "/**\n * <p>\n * Gets the fraction as a <tt>float</tt>. This calculates the fraction as\n * the numerator divided by denominator.\n * </p>\n *\n * @return the fraction as a <tt>float</tt>.\n * @see java.lang.Number#floatValue()\n */\n@Override\npublic float floatValue() {\n    return numerator.floatValue() / denominator.floatValue();\n}", "code_comment": "/**\n * <p>\n * Gets the fraction as a <tt>float</tt>. This calculates the fraction as\n * the numerator divided by denominator.\n * </p>\n *\n * @return the fraction as a <tt>float</tt>.\n * @see java.lang.Number#floatValue()\n */\n", "code_no_comment": "@Override\npublic float floatValue() {\n    return numerator.floatValue() / denominator.floatValue();\n}", "lc": -0.45454545454545453, "pi": -0.6028708133971293, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.8940098661028892, "fo": -0.3333333333333333, "r": 2.4736842105263155, "e": -0.16279340490885932}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-2993_0b4f78cc", "label": 1, "code": "/**\n *  @see org.apache.wicket.request.mapper.AbstractBookmarkableMapper#parseRequest(org.apache.wicket.request.Request)\n */\n@Override\nprotected UrlInfo parseRequest(Request request) {\n    Url url = request.getUrl();\n    if (url.getSegments().size() >= 3 && urlStartsWith(url, getContext().getNamespace(), getContext().getBookmarkableIdentifier())) {\n        // try to extract page and component information from URL\n        PageComponentInfo info = getPageComponentInfo(url);\n        // load the page class\n        String className = url.getSegments().get(2);\n        Class<? extends IRequestablePage> pageClass = getPageClass(className);\n        if (Page.class.isAssignableFrom(pageClass)) {\n            // extract the PageParameters from URL if there are any\n            PageParameters pageParameters = extractPageParameters(request, 3, pageParametersEncoder);\n            return new UrlInfo(info, pageClass, pageParameters);\n        }\n    }\n    return null;\n}", "code_comment": "/**\n *  @see org.apache.wicket.request.mapper.AbstractBookmarkableMapper#parseRequest(org.apache.wicket.request.Request)\n */\n", "code_no_comment": "@Override\nprotected UrlInfo parseRequest(Request request) {\n    Url url = request.getUrl();\n    if (url.getSegments().size() >= 3 && urlStartsWith(url, getContext().getNamespace(), getContext().getBookmarkableIdentifier())) {\n                PageComponentInfo info = getPageComponentInfo(url);\n                String className = url.getSegments().get(2);\n        Class<? extends IRequestablePage> pageClass = getPageClass(className);\n        if (Page.class.isAssignableFrom(pageClass)) {\n                        PageParameters pageParameters = extractPageParameters(request, 3, pageParametersEncoder);\n            return new UrlInfo(info, pageClass, pageParameters);\n        }\n    }\n    return null;\n}", "lc": 0.0, "pi": 0.4449760765550238, "ma": -0.2, "nbd": 0.0, "ml": 0.4166666666666667, "d": -0.07936507936507939, "mi": -0.07906976744186024, "fo": 0.6666666666666666, "r": -0.02631578947368421, "e": 0.031039112970614836}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2047_a0a495f0", "label": 0, "code": "private PrivilegeBits resolvePrivilegeBits(NodeBuilder privileges, String name) {\n    NodeBuilder def = privileges.getChildNode(name);\n    PropertyState b = def.getProperty(REP_BITS);\n    if (b != null) {\n        return PrivilegeBits.getInstance(b);\n    }\n    PrivilegeBits bits = PrivilegeBits.getInstance();\n    for (String n : def.getNames(REP_AGGREGATES)) {\n        bits.add(resolvePrivilegeBits(privileges, n));\n    }\n    def.setProperty(bits.asPropertyState(REP_BITS));\n    return bits;\n}", "code_comment": NaN, "code_no_comment": "private PrivilegeBits resolvePrivilegeBits(NodeBuilder privileges, String name) {\n    NodeBuilder def = privileges.getChildNode(name);\n    PropertyState b = def.getProperty(REP_BITS);\n    if (b != null) {\n        return PrivilegeBits.getInstance(b);\n    }\n    PrivilegeBits bits = PrivilegeBits.getInstance();\n    for (String n : def.getNames(REP_AGGREGATES)) {\n        bits.add(resolvePrivilegeBits(privileges, n));\n    }\n    def.setProperty(bits.asPropertyState(REP_BITS));\n    return bits;\n}", "lc": -0.045454545454545456, "pi": -0.368421052631579, "ma": -0.2, "nbd": -0.5, "ml": -0.25, "d": 0.013888888888888857, "mi": 0.0023960535588444802, "fo": 0.25, "r": 0.02631578947368421, "e": 0.022837318395832234}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-177_f91ce934", "label": 1, "code": "/**\n * Set the header to write when the stream is opened.\n * @param header The header.\n */\npublic synchronized void setHeader(final byte[] header) {\n    if (header != null) {\n        try {\n            this.os.write(header, 0, header.length);\n        } catch (final IOException ioe) {\n            LOGGER.error(\"Unable to write header\", ioe);\n        }\n    }\n}", "code_comment": "/**\n * Set the header to write when the stream is opened.\n * @param header The header.\n */\n", "code_no_comment": "public synchronized void setHeader(final byte[] header) {\n    if (header != null) {\n        try {\n            this.os.write(header, 0, header.length);\n        } catch (final IOException ioe) {\n            LOGGER.error(\"Unable to write header\", ioe);\n        }\n    }\n}", "lc": -0.22727272727272727, "pi": 0.6076555023923443, "ma": -0.2, "nbd": 0.0, "ml": -0.25, "d": -0.3650793650793651, "mi": 0.33502466525722346, "fo": -0.3333333333333333, "r": 0.13157894736842105, "e": -0.16279340490885932}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4757_fd910746", "label": 1, "code": "@Override\npublic void component(final FormComponent<?> formComponent, final IVisit<Void> visit) {\n    Form<?> form = formComponent.getForm();\n    if (!form.isVisibleInHierarchy() || !form.isEnabledInHierarchy()) {\n        // do not validate formComponent or any of formComponent's children\n        visit.dontGoDeeper();\n        return;\n    }\n    if (formComponent.isVisibleInHierarchy() && formComponent.isValid() && formComponent.isEnabledInHierarchy()) {\n        validate(formComponent);\n    }\n    if (formComponent.processChildren() == false) {\n        visit.dontGoDeeper();\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void component(final FormComponent<?> formComponent, final IVisit<Void> visit) {\n    Form<?> form = formComponent.getForm();\n    if (!form.isVisibleInHierarchy() || !form.isEnabledInHierarchy()) {\n                visit.dontGoDeeper();\n        return;\n    }\n    if (formComponent.isVisibleInHierarchy() && formComponent.isValid() && formComponent.isEnabledInHierarchy()) {\n        validate(formComponent);\n    }\n    if (formComponent.processChildren() == false) {\n        visit.dontGoDeeper();\n    }\n}", "lc": 0.0, "pi": -0.08612440191387569, "ma": 0.0, "nbd": -0.5, "ml": 0.5833333333333334, "d": 0.31746031746031744, "mi": -0.004087385482734207, "fo": 0.3333333333333333, "r": -0.02631578947368421, "e": 0.10299268684842929}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-4423_08f0b280", "label": 3, "code": "@Override\npublic Boolean call() {\n    long now = System.currentTimeMillis();\n    refreshHead();\n    SegmentNodeState state = head.get();\n    SegmentNodeBuilder builder = state.builder();\n    NodeBuilder checkpoints = builder.child(\"checkpoints\");\n    for (String n : checkpoints.getChildNodeNames()) {\n        NodeBuilder cp = checkpoints.getChildNode(n);\n        PropertyState ts = cp.getProperty(\"timestamp\");\n        if (ts == null || ts.getType() != LONG || now > ts.getValue(LONG)) {\n            cp.remove();\n        }\n    }\n    NodeBuilder cp = checkpoints.child(name);\n    cp.setProperty(\"timestamp\", now + lifetime);\n    cp.setProperty(\"created\", now);\n    NodeBuilder props = cp.setChildNode(\"properties\");\n    for (Entry<String, String> p : properties.entrySet()) {\n        props.setProperty(p.getKey(), p.getValue());\n    }\n    cp.setChildNode(ROOT, state.getChildNode(ROOT));\n    SegmentNodeState newState = builder.getNodeState();\n    if (revisions.setHead(state.getRecordId(), newState.getRecordId())) {\n        refreshHead();\n        return true;\n    } else {\n        return false;\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic Boolean call() {\n    long now = System.currentTimeMillis();\n    refreshHead();\n    SegmentNodeState state = head.get();\n    SegmentNodeBuilder builder = state.builder();\n    NodeBuilder checkpoints = builder.child(\"checkpoints\");\n    for (String n : checkpoints.getChildNodeNames()) {\n        NodeBuilder cp = checkpoints.getChildNode(n);\n        PropertyState ts = cp.getProperty(\"timestamp\");\n        if (ts == null || ts.getType() != LONG || now > ts.getValue(LONG)) {\n            cp.remove();\n        }\n    }\n    NodeBuilder cp = checkpoints.child(name);\n    cp.setProperty(\"timestamp\", now + lifetime);\n    cp.setProperty(\"created\", now);\n    NodeBuilder props = cp.setChildNode(\"properties\");\n    for (Entry<String, String> p : properties.entrySet()) {\n        props.setProperty(p.getKey(), p.getValue());\n    }\n    cp.setChildNode(ROOT, state.getChildNode(ROOT));\n    SegmentNodeState newState = builder.getNodeState();\n    if (revisions.setHead(state.getRecordId(), newState.getRecordId())) {\n        refreshHead();\n        return true;\n    } else {\n        return false;\n    }\n}", "lc": 0.7272727272727273, "pi": -0.15311004784689008, "ma": 0.2, "nbd": 0.0, "ml": 0.5, "d": 0.7777777777777778, "mi": -0.5563072586328399, "fo": 1.6666666666666667, "r": -0.02631578947368421, "e": 1.5490211672227885}
{"project_name": "Closure", "project_version": 89, "label": 2, "code": "/**\n * Updates the initial assignment to a collapsible property at global scope\n * by changing it to a variable declaration (e.g. a.b = 1 -> var a$b = 1).\n * The property's value may either be a primitive or an object literal or\n * function whose properties aren't collapsible.\n *\n * @param alias The flattened property name (e.g. \"a$b\")\n * @param refName The name for the reference being updated.\n * @param ref An object containing information about the assignment getting\n *     updated\n */\nprivate void updateSimpleDeclaration(String alias, Name refName, Ref ref) {\n    Node rvalue = ref.node.getNext();\n    Node parent = ref.node.getParent();\n    Node gramps = parent.getParent();\n    Node greatGramps = gramps.getParent();\n    Node greatGreatGramps = greatGramps.getParent();\n    // Create the new alias node.\n    Node nameNode = NodeUtil.newName(compiler.getCodingConvention(), alias, gramps.getFirstChild(), refName.fullName());\n    NodeUtil.copyNameAnnotations(ref.node.getLastChild(), nameNode);\n    if (gramps.getType() == Token.EXPR_RESULT) {\n        // BEFORE: a.b.c = ...;\n        // exprstmt\n        // assign\n        // getprop\n        // getprop\n        // name a\n        // string b\n        // string c\n        // NODE\n        // AFTER: var a$b$c = ...;\n        // var\n        // name a$b$c\n        // NODE\n        // Remove the rvalue (NODE).\n        parent.removeChild(rvalue);\n        nameNode.addChildToFront(rvalue);\n        Node varNode = new Node(Token.VAR, nameNode);\n        greatGramps.replaceChild(gramps, varNode);\n    } else {\n        // This must be a complex assignment.\n        Preconditions.checkNotNull(ref.getTwin());\n        // BEFORE:\n        // ... (x.y = 3);\n        // \n        // AFTER:\n        // var x$y;\n        // ... (x$y = 3);\n        Node current = gramps;\n        Node currentParent = gramps.getParent();\n        for (; currentParent.getType() != Token.SCRIPT && currentParent.getType() != Token.BLOCK; current = currentParent, currentParent = currentParent.getParent()) {\n        }\n        // Create a stub variable declaration right\n        // before the current statement.\n        Node stubVar = new Node(Token.VAR, nameNode.cloneTree()).copyInformationFrom(nameNode);\n        currentParent.addChildBefore(stubVar, current);\n        parent.replaceChild(ref.node, nameNode);\n    }\n    compiler.reportCodeChange();\n}", "code_comment": "/**\n * Updates the initial assignment to a collapsible property at global scope\n * by changing it to a variable declaration (e.g. a.b = 1 -> var a$b = 1).\n * The property's value may either be a primitive or an object literal or\n * function whose properties aren't collapsible.\n *\n * @param alias The flattened property name (e.g. \"a$b\")\n * @param refName The name for the reference being updated.\n * @param ref An object containing information about the assignment getting\n *     updated\n */\n", "code_no_comment": "private void updateSimpleDeclaration(String alias, Name refName, Ref ref) {\n    Node rvalue = ref.node.getNext();\n    Node parent = ref.node.getParent();\n    Node gramps = parent.getParent();\n    Node greatGramps = gramps.getParent();\n    Node greatGreatGramps = greatGramps.getParent();\n        Node nameNode = NodeUtil.newName(compiler.getCodingConvention(), alias, gramps.getFirstChild(), refName.fullName());\n    NodeUtil.copyNameAnnotations(ref.node.getLastChild(), nameNode);\n    if (gramps.getType() == Token.EXPR_RESULT) {\n                                                                                                                        parent.removeChild(rvalue);\n        nameNode.addChildToFront(rvalue);\n        Node varNode = new Node(Token.VAR, nameNode);\n        greatGramps.replaceChild(gramps, varNode);\n    } else {\n                Preconditions.checkNotNull(ref.getTwin());\n                                                        Node current = gramps;\n        Node currentParent = gramps.getParent();\n        for (; currentParent.getType() != Token.SCRIPT && currentParent.getType() != Token.BLOCK; current = currentParent, currentParent = currentParent.getParent()) {\n        }\n                        Node stubVar = new Node(Token.VAR, nameNode.cloneTree()).copyInformationFrom(nameNode);\n        currentParent.addChildBefore(stubVar, current);\n        parent.replaceChild(ref.node, nameNode);\n    }\n    compiler.reportCodeChange();\n}", "lc": 0.5, "pi": -0.2200956937799045, "ma": -0.2, "nbd": 0.0, "ml": 0.0, "d": 0.5932539682539683, "mi": -0.4754052149400984, "fo": 1.6666666666666667, "r": -0.02631578947368421, "e": 1.4320107420918262}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-579_7d72e6ed", "label": 3, "code": "/**\n * Prepare executing the query. This method will decide which index to use.\n */\npublic abstract void prepare();", "code_comment": "/**\n * Prepare executing the query. This method will decide which index to use.\n */\n", "code_no_comment": "public abstract void prepare();", "lc": -0.5909090909090909, "pi": -1.4306220095693782, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.8696264975334735, "fo": -0.5, "r": 2.6052631578947367, "e": -0.16279340490885932}
{"project_name": "Closure", "project_version": 169, "label": 2, "code": "boolean checkRecordEquivalenceHelper(RecordType otherRecord, boolean tolerateUnknowns) {\n    Set<String> keySet = properties.keySet();\n    Map<String, JSType> otherProps = otherRecord.properties;\n    if (!otherProps.keySet().equals(keySet)) {\n        return false;\n    }\n    for (String key : keySet) {\n        if (!otherProps.get(key).checkEquivalenceHelper(properties.get(key), tolerateUnknowns)) {\n            return false;\n        }\n    }\n    return true;\n}", "code_comment": NaN, "code_no_comment": "boolean checkRecordEquivalenceHelper(RecordType otherRecord, boolean tolerateUnknowns) {\n    Set<String> keySet = properties.keySet();\n    Map<String, JSType> otherProps = otherRecord.properties;\n    if (!otherProps.keySet().equals(keySet)) {\n        return false;\n    }\n    for (String key : keySet) {\n        if (!otherProps.get(key).checkEquivalenceHelper(properties.get(key), tolerateUnknowns)) {\n            return false;\n        }\n    }\n    return true;\n}", "lc": -0.045454545454545456, "pi": 0.10047846889952151, "ma": 0.0, "nbd": 0.0, "ml": 0.25, "d": 0.009920634920634885, "mi": 0.03255813953488375, "fo": 0.0, "r": -0.02631578947368421, "e": -0.019771442402448082}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4511_4ee5ad1f", "label": 1, "code": "@Override\nprotected final MarkupElement onComponentTag(ComponentTag tag) throws ParseException {\n    // Whatever there is left in the markup, ignore it\n    if (ignoreTheRest == true) {\n        return tag;\n    }\n    // if it is <head> or </head>\n    if (HEAD.equalsIgnoreCase(tag.getName())) {\n        if (tag.getNamespace() == null) {\n            // we found <head>\n            if (tag.isClose()) {\n                foundHead = true;\n            } else if (tag.getId() == null) {\n                tag.setId(HEADER_ID);\n                tag.setAutoComponentTag(true);\n                tag.setModified(true);\n            }\n            return tag;\n        } else {\n            // we found <wicket:head>\n            foundHead = true;\n        }\n    } else if (BODY.equalsIgnoreCase(tag.getName()) && (tag.getNamespace() == null)) {\n        // We found <body>\n        if (foundHead == false) {\n            insertHeadTag();\n        }\n        // <head> must always be before <body>\n        ignoreTheRest = true;\n        return tag;\n    }\n    return tag;\n}", "code_comment": NaN, "code_no_comment": "@Override\nprotected final MarkupElement onComponentTag(ComponentTag tag) throws ParseException {\n        if (ignoreTheRest == true) {\n        return tag;\n    }\n        if (HEAD.equalsIgnoreCase(tag.getName())) {\n        if (tag.getNamespace() == null) {\n                        if (tag.isClose()) {\n                foundHead = true;\n            } else if (tag.getId() == null) {\n                tag.setId(HEADER_ID);\n                tag.setAutoComponentTag(true);\n                tag.setModified(true);\n            }\n            return tag;\n        } else {\n                        foundHead = true;\n        }\n    } else if (BODY.equalsIgnoreCase(tag.getName()) && (tag.getNamespace() == null)) {\n                if (foundHead == false) {\n            insertHeadTag();\n        }\n                ignoreTheRest = true;\n        return tag;\n    }\n    return tag;\n}", "lc": 0.5909090909090909, "pi": 0.8947368421052633, "ma": 0.8, "nbd": 1.0, "ml": 0.9166666666666666, "d": 0.047619047619047616, "mi": -0.40549682875264276, "fo": 0.5, "r": -0.02631578947368421, "e": 0.10665790702097128}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3897_94c6c575", "label": 1, "code": "@Nonnull\nRevisionVector reset(@Nonnull RevisionVector branchHead, @Nonnull RevisionVector ancestor, @Nullable DocumentNodeStoreBranch branch) {\n    checkNotNull(branchHead);\n    checkNotNull(ancestor);\n    Branch b = getBranches().getBranch(branchHead);\n    if (b == null) {\n        throw new DocumentStoreException(\"Empty branch cannot be reset\");\n    }\n    if (!b.getCommits().last().equals(branchHead.getRevision(getClusterId()))) {\n        throw new DocumentStoreException(branchHead + \" is not the head \" + \"of a branch\");\n    }\n    if (!b.containsCommit(ancestor.getBranchRevision())) {\n        throw new DocumentStoreException(ancestor + \" is not \" + \"an ancestor revision of \" + branchHead);\n    }\n    if (branchHead.equals(ancestor)) {\n        // trivial\n        return branchHead;\n    }\n    boolean success = false;\n    Commit commit = newCommit(branchHead, branch);\n    try {\n        Iterator<Revision> it = b.getCommits().tailSet(ancestor.getBranchRevision()).iterator();\n        // first revision is the ancestor (tailSet is inclusive)\n        // do not undo changes for this revision\n        it.next();\n        Map<String, UpdateOp> operations = Maps.newHashMap();\n        if (it.hasNext()) {\n            Revision reset = it.next();\n            // TODO: correct?\n            getRoot(b.getCommit(reset).getBase().update(reset)).compareAgainstBaseState(getRoot(ancestor), new ResetDiff(reset.asTrunkRevision(), operations));\n            UpdateOp rootOp = operations.get(\"/\");\n            if (rootOp == null) {\n                rootOp = new UpdateOp(Utils.getIdFromPath(\"/\"), false);\n                NodeDocument.setModified(rootOp, commit.getRevision());\n                operations.put(\"/\", rootOp);\n            }\n            NodeDocument.removeCollision(rootOp, reset.asTrunkRevision());\n            NodeDocument.removeRevision(rootOp, reset.asTrunkRevision());\n        }\n        // update root document first\n        if (store.findAndUpdate(Collection.NODES, operations.get(\"/\")) != null) {\n            // clean up in-memory branch data\n            // first revision is the ancestor (tailSet is inclusive)\n            List<Revision> revs = Lists.newArrayList(b.getCommits().tailSet(ancestor.getBranchRevision()));\n            for (Revision r : revs.subList(1, revs.size())) {\n                b.removeCommit(r);\n            }\n            // successfully updating the root document can be considered\n            // as success because the changes are not marked as committed\n            // anymore\n            success = true;\n        }\n        operations.remove(\"/\");\n        // update remaining documents\n        for (UpdateOp op : operations.values()) {\n            store.findAndUpdate(Collection.NODES, op);\n        }\n    } finally {\n        if (!success) {\n            canceled(commit);\n        } else {\n            done(commit, true, null);\n        }\n    }\n    return ancestor;\n}", "code_comment": NaN, "code_no_comment": "@Nonnull\nRevisionVector reset(@Nonnull RevisionVector branchHead, @Nonnull RevisionVector ancestor, @Nullable DocumentNodeStoreBranch branch) {\n    checkNotNull(branchHead);\n    checkNotNull(ancestor);\n    Branch b = getBranches().getBranch(branchHead);\n    if (b == null) {\n        throw new DocumentStoreException(\"Empty branch cannot be reset\");\n    }\n    if (!b.getCommits().last().equals(branchHead.getRevision(getClusterId()))) {\n        throw new DocumentStoreException(branchHead + \" is not the head \" + \"of a branch\");\n    }\n    if (!b.containsCommit(ancestor.getBranchRevision())) {\n        throw new DocumentStoreException(ancestor + \" is not \" + \"an ancestor revision of \" + branchHead);\n    }\n    if (branchHead.equals(ancestor)) {\n                return branchHead;\n    }\n    boolean success = false;\n    Commit commit = newCommit(branchHead, branch);\n    try {\n        Iterator<Revision> it = b.getCommits().tailSet(ancestor.getBranchRevision()).iterator();\n                        it.next();\n        Map<String, UpdateOp> operations = Maps.newHashMap();\n        if (it.hasNext()) {\n            Revision reset = it.next();\n                        getRoot(b.getCommit(reset).getBase().update(reset)).compareAgainstBaseState(getRoot(ancestor), new ResetDiff(reset.asTrunkRevision(), operations));\n            UpdateOp rootOp = operations.get(\"/\");\n            if (rootOp == null) {\n                rootOp = new UpdateOp(Utils.getIdFromPath(\"/\"), false);\n                NodeDocument.setModified(rootOp, commit.getRevision());\n                operations.put(\"/\", rootOp);\n            }\n            NodeDocument.removeCollision(rootOp, reset.asTrunkRevision());\n            NodeDocument.removeRevision(rootOp, reset.asTrunkRevision());\n        }\n                if (store.findAndUpdate(Collection.NODES, operations.get(\"/\")) != null) {\n                                    List<Revision> revs = Lists.newArrayList(b.getCommits().tailSet(ancestor.getBranchRevision()));\n            for (Revision r : revs.subList(1, revs.size())) {\n                b.removeCommit(r);\n            }\n                                                success = true;\n        }\n        operations.remove(\"/\");\n                for (UpdateOp op : operations.values()) {\n            store.findAndUpdate(Collection.NODES, op);\n        }\n    } finally {\n        if (!success) {\n            canceled(commit);\n        } else {\n            done(commit, true, null);\n        }\n    }\n    return ancestor;\n}", "lc": 1.8636363636363635, "pi": 0.5502392344497605, "ma": 2.0, "nbd": 0.5, "ml": 1.3333333333333333, "d": 0.48611111111111116, "mi": -0.9884425651867509, "fo": 3.75, "r": -0.02631578947368421, "e": 2.3109120981080316}
{"project_name": "Compress", "project_version": 23, "label": 3, "code": "@Override\nInputStream decode(final InputStream in, final Coder coder, byte[] password) throws IOException {\n    byte propsByte = coder.properties[0];\n    long dictSize = coder.properties[1];\n    for (int i = 1; i < 4; i++) {\n        dictSize |= (coder.properties[i + 1] << (8 * i));\n    }\n    if (dictSize > LZMAInputStream.DICT_SIZE_MAX) {\n        throw new IOException(\"Dictionary larger than 4GiB maximum size\");\n    }\n    return new LZMAInputStream(in, -1, propsByte, (int) dictSize);\n}", "code_comment": NaN, "code_no_comment": "@Override\nInputStream decode(final InputStream in, final Coder coder, byte[] password) throws IOException {\n    byte propsByte = coder.properties[0];\n    long dictSize = coder.properties[1];\n    for (int i = 1; i < 4; i++) {\n        dictSize |= (coder.properties[i + 1] << (8 * i));\n    }\n    if (dictSize > LZMAInputStream.DICT_SIZE_MAX) {\n        throw new IOException(\"Dictionary larger than 4GiB maximum size\");\n    }\n    return new LZMAInputStream(in, -1, propsByte, (int) dictSize);\n}", "lc": -0.09090909090909091, "pi": -0.20574162679425848, "ma": 0.0, "nbd": -0.5, "ml": -0.08333333333333333, "d": 1.2222222222222223, "mi": 0.008879492600422766, "fo": -0.5, "r": 0.0, "e": 0.7510036133538491}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2740_429baf4d", "label": 0, "code": "@Override\npublic boolean definesContextRoot(@Nonnull Tree tree) {\n    String name = tree.getName();\n    return POLICY_NODE_NAMES.contains(name) || REP_PERMISSION_STORE.equals(name);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean definesContextRoot(@Nonnull Tree tree) {\n    String name = tree.getName();\n    return POLICY_NODE_NAMES.contains(name) || REP_PERMISSION_STORE.equals(name);\n}", "lc": -0.4090909090909091, "pi": -0.49282296650717716, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.12103174603174605, "mi": 0.6126849894291753, "fo": -0.25, "r": 1.1052631578947367, "e": -0.12289091359646846}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-366_db4a291f", "label": 1, "code": "@Override\npublic void flush(TInfo tinfo, AuthInfo credentials, String lock, String tableId, ByteBuffer startRow, ByteBuffer endRow) {\n    try {\n        checkPermission(credentials, lock, true, \"flush\");\n    } catch (ThriftSecurityException e) {\n        log.error(e, e);\n        throw new RuntimeException(e);\n    }\n    ArrayList<Tablet> tabletsToFlush = new ArrayList<Tablet>();\n    KeyExtent ke = new KeyExtent(new Text(tableId), ByteBufferUtil.toText(endRow), ByteBufferUtil.toText(startRow));\n    synchronized (onlineTablets) {\n        for (Tablet tablet : onlineTablets.values()) if (ke.overlaps(tablet.getExtent()))\n            tabletsToFlush.add(tablet);\n    }\n    Long flushID = null;\n    for (Tablet tablet : tabletsToFlush) {\n        if (flushID == null) {\n            // read the flush id once from zookeeper instead of reading\n            // it for each tablet\n            flushID = tablet.getFlushID();\n        }\n        tablet.flush(flushID);\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void flush(TInfo tinfo, AuthInfo credentials, String lock, String tableId, ByteBuffer startRow, ByteBuffer endRow) {\n    try {\n        checkPermission(credentials, lock, true, \"flush\");\n    } catch (ThriftSecurityException e) {\n        log.error(e, e);\n        throw new RuntimeException(e);\n    }\n    ArrayList<Tablet> tabletsToFlush = new ArrayList<Tablet>();\n    KeyExtent ke = new KeyExtent(new Text(tableId), ByteBufferUtil.toText(endRow), ByteBufferUtil.toText(startRow));\n    synchronized (onlineTablets) {\n        for (Tablet tablet : onlineTablets.values()) if (ke.overlaps(tablet.getExtent()))\n            tabletsToFlush.add(tablet);\n    }\n    Long flushID = null;\n    for (Tablet tablet : tabletsToFlush) {\n        if (flushID == null) {\n                                    flushID = tablet.getFlushID();\n        }\n        tablet.flush(flushID);\n    }\n}", "lc": 0.36363636363636365, "pi": 0.1531100478468899, "ma": 0.6, "nbd": 0.0, "ml": 0.0, "d": 0.0, "mi": -0.3572938689217757, "fo": 0.3333333333333333, "r": -0.02631578947368421, "e": 0.1761910524829561}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-1978_0078c44e", "label": 1, "code": "@Override\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\npublic T deserialize(T reuse, DataInputView source) throws IOException {\n    // handle null values\n    int flags = source.readByte();\n    if ((flags & IS_NULL) != 0) {\n        return null;\n    }\n    Class<?> subclass = null;\n    TypeSerializer subclassSerializer = null;\n    if ((flags & IS_SUBCLASS) != 0) {\n        String subclassName = source.readUTF();\n        try {\n            subclass = Class.forName(subclassName, true, cl);\n        } catch (ClassNotFoundException e) {\n            throw new RuntimeException(\"Cannot instantiate class.\", e);\n        }\n        subclassSerializer = getSubclassSerializer(subclass);\n        if (reuse == null || subclass != reuse.getClass()) {\n            // cannot reuse\n            reuse = (T) subclassSerializer.createInstance();\n            // also initialize fields for which the subclass serializer is not responsible\n            initializeFields(reuse);\n        }\n    } else if ((flags & IS_TAGGED_SUBCLASS) != 0) {\n        int subclassTag = source.readByte();\n        subclassSerializer = registeredSerializers[subclassTag];\n        if (reuse == null || ((PojoSerializer) subclassSerializer).clazz != reuse.getClass()) {\n            // cannot reuse\n            reuse = (T) subclassSerializer.createInstance();\n            // also initialize fields for which the subclass serializer is not responsible\n            initializeFields(reuse);\n        }\n    } else {\n        if (reuse == null || clazz != reuse.getClass()) {\n            reuse = createInstance();\n        }\n    }\n    if ((flags & NO_SUBCLASS) != 0) {\n        try {\n            for (int i = 0; i < numFields; i++) {\n                boolean isNull = source.readBoolean();\n                if (isNull) {\n                    fields[i].set(reuse, null);\n                } else {\n                    Object field = fieldSerializers[i].deserialize(fields[i].get(reuse), source);\n                    fields[i].set(reuse, field);\n                }\n            }\n        } catch (IllegalAccessException e) {\n            throw new RuntimeException(\"Error during POJO copy, this should not happen since we check the fields before.\");\n        }\n    } else {\n        if (subclassSerializer != null) {\n            reuse = (T) subclassSerializer.deserialize(reuse, source);\n        }\n    }\n    return reuse;\n}", "code_comment": NaN, "code_no_comment": "@Override\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\npublic T deserialize(T reuse, DataInputView source) throws IOException {\n        int flags = source.readByte();\n    if ((flags & IS_NULL) != 0) {\n        return null;\n    }\n    Class<?> subclass = null;\n    TypeSerializer subclassSerializer = null;\n    if ((flags & IS_SUBCLASS) != 0) {\n        String subclassName = source.readUTF();\n        try {\n            subclass = Class.forName(subclassName, true, cl);\n        } catch (ClassNotFoundException e) {\n            throw new RuntimeException(\"Cannot instantiate class.\", e);\n        }\n        subclassSerializer = getSubclassSerializer(subclass);\n        if (reuse == null || subclass != reuse.getClass()) {\n                        reuse = (T) subclassSerializer.createInstance();\n                        initializeFields(reuse);\n        }\n    } else if ((flags & IS_TAGGED_SUBCLASS) != 0) {\n        int subclassTag = source.readByte();\n        subclassSerializer = registeredSerializers[subclassTag];\n        if (reuse == null || ((PojoSerializer) subclassSerializer).clazz != reuse.getClass()) {\n                        reuse = (T) subclassSerializer.createInstance();\n                        initializeFields(reuse);\n        }\n    } else {\n        if (reuse == null || clazz != reuse.getClass()) {\n            reuse = createInstance();\n        }\n    }\n    if ((flags & NO_SUBCLASS) != 0) {\n        try {\n            for (int i = 0; i < numFields; i++) {\n                boolean isNull = source.readBoolean();\n                if (isNull) {\n                    fields[i].set(reuse, null);\n                } else {\n                    Object field = fieldSerializers[i].deserialize(fields[i].get(reuse), source);\n                    fields[i].set(reuse, field);\n                }\n            }\n        } catch (IllegalAccessException e) {\n            throw new RuntimeException(\"Error during POJO copy, this should not happen since we check the fields before.\");\n        }\n    } else {\n        if (subclassSerializer != null) {\n            reuse = (T) subclassSerializer.deserialize(reuse, source);\n        }\n    }\n    return reuse;\n}", "lc": 1.8181818181818181, "pi": 0.9282296650717702, "ma": 2.2, "nbd": 1.0, "ml": 1.5, "d": 1.1071428571428572, "mi": -0.9509513742071879, "fo": 1.0833333333333333, "r": -0.02631578947368421, "e": 3.1893063167418725}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5398_19e7c1cd", "label": 3, "code": "/**\n *  Reads and parses markup from an input stream\n *\n *  @param inputStream\n *             The input stream to read and parse\n *  @param encoding\n *             The default character encoding of the input\n *  @throws IOException\n */\n@Override\npublic void parse(final InputStream inputStream, final String encoding) throws IOException {\n    Args.notNull(inputStream, \"inputStream\");\n    try {\n        xmlReader = new XmlReader(new BufferedInputStream(inputStream, 4000), encoding);\n        input = new FullyBufferedReader(xmlReader);\n    } finally {\n        IOUtils.closeQuietly(inputStream);\n        IOUtils.closeQuietly(xmlReader);\n    }\n}", "code_comment": "/**\n *  Reads and parses markup from an input stream\n *\n *  @param inputStream\n *             The input stream to read and parse\n *  @param encoding\n *             The default character encoding of the input\n *  @throws IOException\n */\n", "code_no_comment": "@Override\npublic void parse(final InputStream inputStream, final String encoding) throws IOException {\n    Args.notNull(inputStream, \"inputStream\");\n    try {\n        xmlReader = new XmlReader(new BufferedInputStream(inputStream, 4000), encoding);\n        input = new FullyBufferedReader(xmlReader);\n    } finally {\n        IOUtils.closeQuietly(inputStream);\n        IOUtils.closeQuietly(xmlReader);\n    }\n}", "lc": -0.13636363636363635, "pi": 0.08612440191387546, "ma": -0.6, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.1704016913319239, "fo": -0.25, "r": 1.6842105263157894, "e": -0.16279340490885932}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-8227_54d7fc59", "label": 3, "code": "public boolean process(Exchange exchange, final AsyncCallback callback) {\n    if (!isStarted()) {\n        exchange.setException(new IllegalStateException(\"SendProcessor has not been started: \" + this));\n        callback.done(true);\n        return true;\n    }\n    // we should preserve existing MEP so remember old MEP\n    // if you want to permanently to change the MEP then use .setExchangePattern in the DSL\n    final ExchangePattern existingPattern = exchange.getPattern();\n    // if we have a producer then use that as its optimized\n    if (producer != null) {\n        // record timing for sending the exchange using the producer\n        final StopWatch watch = new StopWatch();\n        final Exchange target = configureExchange(exchange, pattern);\n        EventHelper.notifyExchangeSending(exchange.getContext(), target, destination);\n        LOG.debug(\">>>> {} {}\", destination, exchange);\n        boolean sync = true;\n        try {\n            sync = producer.process(exchange, new AsyncCallback() {\n\n                @Override\n                public void done(boolean doneSync) {\n                    try {\n                        // restore previous MEP\n                        target.setPattern(existingPattern);\n                        // emit event that the exchange was sent to the endpoint\n                        long timeTaken = watch.stop();\n                        EventHelper.notifyExchangeSent(target.getContext(), target, destination, timeTaken);\n                    } finally {\n                        checkException(target);\n                        callback.done(doneSync);\n                    }\n                }\n            });\n        } catch (Throwable throwable) {\n            if (exchange != null) {\n                exchange.setException(throwable);\n                checkException(exchange);\n            }\n        }\n        return sync;\n    }\n    // send the exchange to the destination using the producer cache for the non optimized producers\n    return producerCache.doInAsyncProducer(destination, exchange, pattern, callback, new AsyncProducerCallback() {\n\n        public boolean doInAsyncProducer(Producer producer, AsyncProcessor asyncProducer, final Exchange exchange, ExchangePattern pattern, final AsyncCallback callback) {\n            final Exchange target = configureExchange(exchange, pattern);\n            LOG.debug(\">>>> {} {}\", destination, exchange);\n            return asyncProducer.process(target, new AsyncCallback() {\n\n                public void done(boolean doneSync) {\n                    // restore previous MEP\n                    target.setPattern(existingPattern);\n                    checkException(target);\n                    // signal we are done\n                    callback.done(doneSync);\n                }\n            });\n        }\n    });\n}", "code_comment": NaN, "code_no_comment": "public boolean process(Exchange exchange, final AsyncCallback callback) {\n    if (!isStarted()) {\n        exchange.setException(new IllegalStateException(\"SendProcessor has not been started: \" + this));\n        callback.done(true);\n        return true;\n    }\n            final ExchangePattern existingPattern = exchange.getPattern();\n        if (producer != null) {\n                final StopWatch watch = new StopWatch();\n        final Exchange target = configureExchange(exchange, pattern);\n        EventHelper.notifyExchangeSending(exchange.getContext(), target, destination);\n        LOG.debug(\">>>> {} {}\", destination, exchange);\n        boolean sync = true;\n        try {\n            sync = producer.process(exchange, new AsyncCallback() {\n\n                @Override\n                public void done(boolean doneSync) {\n                    try {\n                                                target.setPattern(existingPattern);\n                                                long timeTaken = watch.stop();\n                        EventHelper.notifyExchangeSent(target.getContext(), target, destination, timeTaken);\n                    } finally {\n                        checkException(target);\n                        callback.done(doneSync);\n                    }\n                }\n            });\n        } catch (Throwable throwable) {\n            if (exchange != null) {\n                exchange.setException(throwable);\n                checkException(exchange);\n            }\n        }\n        return sync;\n    }\n        return producerCache.doInAsyncProducer(destination, exchange, pattern, callback, new AsyncProducerCallback() {\n\n        public boolean doInAsyncProducer(Producer producer, AsyncProcessor asyncProducer, final Exchange exchange, ExchangePattern pattern, final AsyncCallback callback) {\n            final Exchange target = configureExchange(exchange, pattern);\n            LOG.debug(\">>>> {} {}\", destination, exchange);\n            return asyncProducer.process(target, new AsyncCallback() {\n\n                public void done(boolean doneSync) {\n                                        target.setPattern(existingPattern);\n                    checkException(target);\n                                        callback.done(doneSync);\n                }\n            });\n        }\n    });\n}", "lc": 1.5909090909090908, "pi": 1.7559808612440193, "ma": 0.2, "nbd": 1.0, "ml": 0.08333333333333333, "d": 0.6924603174603174, "mi": -0.7995771670190271, "fo": 1.5, "r": -0.02631578947368421, "e": 1.6457553177388584}
{"project_name": "Closure", "project_version": 148, "label": 2, "code": "/**\n * Write any needed entries from the current position to the end of the\n * provided mapping.\n */\nprivate void writeClosedMapping(Mapping m) throws IOException {\n    int nextLine = getAdjustedLine(m.endPosition);\n    int nextCol = getAdjustedCol(m.endPosition);\n    // current line and column position, write it out now.\n    if (line < nextLine || (line == nextLine && col < nextCol)) {\n        writeCharsUpTo(nextLine, nextCol, m.id);\n    }\n}", "code_comment": "/**\n * Write any needed entries from the current position to the end of the\n * provided mapping.\n */\n", "code_no_comment": "private void writeClosedMapping(Mapping m) throws IOException {\n    int nextLine = getAdjustedLine(m.endPosition);\n    int nextCol = getAdjustedCol(m.endPosition);\n        if (line < nextLine || (line == nextLine && col < nextCol)) {\n        writeCharsUpTo(nextLine, nextCol, m.id);\n    }\n}", "lc": -0.3181818181818182, "pi": -0.20574162679425848, "ma": -0.4, "nbd": -0.5, "ml": 0.16666666666666666, "d": 0.31547619047619047, "mi": 0.36067653276955597, "fo": -0.25, "r": 1.8421052631578947, "e": 0.04535882851264673}
{"project_name": "Collections", "project_version": 26, "label": 1, "code": "/**\n * Recalculate the hash code after deserialization. The hash code of some\n * keys might have change (hash codes based on the system hash code are\n * only stable for the same process).\n * @return the instance with recalculated hash code\n */\nprivate Object readResolve() {\n    calculateHashCode(keys);\n    return this;\n}", "code_comment": "/**\n * Recalculate the hash code after deserialization. The hash code of some\n * keys might have change (hash codes based on the system hash code are\n * only stable for the same process).\n * @return the instance with recalculated hash code\n */\n", "code_no_comment": "private Object readResolve() {\n    calculateHashCode(keys);\n    return this;\n}", "lc": -0.45454545454545453, "pi": -0.47368421052631593, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.9785764622973924, "fo": -0.4166666666666667, "r": 2.5, "e": -0.16279340490885932}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-5261_55c2e2d8", "label": 1, "code": "@Override\nprotected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n    int consumers = getAndRemoveParameter(parameters, \"concurrentConsumers\", Integer.class, defaultConcurrentConsumers);\n    boolean limitConcurrentConsumers = getAndRemoveParameter(parameters, \"limitConcurrentConsumers\", Boolean.class, true);\n    if (limitConcurrentConsumers && consumers > maxConcurrentConsumers) {\n        throw new IllegalArgumentException(\"The limitConcurrentConsumers flag in set to true. ConcurrentConsumers cannot be set at a value greater than \" + maxConcurrentConsumers + \" was \" + consumers);\n    }\n    SedaEndpoint answer = new SedaEndpoint(uri, this, createQueue(uri, parameters), consumers);\n    answer.configureProperties(parameters);\n    return answer;\n}", "code_comment": NaN, "code_no_comment": "@Override\nprotected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n    int consumers = getAndRemoveParameter(parameters, \"concurrentConsumers\", Integer.class, defaultConcurrentConsumers);\n    boolean limitConcurrentConsumers = getAndRemoveParameter(parameters, \"limitConcurrentConsumers\", Boolean.class, true);\n    if (limitConcurrentConsumers && consumers > maxConcurrentConsumers) {\n        throw new IllegalArgumentException(\"The limitConcurrentConsumers flag in set to true. ConcurrentConsumers cannot be set at a value greater than \" + maxConcurrentConsumers + \" was \" + consumers);\n    }\n    SedaEndpoint answer = new SedaEndpoint(uri, this, createQueue(uri, parameters), consumers);\n    answer.configureProperties(parameters);\n    return answer;\n}", "lc": -0.13636363636363635, "pi": -0.3301435406698567, "ma": -0.2, "nbd": -0.5, "ml": 0.0, "d": 0.29563492063492064, "mi": 0.05229034531360123, "fo": -0.16666666666666666, "r": -0.02631578947368421, "e": 0.22549402672844518}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5853_b80f6640", "label": 3, "code": "/**\n *  @param locale\n *  @return Returns the numberFormat.\n */\n@Override\npublic NumberFormat getNumberFormat(final Locale locale) {\n    NumberFormat numberFormat = numberFormats.get(locale);\n    if (numberFormat == null) {\n        numberFormat = newNumberFormat(locale);\n        setNumberFormat(locale, numberFormat);\n    }\n    return (NumberFormat) numberFormat.clone();\n}", "code_comment": "/**\n *  @param locale\n *  @return Returns the numberFormat.\n */\n", "code_no_comment": "@Override\npublic NumberFormat getNumberFormat(final Locale locale) {\n    NumberFormat numberFormat = numberFormats.get(locale);\n    if (numberFormat == null) {\n        numberFormat = newNumberFormat(locale);\n        setNumberFormat(locale, numberFormat);\n    }\n    return (NumberFormat) numberFormat.clone();\n}", "lc": -0.22727272727272727, "pi": -0.01913875598086126, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": -0.029761904761904788, "mi": 0.2896405919661735, "fo": -0.16666666666666666, "r": 1.4999999999999998, "e": -0.08658909769886412}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5147_184e51e9", "label": 1, "code": "/**\n *  @see javax.servlet.Filter#destroy()\n */\n@Override\npublic void destroy() {\n    if (application != null) {\n        try {\n            ThreadContext.setApplication(application);\n            application.internalDestroy();\n        } finally {\n            ThreadContext.detach();\n            application = null;\n        }\n    }\n    if (applicationFactory != null) {\n        applicationFactory.destroy(this);\n    }\n}", "code_comment": "/**\n *  @see javax.servlet.Filter#destroy()\n */\n", "code_no_comment": "@Override\npublic void destroy() {\n    if (application != null) {\n        try {\n            ThreadContext.setApplication(application);\n            application.internalDestroy();\n        } finally {\n            ThreadContext.detach();\n            application = null;\n        }\n    }\n    if (applicationFactory != null) {\n        applicationFactory.destroy(this);\n    }\n}", "lc": 0.045454545454545456, "pi": 0.6411483253588517, "ma": -0.2, "nbd": 0.0, "ml": -0.08333333333333333, "d": -0.007936507936507943, "mi": 0.08809020436927412, "fo": -0.16666666666666666, "r": 1.1842105263157894, "e": -0.10031868974141755}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1877_716e1237", "label": 0, "code": "private static CommitHook newCommitHook(final String name, final String checkpoint) {\n    return new CompositeHook(new ConflictHook(new AnnotatingConflictHandler()), new EditorHook(new ConflictValidatorProvider()), new CommitHook() {\n\n        @Override\n        @Nonnull\n        public NodeState processCommit(NodeState before, NodeState after, CommitInfo info) throws CommitFailedException {\n            // check for concurrent updates by this async task\n            String checkpointAfterRebase = before.getChildNode(ASYNC).getString(name);\n            if (Objects.equal(checkpoint, checkpointAfterRebase)) {\n                return postAsyncRunNodeStatus(after.builder(), name).getNodeState();\n            } else {\n                throw CONCURRENT_UPDATE;\n            }\n        }\n    });\n}", "code_comment": NaN, "code_no_comment": "private static CommitHook newCommitHook(final String name, final String checkpoint) {\n    return new CompositeHook(new ConflictHook(new AnnotatingConflictHandler()), new EditorHook(new ConflictValidatorProvider()), new CommitHook() {\n\n        @Override\n        @Nonnull\n        public NodeState processCommit(NodeState before, NodeState after, CommitInfo info) throws CommitFailedException {\n                        String checkpointAfterRebase = before.getChildNode(ASYNC).getString(name);\n            if (Objects.equal(checkpoint, checkpointAfterRebase)) {\n                return postAsyncRunNodeStatus(after.builder(), name).getNodeState();\n            } else {\n                throw CONCURRENT_UPDATE;\n            }\n        }\n    });\n}", "lc": 0.0, "pi": 0.9521531100478471, "ma": -0.2, "nbd": 0.0, "ml": -0.08333333333333333, "d": -0.3650793650793651, "mi": -0.029457364341085313, "fo": 0.0, "r": -0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-499_61381ea2", "label": 3, "code": "private StaticOperandImpl parseStaticOperand() throws ParseException {\n    if (currentTokenType == PLUS) {\n        read();\n    } else if (currentTokenType == MINUS) {\n        read();\n        if (currentTokenType != VALUE) {\n            throw getSyntaxError(\"number\");\n        }\n        int valueType = currentValue.getType().tag();\n        switch(valueType) {\n            case PropertyType.LONG:\n                currentValue = PropertyValues.newLong(-currentValue.getValue(Type.LONG));\n                break;\n            case PropertyType.DOUBLE:\n                currentValue = PropertyValues.newDouble(-currentValue.getValue(Type.DOUBLE));\n                break;\n            case PropertyType.BOOLEAN:\n                currentValue = PropertyValues.newBoolean(!currentValue.getValue(Type.BOOLEAN));\n                break;\n            case PropertyType.DECIMAL:\n                currentValue = PropertyValues.newDecimal(currentValue.getValue(Type.DECIMAL).negate());\n                break;\n            default:\n                throw getSyntaxError(\"Illegal operation: -\" + currentValue);\n        }\n    }\n    if (currentTokenType == VALUE) {\n        LiteralImpl literal = getUncastLiteral(currentValue);\n        read();\n        return literal;\n    } else if (currentTokenType == PARAMETER) {\n        read();\n        String name = readName();\n        if (readIf(\":\")) {\n            name = name + ':' + readName();\n        }\n        BindVariableValueImpl var = bindVariables.get(name);\n        if (var == null) {\n            var = factory.bindVariable(name);\n            bindVariables.put(name, var);\n        }\n        return var;\n    } else if (readIf(\"TRUE\")) {\n        LiteralImpl literal = getUncastLiteral(PropertyValues.newBoolean(true));\n        return literal;\n    } else if (readIf(\"FALSE\")) {\n        LiteralImpl literal = getUncastLiteral(PropertyValues.newBoolean(false));\n        return literal;\n    } else if (readIf(\"CAST\")) {\n        read(\"(\");\n        StaticOperandImpl op = parseStaticOperand();\n        if (!(op instanceof LiteralImpl)) {\n            throw getSyntaxError(\"literal\");\n        }\n        LiteralImpl literal = (LiteralImpl) op;\n        PropertyValue value = literal.getLiteralValue();\n        read(\"AS\");\n        value = parseCastAs(value);\n        read(\")\");\n        // CastLiteral\n        literal = factory.literal(value);\n        return literal;\n    } else {\n        if (supportSQL1) {\n            if (readIf(\"TIMESTAMP\")) {\n                StaticOperandImpl op = parseStaticOperand();\n                if (!(op instanceof LiteralImpl)) {\n                    throw getSyntaxError(\"literal\");\n                }\n                LiteralImpl literal = (LiteralImpl) op;\n                PropertyValue value = literal.getLiteralValue();\n                value = PropertyValues.newDate(value.getValue(Type.STRING));\n                literal = factory.literal(value);\n                return literal;\n            }\n        }\n        throw getSyntaxError(\"static operand\");\n    }\n}", "code_comment": NaN, "code_no_comment": "private StaticOperandImpl parseStaticOperand() throws ParseException {\n    if (currentTokenType == PLUS) {\n        read();\n    } else if (currentTokenType == MINUS) {\n        read();\n        if (currentTokenType != VALUE) {\n            throw getSyntaxError(\"number\");\n        }\n        int valueType = currentValue.getType().tag();\n        switch(valueType) {\n            case PropertyType.LONG:\n                currentValue = PropertyValues.newLong(-currentValue.getValue(Type.LONG));\n                break;\n            case PropertyType.DOUBLE:\n                currentValue = PropertyValues.newDouble(-currentValue.getValue(Type.DOUBLE));\n                break;\n            case PropertyType.BOOLEAN:\n                currentValue = PropertyValues.newBoolean(!currentValue.getValue(Type.BOOLEAN));\n                break;\n            case PropertyType.DECIMAL:\n                currentValue = PropertyValues.newDecimal(currentValue.getValue(Type.DECIMAL).negate());\n                break;\n            default:\n                throw getSyntaxError(\"Illegal operation: -\" + currentValue);\n        }\n    }\n    if (currentTokenType == VALUE) {\n        LiteralImpl literal = getUncastLiteral(currentValue);\n        read();\n        return literal;\n    } else if (currentTokenType == PARAMETER) {\n        read();\n        String name = readName();\n        if (readIf(\":\")) {\n            name = name + ':' + readName();\n        }\n        BindVariableValueImpl var = bindVariables.get(name);\n        if (var == null) {\n            var = factory.bindVariable(name);\n            bindVariables.put(name, var);\n        }\n        return var;\n    } else if (readIf(\"TRUE\")) {\n        LiteralImpl literal = getUncastLiteral(PropertyValues.newBoolean(true));\n        return literal;\n    } else if (readIf(\"FALSE\")) {\n        LiteralImpl literal = getUncastLiteral(PropertyValues.newBoolean(false));\n        return literal;\n    } else if (readIf(\"CAST\")) {\n        read(\"(\");\n        StaticOperandImpl op = parseStaticOperand();\n        if (!(op instanceof LiteralImpl)) {\n            throw getSyntaxError(\"literal\");\n        }\n        LiteralImpl literal = (LiteralImpl) op;\n        PropertyValue value = literal.getLiteralValue();\n        read(\"AS\");\n        value = parseCastAs(value);\n        read(\")\");\n                literal = factory.literal(value);\n        return literal;\n    } else {\n        if (supportSQL1) {\n            if (readIf(\"TIMESTAMP\")) {\n                StaticOperandImpl op = parseStaticOperand();\n                if (!(op instanceof LiteralImpl)) {\n                    throw getSyntaxError(\"literal\");\n                }\n                LiteralImpl literal = (LiteralImpl) op;\n                PropertyValue value = literal.getLiteralValue();\n                value = PropertyValues.newDate(value.getValue(Type.STRING));\n                literal = factory.literal(value);\n                return literal;\n            }\n        }\n        throw getSyntaxError(\"static operand\");\n    }\n}", "lc": 2.909090909090909, "pi": 0.6411483253588517, "ma": 5.0, "nbd": 3.0, "ml": 1.9166666666666667, "d": 1.2718253968253967, "mi": -1.250317124735729, "fo": 3.4166666666666665, "r": -0.02631578947368421, "e": 4.7562317387320405}
{"project_name": "Lang", "project_version": 28, "label": 3, "code": "/**\n * {@inheritDoc}\n */\n@Override\npublic int translate(CharSequence input, int index, Writer out) throws IOException {\n    // TODO: Protect from ArrayIndexOutOfBounds\n    if (input.charAt(index) == '&' && input.charAt(index + 1) == '#') {\n        int start = index + 2;\n        boolean isHex = false;\n        char firstChar = input.charAt(start);\n        if (firstChar == 'x' || firstChar == 'X') {\n            start++;\n            isHex = true;\n        }\n        int end = start;\n        while (input.charAt(end) != ';') {\n            end++;\n        }\n        int entityValue;\n        try {\n            if (isHex) {\n                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);\n            } else {\n                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);\n            }\n        } catch (NumberFormatException nfe) {\n            return 0;\n        }\n        out.write(entityValue);\n        return 2 + (end - start) + (isHex ? 1 : 0) + 1;\n    }\n    return 0;\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "@Override\npublic int translate(CharSequence input, int index, Writer out) throws IOException {\n        if (input.charAt(index) == '&' && input.charAt(index + 1) == '#') {\n        int start = index + 2;\n        boolean isHex = false;\n        char firstChar = input.charAt(start);\n        if (firstChar == 'x' || firstChar == 'X') {\n            start++;\n            isHex = true;\n        }\n        int end = start;\n        while (input.charAt(end) != ';') {\n            end++;\n        }\n        int entityValue;\n        try {\n            if (isHex) {\n                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);\n            } else {\n                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);\n            }\n        } catch (NumberFormatException nfe) {\n            return 0;\n        }\n        out.write(entityValue);\n        return 2 + (end - start) + (isHex ? 1 : 0) + 1;\n    }\n    return 0;\n}", "lc": 0.6818181818181818, "pi": 0.5119617224880381, "ma": 0.6, "nbd": 0.5, "ml": 0.75, "d": 1.3849206349206349, "mi": -0.5199436222692033, "fo": 0.4166666666666667, "r": 0.0, "e": 1.9210940336439544}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-949_f83bbc1d", "label": 1, "code": "/**\n * {@inheritDoc}\n */\n@Override\npublic PointVectorValuePair doOptimize() {\n    checkParameters();\n    final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker();\n    // Computation will be useless without a checker (see \"for-loop\").\n    if (checker == null) {\n        throw new NullArgumentException();\n    }\n    final double[] targetValues = getTarget();\n    // Number of observed data.\n    final int nR = targetValues.length;\n    final RealMatrix weightMatrix = getWeight();\n    // Diagonal of the weight matrix.\n    final double[] residualsWeights = new double[nR];\n    for (int i = 0; i < nR; i++) {\n        residualsWeights[i] = weightMatrix.getEntry(i, i);\n    }\n    final double[] currentPoint = getStartPoint();\n    final int nC = currentPoint.length;\n    // iterate until convergence is reached\n    PointVectorValuePair current = null;\n    int iter = 0;\n    for (boolean converged = false; !converged; ) {\n        ++iter;\n        // evaluate the objective function and its jacobian\n        PointVectorValuePair previous = current;\n        // Value of the objective function at \"currentPoint\".\n        final double[] currentObjective = computeObjectiveValue(currentPoint);\n        final double[] currentResiduals = computeResiduals(currentObjective);\n        final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n        current = new PointVectorValuePair(currentPoint, currentObjective);\n        // build the linear problem\n        final double[] b = new double[nC];\n        final double[][] a = new double[nC][nC];\n        for (int i = 0; i < nR; ++i) {\n            final double[] grad = weightedJacobian.getRow(i);\n            final double weight = residualsWeights[i];\n            final double residual = currentResiduals[i];\n            // compute the normal equation\n            final double wr = weight * residual;\n            for (int j = 0; j < nC; ++j) {\n                b[j] += wr * grad[j];\n            }\n            // build the contribution matrix for measurement i\n            for (int k = 0; k < nC; ++k) {\n                double[] ak = a[k];\n                double wgk = weight * grad[k];\n                for (int l = 0; l < nC; ++l) {\n                    ak[l] += wgk * grad[l];\n                }\n            }\n        }\n        try {\n            // solve the linearized least squares problem\n            RealMatrix mA = new BlockRealMatrix(a);\n            DecompositionSolver solver = useLU ? new LUDecomposition(mA).getSolver() : new QRDecomposition(mA).getSolver();\n            final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n            // update the estimated parameters\n            for (int i = 0; i < nC; ++i) {\n                currentPoint[i] += dX[i];\n            }\n        } catch (SingularMatrixException e) {\n            throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n        }\n        // Check convergence.\n        if (previous != null) {\n            converged = checker.converged(iter, previous, current);\n            if (converged) {\n                setCost(computeCost(currentResiduals));\n                return current;\n            }\n        }\n    }\n    // Must never happen.\n    throw new MathInternalError();\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "@Override\npublic PointVectorValuePair doOptimize() {\n    checkParameters();\n    final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker();\n        if (checker == null) {\n        throw new NullArgumentException();\n    }\n    final double[] targetValues = getTarget();\n        final int nR = targetValues.length;\n    final RealMatrix weightMatrix = getWeight();\n        final double[] residualsWeights = new double[nR];\n    for (int i = 0; i < nR; i++) {\n        residualsWeights[i] = weightMatrix.getEntry(i, i);\n    }\n    final double[] currentPoint = getStartPoint();\n    final int nC = currentPoint.length;\n        PointVectorValuePair current = null;\n    int iter = 0;\n    for (boolean converged = false; !converged; ) {\n        ++iter;\n                PointVectorValuePair previous = current;\n                final double[] currentObjective = computeObjectiveValue(currentPoint);\n        final double[] currentResiduals = computeResiduals(currentObjective);\n        final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n        current = new PointVectorValuePair(currentPoint, currentObjective);\n                final double[] b = new double[nC];\n        final double[][] a = new double[nC][nC];\n        for (int i = 0; i < nR; ++i) {\n            final double[] grad = weightedJacobian.getRow(i);\n            final double weight = residualsWeights[i];\n            final double residual = currentResiduals[i];\n                        final double wr = weight * residual;\n            for (int j = 0; j < nC; ++j) {\n                b[j] += wr * grad[j];\n            }\n                        for (int k = 0; k < nC; ++k) {\n                double[] ak = a[k];\n                double wgk = weight * grad[k];\n                for (int l = 0; l < nC; ++l) {\n                    ak[l] += wgk * grad[l];\n                }\n            }\n        }\n        try {\n                        RealMatrix mA = new BlockRealMatrix(a);\n            DecompositionSolver solver = useLU ? new LUDecomposition(mA).getSolver() : new QRDecomposition(mA).getSolver();\n            final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                        for (int i = 0; i < nC; ++i) {\n                currentPoint[i] += dX[i];\n            }\n        } catch (SingularMatrixException e) {\n            throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n        }\n                if (previous != null) {\n            converged = checker.converged(iter, previous, current);\n            if (converged) {\n                setCost(computeCost(currentResiduals));\n                return current;\n            }\n        }\n    }\n        throw new MathInternalError();\n}", "lc": 2.227272727272727, "pi": 0.7846889952153109, "ma": 2.4, "nbd": 1.0, "ml": 1.3333333333333333, "d": 1.6130952380952381, "mi": -1.0794926004228327, "fo": 0.9166666666666666, "r": -0.02631578947368421, "e": 6.250604242665236}
{"project_name": "JxPath", "project_version": 9, "label": 1, "code": "public Object computeValue(EvalContext context) {\n    return equal(context, args[0], args[1]) ? Boolean.FALSE : Boolean.TRUE;\n}", "code_comment": NaN, "code_no_comment": "public Object computeValue(EvalContext context) {\n    return equal(context, args[0], args[1]) ? Boolean.FALSE : Boolean.TRUE;\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.4, "nbd": -1.0, "ml": -0.16666666666666666, "d": -0.3650793650793651, "mi": 0.8787878787878789, "fo": -0.4166666666666667, "r": 0.0, "e": -0.16279340490885932}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5770_cf6172bd", "label": 1, "code": "@Override\npublic PageParameters decodePageParameters(final Url url) {\n    PageParameters parameters = new PageParameters();\n    int i = 0;\n    for (String s : url.getSegments()) {\n        parameters.set(i, s);\n        ++i;\n    }\n    for (QueryParameter p : url.getQueryParameters()) {\n        parameters.add(p.getName(), p.getValue(), INamedParameters.Type.QUERY_STRING);\n    }\n    return parameters.isEmpty() ? null : parameters;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic PageParameters decodePageParameters(final Url url) {\n    PageParameters parameters = new PageParameters();\n    int i = 0;\n    for (String s : url.getSegments()) {\n        parameters.set(i, s);\n        ++i;\n    }\n    for (QueryParameter p : url.getQueryParameters()) {\n        parameters.add(p.getName(), p.getValue(), INamedParameters.Type.QUERY_STRING);\n    }\n    return parameters.isEmpty() ? null : parameters;\n}", "lc": -0.045454545454545456, "pi": -0.1291866028708134, "ma": 0.0, "nbd": -0.5, "ml": -0.25, "d": -0.059523809523809534, "mi": 0.012825933756166263, "fo": 0.08333333333333333, "r": -0.02631578947368421, "e": -0.029158094316027266}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1254_25a70439", "label": 1, "code": "void backgroundRead() {\n    String id = Utils.getIdFromPath(\"/\");\n    NodeDocument doc = store.find(Collection.NODES, id, asyncDelay);\n    if (doc == null) {\n        return;\n    }\n    Map<Integer, Revision> lastRevMap = doc.getLastRev();\n    Revision.RevisionComparator revisionComparator = getRevisionComparator();\n    boolean hasNewRevisions = false;\n    // the (old) head occurred first\n    Revision headSeen = Revision.newRevision(0);\n    // then we saw this new revision (from another cluster node)\n    Revision otherSeen = Revision.newRevision(0);\n    for (Map.Entry<Integer, Revision> e : lastRevMap.entrySet()) {\n        int machineId = e.getKey();\n        if (machineId == clusterId) {\n            continue;\n        }\n        Revision r = e.getValue();\n        Revision last = lastKnownRevision.get(machineId);\n        if (last == null || r.compareRevisionTime(last) > 0) {\n            lastKnownRevision.put(machineId, r);\n            hasNewRevisions = true;\n            revisionComparator.add(r, otherSeen);\n        }\n    }\n    if (hasNewRevisions) {\n        store.invalidateCache();\n        // TODO only invalidate affected items\n        docChildrenCache.invalidateAll();\n        // add a new revision, so that changes are visible\n        Revision r = Revision.newRevision(clusterId);\n        // the latest revisions of the current cluster node\n        // happened before the latest revisions of other cluster nodes\n        revisionComparator.add(r, headSeen);\n        // the head revision is after other revisions\n        setHeadRevision(Revision.newRevision(clusterId));\n    }\n    revisionComparator.purge(Revision.getCurrentTimestamp() - REMEMBER_REVISION_ORDER_MILLIS);\n}", "code_comment": NaN, "code_no_comment": "void backgroundRead() {\n    String id = Utils.getIdFromPath(\"/\");\n    NodeDocument doc = store.find(Collection.NODES, id, asyncDelay);\n    if (doc == null) {\n        return;\n    }\n    Map<Integer, Revision> lastRevMap = doc.getLastRev();\n    Revision.RevisionComparator revisionComparator = getRevisionComparator();\n    boolean hasNewRevisions = false;\n        Revision headSeen = Revision.newRevision(0);\n        Revision otherSeen = Revision.newRevision(0);\n    for (Map.Entry<Integer, Revision> e : lastRevMap.entrySet()) {\n        int machineId = e.getKey();\n        if (machineId == clusterId) {\n            continue;\n        }\n        Revision r = e.getValue();\n        Revision last = lastKnownRevision.get(machineId);\n        if (last == null || r.compareRevisionTime(last) > 0) {\n            lastKnownRevision.put(machineId, r);\n            hasNewRevisions = true;\n            revisionComparator.add(r, otherSeen);\n        }\n    }\n    if (hasNewRevisions) {\n        store.invalidateCache();\n                docChildrenCache.invalidateAll();\n                Revision r = Revision.newRevision(clusterId);\n                        revisionComparator.add(r, headSeen);\n                setHeadRevision(Revision.newRevision(clusterId));\n    }\n    revisionComparator.purge(Revision.getCurrentTimestamp() - REMEMBER_REVISION_ORDER_MILLIS);\n}", "lc": 0.8636363636363636, "pi": 0.06220095693779899, "ma": 0.6, "nbd": 0.0, "ml": 0.5, "d": 0.40476190476190477, "mi": -0.6202959830866804, "fo": 1.25, "r": -0.02631578947368421, "e": 1.0533727517389624}
{"project_name": "Lang", "project_version": 51, "label": 1, "code": "// String to boolean methods\n// -----------------------------------------------------------------------\n/**\n * <p>Converts a String to a boolean (optimised for performance).</p>\n *\n * <p><code>'true'</code>, <code>'on'</code> or <code>'yes'</code>\n * (case insensitive) will return <code>true</code>. Otherwise,\n * <code>false</code> is returned.</p>\n *\n * <p>This method performs 4 times faster (JDK1.4) than\n * <code>Boolean.valueOf(String)</code>. However, this method accepts\n * 'on' and 'yes' as true values.\n *\n * <pre>\n *   BooleanUtils.toBoolean(null)    = false\n *   BooleanUtils.toBoolean(\"true\")  = true\n *   BooleanUtils.toBoolean(\"TRUE\")  = true\n *   BooleanUtils.toBoolean(\"tRUe\")  = true\n *   BooleanUtils.toBoolean(\"on\")    = true\n *   BooleanUtils.toBoolean(\"yes\")   = true\n *   BooleanUtils.toBoolean(\"false\") = false\n *   BooleanUtils.toBoolean(\"x gti\") = false\n * </pre>\n *\n * @param str  the String to check\n * @return the boolean value of the string, <code>false</code> if no match\n */\npublic static boolean toBoolean(String str) {\n    // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower.\n    if (str == \"true\") {\n        return true;\n    }\n    if (str == null) {\n        return false;\n    }\n    switch(str.length()) {\n        case 2:\n            {\n                char ch0 = str.charAt(0);\n                char ch1 = str.charAt(1);\n                return (ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N');\n            }\n        case 3:\n            {\n                char ch = str.charAt(0);\n                if (ch == 'y') {\n                    return (str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S');\n                }\n                if (ch == 'Y') {\n                    return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) == 's');\n                }\n            }\n        case 4:\n            {\n                char ch = str.charAt(0);\n                if (ch == 't') {\n                    return (str.charAt(1) == 'r' || str.charAt(1) == 'R') && (str.charAt(2) == 'u' || str.charAt(2) == 'U') && (str.charAt(3) == 'e' || str.charAt(3) == 'E');\n                }\n                if (ch == 'T') {\n                    return (str.charAt(1) == 'R' || str.charAt(1) == 'r') && (str.charAt(2) == 'U' || str.charAt(2) == 'u') && (str.charAt(3) == 'E' || str.charAt(3) == 'e');\n                }\n            }\n    }\n    return false;\n}", "code_comment": "/**\n * <p>Converts a String to a boolean (optimised for performance).</p>\n *\n * <p><code>'true'</code>, <code>'on'</code> or <code>'yes'</code>\n * (case insensitive) will return <code>true</code>. Otherwise,\n * <code>false</code> is returned.</p>\n *\n * <p>This method performs 4 times faster (JDK1.4) than\n * <code>Boolean.valueOf(String)</code>. However, this method accepts\n * 'on' and 'yes' as true values.\n *\n * <pre>\n *   BooleanUtils.toBoolean(null)    = false\n *   BooleanUtils.toBoolean(\"true\")  = true\n *   BooleanUtils.toBoolean(\"TRUE\")  = true\n *   BooleanUtils.toBoolean(\"tRUe\")  = true\n *   BooleanUtils.toBoolean(\"on\")    = true\n *   BooleanUtils.toBoolean(\"yes\")   = true\n *   BooleanUtils.toBoolean(\"false\") = false\n *   BooleanUtils.toBoolean(\"x gti\") = false\n * </pre>\n *\n * @param str  the String to check\n * @return the boolean value of the string, <code>false</code> if no match\n */\n", "code_no_comment": "public static boolean toBoolean(String str) {\n        if (str == \"true\") {\n        return true;\n    }\n    if (str == null) {\n        return false;\n    }\n    switch(str.length()) {\n        case 2:\n            {\n                char ch0 = str.charAt(0);\n                char ch1 = str.charAt(1);\n                return (ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N');\n            }\n        case 3:\n            {\n                char ch = str.charAt(0);\n                if (ch == 'y') {\n                    return (str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S');\n                }\n                if (ch == 'Y') {\n                    return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) == 's');\n                }\n            }\n        case 4:\n            {\n                char ch = str.charAt(0);\n                if (ch == 't') {\n                    return (str.charAt(1) == 'r' || str.charAt(1) == 'R') && (str.charAt(2) == 'u' || str.charAt(2) == 'U') && (str.charAt(3) == 'e' || str.charAt(3) == 'E');\n                }\n                if (ch == 'T') {\n                    return (str.charAt(1) == 'R' || str.charAt(1) == 'r') && (str.charAt(2) == 'U' || str.charAt(2) == 'u') && (str.charAt(3) == 'E' || str.charAt(3) == 'e');\n                }\n            }\n    }\n    return false;\n}", "lc": 1.0454545454545454, "pi": 1.3779904306220097, "ma": 1.2, "nbd": 0.5, "ml": 0.5833333333333334, "d": 1.1746031746031746, "mi": -0.7384073291050032, "fo": 1.5833333333333333, "r": -0.02631578947368421, "e": 3.1722711110342714}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1661_13eb19c2", "label": 1, "code": "/**\n * Gets the columns to be mapped over from this job.\n *\n * @param implementingClass\n *          the class whose name will be used as a prefix for the property configuration key\n * @param conf\n *          the Hadoop configuration object to configure\n * @return a set of columns\n * @since 1.5.0\n * @see #fetchColumns(Class, Configuration, Collection)\n */\npublic static Set<Pair<Text, Text>> getFetchedColumns(Class<?> implementingClass, Configuration conf) {\n    ArgumentChecker.notNull(conf);\n    return deserializeFetchedColumns(conf.getStringCollection(enumToConfKey(implementingClass, ScanOpts.COLUMNS)));\n}", "code_comment": "/**\n * Gets the columns to be mapped over from this job.\n *\n * @param implementingClass\n *          the class whose name will be used as a prefix for the property configuration key\n * @param conf\n *          the Hadoop configuration object to configure\n * @return a set of columns\n * @since 1.5.0\n * @see #fetchColumns(Class, Configuration, Collection)\n */\n", "code_no_comment": "public static Set<Pair<Text, Text>> getFetchedColumns(Class<?> implementingClass, Configuration conf) {\n    ArgumentChecker.notNull(conf);\n    return deserializeFetchedColumns(conf.getStringCollection(enumToConfKey(implementingClass, ScanOpts.COLUMNS)));\n}", "lc": -0.45454545454545453, "pi": -0.47368421052631593, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.6958421423537702, "fo": -0.16666666666666666, "r": 2.1842105263157894, "e": -0.16279340490885932}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-8146_17475d80", "label": 3, "code": "@Override\nprotected void doShutdown() throws Exception {\n    if (shutdownExecutor && scheduledExecutorService != null) {\n        getCamelContext().getExecutorServiceManager().shutdownNow(scheduledExecutorService);\n        scheduledExecutorService = null;\n        future = null;\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\nprotected void doShutdown() throws Exception {\n    if (shutdownExecutor && scheduledExecutorService != null) {\n        getCamelContext().getExecutorServiceManager().shutdownNow(scheduledExecutorService);\n        scheduledExecutorService = null;\n        future = null;\n    }\n}", "lc": -0.2727272727272727, "pi": 0.22488038277511951, "ma": -0.4, "nbd": -0.5, "ml": -0.08333333333333333, "d": -0.09523809523809523, "mi": 0.3874559548978154, "fo": -0.25, "r": 0.5526315789473684, "e": -0.11731240239046119}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-5187_8cadc344", "label": 3, "code": "private void registerMBeanWithServer(Object obj, ObjectName name, boolean forceRegistration) throws JMException {\n    // have we already registered the bean, there can be shared instances in the camel routes\n    boolean exists = server.isRegistered(name);\n    if (exists) {\n        if (forceRegistration) {\n            LOG.info(\"ForceRegistration enabled, unregistering existing MBean with ObjectName: {}\", name);\n            server.unregisterMBean(name);\n        } else {\n            // okay ignore we do not want to force it and it could be a shared instance\n            LOG.debug(\"MBean already registered with ObjectName: {}\", name);\n        }\n    }\n    // register bean if by force or not exists\n    ObjectInstance instance = null;\n    if (forceRegistration || !exists) {\n        LOG.trace(\"Registering MBean with ObjectName: {}\", name);\n        instance = server.registerMBean(obj, name);\n    }\n    // need to use the name returned from the server as some JEE servers may modify the name\n    if (instance != null) {\n        ObjectName registeredName = instance.getObjectName();\n        LOG.debug(\"Registered MBean with ObjectName: {}\", registeredName);\n        mbeansRegistered.add(registeredName);\n    }\n}", "code_comment": NaN, "code_no_comment": "private void registerMBeanWithServer(Object obj, ObjectName name, boolean forceRegistration) throws JMException {\n        boolean exists = server.isRegistered(name);\n    if (exists) {\n        if (forceRegistration) {\n            LOG.info(\"ForceRegistration enabled, unregistering existing MBean with ObjectName: {}\", name);\n            server.unregisterMBean(name);\n        } else {\n                        LOG.debug(\"MBean already registered with ObjectName: {}\", name);\n        }\n    }\n        ObjectInstance instance = null;\n    if (forceRegistration || !exists) {\n        LOG.trace(\"Registering MBean with ObjectName: {}\", name);\n        instance = server.registerMBean(obj, name);\n    }\n        if (instance != null) {\n        ObjectName registeredName = instance.getObjectName();\n        LOG.debug(\"Registered MBean with ObjectName: {}\", registeredName);\n        mbeansRegistered.add(registeredName);\n    }\n}", "lc": 0.3181818181818182, "pi": 0.1961722488038276, "ma": 0.2, "nbd": 0.0, "ml": 0.25, "d": 0.371031746031746, "mi": -0.278646934460888, "fo": 0.25, "r": -0.02631578947368421, "e": 0.34236614166421736}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-3760_494212b3", "label": 0, "code": "private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n    // read the non-transient fields\n    in.defaultReadObject();\n    // read the default value field\n    boolean hasDefaultValue = in.readBoolean();\n    if (hasDefaultValue) {\n        int size = in.readInt();\n        byte[] buffer = new byte[size];\n        int bytesRead = in.read(buffer);\n        if (bytesRead != size) {\n            throw new RuntimeException(\"Read size does not match expected size.\");\n        }\n        try (ByteArrayInputStream bais = new ByteArrayInputStream(buffer);\n            DataInputViewStreamWrapper inView = new DataInputViewStreamWrapper(bais)) {\n            defaultValue = serializer.deserialize(inView);\n        } catch (Exception e) {\n            throw new IOException(\"Unable to deserialize default value.\", e);\n        }\n    } else {\n        defaultValue = null;\n    }\n}", "code_comment": NaN, "code_no_comment": "private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        boolean hasDefaultValue = in.readBoolean();\n    if (hasDefaultValue) {\n        int size = in.readInt();\n        byte[] buffer = new byte[size];\n        int bytesRead = in.read(buffer);\n        if (bytesRead != size) {\n            throw new RuntimeException(\"Read size does not match expected size.\");\n        }\n        try (ByteArrayInputStream bais = new ByteArrayInputStream(buffer);\n            DataInputViewStreamWrapper inView = new DataInputViewStreamWrapper(bais)) {\n            defaultValue = serializer.deserialize(inView);\n        } catch (Exception e) {\n            throw new IOException(\"Unable to deserialize default value.\", e);\n        }\n    } else {\n        defaultValue = null;\n    }\n}", "lc": 0.2727272727272727, "pi": 0.26794258373205726, "ma": 0.4, "nbd": 0.0, "ml": 0.0, "d": -0.06746031746031747, "mi": -0.2076109936575051, "fo": -0.08333333333333333, "r": 0.05263157894736841, "e": -0.023017121649579596}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3019_5135cf4b", "label": 1, "code": "private boolean setVersionablePath(PropertyState after) {\n    if (JcrConstants.JCR_VERSIONHISTORY.equals(after.getName()) && nodeAfter.isVersionable(versionManager)) {\n        NodeBuilder vhBuilder;\n        try {\n            vhBuilder = versionManager.getOrCreateVersionHistory(nodeAfter.builder, Collections.EMPTY_MAP);\n        } catch (CommitFailedException e) {\n            exceptions.add(e);\n            // stop further comparison\n            return false;\n        }\n        if (!vhBuilder.hasProperty(JcrConstants.JCR_MIXINTYPES)) {\n            vhBuilder.setProperty(JcrConstants.JCR_MIXINTYPES, ImmutableSet.of(MIX_REP_VERSIONABLE_PATHS), Type.NAMES);\n        }\n        String versionablePath = nodeAfter.path;\n        vhBuilder.setProperty(workspaceName, versionablePath, Type.PATH);\n    }\n    return true;\n}", "code_comment": NaN, "code_no_comment": "private boolean setVersionablePath(PropertyState after) {\n    if (JcrConstants.JCR_VERSIONHISTORY.equals(after.getName()) && nodeAfter.isVersionable(versionManager)) {\n        NodeBuilder vhBuilder;\n        try {\n            vhBuilder = versionManager.getOrCreateVersionHistory(nodeAfter.builder, Collections.EMPTY_MAP);\n        } catch (CommitFailedException e) {\n            exceptions.add(e);\n                        return false;\n        }\n        if (!vhBuilder.hasProperty(JcrConstants.JCR_MIXINTYPES)) {\n            vhBuilder.setProperty(JcrConstants.JCR_MIXINTYPES, ImmutableSet.of(MIX_REP_VERSIONABLE_PATHS), Type.NAMES);\n        }\n        String versionablePath = nodeAfter.path;\n        vhBuilder.setProperty(workspaceName, versionablePath, Type.PATH);\n    }\n    return true;\n}", "lc": 0.13636363636363635, "pi": 0.3349282296650717, "ma": 0.0, "nbd": 0.0, "ml": 0.25, "d": -0.08333333333333336, "mi": -0.17350246652572232, "fo": 0.25, "r": -0.02631578947368421, "e": 0.027069610368654285}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-1088_63d88c74", "label": 3, "code": "/**\n * {@inheritDoc}\n */\npublic boolean hasNext() {\n    for (int i = 0; i < dimension; i++) {\n        if (counter[i] != size[i] - 1) {\n            return true;\n        }\n    }\n    return false;\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "public boolean hasNext() {\n    for (int i = 0; i < dimension; i++) {\n        if (counter[i] != size[i] - 1) {\n            return true;\n        }\n    }\n    return false;\n}", "lc": -0.2727272727272727, "pi": 0.42105263157894735, "ma": -0.2, "nbd": 0.0, "ml": -0.08333333333333333, "d": 0.1904761904761904, "mi": 0.37730796335447503, "fo": -0.5, "r": 2.5789473684210527, "e": -0.06696749134120548}
{"project_name": "Closure", "project_version": 153, "label": 2, "code": "void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber);", "code_comment": NaN, "code_no_comment": "void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber);", "lc": -0.5909090909090909, "pi": -1.4306220095693782, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.4022551092318531, "fo": -0.5, "r": -0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-867_bfbb156d", "label": 1, "code": "/**\n * {@inheritDoc}\n */\n@Override\nprotected PointValuePair doOptimize() {\n    checkParameters();\n    // -------------------- Initialization --------------------------------\n    isMinimize = getGoalType().equals(GoalType.MINIMIZE);\n    final FitnessFunction fitfun = new FitnessFunction();\n    final double[] guess = fitfun.encode(getStartPoint());\n    // number of objective variables/problem dimension\n    dimension = guess.length;\n    initializeCMA(guess);\n    iterations = 0;\n    double bestValue = fitfun.value(guess);\n    push(fitnessHistory, bestValue);\n    PointValuePair optimum = new PointValuePair(getStartPoint(), isMinimize ? bestValue : -bestValue);\n    PointValuePair lastResult = null;\n    generationLoop: for (iterations = 1; iterations <= maxIterations; iterations++) {\n        // Generate and evaluate lambda offspring\n        RealMatrix arz = randn1(dimension, lambda);\n        RealMatrix arx = zeros(dimension, lambda);\n        double[] fitness = new double[lambda];\n        // generate random offspring\n        for (int k = 0; k < lambda; k++) {\n            RealMatrix arxk = null;\n            for (int i = 0; i < checkFeasableCount + 1; i++) {\n                if (diagonalOnly <= 0) {\n                    arxk = xmean.add(BD.multiply(arz.getColumnMatrix(k)).scalarMultiply(// m + sig * Normal(0,C)\n                    sigma));\n                } else {\n                    arxk = xmean.add(times(diagD, arz.getColumnMatrix(k)).scalarMultiply(sigma));\n                }\n                if (i >= checkFeasableCount || fitfun.isFeasible(arxk.getColumn(0))) {\n                    break;\n                }\n                // regenerate random arguments for row\n                arz.setColumn(k, randn(dimension));\n            }\n            copyColumn(arxk, 0, arx, k);\n            try {\n                // compute fitness\n                fitness[k] = fitfun.value(arx.getColumn(k));\n            } catch (TooManyEvaluationsException e) {\n                break generationLoop;\n            }\n        }\n        // Sort by fitness and compute weighted mean into xmean\n        int[] arindex = sortedIndices(fitness);\n        // Calculate new xmean, this is selection and recombination\n        // for speed up of Eq. (2) and (3)\n        RealMatrix xold = xmean;\n        RealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu));\n        xmean = bestArx.multiply(weights);\n        RealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu));\n        RealMatrix zmean = bestArz.multiply(weights);\n        boolean hsig = updateEvolutionPaths(zmean, xold);\n        if (diagonalOnly <= 0) {\n            updateCovariance(hsig, bestArx, arz, arindex, xold);\n        } else {\n            updateCovarianceDiagonalOnly(hsig, bestArz, xold);\n        }\n        // Adapt step size sigma - Eq. (5)\n        sigma *= Math.exp(Math.min(1.0, (normps / chiN - 1.) * cs / damps));\n        double bestFitness = fitness[arindex[0]];\n        double worstFitness = fitness[arindex[arindex.length - 1]];\n        if (bestValue > bestFitness) {\n            bestValue = bestFitness;\n            lastResult = optimum;\n            optimum = new PointValuePair(fitfun.repairAndDecode(bestArx.getColumn(0)), isMinimize ? bestFitness : -bestFitness);\n            if (getConvergenceChecker() != null && lastResult != null) {\n                if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {\n                    break generationLoop;\n                }\n            }\n        }\n        // Break, if fitness is good enough\n        if (stopFitness != 0) {\n            // only if stopFitness is defined\n            if (bestFitness < (isMinimize ? stopFitness : -stopFitness)) {\n                break generationLoop;\n            }\n        }\n        double[] sqrtDiagC = sqrt(diagC).getColumn(0);\n        double[] pcCol = pc.getColumn(0);\n        for (int i = 0; i < dimension; i++) {\n            if (sigma * (Math.max(Math.abs(pcCol[i]), sqrtDiagC[i])) > stopTolX) {\n                break;\n            }\n            if (i >= dimension - 1) {\n                break generationLoop;\n            }\n        }\n        for (int i = 0; i < dimension; i++) {\n            if (sigma * sqrtDiagC[i] > stopTolUpX) {\n                break generationLoop;\n            }\n        }\n        double historyBest = min(fitnessHistory);\n        double historyWorst = max(fitnessHistory);\n        if (iterations > 2 && Math.max(historyWorst, worstFitness) - Math.min(historyBest, bestFitness) < stopTolFun) {\n            break generationLoop;\n        }\n        if (iterations > fitnessHistory.length && historyWorst - historyBest < stopTolHistFun) {\n            break generationLoop;\n        }\n        // condition number of the covariance matrix exceeds 1e14\n        if (max(diagD) / min(diagD) > 1e7) {\n            break generationLoop;\n        }\n        // user defined termination\n        if (getConvergenceChecker() != null) {\n            PointValuePair current = new PointValuePair(bestArx.getColumn(0), isMinimize ? bestFitness : -bestFitness);\n            if (lastResult != null && getConvergenceChecker().converged(iterations, current, lastResult)) {\n                break generationLoop;\n            }\n            lastResult = current;\n        }\n        // Adjust step size in case of equal function values (flat fitness)\n        if (bestValue == fitness[arindex[(int) (0.1 + lambda / 4.)]]) {\n            sigma = sigma * Math.exp(0.2 + cs / damps);\n        }\n        if (iterations > 2 && Math.max(historyWorst, bestFitness) - Math.min(historyBest, bestFitness) == 0) {\n            sigma = sigma * Math.exp(0.2 + cs / damps);\n        }\n        // store best in history\n        push(fitnessHistory, bestFitness);\n        fitfun.setValueRange(worstFitness - bestFitness);\n        if (generateStatistics) {\n            statisticsSigmaHistory.add(sigma);\n            statisticsFitnessHistory.add(bestFitness);\n            statisticsMeanHistory.add(xmean.transpose());\n            statisticsDHistory.add(diagD.transpose().scalarMultiply(1E5));\n        }\n    }\n    return optimum;\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "@Override\nprotected PointValuePair doOptimize() {\n    checkParameters();\n        isMinimize = getGoalType().equals(GoalType.MINIMIZE);\n    final FitnessFunction fitfun = new FitnessFunction();\n    final double[] guess = fitfun.encode(getStartPoint());\n        dimension = guess.length;\n    initializeCMA(guess);\n    iterations = 0;\n    double bestValue = fitfun.value(guess);\n    push(fitnessHistory, bestValue);\n    PointValuePair optimum = new PointValuePair(getStartPoint(), isMinimize ? bestValue : -bestValue);\n    PointValuePair lastResult = null;\n    generationLoop: for (iterations = 1; iterations <= maxIterations; iterations++) {\n                RealMatrix arz = randn1(dimension, lambda);\n        RealMatrix arx = zeros(dimension, lambda);\n        double[] fitness = new double[lambda];\n                for (int k = 0; k < lambda; k++) {\n            RealMatrix arxk = null;\n            for (int i = 0; i < checkFeasableCount + 1; i++) {\n                if (diagonalOnly <= 0) {\n                    arxk = xmean.add(BD.multiply(arz.getColumnMatrix(k)).scalarMultiply(                    sigma));\n                } else {\n                    arxk = xmean.add(times(diagD, arz.getColumnMatrix(k)).scalarMultiply(sigma));\n                }\n                if (i >= checkFeasableCount || fitfun.isFeasible(arxk.getColumn(0))) {\n                    break;\n                }\n                                arz.setColumn(k, randn(dimension));\n            }\n            copyColumn(arxk, 0, arx, k);\n            try {\n                                fitness[k] = fitfun.value(arx.getColumn(k));\n            } catch (TooManyEvaluationsException e) {\n                break generationLoop;\n            }\n        }\n                int[] arindex = sortedIndices(fitness);\n                        RealMatrix xold = xmean;\n        RealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu));\n        xmean = bestArx.multiply(weights);\n        RealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu));\n        RealMatrix zmean = bestArz.multiply(weights);\n        boolean hsig = updateEvolutionPaths(zmean, xold);\n        if (diagonalOnly <= 0) {\n            updateCovariance(hsig, bestArx, arz, arindex, xold);\n        } else {\n            updateCovarianceDiagonalOnly(hsig, bestArz, xold);\n        }\n                sigma *= Math.exp(Math.min(1.0, (normps / chiN - 1.) * cs / damps));\n        double bestFitness = fitness[arindex[0]];\n        double worstFitness = fitness[arindex[arindex.length - 1]];\n        if (bestValue > bestFitness) {\n            bestValue = bestFitness;\n            lastResult = optimum;\n            optimum = new PointValuePair(fitfun.repairAndDecode(bestArx.getColumn(0)), isMinimize ? bestFitness : -bestFitness);\n            if (getConvergenceChecker() != null && lastResult != null) {\n                if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {\n                    break generationLoop;\n                }\n            }\n        }\n                if (stopFitness != 0) {\n                        if (bestFitness < (isMinimize ? stopFitness : -stopFitness)) {\n                break generationLoop;\n            }\n        }\n        double[] sqrtDiagC = sqrt(diagC).getColumn(0);\n        double[] pcCol = pc.getColumn(0);\n        for (int i = 0; i < dimension; i++) {\n            if (sigma * (Math.max(Math.abs(pcCol[i]), sqrtDiagC[i])) > stopTolX) {\n                break;\n            }\n            if (i >= dimension - 1) {\n                break generationLoop;\n            }\n        }\n        for (int i = 0; i < dimension; i++) {\n            if (sigma * sqrtDiagC[i] > stopTolUpX) {\n                break generationLoop;\n            }\n        }\n        double historyBest = min(fitnessHistory);\n        double historyWorst = max(fitnessHistory);\n        if (iterations > 2 && Math.max(historyWorst, worstFitness) - Math.min(historyBest, bestFitness) < stopTolFun) {\n            break generationLoop;\n        }\n        if (iterations > fitnessHistory.length && historyWorst - historyBest < stopTolHistFun) {\n            break generationLoop;\n        }\n                if (max(diagD) / min(diagD) > 1e7) {\n            break generationLoop;\n        }\n                if (getConvergenceChecker() != null) {\n            PointValuePair current = new PointValuePair(bestArx.getColumn(0), isMinimize ? bestFitness : -bestFitness);\n            if (lastResult != null && getConvergenceChecker().converged(iterations, current, lastResult)) {\n                break generationLoop;\n            }\n            lastResult = current;\n        }\n                if (bestValue == fitness[arindex[(int) (0.1 + lambda / 4.)]]) {\n            sigma = sigma * Math.exp(0.2 + cs / damps);\n        }\n        if (iterations > 2 && Math.max(historyWorst, bestFitness) - Math.min(historyBest, bestFitness) == 0) {\n            sigma = sigma * Math.exp(0.2 + cs / damps);\n        }\n                push(fitnessHistory, bestFitness);\n        fitfun.setValueRange(worstFitness - bestFitness);\n        if (generateStatistics) {\n            statisticsSigmaHistory.add(sigma);\n            statisticsFitnessHistory.add(bestFitness);\n            statisticsMeanHistory.add(xmean.transpose());\n            statisticsDHistory.add(diagD.transpose().scalarMultiply(1E5));\n        }\n    }\n    return optimum;\n}", "lc": 4.7272727272727275, "pi": 0.6220095693779903, "ma": 7.4, "nbd": 1.0, "ml": 5.583333333333333, "d": 4.091269841269842, "mi": -1.6553911205073992, "fo": 5.416666666666667, "r": -0.02631578947368421, "e": 34.23290975836056}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4072_7d5b8645", "label": 1, "code": "/**\n *  render full representation of url (including protocol, host and port)\n *  into string representation\n */\npublic String toAbsoluteString() {\n    return toAbsoluteString(getCharset());\n}", "code_comment": "/**\n *  render full representation of url (including protocol, host and port)\n *  into string representation\n */\n", "code_no_comment": "public String toAbsoluteString() {\n    return toAbsoluteString(getCharset());\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.1319238900634248, "fo": -0.3333333333333333, "r": 2.6052631578947367, "e": -0.16279340490885932}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-3281_f7dd2fff", "label": 1, "code": "/**\n * Adds a route for an interceptor that intercepts every processing step.\n *\n * @return the builder\n */\npublic InterceptDefinition intercept() {\n    routeCollection.setCamelContext(getContext());\n    return routeCollection.intercept();\n}", "code_comment": "/**\n * Adds a route for an interceptor that intercepts every processing step.\n *\n * @return the builder\n */\n", "code_no_comment": "public InterceptDefinition intercept() {\n    routeCollection.setCamelContext(getContext());\n    return routeCollection.intercept();\n}", "lc": -0.45454545454545453, "pi": -0.47368421052631593, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.8940098661028892, "fo": -0.25, "r": 2.5789473684210527, "e": -0.16279340490885932}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-258_7b38965d", "label": 1, "code": "/**\n * Returns appropriate HTML headers.\n * @return The header as a byte array.\n */\n@Override\npublic byte[] getHeader() {\n    final StringBuilder sbuf = new StringBuilder();\n    sbuf.append(\"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\" \");\n    sbuf.append(\"\\\"http://www.w3.org/TR/html4/loose.dtd\\\">\");\n    sbuf.append(Constants.LINE_SEP);\n    sbuf.append(\"<html>\").append(Constants.LINE_SEP);\n    sbuf.append(\"<head>\").append(Constants.LINE_SEP);\n    sbuf.append(\"<title>\").append(title).append(\"</title>\").append(Constants.LINE_SEP);\n    sbuf.append(\"<style type=\\\"text/css\\\">\").append(Constants.LINE_SEP);\n    sbuf.append(\"<!--\").append(Constants.LINE_SEP);\n    sbuf.append(\"body, table {font-family:\").append(font).append(\"; font-size: \");\n    sbuf.append(headerSize).append(\";}\").append(Constants.LINE_SEP);\n    sbuf.append(\"th {background: #336699; color: #FFFFFF; text-align: left;}\").append(Constants.LINE_SEP);\n    sbuf.append(\"-->\").append(Constants.LINE_SEP);\n    sbuf.append(\"</style>\").append(Constants.LINE_SEP);\n    sbuf.append(\"</head>\").append(Constants.LINE_SEP);\n    sbuf.append(\"<body bgcolor=\\\"#FFFFFF\\\" topmargin=\\\"6\\\" leftmargin=\\\"6\\\">\").append(Constants.LINE_SEP);\n    sbuf.append(\"<hr size=\\\"1\\\" noshade>\").append(Constants.LINE_SEP);\n    sbuf.append(\"Log session start time \" + new java.util.Date() + \"<br>\").append(Constants.LINE_SEP);\n    sbuf.append(\"<br>\").append(Constants.LINE_SEP);\n    sbuf.append(\"<table cellspacing=\\\"0\\\" cellpadding=\\\"4\\\" border=\\\"1\\\" bordercolor=\\\"#224466\\\" width=\\\"100%\\\">\");\n    sbuf.append(Constants.LINE_SEP);\n    sbuf.append(\"<tr>\").append(Constants.LINE_SEP);\n    sbuf.append(\"<th>Time</th>\").append(Constants.LINE_SEP);\n    sbuf.append(\"<th>Thread</th>\").append(Constants.LINE_SEP);\n    sbuf.append(\"<th>Level</th>\").append(Constants.LINE_SEP);\n    sbuf.append(\"<th>Logger</th>\").append(Constants.LINE_SEP);\n    if (locationInfo) {\n        sbuf.append(\"<th>File:Line</th>\").append(Constants.LINE_SEP);\n    }\n    sbuf.append(\"<th>Message</th>\").append(Constants.LINE_SEP);\n    sbuf.append(\"</tr>\").append(Constants.LINE_SEP);\n    return sbuf.toString().getBytes(getCharset());\n}", "code_comment": "/**\n * Returns appropriate HTML headers.\n * @return The header as a byte array.\n */\n", "code_no_comment": "@Override\npublic byte[] getHeader() {\n    final StringBuilder sbuf = new StringBuilder();\n    sbuf.append(\"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\" \");\n    sbuf.append(\"\\\"http://www.w3.org/TR/html4/loose.dtd\\\">\");\n    sbuf.append(Constants.LINE_SEP);\n    sbuf.append(\"<html>\").append(Constants.LINE_SEP);\n    sbuf.append(\"<head>\").append(Constants.LINE_SEP);\n    sbuf.append(\"<title>\").append(title).append(\"</title>\").append(Constants.LINE_SEP);\n    sbuf.append(\"<style type=\\\"text/css\\\">\").append(Constants.LINE_SEP);\n    sbuf.append(\"<!--\").append(Constants.LINE_SEP);\n    sbuf.append(\"body, table {font-family:\").append(font).append(\"; font-size: \");\n    sbuf.append(headerSize).append(\";}\").append(Constants.LINE_SEP);\n    sbuf.append(\"th {background: #336699; color: #FFFFFF; text-align: left;}\").append(Constants.LINE_SEP);\n    sbuf.append(\"-->\").append(Constants.LINE_SEP);\n    sbuf.append(\"</style>\").append(Constants.LINE_SEP);\n    sbuf.append(\"</head>\").append(Constants.LINE_SEP);\n    sbuf.append(\"<body bgcolor=\\\"#FFFFFF\\\" topmargin=\\\"6\\\" leftmargin=\\\"6\\\">\").append(Constants.LINE_SEP);\n    sbuf.append(\"<hr size=\\\"1\\\" noshade>\").append(Constants.LINE_SEP);\n    sbuf.append(\"Log session start time \" + new java.util.Date() + \"<br>\").append(Constants.LINE_SEP);\n    sbuf.append(\"<br>\").append(Constants.LINE_SEP);\n    sbuf.append(\"<table cellspacing=\\\"0\\\" cellpadding=\\\"4\\\" border=\\\"1\\\" bordercolor=\\\"#224466\\\" width=\\\"100%\\\">\");\n    sbuf.append(Constants.LINE_SEP);\n    sbuf.append(\"<tr>\").append(Constants.LINE_SEP);\n    sbuf.append(\"<th>Time</th>\").append(Constants.LINE_SEP);\n    sbuf.append(\"<th>Thread</th>\").append(Constants.LINE_SEP);\n    sbuf.append(\"<th>Level</th>\").append(Constants.LINE_SEP);\n    sbuf.append(\"<th>Logger</th>\").append(Constants.LINE_SEP);\n    if (locationInfo) {\n        sbuf.append(\"<th>File:Line</th>\").append(Constants.LINE_SEP);\n    }\n    sbuf.append(\"<th>Message</th>\").append(Constants.LINE_SEP);\n    sbuf.append(\"</tr>\").append(Constants.LINE_SEP);\n    return sbuf.toString().getBytes(getCharset());\n}", "lc": 0.9545454545454546, "pi": -0.7942583732057418, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": 0.3988095238095238, "mi": -0.6715997181113459, "fo": 4.333333333333333, "r": -0.02631578947368421, "e": 1.6106660212190886}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-326_ce185345", "label": 1, "code": "/**\n * {@inheritDoc}\n */\npublic double getLInfNorm() {\n    double max = 0;\n    for (double a : data) {\n        max += Math.max(max, Math.abs(a));\n    }\n    return max;\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "public double getLInfNorm() {\n    double max = 0;\n    for (double a : data) {\n        max += Math.max(max, Math.abs(a));\n    }\n    return max;\n}", "lc": -0.3181818181818182, "pi": -0.20574162679425848, "ma": -0.4, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.017857142857142873, "mi": 0.49372797744890756, "fo": -0.3333333333333333, "r": 2.236842105263158, "e": -0.11991263406003815}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4932_f20b2d70", "label": 1, "code": "/**\n *  Creates a {@code IRequestHandler} that processes a bookmarkable request.\n *\n *  @param pageClass\n *  @param pageParameters\n *  @return a {@code IRequestHandler} capable of processing the bookmarkable request.\n */\nprotected IRequestHandler processBookmarkable(Class<? extends IRequestablePage> pageClass, PageParameters pageParameters) {\n    PageProvider provider = new PageProvider(pageClass, pageParameters);\n    provider.setPageSource(getContext());\n    return new RenderPageRequestHandler(provider);\n}", "code_comment": "/**\n *  Creates a {@code IRequestHandler} that processes a bookmarkable request.\n *\n *  @param pageClass\n *  @param pageParameters\n *  @return a {@code IRequestHandler} capable of processing the bookmarkable request.\n */\n", "code_no_comment": "protected IRequestHandler processBookmarkable(Class<? extends IRequestablePage> pageClass, PageParameters pageParameters) {\n    PageProvider provider = new PageProvider(pageClass, pageParameters);\n    provider.setPageSource(getContext());\n    return new RenderPageRequestHandler(provider);\n}", "lc": -0.4090909090909091, "pi": -0.49282296650717716, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.6084566596194504, "fo": -0.3333333333333333, "r": 2.3947368421052633, "e": -0.16279340490885932}
{"project_name": "Chart", "project_version": 2, "label": 3, "code": "/**\n * Iterates over the items in an {@link XYDataset} to find\n * the range of x-values.\n *\n * @param dataset  the dataset (<code>null</code> not permitted).\n * @param includeInterval  a flag that determines, for an\n *          {@link IntervalXYDataset}, whether the x-interval or just the\n *          x-value is used to determine the overall range.\n *\n * @return The range (possibly <code>null</code>).\n */\npublic static Range iterateDomainBounds(XYDataset dataset, boolean includeInterval) {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    int seriesCount = dataset.getSeriesCount();\n    double lvalue;\n    double uvalue;\n    if (includeInterval && dataset instanceof IntervalXYDataset) {\n        IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset;\n        for (int series = 0; series < seriesCount; series++) {\n            int itemCount = dataset.getItemCount(series);\n            for (int item = 0; item < itemCount; item++) {\n                lvalue = intervalXYData.getStartXValue(series, item);\n                uvalue = intervalXYData.getEndXValue(series, item);\n                if (!Double.isNaN(lvalue)) {\n                    minimum = Math.min(minimum, lvalue);\n                }\n                if (!Double.isNaN(uvalue)) {\n                    maximum = Math.max(maximum, uvalue);\n                }\n            }\n        }\n    } else {\n        for (int series = 0; series < seriesCount; series++) {\n            int itemCount = dataset.getItemCount(series);\n            for (int item = 0; item < itemCount; item++) {\n                lvalue = dataset.getXValue(series, item);\n                uvalue = lvalue;\n                if (!Double.isNaN(lvalue)) {\n                    minimum = Math.min(minimum, lvalue);\n                    maximum = Math.max(maximum, uvalue);\n                }\n            }\n        }\n    }\n    if (minimum > maximum) {\n        return null;\n    } else {\n        return new Range(minimum, maximum);\n    }\n}", "code_comment": "/**\n * Iterates over the items in an {@link XYDataset} to find\n * the range of x-values.\n *\n * @param dataset  the dataset (<code>null</code> not permitted).\n * @param includeInterval  a flag that determines, for an\n *          {@link IntervalXYDataset}, whether the x-interval or just the\n *          x-value is used to determine the overall range.\n *\n * @return The range (possibly <code>null</code>).\n */\n", "code_no_comment": "public static Range iterateDomainBounds(XYDataset dataset, boolean includeInterval) {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    int seriesCount = dataset.getSeriesCount();\n    double lvalue;\n    double uvalue;\n    if (includeInterval && dataset instanceof IntervalXYDataset) {\n        IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset;\n        for (int series = 0; series < seriesCount; series++) {\n            int itemCount = dataset.getItemCount(series);\n            for (int item = 0; item < itemCount; item++) {\n                lvalue = intervalXYData.getStartXValue(series, item);\n                uvalue = intervalXYData.getEndXValue(series, item);\n                if (!Double.isNaN(lvalue)) {\n                    minimum = Math.min(minimum, lvalue);\n                }\n                if (!Double.isNaN(uvalue)) {\n                    maximum = Math.max(maximum, uvalue);\n                }\n            }\n        }\n    } else {\n        for (int series = 0; series < seriesCount; series++) {\n            int itemCount = dataset.getItemCount(series);\n            for (int item = 0; item < itemCount; item++) {\n                lvalue = dataset.getXValue(series, item);\n                uvalue = lvalue;\n                if (!Double.isNaN(lvalue)) {\n                    minimum = Math.min(minimum, lvalue);\n                    maximum = Math.max(maximum, uvalue);\n                }\n            }\n        }\n    }\n    if (minimum > maximum) {\n        return null;\n    } else {\n        return new Range(minimum, maximum);\n    }\n}", "lc": 1.3181818181818181, "pi": 1.3779904306220097, "ma": 1.6, "nbd": 1.0, "ml": 1.5, "d": 1.6428571428571428, "mi": -0.7863284002818883, "fo": 0.5833333333333334, "r": -0.02631578947368421, "e": 3.2913008650150117}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5426_fb45a781", "label": 3, "code": "/**\n *  @see org.apache.wicket.request.component.IRequestablePage#renderPage()\n */\n@Override\npublic void renderPage() {\n    // page id is frozen during the render\n    final boolean frozen = setFreezePageId(true);\n    try {\n        ++renderCount;\n        render();\n    } finally {\n        setFreezePageId(frozen);\n    }\n}", "code_comment": "/**\n *  @see org.apache.wicket.request.component.IRequestablePage#renderPage()\n */\n", "code_no_comment": "@Override\npublic void renderPage() {\n        final boolean frozen = setFreezePageId(true);\n    try {\n        ++renderCount;\n        render();\n    } finally {\n        setFreezePageId(frozen);\n    }\n}", "lc": -0.18181818181818182, "pi": 0.05263157894736836, "ma": -0.6, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.11706349206349208, "mi": 0.3792811839323466, "fo": -0.25, "r": 1.9736842105263157, "e": -0.13982008148775665}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-93_0be7e8f0", "label": 1, "code": "@Override\npublic Iterator<Tree> iterator() {\n    Iterator<? extends ChildNodeEntry> childEntries = getNodeState().getChildNodeEntries().iterator();\n    return Iterators.map(childEntries, new Function1<ChildNodeEntry, Tree>() {\n\n        @Override\n        public Tree apply(ChildNodeEntry entry) {\n            NodeStateBuilder childBuilder = builder.getChildBuilder(entry.getName());\n            return new TreeImpl(store, childBuilder.getNodeState(), childBuilder, TreeImpl.this, entry.getName(), listener);\n        }\n    });\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic Iterator<Tree> iterator() {\n    Iterator<? extends ChildNodeEntry> childEntries = getNodeState().getChildNodeEntries().iterator();\n    return Iterators.map(childEntries, new Function1<ChildNodeEntry, Tree>() {\n\n        @Override\n        public Tree apply(ChildNodeEntry entry) {\n            NodeStateBuilder childBuilder = builder.getChildBuilder(entry.getName());\n            return new TreeImpl(store, childBuilder.getNodeState(), childBuilder, TreeImpl.this, entry.getName(), listener);\n        }\n    });\n}", "lc": -0.13636363636363635, "pi": 0.6124401913875596, "ma": -0.6, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.11797040169133197, "fo": 0.16666666666666666, "r": -0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "Closure", "project_version": 131, "label": 2, "code": "public static boolean isJSIdentifier(String s) {\n    int length = s.length();\n    if (length == 0 || !Character.isJavaIdentifierStart(s.charAt(0))) {\n        return false;\n    }\n    for (int i = 1; i < length; i++) {\n        if (!Character.isJavaIdentifierPart(s.charAt(i))) {\n            return false;\n        }\n    }\n    return true;\n}", "code_comment": NaN, "code_no_comment": "public static boolean isJSIdentifier(String s) {\n    int length = s.length();\n    if (length == 0 || !Character.isJavaIdentifierStart(s.charAt(0))) {\n        return false;\n    }\n    for (int i = 1; i < length; i++) {\n        if (!Character.isJavaIdentifierPart(s.charAt(i))) {\n            return false;\n        }\n    }\n    return true;\n}", "lc": -0.09090909090909091, "pi": 0.1578947368421051, "ma": 0.0, "nbd": 0.0, "ml": 0.4166666666666667, "d": 0.7837301587301587, "mi": 0.081324876673714, "fo": -0.08333333333333333, "r": 0.3684210526315789, "e": 0.24069892751969477}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-4066_9a109aa3", "label": 0, "code": "/**\n * eventually update suggest dictionary\n * @throws IOException if suggest dictionary update fails\n * @param analyzer the analyzer used to update the suggester\n */\nprivate void updateSuggester(Analyzer analyzer) throws IOException {\n    if (definition.isSuggestEnabled()) {\n        boolean updateSuggester = false;\n        NodeBuilder suggesterStatus = definitionBuilder.child(\":suggesterStatus\");\n        if (suggesterStatus.hasProperty(\"lastUpdated\")) {\n            PropertyState suggesterLastUpdatedValue = suggesterStatus.getProperty(\"lastUpdated\");\n            Calendar suggesterLastUpdatedTime = ISO8601.parse(suggesterLastUpdatedValue.getValue(Type.DATE));\n            int updateFrequency = definition.getSuggesterUpdateFrequencyMinutes();\n            suggesterLastUpdatedTime.add(Calendar.MINUTE, updateFrequency);\n            if (getCalendar().after(suggesterLastUpdatedTime)) {\n                updateSuggester = true;\n            }\n        } else {\n            updateSuggester = true;\n        }\n        if (updateSuggester) {\n            DirectoryReader reader = DirectoryReader.open(writer, false);\n            final OakDirectory suggestDirectory = new OakDirectory(definitionBuilder, \":suggest-data\", definition, false);\n            try {\n                SuggestHelper.updateSuggester(suggestDirectory, analyzer, reader);\n                suggesterStatus.setProperty(\"lastUpdated\", ISO8601.format(getCalendar()), Type.DATE);\n            } catch (Throwable e) {\n                log.warn(\"could not update suggester\", e);\n            } finally {\n                suggestDirectory.close();\n                reader.close();\n            }\n        }\n    }\n}", "code_comment": "/**\n * eventually update suggest dictionary\n * @throws IOException if suggest dictionary update fails\n * @param analyzer the analyzer used to update the suggester\n */\n", "code_no_comment": "private void updateSuggester(Analyzer analyzer) throws IOException {\n    if (definition.isSuggestEnabled()) {\n        boolean updateSuggester = false;\n        NodeBuilder suggesterStatus = definitionBuilder.child(\":suggesterStatus\");\n        if (suggesterStatus.hasProperty(\"lastUpdated\")) {\n            PropertyState suggesterLastUpdatedValue = suggesterStatus.getProperty(\"lastUpdated\");\n            Calendar suggesterLastUpdatedTime = ISO8601.parse(suggesterLastUpdatedValue.getValue(Type.DATE));\n            int updateFrequency = definition.getSuggesterUpdateFrequencyMinutes();\n            suggesterLastUpdatedTime.add(Calendar.MINUTE, updateFrequency);\n            if (getCalendar().after(suggesterLastUpdatedTime)) {\n                updateSuggester = true;\n            }\n        } else {\n            updateSuggester = true;\n        }\n        if (updateSuggester) {\n            DirectoryReader reader = DirectoryReader.open(writer, false);\n            final OakDirectory suggestDirectory = new OakDirectory(definitionBuilder, \":suggest-data\", definition, false);\n            try {\n                SuggestHelper.updateSuggester(suggestDirectory, analyzer, reader);\n                suggesterStatus.setProperty(\"lastUpdated\", ISO8601.format(getCalendar()), Type.DATE);\n            } catch (Throwable e) {\n                log.warn(\"could not update suggester\", e);\n            } finally {\n                suggestDirectory.close();\n                reader.close();\n            }\n        }\n    }\n}", "lc": 0.7272727272727273, "pi": 0.6363636363636365, "ma": 0.4, "nbd": 0.5, "ml": 0.3333333333333333, "d": -0.3650793650793651, "mi": -0.5286821705426354, "fo": 1.0, "r": -0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "Lang", "project_version": 5, "label": 1, "code": "// -----------------------------------------------------------------------\n/**\n * <p>Converts a String to a Locale.</p>\n *\n * <p>This method takes the string format of a locale and creates the\n * locale object from it.</p>\n *\n * <pre>\n *   LocaleUtils.toLocale(\"en\")         = new Locale(\"en\", \"\")\n *   LocaleUtils.toLocale(\"en_GB\")      = new Locale(\"en\", \"GB\")\n *   LocaleUtils.toLocale(\"en_GB_xxx\")  = new Locale(\"en\", \"GB\", \"xxx\")   (#)\n * </pre>\n *\n * <p>(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4.\n * In JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn't.\n * Thus, the result from getVariant() may vary depending on your JDK.</p>\n *\n * <p>This method validates the input strictly.\n * The language code must be lowercase.\n * The country code must be uppercase.\n * The separator must be an underscore.\n * The length must be correct.\n * </p>\n *\n * @param str  the locale String to convert, null returns null\n * @return a Locale, null if null input\n * @throws IllegalArgumentException if the string is an invalid format\n */\npublic static Locale toLocale(final String str) {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    if (len < 2) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    final char ch0 = str.charAt(0);\n    final char ch1 = str.charAt(1);\n    if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    if (len == 2) {\n        return new Locale(str);\n    }\n    if (len < 5) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    if (str.charAt(2) != '_') {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    final char ch3 = str.charAt(3);\n    if (ch3 == '_') {\n        return new Locale(str.substring(0, 2), \"\", str.substring(4));\n    }\n    final char ch4 = str.charAt(4);\n    if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    if (len == 5) {\n        return new Locale(str.substring(0, 2), str.substring(3, 5));\n    }\n    if (len < 7) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    if (str.charAt(5) != '_') {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n}", "code_comment": "/**\n * <p>Converts a String to a Locale.</p>\n *\n * <p>This method takes the string format of a locale and creates the\n * locale object from it.</p>\n *\n * <pre>\n *   LocaleUtils.toLocale(\"en\")         = new Locale(\"en\", \"\")\n *   LocaleUtils.toLocale(\"en_GB\")      = new Locale(\"en\", \"GB\")\n *   LocaleUtils.toLocale(\"en_GB_xxx\")  = new Locale(\"en\", \"GB\", \"xxx\")   (#)\n * </pre>\n *\n * <p>(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4.\n * In JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn't.\n * Thus, the result from getVariant() may vary depending on your JDK.</p>\n *\n * <p>This method validates the input strictly.\n * The language code must be lowercase.\n * The country code must be uppercase.\n * The separator must be an underscore.\n * The length must be correct.\n * </p>\n *\n * @param str  the locale String to convert, null returns null\n * @return a Locale, null if null input\n * @throws IllegalArgumentException if the string is an invalid format\n */\n", "code_no_comment": "public static Locale toLocale(final String str) {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    if (len < 2) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    final char ch0 = str.charAt(0);\n    final char ch1 = str.charAt(1);\n    if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    if (len == 2) {\n        return new Locale(str);\n    }\n    if (len < 5) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    if (str.charAt(2) != '_') {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    final char ch3 = str.charAt(3);\n    if (ch3 == '_') {\n        return new Locale(str.substring(0, 2), \"\", str.substring(4));\n    }\n    final char ch4 = str.charAt(4);\n    if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    if (len == 5) {\n        return new Locale(str.substring(0, 2), str.substring(3, 5));\n    }\n    if (len < 7) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    if (str.charAt(5) != '_') {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n}", "lc": 1.2272727272727273, "pi": -0.4401913875598088, "ma": 3.0, "nbd": -0.5, "ml": 1.6666666666666667, "d": 1.9345238095238095, "mi": -0.8054968287526426, "fo": 1.0, "r": -0.02631578947368421, "e": 3.6758124283236224}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-3448_b345dd82", "label": 0, "code": "public static ExceptionPolicyKey newInstance(Class exceptionClass, WhenDefinition when) {\n    return new ExceptionPolicyKey(exceptionClass, when);\n}", "code_comment": NaN, "code_no_comment": "public static ExceptionPolicyKey newInstance(Class exceptionClass, WhenDefinition when) {\n    return new ExceptionPolicyKey(exceptionClass, when);\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.9805496828752639, "fo": -0.5, "r": 0.5789473684210527, "e": -0.16279340490885932}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-844_692efde2", "label": 0, "code": "@Override\npublic boolean accept(Key k, Value v) {\n    Text testVis = k.getColumnVisibility(tmpVis);\n    if (testVis.getLength() == 0 && defaultVisibility.getLength() == 0)\n        return true;\n    else if (testVis.getLength() == 0)\n        testVis = defaultVisibility;\n    Boolean b = (Boolean) cache.get(testVis);\n    if (b != null)\n        return b;\n    try {\n        Boolean bb = ve.evaluate(new ColumnVisibility(testVis));\n        cache.put(new Text(testVis), bb);\n        return bb;\n    } catch (VisibilityParseException e) {\n        log.error(\"Parse Error\", e);\n        return false;\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean accept(Key k, Value v) {\n    Text testVis = k.getColumnVisibility(tmpVis);\n    if (testVis.getLength() == 0 && defaultVisibility.getLength() == 0)\n        return true;\n    else if (testVis.getLength() == 0)\n        testVis = defaultVisibility;\n    Boolean b = (Boolean) cache.get(testVis);\n    if (b != null)\n        return b;\n    try {\n        Boolean bb = ve.evaluate(new ColumnVisibility(testVis));\n        cache.put(new Text(testVis), bb);\n        return bb;\n    } catch (VisibilityParseException e) {\n        log.error(\"Parse Error\", e);\n        return false;\n    }\n}", "lc": 0.22727272727272727, "pi": -0.06220095693779921, "ma": 0.2, "nbd": -0.5, "ml": 0.16666666666666666, "d": 0.2996031746031746, "mi": -0.24171952078928827, "fo": 0.16666666666666666, "r": 0.0, "e": 0.3211447473821914}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-2460_a17d4e82", "label": 1, "code": "@Override\npublic boolean isReleased() {\n    return isReleased;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean isReleased() {\n    return isReleased;\n}", "lc": -0.45454545454545453, "pi": -0.6028708133971293, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.067371388301621, "fo": -0.5, "r": 1.8157894736842104, "e": -0.16279340490885932}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5720_2fc6a395", "label": 3, "code": "/**\n *  Joins string fragments using the specified separator\n *\n *  @param separator\n *  @param fragments\n *  @return combined fragments\n */\npublic static String join(final String separator, final String... fragments) {\n    if ((fragments == null) || (fragments.length < 1)) {\n        // no elements\n        return \"\";\n    } else if (fragments.length < 2) {\n        // single element\n        return fragments[0];\n    } else {\n        // two or more elements\n        StringBuilder buff = new StringBuilder(128);\n        if (fragments[0] != null) {\n            buff.append(fragments[0]);\n        }\n        for (int i = 1; i < fragments.length; i++) {\n            String fragment = fragments[i];\n            if ((fragments[i - 1] != null) || (fragment != null)) {\n                boolean lhsClosed = fragments[i - 1].endsWith(separator);\n                boolean rhsClosed = fragment.startsWith(separator);\n                if (lhsClosed && rhsClosed) {\n                    buff.append(fragment.substring(1));\n                } else if (!lhsClosed && !rhsClosed) {\n                    if (!Strings.isEmpty(fragment)) {\n                        buff.append(separator);\n                    }\n                    buff.append(fragment);\n                } else {\n                    buff.append(fragment);\n                }\n            }\n        }\n        return buff.toString();\n    }\n}", "code_comment": "/**\n *  Joins string fragments using the specified separator\n *\n *  @param separator\n *  @param fragments\n *  @return combined fragments\n */\n", "code_no_comment": "public static String join(final String separator, final String... fragments) {\n    if ((fragments == null) || (fragments.length < 1)) {\n                return \"\";\n    } else if (fragments.length < 2) {\n                return fragments[0];\n    } else {\n                StringBuilder buff = new StringBuilder(128);\n        if (fragments[0] != null) {\n            buff.append(fragments[0]);\n        }\n        for (int i = 1; i < fragments.length; i++) {\n            String fragment = fragments[i];\n            if ((fragments[i - 1] != null) || (fragment != null)) {\n                boolean lhsClosed = fragments[i - 1].endsWith(separator);\n                boolean rhsClosed = fragment.startsWith(separator);\n                if (lhsClosed && rhsClosed) {\n                    buff.append(fragment.substring(1));\n                } else if (!lhsClosed && !rhsClosed) {\n                    if (!Strings.isEmpty(fragment)) {\n                        buff.append(separator);\n                    }\n                    buff.append(fragment);\n                } else {\n                    buff.append(fragment);\n                }\n            }\n        }\n        return buff.toString();\n    }\n}", "lc": 0.7272727272727273, "pi": 1.6315789473684212, "ma": 1.0, "nbd": 2.5, "ml": 1.1666666666666667, "d": 2.111111111111111, "mi": -0.5475687103594078, "fo": 0.3333333333333333, "r": -0.02631578947368421, "e": 2.7643805143986673}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-7209_5f78c646", "label": 1, "code": "@Converter\npublic static ByteBuffer toByteBuffer(String value, Exchange exchange) {\n    ByteBuffer buf = ByteBuffer.allocate(value.length());\n    byte[] bytes = null;\n    if (exchange != null) {\n        String charsetName = exchange.getProperty(Exchange.CHARSET_NAME, String.class);\n        if (charsetName != null) {\n            try {\n                bytes = value.getBytes(charsetName);\n            } catch (UnsupportedEncodingException e) {\n                LOG.warn(\"Cannot convert the byte to String with the charset \" + charsetName, e);\n            }\n        }\n    }\n    if (bytes == null) {\n        bytes = value.getBytes();\n    }\n    buf.put(bytes);\n    return buf;\n}", "code_comment": NaN, "code_no_comment": "@Converter\npublic static ByteBuffer toByteBuffer(String value, Exchange exchange) {\n    ByteBuffer buf = ByteBuffer.allocate(value.length());\n    byte[] bytes = null;\n    if (exchange != null) {\n        String charsetName = exchange.getProperty(Exchange.CHARSET_NAME, String.class);\n        if (charsetName != null) {\n            try {\n                bytes = value.getBytes(charsetName);\n            } catch (UnsupportedEncodingException e) {\n                LOG.warn(\"Cannot convert the byte to String with the charset \" + charsetName, e);\n            }\n        }\n    }\n    if (bytes == null) {\n        bytes = value.getBytes();\n    }\n    buf.put(bytes);\n    return buf;\n}", "lc": 0.2727272727272727, "pi": 0.8564593301435407, "ma": 0.2, "nbd": 0.5, "ml": 0.08333333333333333, "d": 0.44642857142857145, "mi": -0.24143763213530642, "fo": 0.08333333333333333, "r": 0.05263157894736841, "e": 0.33892682814381947}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3433_b76b31f7", "label": 0, "code": "@Override\npublic void acquiring() {\n    if (lastRootRev == null) {\n        // then we cannot and probably don't have to persist anything\n        return;\n    }\n    // lastRootRev never null at this point\n    final String id = JournalEntry.asId(lastRootRev);\n    final JournalEntry existingEntry = docStore.find(Collection.JOURNAL, id);\n    if (existingEntry != null) {\n        // hence: nothing to be done here. return.\n        return;\n    }\n    // otherwise store a new journal entry now\n    docStore.create(JOURNAL, singletonList(changes.asUpdateOp(lastRootRev)));\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void acquiring() {\n    if (lastRootRev == null) {\n                return;\n    }\n        final String id = JournalEntry.asId(lastRootRev);\n    final JournalEntry existingEntry = docStore.find(Collection.JOURNAL, id);\n    if (existingEntry != null) {\n                return;\n    }\n        docStore.create(JOURNAL, singletonList(changes.asUpdateOp(lastRootRev)));\n}", "lc": -0.09090909090909091, "pi": -0.20574162679425848, "ma": -0.2, "nbd": -0.5, "ml": -0.08333333333333333, "d": -0.07936507936507939, "mi": 0.1078224101479916, "fo": -0.08333333333333333, "r": 1.2894736842105263, "e": -0.07504480674031684}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-1277_fb007815", "label": 3, "code": "/**\n * Computes the Kendall's Tau rank correlation coefficient between the two arrays.\n *\n * @param xArray first data array\n * @param yArray second data array\n * @return Returns Kendall's Tau rank correlation coefficient for the two arrays\n * @throws DimensionMismatchException if the arrays lengths do not match\n */\npublic double correlation(final double[] xArray, final double[] yArray) throws DimensionMismatchException {\n    if (xArray.length != yArray.length) {\n        throw new DimensionMismatchException(xArray.length, yArray.length);\n    }\n    final int n = xArray.length;\n    final long numPairs = sum(n - 1);\n    @SuppressWarnings(\"unchecked\")\n    Pair<Double, Double>[] pairs = new Pair[n];\n    for (int i = 0; i < n; i++) {\n        pairs[i] = new Pair<Double, Double>(xArray[i], yArray[i]);\n    }\n    Arrays.sort(pairs, new Comparator<Pair<Double, Double>>() {\n\n        @Override\n        public int compare(Pair<Double, Double> pair1, Pair<Double, Double> pair2) {\n            int compareFirst = pair1.getFirst().compareTo(pair2.getFirst());\n            return compareFirst != 0 ? compareFirst : pair1.getSecond().compareTo(pair2.getSecond());\n        }\n    });\n    long tiedXPairs = 0;\n    long tiedXYPairs = 0;\n    long consecutiveXTies = 1;\n    long consecutiveXYTies = 1;\n    Pair<Double, Double> prev = pairs[0];\n    for (int i = 1; i < n; i++) {\n        final Pair<Double, Double> curr = pairs[i];\n        if (curr.getFirst().equals(prev.getFirst())) {\n            consecutiveXTies++;\n            if (curr.getSecond().equals(prev.getSecond())) {\n                consecutiveXYTies++;\n            } else {\n                tiedXYPairs += sum(consecutiveXYTies - 1);\n                consecutiveXYTies = 1;\n            }\n        } else {\n            tiedXPairs += sum(consecutiveXTies - 1);\n            consecutiveXTies = 1;\n            tiedXYPairs += sum(consecutiveXYTies - 1);\n            consecutiveXYTies = 1;\n        }\n        prev = curr;\n    }\n    tiedXPairs += sum(consecutiveXTies - 1);\n    tiedXYPairs += sum(consecutiveXYTies - 1);\n    int swaps = 0;\n    @SuppressWarnings(\"unchecked\")\n    Pair<Double, Double>[] pairsDestination = new Pair[n];\n    for (int segmentSize = 1; segmentSize < n; segmentSize <<= 1) {\n        for (int offset = 0; offset < n; offset += 2 * segmentSize) {\n            int i = offset;\n            final int iEnd = FastMath.min(i + segmentSize, n);\n            int j = iEnd;\n            final int jEnd = FastMath.min(j + segmentSize, n);\n            int copyLocation = offset;\n            while (i < iEnd || j < jEnd) {\n                if (i < iEnd) {\n                    if (j < jEnd) {\n                        if (pairs[i].getSecond().compareTo(pairs[j].getSecond()) <= 0) {\n                            pairsDestination[copyLocation] = pairs[i];\n                            i++;\n                        } else {\n                            pairsDestination[copyLocation] = pairs[j];\n                            j++;\n                            swaps += iEnd - i;\n                        }\n                    } else {\n                        pairsDestination[copyLocation] = pairs[i];\n                        i++;\n                    }\n                } else {\n                    pairsDestination[copyLocation] = pairs[j];\n                    j++;\n                }\n                copyLocation++;\n            }\n        }\n        final Pair<Double, Double>[] pairsTemp = pairs;\n        pairs = pairsDestination;\n        pairsDestination = pairsTemp;\n    }\n    long tiedYPairs = 0;\n    long consecutiveYTies = 1;\n    prev = pairs[0];\n    for (int i = 1; i < n; i++) {\n        final Pair<Double, Double> curr = pairs[i];\n        if (curr.getSecond().equals(prev.getSecond())) {\n            consecutiveYTies++;\n        } else {\n            tiedYPairs += sum(consecutiveYTies - 1);\n            consecutiveYTies = 1;\n        }\n        prev = curr;\n    }\n    tiedYPairs += sum(consecutiveYTies - 1);\n    final long concordantMinusDiscordant = numPairs - tiedXPairs - tiedYPairs + tiedXYPairs - 2 * swaps;\n    final double nonTiedPairsMultiplied = (numPairs - tiedXPairs) * (double) (numPairs - tiedYPairs);\n    return concordantMinusDiscordant / FastMath.sqrt(nonTiedPairsMultiplied);\n}", "code_comment": "/**\n * Computes the Kendall's Tau rank correlation coefficient between the two arrays.\n *\n * @param xArray first data array\n * @param yArray second data array\n * @return Returns Kendall's Tau rank correlation coefficient for the two arrays\n * @throws DimensionMismatchException if the arrays lengths do not match\n */\n", "code_no_comment": "public double correlation(final double[] xArray, final double[] yArray) throws DimensionMismatchException {\n    if (xArray.length != yArray.length) {\n        throw new DimensionMismatchException(xArray.length, yArray.length);\n    }\n    final int n = xArray.length;\n    final long numPairs = sum(n - 1);\n    @SuppressWarnings(\"unchecked\")\n    Pair<Double, Double>[] pairs = new Pair[n];\n    for (int i = 0; i < n; i++) {\n        pairs[i] = new Pair<Double, Double>(xArray[i], yArray[i]);\n    }\n    Arrays.sort(pairs, new Comparator<Pair<Double, Double>>() {\n\n        @Override\n        public int compare(Pair<Double, Double> pair1, Pair<Double, Double> pair2) {\n            int compareFirst = pair1.getFirst().compareTo(pair2.getFirst());\n            return compareFirst != 0 ? compareFirst : pair1.getSecond().compareTo(pair2.getSecond());\n        }\n    });\n    long tiedXPairs = 0;\n    long tiedXYPairs = 0;\n    long consecutiveXTies = 1;\n    long consecutiveXYTies = 1;\n    Pair<Double, Double> prev = pairs[0];\n    for (int i = 1; i < n; i++) {\n        final Pair<Double, Double> curr = pairs[i];\n        if (curr.getFirst().equals(prev.getFirst())) {\n            consecutiveXTies++;\n            if (curr.getSecond().equals(prev.getSecond())) {\n                consecutiveXYTies++;\n            } else {\n                tiedXYPairs += sum(consecutiveXYTies - 1);\n                consecutiveXYTies = 1;\n            }\n        } else {\n            tiedXPairs += sum(consecutiveXTies - 1);\n            consecutiveXTies = 1;\n            tiedXYPairs += sum(consecutiveXYTies - 1);\n            consecutiveXYTies = 1;\n        }\n        prev = curr;\n    }\n    tiedXPairs += sum(consecutiveXTies - 1);\n    tiedXYPairs += sum(consecutiveXYTies - 1);\n    int swaps = 0;\n    @SuppressWarnings(\"unchecked\")\n    Pair<Double, Double>[] pairsDestination = new Pair[n];\n    for (int segmentSize = 1; segmentSize < n; segmentSize <<= 1) {\n        for (int offset = 0; offset < n; offset += 2 * segmentSize) {\n            int i = offset;\n            final int iEnd = FastMath.min(i + segmentSize, n);\n            int j = iEnd;\n            final int jEnd = FastMath.min(j + segmentSize, n);\n            int copyLocation = offset;\n            while (i < iEnd || j < jEnd) {\n                if (i < iEnd) {\n                    if (j < jEnd) {\n                        if (pairs[i].getSecond().compareTo(pairs[j].getSecond()) <= 0) {\n                            pairsDestination[copyLocation] = pairs[i];\n                            i++;\n                        } else {\n                            pairsDestination[copyLocation] = pairs[j];\n                            j++;\n                            swaps += iEnd - i;\n                        }\n                    } else {\n                        pairsDestination[copyLocation] = pairs[i];\n                        i++;\n                    }\n                } else {\n                    pairsDestination[copyLocation] = pairs[j];\n                    j++;\n                }\n                copyLocation++;\n            }\n        }\n        final Pair<Double, Double>[] pairsTemp = pairs;\n        pairs = pairsDestination;\n        pairsDestination = pairsTemp;\n    }\n    long tiedYPairs = 0;\n    long consecutiveYTies = 1;\n    prev = pairs[0];\n    for (int i = 1; i < n; i++) {\n        final Pair<Double, Double> curr = pairs[i];\n        if (curr.getSecond().equals(prev.getSecond())) {\n            consecutiveYTies++;\n        } else {\n            tiedYPairs += sum(consecutiveYTies - 1);\n            consecutiveYTies = 1;\n        }\n        prev = curr;\n    }\n    tiedYPairs += sum(consecutiveYTies - 1);\n    final long concordantMinusDiscordant = numPairs - tiedXPairs - tiedYPairs + tiedXYPairs - 2 * swaps;\n    final double nonTiedPairsMultiplied = (numPairs - tiedXPairs) * (double) (numPairs - tiedYPairs);\n    return concordantMinusDiscordant / FastMath.sqrt(nonTiedPairsMultiplied);\n}", "lc": 3.772727272727273, "pi": 1.9665071770334928, "ma": 2.4, "nbd": 2.0, "ml": 2.1666666666666665, "d": 6.067460317460318, "mi": -1.3475687103594076, "fo": 2.0, "r": -0.02631578947368421, "e": 33.64990001325472}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-727_d2777388", "label": 1, "code": "/**\n * {@inheritDoc}\n */\n@Override\npublic void integrate(final ExpandableStatefulODE equations, final double t) throws MathIllegalStateException, MathIllegalArgumentException {\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n    // create some internal working arrays\n    final double[] y0 = equations.getCompleteState();\n    final double[] y = y0.clone();\n    final int stages = c.length + 1;\n    final double[][] yDotK = new double[stages][y.length];\n    final double[] yTmp = y0.clone();\n    final double[] yDotTmp = new double[y.length];\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward, equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n    // set up integration control objects\n    stepStart = equations.getTime();\n    double hNew = 0;\n    boolean firstTime = true;\n    initIntegration(equations.getTime(), y0, t);\n    // main integration loop\n    isLastStep = false;\n    do {\n        interpolator.shift();\n        // iterate over step size, ensuring local normalized error is smaller than 1\n        double error = 10;\n        while (error >= 1.0) {\n            if (firstTime || !fsal) {\n                // first stage\n                computeDerivatives(stepStart, y, yDotK[0]);\n            }\n            if (firstTime) {\n                final double[] scale = new double[mainSetDimension];\n                if (vecAbsoluteTolerance == null) {\n                    for (int i = 0; i < scale.length; ++i) {\n                        scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);\n                    }\n                } else {\n                    for (int i = 0; i < scale.length; ++i) {\n                        scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);\n                    }\n                }\n                hNew = initializeStep(forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]);\n                firstTime = false;\n            }\n            stepSize = hNew;\n            // next stages\n            for (int k = 1; k < stages; ++k) {\n                for (int j = 0; j < y0.length; ++j) {\n                    double sum = a[k - 1][0] * yDotK[0][j];\n                    for (int l = 1; l < k; ++l) {\n                        sum += a[k - 1][l] * yDotK[l][j];\n                    }\n                    yTmp[j] = y[j] + stepSize * sum;\n                }\n                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);\n            }\n            // estimate the state at the end of the step\n            for (int j = 0; j < y0.length; ++j) {\n                double sum = b[0] * yDotK[0][j];\n                for (int l = 1; l < stages; ++l) {\n                    sum += b[l] * yDotK[l][j];\n                }\n                yTmp[j] = y[j] + stepSize * sum;\n            }\n            // estimate the error at the end of the step\n            error = estimateError(yDotK, y, yTmp, stepSize);\n            if (error >= 1.0) {\n                // reject the step and attempt to reduce error by stepsize control\n                final double factor = FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n                hNew = filterStep(stepSize * factor, forward, false);\n            }\n        }\n        // local error is small enough: accept the step, trigger events and step handlers\n        interpolator.storeTime(stepStart + stepSize);\n        System.arraycopy(yTmp, 0, y, 0, y0.length);\n        System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n        stepStart = acceptStep(interpolator, y, yDotTmp, t);\n        System.arraycopy(y, 0, yTmp, 0, y.length);\n        if (!isLastStep) {\n            // prepare next step\n            interpolator.storeTime(stepStart);\n            if (fsal) {\n                // save the last evaluation for the next step\n                System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);\n            }\n            // stepsize control for next step\n            final double factor = FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n            final double scaledH = stepSize * factor;\n            final double nextT = stepStart + scaledH;\n            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n            hNew = filterStep(scaledH, forward, nextIsLast);\n            final double filteredNextT = stepStart + hNew;\n            final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);\n            if (filteredNextIsLast) {\n                hNew = t - stepStart;\n            }\n        }\n    } while (!isLastStep);\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n    resetInternalState();\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "@Override\npublic void integrate(final ExpandableStatefulODE equations, final double t) throws MathIllegalStateException, MathIllegalArgumentException {\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n        final double[] y0 = equations.getCompleteState();\n    final double[] y = y0.clone();\n    final int stages = c.length + 1;\n    final double[][] yDotK = new double[stages][y.length];\n    final double[] yTmp = y0.clone();\n    final double[] yDotTmp = new double[y.length];\n        final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward, equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n        stepStart = equations.getTime();\n    double hNew = 0;\n    boolean firstTime = true;\n    initIntegration(equations.getTime(), y0, t);\n        isLastStep = false;\n    do {\n        interpolator.shift();\n                double error = 10;\n        while (error >= 1.0) {\n            if (firstTime || !fsal) {\n                                computeDerivatives(stepStart, y, yDotK[0]);\n            }\n            if (firstTime) {\n                final double[] scale = new double[mainSetDimension];\n                if (vecAbsoluteTolerance == null) {\n                    for (int i = 0; i < scale.length; ++i) {\n                        scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);\n                    }\n                } else {\n                    for (int i = 0; i < scale.length; ++i) {\n                        scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);\n                    }\n                }\n                hNew = initializeStep(forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]);\n                firstTime = false;\n            }\n            stepSize = hNew;\n                        for (int k = 1; k < stages; ++k) {\n                for (int j = 0; j < y0.length; ++j) {\n                    double sum = a[k - 1][0] * yDotK[0][j];\n                    for (int l = 1; l < k; ++l) {\n                        sum += a[k - 1][l] * yDotK[l][j];\n                    }\n                    yTmp[j] = y[j] + stepSize * sum;\n                }\n                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);\n            }\n                        for (int j = 0; j < y0.length; ++j) {\n                double sum = b[0] * yDotK[0][j];\n                for (int l = 1; l < stages; ++l) {\n                    sum += b[l] * yDotK[l][j];\n                }\n                yTmp[j] = y[j] + stepSize * sum;\n            }\n                        error = estimateError(yDotK, y, yTmp, stepSize);\n            if (error >= 1.0) {\n                                final double factor = FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n                hNew = filterStep(stepSize * factor, forward, false);\n            }\n        }\n                interpolator.storeTime(stepStart + stepSize);\n        System.arraycopy(yTmp, 0, y, 0, y0.length);\n        System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n        stepStart = acceptStep(interpolator, y, yDotTmp, t);\n        System.arraycopy(y, 0, yTmp, 0, y.length);\n        if (!isLastStep) {\n                        interpolator.storeTime(stepStart);\n            if (fsal) {\n                                System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);\n            }\n                        final double factor = FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n            final double scaledH = stepSize * factor;\n            final double nextT = stepStart + scaledH;\n            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n            hNew = filterStep(scaledH, forward, nextIsLast);\n            final double filteredNextT = stepStart + hNew;\n            final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);\n            if (filteredNextIsLast) {\n                hNew = t - stepStart;\n            }\n        }\n    } while (!isLastStep);\n        equations.setTime(stepStart);\n    equations.setCompleteState(y);\n    resetInternalState();\n}", "lc": 3.4545454545454546, "pi": 1.444976076555024, "ma": 3.0, "nbd": 1.5, "ml": 2.3333333333333335, "d": 4.327380952380952, "mi": -1.3670190274841434, "fo": 2.9166666666666665, "r": -0.02631578947368421, "e": 30.99054534557378}
{"project_name": "Closure", "project_version": 158, "label": 2, "code": "CommandLineConfig setJscompWarning(List<String> jscompWarning) {\n    this.jscompWarning.clear();\n    this.jscompWarning.addAll(jscompWarning);\n    return this;\n}", "code_comment": NaN, "code_no_comment": "CommandLineConfig setJscompWarning(List<String> jscompWarning) {\n    this.jscompWarning.clear();\n    this.jscompWarning.addAll(jscompWarning);\n    return this;\n}", "lc": -0.4090909090909091, "pi": -0.49282296650717716, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.723749119097956, "fo": -0.3333333333333333, "r": 0.07894736842105263, "e": -0.16279340490885932}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-385_7c2ce5cf", "label": 1, "code": "/**\n * Returns the next potential rollover time.\n * @param current The current time.\n * @param increment The increment to the next time.\n * @param modulus If true the time will be rounded to occur on a boundary aligned with the increment.\n * @return the next potential rollover time and the timestamp for the target file.\n */\npublic long getNextTime(final long current, final int increment, final boolean modulus) {\n    prevFileTime = nextFileTime;\n    long nextTime;\n    if (frequency == null) {\n        throw new IllegalStateException(\"Pattern does not contain a date\");\n    }\n    final Calendar currentCal = Calendar.getInstance();\n    currentCal.setTimeInMillis(current);\n    final Calendar cal = Calendar.getInstance();\n    cal.set(currentCal.get(Calendar.YEAR), 0, 1, 0, 0, 0);\n    cal.set(Calendar.MILLISECOND, 0);\n    if (frequency == RolloverFrequency.ANNUALLY) {\n        increment(cal, Calendar.YEAR, increment, modulus);\n        nextTime = cal.getTimeInMillis();\n        cal.add(Calendar.YEAR, -1);\n        nextFileTime = cal.getTimeInMillis();\n        return nextTime;\n    }\n    if (frequency == RolloverFrequency.MONTHLY) {\n        increment(cal, Calendar.MONTH, increment, modulus);\n        nextTime = cal.getTimeInMillis();\n        cal.add(Calendar.MONTH, -1);\n        nextFileTime = cal.getTimeInMillis();\n        return nextTime;\n    }\n    if (frequency == RolloverFrequency.WEEKLY) {\n        increment(cal, Calendar.WEEK_OF_YEAR, increment, modulus);\n        nextTime = cal.getTimeInMillis();\n        cal.add(Calendar.WEEK_OF_YEAR, -1);\n        nextFileTime = cal.getTimeInMillis();\n        return nextTime;\n    }\n    cal.set(Calendar.DAY_OF_YEAR, currentCal.get(Calendar.DAY_OF_YEAR));\n    if (frequency == RolloverFrequency.DAILY) {\n        increment(cal, Calendar.DAY_OF_YEAR, increment, modulus);\n        nextTime = cal.getTimeInMillis();\n        cal.add(Calendar.DAY_OF_YEAR, -1);\n        nextFileTime = cal.getTimeInMillis();\n        return nextTime;\n    }\n    cal.set(Calendar.HOUR, currentCal.get(Calendar.HOUR));\n    if (frequency == RolloverFrequency.HOURLY) {\n        increment(cal, Calendar.HOUR, increment, modulus);\n        nextTime = cal.getTimeInMillis();\n        cal.add(Calendar.HOUR, -1);\n        nextFileTime = cal.getTimeInMillis();\n        return nextTime;\n    }\n    cal.set(Calendar.MINUTE, currentCal.get(Calendar.MINUTE));\n    if (frequency == RolloverFrequency.EVERY_MINUTE) {\n        increment(cal, Calendar.MINUTE, increment, modulus);\n        nextTime = cal.getTimeInMillis();\n        cal.add(Calendar.MINUTE, -1);\n        nextFileTime = cal.getTimeInMillis();\n        return nextTime;\n    }\n    cal.set(Calendar.SECOND, currentCal.get(Calendar.SECOND));\n    if (frequency == RolloverFrequency.EVERY_SECOND) {\n        increment(cal, Calendar.SECOND, increment, modulus);\n        nextTime = cal.getTimeInMillis();\n        cal.add(Calendar.SECOND, -1);\n        nextFileTime = cal.getTimeInMillis();\n        return nextTime;\n    }\n    increment(cal, Calendar.MILLISECOND, increment, modulus);\n    nextTime = cal.getTimeInMillis();\n    cal.add(Calendar.MILLISECOND, -1);\n    nextFileTime = cal.getTimeInMillis();\n    return nextTime;\n}", "code_comment": "/**\n * Returns the next potential rollover time.\n * @param current The current time.\n * @param increment The increment to the next time.\n * @param modulus If true the time will be rounded to occur on a boundary aligned with the increment.\n * @return the next potential rollover time and the timestamp for the target file.\n */\n", "code_no_comment": "public long getNextTime(final long current, final int increment, final boolean modulus) {\n    prevFileTime = nextFileTime;\n    long nextTime;\n    if (frequency == null) {\n        throw new IllegalStateException(\"Pattern does not contain a date\");\n    }\n    final Calendar currentCal = Calendar.getInstance();\n    currentCal.setTimeInMillis(current);\n    final Calendar cal = Calendar.getInstance();\n    cal.set(currentCal.get(Calendar.YEAR), 0, 1, 0, 0, 0);\n    cal.set(Calendar.MILLISECOND, 0);\n    if (frequency == RolloverFrequency.ANNUALLY) {\n        increment(cal, Calendar.YEAR, increment, modulus);\n        nextTime = cal.getTimeInMillis();\n        cal.add(Calendar.YEAR, -1);\n        nextFileTime = cal.getTimeInMillis();\n        return nextTime;\n    }\n    if (frequency == RolloverFrequency.MONTHLY) {\n        increment(cal, Calendar.MONTH, increment, modulus);\n        nextTime = cal.getTimeInMillis();\n        cal.add(Calendar.MONTH, -1);\n        nextFileTime = cal.getTimeInMillis();\n        return nextTime;\n    }\n    if (frequency == RolloverFrequency.WEEKLY) {\n        increment(cal, Calendar.WEEK_OF_YEAR, increment, modulus);\n        nextTime = cal.getTimeInMillis();\n        cal.add(Calendar.WEEK_OF_YEAR, -1);\n        nextFileTime = cal.getTimeInMillis();\n        return nextTime;\n    }\n    cal.set(Calendar.DAY_OF_YEAR, currentCal.get(Calendar.DAY_OF_YEAR));\n    if (frequency == RolloverFrequency.DAILY) {\n        increment(cal, Calendar.DAY_OF_YEAR, increment, modulus);\n        nextTime = cal.getTimeInMillis();\n        cal.add(Calendar.DAY_OF_YEAR, -1);\n        nextFileTime = cal.getTimeInMillis();\n        return nextTime;\n    }\n    cal.set(Calendar.HOUR, currentCal.get(Calendar.HOUR));\n    if (frequency == RolloverFrequency.HOURLY) {\n        increment(cal, Calendar.HOUR, increment, modulus);\n        nextTime = cal.getTimeInMillis();\n        cal.add(Calendar.HOUR, -1);\n        nextFileTime = cal.getTimeInMillis();\n        return nextTime;\n    }\n    cal.set(Calendar.MINUTE, currentCal.get(Calendar.MINUTE));\n    if (frequency == RolloverFrequency.EVERY_MINUTE) {\n        increment(cal, Calendar.MINUTE, increment, modulus);\n        nextTime = cal.getTimeInMillis();\n        cal.add(Calendar.MINUTE, -1);\n        nextFileTime = cal.getTimeInMillis();\n        return nextTime;\n    }\n    cal.set(Calendar.SECOND, currentCal.get(Calendar.SECOND));\n    if (frequency == RolloverFrequency.EVERY_SECOND) {\n        increment(cal, Calendar.SECOND, increment, modulus);\n        nextTime = cal.getTimeInMillis();\n        cal.add(Calendar.SECOND, -1);\n        nextFileTime = cal.getTimeInMillis();\n        return nextTime;\n    }\n    increment(cal, Calendar.MILLISECOND, increment, modulus);\n    nextTime = cal.getTimeInMillis();\n    cal.add(Calendar.MILLISECOND, -1);\n    nextFileTime = cal.getTimeInMillis();\n    return nextTime;\n}", "lc": 2.5454545454545454, "pi": -0.368421052631579, "ma": 1.2, "nbd": -0.5, "ml": 0.3333333333333333, "d": 0.8353174603174603, "mi": -1.0955602536997884, "fo": 3.3333333333333335, "r": -0.02631578947368421, "e": 3.9140609602185297}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-278_db19e70f", "label": 1, "code": "private Status internalGetPropertyStatus(String name) {\n    NodeState baseState = getBaseState();\n    boolean exists = internalGetProperty(name) != null;\n    if (baseState == null) {\n        // This instance is NEW...\n        if (exists) {\n            // ...so all children are new\n            return Status.NEW;\n        } else {\n            // ...unless they don't exist.\n            return null;\n        }\n    } else {\n        if (exists) {\n            // We have the property...\n            if (baseState.getProperty(name) == null) {\n                // ...but didn't have it before. So its NEW.\n                return Status.NEW;\n            } else {\n                // ... and did have it before. So...\n                PropertyState base = baseState.getProperty(name);\n                PropertyState head = getProperty(name);\n                if (base == null ? head == null : base.equals(head)) {\n                    // ...it's EXISTING if it hasn't changed\n                    return Status.EXISTING;\n                } else {\n                    // ...and MODIFIED otherwise.\n                    return Status.MODIFIED;\n                }\n            }\n        } else {\n            // We don't have the property\n            if (baseState.getProperty(name) == null) {\n                // ...and didn't have it before. So it doesn't exist.\n                return null;\n            } else {\n                // ...but did have it before. So it's REMOVED\n                return Status.REMOVED;\n            }\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "private Status internalGetPropertyStatus(String name) {\n    NodeState baseState = getBaseState();\n    boolean exists = internalGetProperty(name) != null;\n    if (baseState == null) {\n                if (exists) {\n                        return Status.NEW;\n        } else {\n                        return null;\n        }\n    } else {\n        if (exists) {\n                        if (baseState.getProperty(name) == null) {\n                                return Status.NEW;\n            } else {\n                                PropertyState base = baseState.getProperty(name);\n                PropertyState head = getProperty(name);\n                if (base == null ? head == null : base.equals(head)) {\n                                        return Status.EXISTING;\n                } else {\n                                        return Status.MODIFIED;\n                }\n            }\n        } else {\n                        if (baseState.getProperty(name) == null) {\n                                return null;\n            } else {\n                                return Status.REMOVED;\n            }\n        }\n    }\n}", "lc": 0.7727272727272727, "pi": 1.1578947368421053, "ma": 0.8, "nbd": 1.0, "ml": 0.5833333333333334, "d": 0.15079365079365079, "mi": -0.4686398872445383, "fo": 0.08333333333333333, "r": -0.02631578947368421, "e": 0.17339257620027315}
{"project_name": "maven", "project_version": "remotes/origin/bugs-dot-jar_MNG-5075_2eb419ed", "label": 1, "code": "public MavenProject getParent() {\n    if (parent == null) {\n        /*\n             * TODO: This is suboptimal. Without a cache in the project builder, rebuilding the parent chain currently\n             * causes O(n^2) parser invocations for an inheritance hierarchy of depth n.\n             */\n        if (parentFile != null) {\n            checkProjectBuildingRequest();\n            ProjectBuildingRequest request = new DefaultProjectBuildingRequest(projectBuilderConfiguration);\n            request.setRemoteRepositories(getRemoteArtifactRepositories());\n            try {\n                parent = mavenProjectBuilder.build(parentFile, request).getProject();\n            } catch (ProjectBuildingException e) {\n                throw new IllegalStateException(\"Failed to build parent project for \" + getId(), e);\n            }\n        } else if (model.getParent() != null) {\n            checkProjectBuildingRequest();\n            ProjectBuildingRequest request = new DefaultProjectBuildingRequest(projectBuilderConfiguration);\n            request.setRemoteRepositories(getRemoteArtifactRepositories());\n            try {\n                parent = mavenProjectBuilder.build(getParentArtifact(), request).getProject();\n            } catch (ProjectBuildingException e) {\n                throw new IllegalStateException(\"Failed to build parent project for \" + getId(), e);\n            }\n        }\n    }\n    return parent;\n}", "code_comment": NaN, "code_no_comment": "public MavenProject getParent() {\n    if (parent == null) {\n                if (parentFile != null) {\n            checkProjectBuildingRequest();\n            ProjectBuildingRequest request = new DefaultProjectBuildingRequest(projectBuilderConfiguration);\n            request.setRemoteRepositories(getRemoteArtifactRepositories());\n            try {\n                parent = mavenProjectBuilder.build(parentFile, request).getProject();\n            } catch (ProjectBuildingException e) {\n                throw new IllegalStateException(\"Failed to build parent project for \" + getId(), e);\n            }\n        } else if (model.getParent() != null) {\n            checkProjectBuildingRequest();\n            ProjectBuildingRequest request = new DefaultProjectBuildingRequest(projectBuilderConfiguration);\n            request.setRemoteRepositories(getRemoteArtifactRepositories());\n            try {\n                parent = mavenProjectBuilder.build(getParentArtifact(), request).getProject();\n            } catch (ProjectBuildingException e) {\n                throw new IllegalStateException(\"Failed to build parent project for \" + getId(), e);\n            }\n        }\n    }\n    return parent;\n}", "lc": 0.45454545454545453, "pi": 0.7799043062200957, "ma": 0.8, "nbd": 1.0, "ml": 0.08333333333333333, "d": 0.5138888888888888, "mi": -0.3541930937279773, "fo": 0.6666666666666666, "r": -0.02631578947368421, "e": 0.42051140194671593}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-344_a0b4b4b7", "label": 0, "code": "/**\n * Find a zero in the given interval with an initial guess.\n * <p>Throws <code>IllegalArgumentException</code> if the values of the\n * function at the three points have the same sign (note that it is\n * allowed to have endpoints with the same sign if the initial point has\n * opposite sign function-wise).</p>\n *\n * @param f function to solve.\n * @param min the lower bound for the interval.\n * @param max the upper bound for the interval.\n * @param initial the start value to use (must be set to min if no\n * initial point is known).\n * @return the value where the function is zero\n * @throws MaxIterationsExceededException the maximum iteration count\n * is exceeded\n * @throws FunctionEvaluationException if an error occurs evaluating\n *  the function\n * @throws IllegalArgumentException if initial is not between min and max\n * (even if it <em>is</em> a root)\n */\npublic double solve(final UnivariateRealFunction f, final double min, final double max, final double initial) throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifySequence(min, initial, max);\n    // return the initial guess if it is good enough\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n    // return the first endpoint if it is good enough\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(yMin, 0);\n        return result;\n    }\n    // reduce interval if min and initial bracket the root\n    if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n    // return the second endpoint if it is good enough\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(yMax, 0);\n        return result;\n    }\n    // reduce interval if initial and max bracket the root\n    if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }\n    if (yMin * yMax > 0) {\n        throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n    }\n    // full Brent algorithm starting with provided initial guess\n    return solve(f, min, yMin, max, yMax, initial, yInitial);\n}", "code_comment": "/**\n * Find a zero in the given interval with an initial guess.\n * <p>Throws <code>IllegalArgumentException</code> if the values of the\n * function at the three points have the same sign (note that it is\n * allowed to have endpoints with the same sign if the initial point has\n * opposite sign function-wise).</p>\n *\n * @param f function to solve.\n * @param min the lower bound for the interval.\n * @param max the upper bound for the interval.\n * @param initial the start value to use (must be set to min if no\n * initial point is known).\n * @return the value where the function is zero\n * @throws MaxIterationsExceededException the maximum iteration count\n * is exceeded\n * @throws FunctionEvaluationException if an error occurs evaluating\n *  the function\n * @throws IllegalArgumentException if initial is not between min and max\n * (even if it <em>is</em> a root)\n */\n", "code_no_comment": "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial) throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifySequence(min, initial, max);\n        double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n        double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(yMin, 0);\n        return result;\n    }\n        if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n        double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(yMax, 0);\n        return result;\n    }\n        if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }\n    if (yMin * yMax > 0) {\n        throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n    }\n        return solve(f, min, yMin, max, yMax, initial, yInitial);\n}", "lc": 0.6818181818181818, "pi": -0.3444976076555025, "ma": 0.8, "nbd": -0.5, "ml": 0.6666666666666666, "d": 1.123015873015873, "mi": -0.5216349541930935, "fo": 0.75, "r": -0.02631578947368421, "e": 1.5505748517487594}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-5699_6d63a502", "label": 3, "code": "public String format(Exchange exchange) {\n    Message in = exchange.getIn();\n    StringBuilder sb = new StringBuilder();\n    if (showAll || showExchangeId) {\n        if (multiline) {\n            sb.append(LS);\n        }\n        sb.append(\", Id:\").append(exchange.getExchangeId());\n    }\n    if (showAll || showExchangePattern) {\n        if (multiline) {\n            sb.append(LS);\n        }\n        sb.append(\", ExchangePattern:\").append(exchange.getPattern());\n    }\n    if (showAll || showProperties) {\n        if (multiline) {\n            sb.append(LS);\n        }\n        sb.append(\", Properties:\").append(exchange.getProperties());\n    }\n    if (showAll || showHeaders) {\n        if (multiline) {\n            sb.append(LS);\n        }\n        sb.append(\", Headers:\").append(in.getHeaders());\n    }\n    if (showAll || showBodyType) {\n        if (multiline) {\n            sb.append(LS);\n        }\n        sb.append(\", BodyType:\").append(getBodyTypeAsString(in));\n    }\n    if (showAll || showBody) {\n        if (multiline) {\n            sb.append(LS);\n        }\n        sb.append(\", Body:\").append(getBodyAsString(in));\n    }\n    if (showAll || showException || showCaughtException) {\n        // try exception on exchange first\n        Exception exception = exchange.getException();\n        boolean caught = false;\n        if ((showAll || showCaughtException) && exception == null) {\n            // fallback to caught exception\n            exception = exchange.getProperty(Exchange.EXCEPTION_CAUGHT, Exception.class);\n            caught = true;\n        }\n        if (exception != null) {\n            if (multiline) {\n                sb.append(LS);\n            }\n            if (caught) {\n                sb.append(\", CaughtExceptionType:\").append(exception.getClass().getCanonicalName());\n                sb.append(\", CaughtExceptionMessage:\").append(exception.getMessage());\n            } else {\n                sb.append(\", ExceptionType:\").append(exception.getClass().getCanonicalName());\n                sb.append(\", ExceptionMessage:\").append(exception.getMessage());\n            }\n            if (showAll || showStackTrace) {\n                StringWriter sw = new StringWriter();\n                exception.printStackTrace(new PrintWriter(sw));\n                sb.append(\", StackTrace:\").append(sw.toString());\n            }\n        }\n    }\n    if (showAll || showOut) {\n        if (exchange.hasOut()) {\n            Message out = exchange.getOut();\n            if (showAll || showHeaders) {\n                if (multiline) {\n                    sb.append(LS);\n                }\n                sb.append(\", OutHeaders:\").append(out.getHeaders());\n            }\n            if (showAll || showBodyType) {\n                if (multiline) {\n                    sb.append(LS);\n                }\n                sb.append(\", OutBodyType:\").append(getBodyTypeAsString(out));\n            }\n            if (showAll || showBody) {\n                if (multiline) {\n                    sb.append(LS);\n                }\n                sb.append(\", OutBody:\").append(getBodyAsString(out));\n            }\n        } else {\n            if (multiline) {\n                sb.append(LS);\n            }\n            sb.append(\", Out: null\");\n        }\n    }\n    if (maxChars > 0) {\n        StringBuilder answer = new StringBuilder();\n        for (String s : sb.toString().split(LS)) {\n            if (s != null) {\n                if (s.length() > maxChars) {\n                    s = s.substring(0, maxChars);\n                    answer.append(s).append(\"...\");\n                } else {\n                    answer.append(s);\n                }\n                if (multiline) {\n                    answer.append(LS);\n                }\n            }\n        }\n        // get rid of the leading space comma if needed\n        return \"Exchange[\" + (multiline ? answer.append(']').toString() : answer.toString().substring(2) + \"]\");\n    }\n    // get rid of the leading space comma if needed\n    return \"Exchange[\" + (multiline ? sb.append(']').toString() : sb.toString().substring(2) + \"]\");\n}", "code_comment": NaN, "code_no_comment": "public String format(Exchange exchange) {\n    Message in = exchange.getIn();\n    StringBuilder sb = new StringBuilder();\n    if (showAll || showExchangeId) {\n        if (multiline) {\n            sb.append(LS);\n        }\n        sb.append(\", Id:\").append(exchange.getExchangeId());\n    }\n    if (showAll || showExchangePattern) {\n        if (multiline) {\n            sb.append(LS);\n        }\n        sb.append(\", ExchangePattern:\").append(exchange.getPattern());\n    }\n    if (showAll || showProperties) {\n        if (multiline) {\n            sb.append(LS);\n        }\n        sb.append(\", Properties:\").append(exchange.getProperties());\n    }\n    if (showAll || showHeaders) {\n        if (multiline) {\n            sb.append(LS);\n        }\n        sb.append(\", Headers:\").append(in.getHeaders());\n    }\n    if (showAll || showBodyType) {\n        if (multiline) {\n            sb.append(LS);\n        }\n        sb.append(\", BodyType:\").append(getBodyTypeAsString(in));\n    }\n    if (showAll || showBody) {\n        if (multiline) {\n            sb.append(LS);\n        }\n        sb.append(\", Body:\").append(getBodyAsString(in));\n    }\n    if (showAll || showException || showCaughtException) {\n                Exception exception = exchange.getException();\n        boolean caught = false;\n        if ((showAll || showCaughtException) && exception == null) {\n                        exception = exchange.getProperty(Exchange.EXCEPTION_CAUGHT, Exception.class);\n            caught = true;\n        }\n        if (exception != null) {\n            if (multiline) {\n                sb.append(LS);\n            }\n            if (caught) {\n                sb.append(\", CaughtExceptionType:\").append(exception.getClass().getCanonicalName());\n                sb.append(\", CaughtExceptionMessage:\").append(exception.getMessage());\n            } else {\n                sb.append(\", ExceptionType:\").append(exception.getClass().getCanonicalName());\n                sb.append(\", ExceptionMessage:\").append(exception.getMessage());\n            }\n            if (showAll || showStackTrace) {\n                StringWriter sw = new StringWriter();\n                exception.printStackTrace(new PrintWriter(sw));\n                sb.append(\", StackTrace:\").append(sw.toString());\n            }\n        }\n    }\n    if (showAll || showOut) {\n        if (exchange.hasOut()) {\n            Message out = exchange.getOut();\n            if (showAll || showHeaders) {\n                if (multiline) {\n                    sb.append(LS);\n                }\n                sb.append(\", OutHeaders:\").append(out.getHeaders());\n            }\n            if (showAll || showBodyType) {\n                if (multiline) {\n                    sb.append(LS);\n                }\n                sb.append(\", OutBodyType:\").append(getBodyTypeAsString(out));\n            }\n            if (showAll || showBody) {\n                if (multiline) {\n                    sb.append(LS);\n                }\n                sb.append(\", OutBody:\").append(getBodyAsString(out));\n            }\n        } else {\n            if (multiline) {\n                sb.append(LS);\n            }\n            sb.append(\", Out: null\");\n        }\n    }\n    if (maxChars > 0) {\n        StringBuilder answer = new StringBuilder();\n        for (String s : sb.toString().split(LS)) {\n            if (s != null) {\n                if (s.length() > maxChars) {\n                    s = s.substring(0, maxChars);\n                    answer.append(s).append(\"...\");\n                } else {\n                    answer.append(s);\n                }\n                if (multiline) {\n                    answer.append(LS);\n                }\n            }\n        }\n                return \"Exchange[\" + (multiline ? answer.append(']').toString() : answer.toString().substring(2) + \"]\");\n    }\n        return \"Exchange[\" + (multiline ? sb.append(']').toString() : sb.toString().substring(2) + \"]\");\n}", "lc": 4.409090909090909, "pi": 0.923444976076555, "ma": 6.2, "nbd": 1.0, "ml": 5.083333333333333, "d": 1.6626984126984128, "mi": -1.5037350246652568, "fo": 6.0, "r": -0.02631578947368421, "e": 8.611379471309277}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-3394_18e1a142", "label": 3, "code": "/**\n * Common work which must be done when we are done multicasting.\n * <p/>\n * This logic applies for both running synchronous and asynchronous as there are multiple exist points\n * when using the asynchronous routing engine. And therefore we want the logic in one method instead\n * of being scattered.\n *\n * @param original    the original exchange\n * @param subExchange the current sub exchange, can be <tt>null</tt> for the synchronous part\n * @param callback    the callback\n * @param doneSync    the <tt>doneSync</tt> parameter to call on callback\n */\nprotected void doDone(Exchange original, Exchange subExchange, AsyncCallback callback, boolean doneSync) {\n    // cleanup any per exchange aggregation strategy\n    removeAggregationStrategyFromExchange(original);\n    if (original.getException() != null) {\n        // multicast uses error handling on its output processors and they have tried to redeliver\n        // so we shall signal back to the other error handlers that we are exhausted and they should not\n        // also try to redeliver as we will then do that twice\n        original.setProperty(Exchange.REDELIVERY_EXHAUSTED, Boolean.TRUE);\n    }\n    if (subExchange != null) {\n        // and copy the current result to original so it will contain this exception\n        ExchangeHelper.copyResults(original, subExchange);\n    }\n    callback.done(doneSync);\n}", "code_comment": "/**\n * Common work which must be done when we are done multicasting.\n * <p/>\n * This logic applies for both running synchronous and asynchronous as there are multiple exist points\n * when using the asynchronous routing engine. And therefore we want the logic in one method instead\n * of being scattered.\n *\n * @param original    the original exchange\n * @param subExchange the current sub exchange, can be <tt>null</tt> for the synchronous part\n * @param callback    the callback\n * @param doneSync    the <tt>doneSync</tt> parameter to call on callback\n */\n", "code_no_comment": "protected void doDone(Exchange original, Exchange subExchange, AsyncCallback callback, boolean doneSync) {\n        removeAggregationStrategyFromExchange(original);\n    if (original.getException() != null) {\n                                original.setProperty(Exchange.REDELIVERY_EXHAUSTED, Boolean.TRUE);\n    }\n    if (subExchange != null) {\n                ExchangeHelper.copyResults(original, subExchange);\n    }\n    callback.done(doneSync);\n}", "lc": -0.18181818181818182, "pi": -0.2200956937799045, "ma": -0.2, "nbd": -0.5, "ml": -0.08333333333333333, "d": -0.3650793650793651, "mi": 0.19126145172656786, "fo": -0.08333333333333333, "r": 0.0, "e": -0.16279340490885932}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2642_36fe017c", "label": 0, "code": "public void dispose() {\n    runBackgroundOperations();\n    if (!isDisposed.getAndSet(true)) {\n        synchronized (isDisposed) {\n            isDisposed.notifyAll();\n        }\n        try {\n            backgroundThread.join();\n        } catch (InterruptedException e) {\n        // ignore\n        }\n        if (leaseUpdateThread != null) {\n            try {\n                leaseUpdateThread.join();\n            } catch (InterruptedException e) {\n            // ignore\n            }\n        }\n        if (clusterNodeInfo != null) {\n            clusterNodeInfo.dispose();\n        }\n        store.dispose();\n        LOG.info(\"Disposed DocumentNodeStore with clusterNodeId: {}\", clusterId);\n        if (blobStore instanceof Closeable) {\n            try {\n                ((Closeable) blobStore).close();\n            } catch (IOException ex) {\n                LOG.debug(\"Error closing blob store \" + blobStore, ex);\n            }\n        }\n    }\n    if (persistentCache != null) {\n        persistentCache.close();\n    }\n}", "code_comment": NaN, "code_no_comment": "public void dispose() {\n    runBackgroundOperations();\n    if (!isDisposed.getAndSet(true)) {\n        synchronized (isDisposed) {\n            isDisposed.notifyAll();\n        }\n        try {\n            backgroundThread.join();\n        } catch (InterruptedException e) {\n                }\n        if (leaseUpdateThread != null) {\n            try {\n                leaseUpdateThread.join();\n            } catch (InterruptedException e) {\n                        }\n        }\n        if (clusterNodeInfo != null) {\n            clusterNodeInfo.dispose();\n        }\n        store.dispose();\n        LOG.info(\"Disposed DocumentNodeStore with clusterNodeId: {}\", clusterId);\n        if (blobStore instanceof Closeable) {\n            try {\n                ((Closeable) blobStore).close();\n            } catch (IOException ex) {\n                LOG.debug(\"Error closing blob store \" + blobStore, ex);\n            }\n        }\n    }\n    if (persistentCache != null) {\n        persistentCache.close();\n    }\n}", "lc": 0.8636363636363636, "pi": 0.47846889952153115, "ma": 1.0, "nbd": 0.5, "ml": 0.4166666666666667, "d": -0.03373015873015876, "mi": -0.4841437632135305, "fo": 0.4166666666666667, "r": 0.05263157894736841, "e": 0.025728001475308748}
{"project_name": "Closure", "project_version": 169, "label": 2, "code": "private boolean hasAlternate(JSType type, boolean tolerateUnknowns) {\n    for (JSType alternate : alternates) {\n        if (alternate.checkEquivalenceHelper(type, tolerateUnknowns)) {\n            return true;\n        }\n    }\n    return false;\n}", "code_comment": NaN, "code_no_comment": "private boolean hasAlternate(JSType type, boolean tolerateUnknowns) {\n    for (JSType alternate : alternates) {\n        if (alternate.checkEquivalenceHelper(type, tolerateUnknowns)) {\n            return true;\n        }\n    }\n    return false;\n}", "lc": -0.2727272727272727, "pi": 0.42105263157894735, "ma": -0.2, "nbd": 0.0, "ml": -0.08333333333333333, "d": -0.3650793650793651, "mi": 0.4458069062720224, "fo": -0.4166666666666667, "r": 0.2368421052631579, "e": -0.16279340490885932}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-1008_0c20bfd8", "label": 1, "code": "/**\n * Add the class designated by the fully qualified class name provided to the set of\n * resolved classes if and only if it is approved by the Test supplied.\n *\n * @param test the test used to determine if the class matches\n * @param fqn the fully qualified name of a class\n */\nprotected void addIfMatching(final Test test, final String fqn) {\n    try {\n        final ClassLoader loader = getClassLoader();\n        if (test.doesMatchClass()) {\n            final String externalName = fqn.substring(0, fqn.indexOf('.')).replace('/', '.');\n            if (LOGGER.isDebugEnabled()) {\n                LOGGER.debug(\"Checking to see if class \" + externalName + \" matches criteria [\" + test + ']');\n            }\n            final Class<?> type = loader.loadClass(externalName);\n            if (test.matches(type)) {\n                classMatches.add(type);\n            }\n        }\n        if (test.doesMatchResource()) {\n            URL url = loader.getResource(fqn);\n            if (url == null) {\n                url = loader.getResource(fqn.substring(1));\n            }\n            if (url != null && test.matches(url.toURI())) {\n                resourceMatches.add(url.toURI());\n            }\n        }\n    } catch (final Throwable t) {\n        LOGGER.warn(\"Could not examine class '\" + fqn, t);\n    }\n}", "code_comment": "/**\n * Add the class designated by the fully qualified class name provided to the set of\n * resolved classes if and only if it is approved by the Test supplied.\n *\n * @param test the test used to determine if the class matches\n * @param fqn the fully qualified name of a class\n */\n", "code_no_comment": "protected void addIfMatching(final Test test, final String fqn) {\n    try {\n        final ClassLoader loader = getClassLoader();\n        if (test.doesMatchClass()) {\n            final String externalName = fqn.substring(0, fqn.indexOf('.')).replace('/', '.');\n            if (LOGGER.isDebugEnabled()) {\n                LOGGER.debug(\"Checking to see if class \" + externalName + \" matches criteria [\" + test + ']');\n            }\n            final Class<?> type = loader.loadClass(externalName);\n            if (test.matches(type)) {\n                classMatches.add(type);\n            }\n        }\n        if (test.doesMatchResource()) {\n            URL url = loader.getResource(fqn);\n            if (url == null) {\n                url = loader.getResource(fqn.substring(1));\n            }\n            if (url != null && test.matches(url.toURI())) {\n                resourceMatches.add(url.toURI());\n            }\n        }\n    } catch (final Throwable t) {\n        LOGGER.warn(\"Could not examine class '\" + fqn, t);\n    }\n}", "lc": 0.5454545454545454, "pi": 0.7081339712918658, "ma": 0.8, "nbd": 0.5, "ml": 0.8333333333333334, "d": 0.35119047619047616, "mi": -0.4621564482029596, "fo": 1.0833333333333333, "r": -0.02631578947368421, "e": 0.6093693631391802}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3272_c86b972a", "label": 1, "code": "/**\n *  Extracts the {@link PageComponentInfo} from the URL. The {@link PageComponentInfo} is encoded\n *  as the very first query parameter and the parameter consists of name only (no value).\n *\n *  @param url\n *\n *  @return PageComponentInfo instance if one was encoded in URL, <code>null</code> otherwise.\n */\nprotected PageComponentInfo getPageComponentInfo(Url url) {\n    if (url == null) {\n        throw new IllegalStateException(\"Argument 'url' may not be null.\");\n    }\n    if (url.getQueryParameters().size() > 0) {\n        QueryParameter param = url.getQueryParameters().get(0);\n        if (Strings.isEmpty(param.getValue())) {\n            return PageComponentInfo.parse(param.getName());\n        }\n    }\n    return null;\n}", "code_comment": "/**\n *  Extracts the {@link PageComponentInfo} from the URL. The {@link PageComponentInfo} is encoded\n *  as the very first query parameter and the parameter consists of name only (no value).\n *\n *  @param url\n *\n *  @return PageComponentInfo instance if one was encoded in URL, <code>null</code> otherwise.\n */\n", "code_no_comment": "protected PageComponentInfo getPageComponentInfo(Url url) {\n    if (url == null) {\n        throw new IllegalStateException(\"Argument 'url' may not be null.\");\n    }\n    if (url.getQueryParameters().size() > 0) {\n        QueryParameter param = url.getQueryParameters().get(0);\n        if (Strings.isEmpty(param.getValue())) {\n            return PageComponentInfo.parse(param.getName());\n        }\n    }\n    return null;\n}", "lc": -0.09090909090909091, "pi": 0.1961722488038276, "ma": 0.2, "nbd": 0.0, "ml": 0.16666666666666666, "d": -0.07341269841269843, "mi": 0.0878083157152923, "fo": 0.16666666666666666, "r": 0.31578947368421056, "e": -0.06886695135515176}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3196_f1c0f263", "label": 3, "code": "/**\n *  Returns <code>true</code> if the path is valid. A <code>null</code> value is considered\n *  invalid.\n *\n *  @param path\n *             a path value to validate.\n *  @return <code>true</code> if path is valid.\n */\nprotected boolean isValidPath(String path) {\n    if (path == null) {\n        return false;\n    }\n    Matcher pathMatcher = Pattern.compile(PATH_PATTERN).matcher(path);\n    if (!pathMatcher.matches()) {\n        return false;\n    }\n    int slash2Count = countToken(\"//\", path);\n    if (isOff(ALLOW_2_SLASHES) && (slash2Count > 0)) {\n        return false;\n    }\n    int slashCount = countToken(\"/\", path);\n    int dot2Count = countToken(\"..\", path);\n    if (dot2Count > 0) {\n        if ((slashCount - slash2Count - 1) <= dot2Count) {\n            return false;\n        }\n    }\n    return true;\n}", "code_comment": "/**\n *  Returns <code>true</code> if the path is valid. A <code>null</code> value is considered\n *  invalid.\n *\n *  @param path\n *             a path value to validate.\n *  @return <code>true</code> if path is valid.\n */\n", "code_no_comment": "protected boolean isValidPath(String path) {\n    if (path == null) {\n        return false;\n    }\n    Matcher pathMatcher = Pattern.compile(PATH_PATTERN).matcher(path);\n    if (!pathMatcher.matches()) {\n        return false;\n    }\n    int slash2Count = countToken(\"//\", path);\n    if (isOff(ALLOW_2_SLASHES) && (slash2Count > 0)) {\n        return false;\n    }\n    int slashCount = countToken(\"/\", path);\n    int dot2Count = countToken(\"..\", path);\n    if (dot2Count > 0) {\n        if ((slashCount - slash2Count - 1) <= dot2Count) {\n            return false;\n        }\n    }\n    return true;\n}", "lc": 0.3181818181818182, "pi": -0.12440191387559821, "ma": 0.4, "nbd": 0.0, "ml": 0.5833333333333334, "d": 0.634920634920635, "mi": -0.2696264975334742, "fo": 0.08333333333333333, "r": 0.0, "e": 0.45296358407819126}
{"project_name": "Compress", "project_version": 20, "label": 1, "code": "private CpioArchiveEntry readNewEntry(final boolean hasCrc) throws IOException {\n    CpioArchiveEntry ret;\n    if (hasCrc) {\n        ret = new CpioArchiveEntry(FORMAT_NEW_CRC);\n    } else {\n        ret = new CpioArchiveEntry(FORMAT_NEW);\n    }\n    ret.setInode(readAsciiLong(8, 16));\n    long mode = readAsciiLong(8, 16);\n    if (mode != 0) {\n        ret.setMode(mode);\n    }\n    ret.setUID(readAsciiLong(8, 16));\n    ret.setGID(readAsciiLong(8, 16));\n    ret.setNumberOfLinks(readAsciiLong(8, 16));\n    ret.setTime(readAsciiLong(8, 16));\n    ret.setSize(readAsciiLong(8, 16));\n    ret.setDeviceMaj(readAsciiLong(8, 16));\n    ret.setDeviceMin(readAsciiLong(8, 16));\n    ret.setRemoteDeviceMaj(readAsciiLong(8, 16));\n    ret.setRemoteDeviceMin(readAsciiLong(8, 16));\n    long namesize = readAsciiLong(8, 16);\n    ret.setChksum(readAsciiLong(8, 16));\n    String name = readCString((int) namesize);\n    ret.setName(name);\n    if (mode == 0 && !name.equals(CPIO_TRAILER)) {\n        throw new IOException(\"Mode 0 only allowed in the trailer. Found entry name: \" + name + \" Occured at byte: \" + getBytesRead());\n    }\n    skip(ret.getHeaderPadCount());\n    return ret;\n}", "code_comment": NaN, "code_no_comment": "private CpioArchiveEntry readNewEntry(final boolean hasCrc) throws IOException {\n    CpioArchiveEntry ret;\n    if (hasCrc) {\n        ret = new CpioArchiveEntry(FORMAT_NEW_CRC);\n    } else {\n        ret = new CpioArchiveEntry(FORMAT_NEW);\n    }\n    ret.setInode(readAsciiLong(8, 16));\n    long mode = readAsciiLong(8, 16);\n    if (mode != 0) {\n        ret.setMode(mode);\n    }\n    ret.setUID(readAsciiLong(8, 16));\n    ret.setGID(readAsciiLong(8, 16));\n    ret.setNumberOfLinks(readAsciiLong(8, 16));\n    ret.setTime(readAsciiLong(8, 16));\n    ret.setSize(readAsciiLong(8, 16));\n    ret.setDeviceMaj(readAsciiLong(8, 16));\n    ret.setDeviceMin(readAsciiLong(8, 16));\n    ret.setRemoteDeviceMaj(readAsciiLong(8, 16));\n    ret.setRemoteDeviceMin(readAsciiLong(8, 16));\n    long namesize = readAsciiLong(8, 16);\n    ret.setChksum(readAsciiLong(8, 16));\n    String name = readCString((int) namesize);\n    ret.setName(name);\n    if (mode == 0 && !name.equals(CPIO_TRAILER)) {\n        throw new IOException(\"Mode 0 only allowed in the trailer. Found entry name: \" + name + \" Occured at byte: \" + getBytesRead());\n    }\n    skip(ret.getHeaderPadCount());\n    return ret;\n}", "lc": 0.7727272727272727, "pi": -0.598086124401914, "ma": 0.2, "nbd": -0.5, "ml": 0.16666666666666666, "d": 1.2916666666666665, "mi": -0.5639182522903451, "fo": 2.0833333333333335, "r": -0.02631578947368421, "e": 2.198060199512456}
{"project_name": "Math", "project_version": 92, "label": 1, "code": "/**\n * Returns a <code>double</code> representation of the <a\n * href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\"> Binomial\n * Coefficient</a>, \"<code>n choose k</code>\", the number of\n * <code>k</code>-element subsets that can be selected from an\n * <code>n</code>-element set.\n * <p>\n * <Strong>Preconditions</strong>:\n * <ul>\n * <li> <code>0 <= k <= n </code> (otherwise\n * <code>IllegalArgumentException</code> is thrown)</li>\n * <li> The result is small enough to fit into a <code>double</code>. The\n * largest value of <code>n</code> for which all coefficients are <\n * Double.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE,\n * Double.POSITIVE_INFINITY is returned</li>\n * </ul></p>\n *\n * @param n the size of the set\n * @param k the size of the subsets to be counted\n * @return <code>n choose k</code>\n * @throws IllegalArgumentException if preconditions are not met.\n */\npublic static double binomialCoefficientDouble(final int n, final int k) {\n    return Math.floor(Math.exp(binomialCoefficientLog(n, k)) + 0.5);\n}", "code_comment": "/**\n * Returns a <code>double</code> representation of the <a\n * href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\"> Binomial\n * Coefficient</a>, \"<code>n choose k</code>\", the number of\n * <code>k</code>-element subsets that can be selected from an\n * <code>n</code>-element set.\n * <p>\n * <Strong>Preconditions</strong>:\n * <ul>\n * <li> <code>0 <= k <= n </code> (otherwise\n * <code>IllegalArgumentException</code> is thrown)</li>\n * <li> The result is small enough to fit into a <code>double</code>. The\n * largest value of <code>n</code> for which all coefficients are <\n * Double.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE,\n * Double.POSITIVE_INFINITY is returned</li>\n * </ul></p>\n *\n * @param n the size of the set\n * @param k the size of the subsets to be counted\n * @return <code>n choose k</code>\n * @throws IllegalArgumentException if preconditions are not met.\n */\n", "code_no_comment": "public static double binomialCoefficientDouble(final int n, final int k) {\n    return Math.floor(Math.exp(binomialCoefficientLog(n, k)) + 0.5);\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.917406624383368, "fo": -0.25, "r": -0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-812_607c9ec6", "label": 1, "code": "/**\n * Compute the outer product.\n *\n * @param v Vector with which outer product should be computed.\n * @return the matrix outer product between this instance and {@code v}.\n */\npublic RealMatrix outerProduct(RealVector v) {\n    RealMatrix product;\n    if (v instanceof SparseRealVector || this instanceof SparseRealVector) {\n        product = new OpenMapRealMatrix(this.getDimension(), v.getDimension());\n    } else {\n        product = new Array2DRowRealMatrix(this.getDimension(), v.getDimension());\n    }\n    Iterator<Entry> thisIt = sparseIterator();\n    while (thisIt.hasNext()) {\n        final Entry thisE = thisIt.next();\n        Iterator<Entry> otherIt = v.sparseIterator();\n        while (otherIt.hasNext()) {\n            final Entry otherE = otherIt.next();\n            product.setEntry(thisE.getIndex(), otherE.getIndex(), thisE.getValue() * otherE.getValue());\n        }\n    }\n    return product;\n}", "code_comment": "/**\n * Compute the outer product.\n *\n * @param v Vector with which outer product should be computed.\n * @return the matrix outer product between this instance and {@code v}.\n */\n", "code_no_comment": "public RealMatrix outerProduct(RealVector v) {\n    RealMatrix product;\n    if (v instanceof SparseRealVector || this instanceof SparseRealVector) {\n        product = new OpenMapRealMatrix(this.getDimension(), v.getDimension());\n    } else {\n        product = new Array2DRowRealMatrix(this.getDimension(), v.getDimension());\n    }\n    Iterator<Entry> thisIt = sparseIterator();\n    while (thisIt.hasNext()) {\n        final Entry thisE = thisIt.next();\n        Iterator<Entry> otherIt = v.sparseIterator();\n        while (otherIt.hasNext()) {\n            final Entry otherE = otherIt.next();\n            product.setEntry(thisE.getIndex(), otherE.getIndex(), thisE.getValue() * otherE.getValue());\n        }\n    }\n    return product;\n}", "lc": 0.18181818181818182, "pi": 0.1626794258373205, "ma": 0.0, "nbd": 0.0, "ml": 0.16666666666666666, "d": 0.10317460317460313, "mi": -0.19351656095842124, "fo": 0.75, "r": -0.02631578947368421, "e": 0.14083435625248525}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-3757_c1b2f2f8", "label": 3, "code": "/**\n * Mock all endpoints in the route.\n *\n * @throws Exception can be thrown if error occurred\n */\npublic void mockEndpoints() throws Exception {\n    getContext().removeEndpoints(\"*\");\n    getContext().addRegisterEndpointCallback(new InterceptSendToMockEndpointStrategy(null));\n}", "code_comment": "/**\n * Mock all endpoints in the route.\n *\n * @throws Exception can be thrown if error occurred\n */\n", "code_no_comment": "public void mockEndpoints() throws Exception {\n    getContext().removeEndpoints(\"*\");\n    getContext().addRegisterEndpointCallback(new InterceptSendToMockEndpointStrategy(null));\n}", "lc": -0.45454545454545453, "pi": -0.47368421052631593, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.8314305849189569, "fo": -0.16666666666666666, "r": 2.6052631578947367, "e": -0.16279340490885932}
{"project_name": "Closure", "project_version": 144, "label": 2, "code": "/**\n * Gets the function type from the function node and its attached\n * {@link JSDocInfo}.\n * @param name the function's name\n * @param rValue the function node. It must be a {@link Token#FUNCTION}.\n * @param info the {@link JSDocInfo} attached to the function definition\n * @param lvalueNode The node where this function is being\n *     assigned. For example, {@code A.prototype.foo = ...} would be used to\n *     determine that this function is a method of A.prototype. May be\n *     null to indicate that this is not being assigned to a qualified name.\n */\nprivate FunctionType getFunctionType(String name, Node rValue, JSDocInfo info, @Nullable Node lvalueNode) {\n    FunctionType functionType = null;\n    // Handle function aliases.\n    if (rValue != null && rValue.isQualifiedName()) {\n        Var var = scope.getVar(rValue.getQualifiedName());\n        if (var != null && var.getType() instanceof FunctionType) {\n            functionType = (FunctionType) var.getType();\n            if (functionType != null && functionType.isConstructor()) {\n                typeRegistry.declareType(name, functionType.getInstanceType());\n            }\n        }\n        return functionType;\n    }\n    Node owner = null;\n    if (lvalueNode != null) {\n        owner = getPrototypePropertyOwner(lvalueNode);\n    }\n    Node errorRoot = rValue == null ? lvalueNode : rValue;\n    boolean isFnLiteral = rValue != null && rValue.getType() == Token.FUNCTION;\n    Node fnRoot = isFnLiteral ? rValue : null;\n    Node parametersNode = isFnLiteral ? rValue.getFirstChild().getNext() : null;\n    if (functionType == null && info != null && info.hasType()) {\n        JSType type = info.getType().evaluate(scope, typeRegistry);\n        // Known to be not null since we have the FUNCTION token there.\n        type = type.restrictByNotNullOrUndefined();\n        if (type.isFunctionType()) {\n            functionType = (FunctionType) type;\n            functionType.setJSDocInfo(info);\n        }\n    }\n    if (functionType == null) {\n        if (info == null || !FunctionTypeBuilder.isFunctionTypeDeclaration(info)) {\n            // to this function.\n            if (lvalueNode != null && lvalueNode.getType() == Token.GETPROP && lvalueNode.isQualifiedName()) {\n                Var var = scope.getVar(lvalueNode.getFirstChild().getQualifiedName());\n                if (var != null) {\n                    ObjectType ownerType = ObjectType.cast(var.getType());\n                    FunctionType propType = null;\n                    if (ownerType != null) {\n                        String propName = lvalueNode.getLastChild().getString();\n                        propType = findOverriddenFunction(ownerType, propName);\n                    }\n                    if (propType != null) {\n                        functionType = new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setSourceNode(fnRoot).inferFromOverriddenFunction(propType, parametersNode).inferThisType(info, owner).buildAndRegister();\n                    }\n                }\n            }\n        }\n    }\n    if (functionType == null) {\n        functionType = new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setSourceNode(fnRoot).inferTemplateTypeName(info).inferReturnType(info).inferInheritance(info).inferThisType(info, owner).inferParameterTypes(parametersNode, info).buildAndRegister();\n    }\n    // assigning the function type to the function node\n    if (rValue != null) {\n        setDeferredType(rValue, functionType);\n    }\n    // all done\n    return functionType;\n}", "code_comment": "/**\n * Gets the function type from the function node and its attached\n * {@link JSDocInfo}.\n * @param name the function's name\n * @param rValue the function node. It must be a {@link Token#FUNCTION}.\n * @param info the {@link JSDocInfo} attached to the function definition\n * @param lvalueNode The node where this function is being\n *     assigned. For example, {@code A.prototype.foo = ...} would be used to\n *     determine that this function is a method of A.prototype. May be\n *     null to indicate that this is not being assigned to a qualified name.\n */\n", "code_no_comment": "private FunctionType getFunctionType(String name, Node rValue, JSDocInfo info, @Nullable Node lvalueNode) {\n    FunctionType functionType = null;\n        if (rValue != null && rValue.isQualifiedName()) {\n        Var var = scope.getVar(rValue.getQualifiedName());\n        if (var != null && var.getType() instanceof FunctionType) {\n            functionType = (FunctionType) var.getType();\n            if (functionType != null && functionType.isConstructor()) {\n                typeRegistry.declareType(name, functionType.getInstanceType());\n            }\n        }\n        return functionType;\n    }\n    Node owner = null;\n    if (lvalueNode != null) {\n        owner = getPrototypePropertyOwner(lvalueNode);\n    }\n    Node errorRoot = rValue == null ? lvalueNode : rValue;\n    boolean isFnLiteral = rValue != null && rValue.getType() == Token.FUNCTION;\n    Node fnRoot = isFnLiteral ? rValue : null;\n    Node parametersNode = isFnLiteral ? rValue.getFirstChild().getNext() : null;\n    if (functionType == null && info != null && info.hasType()) {\n        JSType type = info.getType().evaluate(scope, typeRegistry);\n                type = type.restrictByNotNullOrUndefined();\n        if (type.isFunctionType()) {\n            functionType = (FunctionType) type;\n            functionType.setJSDocInfo(info);\n        }\n    }\n    if (functionType == null) {\n        if (info == null || !FunctionTypeBuilder.isFunctionTypeDeclaration(info)) {\n                        if (lvalueNode != null && lvalueNode.getType() == Token.GETPROP && lvalueNode.isQualifiedName()) {\n                Var var = scope.getVar(lvalueNode.getFirstChild().getQualifiedName());\n                if (var != null) {\n                    ObjectType ownerType = ObjectType.cast(var.getType());\n                    FunctionType propType = null;\n                    if (ownerType != null) {\n                        String propName = lvalueNode.getLastChild().getString();\n                        propType = findOverriddenFunction(ownerType, propName);\n                    }\n                    if (propType != null) {\n                        functionType = new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setSourceNode(fnRoot).inferFromOverriddenFunction(propType, parametersNode).inferThisType(info, owner).buildAndRegister();\n                    }\n                }\n            }\n        }\n    }\n    if (functionType == null) {\n        functionType = new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setSourceNode(fnRoot).inferTemplateTypeName(info).inferReturnType(info).inferInheritance(info).inferThisType(info, owner).inferParameterTypes(parametersNode, info).buildAndRegister();\n    }\n        if (rValue != null) {\n        setDeferredType(rValue, functionType);\n    }\n        return functionType;\n}", "lc": 1.8181818181818181, "pi": 1.6842105263157894, "ma": 2.8, "nbd": 1.5, "ml": 3.0, "d": 1.4583333333333333, "mi": -1.0293164200140943, "fo": 2.9166666666666665, "r": -0.02631578947368421, "e": 6.049021743515268}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5853_b80f6640", "label": 3, "code": "/**\n *  @param locale\n *             The Locale that was used for this NumberFormat\n *  @param numberFormat\n *             The numberFormat to set.\n */\npublic final void setNumberFormat(final Locale locale, final NumberFormat numberFormat) {\n    if (numberFormat instanceof DecimalFormat) {\n        ((DecimalFormat) numberFormat).setParseBigDecimal(true);\n    }\n    numberFormats.put(locale, numberFormat);\n}", "code_comment": "/**\n *  @param locale\n *             The Locale that was used for this NumberFormat\n *  @param numberFormat\n *             The numberFormat to set.\n */\n", "code_no_comment": "public final void setNumberFormat(final Locale locale, final NumberFormat numberFormat) {\n    if (numberFormat instanceof DecimalFormat) {\n        ((DecimalFormat) numberFormat).setParseBigDecimal(true);\n    }\n    numberFormats.put(locale, numberFormat);\n}", "lc": -0.36363636363636365, "pi": -0.11483253588516758, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": -0.3650793650793651, "mi": 0.55799859055673, "fo": -0.3333333333333333, "r": 2.1052631578947367, "e": -0.16279340490885932}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-757_76b7413d", "label": 1, "code": "/**\n * <p>\n * Adds an element to the end of the array and removes the first\n * element in the array.  Returns the discarded first element.\n * The effect is similar to a push operation in a FIFO queue.\n * </p>\n * <p>\n * Example: If the array contains the elements 1, 2, 3, 4 (in that order)\n * and addElementRolling(5) is invoked, the result is an array containing\n * the entries 2, 3, 4, 5 and the value returned is 1.\n * </p>\n *\n * @param value Value to be added to the array.\n * @return the value which has been discarded or \"pushed\" out of the array\n * by this rolling insert.\n */\n@Override\npublic synchronized double addElementRolling(double value) {\n    double discarded = internalArray[startIndex];\n    if ((startIndex + (numElements + 1)) > internalArray.length) {\n        expand();\n    }\n    // Increment the start index\n    startIndex += 1;\n    // Add the new value\n    internalArray[startIndex + (numElements - 1)] = value;\n    // Check the contraction criterion.\n    if (shouldContract()) {\n        contract();\n    }\n    return discarded;\n}", "code_comment": "/**\n * <p>\n * Adds an element to the end of the array and removes the first\n * element in the array.  Returns the discarded first element.\n * The effect is similar to a push operation in a FIFO queue.\n * </p>\n * <p>\n * Example: If the array contains the elements 1, 2, 3, 4 (in that order)\n * and addElementRolling(5) is invoked, the result is an array containing\n * the entries 2, 3, 4, 5 and the value returned is 1.\n * </p>\n *\n * @param value Value to be added to the array.\n * @return the value which has been discarded or \"pushed\" out of the array\n * by this rolling insert.\n */\n", "code_no_comment": "@Override\npublic synchronized double addElementRolling(double value) {\n    double discarded = internalArray[startIndex];\n    if ((startIndex + (numElements + 1)) > internalArray.length) {\n        expand();\n    }\n        startIndex += 1;\n        internalArray[startIndex + (numElements - 1)] = value;\n        if (shouldContract()) {\n        contract();\n    }\n    return discarded;\n}", "lc": -0.045454545454545456, "pi": -0.25358851674641164, "ma": -0.2, "nbd": -0.5, "ml": 0.08333333333333333, "d": 0.33730158730158727, "mi": 0.07427766032417207, "fo": -0.25, "r": -0.02631578947368421, "e": 0.04808814969773459}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-949_f83bbc1d", "label": 1, "code": "/**\n * {@inheritDoc}\n */\n@Override\nprotected PointValuePair doOptimize() {\n    final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();\n    final double[] point = getStartPoint();\n    final GoalType goal = getGoalType();\n    final int n = point.length;\n    double[] r = computeObjectiveGradient(point);\n    if (goal == GoalType.MINIMIZE) {\n        for (int i = 0; i < n; i++) {\n            r[i] = -r[i];\n        }\n    }\n    // Initial search direction.\n    double[] steepestDescent = preconditioner.precondition(point, r);\n    double[] searchDirection = steepestDescent.clone();\n    double delta = 0;\n    for (int i = 0; i < n; ++i) {\n        delta += r[i] * searchDirection[i];\n    }\n    PointValuePair current = null;\n    int iter = 0;\n    int maxEval = getMaxEvaluations();\n    while (true) {\n        ++iter;\n        final double objective = computeObjectiveValue(point);\n        PointValuePair previous = current;\n        current = new PointValuePair(point, objective);\n        if (previous != null) {\n            if (checker.converged(iter, previous, current)) {\n                // We have found an optimum.\n                return current;\n            }\n        }\n        // Find the optimal step in the search direction.\n        final UnivariateFunction lsf = new LineSearchFunction(point, searchDirection);\n        final double uB = findUpperBound(lsf, 0, initialStep);\n        // XXX Last parameters is set to a value close to zero in order to\n        // work around the divergence problem in the \"testCircleFitting\"\n        // unit test (see MATH-439).\n        final double step = solver.solve(maxEval, lsf, 0, uB, 1e-15);\n        // Subtract used up evaluations.\n        maxEval -= solver.getEvaluations();\n        // Validate new point.\n        for (int i = 0; i < point.length; ++i) {\n            point[i] += step * searchDirection[i];\n        }\n        r = computeObjectiveGradient(point);\n        if (goal == GoalType.MINIMIZE) {\n            for (int i = 0; i < n; ++i) {\n                r[i] = -r[i];\n            }\n        }\n        // Compute beta.\n        final double deltaOld = delta;\n        final double[] newSteepestDescent = preconditioner.precondition(point, r);\n        delta = 0;\n        for (int i = 0; i < n; ++i) {\n            delta += r[i] * newSteepestDescent[i];\n        }\n        final double beta;\n        switch(updateFormula) {\n            case FLETCHER_REEVES:\n                beta = delta / deltaOld;\n                break;\n            case POLAK_RIBIERE:\n                double deltaMid = 0;\n                for (int i = 0; i < r.length; ++i) {\n                    deltaMid += r[i] * steepestDescent[i];\n                }\n                beta = (delta - deltaMid) / deltaOld;\n                break;\n            default:\n                // Should never happen.\n                throw new MathInternalError();\n        }\n        steepestDescent = newSteepestDescent;\n        // Compute conjugate search direction.\n        if (iter % n == 0 || beta < 0) {\n            // Break conjugation: reset search direction.\n            searchDirection = steepestDescent.clone();\n        } else {\n            // Compute new conjugate search direction.\n            for (int i = 0; i < n; ++i) {\n                searchDirection[i] = steepestDescent[i] + beta * searchDirection[i];\n            }\n        }\n    }\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "@Override\nprotected PointValuePair doOptimize() {\n    final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();\n    final double[] point = getStartPoint();\n    final GoalType goal = getGoalType();\n    final int n = point.length;\n    double[] r = computeObjectiveGradient(point);\n    if (goal == GoalType.MINIMIZE) {\n        for (int i = 0; i < n; i++) {\n            r[i] = -r[i];\n        }\n    }\n        double[] steepestDescent = preconditioner.precondition(point, r);\n    double[] searchDirection = steepestDescent.clone();\n    double delta = 0;\n    for (int i = 0; i < n; ++i) {\n        delta += r[i] * searchDirection[i];\n    }\n    PointValuePair current = null;\n    int iter = 0;\n    int maxEval = getMaxEvaluations();\n    while (true) {\n        ++iter;\n        final double objective = computeObjectiveValue(point);\n        PointValuePair previous = current;\n        current = new PointValuePair(point, objective);\n        if (previous != null) {\n            if (checker.converged(iter, previous, current)) {\n                                return current;\n            }\n        }\n                final UnivariateFunction lsf = new LineSearchFunction(point, searchDirection);\n        final double uB = findUpperBound(lsf, 0, initialStep);\n                                final double step = solver.solve(maxEval, lsf, 0, uB, 1e-15);\n                maxEval -= solver.getEvaluations();\n                for (int i = 0; i < point.length; ++i) {\n            point[i] += step * searchDirection[i];\n        }\n        r = computeObjectiveGradient(point);\n        if (goal == GoalType.MINIMIZE) {\n            for (int i = 0; i < n; ++i) {\n                r[i] = -r[i];\n            }\n        }\n                final double deltaOld = delta;\n        final double[] newSteepestDescent = preconditioner.precondition(point, r);\n        delta = 0;\n        for (int i = 0; i < n; ++i) {\n            delta += r[i] * newSteepestDescent[i];\n        }\n        final double beta;\n        switch(updateFormula) {\n            case FLETCHER_REEVES:\n                beta = delta / deltaOld;\n                break;\n            case POLAK_RIBIERE:\n                double deltaMid = 0;\n                for (int i = 0; i < r.length; ++i) {\n                    deltaMid += r[i] * steepestDescent[i];\n                }\n                beta = (delta - deltaMid) / deltaOld;\n                break;\n            default:\n                                throw new MathInternalError();\n        }\n        steepestDescent = newSteepestDescent;\n                if (iter % n == 0 || beta < 0) {\n                        searchDirection = steepestDescent.clone();\n        } else {\n                        for (int i = 0; i < n; ++i) {\n                searchDirection[i] = steepestDescent[i] + beta * searchDirection[i];\n            }\n        }\n    }\n}", "lc": 2.772727272727273, "pi": 0.6889952153110046, "ma": 3.2, "nbd": 1.0, "ml": 1.8333333333333333, "d": 3.845238095238095, "mi": -1.2057787174066241, "fo": 0.75, "r": -0.02631578947368421, "e": 15.565385568483714}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3931_8fbdc68f", "label": 1, "code": "/**\n *  Render a placeholder tag when the component is not visible. The tag is of form:\n *  &lt;componenttag style=\"display:none;\" id=\"markupid\"/&gt;. This method will also call\n *  <code>setOutputMarkupId(true)</code>.\n *\n *  This is useful, for example, in ajax situations where the component starts out invisible and\n *  then becomes visible through an ajax update. With a placeholder tag already in the markup you\n *  do not need to repaint this component's parent, instead you can repaint the component\n *  directly.\n *\n *  When this method is called with parameter <code>false</code> the outputmarkupid flag is not\n *  reverted to false.\n *\n *  @param outputTag\n *  @return this for chaining\n */\npublic final Component setOutputMarkupPlaceholderTag(final boolean outputTag) {\n    if (outputTag != getFlag(FLAG_PLACEHOLDER)) {\n        if (outputTag) {\n            setOutputMarkupId(true);\n            setFlag(FLAG_PLACEHOLDER, true);\n        } else {\n            setFlag(FLAG_PLACEHOLDER, false);\n        // I think it's better to not setOutputMarkupId to false...\n        // user can do it if we want\n        }\n    }\n    return this;\n}", "code_comment": "/**\n *  Render a placeholder tag when the component is not visible. The tag is of form:\n *  &lt;componenttag style=\"display:none;\" id=\"markupid\"/&gt;. This method will also call\n *  <code>setOutputMarkupId(true)</code>.\n *\n *  This is useful, for example, in ajax situations where the component starts out invisible and\n *  then becomes visible through an ajax update. With a placeholder tag already in the markup you\n *  do not need to repaint this component's parent, instead you can repaint the component\n *  directly.\n *\n *  When this method is called with parameter <code>false</code> the outputmarkupid flag is not\n *  reverted to false.\n *\n *  @param outputTag\n *  @return this for chaining\n */\n", "code_no_comment": "public final Component setOutputMarkupPlaceholderTag(final boolean outputTag) {\n    if (outputTag != getFlag(FLAG_PLACEHOLDER)) {\n        if (outputTag) {\n            setOutputMarkupId(true);\n            setFlag(FLAG_PLACEHOLDER, true);\n        } else {\n            setFlag(FLAG_PLACEHOLDER, false);\n                        }\n    }\n    return this;\n}", "lc": -0.13636363636363635, "pi": 0.6124401913875596, "ma": -0.2, "nbd": 0.0, "ml": -0.08333333333333333, "d": -0.3650793650793651, "mi": 0.2659619450317125, "fo": -0.16666666666666666, "r": 0.868421052631579, "e": -0.16279340490885932}
{"project_name": "Closure", "project_version": 155, "label": 2, "code": "/**\n * For each node, update the block stack and reference collection\n * as appropriate.\n */\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() == Token.NAME) {\n        Var v = t.getScope().getVar(n.getString());\n        if (v != null && varFilter.apply(v)) {\n            addReference(t, v, new Reference(n, parent, t, blockStack.peek()));\n        }\n    }\n    if (isBlockBoundary(n, parent)) {\n        blockStack.pop();\n    }\n}", "code_comment": "/**\n * For each node, update the block stack and reference collection\n * as appropriate.\n */\n", "code_no_comment": "public void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() == Token.NAME) {\n        Var v = t.getScope().getVar(n.getString());\n        if (v != null && varFilter.apply(v)) {\n            addReference(t, v, new Reference(n, parent, t, blockStack.peek()));\n        }\n    }\n    if (isBlockBoundary(n, parent)) {\n        blockStack.pop();\n    }\n}", "lc": -0.13636363636363635, "pi": 0.25837320574162664, "ma": 0.0, "nbd": 0.0, "ml": 0.4166666666666667, "d": 0.26388888888888884, "mi": 0.078505990133897, "fo": 0.25, "r": 0.15789473684210528, "e": 0.1319825037603084}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-344_8dead3bb", "label": 1, "code": "@Override\npublic void onStartup(final Set<Class<?>> classes, final ServletContext servletContext) throws ServletException {\n    if (servletContext.getMajorVersion() > 2 && servletContext.getEffectiveMajorVersion() > 2) {\n        servletContext.log(\"Log4jServletContainerInitializer starting up Log4j in Servlet 3.0+ environment.\");\n        final FilterRegistration.Dynamic filter = servletContext.addFilter(\"log4jServletFilter\", new Log4jServletFilter());\n        if (filter == null) {\n            servletContext.log(\"WARNING: In a Servlet 3.0+ application, you should not define a \" + \"log4jServletFilter in web.xml. Log4j 2 normally does this for you automatically. Log4j 2 \" + \"web auto-initialization has been canceled.\");\n            return;\n        }\n        final Log4jWebInitializer initializer = Log4jWebInitializerImpl.getLog4jWebInitializer(servletContext);\n        initializer.initialize();\n        // the application is just now starting to start up\n        initializer.setLoggerContext();\n        servletContext.addListener(new Log4jServletContextListener());\n        filter.addMappingForUrlPatterns(EnumSet.allOf(DispatcherType.class), false, \"/*\");\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void onStartup(final Set<Class<?>> classes, final ServletContext servletContext) throws ServletException {\n    if (servletContext.getMajorVersion() > 2 && servletContext.getEffectiveMajorVersion() > 2) {\n        servletContext.log(\"Log4jServletContainerInitializer starting up Log4j in Servlet 3.0+ environment.\");\n        final FilterRegistration.Dynamic filter = servletContext.addFilter(\"log4jServletFilter\", new Log4jServletFilter());\n        if (filter == null) {\n            servletContext.log(\"WARNING: In a Servlet 3.0+ application, you should not define a \" + \"log4jServletFilter in web.xml. Log4j 2 normally does this for you automatically. Log4j 2 \" + \"web auto-initialization has been canceled.\");\n            return;\n        }\n        final Log4jWebInitializer initializer = Log4jWebInitializerImpl.getLog4jWebInitializer(servletContext);\n        initializer.initialize();\n                initializer.setLoggerContext();\n        servletContext.addListener(new Log4jServletContextListener());\n        filter.addMappingForUrlPatterns(EnumSet.allOf(DispatcherType.class), false, \"/*\");\n    }\n}", "lc": 0.09090909090909091, "pi": 0.3444976076555023, "ma": -0.2, "nbd": 0.0, "ml": 0.08333333333333333, "d": 0.16666666666666669, "mi": -0.15095137420718824, "fo": 0.4166666666666667, "r": -0.02631578947368421, "e": 0.22667888406724174}
{"project_name": "Math", "project_version": 58, "label": 1, "code": "/**\n * Fits a Gaussian function to the observed points.\n *\n * @return the parameters of the Gaussian function that best fits the\n * observed points (in the same order as above).\n */\npublic double[] fit() {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n    return fit(new Gaussian.Parametric(), guess);\n}", "code_comment": "/**\n * Fits a Gaussian function to the observed points.\n *\n * @return the parameters of the Gaussian function that best fits the\n * observed points (in the same order as above).\n */\n", "code_no_comment": "public double[] fit() {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n    return fit(new Gaussian.Parametric(), guess);\n}", "lc": -0.45454545454545453, "pi": -0.47368421052631593, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.8255109231853415, "fo": -0.25, "r": 2.526315789473684, "e": -0.16279340490885932}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-520_ec961a38", "label": 1, "code": "@Override\npublic void insert(NodeBuilder index, String key, boolean unique, Iterable<String> values) throws CommitFailedException {\n    NodeBuilder child = index.child(key);\n    for (String add : values) {\n        NodeBuilder indexEntry = child;\n        Iterator<String> segments = PathUtils.elements(add).iterator();\n        while (segments.hasNext()) {\n            String segment = segments.next();\n            indexEntry = indexEntry.child(segment);\n        }\n        indexEntry.setProperty(\"match\", true);\n    }\n    long matchCount = countMatchingLeaves(child.getNodeState());\n    if (matchCount == 0) {\n        index.removeNode(key);\n    } else if (unique && matchCount > 1) {\n        throw new CommitFailedException(\"Uniqueness constraint violated\");\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void insert(NodeBuilder index, String key, boolean unique, Iterable<String> values) throws CommitFailedException {\n    NodeBuilder child = index.child(key);\n    for (String add : values) {\n        NodeBuilder indexEntry = child;\n        Iterator<String> segments = PathUtils.elements(add).iterator();\n        while (segments.hasNext()) {\n            String segment = segments.next();\n            indexEntry = indexEntry.child(segment);\n        }\n        indexEntry.setProperty(\"match\", true);\n    }\n    long matchCount = countMatchingLeaves(child.getNodeState());\n    if (matchCount == 0) {\n        index.removeNode(key);\n    } else if (unique && matchCount > 1) {\n        throw new CommitFailedException(\"Uniqueness constraint violated\");\n    }\n}", "lc": 0.22727272727272727, "pi": 0.24880382775119597, "ma": 0.4, "nbd": 0.0, "ml": 0.16666666666666666, "d": 0.3531746031746032, "mi": -0.26314305849189545, "fo": 0.3333333333333333, "r": -0.02631578947368421, "e": 0.41610391705998623}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2029_e30023ba", "label": 1, "code": "/**\n * close writer if it's not null\n */\nvoid closeWriter() throws IOException {\n    if (writer != null) {\n        writer.close();\n    }\n}", "code_comment": "/**\n * close writer if it's not null\n */\n", "code_no_comment": "void closeWriter() throws IOException {\n    if (writer != null) {\n        writer.close();\n    }\n}", "lc": -0.4090909090909091, "pi": 0.0, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": -0.3650793650793651, "mi": 0.7736434108527128, "fo": -0.4166666666666667, "r": 2.5789473684210527, "e": -0.16279340490885932}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-7163_5f726d0b", "label": 1, "code": "public void setMessageHeaderOnBreakpoint(String nodeId, String headerName, String value) {\n    backlogDebugger.setMessageHeaderOnBreakpoint(nodeId, headerName, value);\n}", "code_comment": NaN, "code_no_comment": "public void setMessageHeaderOnBreakpoint(String nodeId, String headerName, String value) {\n    backlogDebugger.setMessageHeaderOnBreakpoint(nodeId, headerName, value);\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.9422128259337562, "fo": -0.4166666666666667, "r": -0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-8125_36e7b668", "label": 3, "code": "public Object getInjectionPropertyValue(Class<?> type, String propertyName, String propertyDefaultValue, String injectionPointName, Object bean, String beanName) {\n    try {\n        String key;\n        String prefix = getCamelContext().getPropertyPrefixToken();\n        String suffix = getCamelContext().getPropertySuffixToken();\n        if (prefix == null && suffix == null) {\n            // if no custom prefix/suffix then use defaults\n            prefix = PropertiesComponent.DEFAULT_PREFIX_TOKEN;\n            suffix = PropertiesComponent.DEFAULT_SUFFIX_TOKEN;\n        }\n        if (!propertyName.startsWith(prefix)) {\n            // must enclose the property name with prefix/suffix to have it resolved\n            key = prefix + propertyName + suffix;\n        } else {\n            // key has already prefix/suffix so use it as-is as it may be a compound key\n            key = propertyName;\n        }\n        String value = getCamelContext().resolvePropertyPlaceholders(key);\n        if (value != null) {\n            return getCamelContext().getTypeConverter().mandatoryConvertTo(type, value);\n        } else {\n            return null;\n        }\n    } catch (Exception e) {\n        if (ObjectHelper.isNotEmpty(propertyDefaultValue)) {\n            try {\n                return getCamelContext().getTypeConverter().mandatoryConvertTo(type, propertyDefaultValue);\n            } catch (Exception e2) {\n                throw ObjectHelper.wrapRuntimeCamelException(e2);\n            }\n        }\n        throw ObjectHelper.wrapRuntimeCamelException(e);\n    }\n}", "code_comment": NaN, "code_no_comment": "public Object getInjectionPropertyValue(Class<?> type, String propertyName, String propertyDefaultValue, String injectionPointName, Object bean, String beanName) {\n    try {\n        String key;\n        String prefix = getCamelContext().getPropertyPrefixToken();\n        String suffix = getCamelContext().getPropertySuffixToken();\n        if (prefix == null && suffix == null) {\n                        prefix = PropertiesComponent.DEFAULT_PREFIX_TOKEN;\n            suffix = PropertiesComponent.DEFAULT_SUFFIX_TOKEN;\n        }\n        if (!propertyName.startsWith(prefix)) {\n                        key = prefix + propertyName + suffix;\n        } else {\n                        key = propertyName;\n        }\n        String value = getCamelContext().resolvePropertyPlaceholders(key);\n        if (value != null) {\n            return getCamelContext().getTypeConverter().mandatoryConvertTo(type, value);\n        } else {\n            return null;\n        }\n    } catch (Exception e) {\n        if (ObjectHelper.isNotEmpty(propertyDefaultValue)) {\n            try {\n                return getCamelContext().getTypeConverter().mandatoryConvertTo(type, propertyDefaultValue);\n            } catch (Exception e2) {\n                throw ObjectHelper.wrapRuntimeCamelException(e2);\n            }\n        }\n        throw ObjectHelper.wrapRuntimeCamelException(e);\n    }\n}", "lc": 0.7727272727272727, "pi": 0.3492822966507177, "ma": 1.0, "nbd": 0.5, "ml": 0.5, "d": 1.0297619047619049, "mi": -0.5481324876673711, "fo": 0.8333333333333334, "r": -0.02631578947368421, "e": 1.334257706471188}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2691_d2da7499", "label": 0, "code": "/**\n * Retrieves the {# CLUSTER_ID_PROP}\n *\n * @param store the NodeStore instance\n * @return the repository id\n */\npublic static String getId(NodeStore store) {\n    return store.getRoot().getChildNode(CLUSTER_CONFIG_NODE).getProperty(CLUSTER_ID_PROP).getValue(Type.STRING);\n}", "code_comment": "/**\n * Retrieves the {# CLUSTER_ID_PROP}\n *\n * @param store the NodeStore instance\n * @return the repository id\n */\n", "code_no_comment": "public static String getId(NodeStore store) {\n    return store.getRoot().getChildNode(CLUSTER_CONFIG_NODE).getProperty(CLUSTER_ID_PROP).getValue(Type.STRING);\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.8909090909090904, "fo": -0.16666666666666666, "r": 2.5789473684210527, "e": -0.16279340490885932}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4338_9decad35", "label": 3, "code": "/**\n *  @see org.apache.wicket.request.IRequestParameters#getParameterNames()\n */\npublic Set<String> getParameterNames() {\n    Set<String> result = new HashSet<String>();\n    for (QueryParameter parameter : url.getQueryParameters()) {\n        result.add(parameter.getName());\n    }\n    return Collections.unmodifiableSet(result);\n}", "code_comment": "/**\n *  @see org.apache.wicket.request.IRequestParameters#getParameterNames()\n */\n", "code_no_comment": "public Set<String> getParameterNames() {\n    Set<String> result = new HashSet<String>();\n    for (QueryParameter parameter : url.getQueryParameters()) {\n        result.add(parameter.getName());\n    }\n    return Collections.unmodifiableSet(result);\n}", "lc": -0.3181818181818182, "pi": -0.20574162679425848, "ma": -0.4, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.4300211416490484, "fo": -0.16666666666666666, "r": 0.47368421052631576, "e": -0.16279340490885932}
{"project_name": "Closure", "project_version": 149, "label": 2, "code": "@Override\nprotected CompilerOptions createOptions() {\n    CompilerOptions options = new CompilerOptions();\n    options.setCodingConvention(new ClosureCodingConvention());\n    CompilationLevel level = flags.compilation_level;\n    level.setOptionsForCompilationLevel(options);\n    if (flags.debug) {\n        level.setDebugOptionsForCompilationLevel(options);\n    }\n    WarningLevel wLevel = flags.warning_level;\n    wLevel.setOptionsForWarningLevel(options);\n    for (FormattingOption formattingOption : flags.formatting) {\n        formattingOption.applyToOptions(options);\n    }\n    options.closurePass = flags.process_closure_primitives;\n    initOptionsFromFlags(options);\n    return options;\n}", "code_comment": NaN, "code_no_comment": "@Override\nprotected CompilerOptions createOptions() {\n    CompilerOptions options = new CompilerOptions();\n    options.setCodingConvention(new ClosureCodingConvention());\n    CompilationLevel level = flags.compilation_level;\n    level.setOptionsForCompilationLevel(options);\n    if (flags.debug) {\n        level.setDebugOptionsForCompilationLevel(options);\n    }\n    WarningLevel wLevel = flags.warning_level;\n    wLevel.setOptionsForWarningLevel(options);\n    for (FormattingOption formattingOption : flags.formatting) {\n        formattingOption.applyToOptions(options);\n    }\n    options.closurePass = flags.process_closure_primitives;\n    initOptionsFromFlags(options);\n    return options;\n}", "lc": 0.18181818181818182, "pi": -0.4258373205741628, "ma": -0.2, "nbd": -0.5, "ml": -0.25, "d": -0.3650793650793651, "mi": -0.1529245947850598, "fo": 0.0, "r": -0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "Math", "project_version": 17, "label": 1, "code": "/**\n * Multiply this by a single digit x.\n * @param x multiplicand\n * @return product of this and x\n */\npublic Dfp multiply(final int x) {\n    return multiplyFast(x);\n}", "code_comment": "/**\n * Multiply this by a single digit x.\n * @param x multiplicand\n * @return product of this and x\n */\n", "code_no_comment": "public Dfp multiply(final int x) {\n    return multiplyFast(x);\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.083157152924595, "fo": -0.4166666666666667, "r": 2.6052631578947367, "e": -0.16279340490885932}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-373_bfe4623c", "label": 1, "code": "/**\n * The weighted sum of the entries in the specified portion of\n * the input array, or <code>Double.NaN</code> if the designated subarray\n * is empty.\n * <p>\n * Throws <code>IllegalArgumentException</code> if any of the following are true:\n * <ul><li>the values array is null</li>\n *     <li>the weights array is null</li>\n *     <li>the weights array does not have the same length as the values array</li>\n *     <li>the weights array contains one or more infinite values</li>\n *     <li>the weights array contains one or more NaN values</li>\n *     <li>the weights array contains negative values</li>\n *     <li>the start and length arguments do not determine a valid array</li>\n * </ul></p>\n * <p>\n * Uses the formula, <pre>\n *    weighted sum = &Sigma;(values[i] * weights[i])\n * </pre></p>\n *\n * @param values the input array\n * @param weights the weights array\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return the sum of the values or Double.NaN if length = 0\n * @throws IllegalArgumentException if the parameters are not valid\n * @since 2.1\n */\npublic double evaluate(final double[] values, final double[] weights, final int begin, final int length) {\n    double sum = Double.NaN;\n    if (test(values, weights, begin, length)) {\n        sum = 0.0;\n        for (int i = begin; i < begin + length; i++) {\n            sum += values[i] * weights[i];\n        }\n    }\n    return sum;\n}", "code_comment": "/**\n * The weighted sum of the entries in the specified portion of\n * the input array, or <code>Double.NaN</code> if the designated subarray\n * is empty.\n * <p>\n * Throws <code>IllegalArgumentException</code> if any of the following are true:\n * <ul><li>the values array is null</li>\n *     <li>the weights array is null</li>\n *     <li>the weights array does not have the same length as the values array</li>\n *     <li>the weights array contains one or more infinite values</li>\n *     <li>the weights array contains one or more NaN values</li>\n *     <li>the weights array contains negative values</li>\n *     <li>the start and length arguments do not determine a valid array</li>\n * </ul></p>\n * <p>\n * Uses the formula, <pre>\n *    weighted sum = &Sigma;(values[i] * weights[i])\n * </pre></p>\n *\n * @param values the input array\n * @param weights the weights array\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return the sum of the values or Double.NaN if length = 0\n * @throws IllegalArgumentException if the parameters are not valid\n * @since 2.1\n */\n", "code_no_comment": "public double evaluate(final double[] values, final double[] weights, final int begin, final int length) {\n    double sum = Double.NaN;\n    if (test(values, weights, begin, length)) {\n        sum = 0.0;\n        for (int i = begin; i < begin + length; i++) {\n            sum += values[i] * weights[i];\n        }\n    }\n    return sum;\n}", "lc": -0.18181818181818182, "pi": 0.29186602870813394, "ma": -0.2, "nbd": 0.0, "ml": 0.25, "d": 1.0238095238095237, "mi": 0.17209302325581402, "fo": -0.4166666666666667, "r": -0.02631578947368421, "e": 0.32167032612391433}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-2713_63d9800e", "label": 1, "code": "@Override\npublic void update(S state) throws IOException {\n    if (state == null) {\n        throw new RuntimeException(\"Cannot set state to null.\");\n    }\n    this.state = state;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void update(S state) throws IOException {\n    if (state == null) {\n        throw new RuntimeException(\"Cannot set state to null.\");\n    }\n    this.state = state;\n}", "lc": -0.3181818181818182, "pi": -0.0909090909090911, "ma": -0.2, "nbd": -0.5, "ml": -0.25, "d": -0.10119047619047619, "mi": 0.5007751937984495, "fo": -0.5, "r": 0.868421052631579, "e": -0.13301983022423539}
{"project_name": "Closure", "project_version": 147, "label": 2, "code": "/**\n * Since this pass reports errors only when a global {@code this} keyword\n * is encountered, there is no reason to traverse non global contexts.\n */\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() == Token.FUNCTION) {\n        // Don't traverse functions that are constructors or have the @this\n        // or @override annotation.\n        JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.isInterface() || jsDoc.hasThisType() || jsDoc.isOverride())) {\n            return false;\n        }\n        // Don't traverse functions unless they would normally\n        // be able to have a @this annotation associated with them. e.g.,\n        // var a = function() { }; // or\n        // function a() {} // or\n        // a.x = function() {}; // or\n        // var a = {x: function() {}};\n        int pType = parent.getType();\n        if (!(pType == Token.BLOCK || pType == Token.SCRIPT || pType == Token.NAME || pType == Token.ASSIGN)) {\n            return false;\n        }\n    }\n    if (parent != null && parent.getType() == Token.ASSIGN) {\n        Node lhs = parent.getFirstChild();\n        Node rhs = lhs.getNext();\n        if (n == lhs) {\n            // assignLhsChild should not be overridden.\n            if (assignLhsChild == null) {\n                assignLhsChild = lhs;\n            }\n        } else {\n            // property or subproperty.\n            if (NodeUtil.isGet(lhs)) {\n                if (lhs.getType() == Token.GETPROP && lhs.getLastChild().getString().equals(\"prototype\")) {\n                    return false;\n                }\n                Node llhs = lhs.getFirstChild();\n                if (llhs.getType() == Token.GETPROP && llhs.getLastChild().getString().equals(\"prototype\")) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}", "code_comment": "/**\n * Since this pass reports errors only when a global {@code this} keyword\n * is encountered, there is no reason to traverse non global contexts.\n */\n", "code_no_comment": "public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() == Token.FUNCTION) {\n                        JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.isInterface() || jsDoc.hasThisType() || jsDoc.isOverride())) {\n            return false;\n        }\n                                                        int pType = parent.getType();\n        if (!(pType == Token.BLOCK || pType == Token.SCRIPT || pType == Token.NAME || pType == Token.ASSIGN)) {\n            return false;\n        }\n    }\n    if (parent != null && parent.getType() == Token.ASSIGN) {\n        Node lhs = parent.getFirstChild();\n        Node rhs = lhs.getNext();\n        if (n == lhs) {\n                        if (assignLhsChild == null) {\n                assignLhsChild = lhs;\n            }\n        } else {\n                        if (NodeUtil.isGet(lhs)) {\n                if (lhs.getType() == Token.GETPROP && lhs.getLastChild().getString().equals(\"prototype\")) {\n                    return false;\n                }\n                Node llhs = lhs.getFirstChild();\n                if (llhs.getType() == Token.GETPROP && llhs.getLastChild().getString().equals(\"prototype\")) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}", "lc": 0.8181818181818182, "pi": 1.0526315789473686, "ma": 1.2, "nbd": 1.0, "ml": 2.5833333333333335, "d": 1.0595238095238095, "mi": -0.6180408738548271, "fo": 1.1666666666666667, "r": -0.02631578947368421, "e": 1.9709456383303652}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-359_1df1db27", "label": 1, "code": "@Override\npublic void onStartup(final Set<Class<?>> classes, final ServletContext servletContext) throws ServletException {\n    servletContext.log(\"Log4jServletContainerInitializer starting up Log4j in Servlet 3.0+ environment.\");\n    final Log4jWebInitializer initializer = Log4jWebInitializerImpl.getLog4jWebInitializer(servletContext);\n    initializer.initialize();\n    // the application is just now starting to start up\n    initializer.setLoggerContext();\n    servletContext.addListener(new Log4jServletContextListener());\n    final FilterRegistration.Dynamic filter = servletContext.addFilter(\"log4jServletFilter\", new Log4jServletFilter());\n    filter.addMappingForUrlPatterns(EnumSet.allOf(DispatcherType.class), false, \"/*\");\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void onStartup(final Set<Class<?>> classes, final ServletContext servletContext) throws ServletException {\n    servletContext.log(\"Log4jServletContainerInitializer starting up Log4j in Servlet 3.0+ environment.\");\n    final Log4jWebInitializer initializer = Log4jWebInitializerImpl.getLog4jWebInitializer(servletContext);\n    initializer.initialize();\n        initializer.setLoggerContext();\n    servletContext.addListener(new Log4jServletContextListener());\n    final FilterRegistration.Dynamic filter = servletContext.addFilter(\"log4jServletFilter\", new Log4jServletFilter());\n    filter.addMappingForUrlPatterns(EnumSet.allOf(DispatcherType.class), false, \"/*\");\n}", "lc": -0.18181818181818182, "pi": -0.5550239234449762, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.14305849189570125, "fo": 0.16666666666666666, "r": 0.0, "e": -0.16279340490885932}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-1619_b154d12f", "label": 1, "code": "/**\n *  Create a new increment link. May be subclassed to make use of specialized links, e.g. Ajaxian\n *  links.\n *\n *  @param id\n *             the link id\n *  @param pageable\n *             the pageable to control\n *  @param increment\n *             the increment\n *  @return the increment link\n */\nprotected Link<?> newPagingNavigationIncrementLink(String id, IPageable pageable, int increment) {\n    return new PagingNavigationIncrementLink<Void>(id, pageable, increment) {\n\n        private static final long serialVersionUID = 1L;\n\n        @Override\n        public boolean isEnabled() {\n            return PagingNavigator.this.isEnabled() && PagingNavigator.this.isEnableAllowed();\n        }\n    };\n}", "code_comment": "/**\n *  Create a new increment link. May be subclassed to make use of specialized links, e.g. Ajaxian\n *  links.\n *\n *  @param id\n *             the link id\n *  @param pageable\n *             the pageable to control\n *  @param increment\n *             the increment\n *  @return the increment link\n */\n", "code_no_comment": "protected Link<?> newPagingNavigationIncrementLink(String id, IPageable pageable, int increment) {\n    return new PagingNavigationIncrementLink<Void>(id, pageable, increment) {\n\n        private static final long serialVersionUID = 1L;\n\n        @Override\n        public boolean isEnabled() {\n            return PagingNavigator.this.isEnabled() && PagingNavigator.this.isEnableAllowed();\n        }\n    };\n}", "lc": -0.22727272727272727, "pi": 0.39712918660287067, "ma": -0.6, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.10515873015873016, "mi": 0.29894291754756874, "fo": -0.3333333333333333, "r": 1.9210526315789473, "e": -0.104758447007025}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-7456_02da984a", "label": 3, "code": "public void setPropertySuffix(String propertySuffix) {\n    this.propertySuffix = propertySuffix;\n}", "code_comment": NaN, "code_no_comment": "public void setPropertySuffix(String propertySuffix) {\n    this.propertySuffix = propertySuffix;\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.0606060606060603, "fo": -0.5, "r": 1.3421052631578947, "e": -0.16279340490885932}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5114_518c933b", "label": 1, "code": "/**\n *  Stringizes this url\n *\n *  @param mode\n *             {@link StringMode} that determins how to stringize the url\n *  @param charset\n *             charset\n *  @return sringized version of this url\n */\npublic String toString(StringMode mode, Charset charset) {\n    StringBuilder result = new StringBuilder();\n    final String path = getPath(charset);\n    if (StringMode.FULL == mode) {\n        if (Strings.isEmpty(host)) {\n            throw new IllegalStateException(\"Cannot render this url in \" + StringMode.FULL.name() + \" mode because it does not have a host set.\");\n        }\n        if (Strings.isEmpty(protocol) == false) {\n            result.append(protocol);\n            result.append(\"://\");\n        } else if (Strings.isEmpty(protocol) && Strings.isEmpty(host) == false) {\n            result.append(\"//\");\n        }\n        result.append(host);\n        if (port != null && port.equals(getDefaultPortForProtocol(protocol)) == false) {\n            result.append(':');\n            result.append(port);\n        }\n        if (path.contains(\"..\")) {\n            throw new IllegalStateException(\"Cannot render this url in \" + StringMode.FULL.name() + \" mode because it has a `..` segment: \" + toString());\n        }\n        if (!path.startsWith(\"/\")) {\n            result.append('/');\n        }\n    }\n    result.append(path);\n    result.append(getQueryString(charset));\n    return result.toString();\n}", "code_comment": "/**\n *  Stringizes this url\n *\n *  @param mode\n *             {@link StringMode} that determins how to stringize the url\n *  @param charset\n *             charset\n *  @return sringized version of this url\n */\n", "code_no_comment": "public String toString(StringMode mode, Charset charset) {\n    StringBuilder result = new StringBuilder();\n    final String path = getPath(charset);\n    if (StringMode.FULL == mode) {\n        if (Strings.isEmpty(host)) {\n            throw new IllegalStateException(\"Cannot render this url in \" + StringMode.FULL.name() + \" mode because it does not have a host set.\");\n        }\n        if (Strings.isEmpty(protocol) == false) {\n            result.append(protocol);\n            result.append(\"://\");\n        } else if (Strings.isEmpty(protocol) && Strings.isEmpty(host) == false) {\n            result.append(\"//\");\n        }\n        result.append(host);\n        if (port != null && port.equals(getDefaultPortForProtocol(protocol)) == false) {\n            result.append(':');\n            result.append(port);\n        }\n        if (path.contains(\"..\")) {\n            throw new IllegalStateException(\"Cannot render this url in \" + StringMode.FULL.name() + \" mode because it has a `..` segment: \" + toString());\n        }\n        if (!path.startsWith(\"/\")) {\n            result.append('/');\n        }\n    }\n    result.append(path);\n    result.append(getQueryString(charset));\n    return result.toString();\n}", "lc": 0.6818181818181818, "pi": 0.26315789473684204, "ma": 1.2, "nbd": 0.5, "ml": 1.1666666666666667, "d": 1.1150793650793651, "mi": -0.5444679351656094, "fo": 1.4166666666666667, "r": -0.02631578947368421, "e": 1.6607112601787657}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2642_36fe017c", "label": 0, "code": "/**\n * Creates a new commit. The caller must acknowledge the commit either with\n * {@link #done(Commit, boolean, CommitInfo)} or {@link #canceled(Commit)},\n * depending on the result of the commit.\n *\n * @param base the base revision for the commit or <code>null</code> if the\n *             commit should use the current head revision as base.\n * @param branch the branch instance if this is a branch commit. The life\n *               time of this branch commit is controlled by the\n *               reachability of this parameter. Once {@code branch} is\n *               weakly reachable, the document store implementation is\n *               free to remove the commits associated with the branch.\n * @return a new commit.\n */\n@Nonnull\nCommit newCommit(@Nullable Revision base, @Nullable DocumentNodeStoreBranch branch) {\n    if (base == null) {\n        base = headRevision;\n    }\n    backgroundOperationLock.readLock().lock();\n    boolean success = false;\n    Commit c;\n    try {\n        c = new Commit(this, commitQueue.createRevision(), base, branch);\n        success = true;\n    } finally {\n        if (!success) {\n            backgroundOperationLock.readLock().unlock();\n        }\n    }\n    return c;\n}", "code_comment": "/**\n * Creates a new commit. The caller must acknowledge the commit either with\n * {@link #done(Commit, boolean, CommitInfo)} or {@link #canceled(Commit)},\n * depending on the result of the commit.\n *\n * @param base the base revision for the commit or <code>null</code> if the\n *             commit should use the current head revision as base.\n * @param branch the branch instance if this is a branch commit. The life\n *               time of this branch commit is controlled by the\n *               reachability of this parameter. Once {@code branch} is\n *               weakly reachable, the document store implementation is\n *               free to remove the commits associated with the branch.\n * @return a new commit.\n */\n", "code_no_comment": "@Nonnull\nCommit newCommit(@Nullable Revision base, @Nullable DocumentNodeStoreBranch branch) {\n    if (base == null) {\n        base = headRevision;\n    }\n    backgroundOperationLock.readLock().lock();\n    boolean success = false;\n    Commit c;\n    try {\n        c = new Commit(this, commitQueue.createRevision(), base, branch);\n        success = true;\n    } finally {\n        if (!success) {\n            backgroundOperationLock.readLock().unlock();\n        }\n    }\n    return c;\n}", "lc": 0.18181818181818182, "pi": 0.07177033492822962, "ma": -0.2, "nbd": 0.0, "ml": -0.08333333333333333, "d": -0.04365079365079365, "mi": -0.12558139534883714, "fo": -0.08333333333333333, "r": -0.02631578947368421, "e": -0.02589858404937674}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1877_716e1237", "label": 0, "code": "private static void preAsyncRunNodeStatus(NodeBuilder builder, String name) {\n    String now = now();\n    builder.getChildNode(INDEX_DEFINITIONS_NAME).setProperty(name + \"-status\", STATUS_RUNNING).setProperty(name + \"-start\", now, Type.DATE).removeProperty(name + \"-done\");\n}", "code_comment": NaN, "code_no_comment": "private static void preAsyncRunNodeStatus(NodeBuilder builder, String name) {\n    String now = now();\n    builder.getChildNode(INDEX_DEFINITIONS_NAME).setProperty(name + \"-status\", STATUS_RUNNING).setProperty(name + \"-start\", now, Type.DATE).removeProperty(name + \"-done\");\n}", "lc": -0.45454545454545453, "pi": -0.47368421052631593, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.07341269841269843, "mi": 0.6324171952078927, "fo": -0.08333333333333333, "r": -0.02631578947368421, "e": -0.07927248837329921}
{"project_name": "maven", "project_version": "remotes/origin/bugs-dot-jar_MNG-4933_469d0096", "label": 1, "code": "public void alignToBaseDirectory(Model model, File basedir) {\n    Build build = model.getBuild();\n    if (build != null) {\n        build.setDirectory(alignToBaseDirectory(build.getDirectory(), basedir));\n        build.setSourceDirectory(alignToBaseDirectory(build.getSourceDirectory(), basedir));\n        build.setTestSourceDirectory(alignToBaseDirectory(build.getTestSourceDirectory(), basedir));\n        for (Resource resource : build.getResources()) {\n            resource.setDirectory(alignToBaseDirectory(resource.getDirectory(), basedir));\n        }\n        for (Resource resource : build.getTestResources()) {\n            resource.setDirectory(alignToBaseDirectory(resource.getDirectory(), basedir));\n        }\n        if (build.getFilters() != null) {\n            List<String> filters = new ArrayList<String>();\n            for (String filter : build.getFilters()) {\n                filters.add(alignToBaseDirectory(filter, basedir));\n            }\n            build.setFilters(filters);\n        }\n        build.setOutputDirectory(alignToBaseDirectory(build.getOutputDirectory(), basedir));\n        build.setTestOutputDirectory(alignToBaseDirectory(build.getTestOutputDirectory(), basedir));\n    }\n    Reporting reporting = model.getReporting();\n    if (reporting != null) {\n        reporting.setOutputDirectory(alignToBaseDirectory(reporting.getOutputDirectory(), basedir));\n    }\n}", "code_comment": NaN, "code_no_comment": "public void alignToBaseDirectory(Model model, File basedir) {\n    Build build = model.getBuild();\n    if (build != null) {\n        build.setDirectory(alignToBaseDirectory(build.getDirectory(), basedir));\n        build.setSourceDirectory(alignToBaseDirectory(build.getSourceDirectory(), basedir));\n        build.setTestSourceDirectory(alignToBaseDirectory(build.getTestSourceDirectory(), basedir));\n        for (Resource resource : build.getResources()) {\n            resource.setDirectory(alignToBaseDirectory(resource.getDirectory(), basedir));\n        }\n        for (Resource resource : build.getTestResources()) {\n            resource.setDirectory(alignToBaseDirectory(resource.getDirectory(), basedir));\n        }\n        if (build.getFilters() != null) {\n            List<String> filters = new ArrayList<String>();\n            for (String filter : build.getFilters()) {\n                filters.add(alignToBaseDirectory(filter, basedir));\n            }\n            build.setFilters(filters);\n        }\n        build.setOutputDirectory(alignToBaseDirectory(build.getOutputDirectory(), basedir));\n        build.setTestOutputDirectory(alignToBaseDirectory(build.getTestOutputDirectory(), basedir));\n    }\n    Reporting reporting = model.getReporting();\n    if (reporting != null) {\n        reporting.setOutputDirectory(alignToBaseDirectory(reporting.getOutputDirectory(), basedir));\n    }\n}", "lc": 0.5909090909090909, "pi": 0.36842105263157876, "ma": 0.6, "nbd": 0.5, "ml": 0.08333333333333333, "d": 0.16865079365079363, "mi": -0.48978153629316407, "fo": 2.25, "r": -0.02631578947368421, "e": 0.4822438523999699}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-193_8ad5a888", "label": 3, "code": "public static String toPrintableString(byte[] ba, int offset, int len, int maxLen) {\n    StringBuilder sb = new StringBuilder();\n    int plen = Math.min(len, maxLen);\n    for (int i = 0; i < plen; i++) {\n        int c = 0xff & ba[offset + i];\n        if (c >= 32 && c <= 126)\n            sb.append((char) c);\n        else\n            sb.append(\"%\" + String.format(\"%02x;\", c));\n    }\n    if (len > maxLen) {\n        sb.append(\"... TRUNCATED\");\n    }\n    return sb.toString();\n}", "code_comment": NaN, "code_no_comment": "public static String toPrintableString(byte[] ba, int offset, int len, int maxLen) {\n    StringBuilder sb = new StringBuilder();\n    int plen = Math.min(len, maxLen);\n    for (int i = 0; i < plen; i++) {\n        int c = 0xff & ba[offset + i];\n        if (c >= 32 && c <= 126)\n            sb.append((char) c);\n        else\n            sb.append(\"%\" + String.format(\"%02x;\", c));\n    }\n    if (len > maxLen) {\n        sb.append(\"... TRUNCATED\");\n    }\n    return sb.toString();\n}", "lc": 0.045454545454545456, "pi": 0.2535885167464114, "ma": 0.0, "nbd": -0.5, "ml": 0.3333333333333333, "d": 1.1567460317460319, "mi": -0.1199436222692035, "fo": 0.0, "r": -0.02631578947368421, "e": 0.8891708880090822}
{"project_name": "Lang", "project_version": 39, "label": 1, "code": "/**\n * <p>\n * Replaces all occurrences of Strings within another String.\n * </p>\n *\n * <p>\n * A <code>null</code> reference passed to this method is a no-op, or if\n * any \"search string\" or \"string to replace\" is null, that replace will be\n * ignored.\n * </p>\n *\n * <pre>\n *  StringUtils.replaceEach(null, *, *, *) = null\n *  StringUtils.replaceEach(\"\", *, *, *) = \"\"\n *  StringUtils.replaceEach(\"aba\", null, null, *) = \"aba\"\n *  StringUtils.replaceEach(\"aba\", new String[0], null, *) = \"aba\"\n *  StringUtils.replaceEach(\"aba\", null, new String[0], *) = \"aba\"\n *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null, *) = \"aba\"\n *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"}, *) = \"b\"\n *  StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"}, *) = \"aba\"\n *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}, *) = \"wcte\"\n *  (example of how it repeats)\n *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, false) = \"dcte\"\n *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, true) = \"tcte\"\n *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, *) = IllegalArgumentException\n * </pre>\n *\n * @param text\n *            text to search and replace in, no-op if null\n * @param searchList\n *            the Strings to search for, no-op if null\n * @param replacementList\n *            the Strings to replace them with, no-op if null\n * @param repeat if true, then replace repeatedly\n *       until there are no more possible replacements or timeToLive < 0\n * @param timeToLive\n *            if less than 0 then there is a circular reference and endless\n *            loop\n * @return the text with any replacements processed, <code>null</code> if\n *         null String input\n * @throws IllegalArgumentException\n *             if the search is repeating and there is an endless loop due\n *             to outputs of one being inputs to another\n * @throws IndexOutOfBoundsException\n *             if the lengths of the arrays are not the same (null is ok,\n *             and/or size 0)\n * @since 2.4\n */\nprivate static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {\n    if (text == null || text.length() == 0 || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {\n        return text;\n    }\n    // if recursing, this shouldnt be less than 0\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n    // make sure lengths are ok, these need to be equal\n    if (searchLength != replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + searchLength + \" vs \" + replacementLength);\n    }\n    // keep track of which still have matches\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n    // index on index that the match was found\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n    // NOTE: logic duplicated below START\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n        // see if we need to keep searching for this\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n    // no search strings found, we are done\n    if (textIndex == -1) {\n        return text;\n    }\n    int start = 0;\n    // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit\n    int increase = 0;\n    // count the replacement text elements that are larger than their corresponding text being replaced\n    for (int i = 0; i < searchList.length; i++) {\n        int greater = replacementList[i].length() - searchList[i].length();\n        if (greater > 0) {\n            // assume 3 matches\n            increase += 3 * greater;\n        }\n    }\n    // have upper-bound at 20% increase, then let Java take over\n    increase = Math.min(increase, text.length() / 5);\n    StringBuilder buf = new StringBuilder(text.length() + increase);\n    while (textIndex != -1) {\n        for (int i = start; i < textIndex; i++) {\n            buf.append(text.charAt(i));\n        }\n        buf.append(replacementList[replaceIndex]);\n        start = textIndex + searchList[replaceIndex].length();\n        textIndex = -1;\n        replaceIndex = -1;\n        tempIndex = -1;\n        // NOTE: logic mostly duplicated above START\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i], start);\n            // see if we need to keep searching for this\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n    // NOTE: logic duplicated above END\n    }\n    int textLength = text.length();\n    for (int i = start; i < textLength; i++) {\n        buf.append(text.charAt(i));\n    }\n    String result = buf.toString();\n    if (!repeat) {\n        return result;\n    }\n    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n}", "code_comment": "/**\n * <p>\n * Replaces all occurrences of Strings within another String.\n * </p>\n *\n * <p>\n * A <code>null</code> reference passed to this method is a no-op, or if\n * any \"search string\" or \"string to replace\" is null, that replace will be\n * ignored.\n * </p>\n *\n * <pre>\n *  StringUtils.replaceEach(null, *, *, *) = null\n *  StringUtils.replaceEach(\"\", *, *, *) = \"\"\n *  StringUtils.replaceEach(\"aba\", null, null, *) = \"aba\"\n *  StringUtils.replaceEach(\"aba\", new String[0], null, *) = \"aba\"\n *  StringUtils.replaceEach(\"aba\", null, new String[0], *) = \"aba\"\n *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null, *) = \"aba\"\n *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"}, *) = \"b\"\n *  StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"}, *) = \"aba\"\n *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}, *) = \"wcte\"\n *  (example of how it repeats)\n *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, false) = \"dcte\"\n *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, true) = \"tcte\"\n *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, *) = IllegalArgumentException\n * </pre>\n *\n * @param text\n *            text to search and replace in, no-op if null\n * @param searchList\n *            the Strings to search for, no-op if null\n * @param replacementList\n *            the Strings to replace them with, no-op if null\n * @param repeat if true, then replace repeatedly\n *       until there are no more possible replacements or timeToLive < 0\n * @param timeToLive\n *            if less than 0 then there is a circular reference and endless\n *            loop\n * @return the text with any replacements processed, <code>null</code> if\n *         null String input\n * @throws IllegalArgumentException\n *             if the search is repeating and there is an endless loop due\n *             to outputs of one being inputs to another\n * @throws IndexOutOfBoundsException\n *             if the lengths of the arrays are not the same (null is ok,\n *             and/or size 0)\n * @since 2.4\n */\n", "code_no_comment": "private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {\n    if (text == null || text.length() == 0 || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {\n        return text;\n    }\n        if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n        if (searchLength != replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + searchLength + \" vs \" + replacementLength);\n    }\n        boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n        int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n        for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n                if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n        if (textIndex == -1) {\n        return text;\n    }\n    int start = 0;\n        int increase = 0;\n        for (int i = 0; i < searchList.length; i++) {\n        int greater = replacementList[i].length() - searchList[i].length();\n        if (greater > 0) {\n                        increase += 3 * greater;\n        }\n    }\n        increase = Math.min(increase, text.length() / 5);\n    StringBuilder buf = new StringBuilder(text.length() + increase);\n    while (textIndex != -1) {\n        for (int i = start; i < textIndex; i++) {\n            buf.append(text.charAt(i));\n        }\n        buf.append(replacementList[replaceIndex]);\n        start = textIndex + searchList[replaceIndex].length();\n        textIndex = -1;\n        replaceIndex = -1;\n        tempIndex = -1;\n                for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i], start);\n                        if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n        }\n    int textLength = text.length();\n    for (int i = start; i < textLength; i++) {\n        buf.append(text.charAt(i));\n    }\n    String result = buf.toString();\n    if (!repeat) {\n        return result;\n    }\n    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n}", "lc": 2.8636363636363638, "pi": 0.6698564593301434, "ma": 3.8, "nbd": 1.0, "ml": 3.5, "d": 5.936507936507937, "mi": -1.254827343199436, "fo": 1.0833333333333333, "r": -0.02631578947368421, "e": 26.37760527422877}
{"project_name": "maven", "project_version": "remotes/origin/bugs-dot-jar_MNG-3131_56cd921f", "label": 1, "code": "private static void decomposeParameterIntoUserInstructions(MojoDescriptor mojo, Parameter param, StringBuilder messageBuffer) {\n    String expression = param.getExpression();\n    if (param.isEditable()) {\n        messageBuffer.append(\"Inside the definition for plugin \\'\" + mojo.getPluginDescriptor().getArtifactId() + \"\\', specify the following:\\n\\n<configuration>\\n  ...\\n  <\" + param.getName() + \">VALUE</\" + param.getName() + \">\\n</configuration>\");\n        String alias = param.getAlias();\n        if (StringUtils.isNotEmpty(alias) && !alias.equals(param.getName())) {\n            messageBuffer.append(\"\\n\\n-OR-\\n\\n<configuration>\\n  ...\\n  <\" + alias + \">VALUE</\" + alias + \">\\n</configuration>\\n\");\n        }\n    }\n    if (StringUtils.isEmpty(expression)) {\n        messageBuffer.append(\".\");\n    } else {\n        if (param.isEditable()) {\n            messageBuffer.append(\"\\n\\n-OR-\\n\\n\");\n        }\n    // addParameterUsageInfo( expression, messageBuffer );\n    }\n}", "code_comment": NaN, "code_no_comment": "private static void decomposeParameterIntoUserInstructions(MojoDescriptor mojo, Parameter param, StringBuilder messageBuffer) {\n    String expression = param.getExpression();\n    if (param.isEditable()) {\n        messageBuffer.append(\"Inside the definition for plugin \\'\" + mojo.getPluginDescriptor().getArtifactId() + \"\\', specify the following:\\n\\n<configuration>\\n  ...\\n  <\" + param.getName() + \">VALUE</\" + param.getName() + \">\\n</configuration>\");\n        String alias = param.getAlias();\n        if (StringUtils.isNotEmpty(alias) && !alias.equals(param.getName())) {\n            messageBuffer.append(\"\\n\\n-OR-\\n\\n<configuration>\\n  ...\\n  <\" + alias + \">VALUE</\" + alias + \">\\n</configuration>\\n\");\n        }\n    }\n    if (StringUtils.isEmpty(expression)) {\n        messageBuffer.append(\".\");\n    } else {\n        if (param.isEditable()) {\n            messageBuffer.append(\"\\n\\n-OR-\\n\\n\");\n        }\n        }\n}", "lc": 0.13636363636363635, "pi": 0.1913875598086124, "ma": 0.2, "nbd": 0.0, "ml": 0.5833333333333334, "d": 0.375, "mi": -0.19210711768851294, "fo": 0.8333333333333334, "r": -0.02631578947368421, "e": 0.3801109939316401}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3906_aadaa4e9", "label": 1, "code": "/**\n *  @see org.apache.wicket.request.mapper.parameter.INamedParameters#set(java.lang.String,\n *       java.lang.Object)\n */\npublic PageParameters set(final String name, final Object value) {\n    set(name, value, -1);\n    return this;\n}", "code_comment": "/**\n *  @see org.apache.wicket.request.mapper.parameter.INamedParameters#set(java.lang.String,\n *       java.lang.Object)\n */\n", "code_no_comment": "public PageParameters set(final String name, final Object value) {\n    set(name, value, -1);\n    return this;\n}", "lc": -0.45454545454545453, "pi": -0.47368421052631593, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.8046511627906971, "fo": -0.4166666666666667, "r": 0.39473684210526316, "e": -0.16279340490885932}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-2974_5eceb10e", "label": 0, "code": "private void deleteTablets(MergeInfo info) throws AccumuloException {\n    KeyExtent extent = info.getExtent();\n    String targetSystemTable = extent.isMeta() ? RootTable.NAME : MetadataTable.NAME;\n    Master.log.debug(\"Deleting tablets for \" + extent);\n    char timeType = '\\0';\n    KeyExtent followingTablet = null;\n    if (extent.getEndRow() != null) {\n        Key nextExtent = new Key(extent.getEndRow()).followingKey(PartialKey.ROW);\n        followingTablet = getHighTablet(new KeyExtent(extent.getTableId(), nextExtent.getRow(), extent.getEndRow()));\n        Master.log.debug(\"Found following tablet \" + followingTablet);\n    }\n    try {\n        Connector conn = this.master.getConnector();\n        Text start = extent.getPrevEndRow();\n        if (start == null) {\n            start = new Text();\n        }\n        Master.log.debug(\"Making file deletion entries for \" + extent);\n        Range deleteRange = new Range(KeyExtent.getMetadataEntry(extent.getTableId(), start), false, KeyExtent.getMetadataEntry(extent.getTableId(), extent.getEndRow()), true);\n        Scanner scanner = conn.createScanner(targetSystemTable, Authorizations.EMPTY);\n        scanner.setRange(deleteRange);\n        TabletsSection.ServerColumnFamily.DIRECTORY_COLUMN.fetch(scanner);\n        TabletsSection.ServerColumnFamily.TIME_COLUMN.fetch(scanner);\n        scanner.fetchColumnFamily(DataFileColumnFamily.NAME);\n        scanner.fetchColumnFamily(TabletsSection.CurrentLocationColumnFamily.NAME);\n        Set<FileRef> datafiles = new TreeSet<FileRef>();\n        for (Entry<Key, Value> entry : scanner) {\n            Key key = entry.getKey();\n            if (key.compareColumnFamily(DataFileColumnFamily.NAME) == 0) {\n                datafiles.add(new FileRef(this.master.fs, key));\n                if (datafiles.size() > 1000) {\n                    MetadataTableUtil.addDeleteEntries(extent, datafiles, SystemCredentials.get());\n                    datafiles.clear();\n                }\n            } else if (TabletsSection.ServerColumnFamily.TIME_COLUMN.hasColumns(key)) {\n                timeType = entry.getValue().toString().charAt(0);\n            } else if (key.compareColumnFamily(TabletsSection.CurrentLocationColumnFamily.NAME) == 0) {\n                throw new IllegalStateException(\"Tablet \" + key.getRow() + \" is assigned during a merge!\");\n            } else if (TabletsSection.ServerColumnFamily.DIRECTORY_COLUMN.hasColumns(key)) {\n                datafiles.add(new FileRef(entry.getValue().toString(), this.master.fs.getFullPath(FileType.TABLE, entry.getValue().toString())));\n                if (datafiles.size() > 1000) {\n                    MetadataTableUtil.addDeleteEntries(extent, datafiles, SystemCredentials.get());\n                    datafiles.clear();\n                }\n            }\n        }\n        MetadataTableUtil.addDeleteEntries(extent, datafiles, SystemCredentials.get());\n        BatchWriter bw = conn.createBatchWriter(targetSystemTable, new BatchWriterConfig());\n        try {\n            deleteTablets(info, deleteRange, bw, conn);\n        } finally {\n            bw.close();\n        }\n        if (followingTablet != null) {\n            Master.log.debug(\"Updating prevRow of \" + followingTablet + \" to \" + extent.getPrevEndRow());\n            bw = conn.createBatchWriter(targetSystemTable, new BatchWriterConfig());\n            try {\n                Mutation m = new Mutation(followingTablet.getMetadataEntry());\n                TabletsSection.TabletColumnFamily.PREV_ROW_COLUMN.put(m, KeyExtent.encodePrevEndRow(extent.getPrevEndRow()));\n                ChoppedColumnFamily.CHOPPED_COLUMN.putDelete(m);\n                bw.addMutation(m);\n                bw.flush();\n            } finally {\n                bw.close();\n            }\n        } else {\n            // Recreate the default tablet to hold the end of the table\n            Master.log.debug(\"Recreating the last tablet to point to \" + extent.getPrevEndRow());\n            String tdir = master.getFileSystem().choose(ServerConstants.getTablesDirs()) + \"/\" + extent.getTableId() + Constants.DEFAULT_TABLET_LOCATION;\n            MetadataTableUtil.addTablet(new KeyExtent(extent.getTableId(), null, extent.getPrevEndRow()), tdir, SystemCredentials.get(), timeType, this.master.masterLock);\n        }\n    } catch (Exception ex) {\n        throw new AccumuloException(ex);\n    }\n}", "code_comment": NaN, "code_no_comment": "private void deleteTablets(MergeInfo info) throws AccumuloException {\n    KeyExtent extent = info.getExtent();\n    String targetSystemTable = extent.isMeta() ? RootTable.NAME : MetadataTable.NAME;\n    Master.log.debug(\"Deleting tablets for \" + extent);\n    char timeType = '\\0';\n    KeyExtent followingTablet = null;\n    if (extent.getEndRow() != null) {\n        Key nextExtent = new Key(extent.getEndRow()).followingKey(PartialKey.ROW);\n        followingTablet = getHighTablet(new KeyExtent(extent.getTableId(), nextExtent.getRow(), extent.getEndRow()));\n        Master.log.debug(\"Found following tablet \" + followingTablet);\n    }\n    try {\n        Connector conn = this.master.getConnector();\n        Text start = extent.getPrevEndRow();\n        if (start == null) {\n            start = new Text();\n        }\n        Master.log.debug(\"Making file deletion entries for \" + extent);\n        Range deleteRange = new Range(KeyExtent.getMetadataEntry(extent.getTableId(), start), false, KeyExtent.getMetadataEntry(extent.getTableId(), extent.getEndRow()), true);\n        Scanner scanner = conn.createScanner(targetSystemTable, Authorizations.EMPTY);\n        scanner.setRange(deleteRange);\n        TabletsSection.ServerColumnFamily.DIRECTORY_COLUMN.fetch(scanner);\n        TabletsSection.ServerColumnFamily.TIME_COLUMN.fetch(scanner);\n        scanner.fetchColumnFamily(DataFileColumnFamily.NAME);\n        scanner.fetchColumnFamily(TabletsSection.CurrentLocationColumnFamily.NAME);\n        Set<FileRef> datafiles = new TreeSet<FileRef>();\n        for (Entry<Key, Value> entry : scanner) {\n            Key key = entry.getKey();\n            if (key.compareColumnFamily(DataFileColumnFamily.NAME) == 0) {\n                datafiles.add(new FileRef(this.master.fs, key));\n                if (datafiles.size() > 1000) {\n                    MetadataTableUtil.addDeleteEntries(extent, datafiles, SystemCredentials.get());\n                    datafiles.clear();\n                }\n            } else if (TabletsSection.ServerColumnFamily.TIME_COLUMN.hasColumns(key)) {\n                timeType = entry.getValue().toString().charAt(0);\n            } else if (key.compareColumnFamily(TabletsSection.CurrentLocationColumnFamily.NAME) == 0) {\n                throw new IllegalStateException(\"Tablet \" + key.getRow() + \" is assigned during a merge!\");\n            } else if (TabletsSection.ServerColumnFamily.DIRECTORY_COLUMN.hasColumns(key)) {\n                datafiles.add(new FileRef(entry.getValue().toString(), this.master.fs.getFullPath(FileType.TABLE, entry.getValue().toString())));\n                if (datafiles.size() > 1000) {\n                    MetadataTableUtil.addDeleteEntries(extent, datafiles, SystemCredentials.get());\n                    datafiles.clear();\n                }\n            }\n        }\n        MetadataTableUtil.addDeleteEntries(extent, datafiles, SystemCredentials.get());\n        BatchWriter bw = conn.createBatchWriter(targetSystemTable, new BatchWriterConfig());\n        try {\n            deleteTablets(info, deleteRange, bw, conn);\n        } finally {\n            bw.close();\n        }\n        if (followingTablet != null) {\n            Master.log.debug(\"Updating prevRow of \" + followingTablet + \" to \" + extent.getPrevEndRow());\n            bw = conn.createBatchWriter(targetSystemTable, new BatchWriterConfig());\n            try {\n                Mutation m = new Mutation(followingTablet.getMetadataEntry());\n                TabletsSection.TabletColumnFamily.PREV_ROW_COLUMN.put(m, KeyExtent.encodePrevEndRow(extent.getPrevEndRow()));\n                ChoppedColumnFamily.CHOPPED_COLUMN.putDelete(m);\n                bw.addMutation(m);\n                bw.flush();\n            } finally {\n                bw.close();\n            }\n        } else {\n                        Master.log.debug(\"Recreating the last tablet to point to \" + extent.getPrevEndRow());\n            String tdir = master.getFileSystem().choose(ServerConstants.getTablesDirs()) + \"/\" + extent.getTableId() + Constants.DEFAULT_TABLET_LOCATION;\n            MetadataTableUtil.addTablet(new KeyExtent(extent.getTableId(), null, extent.getPrevEndRow()), tdir, SystemCredentials.get(), timeType, this.master.masterLock);\n        }\n    } catch (Exception ex) {\n        throw new AccumuloException(ex);\n    }\n}", "lc": 2.727272727272727, "pi": 0.8181818181818182, "ma": 2.2, "nbd": 2.5, "ml": 1.25, "d": 0.6170634920634921, "mi": -1.2193093727977444, "fo": 5.75, "r": -0.02631578947368421, "e": 5.067236043636866}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4259_1f128536", "label": 3, "code": "/**\n *  Gets the label component.\n *\n *  @return The label component\n */\nprotected final Component getLabel() {\n    if (label == null) {\n        initLabelAndEditor(getDelegatingParentModel());\n    }\n    return label;\n}", "code_comment": "/**\n *  Gets the label component.\n *\n *  @return The label component\n */\n", "code_no_comment": "protected final Component getLabel() {\n    if (label == null) {\n        initLabelAndEditor(getDelegatingParentModel());\n    }\n    return label;\n}", "lc": -0.36363636363636365, "pi": -0.11483253588516758, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": -0.3650793650793651, "mi": 0.6634249471458771, "fo": -0.3333333333333333, "r": 2.552631578947368, "e": -0.16279340490885932}
{"project_name": "Math", "project_version": 68, "label": 1, "code": "/**\n * {@inheritDoc}\n */\n@Override\nprotected VectorialPointValuePair doOptimize() throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n    // arrays shared with the other private methods\n    solvedCols = Math.min(rows, cols);\n    diagR = new double[cols];\n    jacNorm = new double[cols];\n    beta = new double[cols];\n    permutation = new int[cols];\n    lmDir = new double[cols];\n    // local point\n    double delta = 0;\n    double xNorm = 0;\n    double[] diag = new double[cols];\n    double[] oldX = new double[cols];\n    double[] oldRes = new double[rows];\n    double[] work1 = new double[cols];\n    double[] work2 = new double[cols];\n    double[] work3 = new double[cols];\n    // evaluate the function at the starting point and calculate its norm\n    updateResidualsAndCost();\n    // outer loop\n    lmPar = 0;\n    boolean firstIteration = true;\n    while (true) {\n        incrementIterationsCounter();\n        // compute the Q.R. decomposition of the jacobian matrix\n        updateJacobian();\n        qrDecomposition();\n        // compute Qt.res\n        qTy(residuals);\n        // so let jacobian contain the R matrix with its diagonal elements\n        for (int k = 0; k < solvedCols; ++k) {\n            int pk = permutation[k];\n            jacobian[k][pk] = diagR[pk];\n        }\n        if (firstIteration) {\n            // scale the point according to the norms of the columns\n            // of the initial jacobian\n            xNorm = 0;\n            for (int k = 0; k < cols; ++k) {\n                double dk = jacNorm[k];\n                if (dk == 0) {\n                    dk = 1.0;\n                }\n                double xk = dk * point[k];\n                xNorm += xk * xk;\n                diag[k] = dk;\n            }\n            xNorm = Math.sqrt(xNorm);\n            // initialize the step bound delta\n            delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n        }\n        // check orthogonality between function vector and jacobian columns\n        double maxCosine = 0;\n        if (cost != 0) {\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double s = jacNorm[pj];\n                if (s != 0) {\n                    double sum = 0;\n                    for (int i = 0; i <= j; ++i) {\n                        sum += jacobian[i][pj] * residuals[i];\n                    }\n                    maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                }\n            }\n        }\n        if (maxCosine <= orthoTolerance) {\n            // convergence has been reached\n            return new VectorialPointValuePair(point, objective);\n        }\n        // rescale if necessary\n        for (int j = 0; j < cols; ++j) {\n            diag[j] = Math.max(diag[j], jacNorm[j]);\n        }\n        // inner loop\n        for (double ratio = 0; ratio < 1.0e-4; ) {\n            // save the state\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                oldX[pj] = point[pj];\n            }\n            double previousCost = cost;\n            double[] tmpVec = residuals;\n            residuals = oldRes;\n            oldRes = tmpVec;\n            // determine the Levenberg-Marquardt parameter\n            determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n            // compute the new point and the norm of the evolution direction\n            double lmNorm = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                lmDir[pj] = -lmDir[pj];\n                point[pj] = oldX[pj] + lmDir[pj];\n                double s = diag[pj] * lmDir[pj];\n                lmNorm += s * s;\n            }\n            lmNorm = Math.sqrt(lmNorm);\n            // on the first iteration, adjust the initial step bound.\n            if (firstIteration) {\n                delta = Math.min(delta, lmNorm);\n            }\n            // evaluate the function at x + p and calculate its norm\n            updateResidualsAndCost();\n            // compute the scaled actual reduction\n            double actRed = -1.0;\n            if (0.1 * cost < previousCost) {\n                double r = cost / previousCost;\n                actRed = 1.0 - r * r;\n            }\n            // and the scaled directional derivative\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double dirJ = lmDir[pj];\n                work1[j] = 0;\n                for (int i = 0; i <= j; ++i) {\n                    work1[i] += jacobian[i][pj] * dirJ;\n                }\n            }\n            double coeff1 = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                coeff1 += work1[j] * work1[j];\n            }\n            double pc2 = previousCost * previousCost;\n            coeff1 = coeff1 / pc2;\n            double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n            double preRed = coeff1 + 2 * coeff2;\n            double dirDer = -(coeff1 + coeff2);\n            // ratio of the actual to the predicted reduction\n            ratio = (preRed == 0) ? 0 : (actRed / preRed);\n            // update the step bound\n            if (ratio <= 0.25) {\n                double tmp = (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {\n                    tmp = 0.1;\n                }\n                delta = tmp * Math.min(delta, 10.0 * lmNorm);\n                lmPar /= tmp;\n            } else if ((lmPar == 0) || (ratio >= 0.75)) {\n                delta = 2 * lmNorm;\n                lmPar *= 0.5;\n            }\n            // test for successful iteration.\n            if (ratio >= 1.0e-4) {\n                // successful iteration, update the norm\n                firstIteration = false;\n                xNorm = 0;\n                for (int k = 0; k < cols; ++k) {\n                    double xK = diag[k] * point[k];\n                    xNorm += xK * xK;\n                }\n                xNorm = Math.sqrt(xNorm);\n            } else {\n                // failed iteration, reset the previous values\n                cost = previousCost;\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    point[pj] = oldX[pj];\n                }\n                tmpVec = residuals;\n                residuals = oldRes;\n                oldRes = tmpVec;\n            }\n            // we use the Levenberg-Marquardt specific convergence parameters\n            if (((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance) && (ratio <= 2.0)) || (delta <= parRelativeTolerance * xNorm)) {\n                return new VectorialPointValuePair(point, objective);\n            }\n            // (2.2204e-16 is the machine epsilon for IEEE754)\n            if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n                throw new OptimizationException(\"cost relative tolerance is too small ({0}),\" + \" no further reduction in the\" + \" sum of squares is possible\", costRelativeTolerance);\n            } else if (delta <= 2.2204e-16 * xNorm) {\n                throw new OptimizationException(\"parameters relative tolerance is too small\" + \" ({0}), no further improvement in\" + \" the approximate solution is possible\", parRelativeTolerance);\n            } else if (maxCosine <= 2.2204e-16) {\n                throw new OptimizationException(\"orthogonality tolerance is too small ({0}),\" + \" solution is orthogonal to the jacobian\", orthoTolerance);\n            }\n        }\n    }\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "@Override\nprotected VectorialPointValuePair doOptimize() throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n        solvedCols = Math.min(rows, cols);\n    diagR = new double[cols];\n    jacNorm = new double[cols];\n    beta = new double[cols];\n    permutation = new int[cols];\n    lmDir = new double[cols];\n        double delta = 0;\n    double xNorm = 0;\n    double[] diag = new double[cols];\n    double[] oldX = new double[cols];\n    double[] oldRes = new double[rows];\n    double[] work1 = new double[cols];\n    double[] work2 = new double[cols];\n    double[] work3 = new double[cols];\n        updateResidualsAndCost();\n        lmPar = 0;\n    boolean firstIteration = true;\n    while (true) {\n        incrementIterationsCounter();\n                updateJacobian();\n        qrDecomposition();\n                qTy(residuals);\n                for (int k = 0; k < solvedCols; ++k) {\n            int pk = permutation[k];\n            jacobian[k][pk] = diagR[pk];\n        }\n        if (firstIteration) {\n                                    xNorm = 0;\n            for (int k = 0; k < cols; ++k) {\n                double dk = jacNorm[k];\n                if (dk == 0) {\n                    dk = 1.0;\n                }\n                double xk = dk * point[k];\n                xNorm += xk * xk;\n                diag[k] = dk;\n            }\n            xNorm = Math.sqrt(xNorm);\n                        delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n        }\n                double maxCosine = 0;\n        if (cost != 0) {\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double s = jacNorm[pj];\n                if (s != 0) {\n                    double sum = 0;\n                    for (int i = 0; i <= j; ++i) {\n                        sum += jacobian[i][pj] * residuals[i];\n                    }\n                    maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                }\n            }\n        }\n        if (maxCosine <= orthoTolerance) {\n                        return new VectorialPointValuePair(point, objective);\n        }\n                for (int j = 0; j < cols; ++j) {\n            diag[j] = Math.max(diag[j], jacNorm[j]);\n        }\n                for (double ratio = 0; ratio < 1.0e-4; ) {\n                        for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                oldX[pj] = point[pj];\n            }\n            double previousCost = cost;\n            double[] tmpVec = residuals;\n            residuals = oldRes;\n            oldRes = tmpVec;\n                        determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n                        double lmNorm = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                lmDir[pj] = -lmDir[pj];\n                point[pj] = oldX[pj] + lmDir[pj];\n                double s = diag[pj] * lmDir[pj];\n                lmNorm += s * s;\n            }\n            lmNorm = Math.sqrt(lmNorm);\n                        if (firstIteration) {\n                delta = Math.min(delta, lmNorm);\n            }\n                        updateResidualsAndCost();\n                        double actRed = -1.0;\n            if (0.1 * cost < previousCost) {\n                double r = cost / previousCost;\n                actRed = 1.0 - r * r;\n            }\n                        for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double dirJ = lmDir[pj];\n                work1[j] = 0;\n                for (int i = 0; i <= j; ++i) {\n                    work1[i] += jacobian[i][pj] * dirJ;\n                }\n            }\n            double coeff1 = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                coeff1 += work1[j] * work1[j];\n            }\n            double pc2 = previousCost * previousCost;\n            coeff1 = coeff1 / pc2;\n            double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n            double preRed = coeff1 + 2 * coeff2;\n            double dirDer = -(coeff1 + coeff2);\n                        ratio = (preRed == 0) ? 0 : (actRed / preRed);\n                        if (ratio <= 0.25) {\n                double tmp = (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {\n                    tmp = 0.1;\n                }\n                delta = tmp * Math.min(delta, 10.0 * lmNorm);\n                lmPar /= tmp;\n            } else if ((lmPar == 0) || (ratio >= 0.75)) {\n                delta = 2 * lmNorm;\n                lmPar *= 0.5;\n            }\n                        if (ratio >= 1.0e-4) {\n                                firstIteration = false;\n                xNorm = 0;\n                for (int k = 0; k < cols; ++k) {\n                    double xK = diag[k] * point[k];\n                    xNorm += xK * xK;\n                }\n                xNorm = Math.sqrt(xNorm);\n            } else {\n                                cost = previousCost;\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    point[pj] = oldX[pj];\n                }\n                tmpVec = residuals;\n                residuals = oldRes;\n                oldRes = tmpVec;\n            }\n                        if (((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance) && (ratio <= 2.0)) || (delta <= parRelativeTolerance * xNorm)) {\n                return new VectorialPointValuePair(point, objective);\n            }\n                        if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n                throw new OptimizationException(\"cost relative tolerance is too small ({0}),\" + \" no further reduction in the\" + \" sum of squares is possible\", costRelativeTolerance);\n            } else if (delta <= 2.2204e-16 * xNorm) {\n                throw new OptimizationException(\"parameters relative tolerance is too small\" + \" ({0}), no further improvement in\" + \" the approximate solution is possible\", parRelativeTolerance);\n            } else if (maxCosine <= 2.2204e-16) {\n                throw new OptimizationException(\"orthogonality tolerance is too small ({0}),\" + \" solution is orthogonal to the jacobian\", orthoTolerance);\n            }\n        }\n    }\n}", "lc": 6.181818181818182, "pi": 0.8899521531100476, "ma": 6.4, "nbd": 1.5, "ml": 4.666666666666667, "d": 6.990079365079365, "mi": -1.7616631430584915, "fo": 1.0, "r": -0.02631578947368421, "e": 69.16616010557676}
{"project_name": "Closure", "project_version": 169, "label": 2, "code": "boolean checkArrowEquivalenceHelper(ArrowType that, boolean tolerateUnknowns) {\n    // Please keep this method in sync with the hashCode() method below.\n    if (!returnType.checkEquivalenceHelper(that.returnType, tolerateUnknowns)) {\n        return false;\n    }\n    return hasEqualParameters(that, tolerateUnknowns);\n}", "code_comment": NaN, "code_no_comment": "boolean checkArrowEquivalenceHelper(ArrowType that, boolean tolerateUnknowns) {\n        if (!returnType.checkEquivalenceHelper(that.returnType, tolerateUnknowns)) {\n        return false;\n    }\n    return hasEqualParameters(that, tolerateUnknowns);\n}", "lc": -0.36363636363636365, "pi": -0.11483253588516758, "ma": -0.4, "nbd": -0.5, "ml": -0.08333333333333333, "d": -0.3650793650793651, "mi": 0.5735024665257221, "fo": -0.3333333333333333, "r": 0.39473684210526316, "e": -0.16279340490885932}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3511_4a875f46", "label": 1, "code": "public String getReference() {\n    return fileName;\n}", "code_comment": NaN, "code_no_comment": "public String getReference() {\n    return fileName;\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.1646229739252991, "fo": -0.5, "r": 2.236842105263158, "e": -0.16279340490885932}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-366_db4a291f", "label": 1, "code": "@Override\npublic void flushTablet(TInfo tinfo, AuthInfo credentials, String lock, TKeyExtent textent) throws TException {\n    try {\n        checkPermission(credentials, lock, true, \"flushTablet\");\n    } catch (ThriftSecurityException e) {\n        log.error(e, e);\n        throw new RuntimeException(e);\n    }\n    Tablet tablet = onlineTablets.get(new KeyExtent(textent));\n    if (tablet != null) {\n        log.info(\"Flushing \" + tablet.getExtent());\n        tablet.flush(tablet.getFlushID());\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void flushTablet(TInfo tinfo, AuthInfo credentials, String lock, TKeyExtent textent) throws TException {\n    try {\n        checkPermission(credentials, lock, true, \"flushTablet\");\n    } catch (ThriftSecurityException e) {\n        log.error(e, e);\n        throw new RuntimeException(e);\n    }\n    Tablet tablet = onlineTablets.get(new KeyExtent(textent));\n    if (tablet != null) {\n        log.info(\"Flushing \" + tablet.getExtent());\n        tablet.flush(tablet.getFlushID());\n    }\n}", "lc": 0.0, "pi": -0.00956937799043063, "ma": 0.0, "nbd": -0.5, "ml": -0.25, "d": -0.08730158730158734, "mi": -0.04862579281183915, "fo": 0.08333333333333333, "r": 0.0, "e": -0.016276804803974112}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5345_3fc7234e", "label": 1, "code": "/**\n *  Try to reduce url by eliminating '..' and '.' from the path where appropriate (this is\n *  somehow similar to {@link java.io.File#getCanonicalPath()}). Either by different / unexpected\n *  browser behavior or by malicious attacks it can happen that these kind of redundant urls are\n *  processed by wicket. These urls can cause some trouble when mapping the request.\n *  <p/>\n *  <strong>example:</strong>\n *\n *  the url\n *\n *  <pre>\n *  /example/..;jsessionid=234792?0\n *  </pre>\n *\n *  will not get normalized by the browser due to the ';jsessionid' string that gets appended by\n *  the servlet container. After wicket strips the jsessionid part the resulting internal url\n *  will be\n *\n *  <pre>\n *  /example/..\n *  </pre>\n *\n *  instead of\n *\n *  <pre>\n *  /\n *  </pre>\n *\n *  <p/>\n *\n *  This code correlates to <a\n *  href=\"https://issues.apache.org/jira/browse/WICKET-4303\">WICKET-4303</a>\n *\n *  @return canonical url\n */\npublic Url canonical() {\n    Url url = new Url(this);\n    url.segments.clear();\n    for (int i = 0; i < segments.size(); i++) {\n        final String segment = segments.get(i);\n        // drop '.' from path\n        if (\".\".equals(segment)) {\n            continue;\n        }\n        // skip segment if following segment is a '..'\n        if ((i + 1) < segments.size() && \"..\".equals(segments.get(i + 1))) {\n            i++;\n            continue;\n        }\n        url.segments.add(segment);\n    }\n    return url;\n}", "code_comment": "/**\n *  Try to reduce url by eliminating '..' and '.' from the path where appropriate (this is\n *  somehow similar to {@link java.io.File#getCanonicalPath()}). Either by different / unexpected\n *  browser behavior or by malicious attacks it can happen that these kind of redundant urls are\n *  processed by wicket. These urls can cause some trouble when mapping the request.\n *  <p/>\n *  <strong>example:</strong>\n *\n *  the url\n *\n *  <pre>\n *  /example/..;jsessionid=234792?0\n *  </pre>\n *\n *  will not get normalized by the browser due to the ';jsessionid' string that gets appended by\n *  the servlet container. After wicket strips the jsessionid part the resulting internal url\n *  will be\n *\n *  <pre>\n *  /example/..\n *  </pre>\n *\n *  instead of\n *\n *  <pre>\n *  /\n *  </pre>\n *\n *  <p/>\n *\n *  This code correlates to <a\n *  href=\"https://issues.apache.org/jira/browse/WICKET-4303\">WICKET-4303</a>\n *\n *  @return canonical url\n */\n", "code_no_comment": "public Url canonical() {\n    Url url = new Url(this);\n    url.segments.clear();\n    for (int i = 0; i < segments.size(); i++) {\n        final String segment = segments.get(i);\n                if (\".\".equals(segment)) {\n            continue;\n        }\n                if ((i + 1) < segments.size() && \"..\".equals(segments.get(i + 1))) {\n            i++;\n            continue;\n        }\n        url.segments.add(segment);\n    }\n    return url;\n}", "lc": 0.09090909090909091, "pi": 0.3444976076555023, "ma": 0.4, "nbd": 0.0, "ml": 0.4166666666666667, "d": 0.5456349206349206, "mi": -0.11712473572938689, "fo": 0.16666666666666666, "r": 0.05263157894736841, "e": 0.29943465707715977}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-2882_ebe56869", "label": 1, "code": "/**\n *  Attempts to resolve a component using resolvers. Tries resolvers in the component hierarchy\n *  as well as application-wide.\n *  <p>\n *  This method encapsulates the contract of resolving components and should be used any time a\n *  component needs to be resolved under normal circumstances.\n *  </p>\n *\n *  @param container\n *  @param markupStream\n *  @param tag\n *  @return <code>null</code> if a component was could not be found\n */\npublic static Component resolve(final MarkupContainer container, final MarkupStream markupStream, final ComponentTag tag) {\n    // try to resolve using component hierarchy\n    Component cursor = container;\n    while (cursor != null) {\n        if (cursor instanceof IComponentResolver) {\n            IComponentResolver resolver = (IComponentResolver) cursor;\n            Component component = resolver.resolve(container, markupStream, tag);\n            if (component != null) {\n                return component;\n            }\n        }\n        cursor = cursor.getParent();\n    }\n    for (final IComponentResolver resolver : Application.get().getPageSettings().getComponentResolvers()) {\n        Component component = resolver.resolve(container, markupStream, tag);\n        if (component != null) {\n            return component;\n        }\n    }\n    return null;\n}", "code_comment": "/**\n *  Attempts to resolve a component using resolvers. Tries resolvers in the component hierarchy\n *  as well as application-wide.\n *  <p>\n *  This method encapsulates the contract of resolving components and should be used any time a\n *  component needs to be resolved under normal circumstances.\n *  </p>\n *\n *  @param container\n *  @param markupStream\n *  @param tag\n *  @return <code>null</code> if a component was could not be found\n */\n", "code_no_comment": "public static Component resolve(final MarkupContainer container, final MarkupStream markupStream, final ComponentTag tag) {\n        Component cursor = container;\n    while (cursor != null) {\n        if (cursor instanceof IComponentResolver) {\n            IComponentResolver resolver = (IComponentResolver) cursor;\n            Component component = resolver.resolve(container, markupStream, tag);\n            if (component != null) {\n                return component;\n            }\n        }\n        cursor = cursor.getParent();\n    }\n    for (final IComponentResolver resolver : Application.get().getPageSettings().getComponentResolvers()) {\n        Component component = resolver.resolve(container, markupStream, tag);\n        if (component != null) {\n            return component;\n        }\n    }\n    return null;\n}", "lc": 0.2727272727272727, "pi": 0.6028708133971291, "ma": 0.4, "nbd": 0.5, "ml": 0.08333333333333333, "d": 0.15674603174603172, "mi": -0.24143763213530642, "fo": 0.0, "r": -0.02631578947368421, "e": 0.14628838828282126}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-965_43517f15", "label": 0, "code": "private static OutputStream getOutputStream(final boolean follow, final Target target) {\n    final String enc = Charset.defaultCharset().name();\n    PrintStream printStream = null;\n    try {\n        printStream = target == Target.SYSTEM_OUT ? follow ? new PrintStream(new CloseShieldOutputStream(System.out), true, enc) : System.out : follow ? new PrintStream(new CloseShieldOutputStream(System.err), true, enc) : System.err;\n    } catch (final UnsupportedEncodingException ex) {\n        // should never happen\n        throw new IllegalStateException(\"Unsupported default encoding \" + enc, ex);\n    }\n    final PropertiesUtil propsUtil = PropertiesUtil.getProperties();\n    if (!propsUtil.getStringProperty(\"os.name\").startsWith(\"Windows\") || propsUtil.getBooleanProperty(\"log4j.skipJansi\")) {\n        return printStream;\n    }\n    try {\n        // We type the parameter as a wildcard to avoid a hard reference to Jansi.\n        final Class<?> clazz = Loader.loadClass(JANSI_CLASS);\n        final Constructor<?> constructor = clazz.getConstructor(OutputStream.class);\n        // LOG4J-965\n        return new CloseShieldOutputStream((OutputStream) constructor.newInstance(printStream));\n    } catch (final ClassNotFoundException cnfe) {\n        LOGGER.debug(\"Jansi is not installed, cannot find {}\", JANSI_CLASS);\n    } catch (final NoSuchMethodException nsme) {\n        LOGGER.warn(\"{} is missing the proper constructor\", JANSI_CLASS);\n    } catch (final Exception ex) {\n        LOGGER.warn(\"Unable to instantiate {}\", JANSI_CLASS);\n    }\n    return printStream;\n}", "code_comment": NaN, "code_no_comment": "private static OutputStream getOutputStream(final boolean follow, final Target target) {\n    final String enc = Charset.defaultCharset().name();\n    PrintStream printStream = null;\n    try {\n        printStream = target == Target.SYSTEM_OUT ? follow ? new PrintStream(new CloseShieldOutputStream(System.out), true, enc) : System.out : follow ? new PrintStream(new CloseShieldOutputStream(System.err), true, enc) : System.err;\n    } catch (final UnsupportedEncodingException ex) {\n                throw new IllegalStateException(\"Unsupported default encoding \" + enc, ex);\n    }\n    final PropertiesUtil propsUtil = PropertiesUtil.getProperties();\n    if (!propsUtil.getStringProperty(\"os.name\").startsWith(\"Windows\") || propsUtil.getBooleanProperty(\"log4j.skipJansi\")) {\n        return printStream;\n    }\n    try {\n                final Class<?> clazz = Loader.loadClass(JANSI_CLASS);\n        final Constructor<?> constructor = clazz.getConstructor(OutputStream.class);\n                return new CloseShieldOutputStream((OutputStream) constructor.newInstance(printStream));\n    } catch (final ClassNotFoundException cnfe) {\n        LOGGER.debug(\"Jansi is not installed, cannot find {}\", JANSI_CLASS);\n    } catch (final NoSuchMethodException nsme) {\n        LOGGER.warn(\"{} is missing the proper constructor\", JANSI_CLASS);\n    } catch (final Exception ex) {\n        LOGGER.warn(\"Unable to instantiate {}\", JANSI_CLASS);\n    }\n    return printStream;\n}", "lc": 0.5, "pi": -0.2775119617224881, "ma": 1.2, "nbd": -0.5, "ml": 0.3333333333333333, "d": 0.30158730158730157, "mi": -0.48978153629316407, "fo": 0.5, "r": -0.02631578947368421, "e": 0.7351717063444038}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-4482_e38494f1", "label": 1, "code": "protected Iterable<ProcessorExchangePair> createProcessorExchangePairs(Exchange exchange) throws Exception {\n    List<ProcessorExchangePair> result = new ArrayList<ProcessorExchangePair>(processors.size());\n    int index = 0;\n    for (Processor processor : processors) {\n        // copy exchange, and do not share the unit of work\n        Exchange copy = ExchangeHelper.createCorrelatedCopy(exchange, false);\n        // if we share unit of work, we need to prepare the child exchange\n        if (isShareUnitOfWork()) {\n            prepareSharedUnitOfWork(copy, exchange);\n        }\n        // and add the pair\n        RouteContext routeContext = exchange.getUnitOfWork() != null ? exchange.getUnitOfWork().getRouteContext() : null;\n        result.add(createProcessorExchangePair(index++, processor, copy, routeContext));\n    }\n    return result;\n}", "code_comment": NaN, "code_no_comment": "protected Iterable<ProcessorExchangePair> createProcessorExchangePairs(Exchange exchange) throws Exception {\n    List<ProcessorExchangePair> result = new ArrayList<ProcessorExchangePair>(processors.size());\n    int index = 0;\n    for (Processor processor : processors) {\n                Exchange copy = ExchangeHelper.createCorrelatedCopy(exchange, false);\n                if (isShareUnitOfWork()) {\n            prepareSharedUnitOfWork(copy, exchange);\n        }\n                RouteContext routeContext = exchange.getUnitOfWork() != null ? exchange.getUnitOfWork().getRouteContext() : null;\n        result.add(createProcessorExchangePair(index++, processor, copy, routeContext));\n    }\n    return result;\n}", "lc": -0.045454545454545456, "pi": 0.16746411483253573, "ma": 0.0, "nbd": 0.0, "ml": -0.08333333333333333, "d": -0.0496031746031746, "mi": -0.034813248766737116, "fo": 0.25, "r": -0.02631578947368421, "e": 0.027341620419195148}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-9124_9da2c05a", "label": 3, "code": "public RedeliveryPolicy createRedeliveryPolicy(CamelContext context, RedeliveryPolicy parentPolicy) {\n    RedeliveryPolicy answer;\n    if (parentPolicy != null) {\n        answer = parentPolicy.copy();\n    } else {\n        answer = new RedeliveryPolicy();\n    }\n    try {\n        // copy across the properties - if they are set\n        if (maximumRedeliveries != null) {\n            answer.setMaximumRedeliveries(CamelContextHelper.parseInteger(context, maximumRedeliveries));\n        }\n        if (redeliveryDelay != null) {\n            answer.setRedeliveryDelay(CamelContextHelper.parseLong(context, redeliveryDelay));\n        }\n        if (asyncDelayedRedelivery != null) {\n            if (CamelContextHelper.parseBoolean(context, asyncDelayedRedelivery)) {\n                answer.asyncDelayedRedelivery();\n            }\n        }\n        if (retriesExhaustedLogLevel != null) {\n            answer.setRetriesExhaustedLogLevel(retriesExhaustedLogLevel);\n        }\n        if (retryAttemptedLogLevel != null) {\n            answer.setRetryAttemptedLogLevel(retryAttemptedLogLevel);\n        }\n        if (backOffMultiplier != null) {\n            answer.setBackOffMultiplier(CamelContextHelper.parseDouble(context, backOffMultiplier));\n        }\n        if (useExponentialBackOff != null) {\n            answer.setUseExponentialBackOff(CamelContextHelper.parseBoolean(context, useExponentialBackOff));\n        }\n        if (collisionAvoidanceFactor != null) {\n            answer.setCollisionAvoidanceFactor(CamelContextHelper.parseDouble(context, collisionAvoidanceFactor));\n        }\n        if (useCollisionAvoidance != null) {\n            answer.setUseCollisionAvoidance(CamelContextHelper.parseBoolean(context, useCollisionAvoidance));\n        }\n        if (maximumRedeliveryDelay != null) {\n            answer.setMaximumRedeliveryDelay(CamelContextHelper.parseLong(context, maximumRedeliveryDelay));\n        }\n        if (logStackTrace != null) {\n            answer.setLogStackTrace(CamelContextHelper.parseBoolean(context, logStackTrace));\n        }\n        if (logRetryStackTrace != null) {\n            answer.setLogRetryStackTrace(CamelContextHelper.parseBoolean(context, logRetryStackTrace));\n        }\n        if (logHandled != null) {\n            answer.setLogHandled(CamelContextHelper.parseBoolean(context, logHandled));\n        }\n        if (logNewException != null) {\n            answer.setLogNewException(CamelContextHelper.parseBoolean(context, logNewException));\n        }\n        if (logContinued != null) {\n            answer.setLogContinued(CamelContextHelper.parseBoolean(context, logContinued));\n        }\n        if (logRetryAttempted != null) {\n            answer.setLogRetryAttempted(CamelContextHelper.parseBoolean(context, logRetryAttempted));\n        }\n        if (logExhausted != null) {\n            answer.setLogExhausted(CamelContextHelper.parseBoolean(context, logExhausted));\n        }\n        if (logExhaustedMessageHistory != null) {\n            answer.setLogExhaustedMessageHistory(CamelContextHelper.parseBoolean(context, logExhaustedMessageHistory));\n        }\n        if (disableRedelivery != null) {\n            if (CamelContextHelper.parseBoolean(context, disableRedelivery)) {\n                answer.setMaximumRedeliveries(0);\n            }\n        }\n        if (delayPattern != null) {\n            answer.setDelayPattern(delayPattern);\n        }\n        if (allowRedeliveryWhileStopping != null) {\n            answer.setAllowRedeliveryWhileStopping(CamelContextHelper.parseBoolean(context, allowRedeliveryWhileStopping));\n        }\n        if (exchangeFormatterRef != null) {\n            answer.setExchangeFormatterRef(exchangeFormatterRef);\n        }\n    } catch (Exception e) {\n        throw ObjectHelper.wrapRuntimeCamelException(e);\n    }\n    return answer;\n}", "code_comment": NaN, "code_no_comment": "public RedeliveryPolicy createRedeliveryPolicy(CamelContext context, RedeliveryPolicy parentPolicy) {\n    RedeliveryPolicy answer;\n    if (parentPolicy != null) {\n        answer = parentPolicy.copy();\n    } else {\n        answer = new RedeliveryPolicy();\n    }\n    try {\n                if (maximumRedeliveries != null) {\n            answer.setMaximumRedeliveries(CamelContextHelper.parseInteger(context, maximumRedeliveries));\n        }\n        if (redeliveryDelay != null) {\n            answer.setRedeliveryDelay(CamelContextHelper.parseLong(context, redeliveryDelay));\n        }\n        if (asyncDelayedRedelivery != null) {\n            if (CamelContextHelper.parseBoolean(context, asyncDelayedRedelivery)) {\n                answer.asyncDelayedRedelivery();\n            }\n        }\n        if (retriesExhaustedLogLevel != null) {\n            answer.setRetriesExhaustedLogLevel(retriesExhaustedLogLevel);\n        }\n        if (retryAttemptedLogLevel != null) {\n            answer.setRetryAttemptedLogLevel(retryAttemptedLogLevel);\n        }\n        if (backOffMultiplier != null) {\n            answer.setBackOffMultiplier(CamelContextHelper.parseDouble(context, backOffMultiplier));\n        }\n        if (useExponentialBackOff != null) {\n            answer.setUseExponentialBackOff(CamelContextHelper.parseBoolean(context, useExponentialBackOff));\n        }\n        if (collisionAvoidanceFactor != null) {\n            answer.setCollisionAvoidanceFactor(CamelContextHelper.parseDouble(context, collisionAvoidanceFactor));\n        }\n        if (useCollisionAvoidance != null) {\n            answer.setUseCollisionAvoidance(CamelContextHelper.parseBoolean(context, useCollisionAvoidance));\n        }\n        if (maximumRedeliveryDelay != null) {\n            answer.setMaximumRedeliveryDelay(CamelContextHelper.parseLong(context, maximumRedeliveryDelay));\n        }\n        if (logStackTrace != null) {\n            answer.setLogStackTrace(CamelContextHelper.parseBoolean(context, logStackTrace));\n        }\n        if (logRetryStackTrace != null) {\n            answer.setLogRetryStackTrace(CamelContextHelper.parseBoolean(context, logRetryStackTrace));\n        }\n        if (logHandled != null) {\n            answer.setLogHandled(CamelContextHelper.parseBoolean(context, logHandled));\n        }\n        if (logNewException != null) {\n            answer.setLogNewException(CamelContextHelper.parseBoolean(context, logNewException));\n        }\n        if (logContinued != null) {\n            answer.setLogContinued(CamelContextHelper.parseBoolean(context, logContinued));\n        }\n        if (logRetryAttempted != null) {\n            answer.setLogRetryAttempted(CamelContextHelper.parseBoolean(context, logRetryAttempted));\n        }\n        if (logExhausted != null) {\n            answer.setLogExhausted(CamelContextHelper.parseBoolean(context, logExhausted));\n        }\n        if (logExhaustedMessageHistory != null) {\n            answer.setLogExhaustedMessageHistory(CamelContextHelper.parseBoolean(context, logExhaustedMessageHistory));\n        }\n        if (disableRedelivery != null) {\n            if (CamelContextHelper.parseBoolean(context, disableRedelivery)) {\n                answer.setMaximumRedeliveries(0);\n            }\n        }\n        if (delayPattern != null) {\n            answer.setDelayPattern(delayPattern);\n        }\n        if (allowRedeliveryWhileStopping != null) {\n            answer.setAllowRedeliveryWhileStopping(CamelContextHelper.parseBoolean(context, allowRedeliveryWhileStopping));\n        }\n        if (exchangeFormatterRef != null) {\n            answer.setExchangeFormatterRef(exchangeFormatterRef);\n        }\n    } catch (Exception e) {\n        throw ObjectHelper.wrapRuntimeCamelException(e);\n    }\n    return answer;\n}", "lc": 3.1363636363636362, "pi": -0.023923444976076683, "ma": 4.8, "nbd": 0.5, "ml": 3.8333333333333335, "d": 0.24404761904761899, "mi": -1.2692036645525013, "fo": 3.0, "r": -0.02631578947368421, "e": 1.6281576505708173}
{"project_name": "Math", "project_version": 31, "label": 1, "code": "/**\n * <p>\n * Evaluates the continued fraction at the value x.\n * </p>\n *\n * <p>\n * The implementation of this method is based on the modified Lentz algorithm as described\n * on page 18 ff. in:\n * <ul>\n * <li>\n *   I. J. Thompson,  A. R. Barnett. \"Coulomb and Bessel Functions of Complex Arguments and Order.\"\n *   <a target=\"_blank\" href=\"http://www.fresco.org.uk/papers/Thompson-JCP64p490.pdf\">\n *   http://www.fresco.org.uk/papers/Thompson-JCP64p490.pdf</a>\n * </li>\n * </ul>\n * Note: the implementation uses the terms a<sub>i</sub> and b<sub>i</sub> as defined in\n * <a href=\"http://mathworld.wolfram.com/ContinuedFraction.html\">Continued Fraction / MathWorld</a>.\n * </p>\n *\n * @param x the evaluation point.\n * @param epsilon maximum error allowed.\n * @param maxIterations maximum number of convergents\n * @return the value of the continued fraction evaluated at x.\n * @throws ConvergenceException if the algorithm fails to converge.\n */\npublic double evaluate(double x, double epsilon, int maxIterations) {\n    final double small = 1e-50;\n    double hPrev = getA(0, x);\n    // use the value of small as epsilon criteria for zero checks\n    if (Precision.equals(hPrev, 0.0, small)) {\n        hPrev = small;\n    }\n    int n = 1;\n    double dPrev = 0.0;\n    double p0 = 1.0;\n    double q1 = 1.0;\n    double cPrev = hPrev;\n    double hN = hPrev;\n    while (n < maxIterations) {\n        final double a = getA(n, x);\n        final double b = getB(n, x);\n        double cN = a * hPrev + b * p0;\n        double q2 = a * q1 + b * dPrev;\n        if (Double.isInfinite(cN) || Double.isInfinite(q2)) {\n            double scaleFactor = 1d;\n            double lastScaleFactor = 1d;\n            final int maxPower = 5;\n            final double scale = FastMath.max(a, b);\n            if (scale <= 0) {\n                // Can't scale\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n            }\n            for (int i = 0; i < maxPower; i++) {\n                lastScaleFactor = scaleFactor;\n                scaleFactor *= scale;\n                if (a != 0.0 && a > b) {\n                    cN = hPrev / lastScaleFactor + (b / scaleFactor * p0);\n                    q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev);\n                } else if (b != 0) {\n                    cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor;\n                    q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor;\n                }\n                if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) {\n                    break;\n                }\n            }\n        }\n        final double deltaN = cN / q2 / cPrev;\n        hN = cPrev * deltaN;\n        if (Double.isInfinite(hN)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n        }\n        if (Double.isNaN(hN)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, x);\n        }\n        if (FastMath.abs(deltaN - 1.0) < epsilon) {\n            break;\n        }\n        dPrev = q1;\n        cPrev = cN / q2;\n        p0 = hPrev;\n        hPrev = cN;\n        q1 = q2;\n        n++;\n    }\n    if (n >= maxIterations) {\n        throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION, maxIterations, x);\n    }\n    return hN;\n}", "code_comment": "/**\n * <p>\n * Evaluates the continued fraction at the value x.\n * </p>\n *\n * <p>\n * The implementation of this method is based on the modified Lentz algorithm as described\n * on page 18 ff. in:\n * <ul>\n * <li>\n *   I. J. Thompson,  A. R. Barnett. \"Coulomb and Bessel Functions of Complex Arguments and Order.\"\n *   <a target=\"_blank\" href=\"http://www.fresco.org.uk/papers/Thompson-JCP64p490.pdf\">\n *   http://www.fresco.org.uk/papers/Thompson-JCP64p490.pdf</a>\n * </li>\n * </ul>\n * Note: the implementation uses the terms a<sub>i</sub> and b<sub>i</sub> as defined in\n * <a href=\"http://mathworld.wolfram.com/ContinuedFraction.html\">Continued Fraction / MathWorld</a>.\n * </p>\n *\n * @param x the evaluation point.\n * @param epsilon maximum error allowed.\n * @param maxIterations maximum number of convergents\n * @return the value of the continued fraction evaluated at x.\n * @throws ConvergenceException if the algorithm fails to converge.\n */\n", "code_no_comment": "public double evaluate(double x, double epsilon, int maxIterations) {\n    final double small = 1e-50;\n    double hPrev = getA(0, x);\n        if (Precision.equals(hPrev, 0.0, small)) {\n        hPrev = small;\n    }\n    int n = 1;\n    double dPrev = 0.0;\n    double p0 = 1.0;\n    double q1 = 1.0;\n    double cPrev = hPrev;\n    double hN = hPrev;\n    while (n < maxIterations) {\n        final double a = getA(n, x);\n        final double b = getB(n, x);\n        double cN = a * hPrev + b * p0;\n        double q2 = a * q1 + b * dPrev;\n        if (Double.isInfinite(cN) || Double.isInfinite(q2)) {\n            double scaleFactor = 1d;\n            double lastScaleFactor = 1d;\n            final int maxPower = 5;\n            final double scale = FastMath.max(a, b);\n            if (scale <= 0) {\n                                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n            }\n            for (int i = 0; i < maxPower; i++) {\n                lastScaleFactor = scaleFactor;\n                scaleFactor *= scale;\n                if (a != 0.0 && a > b) {\n                    cN = hPrev / lastScaleFactor + (b / scaleFactor * p0);\n                    q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev);\n                } else if (b != 0) {\n                    cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor;\n                    q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor;\n                }\n                if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) {\n                    break;\n                }\n            }\n        }\n        final double deltaN = cN / q2 / cPrev;\n        hN = cPrev * deltaN;\n        if (Double.isInfinite(hN)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n        }\n        if (Double.isNaN(hN)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, x);\n        }\n        if (FastMath.abs(deltaN - 1.0) < epsilon) {\n            break;\n        }\n        dPrev = q1;\n        cPrev = cN / q2;\n        p0 = hPrev;\n        hPrev = cN;\n        q1 = q2;\n        n++;\n    }\n    if (n >= maxIterations) {\n        throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION, maxIterations, x);\n    }\n    return hN;\n}", "lc": 2.227272727272727, "pi": 1.0095693779904304, "ma": 3.0, "nbd": 1.5, "ml": 2.5, "d": 4.587301587301588, "mi": -1.0989429175475685, "fo": 0.5, "r": -0.02631578947368421, "e": 15.873116532102367}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-395_e6c31270", "label": 1, "code": "@Override\npublic Property perform() throws RepositoryException {\n    if (values == null) {\n        Property p = getProperty(jcrName);\n        p.remove();\n        return p;\n    } else {\n        String oakName = sessionDelegate.getOakPathOrThrow(jcrName);\n        PropertyDefinition definition;\n        if (hasProperty(jcrName)) {\n            definition = getProperty(jcrName).getDefinition();\n        } else {\n            definition = dlg.sessionDelegate.getDefinitionProvider().getDefinition(NodeImpl.this, oakName, true, type, exactTypeMatch);\n        }\n        checkProtected(definition);\n        if (!definition.isMultiple()) {\n            throw new ValueFormatException(\"Cannot set value array to single value property\");\n        }\n        int targetType = getTargetType(values, definition);\n        Value[] targetValues = ValueHelper.convert(values, targetType, getValueFactory());\n        Iterable<Value> nonNullValues = Iterables.filter(Arrays.asList(targetValues), Predicates.notNull());\n        return new PropertyImpl(dlg.setProperty(oakName, nonNullValues));\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic Property perform() throws RepositoryException {\n    if (values == null) {\n        Property p = getProperty(jcrName);\n        p.remove();\n        return p;\n    } else {\n        String oakName = sessionDelegate.getOakPathOrThrow(jcrName);\n        PropertyDefinition definition;\n        if (hasProperty(jcrName)) {\n            definition = getProperty(jcrName).getDefinition();\n        } else {\n            definition = dlg.sessionDelegate.getDefinitionProvider().getDefinition(NodeImpl.this, oakName, true, type, exactTypeMatch);\n        }\n        checkProtected(definition);\n        if (!definition.isMultiple()) {\n            throw new ValueFormatException(\"Cannot set value array to single value property\");\n        }\n        int targetType = getTargetType(values, definition);\n        Value[] targetValues = ValueHelper.convert(values, targetType, getValueFactory());\n        Iterable<Value> nonNullValues = Iterables.filter(Arrays.asList(targetValues), Predicates.notNull());\n        return new PropertyImpl(dlg.setProperty(oakName, nonNullValues));\n    }\n}", "lc": 0.45454545454545453, "pi": 0.1578947368421051, "ma": 0.2, "nbd": 0.0, "ml": 0.16666666666666666, "d": -0.06746031746031747, "mi": -0.39760394644115576, "fo": 0.9166666666666666, "r": -0.02631578947368421, "e": 0.1400690398390991}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5689_2ac29d30", "label": 3, "code": "protected BufferedWebResponse getAndRemoveBufferedResponse(Url url) {\n    return WebApplication.get().getAndRemoveBufferedResponse(getSessionId(), url);\n}", "code_comment": NaN, "code_no_comment": "protected BufferedWebResponse getAndRemoveBufferedResponse(Url url) {\n    return WebApplication.get().getAndRemoveBufferedResponse(getSessionId(), url);\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.9709654686398869, "fo": -0.25, "r": 0.39473684210526316, "e": -0.16279340490885932}
{"project_name": "Math", "project_version": 81, "label": 1, "code": "/**\n * Compute the shift increment as an estimate of the smallest eigenvalue.\n * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>\n * @param start start index\n * @param end end index\n * @param deflated number of realEigenvalues just deflated\n */\nprivate void computeShiftIncrement(final int start, final int end, final int deflated) {\n    final double cnst1 = 0.563;\n    final double cnst2 = 1.010;\n    final double cnst3 = 1.05;\n    // tType records the type of shift.\n    if (dMin <= 0.0) {\n        tau = -dMin;\n        tType = -1;\n        return;\n    }\n    int nn = 4 * end + pingPong - 1;\n    switch(deflated) {\n        case // no realEigenvalues deflated.\n        0:\n            if (dMin == dN || dMin == dN1) {\n                double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]);\n                double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]);\n                double a2 = work[nn - 7] + work[nn - 5];\n                if (dMin == dN && dMin1 == dN1) {\n                    // cases 2 and 3.\n                    final double gap2 = dMin2 - a2 - dMin2 * 0.25;\n                    final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2));\n                    if (gap1 > 0.0 && gap1 > b1) {\n                        tau = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin);\n                        tType = -2;\n                    } else {\n                        double s = 0.0;\n                        if (dN > b1) {\n                            s = dN - b1;\n                        }\n                        if (a2 > (b1 + b2)) {\n                            s = Math.min(s, a2 - (b1 + b2));\n                        }\n                        tau = Math.max(s, 0.333 * dMin);\n                        tType = -3;\n                    }\n                } else {\n                    // case 4.\n                    tType = -4;\n                    double s = 0.25 * dMin;\n                    double gam;\n                    int np;\n                    if (dMin == dN) {\n                        gam = dN;\n                        a2 = 0.0;\n                        if (work[nn - 5] > work[nn - 7]) {\n                            return;\n                        }\n                        b2 = work[nn - 5] / work[nn - 7];\n                        np = nn - 9;\n                    } else {\n                        np = nn - 2 * pingPong;\n                        b2 = work[np - 2];\n                        gam = dN1;\n                        if (work[np - 4] > work[np - 2]) {\n                            return;\n                        }\n                        a2 = work[np - 4] / work[np - 2];\n                        if (work[nn - 9] > work[nn - 11]) {\n                            return;\n                        }\n                        b2 = work[nn - 9] / work[nn - 11];\n                        np = nn - 13;\n                    }\n                    // approximate contribution to norm squared from i < nn-1.\n                    a2 = a2 + b2;\n                    for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (b2 == 0.0) {\n                            break;\n                        }\n                        b1 = b2;\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b2 = b2 * (work[i4] / work[i4 - 2]);\n                        a2 = a2 + b2;\n                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {\n                            break;\n                        }\n                    }\n                    a2 = cnst3 * a2;\n                    // rayleigh quotient residual bound.\n                    if (a2 < cnst1) {\n                        s = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                    }\n                    tau = s;\n                }\n            } else if (dMin == dN2) {\n                // case 5.\n                tType = -5;\n                double s = 0.25 * dMin;\n                // compute contribution to norm squared from i > nn-2.\n                final int np = nn - 2 * pingPong;\n                double b1 = work[np - 2];\n                double b2 = work[np - 6];\n                final double gam = dN2;\n                if (work[np - 8] > b2 || work[np - 4] > b1) {\n                    return;\n                }\n                double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n                // approximate contribution to norm squared from i < nn-2.\n                if (end - start > 2) {\n                    b2 = work[nn - 13] / work[nn - 15];\n                    a2 = a2 + b2;\n                    for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (b2 == 0.0) {\n                            break;\n                        }\n                        b1 = b2;\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b2 = b2 * (work[i4] / work[i4 - 2]);\n                        a2 = a2 + b2;\n                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {\n                            break;\n                        }\n                    }\n                    a2 = cnst3 * a2;\n                }\n                if (a2 < cnst1) {\n                    tau = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                } else {\n                    tau = s;\n                }\n            } else {\n                // case 6, no information to guide us.\n                if (tType == -6) {\n                    g += 0.333 * (1 - g);\n                } else if (tType == -18) {\n                    g = 0.25 * 0.333;\n                } else {\n                    g = 0.25;\n                }\n                tau = g * dMin;\n                tType = -6;\n            }\n            break;\n        case // one eigenvalue just deflated. use dMin1, dN1 for dMin and dN.\n        1:\n            if (dMin1 == dN1 && dMin2 == dN2) {\n                // cases 7 and 8.\n                tType = -7;\n                double s = 0.333 * dMin1;\n                if (work[nn - 5] > work[nn - 7]) {\n                    return;\n                }\n                double b1 = work[nn - 5] / work[nn - 7];\n                double b2 = b1;\n                if (b2 != 0.0) {\n                    for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        final double oldB1 = b1;\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b1 = b1 * (work[i4] / work[i4 - 2]);\n                        b2 = b2 + b1;\n                        if (100 * Math.max(b1, oldB1) < b2) {\n                            break;\n                        }\n                    }\n                }\n                b2 = Math.sqrt(cnst3 * b2);\n                final double a2 = dMin1 / (1 + b2 * b2);\n                final double gap2 = 0.5 * dMin2 - a2;\n                if (gap2 > 0.0 && gap2 > b2 * a2) {\n                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n                } else {\n                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n                    tType = -8;\n                }\n            } else {\n                // case 9.\n                tau = 0.25 * dMin1;\n                if (dMin1 == dN1) {\n                    tau = 0.5 * dMin1;\n                }\n                tType = -9;\n            }\n            break;\n        case // two realEigenvalues deflated. use dMin2, dN2 for dMin and dN.\n        2:\n            // cases 10 and 11.\n            if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) {\n                tType = -10;\n                final double s = 0.333 * dMin2;\n                if (work[nn - 5] > work[nn - 7]) {\n                    return;\n                }\n                double b1 = work[nn - 5] / work[nn - 7];\n                double b2 = b1;\n                if (b2 != 0.0) {\n                    for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b1 *= work[i4] / work[i4 - 2];\n                        b2 += b1;\n                        if (100 * b1 < b2) {\n                            break;\n                        }\n                    }\n                }\n                b2 = Math.sqrt(cnst3 * b2);\n                final double a2 = dMin2 / (1 + b2 * b2);\n                final double gap2 = work[nn - 7] + work[nn - 9] - Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2;\n                if (gap2 > 0.0 && gap2 > b2 * a2) {\n                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n                } else {\n                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n                }\n            } else {\n                tau = 0.25 * dMin2;\n                tType = -11;\n            }\n            break;\n        default:\n            // case 12, more than two realEigenvalues deflated. no information.\n            tau = 0.0;\n            tType = -12;\n    }\n}", "code_comment": "/**\n * Compute the shift increment as an estimate of the smallest eigenvalue.\n * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>\n * @param start start index\n * @param end end index\n * @param deflated number of realEigenvalues just deflated\n */\n", "code_no_comment": "private void computeShiftIncrement(final int start, final int end, final int deflated) {\n    final double cnst1 = 0.563;\n    final double cnst2 = 1.010;\n    final double cnst3 = 1.05;\n        if (dMin <= 0.0) {\n        tau = -dMin;\n        tType = -1;\n        return;\n    }\n    int nn = 4 * end + pingPong - 1;\n    switch(deflated) {\n        case         0:\n            if (dMin == dN || dMin == dN1) {\n                double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]);\n                double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]);\n                double a2 = work[nn - 7] + work[nn - 5];\n                if (dMin == dN && dMin1 == dN1) {\n                                        final double gap2 = dMin2 - a2 - dMin2 * 0.25;\n                    final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2));\n                    if (gap1 > 0.0 && gap1 > b1) {\n                        tau = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin);\n                        tType = -2;\n                    } else {\n                        double s = 0.0;\n                        if (dN > b1) {\n                            s = dN - b1;\n                        }\n                        if (a2 > (b1 + b2)) {\n                            s = Math.min(s, a2 - (b1 + b2));\n                        }\n                        tau = Math.max(s, 0.333 * dMin);\n                        tType = -3;\n                    }\n                } else {\n                                        tType = -4;\n                    double s = 0.25 * dMin;\n                    double gam;\n                    int np;\n                    if (dMin == dN) {\n                        gam = dN;\n                        a2 = 0.0;\n                        if (work[nn - 5] > work[nn - 7]) {\n                            return;\n                        }\n                        b2 = work[nn - 5] / work[nn - 7];\n                        np = nn - 9;\n                    } else {\n                        np = nn - 2 * pingPong;\n                        b2 = work[np - 2];\n                        gam = dN1;\n                        if (work[np - 4] > work[np - 2]) {\n                            return;\n                        }\n                        a2 = work[np - 4] / work[np - 2];\n                        if (work[nn - 9] > work[nn - 11]) {\n                            return;\n                        }\n                        b2 = work[nn - 9] / work[nn - 11];\n                        np = nn - 13;\n                    }\n                                        a2 = a2 + b2;\n                    for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (b2 == 0.0) {\n                            break;\n                        }\n                        b1 = b2;\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b2 = b2 * (work[i4] / work[i4 - 2]);\n                        a2 = a2 + b2;\n                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {\n                            break;\n                        }\n                    }\n                    a2 = cnst3 * a2;\n                                        if (a2 < cnst1) {\n                        s = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                    }\n                    tau = s;\n                }\n            } else if (dMin == dN2) {\n                                tType = -5;\n                double s = 0.25 * dMin;\n                                final int np = nn - 2 * pingPong;\n                double b1 = work[np - 2];\n                double b2 = work[np - 6];\n                final double gam = dN2;\n                if (work[np - 8] > b2 || work[np - 4] > b1) {\n                    return;\n                }\n                double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n                                if (end - start > 2) {\n                    b2 = work[nn - 13] / work[nn - 15];\n                    a2 = a2 + b2;\n                    for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (b2 == 0.0) {\n                            break;\n                        }\n                        b1 = b2;\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b2 = b2 * (work[i4] / work[i4 - 2]);\n                        a2 = a2 + b2;\n                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {\n                            break;\n                        }\n                    }\n                    a2 = cnst3 * a2;\n                }\n                if (a2 < cnst1) {\n                    tau = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                } else {\n                    tau = s;\n                }\n            } else {\n                                if (tType == -6) {\n                    g += 0.333 * (1 - g);\n                } else if (tType == -18) {\n                    g = 0.25 * 0.333;\n                } else {\n                    g = 0.25;\n                }\n                tau = g * dMin;\n                tType = -6;\n            }\n            break;\n        case         1:\n            if (dMin1 == dN1 && dMin2 == dN2) {\n                                tType = -7;\n                double s = 0.333 * dMin1;\n                if (work[nn - 5] > work[nn - 7]) {\n                    return;\n                }\n                double b1 = work[nn - 5] / work[nn - 7];\n                double b2 = b1;\n                if (b2 != 0.0) {\n                    for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        final double oldB1 = b1;\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b1 = b1 * (work[i4] / work[i4 - 2]);\n                        b2 = b2 + b1;\n                        if (100 * Math.max(b1, oldB1) < b2) {\n                            break;\n                        }\n                    }\n                }\n                b2 = Math.sqrt(cnst3 * b2);\n                final double a2 = dMin1 / (1 + b2 * b2);\n                final double gap2 = 0.5 * dMin2 - a2;\n                if (gap2 > 0.0 && gap2 > b2 * a2) {\n                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n                } else {\n                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n                    tType = -8;\n                }\n            } else {\n                                tau = 0.25 * dMin1;\n                if (dMin1 == dN1) {\n                    tau = 0.5 * dMin1;\n                }\n                tType = -9;\n            }\n            break;\n        case         2:\n                        if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) {\n                tType = -10;\n                final double s = 0.333 * dMin2;\n                if (work[nn - 5] > work[nn - 7]) {\n                    return;\n                }\n                double b1 = work[nn - 5] / work[nn - 7];\n                double b2 = b1;\n                if (b2 != 0.0) {\n                    for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b1 *= work[i4] / work[i4 - 2];\n                        b2 += b1;\n                        if (100 * b1 < b2) {\n                            break;\n                        }\n                    }\n                }\n                b2 = Math.sqrt(cnst3 * b2);\n                final double a2 = dMin2 / (1 + b2 * b2);\n                final double gap2 = work[nn - 7] + work[nn - 9] - Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2;\n                if (gap2 > 0.0 && gap2 > b2 * a2) {\n                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n                } else {\n                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n                }\n            } else {\n                tau = 0.25 * dMin2;\n                tType = -11;\n            }\n            break;\n        default:\n                        tau = 0.0;\n            tType = -12;\n    }\n}", "lc": 8.863636363636363, "pi": 1.464114832535885, "ma": 10.2, "nbd": 2.5, "ml": 5.916666666666667, "d": 15.642857142857144, "mi": -2.0906272022551087, "fo": 1.1666666666666667, "r": -0.02631578947368421, "e": 218.31397336376153}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-3448_b345dd82", "label": 0, "code": "@Override\npublic boolean equals(Object o) {\n    if (this == o) {\n        return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n        return false;\n    }\n    ExceptionPolicyKey that = (ExceptionPolicyKey) o;\n    if (!exceptionClass.equals(that.exceptionClass)) {\n        return false;\n    }\n    if (when != null ? !when.equals(that.when) : that.when != null) {\n        return false;\n    }\n    return true;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean equals(Object o) {\n    if (this == o) {\n        return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n        return false;\n    }\n    ExceptionPolicyKey that = (ExceptionPolicyKey) o;\n    if (!exceptionClass.equals(that.exceptionClass)) {\n        return false;\n    }\n    if (when != null ? !when.equals(that.when) : that.when != null) {\n        return false;\n    }\n    return true;\n}", "lc": 0.13636363636363635, "pi": -0.20574162679425848, "ma": 0.4, "nbd": -0.5, "ml": 0.5833333333333334, "d": 0.6428571428571429, "mi": -0.11233262861169833, "fo": -0.16666666666666666, "r": 0.5526315789473684, "e": 0.2471395722757213}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-2882_ebe56869", "label": 1, "code": "/**\n *  @see org.apache.wicket.application.IComponentOnBeforeRenderListener#onBeforeRender(org.apache.wicket.Component)\n */\npublic void onAfterRender(final Component component) {\n    if (log.isWarnEnabled()) {\n        if ((component instanceof FormComponent) || (component instanceof IFormSubmittingComponent) || (component instanceof Form)) {\n            log.warn(\"Please note that onBeforeRender() and validate() might be called on invisible components inside an Enclosure. \" + \"Please see EnclosureContainer for an alternative. Enclosure: \" + enclosure.toString());\n        }\n    }\n}", "code_comment": "/**\n *  @see org.apache.wicket.application.IComponentOnBeforeRenderListener#onBeforeRender(org.apache.wicket.Component)\n */\n", "code_no_comment": "public void onAfterRender(final Component component) {\n    if (log.isWarnEnabled()) {\n        if ((component instanceof FormComponent) || (component instanceof IFormSubmittingComponent) || (component instanceof Form)) {\n            log.warn(\"Please note that onBeforeRender() and validate() might be called on invisible components inside an Enclosure. \" + \"Please see EnclosureContainer for an alternative. Enclosure: \" + enclosure.toString());\n        }\n    }\n}", "lc": -0.3181818181818182, "pi": 0.5406698564593301, "ma": -0.2, "nbd": 0.0, "ml": 0.08333333333333333, "d": -0.10912698412698414, "mi": 0.42720225510923177, "fo": -0.25, "r": 0.05263157894736841, "e": -0.11537144931795783}
{"project_name": "Time", "project_version": 26, "label": 2, "code": "public long addWrapField(long instant, int value) {\n    if (iTimeField) {\n        int offset = getOffsetToAdd(instant);\n        long localInstant = iField.addWrapField(instant + offset, value);\n        return localInstant - offset;\n    } else {\n        long localInstant = iZone.convertUTCToLocal(instant);\n        localInstant = iField.addWrapField(localInstant, value);\n        return iZone.convertLocalToUTC(localInstant, false);\n    }\n}", "code_comment": NaN, "code_no_comment": "public long addWrapField(long instant, int value) {\n    if (iTimeField) {\n        int offset = getOffsetToAdd(instant);\n        long localInstant = iField.addWrapField(instant + offset, value);\n        return localInstant - offset;\n    } else {\n        long localInstant = iZone.convertUTCToLocal(instant);\n        localInstant = iField.addWrapField(localInstant, value);\n        return iZone.convertLocalToUTC(localInstant, false);\n    }\n}", "lc": -0.13636363636363635, "pi": 0.04784688995215294, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": 0.07738095238095236, "mi": 0.14531360112755462, "fo": -0.08333333333333333, "r": 0.02631578947368421, "e": -0.018807881375955928}
{"project_name": "maven", "project_version": "remotes/origin/bugs-dot-jar_MNG-1999_ad38e46b", "label": 1, "code": "private void assembleReportingInheritance(Model child, Model parent) {\n    // Reports :: aggregate\n    Reporting childReporting = child.getReporting();\n    Reporting parentReporting = parent.getReporting();\n    if (parentReporting != null) {\n        if (childReporting == null) {\n            childReporting = new Reporting();\n            child.setReporting(childReporting);\n        }\n        if (StringUtils.isEmpty(childReporting.getOutputDirectory())) {\n            childReporting.setOutputDirectory(parentReporting.getOutputDirectory());\n        }\n        ModelUtils.mergeReportPluginLists(childReporting, parentReporting, true);\n    }\n}", "code_comment": NaN, "code_no_comment": "private void assembleReportingInheritance(Model child, Model parent) {\n        Reporting childReporting = child.getReporting();\n    Reporting parentReporting = parent.getReporting();\n    if (parentReporting != null) {\n        if (childReporting == null) {\n            childReporting = new Reporting();\n            child.setReporting(childReporting);\n        }\n        if (StringUtils.isEmpty(childReporting.getOutputDirectory())) {\n            childReporting.setOutputDirectory(parentReporting.getOutputDirectory());\n        }\n        ModelUtils.mergeReportPluginLists(childReporting, parentReporting, true);\n    }\n}", "lc": 0.0, "pi": 0.43062200956937796, "ma": 0.0, "nbd": 0.0, "ml": 0.16666666666666666, "d": 0.03174603174603173, "mi": -0.014799154334038212, "fo": 0.16666666666666666, "r": 0.0, "e": 0.003257205096730691}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-531_90c45a02", "label": 1, "code": "@Nonnull\nprivate NodeState read() {\n    if (revision != root.revision) {\n        // root never gets here since revision == root.revision\n        assert (!isRoot());\n        checkState(!parent.removed(name), \"This node has already been removed\");\n        parent.read();\n        // The builder could have been reset, need to re-get base state\n        baseState = parent.getBaseState(name);\n        // ... same for the write state\n        writeState = parent.getWriteState(name);\n        revision = root.revision;\n    }\n    assert classInvariants();\n    if (writeState != null) {\n        return writeState;\n    } else {\n        return baseState;\n    }\n}", "code_comment": NaN, "code_no_comment": "@Nonnull\nprivate NodeState read() {\n    if (revision != root.revision) {\n                assert (!isRoot());\n        checkState(!parent.removed(name), \"This node has already been removed\");\n        parent.read();\n                baseState = parent.getBaseState(name);\n                writeState = parent.getWriteState(name);\n        revision = root.revision;\n    }\n    assert classInvariants();\n    if (writeState != null) {\n        return writeState;\n    } else {\n        return baseState;\n    }\n}", "lc": 0.13636363636363635, "pi": 0.0, "ma": -0.2, "nbd": -0.5, "ml": 0.0, "d": -0.3650793650793651, "mi": 0.35954897815362913, "fo": 0.08333333333333333, "r": 0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-1008_0c20bfd8", "label": 1, "code": "/**\n * Will be called repeatedly with candidate classes. Must return True if a class\n * is to be included in the results, false otherwise.\n * @param type The Class to match against.\n * @return true if the Class matches.\n */\nboolean matches(Class<?> type);", "code_comment": "/**\n * Will be called repeatedly with candidate classes. Must return True if a class\n * is to be included in the results, false otherwise.\n * @param type The Class to match against.\n * @return true if the Class matches.\n */\n", "code_no_comment": "boolean matches(Class<?> type);", "lc": -0.5909090909090909, "pi": -1.4306220095693782, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.6663847780126848, "fo": -0.5, "r": 2.5789473684210527, "e": -0.16279340490885932}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-373_bfe4623c", "label": 1, "code": "/**\n * The sum of the entries in the specified portion of\n * the input array, or <code>Double.NaN</code> if the designated subarray\n * is empty.\n * <p>\n * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n *\n * @param values the input array\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return the sum of the values or Double.NaN if length = 0\n * @throws IllegalArgumentException if the array is null or the array index\n *  parameters are not valid\n */\n@Override\npublic double evaluate(final double[] values, final int begin, final int length) {\n    double sum = Double.NaN;\n    if (test(values, begin, length)) {\n        sum = 0.0;\n        for (int i = begin; i < begin + length; i++) {\n            sum += values[i];\n        }\n    }\n    return sum;\n}", "code_comment": "/**\n * The sum of the entries in the specified portion of\n * the input array, or <code>Double.NaN</code> if the designated subarray\n * is empty.\n * <p>\n * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n *\n * @param values the input array\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return the sum of the values or Double.NaN if length = 0\n * @throws IllegalArgumentException if the array is null or the array index\n *  parameters are not valid\n */\n", "code_no_comment": "@Override\npublic double evaluate(final double[] values, final int begin, final int length) {\n    double sum = Double.NaN;\n    if (test(values, begin, length)) {\n        sum = 0.0;\n        for (int i = begin; i < begin + length; i++) {\n            sum += values[i];\n        }\n    }\n    return sum;\n}", "lc": -0.13636363636363635, "pi": 0.35885167464114837, "ma": -0.2, "nbd": 0.0, "ml": 0.16666666666666666, "d": 0.4623015873015873, "mi": 0.14869626497533486, "fo": -0.4166666666666667, "r": 0.0, "e": 0.08847011635345169}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-1145_22c370d9", "label": 1, "code": "/**\n *  Checks if the given field is a valid pojo field:\n *  - it is public\n *  OR\n *   - there are getter and setter methods for the field.\n *\n *  @param f field to check\n *  @param clazz class of field\n *  @param typeHierarchy type hierarchy for materializing generic types\n *  @return\n */\nprivate boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy) {\n    if (Modifier.isPublic(f.getModifiers())) {\n        return true;\n    } else {\n        boolean hasGetter = false, hasSetter = false;\n        final String fieldNameLow = f.getName().toLowerCase();\n        Type fieldType = f.getGenericType();\n        TypeVariable<?> fieldTypeGeneric = null;\n        if (fieldType instanceof TypeVariable) {\n            fieldTypeGeneric = (TypeVariable<?>) fieldType;\n            fieldType = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) fieldType);\n        }\n        for (Method m : clazz.getMethods()) {\n            if (// The name should be \"get<FieldName>\" or \"<fieldName>\" (for scala).\n            (m.getName().toLowerCase().equals(\"get\" + fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow)) && // no arguments for the getter\n            m.getParameterTypes().length == 0 && // return type is same as field type (or the generic variant of it)\n            m.getReturnType().equals(fieldType) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric))) {\n                if (hasGetter) {\n                    throw new IllegalStateException(\"Detected more than one getters\");\n                }\n                hasGetter = true;\n            }\n            // check for setters (<FieldName>_$eq for scala)\n            if ((m.getName().toLowerCase().equals(\"set\" + fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow + \"_$eq\")) && // one parameter of the field's type\n            m.getParameterTypes().length == 1 && (m.getParameterTypes()[0].equals(fieldType) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric))) && // return type is void.\n            m.getReturnType().equals(Void.TYPE)) {\n                if (hasSetter) {\n                    throw new IllegalStateException(\"Detected more than one getters\");\n                }\n                hasSetter = true;\n            }\n        }\n        if (hasGetter && hasSetter) {\n            return true;\n        } else {\n            if (!hasGetter) {\n                LOG.warn(\"Class \" + clazz + \" does not contain a getter for field \" + f.getName());\n            }\n            if (!hasSetter) {\n                LOG.warn(\"Class \" + clazz + \" does not contain a setter for field \" + f.getName());\n            }\n            return false;\n        }\n    }\n}", "code_comment": "/**\n *  Checks if the given field is a valid pojo field:\n *  - it is public\n *  OR\n *   - there are getter and setter methods for the field.\n *\n *  @param f field to check\n *  @param clazz class of field\n *  @param typeHierarchy type hierarchy for materializing generic types\n *  @return\n */\n", "code_no_comment": "private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy) {\n    if (Modifier.isPublic(f.getModifiers())) {\n        return true;\n    } else {\n        boolean hasGetter = false, hasSetter = false;\n        final String fieldNameLow = f.getName().toLowerCase();\n        Type fieldType = f.getGenericType();\n        TypeVariable<?> fieldTypeGeneric = null;\n        if (fieldType instanceof TypeVariable) {\n            fieldTypeGeneric = (TypeVariable<?>) fieldType;\n            fieldType = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) fieldType);\n        }\n        for (Method m : clazz.getMethods()) {\n            if (            (m.getName().toLowerCase().equals(\"get\" + fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow)) &&             m.getParameterTypes().length == 0 &&             m.getReturnType().equals(fieldType) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric))) {\n                if (hasGetter) {\n                    throw new IllegalStateException(\"Detected more than one getters\");\n                }\n                hasGetter = true;\n            }\n                        if ((m.getName().toLowerCase().equals(\"set\" + fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow + \"_$eq\")) &&             m.getParameterTypes().length == 1 && (m.getParameterTypes()[0].equals(fieldType) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric))) &&             m.getReturnType().equals(Void.TYPE)) {\n                if (hasSetter) {\n                    throw new IllegalStateException(\"Detected more than one getters\");\n                }\n                hasSetter = true;\n            }\n        }\n        if (hasGetter && hasSetter) {\n            return true;\n        } else {\n            if (!hasGetter) {\n                LOG.warn(\"Class \" + clazz + \" does not contain a getter for field \" + f.getName());\n            }\n            if (!hasSetter) {\n                LOG.warn(\"Class \" + clazz + \" does not contain a setter for field \" + f.getName());\n            }\n            return false;\n        }\n    }\n}", "lc": 1.3636363636363635, "pi": 0.7033492822966506, "ma": 1.8, "nbd": 1.0, "ml": 2.75, "d": 1.2380952380952381, "mi": -0.8401691331923886, "fo": 2.4166666666666665, "r": -0.02631578947368421, "e": 3.38578516968932}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1932_913c2f53", "label": 1, "code": "public void compact() {\n    long start = System.nanoTime();\n    log.info(\"TarMK compaction started\");\n    SegmentWriter writer = new SegmentWriter(this, tracker);\n    Compactor compactor = new Compactor(writer);\n    SegmentNodeState before = getHead();\n    SegmentNodeState after = compactor.compact(EMPTY_NODE, before);\n    while (!setHead(before, after)) {\n        // Some other concurrent changes have been made.\n        // Rebase (and compact) those changes on top of the\n        // compacted state before retrying to set the head.\n        SegmentNodeState head = getHead();\n        after = compactor.compact(before, head);\n        before = head;\n    }\n    tracker.setCompactionMap(compactor.getCompactionMap());\n    log.info(\"TarMK compaction completed in {}ms\", MILLISECONDS.convert(System.nanoTime() - start, NANOSECONDS));\n    cleanupNeeded.set(true);\n}", "code_comment": NaN, "code_no_comment": "public void compact() {\n    long start = System.nanoTime();\n    log.info(\"TarMK compaction started\");\n    SegmentWriter writer = new SegmentWriter(this, tracker);\n    Compactor compactor = new Compactor(writer);\n    SegmentNodeState before = getHead();\n    SegmentNodeState after = compactor.compact(EMPTY_NODE, before);\n    while (!setHead(before, after)) {\n                                SegmentNodeState head = getHead();\n        after = compactor.compact(before, head);\n        before = head;\n    }\n    tracker.setCompactionMap(compactor.getCompactionMap());\n    log.info(\"TarMK compaction completed in {}ms\", MILLISECONDS.convert(System.nanoTime() - start, NANOSECONDS));\n    cleanupNeeded.set(true);\n}", "lc": 0.09090909090909091, "pi": -0.368421052631579, "ma": -0.4, "nbd": -0.5, "ml": -0.08333333333333333, "d": 0.0039682539682539715, "mi": -0.14700493305144474, "fo": 0.5833333333333334, "r": -0.02631578947368421, "e": 0.11191830477804093}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-6687_617eab1c", "label": 1, "code": "protected Expression createParametersExpression() {\n    final int size = parameters.size();\n    LOG.trace(\"Creating parameters expression for {} parameters\", size);\n    final Expression[] expressions = new Expression[size];\n    for (int i = 0; i < size; i++) {\n        Expression parameterExpression = parameters.get(i).getExpression();\n        expressions[i] = parameterExpression;\n        LOG.trace(\"Parameter #{} has expression: {}\", i, parameterExpression);\n    }\n    return new Expression() {\n\n        @SuppressWarnings(\"unchecked\")\n        public <T> T evaluate(Exchange exchange, Class<T> type) {\n            Object[] answer = new Object[size];\n            Object body = exchange.getIn().getBody();\n            boolean multiParameterArray = false;\n            if (exchange.getIn().getHeader(Exchange.BEAN_MULTI_PARAMETER_ARRAY) != null) {\n                multiParameterArray = exchange.getIn().getHeader(Exchange.BEAN_MULTI_PARAMETER_ARRAY, Boolean.class);\n            }\n            // if there was an explicit method name to invoke, then we should support using\n            // any provided parameter values in the method name\n            String methodName = exchange.getIn().getHeader(Exchange.BEAN_METHOD_NAME, \"\", String.class);\n            // the parameter values is between the parenthesis\n            String methodParameters = ObjectHelper.between(methodName, \"(\", \")\");\n            // use an iterator to walk the parameter values\n            Iterator<?> it = null;\n            if (methodParameters != null) {\n                // split the parameters safely separated by comma, but beware that we can have\n                // quoted parameters which contains comma as well, so do a safe quote split\n                String[] parameters = StringQuoteHelper.splitSafeQuote(methodParameters, ',', true);\n                it = ObjectHelper.createIterator(parameters, \",\", true);\n            }\n            // remove headers as they should not be propagated\n            // we need to do this before the expressions gets evaluated as it may contain\n            // a @Bean expression which would by mistake read these headers. So the headers\n            // must be removed at this point of time\n            exchange.getIn().removeHeader(Exchange.BEAN_MULTI_PARAMETER_ARRAY);\n            exchange.getIn().removeHeader(Exchange.BEAN_METHOD_NAME);\n            for (int i = 0; i < size; i++) {\n                // grab the parameter value for the given index\n                Object parameterValue = it != null && it.hasNext() ? it.next() : null;\n                // and the expected parameter type\n                Class<?> parameterType = parameters.get(i).getType();\n                // the value for the parameter to use\n                Object value = null;\n                if (multiParameterArray) {\n                    // get the value from the array\n                    value = ((Object[]) body)[i];\n                } else {\n                    // we should skip * as its a type placeholder to indicate any type\n                    if (parameterValue != null && !parameterValue.equals(\"*\")) {\n                        // evaluate the parameter value binding\n                        value = evaluateParameterValue(exchange, i, parameterValue, parameterType);\n                    }\n                    // use bean parameter binding, if still no value\n                    Expression expression = expressions[i];\n                    if (value == null && expression != null) {\n                        value = evaluateParameterBinding(exchange, expression, i, parameterType);\n                    }\n                }\n                // remember the value to use\n                if (value != Void.TYPE) {\n                    answer[i] = value;\n                }\n            }\n            return (T) answer;\n        }\n\n        /**\n         * Evaluate using parameter values where the values can be provided in the method name syntax.\n         * <p/>\n         * This methods returns accordingly:\n         * <ul>\n         *     <li><tt>null</tt> - if not a parameter value</li>\n         *     <li><tt>Void.TYPE</tt> - if an explicit null, forcing Camel to pass in <tt>null</tt> for that given parameter</li>\n         *     <li>a non <tt>null</tt> value - if the parameter was a parameter value, and to be used</li>\n         * </ul>\n         *\n         * @since 2.9\n         */\n        private Object evaluateParameterValue(Exchange exchange, int index, Object parameterValue, Class<?> parameterType) {\n            Object answer = null;\n            // convert the parameter value to a String\n            String exp = exchange.getContext().getTypeConverter().convertTo(String.class, exchange, parameterValue);\n            if (exp != null) {\n                // check if its a valid parameter value\n                boolean valid = BeanHelper.isValidParameterValue(exp);\n                if (!valid) {\n                    // it may be a parameter type instead, and if so, then we should return null,\n                    // as this method is only for evaluating parameter values\n                    Boolean isClass = BeanHelper.isAssignableToExpectedType(exchange.getContext().getClassResolver(), exp, parameterType);\n                    // the method will return a non null value if exp is a class\n                    if (isClass != null) {\n                        return null;\n                    }\n                }\n                // use simple language to evaluate the expression, as it may use the simple language to refer to message body, headers etc.\n                Expression expression = null;\n                try {\n                    expression = exchange.getContext().resolveLanguage(\"simple\").createExpression(exp);\n                    parameterValue = expression.evaluate(exchange, Object.class);\n                } catch (Exception e) {\n                    throw new ExpressionEvaluationException(expression, \"Cannot create/evaluate simple expression: \" + exp + \" to be bound to parameter at index: \" + index + \" on method: \" + getMethod(), exchange, e);\n                }\n                if (parameterValue != null) {\n                    // see method javadoc for details\n                    if (\"null\".equals(parameterValue)) {\n                        return Void.TYPE;\n                    }\n                    // the parameter value was not already valid, but since the simple language have evaluated the expression\n                    // which may change the parameterValue, so we have to check it again to see if its now valid\n                    exp = exchange.getContext().getTypeConverter().convertTo(String.class, parameterValue);\n                    // String values from the simple language is always valid\n                    if (!valid) {\n                        // re validate if the parameter was not valid the first time (String values should be accepted)\n                        valid = parameterValue instanceof String || BeanHelper.isValidParameterValue(exp);\n                    }\n                    if (valid) {\n                        // we need to unquote String parameters, as the enclosing quotes is there to denote a parameter value\n                        if (parameterValue instanceof String) {\n                            parameterValue = StringHelper.removeLeadingAndEndingQuotes((String) parameterValue);\n                        }\n                        if (parameterValue != null) {\n                            try {\n                                // its a valid parameter value, so convert it to the expected type of the parameter\n                                answer = exchange.getContext().getTypeConverter().mandatoryConvertTo(parameterType, exchange, parameterValue);\n                                if (LOG.isTraceEnabled()) {\n                                    LOG.trace(\"Parameter #{} evaluated as: {} type: \", new Object[] { index, answer, ObjectHelper.type(answer) });\n                                }\n                            } catch (Exception e) {\n                                if (LOG.isDebugEnabled()) {\n                                    LOG.debug(\"Cannot convert from type: {} to type: {} for parameter #{}\", new Object[] { ObjectHelper.type(parameterValue), parameterType, index });\n                                }\n                                throw new ParameterBindingException(e, method, index, parameterType, parameterValue);\n                            }\n                        }\n                    }\n                }\n            }\n            return answer;\n        }\n\n        /**\n         * Evaluate using classic parameter binding using the pre compute expression\n         */\n        private Object evaluateParameterBinding(Exchange exchange, Expression expression, int index, Class<?> parameterType) {\n            Object answer = null;\n            // use object first to avoid type conversion so we know if there is a value or not\n            Object result = expression.evaluate(exchange, Object.class);\n            if (result != null) {\n                // we got a value now try to convert it to the expected type\n                try {\n                    answer = exchange.getContext().getTypeConverter().mandatoryConvertTo(parameterType, result);\n                    if (LOG.isTraceEnabled()) {\n                        LOG.trace(\"Parameter #{} evaluated as: {} type: \", new Object[] { index, answer, ObjectHelper.type(answer) });\n                    }\n                } catch (NoTypeConversionAvailableException e) {\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Cannot convert from type: {} to type: {} for parameter #{}\", new Object[] { ObjectHelper.type(result), parameterType, index });\n                    }\n                    throw new ParameterBindingException(e, method, index, parameterType, result);\n                }\n            } else {\n                LOG.trace(\"Parameter #{} evaluated as null\", index);\n            }\n            return answer;\n        }\n\n        @Override\n        public String toString() {\n            return \"ParametersExpression: \" + Arrays.asList(expressions);\n        }\n    };\n}", "code_comment": "/**\n * Evaluate using parameter values where the values can be provided in the method name syntax.\n * <p/>\n * This methods returns accordingly:\n * <ul>\n *     <li><tt>null</tt> - if not a parameter value</li>\n *     <li><tt>Void.TYPE</tt> - if an explicit null, forcing Camel to pass in <tt>null</tt> for that given parameter</li>\n *     <li>a non <tt>null</tt> value - if the parameter was a parameter value, and to be used</li>\n * </ul>\n *\n * @since 2.9\n */\n/**\n * Evaluate using classic parameter binding using the pre compute expression\n */\n", "code_no_comment": "protected Expression createParametersExpression() {\n    final int size = parameters.size();\n    LOG.trace(\"Creating parameters expression for {} parameters\", size);\n    final Expression[] expressions = new Expression[size];\n    for (int i = 0; i < size; i++) {\n        Expression parameterExpression = parameters.get(i).getExpression();\n        expressions[i] = parameterExpression;\n        LOG.trace(\"Parameter #{} has expression: {}\", i, parameterExpression);\n    }\n    return new Expression() {\n\n        @SuppressWarnings(\"unchecked\")\n        public <T> T evaluate(Exchange exchange, Class<T> type) {\n            Object[] answer = new Object[size];\n            Object body = exchange.getIn().getBody();\n            boolean multiParameterArray = false;\n            if (exchange.getIn().getHeader(Exchange.BEAN_MULTI_PARAMETER_ARRAY) != null) {\n                multiParameterArray = exchange.getIn().getHeader(Exchange.BEAN_MULTI_PARAMETER_ARRAY, Boolean.class);\n            }\n                                    String methodName = exchange.getIn().getHeader(Exchange.BEAN_METHOD_NAME, \"\", String.class);\n                        String methodParameters = ObjectHelper.between(methodName, \"(\", \")\");\n                        Iterator<?> it = null;\n            if (methodParameters != null) {\n                                                String[] parameters = StringQuoteHelper.splitSafeQuote(methodParameters, ',', true);\n                it = ObjectHelper.createIterator(parameters, \",\", true);\n            }\n                                                            exchange.getIn().removeHeader(Exchange.BEAN_MULTI_PARAMETER_ARRAY);\n            exchange.getIn().removeHeader(Exchange.BEAN_METHOD_NAME);\n            for (int i = 0; i < size; i++) {\n                                Object parameterValue = it != null && it.hasNext() ? it.next() : null;\n                                Class<?> parameterType = parameters.get(i).getType();\n                                Object value = null;\n                if (multiParameterArray) {\n                                        value = ((Object[]) body)[i];\n                } else {\n                                        if (parameterValue != null && !parameterValue.equals(\"*\")) {\n                                                value = evaluateParameterValue(exchange, i, parameterValue, parameterType);\n                    }\n                                        Expression expression = expressions[i];\n                    if (value == null && expression != null) {\n                        value = evaluateParameterBinding(exchange, expression, i, parameterType);\n                    }\n                }\n                                if (value != Void.TYPE) {\n                    answer[i] = value;\n                }\n            }\n            return (T) answer;\n        }\n\n        /**\n         * Evaluate using parameter values where the values can be provided in the method name syntax.\n         * <p/>\n         * This methods returns accordingly:\n         * <ul>\n         *     <li><tt>null</tt> - if not a parameter value</li>\n         *     <li><tt>Void.TYPE</tt> - if an explicit null, forcing Camel to pass in <tt>null</tt> for that given parameter</li>\n         *     <li>a non <tt>null</tt> value - if the parameter was a parameter value, and to be used</li>\n         * </ul>\n         *\n         * @since 2.9\n         */\n        private Object evaluateParameterValue(Exchange exchange, int index, Object parameterValue, Class<?> parameterType) {\n            Object answer = null;\n                        String exp = exchange.getContext().getTypeConverter().convertTo(String.class, exchange, parameterValue);\n            if (exp != null) {\n                                boolean valid = BeanHelper.isValidParameterValue(exp);\n                if (!valid) {\n                                                            Boolean isClass = BeanHelper.isAssignableToExpectedType(exchange.getContext().getClassResolver(), exp, parameterType);\n                                        if (isClass != null) {\n                        return null;\n                    }\n                }\n                                Expression expression = null;\n                try {\n                    expression = exchange.getContext().resolveLanguage(\"simple\").createExpression(exp);\n                    parameterValue = expression.evaluate(exchange, Object.class);\n                } catch (Exception e) {\n                    throw new ExpressionEvaluationException(expression, \"Cannot create/evaluate simple expression: \" + exp + \" to be bound to parameter at index: \" + index + \" on method: \" + getMethod(), exchange, e);\n                }\n                if (parameterValue != null) {\n                                        if (\"null\".equals(parameterValue)) {\n                        return Void.TYPE;\n                    }\n                                                            exp = exchange.getContext().getTypeConverter().convertTo(String.class, parameterValue);\n                                        if (!valid) {\n                                                valid = parameterValue instanceof String || BeanHelper.isValidParameterValue(exp);\n                    }\n                    if (valid) {\n                                                if (parameterValue instanceof String) {\n                            parameterValue = StringHelper.removeLeadingAndEndingQuotes((String) parameterValue);\n                        }\n                        if (parameterValue != null) {\n                            try {\n                                                                answer = exchange.getContext().getTypeConverter().mandatoryConvertTo(parameterType, exchange, parameterValue);\n                                if (LOG.isTraceEnabled()) {\n                                    LOG.trace(\"Parameter #{} evaluated as: {} type: \", new Object[] { index, answer, ObjectHelper.type(answer) });\n                                }\n                            } catch (Exception e) {\n                                if (LOG.isDebugEnabled()) {\n                                    LOG.debug(\"Cannot convert from type: {} to type: {} for parameter #{}\", new Object[] { ObjectHelper.type(parameterValue), parameterType, index });\n                                }\n                                throw new ParameterBindingException(e, method, index, parameterType, parameterValue);\n                            }\n                        }\n                    }\n                }\n            }\n            return answer;\n        }\n\n        /**\n         * Evaluate using classic parameter binding using the pre compute expression\n         */\n        private Object evaluateParameterBinding(Exchange exchange, Expression expression, int index, Class<?> parameterType) {\n            Object answer = null;\n                        Object result = expression.evaluate(exchange, Object.class);\n            if (result != null) {\n                                try {\n                    answer = exchange.getContext().getTypeConverter().mandatoryConvertTo(parameterType, result);\n                    if (LOG.isTraceEnabled()) {\n                        LOG.trace(\"Parameter #{} evaluated as: {} type: \", new Object[] { index, answer, ObjectHelper.type(answer) });\n                    }\n                } catch (NoTypeConversionAvailableException e) {\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Cannot convert from type: {} to type: {} for parameter #{}\", new Object[] { ObjectHelper.type(result), parameterType, index });\n                    }\n                    throw new ParameterBindingException(e, method, index, parameterType, result);\n                }\n            } else {\n                LOG.trace(\"Parameter #{} evaluated as null\", index);\n            }\n            return answer;\n        }\n\n        @Override\n        public String toString() {\n            return \"ParametersExpression: \" + Arrays.asList(expressions);\n        }\n    };\n}", "lc": 5.590909090909091, "pi": 2.124401913875598, "ma": 5.2, "nbd": 2.5, "ml": 3.25, "d": 2.555555555555556, "mi": -1.6373502466525718, "fo": 5.0, "r": -0.02631578947368421, "e": 20.208186810970297}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1190_e29dc4f5", "label": 3, "code": "@Override\npublic void onRemoval(RemovalNotification<UUID, BatchWriter> notification) {\n    try {\n        notification.getValue().close();\n    } catch (MutationsRejectedException e) {\n        logger.warn(e, e);\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void onRemoval(RemovalNotification<UUID, BatchWriter> notification) {\n    try {\n        notification.getValue().close();\n    } catch (MutationsRejectedException e) {\n        logger.warn(e, e);\n    }\n}", "lc": -0.2727272727272727, "pi": 0.06220095693779899, "ma": -0.4, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.4167723749119096, "fo": -0.25, "r": 0.39473684210526316, "e": -0.16279340490885932}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-3789_9319e139", "label": 1, "code": "public void releaseExclusiveReadLock(GenericFileOperations<File> operations, GenericFile<File> file, Exchange exchange) throws Exception {\n    if (lock != null) {\n        LOG.trace(\"Unlocking file: {}\", lockFileName);\n        boolean deleted = FileUtil.deleteFile(lock);\n        LOG.trace(\"Lock file: {} was deleted: {}\", lockFileName, deleted);\n    }\n}", "code_comment": NaN, "code_no_comment": "public void releaseExclusiveReadLock(GenericFileOperations<File> operations, GenericFile<File> file, Exchange exchange) throws Exception {\n    if (lock != null) {\n        LOG.trace(\"Unlocking file: {}\", lockFileName);\n        boolean deleted = FileUtil.deleteFile(lock);\n        LOG.trace(\"Lock file: {} was deleted: {}\", lockFileName, deleted);\n    }\n}", "lc": -0.3181818181818182, "pi": 0.1626794258373205, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": -0.10714285714285715, "mi": 0.36828752642706114, "fo": -0.25, "r": 0.0, "e": -0.08795836863124773}
{"project_name": "Codec", "project_version": 11, "label": 1, "code": "/**\n * Decodes an array quoted-printable characters into an array of original bytes. Escaped characters are\n * converted back to their original representation.\n *\n * <p>\n * This function fully implements the quoted-printable encoding specification (rule #1 through rule #5) as\n * defined in RFC 1521.\n * </p>\n *\n * @param bytes\n *                  array of quoted-printable characters\n * @return array of original bytes\n * @throws DecoderException\n *                  Thrown if quoted-printable decoding is unsuccessful\n */\npublic static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {\n    if (bytes == null) {\n        return null;\n    }\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        final int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                // if the next octet is a CR we have found a soft line break\n                int u = Utils.digit16(bytes[++i]);\n                int l = Utils.digit16(bytes[++i]);\n                buffer.write((char) ((u << 4) + l));\n            } catch (ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid quoted-printable encoding\", e);\n            }\n        } else {\n            // every other octet is appended except for CR & LF\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}", "code_comment": "/**\n * Decodes an array quoted-printable characters into an array of original bytes. Escaped characters are\n * converted back to their original representation.\n *\n * <p>\n * This function fully implements the quoted-printable encoding specification (rule #1 through rule #5) as\n * defined in RFC 1521.\n * </p>\n *\n * @param bytes\n *                  array of quoted-printable characters\n * @return array of original bytes\n * @throws DecoderException\n *                  Thrown if quoted-printable decoding is unsuccessful\n */\n", "code_no_comment": "public static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {\n    if (bytes == null) {\n        return null;\n    }\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        final int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                                int u = Utils.digit16(bytes[++i]);\n                int l = Utils.digit16(bytes[++i]);\n                buffer.write((char) ((u << 4) + l));\n            } catch (ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid quoted-printable encoding\", e);\n            }\n        } else {\n                        buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}", "lc": 0.3181818181818182, "pi": 1.0, "ma": 0.4, "nbd": 0.5, "ml": 0.16666666666666666, "d": 0.878968253968254, "mi": -0.2794926004228327, "fo": -0.08333333333333333, "r": 0.05263157894736841, "e": 0.6574598180068347}
{"project_name": "Closure", "project_version": 3, "label": 1, "code": "@Override\npublic boolean apply(Node input) {\n    switch(input.getType()) {\n        case Token.GETELEM:\n        case Token.GETPROP:\n        case Token.ARRAYLIT:\n        case Token.OBJECTLIT:\n        case Token.REGEXP:\n        case Token.NEW:\n            return true;\n    }\n    return false;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean apply(Node input) {\n    switch(input.getType()) {\n        case Token.GETELEM:\n        case Token.GETPROP:\n        case Token.ARRAYLIT:\n        case Token.OBJECTLIT:\n        case Token.REGEXP:\n        case Token.NEW:\n            return true;\n    }\n    return false;\n}", "lc": -0.045454545454545456, "pi": 0.3349282296650717, "ma": 0.6, "nbd": 0.0, "ml": 0.16666666666666666, "d": -0.3650793650793651, "mi": 0.11486962649753353, "fo": -0.4166666666666667, "r": 0.10526315789473684, "e": -0.16279340490885932}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5071_6e794ad0", "label": 1, "code": "private boolean matches(final Url url) {\n    return (url.getSegments().size() >= 3 && urlStartsWith(url, getContext().getNamespace(), getContext().getBookmarkableIdentifier()));\n}", "code_comment": NaN, "code_no_comment": "private boolean matches(final Url url) {\n    return (url.getSegments().size() >= 3 && urlStartsWith(url, getContext().getNamespace(), getContext().getBookmarkableIdentifier()));\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.11309523809523811, "mi": 0.8711768851303733, "fo": 0.08333333333333333, "r": -0.02631578947368421, "e": -0.12805449421690493}
{"project_name": "Cli", "project_version": 21, "label": 1, "code": "/**\n * Tests whether the passed in trigger looks like an option. This\n * implementation first checks whether the passed in string starts with a\n * prefix that indicates an option. If this is the case, it is also checked\n * whether an option of this name is known for the current option. (This can\n * lead to reentrant invocations of this method, so care has to be taken\n * about this.)\n *\n * @param trigger the command line element to test\n * @return a flag whether this element seems to be an option\n */\npublic boolean looksLikeOption(final String trigger) {\n    for (final Iterator i = prefixes.iterator(); i.hasNext(); ) {\n        final String prefix = (String) i.next();\n        if (trigger.startsWith(prefix)) {\n            return true;\n        }\n    }\n    return false;\n}", "code_comment": "/**\n * Tests whether the passed in trigger looks like an option. This\n * implementation first checks whether the passed in string starts with a\n * prefix that indicates an option. If this is the case, it is also checked\n * whether an option of this name is known for the current option. (This can\n * lead to reentrant invocations of this method, so care has to be taken\n * about this.)\n *\n * @param trigger the command line element to test\n * @return a flag whether this element seems to be an option\n */\n", "code_no_comment": "public boolean looksLikeOption(final String trigger) {\n    for (final Iterator i = prefixes.iterator(); i.hasNext(); ) {\n        final String prefix = (String) i.next();\n        if (trigger.startsWith(prefix)) {\n            return true;\n        }\n    }\n    return false;\n}", "lc": -0.22727272727272727, "pi": 0.3732057416267942, "ma": -0.2, "nbd": 0.0, "ml": 0.0, "d": -0.3650793650793651, "mi": 0.30204369274136716, "fo": -0.16666666666666666, "r": 1.1052631578947367, "e": -0.16279340490885932}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3511_4a875f46", "label": 1, "code": "public IResourceStream locate(Class<?> scope, String path, String style, String variation, Locale locale, String extension, boolean strict) {\n    Key key = new Key(scope.getName(), path, locale, style, variation);\n    IResourceStream resourceStream = getCopyFromCache(key);\n    if (resourceStream == null) {\n        resourceStream = delegate.locate(scope, path, style, variation, locale, extension, strict);\n        updateCache(key, resourceStream);\n    }\n    return resourceStream;\n}", "code_comment": NaN, "code_no_comment": "public IResourceStream locate(Class<?> scope, String path, String style, String variation, Locale locale, String extension, boolean strict) {\n    Key key = new Key(scope.getName(), path, locale, style, variation);\n    IResourceStream resourceStream = getCopyFromCache(key);\n    if (resourceStream == null) {\n        resourceStream = delegate.locate(scope, path, style, variation, locale, extension, strict);\n        updateCache(key, resourceStream);\n    }\n    return resourceStream;\n}", "lc": -0.22727272727272727, "pi": -0.15311004784689008, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": 0.059523809523809534, "mi": 0.16955602536997882, "fo": -0.16666666666666666, "r": -0.02631578947368421, "e": 0.05618390645620465}
{"project_name": "Closure", "project_version": 34, "label": 2, "code": "/**\n * We could use addList recursively here, but sometimes we produce\n * very deeply nested operators and run out of stack space, so we\n * just unroll the recursion when possible.\n *\n * We assume nodes are left-recursive.\n */\nprivate void unrollBinaryOperator(Node n, int op, String opStr, Context context, Context rhsContext, int leftPrecedence, int rightPrecedence) {\n    Node firstNonOperator = n.getFirstChild();\n    while (firstNonOperator.getType() == op) {\n        firstNonOperator = firstNonOperator.getFirstChild();\n    }\n    addExpr(firstNonOperator, leftPrecedence, context);\n    Node current = firstNonOperator;\n    do {\n        current = current.getParent();\n        cc.listSeparator();\n        addExpr(current.getFirstChild().getNext(), rightPrecedence, rhsContext);\n    } while (current != n);\n}", "code_comment": "/**\n * We could use addList recursively here, but sometimes we produce\n * very deeply nested operators and run out of stack space, so we\n * just unroll the recursion when possible.\n *\n * We assume nodes are left-recursive.\n */\n", "code_no_comment": "private void unrollBinaryOperator(Node n, int op, String opStr, Context context, Context rhsContext, int leftPrecedence, int rightPrecedence) {\n    Node firstNonOperator = n.getFirstChild();\n    while (firstNonOperator.getType() == op) {\n        firstNonOperator = firstNonOperator.getFirstChild();\n    }\n    addExpr(firstNonOperator, leftPrecedence, context);\n    Node current = firstNonOperator;\n    do {\n        current = current.getParent();\n        cc.listSeparator();\n        addExpr(current.getFirstChild().getNext(), rightPrecedence, rhsContext);\n    } while (current != n);\n}", "lc": -0.045454545454545456, "pi": -0.16267942583732073, "ma": -0.2, "nbd": -0.5, "ml": 0.08333333333333333, "d": 0.041666666666666616, "mi": -0.0069062720225512185, "fo": 0.25, "r": 0.0, "e": 0.04929144839588986}
{"project_name": "Math", "project_version": 62, "label": 1, "code": "/**\n * {@inheritDoc}\n */\npublic UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal, final double min, final double max) throws FunctionEvaluationException {\n    return optimize(f, goal, min, max, 0);\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal, final double min, final double max) throws FunctionEvaluationException {\n    return optimize(f, goal, min, max, 0);\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.8810429880197319, "fo": -0.4166666666666667, "r": 0.7368421052631579, "e": -0.16279340490885932}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-395_962315ba", "label": 1, "code": "/**\n * Temporary workaround.\n */\nprotected double doOptimize() {\n    throw new UnsupportedOperationException();\n}", "code_comment": "/**\n * Temporary workaround.\n */\n", "code_no_comment": "protected double doOptimize() {\n    throw new UnsupportedOperationException();\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.4, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.2342494714587733, "fo": -0.5, "r": 2.5789473684210527, "e": -0.16279340490885932}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1505_994df698", "label": 1, "code": "@Override\npublic void addMutation(Mutation m) throws MutationsRejectedException {\n    acu.addMutation(tablename, m);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void addMutation(Mutation m) throws MutationsRejectedException {\n    acu.addMutation(tablename, m);\n}", "lc": -0.45454545454545453, "pi": -0.6028708133971293, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.8396053558844253, "fo": -0.4166666666666667, "r": 1.1052631578947367, "e": -0.16279340490885932}
{"project_name": "Math", "project_version": 55, "label": 1, "code": "/**\n * Compute the cross-product of two vectors.\n * @param v1 first vector\n * @param v2 second vector\n * @return the cross product v1 ^ v2 as a new Vector\n */\npublic static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\n    // compute cross product from v3 and v2 instead of v1 and v2\n    return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);\n}", "code_comment": "/**\n * Compute the cross-product of two vectors.\n * @param v1 first vector\n * @param v2 second vector\n * @return the cross product v1 ^ v2 as a new Vector\n */\n", "code_no_comment": "public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\n        return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": 0.4285714285714286, "mi": 0.7491190979563072, "fo": -0.5, "r": 0.02631578947368421, "e": 0.08837790955665815}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-210_aeb6fc9d", "label": 1, "code": "public void asXML(final StringBuilder sb) {\n    sb.append(\"<Map>\\n\");\n    for (final Map.Entry<String, String> entry : data.entrySet()) {\n        sb.append(\"  <Entry key=\").append(entry.getKey()).append(\">\").append(entry.getValue()).append(\"</Entry>\\n\");\n    }\n    sb.append(\"</Map>\");\n}", "code_comment": NaN, "code_no_comment": "public void asXML(final StringBuilder sb) {\n    sb.append(\"<Map>\\n\");\n    for (final Map.Entry<String, String> entry : data.entrySet()) {\n        sb.append(\"  <Entry key=\").append(entry.getKey()).append(\">\").append(entry.getValue()).append(\"</Entry>\\n\");\n    }\n    sb.append(\"</Map>\");\n}", "lc": -0.3181818181818182, "pi": -0.20574162679425848, "ma": -0.4, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.36800563777307976, "fo": 0.3333333333333333, "r": -0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-757_76b7413d", "label": 1, "code": "/**\n * Clear the array contents, resetting the number of elements to zero.\n */\n@Override\npublic synchronized void clear() {\n    numElements = 0;\n    startIndex = 0;\n}", "code_comment": "/**\n * Clear the array contents, resetting the number of elements to zero.\n */\n", "code_no_comment": "@Override\npublic synchronized void clear() {\n    numElements = 0;\n    startIndex = 0;\n}", "lc": -0.4090909090909091, "pi": -0.49282296650717716, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.7626497533474278, "fo": -0.5, "r": 2.552631578947368, "e": -0.16279340490885932}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-113_fc3e9d2d", "label": 1, "code": "/**\n * Create the StructuredDataFilter.\n * @param pairs Key and value pairs.\n * @param oper The operator to perform. If not \"or\" the operation will be an \"and\".\n * @param match The action to perform on a match.\n * @param mismatch The action to perform on a mismatch.\n * @return The StructuredDataFilter.\n */\n@PluginFactory\npublic static StructuredDataFilter createFilter(@PluginAttr(\"pairs\") KeyValuePair[] pairs, @PluginAttr(\"operator\") String oper, @PluginAttr(\"onmatch\") String match, @PluginAttr(\"onmismatch\") String mismatch) {\n    if (pairs == null || pairs.length == 0) {\n        LOGGER.error(\"keys and values must be specified for the StructuredDataFilter\");\n        return null;\n    }\n    Map<String, List<String>> map = new HashMap<String, List<String>>();\n    for (KeyValuePair pair : pairs) {\n        String key = pair.getKey();\n        if (key == null) {\n            LOGGER.error(\"A null key is not valid in MapFilter\");\n            continue;\n        }\n        String value = pair.getValue();\n        if (value == null) {\n            LOGGER.error(\"A null value for key \" + key + \" is not allowed in MapFilter\");\n            continue;\n        }\n        List<String> list = map.get(pair.getKey());\n        if (list != null) {\n            list.add(value);\n        } else {\n            list = new ArrayList<String>();\n            list.add(value);\n            map.put(pair.getKey(), list);\n        }\n    }\n    if (map.size() == 0) {\n        LOGGER.error(\"StructuredDataFilter is not configured with any valid key value pairs\");\n        return null;\n    }\n    boolean isAnd = oper == null || !oper.equalsIgnoreCase(\"or\");\n    Result onMatch = Result.toResult(match);\n    Result onMismatch = Result.toResult(mismatch);\n    return new StructuredDataFilter(map, isAnd, onMatch, onMismatch);\n}", "code_comment": "/**\n * Create the StructuredDataFilter.\n * @param pairs Key and value pairs.\n * @param oper The operator to perform. If not \"or\" the operation will be an \"and\".\n * @param match The action to perform on a match.\n * @param mismatch The action to perform on a mismatch.\n * @return The StructuredDataFilter.\n */\n", "code_no_comment": "@PluginFactory\npublic static StructuredDataFilter createFilter(@PluginAttr(\"pairs\") KeyValuePair[] pairs, @PluginAttr(\"operator\") String oper, @PluginAttr(\"onmatch\") String match, @PluginAttr(\"onmismatch\") String mismatch) {\n    if (pairs == null || pairs.length == 0) {\n        LOGGER.error(\"keys and values must be specified for the StructuredDataFilter\");\n        return null;\n    }\n    Map<String, List<String>> map = new HashMap<String, List<String>>();\n    for (KeyValuePair pair : pairs) {\n        String key = pair.getKey();\n        if (key == null) {\n            LOGGER.error(\"A null key is not valid in MapFilter\");\n            continue;\n        }\n        String value = pair.getValue();\n        if (value == null) {\n            LOGGER.error(\"A null value for key \" + key + \" is not allowed in MapFilter\");\n            continue;\n        }\n        List<String> list = map.get(pair.getKey());\n        if (list != null) {\n            list.add(value);\n        } else {\n            list = new ArrayList<String>();\n            list.add(value);\n            map.put(pair.getKey(), list);\n        }\n    }\n    if (map.size() == 0) {\n        LOGGER.error(\"StructuredDataFilter is not configured with any valid key value pairs\");\n        return null;\n    }\n    boolean isAnd = oper == null || !oper.equalsIgnoreCase(\"or\");\n    Result onMatch = Result.toResult(match);\n    Result onMismatch = Result.toResult(mismatch);\n    return new StructuredDataFilter(map, isAnd, onMatch, onMismatch);\n}", "lc": 1.0, "pi": 0.2775119617224879, "ma": 1.0, "nbd": 0.0, "ml": 0.5833333333333334, "d": 1.0833333333333333, "mi": -0.6868217054263562, "fo": 0.8333333333333334, "r": -0.02631578947368421, "e": 2.3519533433608224}
{"project_name": "Closure", "project_version": 155, "label": 2, "code": "/**\n * For all variables in this scope, see if they are only used once.\n * If it looks safe to do so, inline them.\n */\nprivate void doInlinesForScope(NodeTraversal t, Map<Var, ReferenceCollection> referenceMap) {\n    for (Iterator<Var> it = t.getScope().getVars(); it.hasNext(); ) {\n        Var v = it.next();\n        ReferenceCollection referenceInfo = referenceMap.get(v);\n        // and the variable is not a constant.\n        if (referenceInfo == null || isVarInlineForbidden(v)) {\n            // were not collected or variables that have already been inlined.\n            continue;\n        } else if (isInlineableDeclaredConstant(v, referenceInfo)) {\n            Reference init = referenceInfo.getInitializingReferenceForConstants();\n            Node value = init.getAssignedValue();\n            inlineDeclaredConstant(v, value, referenceInfo.references);\n            staleVars.add(v);\n        } else if (mode == Mode.CONSTANTS_ONLY) {\n            // inlining heuristics. See InlineConstantsTest.\n            continue;\n        } else {\n            inlineNonConstants(v, referenceInfo);\n        }\n    }\n}", "code_comment": "/**\n * For all variables in this scope, see if they are only used once.\n * If it looks safe to do so, inline them.\n */\n", "code_no_comment": "private void doInlinesForScope(NodeTraversal t, Map<Var, ReferenceCollection> referenceMap) {\n    for (Iterator<Var> it = t.getScope().getVars(); it.hasNext(); ) {\n        Var v = it.next();\n        ReferenceCollection referenceInfo = referenceMap.get(v);\n                if (referenceInfo == null || isVarInlineForbidden(v)) {\n                        continue;\n        } else if (isInlineableDeclaredConstant(v, referenceInfo)) {\n            Reference init = referenceInfo.getInitializingReferenceForConstants();\n            Node value = init.getAssignedValue();\n            inlineDeclaredConstant(v, value, referenceInfo.references);\n            staleVars.add(v);\n        } else if (mode == Mode.CONSTANTS_ONLY) {\n                        continue;\n        } else {\n            inlineNonConstants(v, referenceInfo);\n        }\n    }\n}", "lc": 0.18181818181818182, "pi": 0.42583732057416257, "ma": 0.6, "nbd": 1.0, "ml": 0.5, "d": -0.0496031746031746, "mi": -0.23467230443974632, "fo": 0.5, "r": -0.02631578947368421, "e": 0.07370780818681096}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3510_01f5a26f", "label": 1, "code": "/**\n * Creates an external identity reference from a string representation.\n * @param str the string\n * @return the reference\n */\npublic static ExternalIdentityRef fromString(@Nonnull String str) {\n    int idx = str.indexOf(';');\n    if (idx < 0) {\n        return new ExternalIdentityRef(Text.unescape(str), null);\n    } else {\n        return new ExternalIdentityRef(Text.unescape(str.substring(0, idx)), Text.unescape(str.substring(idx + 1)));\n    }\n}", "code_comment": "/**\n * Creates an external identity reference from a string representation.\n * @param str the string\n * @return the reference\n */\n", "code_no_comment": "public static ExternalIdentityRef fromString(@Nonnull String str) {\n    int idx = str.indexOf(';');\n    if (idx < 0) {\n        return new ExternalIdentityRef(Text.unescape(str), null);\n    } else {\n        return new ExternalIdentityRef(Text.unescape(str.substring(0, idx)), Text.unescape(str.substring(idx + 1)));\n    }\n}", "lc": -0.2727272727272727, "pi": -0.07655502392344504, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": 0.03174603174603173, "mi": 0.29330514446793515, "fo": 0.0, "r": 0.3684210526315789, "e": -0.03590763184131209}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-428_d906576c", "label": 3, "code": "public Object get(final int index) {\n    return value;\n}", "code_comment": NaN, "code_no_comment": "public Object get(final int index) {\n    return value;\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.1099365750528538, "fo": -0.5, "r": 2.4473684210526314, "e": -0.16279340490885932}
{"project_name": "Closure", "project_version": 24, "label": 2, "code": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        int type = n.getType();\n        Node parent = n.getParent();\n        if (parent.isVar()) {\n            if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n                String name = n.getString();\n                Var aliasVar = scope.getVar(name);\n                aliases.put(name, aliasVar);\n                String qualifiedName = aliasVar.getInitialValue().getQualifiedName();\n                transformation.addAlias(name, qualifiedName);\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n            } else {\n                // TODO(robbyw): Support using locals for private variables.\n                report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n            }\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        int type = n.getType();\n        Node parent = n.getParent();\n        if (parent.isVar()) {\n            if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n                String name = n.getString();\n                Var aliasVar = scope.getVar(name);\n                aliases.put(name, aliasVar);\n                String qualifiedName = aliasVar.getInitialValue().getQualifiedName();\n                transformation.addAlias(name, qualifiedName);\n                                                            } else {\n                                report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n            }\n        }\n    }\n}", "lc": 0.22727272727272727, "pi": 1.15311004784689, "ma": 0.0, "nbd": 0.5, "ml": 0.08333333333333333, "d": -0.03571428571428575, "mi": -0.2490486257928116, "fo": 0.9166666666666666, "r": 0.02631578947368421, "e": 0.09988992813632772}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-93_0be7e8f0", "label": 1, "code": "@Override\npublic PropertyState setProperty(String name, List<CoreValue> values) {\n    PropertyState property = new PropertyStateImpl(name, values);\n    if (hasProperty(name)) {\n        context.setProperty(property, path);\n    } else {\n        context.addProperty(property, path);\n    }\n    return property;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic PropertyState setProperty(String name, List<CoreValue> values) {\n    PropertyState property = new PropertyStateImpl(name, values);\n    if (hasProperty(name)) {\n        context.setProperty(property, path);\n    } else {\n        context.addProperty(property, path);\n    }\n    return property;\n}", "lc": -0.18181818181818182, "pi": -0.0909090909090911, "ma": -0.4, "nbd": -0.5, "ml": -0.16666666666666666, "d": -0.3650793650793651, "mi": 0.23241719520789295, "fo": -0.25, "r": 0.05263157894736841, "e": -0.16279340490885932}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4153_2737d7c7", "label": 3, "code": "/**\n *  Create the MarkupContainer for the <tbody> tag. Users may subclass it to provide their own\n *  (modified) implementation.\n *\n *  @param id\n *  @return A new markup container\n */\nprotected WebMarkupContainer newBodyContainer(final String id) {\n    return new WebMarkupContainer(id);\n}", "code_comment": "/**\n *  Create the MarkupContainer for the <tbody> tag. Users may subclass it to provide their own\n *  (modified) implementation.\n *\n *  @param id\n *  @return A new markup container\n */\n", "code_no_comment": "protected WebMarkupContainer newBodyContainer(final String id) {\n    return new WebMarkupContainer(id);\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.0606060606060603, "fo": -0.5, "r": 2.6052631578947367, "e": -0.16279340490885932}
{"project_name": "Lang", "project_version": 30, "label": 3, "code": "// IndexOfAny chars\n// -----------------------------------------------------------------------\n/**\n * <p>Search a CharSequence to find the first index of any\n * character in the given set of characters.</p>\n *\n * <p>A <code>null</code> String will return <code>-1</code>.\n * A <code>null</code> or zero length search array will return <code>-1</code>.</p>\n *\n * <pre>\n * StringUtils.indexOfAny(null, *)                = -1\n * StringUtils.indexOfAny(\"\", *)                  = -1\n * StringUtils.indexOfAny(*, null)                = -1\n * StringUtils.indexOfAny(*, [])                  = -1\n * StringUtils.indexOfAny(\"zzabyycdxx\",['z','a']) = 0\n * StringUtils.indexOfAny(\"zzabyycdxx\",['b','y']) = 3\n * StringUtils.indexOfAny(\"aba\", ['z'])           = -1\n * </pre>\n *\n * @param cs  the CharSequence to check, may be null\n * @param searchChars  the chars to search for, may be null\n * @return the index of any of the chars, -1 if no match or null input\n * @since 2.0\n */\npublic static int indexOfAny(CharSequence cs, char[] searchChars) {\n    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n        return INDEX_NOT_FOUND;\n    }\n    int csLen = cs.length();\n    int searchLen = searchChars.length;\n    for (int i = 0; i < csLen; i++) {\n        char ch = cs.charAt(i);\n        for (int j = 0; j < searchLen; j++) {\n            if (searchChars[j] == ch) {\n                // ch is a supplementary character\n                return i;\n            }\n        }\n    }\n    return INDEX_NOT_FOUND;\n}", "code_comment": "/**\n * <p>Search a CharSequence to find the first index of any\n * character in the given set of characters.</p>\n *\n * <p>A <code>null</code> String will return <code>-1</code>.\n * A <code>null</code> or zero length search array will return <code>-1</code>.</p>\n *\n * <pre>\n * StringUtils.indexOfAny(null, *)                = -1\n * StringUtils.indexOfAny(\"\", *)                  = -1\n * StringUtils.indexOfAny(*, null)                = -1\n * StringUtils.indexOfAny(*, [])                  = -1\n * StringUtils.indexOfAny(\"zzabyycdxx\",['z','a']) = 0\n * StringUtils.indexOfAny(\"zzabyycdxx\",['b','y']) = 3\n * StringUtils.indexOfAny(\"aba\", ['z'])           = -1\n * </pre>\n *\n * @param cs  the CharSequence to check, may be null\n * @param searchChars  the chars to search for, may be null\n * @return the index of any of the chars, -1 if no match or null input\n * @since 2.0\n */\n", "code_no_comment": "public static int indexOfAny(CharSequence cs, char[] searchChars) {\n    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n        return INDEX_NOT_FOUND;\n    }\n    int csLen = cs.length();\n    int searchLen = searchChars.length;\n    for (int i = 0; i < csLen; i++) {\n        char ch = cs.charAt(i);\n        for (int j = 0; j < searchLen; j++) {\n            if (searchChars[j] == ch) {\n                                return i;\n            }\n        }\n    }\n    return INDEX_NOT_FOUND;\n}", "lc": 0.09090909090909091, "pi": 0.5980861244019139, "ma": 0.2, "nbd": 0.5, "ml": 0.75, "d": 0.5277777777777778, "mi": -0.10218463706835798, "fo": -0.16666666666666666, "r": 0.15789473684210528, "e": 0.2654979455173089}
{"project_name": "Compress", "project_version": 18, "label": 1, "code": "/**\n * Writes a PAX extended header with the given map as contents.\n * @since 1.4\n */\nvoid writePaxHeaders(String entryName, Map<String, String> headers) throws IOException {\n    String name = \"./PaxHeaders.X/\" + stripTo7Bits(entryName);\n    // and not allow any data to be written\n    if (name.length() >= TarConstants.NAMELEN) {\n        name = name.substring(0, TarConstants.NAMELEN - 1);\n    }\n    TarArchiveEntry pex = new TarArchiveEntry(name, TarConstants.LF_PAX_EXTENDED_HEADER_LC);\n    StringWriter w = new StringWriter();\n    for (Map.Entry<String, String> h : headers.entrySet()) {\n        String key = h.getKey();\n        String value = h.getValue();\n        int len = key.length() + value.length() + 3 + /* blank, equals and newline */\n        2;\n        String line = len + \" \" + key + \"=\" + value + \"\\n\";\n        int actualLength = line.getBytes(CharsetNames.UTF_8).length;\n        while (len != actualLength) {\n            // Adjust for cases where length < 10 or > 100\n            // or where UTF-8 encoding isn't a single octet\n            // per character.\n            // Must be in loop as size may go from 99 to 100 in\n            // first pass so we'd need a second.\n            len = actualLength;\n            line = len + \" \" + key + \"=\" + value + \"\\n\";\n            actualLength = line.getBytes(CharsetNames.UTF_8).length;\n        }\n        w.write(line);\n    }\n    byte[] data = w.toString().getBytes(CharsetNames.UTF_8);\n    pex.setSize(data.length);\n    putArchiveEntry(pex);\n    write(data);\n    closeArchiveEntry();\n}", "code_comment": "/**\n * Writes a PAX extended header with the given map as contents.\n * @since 1.4\n */\n", "code_no_comment": "void writePaxHeaders(String entryName, Map<String, String> headers) throws IOException {\n    String name = \"./PaxHeaders.X/\" + stripTo7Bits(entryName);\n        if (name.length() >= TarConstants.NAMELEN) {\n        name = name.substring(0, TarConstants.NAMELEN - 1);\n    }\n    TarArchiveEntry pex = new TarArchiveEntry(name, TarConstants.LF_PAX_EXTENDED_HEADER_LC);\n    StringWriter w = new StringWriter();\n    for (Map.Entry<String, String> h : headers.entrySet()) {\n        String key = h.getKey();\n        String value = h.getValue();\n        int len = key.length() + value.length() + 3 +         2;\n        String line = len + \" \" + key + \"=\" + value + \"\\n\";\n        int actualLength = line.getBytes(CharsetNames.UTF_8).length;\n        while (len != actualLength) {\n                                                                        len = actualLength;\n            line = len + \" \" + key + \"=\" + value + \"\\n\";\n            actualLength = line.getBytes(CharsetNames.UTF_8).length;\n        }\n        w.write(line);\n    }\n    byte[] data = w.toString().getBytes(CharsetNames.UTF_8);\n    pex.setSize(data.length);\n    putArchiveEntry(pex);\n    write(data);\n    closeArchiveEntry();\n}", "lc": 0.5909090909090909, "pi": 0.07655502392344483, "ma": 0.0, "nbd": 0.0, "ml": 0.0, "d": 0.5615079365079365, "mi": -0.5148696264975333, "fo": 0.9166666666666666, "r": -0.02631578947368421, "e": 1.3550457288082844}
{"project_name": "Closure", "project_version": 163, "label": 1, "code": "@Override\npublic void exitScope(NodeTraversal t) {\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void exitScope(NodeTraversal t) {\n}", "lc": -0.5, "pi": -1.4306220095693782, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.1099365750528538, "fo": -0.5, "r": 2.3157894736842106, "e": -0.16279340490885932}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-2899_31aea2ad", "label": 0, "code": "@Override\npublic Path getFullPath(FileType fileType, String path) {\n    if (path.contains(\":\"))\n        return new Path(path);\n    // normalize the path\n    Path fullPath = new Path(defaultVolume.getBasePath(), fileType.getDirectory());\n    if (path.startsWith(\"/\"))\n        path = path.substring(1);\n    fullPath = new Path(fullPath, path);\n    FileSystem fs = getVolumeByPath(fullPath).getFileSystem();\n    return fs.makeQualified(fullPath);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic Path getFullPath(FileType fileType, String path) {\n    if (path.contains(\":\"))\n        return new Path(path);\n        Path fullPath = new Path(defaultVolume.getBasePath(), fileType.getDirectory());\n    if (path.startsWith(\"/\"))\n        path = path.substring(1);\n    fullPath = new Path(fullPath, path);\n    FileSystem fs = getVolumeByPath(fullPath).getFileSystem();\n    return fs.makeQualified(fullPath);\n}", "lc": -0.13636363636363635, "pi": -0.15311004784689008, "ma": -0.2, "nbd": -1.0, "ml": -0.08333333333333333, "d": -0.3650793650793651, "mi": 0.08865398167723736, "fo": 0.16666666666666666, "r": 0.0, "e": -0.16279340490885932}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-782_45b110e1", "label": 1, "code": "@Nonnull\nprivate MutableNodeState write(long newRevision, boolean reconnect) {\n    // make sure that all revision numbers up to the root gets updated\n    if (!isRoot()) {\n        parent.write(newRevision, reconnect);\n        checkState(reconnect || exists(), \"This node has been removed\");\n    }\n    if (writeState == null || revision != root.revision) {\n        // root never gets here since revision == root.revision\n        assert (!isRoot());\n        // The builder could have been reset, need to re-get base state\n        baseState = parent.getBaseState(name);\n        writeState = parent.getWriteState(name);\n        if (writeState == null) {\n            if (exists()) {\n                writeState = new MutableNodeState(baseState);\n            } else {\n                writeState = new MutableNodeState(null);\n            }\n            // guaranteed by called parent.write()\n            assert parent.writeState != null;\n            parent.writeState.nodes.put(name, writeState);\n        }\n    }\n    revision = newRevision;\n    assert classInvariants();\n    assert writeState != null;\n    return writeState;\n}", "code_comment": NaN, "code_no_comment": "@Nonnull\nprivate MutableNodeState write(long newRevision, boolean reconnect) {\n        if (!isRoot()) {\n        parent.write(newRevision, reconnect);\n        checkState(reconnect || exists(), \"This node has been removed\");\n    }\n    if (writeState == null || revision != root.revision) {\n                assert (!isRoot());\n                baseState = parent.getBaseState(name);\n        writeState = parent.getWriteState(name);\n        if (writeState == null) {\n            if (exists()) {\n                writeState = new MutableNodeState(baseState);\n            } else {\n                writeState = new MutableNodeState(null);\n            }\n                        assert parent.writeState != null;\n            parent.writeState.nodes.put(name, writeState);\n        }\n    }\n    revision = newRevision;\n    assert classInvariants();\n    assert writeState != null;\n    return writeState;\n}", "lc": 0.5, "pi": 0.736842105263158, "ma": 0.2, "nbd": 0.5, "ml": 0.4166666666666667, "d": -0.3650793650793651, "mi": 0.07343199436222701, "fo": 0.3333333333333333, "r": -0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "Csv", "project_version": 14, "label": 3, "code": "/*\n     * Note: must only be called if quoting is enabled, otherwise will generate NPE\n     */\n// the original object is needed so can check for Number\nprivate void printAndQuote(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch(quoteModePolicy) {\n        case ALL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            // Use the existing escaping code\n            printAndEscape(value, offset, len, out);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                // an empty line has no tokens.\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char c = value.charAt(pos);\n                // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E\n                if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n                    quote = true;\n                } else if (c <= COMMENT) {\n                    // Some other chars at the start of a value caused the parser to fail, so for now\n                    // encapsulate if we start in anything less than '#'. We are being conservative\n                    // by including the default comment char too.\n                    quote = true;\n                } else {\n                    while (pos < end) {\n                        c = value.charAt(pos);\n                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                            quote = true;\n                            break;\n                        }\n                        pos++;\n                    }\n                    if (!quote) {\n                        pos = end - 1;\n                        c = value.charAt(pos);\n                        // encapsulate if we end in anything less than ' '\n                        if (c <= SP) {\n                            quote = true;\n                        }\n                    }\n                }\n            }\n            if (!quote) {\n                // no encapsulation needed - write out the original value\n                out.append(value, start, end);\n                return;\n            }\n            break;\n        default:\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n    }\n    if (!quote) {\n        // no encapsulation needed - write out the original value\n        out.append(value, start, end);\n        return;\n    }\n    // we hit something that needed encapsulation\n    out.append(quoteChar);\n    // the need for encapsulation.\n    while (pos < end) {\n        final char c = value.charAt(pos);\n        if (c == quoteChar) {\n            // write out the chunk up until this point\n            // add 1 to the length to write out the encapsulator also\n            out.append(value, start, pos + 1);\n            // put the next starting position on the encapsulator so we will\n            // write it out again with the next string (effectively doubling it)\n            start = pos;\n        }\n        pos++;\n    }\n    // write the last segment\n    out.append(value, start, pos);\n    out.append(quoteChar);\n}", "code_comment": NaN, "code_no_comment": "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch(quoteModePolicy) {\n        case ALL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n                        printAndEscape(value, offset, len, out);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char c = value.charAt(pos);\n                                if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n                    quote = true;\n                } else if (c <= COMMENT) {\n                                                                                quote = true;\n                } else {\n                    while (pos < end) {\n                        c = value.charAt(pos);\n                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                            quote = true;\n                            break;\n                        }\n                        pos++;\n                    }\n                    if (!quote) {\n                        pos = end - 1;\n                        c = value.charAt(pos);\n                                                if (c <= SP) {\n                            quote = true;\n                        }\n                    }\n                }\n            }\n            if (!quote) {\n                                out.append(value, start, end);\n                return;\n            }\n            break;\n        default:\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n    }\n    if (!quote) {\n                out.append(value, start, end);\n        return;\n    }\n        out.append(quoteChar);\n        while (pos < end) {\n        final char c = value.charAt(pos);\n        if (c == quoteChar) {\n                                    out.append(value, start, pos + 1);\n                                    start = pos;\n        }\n        pos++;\n    }\n        out.append(value, start, pos);\n    out.append(quoteChar);\n}", "lc": 2.727272727272727, "pi": 2.148325358851675, "ma": 4.0, "nbd": 2.5, "ml": 2.5, "d": 2.6507936507936507, "mi": -1.1849189570119798, "fo": 0.75, "r": -0.02631578947368421, "e": 8.366621139560749}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3838_97514205", "label": 1, "code": "/**\n *  @see org.apache.wicket.request.mapper.AbstractBookmarkableMapper#buildUrl(org.apache.wicket.request.mapper.AbstractBookmarkableMapper.UrlInfo)\n */\n@Override\nprotected Url buildUrl(UrlInfo info) {\n    Class<? extends IRequestablePage> pageClass = info.getPageClass();\n    if (PackageName.forClass(pageClass).equals(packageName)) {\n        Url url = new Url();\n        url.getSegments().add(pageClass.getSimpleName());\n        encodePageComponentInfo(url, info.getPageComponentInfo());\n        return encodePageParameters(url, info.getPageParameters(), pageParametersEncoder);\n    }\n    return null;\n}", "code_comment": "/**\n *  @see org.apache.wicket.request.mapper.AbstractBookmarkableMapper#buildUrl(org.apache.wicket.request.mapper.AbstractBookmarkableMapper.UrlInfo)\n */\n", "code_no_comment": "@Override\nprotected Url buildUrl(UrlInfo info) {\n    Class<? extends IRequestablePage> pageClass = info.getPageClass();\n    if (PackageName.forClass(pageClass).equals(packageName)) {\n        Url url = new Url();\n        url.getSegments().add(pageClass.getSimpleName());\n        encodePageComponentInfo(url, info.getPageComponentInfo());\n        return encodePageParameters(url, info.getPageParameters(), pageParametersEncoder);\n    }\n    return null;\n}", "lc": -0.13636363636363635, "pi": 0.08612440191387546, "ma": -0.4, "nbd": -0.5, "ml": -0.16666666666666666, "d": -0.3650793650793651, "mi": 0.11909795630725845, "fo": 0.3333333333333333, "r": -0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-2713_63d9800e", "label": 1, "code": "@Override\npublic void update(S state) throws IOException {\n    if (currentInput == null) {\n        throw new IllegalStateException(\"Need a valid input for updating a state.\");\n    } else {\n        Serializable key;\n        try {\n            key = keySelector.getKey(currentInput);\n        } catch (Exception e) {\n            throw new RuntimeException(\"User-defined key selector threw an exception.\");\n        }\n        if (state == null) {\n            // Remove state if set to null\n            stateStore.removeStateForKey(key);\n        } else {\n            stateStore.setStateForKey(key, state);\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void update(S state) throws IOException {\n    if (currentInput == null) {\n        throw new IllegalStateException(\"Need a valid input for updating a state.\");\n    } else {\n        Serializable key;\n        try {\n            key = keySelector.getKey(currentInput);\n        } catch (Exception e) {\n            throw new RuntimeException(\"User-defined key selector threw an exception.\");\n        }\n        if (state == null) {\n                        stateStore.removeStateForKey(key);\n        } else {\n            stateStore.setStateForKey(key, state);\n        }\n    }\n}", "lc": 0.18181818181818182, "pi": 0.4641148325358851, "ma": 0.4, "nbd": 0.0, "ml": -0.08333333333333333, "d": -0.0912698412698413, "mi": -0.11035940803382639, "fo": -0.25, "r": 0.07894736842105263, "e": -0.07063271151374745}
{"project_name": "maven", "project_version": "remotes/origin/bugs-dot-jar_MNG-1856_faa5cf27", "label": 3, "code": "private void assembleModelInheritance(Model child, Model parent, String childPathAdjustment, boolean appendPaths) {\n    // cannot inherit from null parent.\n    if (parent == null) {\n        return;\n    }\n    // Group id\n    if (child.getGroupId() == null) {\n        child.setGroupId(parent.getGroupId());\n    }\n    // version\n    if (child.getVersion() == null) {\n        if (child.getParent() != null) {\n            child.setVersion(child.getParent().getVersion());\n        }\n    }\n    // inceptionYear\n    if (child.getInceptionYear() == null) {\n        child.setInceptionYear(parent.getInceptionYear());\n    }\n    // url\n    if (child.getUrl() == null) {\n        if (parent.getUrl() != null) {\n            child.setUrl(appendPath(parent.getUrl(), child.getArtifactId(), childPathAdjustment, appendPaths));\n        } else {\n            child.setUrl(parent.getUrl());\n        }\n    }\n    // ----------------------------------------------------------------------\n    // Distribution\n    // ----------------------------------------------------------------------\n    assembleDistributionInheritence(child, parent, childPathAdjustment, appendPaths);\n    // issueManagement\n    if (child.getIssueManagement() == null) {\n        child.setIssueManagement(parent.getIssueManagement());\n    }\n    // description\n    if (child.getDescription() == null) {\n        child.setDescription(parent.getDescription());\n    }\n    // Organization\n    if (child.getOrganization() == null) {\n        child.setOrganization(parent.getOrganization());\n    }\n    // Scm\n    assembleScmInheritance(child, parent, childPathAdjustment, appendPaths);\n    // ciManagement\n    if (child.getCiManagement() == null) {\n        child.setCiManagement(parent.getCiManagement());\n    }\n    // developers\n    if (child.getDevelopers().size() == 0) {\n        child.setDevelopers(parent.getDevelopers());\n    }\n    // licenses\n    if (child.getLicenses().size() == 0) {\n        child.setLicenses(parent.getLicenses());\n    }\n    // developers\n    if (child.getContributors().size() == 0) {\n        child.setContributors(parent.getContributors());\n    }\n    // mailingLists\n    if (child.getMailingLists().size() == 0) {\n        child.setMailingLists(parent.getMailingLists());\n    }\n    // Build\n    assembleBuildInheritance(child, parent);\n    assembleDependencyInheritance(child, parent);\n    child.setRepositories(ModelUtils.mergeRepositoryLists(child.getRepositories(), parent.getRepositories()));\n    child.setPluginRepositories(ModelUtils.mergeRepositoryLists(child.getPluginRepositories(), parent.getPluginRepositories()));\n    assembleReportingInheritance(child, parent);\n    assembleDependencyManagementInheritance(child, parent);\n    assembleDistributionManagementInheritance(child, parent);\n    Properties props = new Properties();\n    props.putAll(parent.getProperties());\n    props.putAll(child.getProperties());\n    child.setProperties(props);\n}", "code_comment": NaN, "code_no_comment": "private void assembleModelInheritance(Model child, Model parent, String childPathAdjustment, boolean appendPaths) {\n        if (parent == null) {\n        return;\n    }\n        if (child.getGroupId() == null) {\n        child.setGroupId(parent.getGroupId());\n    }\n        if (child.getVersion() == null) {\n        if (child.getParent() != null) {\n            child.setVersion(child.getParent().getVersion());\n        }\n    }\n        if (child.getInceptionYear() == null) {\n        child.setInceptionYear(parent.getInceptionYear());\n    }\n        if (child.getUrl() == null) {\n        if (parent.getUrl() != null) {\n            child.setUrl(appendPath(parent.getUrl(), child.getArtifactId(), childPathAdjustment, appendPaths));\n        } else {\n            child.setUrl(parent.getUrl());\n        }\n    }\n                assembleDistributionInheritence(child, parent, childPathAdjustment, appendPaths);\n        if (child.getIssueManagement() == null) {\n        child.setIssueManagement(parent.getIssueManagement());\n    }\n        if (child.getDescription() == null) {\n        child.setDescription(parent.getDescription());\n    }\n        if (child.getOrganization() == null) {\n        child.setOrganization(parent.getOrganization());\n    }\n        assembleScmInheritance(child, parent, childPathAdjustment, appendPaths);\n        if (child.getCiManagement() == null) {\n        child.setCiManagement(parent.getCiManagement());\n    }\n        if (child.getDevelopers().size() == 0) {\n        child.setDevelopers(parent.getDevelopers());\n    }\n        if (child.getLicenses().size() == 0) {\n        child.setLicenses(parent.getLicenses());\n    }\n        if (child.getContributors().size() == 0) {\n        child.setContributors(parent.getContributors());\n    }\n        if (child.getMailingLists().size() == 0) {\n        child.setMailingLists(parent.getMailingLists());\n    }\n        assembleBuildInheritance(child, parent);\n    assembleDependencyInheritance(child, parent);\n    child.setRepositories(ModelUtils.mergeRepositoryLists(child.getRepositories(), parent.getRepositories()));\n    child.setPluginRepositories(ModelUtils.mergeRepositoryLists(child.getPluginRepositories(), parent.getPluginRepositories()));\n    assembleReportingInheritance(child, parent);\n    assembleDependencyManagementInheritance(child, parent);\n    assembleDistributionManagementInheritance(child, parent);\n    Properties props = new Properties();\n    props.putAll(parent.getProperties());\n    props.putAll(child.getProperties());\n    child.setProperties(props);\n}", "lc": 2.090909090909091, "pi": -0.23923444976076558, "ma": 2.4, "nbd": 0.0, "ml": 2.0833333333333335, "d": 0.23809523809523808, "mi": -1.021705426356589, "fo": 5.083333333333333, "r": -0.02631578947368421, "e": 1.3685724658978924}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-3281_f7dd2fff", "label": 1, "code": "/**\n * <a href=\"http://camel.apache.org/exception-clause.html\">Exception clause</a>\n * for catching certain exceptions and handling them.\n *\n * @param exception exception to catch\n * @return the builder\n */\npublic OnExceptionDefinition onException(Class exception) {\n    routeCollection.setCamelContext(getContext());\n    return routeCollection.onException(exception);\n}", "code_comment": "/**\n * <a href=\"http://camel.apache.org/exception-clause.html\">Exception clause</a>\n * for catching certain exceptions and handling them.\n *\n * @param exception exception to catch\n * @return the builder\n */\n", "code_no_comment": "public OnExceptionDefinition onException(Class exception) {\n    routeCollection.setCamelContext(getContext());\n    return routeCollection.onException(exception);\n}", "lc": -0.45454545454545453, "pi": -0.47368421052631593, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.8255109231853415, "fo": -0.25, "r": 2.3947368421052633, "e": -0.16279340490885932}
{"project_name": "Cli", "project_version": 26, "label": 3, "code": "/**\n * Create an Option using the current settings and with\n * the specified Option <code>char</code>.\n *\n * @param opt the <code>java.lang.String</code> representation\n * of the Option\n * @return the Option instance\n * @throws IllegalArgumentException if <code>opt</code> is not\n * a valid character.  See Option.\n */\npublic static Option create(String opt) throws IllegalArgumentException {\n    // create the option\n    Option option = new Option(opt, description);\n    // set the option properties\n    option.setLongOpt(longopt);\n    option.setRequired(required);\n    option.setOptionalArg(optionalArg);\n    option.setArgs(numberOfArgs);\n    option.setType(type);\n    option.setValueSeparator(valuesep);\n    option.setArgName(argName);\n    // reset the OptionBuilder properties\n    OptionBuilder.reset();\n    // return the Option instance\n    return option;\n}", "code_comment": "/**\n * Create an Option using the current settings and with\n * the specified Option <code>char</code>.\n *\n * @param opt the <code>java.lang.String</code> representation\n * of the Option\n * @return the Option instance\n * @throws IllegalArgumentException if <code>opt</code> is not\n * a valid character.  See Option.\n */\n", "code_no_comment": "public static Option create(String opt) throws IllegalArgumentException {\n        Option option = new Option(opt, description);\n        option.setLongOpt(longopt);\n    option.setRequired(required);\n    option.setOptionalArg(optionalArg);\n    option.setArgs(numberOfArgs);\n    option.setType(type);\n    option.setValueSeparator(valuesep);\n    option.setArgName(argName);\n        OptionBuilder.reset();\n        return option;\n}", "lc": -0.09090909090909091, "pi": -0.7177033492822968, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.08611698379140256, "fo": 0.16666666666666666, "r": 0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1822_016df669", "label": 1, "code": "/**\n * Add a new or update an existing map entry.\n * The property is a map of revisions / values.\n *\n * @param property the property\n * @param revision the revision\n * @param value the value\n */\nvoid setMapEntry(@Nonnull String property, @Nonnull Revision revision, Object value) {\n    Operation op = new Operation();\n    op.type = Operation.Type.SET_MAP_ENTRY;\n    op.value = value;\n    changes.put(new Key(property, checkNotNull(revision)), op);\n}", "code_comment": "/**\n * Add a new or update an existing map entry.\n * The property is a map of revisions / values.\n *\n * @param property the property\n * @param revision the revision\n * @param value the value\n */\n", "code_no_comment": "void setMapEntry(@Nonnull String property, @Nonnull Revision revision, Object value) {\n    Operation op = new Operation();\n    op.type = Operation.Type.SET_MAP_ENTRY;\n    op.value = value;\n    changes.put(new Key(property, checkNotNull(revision)), op);\n}", "lc": -0.36363636363636365, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.437632135306554, "fo": -0.3333333333333333, "r": 1.9736842105263157, "e": -0.16279340490885932}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2389_0fa892b3", "label": 1, "code": "/**\n * Escape a string into the target buffer.\n *\n * @param s      the string to escape\n * @param length the number of characters.\n * @param buff   the target buffer\n */\nprivate static void escape(String s, int length, StringBuilder buff) {\n    for (int i = 0; i < length; i++) {\n        char c = s.charAt(i);\n        int ic = (int) c;\n        switch(c) {\n            case '\"':\n                // quotation mark\n                buff.append(\"\\\\\\\"\");\n                break;\n            case '\\\\':\n                // backslash\n                buff.append(\"\\\\\\\\\");\n                break;\n            case '\\b':\n                // backspace\n                buff.append(\"\\\\b\");\n                break;\n            case '\\f':\n                // formfeed\n                buff.append(\"\\\\f\");\n                break;\n            case '\\n':\n                // newline\n                buff.append(\"\\\\n\");\n                break;\n            case '\\r':\n                // carriage return\n                buff.append(\"\\\\r\");\n                break;\n            case '\\t':\n                // horizontal tab\n                buff.append(\"\\\\t\");\n                break;\n            default:\n                if (c < ' ') {\n                    buff.append(String.format(\"\\\\u%04x\", ic));\n                } else if (ic >= 0xD800 && ic <= 0xDBFF) {\n                    // isSurrogate(), only available in Java 7\n                    if (i < length - 1 && Character.isSurrogatePair(c, s.charAt(i + 1))) {\n                        // ok surrogate\n                        buff.append(c);\n                        buff.append(s.charAt(i + 1));\n                        i += 1;\n                    } else {\n                        // broken surrogate -> escape\n                        buff.append(String.format(\"\\\\u%04x\", ic));\n                    }\n                } else {\n                    buff.append(c);\n                }\n        }\n    }\n}", "code_comment": "/**\n * Escape a string into the target buffer.\n *\n * @param s      the string to escape\n * @param length the number of characters.\n * @param buff   the target buffer\n */\n", "code_no_comment": "private static void escape(String s, int length, StringBuilder buff) {\n    for (int i = 0; i < length; i++) {\n        char c = s.charAt(i);\n        int ic = (int) c;\n        switch(c) {\n            case '\"':\n                                buff.append(\"\\\\\\\"\");\n                break;\n            case '\\\\':\n                                buff.append(\"\\\\\\\\\");\n                break;\n            case '\\b':\n                                buff.append(\"\\\\b\");\n                break;\n            case '\\f':\n                                buff.append(\"\\\\f\");\n                break;\n            case '\\n':\n                                buff.append(\"\\\\n\");\n                break;\n            case '\\r':\n                                buff.append(\"\\\\r\");\n                break;\n            case '\\t':\n                                buff.append(\"\\\\t\");\n                break;\n            default:\n                if (c < ' ') {\n                    buff.append(String.format(\"\\\\u%04x\", ic));\n                } else if (ic >= 0xD800 && ic <= 0xDBFF) {\n                                        if (i < length - 1 && Character.isSurrogatePair(c, s.charAt(i + 1))) {\n                                                buff.append(c);\n                        buff.append(s.charAt(i + 1));\n                        i += 1;\n                    } else {\n                                                buff.append(String.format(\"\\\\u%04x\", ic));\n                    }\n                } else {\n                    buff.append(c);\n                }\n        }\n    }\n}", "lc": 1.3181818181818181, "pi": 1.3110047846889954, "ma": 3.2, "nbd": 2.0, "ml": 1.1666666666666667, "d": 1.6527777777777777, "mi": -0.7992952783650458, "fo": 1.0, "r": -0.02631578947368421, "e": 2.499742397261458}
{"project_name": "Closure", "project_version": 113, "label": 2, "code": "/**\n * Handles a goog.require call.\n */\nprivate void processRequireCall(NodeTraversal t, Node n, Node parent) {\n    Node left = n.getFirstChild();\n    Node arg = left.getNext();\n    if (verifyLastArgumentIsString(t, left, arg)) {\n        String ns = arg.getString();\n        ProvidedName provided = providedNames.get(ns);\n        if (provided == null || !provided.isExplicitlyProvided()) {\n            unrecognizedRequires.add(new UnrecognizedRequire(n, ns, t.getSourceName()));\n        } else {\n            JSModule providedModule = provided.explicitModule;\n            // This must be non-null, because there was an explicit provide.\n            Preconditions.checkNotNull(providedModule);\n            JSModule module = t.getModule();\n            if (moduleGraph != null && module != providedModule && !moduleGraph.dependsOn(module, providedModule)) {\n                compiler.report(t.makeError(n, XMODULE_REQUIRE_ERROR, ns, providedModule.getName(), module.getName()));\n            }\n        }\n        maybeAddToSymbolTable(left);\n        maybeAddStringNodeToSymbolTable(arg);\n        // let them be caught in the subsequent run.\n        if (provided != null) {\n            parent.detachFromParent();\n            compiler.reportCodeChange();\n        }\n    }\n}", "code_comment": "/**\n * Handles a goog.require call.\n */\n", "code_no_comment": "private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n    Node left = n.getFirstChild();\n    Node arg = left.getNext();\n    if (verifyLastArgumentIsString(t, left, arg)) {\n        String ns = arg.getString();\n        ProvidedName provided = providedNames.get(ns);\n        if (provided == null || !provided.isExplicitlyProvided()) {\n            unrecognizedRequires.add(new UnrecognizedRequire(n, ns, t.getSourceName()));\n        } else {\n            JSModule providedModule = provided.explicitModule;\n                        Preconditions.checkNotNull(providedModule);\n            JSModule module = t.getModule();\n            if (moduleGraph != null && module != providedModule && !moduleGraph.dependsOn(module, providedModule)) {\n                compiler.report(t.makeError(n, XMODULE_REQUIRE_ERROR, ns, providedModule.getName(), module.getName()));\n            }\n        }\n        maybeAddToSymbolTable(left);\n        maybeAddStringNodeToSymbolTable(arg);\n                if (provided != null) {\n            parent.detachFromParent();\n            compiler.reportCodeChange();\n        }\n    }\n}", "lc": 0.45454545454545453, "pi": 0.47846889952153115, "ma": 0.2, "nbd": 0.5, "ml": 1.0, "d": 0.7420634920634921, "mi": -0.42663847780126857, "fo": 1.0833333333333333, "r": -0.02631578947368421, "e": 1.2097508687609133}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-738_8ed779dc", "label": 1, "code": "@Override\n@Nonnull\npublic Node addNode(final String relPath, final String primaryNodeTypeName) throws RepositoryException {\n    return perform(new ItemWriteOperation<Node>() {\n\n        @Override\n        protected void checkPreconditions() throws RepositoryException {\n            super.checkPreconditions();\n            SessionImpl.checkIndexOnName(sessionContext, relPath);\n        }\n\n        @Override\n        public Node perform() throws RepositoryException {\n            String oakPath = sessionContext.getOakPathOrThrowNotFound(relPath);\n            String oakName = PathUtils.getName(oakPath);\n            String parentPath = PathUtils.getParentPath(oakPath);\n            NodeDelegate parent = dlg.getChild(parentPath);\n            if (parent == null) {\n                // is it a property?\n                String grandParentPath = PathUtils.getParentPath(parentPath);\n                NodeDelegate grandParent = dlg.getChild(grandParentPath);\n                if (grandParent != null) {\n                    String propName = PathUtils.getName(parentPath);\n                    if (grandParent.getPropertyOrNull(propName) != null) {\n                        throw new ConstraintViolationException(\"Can't add new node to property.\");\n                    }\n                }\n                throw new PathNotFoundException(relPath);\n            }\n            if (parent.getChild(oakName) != null) {\n                throw new ItemExistsException(relPath);\n            }\n            String ntName = primaryNodeTypeName;\n            if (ntName == null) {\n                DefinitionProvider dp = getDefinitionProvider();\n                String childName = getOakName(PathUtils.getName(relPath));\n                NodeDefinition def = dp.getDefinition(parent.getTree(), childName);\n                ntName = def.getDefaultPrimaryTypeName();\n                if (ntName == null) {\n                    throw new ConstraintViolationException(\"no matching child node definition found for \" + relPath);\n                }\n            }\n            // TODO: figure out the right place for this check\n            // throws on not found\n            NodeType nt = getNodeTypeManager().getNodeType(ntName);\n            if (nt.isAbstract() || nt.isMixin()) {\n                throw new ConstraintViolationException();\n            }\n            // TODO: END\n            NodeDelegate added = parent.addChild(oakName);\n            if (added == null) {\n                throw new ItemExistsException();\n            }\n            if (getPrimaryNodeType().hasOrderableChildNodes()) {\n                dlg.setOrderableChildren(true);\n            }\n            NodeImpl<?> childNode = new NodeImpl<NodeDelegate>(added, sessionContext);\n            childNode.internalSetPrimaryType(ntName);\n            childNode.autoCreateItems();\n            return childNode;\n        }\n    });\n}", "code_comment": NaN, "code_no_comment": "@Override\n@Nonnull\npublic Node addNode(final String relPath, final String primaryNodeTypeName) throws RepositoryException {\n    return perform(new ItemWriteOperation<Node>() {\n\n        @Override\n        protected void checkPreconditions() throws RepositoryException {\n            super.checkPreconditions();\n            SessionImpl.checkIndexOnName(sessionContext, relPath);\n        }\n\n        @Override\n        public Node perform() throws RepositoryException {\n            String oakPath = sessionContext.getOakPathOrThrowNotFound(relPath);\n            String oakName = PathUtils.getName(oakPath);\n            String parentPath = PathUtils.getParentPath(oakPath);\n            NodeDelegate parent = dlg.getChild(parentPath);\n            if (parent == null) {\n                                String grandParentPath = PathUtils.getParentPath(parentPath);\n                NodeDelegate grandParent = dlg.getChild(grandParentPath);\n                if (grandParent != null) {\n                    String propName = PathUtils.getName(parentPath);\n                    if (grandParent.getPropertyOrNull(propName) != null) {\n                        throw new ConstraintViolationException(\"Can't add new node to property.\");\n                    }\n                }\n                throw new PathNotFoundException(relPath);\n            }\n            if (parent.getChild(oakName) != null) {\n                throw new ItemExistsException(relPath);\n            }\n            String ntName = primaryNodeTypeName;\n            if (ntName == null) {\n                DefinitionProvider dp = getDefinitionProvider();\n                String childName = getOakName(PathUtils.getName(relPath));\n                NodeDefinition def = dp.getDefinition(parent.getTree(), childName);\n                ntName = def.getDefaultPrimaryTypeName();\n                if (ntName == null) {\n                    throw new ConstraintViolationException(\"no matching child node definition found for \" + relPath);\n                }\n            }\n                                    NodeType nt = getNodeTypeManager().getNodeType(ntName);\n            if (nt.isAbstract() || nt.isMixin()) {\n                throw new ConstraintViolationException();\n            }\n                        NodeDelegate added = parent.addChild(oakName);\n            if (added == null) {\n                throw new ItemExistsException();\n            }\n            if (getPrimaryNodeType().hasOrderableChildNodes()) {\n                dlg.setOrderableChildren(true);\n            }\n            NodeImpl<?> childNode = new NodeImpl<NodeDelegate>(added, sessionContext);\n            childNode.internalSetPrimaryType(ntName);\n            childNode.autoCreateItems();\n            return childNode;\n        }\n    });\n}", "lc": 1.9545454545454546, "pi": 0.9712918660287079, "ma": 2.4, "nbd": 1.0, "ml": 1.3333333333333333, "d": 0.5297619047619048, "mi": -0.9864693446088794, "fo": 1.8333333333333333, "r": -0.02631578947368421, "e": 1.9373777539576886}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-276_1bf5c550", "label": 1, "code": "@Override\npublic boolean markCommit(Id id) throws Exception {\n    return touch(id, gcStart);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean markCommit(Id id) throws Exception {\n    return touch(id, gcStart);\n}", "lc": -0.45454545454545453, "pi": -0.6028708133971293, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.8548273431994357, "fo": -0.4166666666666667, "r": 1.8157894736842104, "e": -0.16279340490885932}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5265_0eb596df", "label": 1, "code": "@Override\nprotected List<FeedbackMessage> collectMessages(Component panel, IFeedbackMessageFilter filter) {\n    if (fence == null) {\n        return new FeedbackCollector(panel.getPage()) {\n\n            @Override\n            protected boolean shouldRecurseInto(Component component) {\n                return component.getMetaData(FENCE_KEY) == null;\n            }\n        }.collect(filter);\n    } else {\n        return new FeedbackCollector(fence) {\n\n            @Override\n            protected boolean shouldRecurseInto(Component component) {\n                return component.getMetaData(FENCE_KEY) == null;\n            }\n        }.setIncludeSession(false).collect(filter);\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\nprotected List<FeedbackMessage> collectMessages(Component panel, IFeedbackMessageFilter filter) {\n    if (fence == null) {\n        return new FeedbackCollector(panel.getPage()) {\n\n            @Override\n            protected boolean shouldRecurseInto(Component component) {\n                return component.getMetaData(FENCE_KEY) == null;\n            }\n        }.collect(filter);\n    } else {\n        return new FeedbackCollector(fence) {\n\n            @Override\n            protected boolean shouldRecurseInto(Component component) {\n                return component.getMetaData(FENCE_KEY) == null;\n            }\n        }.setIncludeSession(false).collect(filter);\n    }\n}", "lc": 0.18181818181818182, "pi": 0.9952153110047848, "ma": -0.4, "nbd": 0.0, "ml": -0.25, "d": -0.3650793650793651, "mi": -0.11656095842142365, "fo": 0.0, "r": 0.13157894736842105, "e": -0.16279340490885932}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-579_7d72e6ed", "label": 3, "code": "public abstract void restrict(FilterImpl f);", "code_comment": NaN, "code_no_comment": "public abstract void restrict(FilterImpl f);", "lc": -0.5909090909090909, "pi": -1.4306220095693782, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.6663847780126848, "fo": -0.5, "r": 2.552631578947368, "e": -0.16279340490885932}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5582_1fb66533", "label": 1, "code": "@Override\npublic String encodeRedirectURL(CharSequence url) {\n    Args.notNull(url, \"url\");\n    /*\n\t\t  WICKET-4854 - always pass absolute url to the web container for encoding\n\t\t  because when REDIRECT_TO_BUFFER is in use Wicket may render PageB when\n\t\t  PageA is actually the requested one and the web container cannot resolve\n\t\t  the base url properly\n\t\t */\n    UrlRenderer urlRenderer = new UrlRenderer(webRequest);\n    Url relativeUrl = Url.parse(url);\n    String fullUrl = urlRenderer.renderFullUrl(relativeUrl);\n    String encodedFullUrl = httpServletResponse.encodeRedirectURL(fullUrl);\n    final String encodedRelativeUrl;\n    if (fullUrl.equals(encodedFullUrl)) {\n        // no encoding happened so just reuse the relative url\n        encodedRelativeUrl = url.toString();\n    } else {\n        // get the relative url with the jsessionid encoded in it\n        Url _encoded = Url.parse(encodedFullUrl);\n        encodedRelativeUrl = urlRenderer.renderRelativeUrl(_encoded);\n    }\n    return encodedRelativeUrl;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic String encodeRedirectURL(CharSequence url) {\n    Args.notNull(url, \"url\");\n        UrlRenderer urlRenderer = new UrlRenderer(webRequest);\n    Url relativeUrl = Url.parse(url);\n    String fullUrl = urlRenderer.renderFullUrl(relativeUrl);\n    String encodedFullUrl = httpServletResponse.encodeRedirectURL(fullUrl);\n    final String encodedRelativeUrl;\n    if (fullUrl.equals(encodedFullUrl)) {\n                encodedRelativeUrl = url.toString();\n    } else {\n                Url _encoded = Url.parse(encodedFullUrl);\n        encodedRelativeUrl = urlRenderer.renderRelativeUrl(_encoded);\n    }\n    return encodedRelativeUrl;\n}", "lc": 0.09090909090909091, "pi": -0.2583732057416268, "ma": -0.4, "nbd": -0.5, "ml": -0.16666666666666666, "d": -0.3650793650793651, "mi": -0.10951374207188172, "fo": 0.16666666666666666, "r": -0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4488_e6582c52", "label": 1, "code": "/**\n *  Looks up a page by id from the {@link IPageStore}. <br/>\n *  If {@linkplain #pageClass} is specified then compares it against the stored instance class\n *  and returns the found instance only if they match.\n *\n *  @param pageId\n *             the id of the page to look for.\n *  @return the found page instance by id.\n */\nprivate IRequestablePage getStoredPage(final int pageId) {\n    IRequestablePage storedPageInstance = getPageSource().getPageInstance(pageId);\n    if (storedPageInstance != null && (pageClass == null || pageClass.equals(storedPageInstance.getClass()))) {\n        pageInstance = storedPageInstance;\n        pageInstanceIsFresh = false;\n        if (pageInstance != null) {\n            if (renderCount != null && pageInstance.getRenderCount() != renderCount) {\n                throw new StalePageException(pageInstance);\n            }\n        }\n    }\n    return storedPageInstance;\n}", "code_comment": "/**\n *  Looks up a page by id from the {@link IPageStore}. <br/>\n *  If {@linkplain #pageClass} is specified then compares it against the stored instance class\n *  and returns the found instance only if they match.\n *\n *  @param pageId\n *             the id of the page to look for.\n *  @return the found page instance by id.\n */\n", "code_no_comment": "private IRequestablePage getStoredPage(final int pageId) {\n    IRequestablePage storedPageInstance = getPageSource().getPageInstance(pageId);\n    if (storedPageInstance != null && (pageClass == null || pageClass.equals(storedPageInstance.getClass()))) {\n        pageInstance = storedPageInstance;\n        pageInstanceIsFresh = false;\n        if (pageInstance != null) {\n            if (renderCount != null && pageInstance.getRenderCount() != renderCount) {\n                throw new StalePageException(pageInstance);\n            }\n        }\n    }\n    return storedPageInstance;\n}", "lc": -0.045454545454545456, "pi": 0.7416267942583732, "ma": 0.2, "nbd": 0.5, "ml": 0.6666666666666666, "d": 0.3591269841269841, "mi": 0.0069062720225512185, "fo": -0.08333333333333333, "r": 0.631578947368421, "e": 0.15212968885969005}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-3475_7651b777", "label": 1, "code": "public int start() throws IOException {\n    if (configError)\n        return 1;\n    String input;\n    if (isVerbose())\n        printInfo();\n    String home = System.getProperty(\"HOME\");\n    if (home == null)\n        home = System.getenv(\"HOME\");\n    String configDir = home + \"/.accumulo\";\n    String historyPath = configDir + \"/shell_history.txt\";\n    File accumuloDir = new File(configDir);\n    if (!accumuloDir.exists() && !accumuloDir.mkdirs())\n        log.warn(\"Unable to make directory for history at \" + accumuloDir);\n    try {\n        History history = new History();\n        history.setHistoryFile(new File(historyPath));\n        reader.setHistory(history);\n    } catch (IOException e) {\n        log.warn(\"Unable to load history file at \" + historyPath);\n    }\n    ShellCompletor userCompletor = null;\n    if (execFile != null) {\n        java.util.Scanner scanner = new java.util.Scanner(new File(execFile), UTF_8.name());\n        try {\n            while (scanner.hasNextLine() && !hasExited()) {\n                execCommand(scanner.nextLine(), true, isVerbose());\n            }\n        } finally {\n            scanner.close();\n        }\n    } else if (execCommand != null) {\n        for (String command : execCommand.split(\"\\n\")) {\n            execCommand(command, true, isVerbose());\n        }\n        return exitCode;\n    }\n    while (true) {\n        if (hasExited())\n            return exitCode;\n        // If tab completion is true we need to reset\n        if (tabCompletion) {\n            if (userCompletor != null)\n                reader.removeCompletor(userCompletor);\n            userCompletor = setupCompletion();\n            reader.addCompletor(userCompletor);\n        }\n        reader.setDefaultPrompt(getDefaultPrompt());\n        input = reader.readLine();\n        if (input == null) {\n            reader.printNewline();\n            return exitCode;\n        }\n        // user canceled\n        execCommand(input, disableAuthTimeout, false);\n    }\n}", "code_comment": NaN, "code_no_comment": "public int start() throws IOException {\n    if (configError)\n        return 1;\n    String input;\n    if (isVerbose())\n        printInfo();\n    String home = System.getProperty(\"HOME\");\n    if (home == null)\n        home = System.getenv(\"HOME\");\n    String configDir = home + \"/.accumulo\";\n    String historyPath = configDir + \"/shell_history.txt\";\n    File accumuloDir = new File(configDir);\n    if (!accumuloDir.exists() && !accumuloDir.mkdirs())\n        log.warn(\"Unable to make directory for history at \" + accumuloDir);\n    try {\n        History history = new History();\n        history.setHistoryFile(new File(historyPath));\n        reader.setHistory(history);\n    } catch (IOException e) {\n        log.warn(\"Unable to load history file at \" + historyPath);\n    }\n    ShellCompletor userCompletor = null;\n    if (execFile != null) {\n        java.util.Scanner scanner = new java.util.Scanner(new File(execFile), UTF_8.name());\n        try {\n            while (scanner.hasNextLine() && !hasExited()) {\n                execCommand(scanner.nextLine(), true, isVerbose());\n            }\n        } finally {\n            scanner.close();\n        }\n    } else if (execCommand != null) {\n        for (String command : execCommand.split(\"\\n\")) {\n            execCommand(command, true, isVerbose());\n        }\n        return exitCode;\n    }\n    while (true) {\n        if (hasExited())\n            return exitCode;\n                if (tabCompletion) {\n            if (userCompletor != null)\n                reader.removeCompletor(userCompletor);\n            userCompletor = setupCompletion();\n            reader.addCompletor(userCompletor);\n        }\n        reader.setDefaultPrompt(getDefaultPrompt());\n        input = reader.readLine();\n        if (input == null) {\n            reader.printNewline();\n            return exitCode;\n        }\n                execCommand(input, disableAuthTimeout, false);\n    }\n}", "lc": 1.8636363636363635, "pi": 0.25837320574162664, "ma": 2.2, "nbd": 0.5, "ml": 1.75, "d": 0.8154761904761906, "mi": -0.9458773784355176, "fo": 1.9166666666666667, "r": -0.02631578947368421, "e": 2.2925998282648408}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1822_016df669", "label": 1, "code": "/**\n * Increment the value.\n *\n * @param property the key\n * @param value the increment\n */\npublic void increment(@Nonnull String property, long value) {\n    Operation op = new Operation();\n    op.type = Operation.Type.INCREMENT;\n    op.value = value;\n    changes.put(new Key(property, null), op);\n}", "code_comment": "/**\n * Increment the value.\n *\n * @param property the key\n * @param value the increment\n */\n", "code_no_comment": "public void increment(@Nonnull String property, long value) {\n    Operation op = new Operation();\n    op.type = Operation.Type.INCREMENT;\n    op.value = value;\n    changes.put(new Key(property, null), op);\n}", "lc": -0.36363636363636365, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.47202255109231855, "fo": -0.4166666666666667, "r": 2.0526315789473686, "e": -0.16279340490885932}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1178_84fb6b29", "label": 1, "code": "@Override\npublic boolean isNew() {\n    return !isRoot() && !parent.base().hasChildNode(name) && parent.hasChildNode(name);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean isNew() {\n    return !isRoot() && !parent.base().hasChildNode(name) && parent.hasChildNode(name);\n}", "lc": -0.45454545454545453, "pi": -0.6028708133971293, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.0912698412698413, "mi": 0.775334742776603, "fo": -0.16666666666666666, "r": 1.2105263157894737, "e": -0.13331028163413494}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-757_76b7413d", "label": 1, "code": "/**\n * Discards the <code>i</code> last elements of the array.  For example,\n * if the array contains the elements 1,2,3,4, invoking\n * <code>discardMostRecentElements(2)</code> will cause the last two elements\n * to be discarded, leaving 1,2 in the array.  Throws illegalArgumentException\n * if i exceeds numElements.\n *\n * @param i  the number of elements to discard from the end of the array\n * @throws MathIllegalArgumentException if i is greater than numElements.\n * @since 2.0\n */\npublic synchronized void discardMostRecentElements(int i) throws MathIllegalArgumentException {\n    discardExtremeElements(i, false);\n}", "code_comment": "/**\n * Discards the <code>i</code> last elements of the array.  For example,\n * if the array contains the elements 1,2,3,4, invoking\n * <code>discardMostRecentElements(2)</code> will cause the last two elements\n * to be discarded, leaving 1,2 in the array.  Throws illegalArgumentException\n * if i exceeds numElements.\n *\n * @param i  the number of elements to discard from the end of the array\n * @throws MathIllegalArgumentException if i is greater than numElements.\n * @since 2.0\n */\n", "code_no_comment": "public synchronized void discardMostRecentElements(int i) throws MathIllegalArgumentException {\n    discardExtremeElements(i, false);\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.0451021846370678, "fo": -0.4166666666666667, "r": 0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "Math", "project_version": 74, "label": 1, "code": "/**\n * {@inheritDoc}\n */\n@Override\npublic double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException {\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > t0;\n    // create some internal working arrays\n    final int stages = c.length + 1;\n    if (y != y0) {\n        System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n    final double[][] yDotK = new double[stages][y0.length];\n    final double[] yTmp = new double[y0.length];\n    // set up an interpolator sharing the integrator arrays\n    AbstractStepInterpolator interpolator;\n    if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {\n        final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n        rki.reinitialize(this, yTmp, yDotK, forward);\n        interpolator = rki;\n    } else {\n        interpolator = new DummyStepInterpolator(yTmp, forward);\n    }\n    interpolator.storeTime(t0);\n    // set up integration control objects\n    stepStart = t0;\n    double hNew = 0;\n    boolean firstTime = true;\n    for (StepHandler handler : stepHandlers) {\n        handler.reset();\n    }\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n    boolean lastStep = false;\n    // main integration loop\n    while (!lastStep) {\n        interpolator.shift();\n        double error = 0;\n        for (boolean loop = true; loop; ) {\n            if (firstTime || !fsal) {\n                // first stage\n                computeDerivatives(stepStart, y, yDotK[0]);\n            }\n            if (firstTime) {\n                final double[] scale;\n                if (vecAbsoluteTolerance == null) {\n                    scale = new double[y0.length];\n                    java.util.Arrays.fill(scale, scalAbsoluteTolerance);\n                } else {\n                    scale = vecAbsoluteTolerance;\n                }\n                hNew = initializeStep(equations, forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]);\n                firstTime = false;\n            }\n            stepSize = hNew;\n            // next stages\n            for (int k = 1; k < stages; ++k) {\n                for (int j = 0; j < y0.length; ++j) {\n                    double sum = a[k - 1][0] * yDotK[0][j];\n                    for (int l = 1; l < k; ++l) {\n                        sum += a[k - 1][l] * yDotK[l][j];\n                    }\n                    yTmp[j] = y[j] + stepSize * sum;\n                }\n                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);\n            }\n            // estimate the state at the end of the step\n            for (int j = 0; j < y0.length; ++j) {\n                double sum = b[0] * yDotK[0][j];\n                for (int l = 1; l < stages; ++l) {\n                    sum += b[l] * yDotK[l][j];\n                }\n                yTmp[j] = y[j] + stepSize * sum;\n            }\n            // estimate the error at the end of the step\n            error = estimateError(yDotK, y, yTmp, stepSize);\n            if (error <= 1.0) {\n                // discrete events handling\n                interpolator.storeTime(stepStart + stepSize);\n                if (manager.evaluateStep(interpolator)) {\n                    final double dt = manager.getEventTime() - stepStart;\n                    if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                        // rejecting the step would lead to a too small next step, we accept it\n                        loop = false;\n                    } else {\n                        // reject the step to match exactly the next switch time\n                        hNew = dt;\n                    }\n                } else {\n                    // accept the step\n                    loop = false;\n                }\n            } else {\n                // reject the step and attempt to reduce error by stepsize control\n                final double factor = Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(error, exp)));\n                hNew = filterStep(stepSize * factor, forward, false);\n            }\n        }\n        // the step has been accepted\n        final double nextStep = stepStart + stepSize;\n        System.arraycopy(yTmp, 0, y, 0, y0.length);\n        manager.stepAccepted(nextStep, y);\n        lastStep = manager.stop();\n        // provide the step data to the step handler\n        interpolator.storeTime(nextStep);\n        for (StepHandler handler : stepHandlers) {\n            handler.handleStep(interpolator, lastStep);\n        }\n        stepStart = nextStep;\n        if (fsal) {\n            // save the last evaluation for the next step\n            System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n        }\n        if (manager.reset(stepStart, y) && !lastStep) {\n            // some event handler has triggered changes that\n            // invalidate the derivatives, we need to recompute them\n            computeDerivatives(stepStart, y, yDotK[0]);\n        }\n        if (!lastStep) {\n            // in some rare cases we may get here with stepSize = 0, for example\n            // when an event occurs at integration start, reducing the first step\n            // to zero; we have to reset the step to some safe non zero value\n            stepSize = filterStep(stepSize, forward, true);\n            // stepsize control for next step\n            final double factor = Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(error, exp)));\n            final double scaledH = stepSize * factor;\n            final double nextT = stepStart + scaledH;\n            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n            hNew = filterStep(scaledH, forward, nextIsLast);\n        }\n    }\n    final double stopTime = stepStart;\n    resetInternalState();\n    return stopTime;\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "@Override\npublic double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException {\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > t0;\n        final int stages = c.length + 1;\n    if (y != y0) {\n        System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n    final double[][] yDotK = new double[stages][y0.length];\n    final double[] yTmp = new double[y0.length];\n        AbstractStepInterpolator interpolator;\n    if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {\n        final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n        rki.reinitialize(this, yTmp, yDotK, forward);\n        interpolator = rki;\n    } else {\n        interpolator = new DummyStepInterpolator(yTmp, forward);\n    }\n    interpolator.storeTime(t0);\n        stepStart = t0;\n    double hNew = 0;\n    boolean firstTime = true;\n    for (StepHandler handler : stepHandlers) {\n        handler.reset();\n    }\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n    boolean lastStep = false;\n        while (!lastStep) {\n        interpolator.shift();\n        double error = 0;\n        for (boolean loop = true; loop; ) {\n            if (firstTime || !fsal) {\n                                computeDerivatives(stepStart, y, yDotK[0]);\n            }\n            if (firstTime) {\n                final double[] scale;\n                if (vecAbsoluteTolerance == null) {\n                    scale = new double[y0.length];\n                    java.util.Arrays.fill(scale, scalAbsoluteTolerance);\n                } else {\n                    scale = vecAbsoluteTolerance;\n                }\n                hNew = initializeStep(equations, forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]);\n                firstTime = false;\n            }\n            stepSize = hNew;\n                        for (int k = 1; k < stages; ++k) {\n                for (int j = 0; j < y0.length; ++j) {\n                    double sum = a[k - 1][0] * yDotK[0][j];\n                    for (int l = 1; l < k; ++l) {\n                        sum += a[k - 1][l] * yDotK[l][j];\n                    }\n                    yTmp[j] = y[j] + stepSize * sum;\n                }\n                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);\n            }\n                        for (int j = 0; j < y0.length; ++j) {\n                double sum = b[0] * yDotK[0][j];\n                for (int l = 1; l < stages; ++l) {\n                    sum += b[l] * yDotK[l][j];\n                }\n                yTmp[j] = y[j] + stepSize * sum;\n            }\n                        error = estimateError(yDotK, y, yTmp, stepSize);\n            if (error <= 1.0) {\n                                interpolator.storeTime(stepStart + stepSize);\n                if (manager.evaluateStep(interpolator)) {\n                    final double dt = manager.getEventTime() - stepStart;\n                    if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                                                loop = false;\n                    } else {\n                                                hNew = dt;\n                    }\n                } else {\n                                        loop = false;\n                }\n            } else {\n                                final double factor = Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(error, exp)));\n                hNew = filterStep(stepSize * factor, forward, false);\n            }\n        }\n                final double nextStep = stepStart + stepSize;\n        System.arraycopy(yTmp, 0, y, 0, y0.length);\n        manager.stepAccepted(nextStep, y);\n        lastStep = manager.stop();\n                interpolator.storeTime(nextStep);\n        for (StepHandler handler : stepHandlers) {\n            handler.handleStep(interpolator, lastStep);\n        }\n        stepStart = nextStep;\n        if (fsal) {\n                        System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n        }\n        if (manager.reset(stepStart, y) && !lastStep) {\n                                    computeDerivatives(stepStart, y, yDotK[0]);\n        }\n        if (!lastStep) {\n                                                stepSize = filterStep(stepSize, forward, true);\n                        final double factor = Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(error, exp)));\n            final double scaledH = stepSize * factor;\n            final double nextT = stepStart + scaledH;\n            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n            hNew = filterStep(scaledH, forward, nextIsLast);\n        }\n    }\n    final double stopTime = stepStart;\n    resetInternalState();\n    return stopTime;\n}", "lc": 4.409090909090909, "pi": 1.4162679425837321, "ma": 3.6, "nbd": 1.5, "ml": 3.3333333333333335, "d": 4.646825396825397, "mi": -1.4907681465820997, "fo": 2.9166666666666665, "r": -0.02631578947368421, "e": 35.11209695544682}
{"project_name": "JxPath", "project_version": 2, "label": 1, "code": "public Iterator iteratePointers(EvalContext context) {\n    Object result = compute(context);\n    if (result == null) {\n        return Collections.EMPTY_LIST.iterator();\n    }\n    if (result instanceof EvalContext) {\n        return (EvalContext) result;\n    }\n    return new PointerIterator(ValueUtils.iterate(result), new QName(null, \"value\"), context.getRootContext().getCurrentNodePointer().getLocale());\n}", "code_comment": NaN, "code_no_comment": "public Iterator iteratePointers(EvalContext context) {\n    Object result = compute(context);\n    if (result == null) {\n        return Collections.EMPTY_LIST.iterator();\n    }\n    if (result instanceof EvalContext) {\n        return (EvalContext) result;\n    }\n    return new PointerIterator(ValueUtils.iterate(result), new QName(null, \"value\"), context.getRootContext().getCurrentNodePointer().getLocale());\n}", "lc": -0.18181818181818182, "pi": -0.2200956937799045, "ma": -0.2, "nbd": -0.5, "ml": -0.16666666666666666, "d": -0.07738095238095241, "mi": 0.18421423537702594, "fo": 0.0, "r": 0.0, "e": -0.07037914282256531}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3396_c83755c3", "label": 0, "code": "@Nonnull\nprivate ExternalUser createUser(@Nonnull Entry entry, @CheckForNull String id) throws LdapInvalidAttributeValueException {\n    ExternalIdentityRef ref = new ExternalIdentityRef(entry.getDn().getName(), this.getName());\n    if (id == null) {\n        id = entry.get(config.getUserConfig().getIdAttribute()).getString();\n    }\n    String path = config.getUserConfig().makeDnPath() ? createDNPath(entry.getDn()) : null;\n    LdapUser user = new LdapUser(this, ref, id, path);\n    Map<String, Object> props = user.getProperties();\n    applyAttributes(props, entry);\n    return user;\n}", "code_comment": NaN, "code_no_comment": "@Nonnull\nprivate ExternalUser createUser(@Nonnull Entry entry, @CheckForNull String id) throws LdapInvalidAttributeValueException {\n    ExternalIdentityRef ref = new ExternalIdentityRef(entry.getDn().getName(), this.getName());\n    if (id == null) {\n        id = entry.get(config.getUserConfig().getIdAttribute()).getString();\n    }\n    String path = config.getUserConfig().makeDnPath() ? createDNPath(entry.getDn()) : null;\n    LdapUser user = new LdapUser(this, ref, id, path);\n    Map<String, Object> props = user.getProperties();\n    applyAttributes(props, entry);\n    return user;\n}", "lc": -0.09090909090909091, "pi": -0.37320574162679443, "ma": -0.2, "nbd": -0.5, "ml": -0.08333333333333333, "d": -0.021825396825396845, "mi": -0.007751937984496283, "fo": 0.5833333333333334, "r": -0.02631578947368421, "e": 0.06895454781210558}
{"project_name": "Lang", "project_version": 46, "label": 0, "code": "/**\n * <p>Escapes the characters in a <code>String</code> using JavaScript String rules.</p>\n * <p>Escapes any values it finds into their JavaScript String form.\n * Deals correctly with quotes and control-chars (tab, backslash, cr, ff, etc.) </p>\n *\n * <p>So a tab becomes the characters <code>'\\\\'</code> and\n * <code>'t'</code>.</p>\n *\n * <p>The only difference between Java strings and JavaScript strings\n * is that in JavaScript, a single quote must be escaped.</p>\n *\n * <p>Example:\n * <pre>\n * input string: He didn't say, \"Stop!\"\n * output string: He didn\\'t say, \\\"Stop!\\\"\n * </pre>\n * </p>\n *\n * @param str  String to escape values in, may be null\n * @return String with escaped values, <code>null</code> if null string input\n */\npublic static String escapeJavaScript(String str) {\n    return escapeJavaStyleString(str, true);\n}", "code_comment": "/**\n * <p>Escapes the characters in a <code>String</code> using JavaScript String rules.</p>\n * <p>Escapes any values it finds into their JavaScript String form.\n * Deals correctly with quotes and control-chars (tab, backslash, cr, ff, etc.) </p>\n *\n * <p>So a tab becomes the characters <code>'\\\\'</code> and\n * <code>'t'</code>.</p>\n *\n * <p>The only difference between Java strings and JavaScript strings\n * is that in JavaScript, a single quote must be escaped.</p>\n *\n * <p>Example:\n * <pre>\n * input string: He didn't say, \"Stop!\"\n * output string: He didn\\'t say, \\\"Stop!\\\"\n * </pre>\n * </p>\n *\n * @param str  String to escape values in, may be null\n * @return String with escaped values, <code>null</code> if null string input\n */\n", "code_no_comment": "public static String escapeJavaScript(String str) {\n    return escapeJavaStyleString(str, true);\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.0253699788583508, "fo": -0.4166666666666667, "r": 0.31578947368421056, "e": -0.16279340490885932}
{"project_name": "Cli", "project_version": 22, "label": 1, "code": "/**\n * <p>An implementation of {@link Parser}'s abstract\n * {@link Parser#flatten(Options,String[],boolean) flatten} method.</p>\n *\n * <p>The following are the rules used by this flatten method.\n * <ol>\n *  <li>if <code>stopAtNonOption</code> is <b>true</b> then do not\n *  burst anymore of <code>arguments</code> entries, just add each\n *  successive entry without further processing.  Otherwise, ignore\n *  <code>stopAtNonOption</code>.</li>\n *  <li>if the current <code>arguments</code> entry is \"<b>--</b>\"\n *  just add the entry to the list of processed tokens</li>\n *  <li>if the current <code>arguments</code> entry is \"<b>-</b>\"\n *  just add the entry to the list of processed tokens</li>\n *  <li>if the current <code>arguments</code> entry is two characters\n *  in length and the first character is \"<b>-</b>\" then check if this\n *  is a valid {@link Option} id.  If it is a valid id, then add the\n *  entry to the list of processed tokens and set the current {@link Option}\n *  member.  If it is not a valid id and <code>stopAtNonOption</code>\n *  is true, then the remaining entries are copied to the list of\n *  processed tokens.  Otherwise, the current entry is ignored.</li>\n *  <li>if the current <code>arguments</code> entry is more than two\n *  characters in length and the first character is \"<b>-</b>\" then\n *  we need to burst the entry to determine its constituents.  For more\n *  information on the bursting algorithm see\n *  {@link PosixParser#burstToken(String, boolean) burstToken}.</li>\n *  <li>if the current <code>arguments</code> entry is not handled\n *  by any of the previous rules, then the entry is added to the list\n *  of processed tokens.</li>\n * </ol>\n * </p>\n *\n * @param options The command line {@link Options}\n * @param arguments The command line arguments to be parsed\n * @param stopAtNonOption Specifies whether to stop flattening\n * when an non option is found.\n * @return The flattened <code>arguments</code> String array.\n */\nprotected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption) {\n    init();\n    this.options = options;\n    // an iterator for the command line tokens\n    Iterator iter = Arrays.asList(arguments).iterator();\n    // process each command line token\n    while (iter.hasNext()) {\n        // get the next command line token\n        String token = (String) iter.next();\n        // handle long option --foo or --foo=bar\n        if (token.startsWith(\"--\")) {\n            int pos = token.indexOf('=');\n            // --foo\n            String opt = pos == -1 ? token : token.substring(0, pos);\n            if (!options.hasOption(opt)) {\n                processNonOptionToken(token);\n            } else {\n                tokens.add(opt);\n                if (pos != -1) {\n                    tokens.add(token.substring(pos + 1));\n                }\n            }\n        } else // single hyphen\n        if (\"-\".equals(token)) {\n            tokens.add(token);\n        } else if (token.startsWith(\"-\")) {\n            if (token.length() == 2 || options.hasOption(token)) {\n                processOptionToken(token, stopAtNonOption);\n            } else // requires bursting\n            {\n                burstToken(token, stopAtNonOption);\n            }\n        } else if (stopAtNonOption) {\n            processNonOptionToken(token);\n        } else {\n            tokens.add(token);\n        }\n        gobble(iter);\n    }\n    return (String[]) tokens.toArray(new String[tokens.size()]);\n}", "code_comment": "/**\n * <p>An implementation of {@link Parser}'s abstract\n * {@link Parser#flatten(Options,String[],boolean) flatten} method.</p>\n *\n * <p>The following are the rules used by this flatten method.\n * <ol>\n *  <li>if <code>stopAtNonOption</code> is <b>true</b> then do not\n *  burst anymore of <code>arguments</code> entries, just add each\n *  successive entry without further processing.  Otherwise, ignore\n *  <code>stopAtNonOption</code>.</li>\n *  <li>if the current <code>arguments</code> entry is \"<b>--</b>\"\n *  just add the entry to the list of processed tokens</li>\n *  <li>if the current <code>arguments</code> entry is \"<b>-</b>\"\n *  just add the entry to the list of processed tokens</li>\n *  <li>if the current <code>arguments</code> entry is two characters\n *  in length and the first character is \"<b>-</b>\" then check if this\n *  is a valid {@link Option} id.  If it is a valid id, then add the\n *  entry to the list of processed tokens and set the current {@link Option}\n *  member.  If it is not a valid id and <code>stopAtNonOption</code>\n *  is true, then the remaining entries are copied to the list of\n *  processed tokens.  Otherwise, the current entry is ignored.</li>\n *  <li>if the current <code>arguments</code> entry is more than two\n *  characters in length and the first character is \"<b>-</b>\" then\n *  we need to burst the entry to determine its constituents.  For more\n *  information on the bursting algorithm see\n *  {@link PosixParser#burstToken(String, boolean) burstToken}.</li>\n *  <li>if the current <code>arguments</code> entry is not handled\n *  by any of the previous rules, then the entry is added to the list\n *  of processed tokens.</li>\n * </ol>\n * </p>\n *\n * @param options The command line {@link Options}\n * @param arguments The command line arguments to be parsed\n * @param stopAtNonOption Specifies whether to stop flattening\n * when an non option is found.\n * @return The flattened <code>arguments</code> String array.\n */\n", "code_no_comment": "protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption) {\n    init();\n    this.options = options;\n        Iterator iter = Arrays.asList(arguments).iterator();\n        while (iter.hasNext()) {\n                String token = (String) iter.next();\n                if (token.startsWith(\"--\")) {\n            int pos = token.indexOf('=');\n                        String opt = pos == -1 ? token : token.substring(0, pos);\n            if (!options.hasOption(opt)) {\n                processNonOptionToken(token);\n            } else {\n                tokens.add(opt);\n                if (pos != -1) {\n                    tokens.add(token.substring(pos + 1));\n                }\n            }\n        } else         if (\"-\".equals(token)) {\n            tokens.add(token);\n        } else if (token.startsWith(\"-\")) {\n            if (token.length() == 2 || options.hasOption(token)) {\n                processOptionToken(token, stopAtNonOption);\n            } else             {\n                burstToken(token, stopAtNonOption);\n            }\n        } else if (stopAtNonOption) {\n            processNonOptionToken(token);\n        } else {\n            tokens.add(token);\n        }\n        gobble(iter);\n    }\n    return (String[]) tokens.toArray(new String[tokens.size()]);\n}", "lc": 1.0, "pi": 0.8468899521531099, "ma": 1.2, "nbd": 1.5, "ml": 1.3333333333333333, "d": 1.0595238095238095, "mi": -0.6541226215644819, "fo": 1.5833333333333333, "r": -0.02631578947368421, "e": 1.728958120825481}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-631_334c01e6", "label": 1, "code": "/**\n * {@inheritDoc}\n */\nprotected final double doSolve() {\n    // Get initial solution\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    // regardless of the allowed solutions.\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    // Verify bracketing of initial solution.\n    verifyBracketing(x0, x1);\n    // Get accuracies.\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    // Keep track of inverted intervals, meaning that the left bound is\n    // larger than the right bound.\n    boolean inverted = false;\n    // Keep finding better approximations.\n    while (true) {\n        // Calculate the next approximation.\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        // we can return it regardless of the allowed solutions.\n        if (fx == 0.0) {\n            return x;\n        }\n        // Update the bounds with the new approximation.\n        if (f1 * fx < 0) {\n            // We had [x0..x1]. We update it to [x1, x]. Note that the\n            // value of x1 has switched to the other bound, thus inverting\n            // the interval.\n            x0 = x1;\n            f0 = f1;\n            x1 = x;\n            f1 = fx;\n            inverted = !inverted;\n        } else {\n            // We had [x0..x1]. We update it to [x0, x].\n            if (method == Method.ILLINOIS) {\n                f0 *= 0.5;\n            }\n            if (method == Method.PEGASUS) {\n                f0 *= f1 / (f1 + fx);\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        // the root than we already are.\n        if (FastMath.abs(f1) <= ftol) {\n            switch(allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                case BELOW_SIDE:\n                    if (f1 <= 0) {\n                        return x1;\n                    }\n                    break;\n                case ABOVE_SIDE:\n                    if (f1 >= 0) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n        // are satisfied with the current approximation.\n        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {\n            switch(allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                case BELOW_SIDE:\n                    return (f1 <= 0) ? x1 : x0;\n                case ABOVE_SIDE:\n                    return (f1 >= 0) ? x1 : x0;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n    }\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "protected final double doSolve() {\n        double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n        if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n        verifyBracketing(x0, x1);\n        final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n            boolean inverted = false;\n        while (true) {\n                final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n                if (fx == 0.0) {\n            return x;\n        }\n                if (f1 * fx < 0) {\n                                                x0 = x1;\n            f0 = f1;\n            x1 = x;\n            f1 = fx;\n            inverted = !inverted;\n        } else {\n                        if (method == Method.ILLINOIS) {\n                f0 *= 0.5;\n            }\n            if (method == Method.PEGASUS) {\n                f0 *= f1 / (f1 + fx);\n            }\n            x1 = x;\n            f1 = fx;\n        }\n                if (FastMath.abs(f1) <= ftol) {\n            switch(allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                case BELOW_SIDE:\n                    if (f1 <= 0) {\n                        return x1;\n                    }\n                    break;\n                case ABOVE_SIDE:\n                    if (f1 >= 0) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n                if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {\n            switch(allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                case BELOW_SIDE:\n                    return (f1 <= 0) ? x1 : x0;\n                case ABOVE_SIDE:\n                    return (f1 >= 0) ? x1 : x0;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n    }\n}", "lc": 3.1818181818181817, "pi": 1.6507177033492826, "ma": 6.4, "nbd": 1.5, "ml": 3.0833333333333335, "d": 2.9503968253968256, "mi": -1.2849894291754753, "fo": 0.5833333333333334, "r": -0.02631578947368421, "e": 7.190795456510086}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4338_9decad35", "label": 3, "code": "/**\n *  @see org.apache.wicket.request.mapper.parameter.IPageParametersEncoder#decodePageParameters(org.apache.wicket.request.Request)\n */\npublic PageParameters decodePageParameters(final Request request) {\n    PageParameters parameters = new PageParameters();\n    int i = 0;\n    for (String s : request.getUrl().getSegments()) {\n        parameters.set(i, s);\n        ++i;\n    }\n    for (QueryParameter p : request.getUrl().getQueryParameters()) {\n        parameters.add(p.getName(), p.getValue());\n    }\n    return parameters.isEmpty() ? null : parameters;\n}", "code_comment": "/**\n *  @see org.apache.wicket.request.mapper.parameter.IPageParametersEncoder#decodePageParameters(org.apache.wicket.request.Request)\n */\n", "code_no_comment": "public PageParameters decodePageParameters(final Request request) {\n    PageParameters parameters = new PageParameters();\n    int i = 0;\n    for (String s : request.getUrl().getSegments()) {\n        parameters.set(i, s);\n        ++i;\n    }\n    for (QueryParameter p : request.getUrl().getQueryParameters()) {\n        parameters.add(p.getName(), p.getValue());\n    }\n    return parameters.isEmpty() ? null : parameters;\n}", "lc": -0.09090909090909091, "pi": -0.20574162679425848, "ma": 0.0, "nbd": -0.5, "ml": -0.25, "d": -0.03373015873015876, "mi": 0.06243833685694159, "fo": 0.25, "r": -0.02631578947368421, "e": -0.03071177884199789}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-1069_e9b628ec", "label": 3, "code": "@Override\nprotected int[] getEventIndices(final String text, final int beginIndex) {\n    // Scan the text for the end of the next JSON object.\n    final int start = text.indexOf(EVENT_START_MARKER, beginIndex);\n    if (start == END) {\n        return END_PAIR;\n    }\n    final char[] charArray = text.toCharArray();\n    int stack = 0;\n    boolean inStr = false;\n    boolean inEsc = false;\n    for (int i = start; i < charArray.length; i++) {\n        final char c = charArray[i];\n        if (!inEsc) {\n            inEsc = false;\n            switch(c) {\n                case EVENT_START_MARKER:\n                    if (!inStr) {\n                        stack++;\n                    }\n                    break;\n                case EVENT_END_MARKER:\n                    if (!inStr) {\n                        stack--;\n                    }\n                    break;\n                case JSON_STR_DELIM:\n                    inStr = !inStr;\n                    break;\n                case JSON_ESC:\n                    inEsc = true;\n                    break;\n            }\n            if (stack == 0) {\n                return new int[] { start, i };\n            }\n        }\n    }\n    return END_PAIR;\n}", "code_comment": NaN, "code_no_comment": "@Override\nprotected int[] getEventIndices(final String text, final int beginIndex) {\n        final int start = text.indexOf(EVENT_START_MARKER, beginIndex);\n    if (start == END) {\n        return END_PAIR;\n    }\n    final char[] charArray = text.toCharArray();\n    int stack = 0;\n    boolean inStr = false;\n    boolean inEsc = false;\n    for (int i = start; i < charArray.length; i++) {\n        final char c = charArray[i];\n        if (!inEsc) {\n            inEsc = false;\n            switch(c) {\n                case EVENT_START_MARKER:\n                    if (!inStr) {\n                        stack++;\n                    }\n                    break;\n                case EVENT_END_MARKER:\n                    if (!inStr) {\n                        stack--;\n                    }\n                    break;\n                case JSON_STR_DELIM:\n                    inStr = !inStr;\n                    break;\n                case JSON_ESC:\n                    inEsc = true;\n                    break;\n            }\n            if (stack == 0) {\n                return new int[] { start, i };\n            }\n        }\n    }\n    return END_PAIR;\n}", "lc": 1.1363636363636365, "pi": 2.1148325358851676, "ma": 2.2, "nbd": 1.5, "ml": 1.0, "d": 0.8968253968253969, "mi": -0.6560958421423537, "fo": -0.3333333333333333, "r": 0.1842105263157895, "e": 0.8976446926344057}
{"project_name": "Lang", "project_version": 47, "label": 1, "code": "/**\n * Appends an object to the builder padding on the right to a fixed length.\n * The <code>toString</code> of the object is used.\n * If the object is larger than the length, the right hand side is lost.\n * If the object is null, null text value is used.\n *\n * @param obj  the object to append, null uses null text\n * @param width  the fixed field width, zero or negative has no effect\n * @param padChar  the pad character to use\n * @return this, to enable chaining\n */\npublic StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}", "code_comment": "/**\n * Appends an object to the builder padding on the right to a fixed length.\n * The <code>toString</code> of the object is used.\n * If the object is larger than the length, the right hand side is lost.\n * If the object is null, null text value is used.\n *\n * @param obj  the object to append, null uses null text\n * @param width  the fixed field width, zero or negative has no effect\n * @param padChar  the pad character to use\n * @return this, to enable chaining\n */\n", "code_no_comment": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}", "lc": 0.18181818181818182, "pi": 0.5885167464114831, "ma": 0.2, "nbd": 0.5, "ml": 0.3333333333333333, "d": 1.5615079365079367, "mi": -0.2197322057787174, "fo": 0.0, "r": -0.02631578947368421, "e": 1.2656512393169779}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-217_add180fb", "label": 1, "code": "@Override\npublic void addSplits(String tableName, SortedSet<Text> partitionKeys) throws TableNotFoundException, AccumuloException, AccumuloSecurityException {\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void addSplits(String tableName, SortedSet<Text> partitionKeys) throws TableNotFoundException, AccumuloException, AccumuloSecurityException {\n}", "lc": -0.5, "pi": -1.4306220095693782, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.9360112755461594, "fo": -0.5, "r": 0.10526315789473684, "e": -0.16279340490885932}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-9444_baece126", "label": 1, "code": "@Override\npublic boolean process(Exchange exchange, final AsyncCallback callback) {\n    final AggregationStrategy strategy = getAggregationStrategy();\n    // to ensure it supports async routing\n    if (strategy == null) {\n        UseOriginalAggregationStrategy original = new UseOriginalAggregationStrategy(exchange, true);\n        setAggregationStrategyOnExchange(exchange, original);\n    }\n    return super.process(exchange, callback);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean process(Exchange exchange, final AsyncCallback callback) {\n    final AggregationStrategy strategy = getAggregationStrategy();\n        if (strategy == null) {\n        UseOriginalAggregationStrategy original = new UseOriginalAggregationStrategy(exchange, true);\n        setAggregationStrategyOnExchange(exchange, original);\n    }\n    return super.process(exchange, callback);\n}", "lc": -0.22727272727272727, "pi": -0.01913875598086126, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": -0.06150793650793652, "mi": 0.27723749119097973, "fo": -0.25, "r": 0.6578947368421053, "e": -0.08766791722134817}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-1496_0a4c7694", "label": 1, "code": "/**\n *  Returns the total number of input channels for this reader.\n *  <p>\n *  Note: This number might be smaller the current number of input channels\n *  of the reader as channels are possibly updated during runtime.\n */\npublic int getNumberOfInputChannels() {\n    return totalNumberOfInputChannels;\n}", "code_comment": "/**\n *  Returns the total number of input channels for this reader.\n *  <p>\n *  Note: This number might be smaller the current number of input channels\n *  of the reader as channels are possibly updated during runtime.\n */\n", "code_no_comment": "public int getNumberOfInputChannels() {\n    return totalNumberOfInputChannels;\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.2407329105003524, "fo": -0.5, "r": 2.6052631578947367, "e": -0.16279340490885932}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5466_c1c1f794", "label": 1, "code": "/**\n *  @see org.apache.wicket.request.IRequestHandler#respond(org.apache.wicket.request.IRequestCycle)\n */\n@Override\npublic void respond(final IRequestCycle requestCycle) {\n    final IRequestablePage page = getPage();\n    final boolean freshPage = pageComponentProvider.isPageInstanceFresh();\n    final boolean isAjax = ((WebRequest) requestCycle.getRequest()).isAjax();\n    IRequestableComponent component;\n    try {\n        component = getComponent();\n    } catch (ComponentNotFoundException e) {\n        // either the page is stateless and the component we are looking for is not added in the\n        // constructor\n        // or the page is stateful+stale and a new instances was created by pageprovider\n        // we denote this by setting component to null\n        component = null;\n    }\n    if ((component == null && freshPage) || (component != null && getComponent().getPage() == page)) {\n        if (page instanceof Page) {\n            // initialize the page to be able to check whether it is stateless\n            ((Page) page).internalInitialize();\n        }\n        final boolean isStateless = page.isPageStateless();\n        RedirectPolicy policy = isStateless ? RedirectPolicy.NEVER_REDIRECT : RedirectPolicy.AUTO_REDIRECT;\n        final IPageProvider pageProvider = new PageProvider(page);\n        if (freshPage && (isStateless == false || component == null)) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"A ListenerInterface '{}' assigned to '{}' is executed on an expired stateful page. \" + \"Scheduling re-create of the page and ignoring the listener interface...\", listenerInterface, getComponentPath());\n            }\n            if (isAjax) {\n                policy = RedirectPolicy.ALWAYS_REDIRECT;\n            }\n            requestCycle.scheduleRequestHandlerAfterCurrent(new RenderPageRequestHandler(pageProvider, policy));\n            return;\n        }\n        if (isAjax == false && listenerInterface.isRenderPageAfterInvocation()) {\n            // schedule page render after current request handler is done. this can be\n            // overridden during invocation of listener\n            // method (i.e. by calling RequestCycle#setResponsePage)\n            requestCycle.scheduleRequestHandlerAfterCurrent(new RenderPageRequestHandler(pageProvider, policy));\n        }\n        invokeListener();\n    } else {\n        throw new WicketRuntimeException(\"Component \" + getComponent() + \" has been removed from page.\");\n    }\n}", "code_comment": "/**\n *  @see org.apache.wicket.request.IRequestHandler#respond(org.apache.wicket.request.IRequestCycle)\n */\n", "code_no_comment": "@Override\npublic void respond(final IRequestCycle requestCycle) {\n    final IRequestablePage page = getPage();\n    final boolean freshPage = pageComponentProvider.isPageInstanceFresh();\n    final boolean isAjax = ((WebRequest) requestCycle.getRequest()).isAjax();\n    IRequestableComponent component;\n    try {\n        component = getComponent();\n    } catch (ComponentNotFoundException e) {\n                                        component = null;\n    }\n    if ((component == null && freshPage) || (component != null && getComponent().getPage() == page)) {\n        if (page instanceof Page) {\n                        ((Page) page).internalInitialize();\n        }\n        final boolean isStateless = page.isPageStateless();\n        RedirectPolicy policy = isStateless ? RedirectPolicy.NEVER_REDIRECT : RedirectPolicy.AUTO_REDIRECT;\n        final IPageProvider pageProvider = new PageProvider(page);\n        if (freshPage && (isStateless == false || component == null)) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"A ListenerInterface '{}' assigned to '{}' is executed on an expired stateful page. \" + \"Scheduling re-create of the page and ignoring the listener interface...\", listenerInterface, getComponentPath());\n            }\n            if (isAjax) {\n                policy = RedirectPolicy.ALWAYS_REDIRECT;\n            }\n            requestCycle.scheduleRequestHandlerAfterCurrent(new RenderPageRequestHandler(pageProvider, policy));\n            return;\n        }\n        if (isAjax == false && listenerInterface.isRenderPageAfterInvocation()) {\n                                                requestCycle.scheduleRequestHandlerAfterCurrent(new RenderPageRequestHandler(pageProvider, policy));\n        }\n        invokeListener();\n    } else {\n        throw new WicketRuntimeException(\"Component \" + getComponent() + \" has been removed from page.\");\n    }\n}", "lc": 1.0, "pi": 0.5263157894736841, "ma": 1.2, "nbd": 0.5, "ml": 1.3333333333333333, "d": 0.736111111111111, "mi": -0.6684989429175475, "fo": 0.9166666666666666, "r": -0.02631578947368421, "e": 1.450323011935017}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1977_4bfbfcdd", "label": 1, "code": "@Override\npublic Iterator<String> iterator() {\n    PathIterator pi = new PathIterator(filter, indexName);\n    pi.setPathContainsValue(true);\n    pi.enqueue(children.iterator());\n    return pi;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic Iterator<String> iterator() {\n    PathIterator pi = new PathIterator(filter, indexName);\n    pi.setPathContainsValue(true);\n    pi.enqueue(children.iterator());\n    return pi;\n}", "lc": -0.3181818181818182, "pi": -0.48325358851674655, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.45482734319943624, "fo": -0.25, "r": 0.2631578947368421, "e": -0.16279340490885932}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-217_add180fb", "label": 1, "code": "@Override\npublic Collection<Text> getSplits(String tableName, int maxSplits) {\n    return Collections.emptyList();\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic Collection<Text> getSplits(String tableName, int maxSplits) {\n    return Collections.emptyList();\n}", "lc": -0.45454545454545453, "pi": -0.6028708133971293, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.8246652572233965, "fo": -0.4166666666666667, "r": 0.763157894736842, "e": -0.16279340490885932}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-5137_afa1d132", "label": 3, "code": "@Override\npublic void run() {\n    try {\n        long count = counter.incrementAndGet();\n        boolean fire = endpoint.getRepeatCount() <= 0 || count <= endpoint.getRepeatCount();\n        if (fire) {\n            sendTimerExchange(count);\n        } else {\n            // no need to fire anymore as we exceeded repeat count\n            LOG.debug(\"Cancelling {} timer as repeat count limit reached after {} counts.\", endpoint.getTimerName(), endpoint.getRepeatCount());\n            cancel();\n        }\n    } catch (Throwable e) {\n        // catch all to avoid the JVM closing the thread and not firing again\n        LOG.warn(\"Error processing exchange. This exception will be ignored, to let the timer be able to trigger again.\", e);\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void run() {\n    try {\n        long count = counter.incrementAndGet();\n        boolean fire = endpoint.getRepeatCount() <= 0 || count <= endpoint.getRepeatCount();\n        if (fire) {\n            sendTimerExchange(count);\n        } else {\n                        LOG.debug(\"Cancelling {} timer as repeat count limit reached after {} counts.\", endpoint.getTimerName(), endpoint.getRepeatCount());\n            cancel();\n        }\n    } catch (Throwable e) {\n                LOG.warn(\"Error processing exchange. This exception will be ignored, to let the timer be able to trigger again.\", e);\n    }\n}", "lc": 0.045454545454545456, "pi": 0.5215311004784688, "ma": -0.2, "nbd": 0.0, "ml": -0.25, "d": -0.06746031746031747, "mi": -0.021000704721635077, "fo": 0.25, "r": 0.0, "e": -0.0533024440564075}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-428_916cd92f", "label": 1, "code": "/**\n * Splits a {@code jsonString}, which is prefixed with a type code\n * at the location where the prefix ends.\n * @param jsonString  json string to split\n * @return  the location where the prefix ends or -1 if no prefix is present\n */\npublic static int split(String jsonString) {\n    if (jsonString.length() >= 4 && jsonString.charAt(3) == ':') {\n        return 3;\n    } else {\n        return -1;\n    }\n}", "code_comment": "/**\n * Splits a {@code jsonString}, which is prefixed with a type code\n * at the location where the prefix ends.\n * @param jsonString  json string to split\n * @return  the location where the prefix ends or -1 if no prefix is present\n */\n", "code_no_comment": "public static int split(String jsonString) {\n    if (jsonString.length() >= 4 && jsonString.charAt(3) == ':') {\n        return 3;\n    } else {\n        return -1;\n    }\n}", "lc": -0.3181818181818182, "pi": 0.01435406698564584, "ma": -0.4, "nbd": -0.5, "ml": -0.08333333333333333, "d": 0.15079365079365079, "mi": 0.4646934460887948, "fo": -0.3333333333333333, "r": 2.263157894736842, "e": -0.0852059957469615}
{"project_name": "JxPath", "project_version": 21, "label": 0, "code": "/**\n * If the property contains a collection, then the length of that\n * collection, otherwise - 1.\n * @return int length\n */\npublic int getLength() {\n    return ValueUtils.getLength(getBaseValue());\n}", "code_comment": "/**\n * If the property contains a collection, then the length of that\n * collection, otherwise - 1.\n * @return int length\n */\n", "code_no_comment": "public int getLength() {\n    return ValueUtils.getLength(getBaseValue());\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.1319238900634248, "fo": -0.3333333333333333, "r": 2.5789473684210527, "e": -0.16279340490885932}
{"project_name": "Closure", "project_version": 155, "label": 2, "code": "// Any reference that is not a read of the arguments property\n// consider a escape of the arguments object.\nprivate void inlineNonConstants(Var v, ReferenceCollection referenceInfo) {\n    int refCount = referenceInfo.references.size();\n    Reference declaration = referenceInfo.references.get(0);\n    Reference init = referenceInfo.getInitializingReference();\n    int firstRefAfterInit = (declaration == init) ? 2 : 3;\n    if (refCount > 1 && isImmutableAndWellDefinedVariable(v, referenceInfo)) {\n        // if the variable is referenced more than once, we can only\n        // inline it if it's immutable and never defined before referenced.\n        Node value;\n        if (init != null) {\n            value = init.getAssignedValue();\n        } else {\n            // Create a new node for variable that is never initialized.\n            Node srcLocation = declaration.getNameNode();\n            value = NodeUtil.newUndefinedNode(srcLocation);\n        }\n        Preconditions.checkNotNull(value);\n        inlineWellDefinedVariable(v, value, referenceInfo.references);\n        staleVars.add(v);\n    } else if (refCount == firstRefAfterInit) {\n        // The variable likely only read once, try some more\n        // complex inlining heuristics.\n        Reference reference = referenceInfo.references.get(firstRefAfterInit - 1);\n        if (canInline(declaration, init, reference)) {\n            inline(v, declaration, init, reference);\n            staleVars.add(v);\n        }\n    } else if (declaration != init && refCount == 2) {\n        if (isValidDeclaration(declaration) && isValidInitialization(init)) {\n            // The only reference is the initialization, remove the assignment and\n            // the variable declaration.\n            Node value = init.getAssignedValue();\n            Preconditions.checkNotNull(value);\n            inlineWellDefinedVariable(v, value, referenceInfo.references);\n            staleVars.add(v);\n        }\n    }\n    // the next pass.)\n    if (!staleVars.contains(v) && referenceInfo.isWellDefined() && referenceInfo.isAssignedOnceInLifetime()) {\n        List<Reference> refs = referenceInfo.references;\n        for (int i = 1; /* start from a read */\n        i < refs.size(); i++) {\n            Node nameNode = refs.get(i).getNameNode();\n            if (aliasCandidates.containsKey(nameNode)) {\n                AliasCandidate candidate = aliasCandidates.get(nameNode);\n                if (!staleVars.contains(candidate.alias) && !isVarInlineForbidden(candidate.alias)) {\n                    Reference aliasInit;\n                    aliasInit = candidate.refInfo.getInitializingReference();\n                    Node value = aliasInit.getAssignedValue();\n                    Preconditions.checkNotNull(value);\n                    inlineWellDefinedVariable(candidate.alias, value, candidate.refInfo.references);\n                    staleVars.add(candidate.alias);\n                }\n            }\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "private void inlineNonConstants(Var v, ReferenceCollection referenceInfo) {\n    int refCount = referenceInfo.references.size();\n    Reference declaration = referenceInfo.references.get(0);\n    Reference init = referenceInfo.getInitializingReference();\n    int firstRefAfterInit = (declaration == init) ? 2 : 3;\n    if (refCount > 1 && isImmutableAndWellDefinedVariable(v, referenceInfo)) {\n                        Node value;\n        if (init != null) {\n            value = init.getAssignedValue();\n        } else {\n                        Node srcLocation = declaration.getNameNode();\n            value = NodeUtil.newUndefinedNode(srcLocation);\n        }\n        Preconditions.checkNotNull(value);\n        inlineWellDefinedVariable(v, value, referenceInfo.references);\n        staleVars.add(v);\n    } else if (refCount == firstRefAfterInit) {\n                        Reference reference = referenceInfo.references.get(firstRefAfterInit - 1);\n        if (canInline(declaration, init, reference)) {\n            inline(v, declaration, init, reference);\n            staleVars.add(v);\n        }\n    } else if (declaration != init && refCount == 2) {\n        if (isValidDeclaration(declaration) && isValidInitialization(init)) {\n                                    Node value = init.getAssignedValue();\n            Preconditions.checkNotNull(value);\n            inlineWellDefinedVariable(v, value, referenceInfo.references);\n            staleVars.add(v);\n        }\n    }\n        if (!staleVars.contains(v) && referenceInfo.isWellDefined() && referenceInfo.isAssignedOnceInLifetime()) {\n        List<Reference> refs = referenceInfo.references;\n        for (int i = 1;         i < refs.size(); i++) {\n            Node nameNode = refs.get(i).getNameNode();\n            if (aliasCandidates.containsKey(nameNode)) {\n                AliasCandidate candidate = aliasCandidates.get(nameNode);\n                if (!staleVars.contains(candidate.alias) && !isVarInlineForbidden(candidate.alias)) {\n                    Reference aliasInit;\n                    aliasInit = candidate.refInfo.getInitializingReference();\n                    Node value = aliasInit.getAssignedValue();\n                    Preconditions.checkNotNull(value);\n                    inlineWellDefinedVariable(candidate.alias, value, candidate.refInfo.references);\n                    staleVars.add(candidate.alias);\n                }\n            }\n        }\n    }\n}", "lc": 1.5909090909090908, "pi": 1.1052631578947367, "ma": 1.6, "nbd": 1.0, "ml": 2.75, "d": 2.0753968253968256, "mi": -0.9117688513037348, "fo": 2.4166666666666665, "r": -0.02631578947368421, "e": 6.422307129314269}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3028_89317b28", "label": 0, "code": "/**\n * Creates a deep copy of this update operation. Changes to the returned\n * {@code UpdateOp} do not affect this object.\n *\n * @return a copy of this operation.\n */\npublic UpdateOp copy() {\n    return new UpdateOp(id, isNew, isDelete, new HashMap<Key, Operation>(changes));\n}", "code_comment": "/**\n * Creates a deep copy of this update operation. Changes to the returned\n * {@code UpdateOp} do not affect this object.\n *\n * @return a copy of this operation.\n */\n", "code_no_comment": "public UpdateOp copy() {\n    return new UpdateOp(id, isNew, isDelete, new HashMap<Key, Operation>(changes));\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.9419309372797741, "fo": -0.5, "r": 2.4210526315789473, "e": -0.16279340490885932}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-4432_c9765c21", "label": 3, "code": "@Override\npublic boolean apply(File input) {\n    return input.isFile() && !input.getParent().equals(path);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean apply(File input) {\n    return input.isFile() && !input.getParent().equals(path);\n}", "lc": -0.45454545454545453, "pi": -0.6028708133971293, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.12301587301587304, "mi": 0.7801268498942919, "fo": -0.25, "r": 0.7894736842105263, "e": -0.13745036681016345}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-147_17296089", "label": 1, "code": "private Result filter() {\n    boolean match = false;\n    if (useMap) {\n        for (final Map.Entry<String, List<String>> entry : getMap().entrySet()) {\n            final String toMatch = ThreadContext.get(entry.getKey());\n            if (toMatch != null) {\n                match = entry.getValue().contains(toMatch);\n            } else {\n                match = false;\n            }\n            if ((!isAnd() && match) || (isAnd() && !match)) {\n                break;\n            }\n        }\n    } else {\n        match = key.equals(ThreadContext.get(key));\n    }\n    return match ? onMatch : onMismatch;\n}", "code_comment": NaN, "code_no_comment": "private Result filter() {\n    boolean match = false;\n    if (useMap) {\n        for (final Map.Entry<String, List<String>> entry : getMap().entrySet()) {\n            final String toMatch = ThreadContext.get(entry.getKey());\n            if (toMatch != null) {\n                match = entry.getValue().contains(toMatch);\n            } else {\n                match = false;\n            }\n            if ((!isAnd() && match) || (isAnd() && !match)) {\n                break;\n            }\n        }\n    } else {\n        match = key.equals(ThreadContext.get(key));\n    }\n    return match ? onMatch : onMismatch;\n}", "lc": 0.22727272727272727, "pi": 0.9952153110047848, "ma": 0.6, "nbd": 0.5, "ml": 0.5, "d": 0.30158730158730157, "mi": -0.2276250880902044, "fo": 0.3333333333333333, "r": 0.02631578947368421, "e": 0.24006731096165923}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4572_dfc56674", "label": 0, "code": "/**\n *  @param pageId\n */\nprivate void removeWindowIndex(int pageId) {\n    idToWindowIndex.remove(pageId);\n}", "code_comment": "/**\n *  @param pageId\n */\n", "code_no_comment": "private void removeWindowIndex(int pageId) {\n    idToWindowIndex.remove(pageId);\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.083157152924595, "fo": -0.4166666666666667, "r": 2.5789473684210527, "e": -0.16279340490885932}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-3383_97f16db4", "label": 3, "code": "private static File computeTopCacheDir() {\n    String procName = ManagementFactory.getRuntimeMXBean().getName();\n    return new File(System.getProperty(\"java.io.tmpdir\"), \"accumulo-vfs-cache-\" + procName + \"-\" + System.getProperty(\"user.name\", \"nouser\"));\n}", "code_comment": NaN, "code_no_comment": "private static File computeTopCacheDir() {\n    String procName = ManagementFactory.getRuntimeMXBean().getName();\n    return new File(System.getProperty(\"java.io.tmpdir\"), \"accumulo-vfs-cache-\" + procName + \"-\" + System.getProperty(\"user.name\", \"nouser\"));\n}", "lc": -0.45454545454545453, "pi": -0.47368421052631593, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.11309523809523811, "mi": 0.685412262156448, "fo": -0.16666666666666666, "r": 0.02631578947368421, "e": -0.11266517983206835}
{"project_name": "Compress", "project_version": 27, "label": 1, "code": "/**\n * Parse an octal string from a buffer.\n *\n * <p>Leading spaces are ignored.\n * The buffer must contain a trailing space or NUL,\n * and may contain an additional trailing space or NUL.</p>\n *\n * <p>The input buffer is allowed to contain all NULs,\n * in which case the method returns 0L\n * (this allows for missing fields).</p>\n *\n * <p>To work-around some tar implementations that insert a\n * leading NUL this method returns 0 if it detects a leading NUL\n * since Commons Compress 1.4.</p>\n *\n * @param buffer The buffer from which to parse.\n * @param offset The offset into the buffer from which to parse.\n * @param length The maximum number of bytes to parse - must be at least 2 bytes.\n * @return The long value of the octal string.\n * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n */\npublic static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long result = 0;\n    int end = offset + length;\n    int start = offset;\n    if (length < 2) {\n        throw new IllegalArgumentException(\"Length \" + length + \" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    // Skip leading spaces\n    while (start < end) {\n        if (buffer[start] == ' ') {\n            start++;\n        } else {\n            break;\n        }\n    }\n    // Trim all trailing NULs and spaces.\n    // The ustar and POSIX tar specs require a trailing NUL or\n    // space but some implementations use the extra digit for big\n    // sizes/uids/gids ...\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer == ' ')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    if (start == end) {\n        throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, trailer));\n    }\n    for (; start < end; start++) {\n        final byte currentByte = buffer[start];\n        // CheckStyle:MagicNumber OFF\n        if (currentByte < '0' || currentByte > '7') {\n            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));\n        }\n        // convert from ASCII\n        result = (result << 3) + (currentByte - '0');\n    // CheckStyle:MagicNumber ON\n    }\n    return result;\n}", "code_comment": "/**\n * Parse an octal string from a buffer.\n *\n * <p>Leading spaces are ignored.\n * The buffer must contain a trailing space or NUL,\n * and may contain an additional trailing space or NUL.</p>\n *\n * <p>The input buffer is allowed to contain all NULs,\n * in which case the method returns 0L\n * (this allows for missing fields).</p>\n *\n * <p>To work-around some tar implementations that insert a\n * leading NUL this method returns 0 if it detects a leading NUL\n * since Commons Compress 1.4.</p>\n *\n * @param buffer The buffer from which to parse.\n * @param offset The offset into the buffer from which to parse.\n * @param length The maximum number of bytes to parse - must be at least 2 bytes.\n * @return The long value of the octal string.\n * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n */\n", "code_no_comment": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long result = 0;\n    int end = offset + length;\n    int start = offset;\n    if (length < 2) {\n        throw new IllegalArgumentException(\"Length \" + length + \" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n        while (start < end) {\n        if (buffer[start] == ' ') {\n            start++;\n        } else {\n            break;\n        }\n    }\n                    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer == ' ')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    if (start == end) {\n        throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, trailer));\n    }\n    for (; start < end; start++) {\n        final byte currentByte = buffer[start];\n                if (currentByte < '0' || currentByte > '7') {\n            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));\n        }\n                result = (result << 3) + (currentByte - '0');\n        }\n    return result;\n}", "lc": 0.9090909090909091, "pi": -0.01913875598086126, "ma": 1.8, "nbd": 0.0, "ml": 0.9166666666666666, "d": 3.1785714285714284, "mi": -0.6366455250176177, "fo": -0.3333333333333333, "r": -0.02631578947368421, "e": 4.20056591921532}
{"project_name": "JxPath", "project_version": 11, "label": 1, "code": "private Attr getAttribute(Element element, QName name) {\n    String testPrefix = name.getPrefix();\n    String testNS = null;\n    if (testPrefix != null) {\n        testNS = parent.getNamespaceURI(testPrefix);\n    }\n    if (testNS != null) {\n        Attr attr = element.getAttributeNodeNS(testNS, name.getName());\n        if (attr != null) {\n            return attr;\n        }\n        // This may mean that the parser does not support NS for\n        // attributes, example - the version of Crimson bundled\n        // with JDK 1.4.0\n        NamedNodeMap nnm = element.getAttributes();\n        for (int i = 0; i < nnm.getLength(); i++) {\n            attr = (Attr) nnm.item(i);\n            if (testAttr(attr, name)) {\n                return attr;\n            }\n        }\n        return null;\n    }\n    return element.getAttributeNode(name.getName());\n}", "code_comment": NaN, "code_no_comment": "private Attr getAttribute(Element element, QName name) {\n    String testPrefix = name.getPrefix();\n    String testNS = null;\n    if (testPrefix != null) {\n        testNS = parent.getNamespaceURI(testPrefix);\n    }\n    if (testNS != null) {\n        Attr attr = element.getAttributeNodeNS(testNS, name.getName());\n        if (attr != null) {\n            return attr;\n        }\n                                NamedNodeMap nnm = element.getAttributes();\n        for (int i = 0; i < nnm.getLength(); i++) {\n            attr = (Attr) nnm.item(i);\n            if (testAttr(attr, name)) {\n                return attr;\n            }\n        }\n        return null;\n    }\n    return element.getAttributeNode(name.getName());\n}", "lc": 0.36363636363636365, "pi": 0.47846889952153115, "ma": 0.4, "nbd": 0.5, "ml": 0.5833333333333334, "d": 0.490079365079365, "mi": -0.3245947850599013, "fo": 0.3333333333333333, "r": -0.02631578947368421, "e": 0.4998691816070491}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-4307_f303c916", "label": 1, "code": "private RecordId writeStream(InputStream stream) throws IOException {\n    boolean threw = true;\n    try {\n        RecordId id = SegmentStream.getRecordIdIfAvailable(stream, store);\n        if (id == null || isOldGen(id)) {\n            id = internalWriteStream(stream);\n        }\n        threw = false;\n        return id;\n    } finally {\n        Closeables.close(stream, threw);\n    }\n}", "code_comment": NaN, "code_no_comment": "private RecordId writeStream(InputStream stream) throws IOException {\n    boolean threw = true;\n    try {\n        RecordId id = SegmentStream.getRecordIdIfAvailable(stream, store);\n        if (id == null || isOldGen(id)) {\n            id = internalWriteStream(stream);\n        }\n        threw = false;\n        return id;\n    } finally {\n        Closeables.close(stream, threw);\n    }\n}", "lc": -0.045454545454545456, "pi": 0.18181818181818177, "ma": -0.4, "nbd": 0.0, "ml": -0.08333333333333333, "d": -0.05555555555555556, "mi": 0.059619450317124574, "fo": -0.16666666666666666, "r": 0.47368421052631576, "e": -0.05569521043319905}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-579_7d72e6ed", "label": 3, "code": "@Override\npublic void restrict(FilterImpl f) {\n    if (f.getSelector() == ancestorSelector) {\n        String d = descendantSelector.currentPath();\n        if (d != null) {\n            f.restrictPath(PathUtils.getParentPath(d), Filter.PathRestriction.PARENT);\n        }\n    }\n    if (f.getSelector() == descendantSelector) {\n        String a = ancestorSelector.currentPath();\n        if (a != null) {\n            f.restrictPath(a, Filter.PathRestriction.DIRECT_CHILDREN);\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void restrict(FilterImpl f) {\n    if (f.getSelector() == ancestorSelector) {\n        String d = descendantSelector.currentPath();\n        if (d != null) {\n            f.restrictPath(PathUtils.getParentPath(d), Filter.PathRestriction.PARENT);\n        }\n    }\n    if (f.getSelector() == descendantSelector) {\n        String a = ancestorSelector.currentPath();\n        if (a != null) {\n            f.restrictPath(a, Filter.PathRestriction.DIRECT_CHILDREN);\n        }\n    }\n}", "lc": 0.045454545454545456, "pi": 0.40191387559808606, "ma": 0.2, "nbd": 0.0, "ml": 0.3333333333333333, "d": 0.0019841269841269858, "mi": -0.06412966878083172, "fo": 0.08333333333333333, "r": 0.07894736842105263, "e": 0.0031096742218610805}
{"project_name": "Closure", "project_version": 30, "label": 2, "code": "@Override\npublic void process(Node externs, Node root) {\n    (new NodeTraversal(compiler, this)).traverse(root);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void process(Node externs, Node root) {\n    (new NodeTraversal(compiler, this)).traverse(root);\n}", "lc": -0.45454545454545453, "pi": -0.6028708133971293, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.8173361522198731, "fo": -0.4166666666666667, "r": 0.31578947368421056, "e": -0.16279340490885932}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2929_a2950285", "label": 3, "code": "/**\n * Get the revision of the latest change made to this node.\n *\n * @param context the revision context\n * @param changeRev the revision of the current change\n * @param handler the conflict handler, which is called for concurrent changes\n *                preceding <code>changeRev</code>.\n * @return the revision, or null if deleted\n */\n@CheckForNull\npublic Revision getNewestRevision(final RevisionContext context, final Revision changeRev, final CollisionHandler handler) {\n    final Map<Revision, String> validRevisions = Maps.newHashMap();\n    Predicate<Revision> predicate = new Predicate<Revision>() {\n\n        @Override\n        public boolean apply(Revision input) {\n            if (input.equals(changeRev)) {\n                return false;\n            }\n            if (isValidRevision(context, input, null, changeRev, validRevisions)) {\n                return true;\n            }\n            handler.concurrentModification(input);\n            return false;\n        }\n    };\n    Revision newestRev = null;\n    // check local commits first\n    SortedMap<Revision, String> revisions = getLocalRevisions();\n    SortedMap<Revision, String> commitRoots = getLocalCommitRoot();\n    Iterator<Revision> it = filter(Iterables.mergeSorted(ImmutableList.of(revisions.keySet(), commitRoots.keySet()), revisions.comparator()), predicate).iterator();\n    if (it.hasNext()) {\n        newestRev = it.next();\n    } else {\n        // check full history (only needed in rare cases)\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"getNewestRevision() with changeRev {} on {}, \" + \"_revisions {}, _commitRoot {}\", changeRev, getId(), getLocalRevisions(), getLocalCommitRoot());\n        }\n        it = filter(getAllChanges(), predicate).iterator();\n        if (it.hasNext()) {\n            newestRev = it.next();\n        }\n    }\n    if (newestRev == null) {\n        return null;\n    }\n    // the local deleted map contains the most recent revisions\n    SortedMap<Revision, String> deleted = getLocalDeleted();\n    String value = deleted.get(newestRev);\n    if (value == null && deleted.headMap(newestRev).isEmpty()) {\n        // no need to check previous docs\n        return newestRev;\n    }\n    if (value == null) {\n        // get from complete map\n        value = getDeleted().get(newestRev);\n    }\n    if (\"true\".equals(value)) {\n        // deleted in the newest revision\n        return null;\n    }\n    return newestRev;\n}", "code_comment": "/**\n * Get the revision of the latest change made to this node.\n *\n * @param context the revision context\n * @param changeRev the revision of the current change\n * @param handler the conflict handler, which is called for concurrent changes\n *                preceding <code>changeRev</code>.\n * @return the revision, or null if deleted\n */\n", "code_no_comment": "@CheckForNull\npublic Revision getNewestRevision(final RevisionContext context, final Revision changeRev, final CollisionHandler handler) {\n    final Map<Revision, String> validRevisions = Maps.newHashMap();\n    Predicate<Revision> predicate = new Predicate<Revision>() {\n\n        @Override\n        public boolean apply(Revision input) {\n            if (input.equals(changeRev)) {\n                return false;\n            }\n            if (isValidRevision(context, input, null, changeRev, validRevisions)) {\n                return true;\n            }\n            handler.concurrentModification(input);\n            return false;\n        }\n    };\n    Revision newestRev = null;\n        SortedMap<Revision, String> revisions = getLocalRevisions();\n    SortedMap<Revision, String> commitRoots = getLocalCommitRoot();\n    Iterator<Revision> it = filter(Iterables.mergeSorted(ImmutableList.of(revisions.keySet(), commitRoots.keySet()), revisions.comparator()), predicate).iterator();\n    if (it.hasNext()) {\n        newestRev = it.next();\n    } else {\n                if (LOG.isDebugEnabled()) {\n            LOG.debug(\"getNewestRevision() with changeRev {} on {}, \" + \"_revisions {}, _commitRoot {}\", changeRev, getId(), getLocalRevisions(), getLocalCommitRoot());\n        }\n        it = filter(getAllChanges(), predicate).iterator();\n        if (it.hasNext()) {\n            newestRev = it.next();\n        }\n    }\n    if (newestRev == null) {\n        return null;\n    }\n        SortedMap<Revision, String> deleted = getLocalDeleted();\n    String value = deleted.get(newestRev);\n    if (value == null && deleted.headMap(newestRev).isEmpty()) {\n                return newestRev;\n    }\n    if (value == null) {\n                value = getDeleted().get(newestRev);\n    }\n    if (\"true\".equals(value)) {\n                return null;\n    }\n    return newestRev;\n}", "lc": 1.5, "pi": 0.42583732057416257, "ma": 1.2, "nbd": 0.0, "ml": 1.4166666666666667, "d": 0.5059523809523809, "mi": -0.8328400281888653, "fo": 2.1666666666666665, "r": -0.02631578947368421, "e": 1.5401278216720546}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-1820_39d526e6", "label": 0, "code": "@Override\npublic int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, IntValue reusable) {\n    long val = 0;\n    boolean neg = false;\n    final int delimLimit = limit - delimiter.length + 1;\n    this.result = reusable;\n    if (bytes[startPos] == '-') {\n        neg = true;\n        startPos++;\n        // check for empty field with only the sign\n        if (startPos == limit || (startPos < delimLimit && delimiterNext(bytes, startPos, delimiter))) {\n            setErrorState(ParseErrorState.NUMERIC_VALUE_ORPHAN_SIGN);\n            return -1;\n        }\n    }\n    for (int i = startPos; i < limit; i++) {\n        if (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\n            reusable.setValue((int) (neg ? -val : val));\n            return i + delimiter.length;\n        }\n        if (bytes[i] < 48 || bytes[i] > 57) {\n            setErrorState(ParseErrorState.NUMERIC_VALUE_ILLEGAL_CHARACTER);\n            return -1;\n        }\n        val *= 10;\n        val += bytes[i] - 48;\n        if (val > OVERFLOW_BOUND && (!neg || val > UNDERFLOW_BOUND)) {\n            setErrorState(ParseErrorState.NUMERIC_VALUE_OVERFLOW_UNDERFLOW);\n            return -1;\n        }\n    }\n    reusable.setValue((int) (neg ? -val : val));\n    return limit;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, IntValue reusable) {\n    long val = 0;\n    boolean neg = false;\n    final int delimLimit = limit - delimiter.length + 1;\n    this.result = reusable;\n    if (bytes[startPos] == '-') {\n        neg = true;\n        startPos++;\n                if (startPos == limit || (startPos < delimLimit && delimiterNext(bytes, startPos, delimiter))) {\n            setErrorState(ParseErrorState.NUMERIC_VALUE_ORPHAN_SIGN);\n            return -1;\n        }\n    }\n    for (int i = startPos; i < limit; i++) {\n        if (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\n            reusable.setValue((int) (neg ? -val : val));\n            return i + delimiter.length;\n        }\n        if (bytes[i] < 48 || bytes[i] > 57) {\n            setErrorState(ParseErrorState.NUMERIC_VALUE_ILLEGAL_CHARACTER);\n            return -1;\n        }\n        val *= 10;\n        val += bytes[i] - 48;\n        if (val > OVERFLOW_BOUND && (!neg || val > UNDERFLOW_BOUND)) {\n            setErrorState(ParseErrorState.NUMERIC_VALUE_OVERFLOW_UNDERFLOW);\n            return -1;\n        }\n    }\n    reusable.setValue((int) (neg ? -val : val));\n    return limit;\n}", "lc": 0.8636363636363636, "pi": 0.3349282296650717, "ma": 1.0, "nbd": 0.0, "ml": 1.5833333333333333, "d": 2.9087301587301586, "mi": -0.6315715292459477, "fo": 0.08333333333333333, "r": -0.02631578947368421, "e": 4.945426254732801}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2021_004db804", "label": 1, "code": "private static void addToUnionList(Expression condition, ArrayList<Expression> unionList) {\n    if (condition instanceof OrCondition) {\n        OrCondition or = (OrCondition) condition;\n        if (or.getCommonLeftPart() != null) {\n        // @x = 1 or @x = 2\n        // is automatically converted to\n        // @x in (1, 2)\n        // within the query engine\n        } else if (or.left instanceof Contains && or.right instanceof Contains) {\n        // do not optimize \"contains\"\n        } else {\n            // conditions of type\n            // @x = 1 or @y = 2\n            // or similar are converted to\n            // (@x = 1) union (@y = 2)\n            addToUnionList(or.left, unionList);\n            addToUnionList(or.right, unionList);\n            return;\n        }\n    } else if (condition instanceof AndCondition) {\n        // conditions of type\n        // @a = 1 and (@x = 1 or @y = 2)\n        // are automatically converted to\n        // (@a = 1 and @x = 1) union (@a = 1 and @y = 2)\n        AndCondition and = (AndCondition) condition;\n        and = and.pullOrRight();\n        if (and.right instanceof OrCondition) {\n            OrCondition or = (OrCondition) and.right;\n            if (or.getCommonLeftPart() != null) {\n            // @x = 1 or @x = 2\n            // is automatically converted to\n            // @x in (1, 2)\n            // within the query engine\n            } else if (or.left instanceof Contains && or.right instanceof Contains) {\n            // do not optimize \"contains\"\n            } else {\n                // same as above, but with the added \"and\"\n                addToUnionList(new AndCondition(and.left, or.left), unionList);\n                addToUnionList(new AndCondition(and.left, or.right), unionList);\n                return;\n            }\n        }\n    }\n    unionList.add(condition);\n}", "code_comment": NaN, "code_no_comment": "private static void addToUnionList(Expression condition, ArrayList<Expression> unionList) {\n    if (condition instanceof OrCondition) {\n        OrCondition or = (OrCondition) condition;\n        if (or.getCommonLeftPart() != null) {\n                                        } else if (or.left instanceof Contains && or.right instanceof Contains) {\n                } else {\n                                                            addToUnionList(or.left, unionList);\n            addToUnionList(or.right, unionList);\n            return;\n        }\n    } else if (condition instanceof AndCondition) {\n                                        AndCondition and = (AndCondition) condition;\n        and = and.pullOrRight();\n        if (and.right instanceof OrCondition) {\n            OrCondition or = (OrCondition) and.right;\n            if (or.getCommonLeftPart() != null) {\n                                                            } else if (or.left instanceof Contains && or.right instanceof Contains) {\n                        } else {\n                                addToUnionList(new AndCondition(and.left, or.left), unionList);\n                addToUnionList(new AndCondition(and.left, or.right), unionList);\n                return;\n            }\n        }\n    }\n    unionList.add(condition);\n}", "lc": 0.5454545454545454, "pi": 0.6459330143540669, "ma": 0.8, "nbd": 1.5, "ml": 0.75, "d": 0.48611111111111116, "mi": -0.4207188160676531, "fo": 0.16666666666666666, "r": -0.02631578947368421, "e": 0.5302651521700292}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5853_b80f6640", "label": 3, "code": "@Override\npublic BigDecimal convertToObject(final String value, final Locale locale) {\n    if (Strings.isEmpty(value)) {\n        return null;\n    }\n    final Number number = parse(value, -Double.MAX_VALUE, Double.MAX_VALUE, locale);\n    if (number instanceof BigDecimal) {\n        return (BigDecimal) number;\n    } else if (number instanceof Double) {\n        // http://java.sun.com/j2se/1.4.2/docs/api/java/math/BigDecimal.html#BigDecimal%28double%29\n        return new BigDecimal(Double.toString(number.doubleValue()));\n    } else if (number instanceof Long) {\n        return new BigDecimal(number.longValue());\n    } else if (number instanceof Float) {\n        return new BigDecimal(number.floatValue());\n    } else if (number instanceof Integer) {\n        return new BigDecimal(number.intValue());\n    } else {\n        return new BigDecimal(value);\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic BigDecimal convertToObject(final String value, final Locale locale) {\n    if (Strings.isEmpty(value)) {\n        return null;\n    }\n    final Number number = parse(value, -Double.MAX_VALUE, Double.MAX_VALUE, locale);\n    if (number instanceof BigDecimal) {\n        return (BigDecimal) number;\n    } else if (number instanceof Double) {\n                return new BigDecimal(Double.toString(number.doubleValue()));\n    } else if (number instanceof Long) {\n        return new BigDecimal(number.longValue());\n    } else if (number instanceof Float) {\n        return new BigDecimal(number.floatValue());\n    } else if (number instanceof Integer) {\n        return new BigDecimal(number.intValue());\n    } else {\n        return new BigDecimal(value);\n    }\n}", "lc": 0.2727272727272727, "pi": -0.13397129186602882, "ma": 0.6, "nbd": 1.5, "ml": 0.3333333333333333, "d": 0.03968253968253967, "mi": -0.23890063424947125, "fo": 0.08333333333333333, "r": -0.02631578947368421, "e": 0.0628504578643753}
{"project_name": "Math", "project_version": 29, "label": 1, "code": "/**\n * {@inheritDoc}\n */\n@Override\npublic OpenMapRealVector ebeDivide(RealVector v) {\n    checkVectorDimensions(v.getDimension());\n    OpenMapRealVector res = new OpenMapRealVector(this);\n    /*\n         * MATH-803: it is not sufficient to loop through non zero entries of\n         * this only. Indeed, if this[i] = 0d and v[i] = 0d, then\n         * this[i] / v[i] = NaN, and not 0d.\n         */\n    Iterator iter = entries.iterator();\n    while (iter.hasNext()) {\n        iter.advance();\n        res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));\n    }\n    return res;\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "@Override\npublic OpenMapRealVector ebeDivide(RealVector v) {\n    checkVectorDimensions(v.getDimension());\n    OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = entries.iterator();\n    while (iter.hasNext()) {\n        iter.advance();\n        res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));\n    }\n    return res;\n}", "lc": -0.13636363636363635, "pi": -0.15311004784689008, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": -0.041666666666666706, "mi": 0.1357293868921775, "fo": 0.3333333333333333, "r": 0.5, "e": -0.05045786437532777}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3798_2ac1dccd", "label": 1, "code": "/**\n * Get the revision of the latest change made to this node. At the same\n * time this method collects all collisions that happened for the given\n * {@code changeRev}. The reported latest change takes branches into\n * account. This means, if {@code changeRev} is on a branch, the latest\n * change is either a change that was done by a preceding branch commit or\n * a change that happened before the base of the branch. Changes done after\n * the branch base on trunk are not considered in this case. For a trunk\n * commit the latest change is reported similarly. In this case, unmerged\n * branch commits are not considered as latest change. Only commits to trunk\n * are considered.\n *\n * Collisions include the following cases:\n * <ul>\n *     <li>The other change is not yet committed</li>\n *     <li>The other change is a branch commit and not yet merged</li>\n *     <li>The {@code changeRev} is a branch commit and the other change\n *       happened after the base revision of the branch</li>\n *     <li>The other change is from another cluster node and not yet\n *       visible</li>\n * </ul>\n *\n * @param context the revision context.\n * @param baseRev the base revision of the current change.\n * @param changeRev the revision of the current change.\n * @param branch the branch associated with the current change or\n *              {@code null} if {@code changeRev} is not a branch commit.\n * @param collisions changes that happened after {@code baseRev}.\n */\n@CheckForNull\nRevision getNewestRevision(final RevisionContext context, final Revision baseRev, final Revision changeRev, final Branch branch, final Set<Revision> collisions) {\n    checkArgument(!baseRev.isBranch() || branch != null, \"Branch must be non-null if baseRev is a branch revision\");\n    Revision head = context.getHeadRevision();\n    Revision lower = branch != null ? branch.getBase() : baseRev;\n    // the clusterIds to check when walking the changes\n    Set<Integer> clusterIds = Collections.emptySet();\n    if (!getPreviousRanges().isEmpty()) {\n        clusterIds = Sets.newHashSet();\n        for (Revision prevRev : getPreviousRanges().keySet()) {\n            if (!isRevisionNewer(context, lower, prevRev)) {\n                clusterIds.add(prevRev.getClusterId());\n            }\n        }\n    }\n    // if we don't have clusterIds, we can use the local changes only\n    boolean fullScan = true;\n    Iterable<Revision> changes;\n    if (clusterIds.isEmpty()) {\n        // baseRev is newer than all previous documents\n        changes = Iterables.mergeSorted(ImmutableList.of(getLocalRevisions().keySet(), getLocalCommitRoot().keySet()), getLocalRevisions().comparator());\n    } else {\n        // include previous documents as well (only needed in rare cases)\n        fullScan = false;\n        changes = getAllChanges();\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"getNewestRevision() with changeRev {} on {}, \" + \"_revisions {}, _commitRoot {}\", changeRev, getId(), getLocalRevisions(), getLocalCommitRoot());\n        }\n    }\n    Map<Integer, Revision> newestRevs = Maps.newHashMap();\n    Map<Revision, String> validRevisions = Maps.newHashMap();\n    for (Revision r : changes) {\n        if (r.equals(changeRev)) {\n            continue;\n        }\n        if (!fullScan) {\n            // check if we can stop going through changes\n            if (clusterIds.contains(r.getClusterId())) {\n                if (isRevisionNewer(context, lower, r)) {\n                    clusterIds.remove(r.getClusterId());\n                    if (clusterIds.isEmpty()) {\n                        // the lower bound\n                        break;\n                    }\n                }\n            }\n        }\n        if (newestRevs.containsKey(r.getClusterId())) {\n            // of the branch if this is for a commit on a branch\n            if (branch != null && !branch.containsCommit(r)) {\n                // change does not belong to the branch\n                if (isRevisionNewer(context, r, branch.getBase())) {\n                    // and happened after the base of the branch\n                    collisions.add(r);\n                }\n            }\n        } else {\n            // check if change is visible from baseRev\n            if (isValidRevision(context, r, null, baseRev, validRevisions)) {\n                // consider for newestRev\n                newestRevs.put(r.getClusterId(), r);\n            } else {\n                // not valid means:\n                // 1) 'r' is not committed -> collision\n                // 2) 'r' is on a branch, but not the same as\n                // changeRev -> collisions\n                // 3) changeRev is on a branch and 'r' is newer than\n                // the base of the branch -> collision\n                // 4) 'r' is committed but not yet visible to current\n                // cluster node -> collisions\n                // 5) changeRev is not on a branch, 'r' is committed and\n                // newer than baseRev -> newestRev\n                NodeDocument commitRoot = getCommitRoot(r);\n                Revision commitRevision = null;\n                if (commitRoot != null) {\n                    commitRevision = commitRoot.getCommitRevision(r);\n                }\n                if (// committed but not yet visible\n                commitRevision != null && isRevisionNewer(context, commitRevision, head)) {\n                    // case 4)\n                    collisions.add(r);\n                } else if (// committed\n                commitRevision != null && // changeRev not on branch\n                branch == null && isRevisionNewer(context, r, baseRev)) {\n                    // case 5)\n                    newestRevs.put(r.getClusterId(), r);\n                } else {\n                    // remaining cases 1), 2) and 3)\n                    collisions.add(r);\n                }\n            }\n        }\n    }\n    // select the newest committed change\n    Revision newestRev = null;\n    for (Revision r : newestRevs.values()) {\n        newestRev = Utils.max(newestRev, r, context.getRevisionComparator());\n    }\n    if (newestRev == null) {\n        return null;\n    }\n    // the local deleted map contains the most recent revisions\n    SortedMap<Revision, String> deleted = getLocalDeleted();\n    String value = deleted.get(newestRev);\n    if (value == null && deleted.headMap(newestRev).isEmpty()) {\n        // no need to check previous docs\n        return newestRev;\n    }\n    if (value == null) {\n        // get from complete map\n        value = getDeleted().get(newestRev);\n    }\n    if (\"true\".equals(value)) {\n        // deleted in the newest revision\n        return null;\n    }\n    return newestRev;\n}", "code_comment": "/**\n * Get the revision of the latest change made to this node. At the same\n * time this method collects all collisions that happened for the given\n * {@code changeRev}. The reported latest change takes branches into\n * account. This means, if {@code changeRev} is on a branch, the latest\n * change is either a change that was done by a preceding branch commit or\n * a change that happened before the base of the branch. Changes done after\n * the branch base on trunk are not considered in this case. For a trunk\n * commit the latest change is reported similarly. In this case, unmerged\n * branch commits are not considered as latest change. Only commits to trunk\n * are considered.\n *\n * Collisions include the following cases:\n * <ul>\n *     <li>The other change is not yet committed</li>\n *     <li>The other change is a branch commit and not yet merged</li>\n *     <li>The {@code changeRev} is a branch commit and the other change\n *       happened after the base revision of the branch</li>\n *     <li>The other change is from another cluster node and not yet\n *       visible</li>\n * </ul>\n *\n * @param context the revision context.\n * @param baseRev the base revision of the current change.\n * @param changeRev the revision of the current change.\n * @param branch the branch associated with the current change or\n *              {@code null} if {@code changeRev} is not a branch commit.\n * @param collisions changes that happened after {@code baseRev}.\n */\n", "code_no_comment": "@CheckForNull\nRevision getNewestRevision(final RevisionContext context, final Revision baseRev, final Revision changeRev, final Branch branch, final Set<Revision> collisions) {\n    checkArgument(!baseRev.isBranch() || branch != null, \"Branch must be non-null if baseRev is a branch revision\");\n    Revision head = context.getHeadRevision();\n    Revision lower = branch != null ? branch.getBase() : baseRev;\n        Set<Integer> clusterIds = Collections.emptySet();\n    if (!getPreviousRanges().isEmpty()) {\n        clusterIds = Sets.newHashSet();\n        for (Revision prevRev : getPreviousRanges().keySet()) {\n            if (!isRevisionNewer(context, lower, prevRev)) {\n                clusterIds.add(prevRev.getClusterId());\n            }\n        }\n    }\n        boolean fullScan = true;\n    Iterable<Revision> changes;\n    if (clusterIds.isEmpty()) {\n                changes = Iterables.mergeSorted(ImmutableList.of(getLocalRevisions().keySet(), getLocalCommitRoot().keySet()), getLocalRevisions().comparator());\n    } else {\n                fullScan = false;\n        changes = getAllChanges();\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"getNewestRevision() with changeRev {} on {}, \" + \"_revisions {}, _commitRoot {}\", changeRev, getId(), getLocalRevisions(), getLocalCommitRoot());\n        }\n    }\n    Map<Integer, Revision> newestRevs = Maps.newHashMap();\n    Map<Revision, String> validRevisions = Maps.newHashMap();\n    for (Revision r : changes) {\n        if (r.equals(changeRev)) {\n            continue;\n        }\n        if (!fullScan) {\n                        if (clusterIds.contains(r.getClusterId())) {\n                if (isRevisionNewer(context, lower, r)) {\n                    clusterIds.remove(r.getClusterId());\n                    if (clusterIds.isEmpty()) {\n                                                break;\n                    }\n                }\n            }\n        }\n        if (newestRevs.containsKey(r.getClusterId())) {\n                        if (branch != null && !branch.containsCommit(r)) {\n                                if (isRevisionNewer(context, r, branch.getBase())) {\n                                        collisions.add(r);\n                }\n            }\n        } else {\n                        if (isValidRevision(context, r, null, baseRev, validRevisions)) {\n                                newestRevs.put(r.getClusterId(), r);\n            } else {\n                                                                                                                                                                                NodeDocument commitRoot = getCommitRoot(r);\n                Revision commitRevision = null;\n                if (commitRoot != null) {\n                    commitRevision = commitRoot.getCommitRevision(r);\n                }\n                if (                commitRevision != null && isRevisionNewer(context, commitRevision, head)) {\n                                        collisions.add(r);\n                } else if (                commitRevision != null &&                 branch == null && isRevisionNewer(context, r, baseRev)) {\n                                        newestRevs.put(r.getClusterId(), r);\n                } else {\n                                        collisions.add(r);\n                }\n            }\n        }\n    }\n        Revision newestRev = null;\n    for (Revision r : newestRevs.values()) {\n        newestRev = Utils.max(newestRev, r, context.getRevisionComparator());\n    }\n    if (newestRev == null) {\n        return null;\n    }\n        SortedMap<Revision, String> deleted = getLocalDeleted();\n    String value = deleted.get(newestRev);\n    if (value == null && deleted.headMap(newestRev).isEmpty()) {\n                return newestRev;\n    }\n    if (value == null) {\n                value = getDeleted().get(newestRev);\n    }\n    if (\"true\".equals(value)) {\n                return null;\n    }\n    return newestRev;\n}", "lc": 3.409090909090909, "pi": 1.3779904306220097, "ma": 4.6, "nbd": 1.5, "ml": 4.333333333333333, "d": 1.2837301587301588, "mi": -1.341930937279774, "fo": 4.833333333333333, "r": -0.02631578947368421, "e": 6.555149461454676}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2147_a1556c30", "label": 1, "code": "/**\n * seek for an element in the index given the provided Predicate. If {@code walkedLanes} won't\n * be null it will have on the way out the last elements of each lane walked through during the\n * seek.\n *\n * @param index the index content node {@code :index}\n * @param condition the predicate to evaluate\n * @param walkedLanes if not null will contain the last element of the walked lanes with each\n *            lane represented by the corresponding position in the array. <b>You have</b> to\n *            pass in an array already sized as {@link OrderedIndex#LANES} or an\n *            {@link IllegalArgumentException} will be raised\n * @return the entry or null if not found\n */\nString seek(@Nonnull final NodeBuilder index, @Nonnull final Predicate<String> condition, @Nullable final String[] walkedLanes) {\n    boolean keepWalked = false;\n    String searchfor = condition.getSearchFor();\n    if (LOG.isDebugEnabled()) {\n        LOG.debug(\"seek() - Searching for: {}\", condition.getSearchFor());\n        LOG.debug(\"seek() - condition: {}\", condition);\n    }\n    Predicate<String> walkingPredicate = direction.isAscending() ? new PredicateLessThan(searchfor, true) : new PredicateGreaterThan(searchfor, true);\n    // we always begin with :start\n    String currentKey = START;\n    String found = null;\n    if (walkedLanes != null) {\n        if (walkedLanes.length != OrderedIndex.LANES) {\n            throw new IllegalArgumentException(String.format(\"Wrong size for keeping track of the Walked Lanes. Expected %d but was %d\", OrderedIndex.LANES, walkedLanes.length));\n        }\n        // ensuring the right data\n        for (int i = 0; i < walkedLanes.length; i++) {\n            walkedLanes[i] = currentKey;\n        }\n        keepWalked = true;\n    }\n    int lane;\n    boolean stillLaning;\n    String nextkey;\n    if ((direction.isAscending() && condition instanceof PredicateLessThan) || (direction.isDescending() && condition instanceof PredicateGreaterThan)) {\n        // we're asking for a <, <= query from ascending index or >, >= from descending\n        // we have to walk the lanes from bottom to up rather than up to bottom.\n        LOG.debug(\"seek() - cross case\");\n        lane = 0;\n        do {\n            stillLaning = lane < OrderedIndex.LANES;\n            nextkey = getPropertyNext(index.getChildNode(currentKey), lane);\n            if ((Strings.isNullOrEmpty(nextkey) || !walkingPredicate.apply(nextkey)) && lane < OrderedIndex.LANES) {\n                // if we're currently pointing to NIL or the next element does not fit the search\n                // but we still have lanes left\n                lane++;\n            } else {\n                if (condition.apply(nextkey)) {\n                    found = nextkey;\n                } else {\n                    currentKey = nextkey;\n                    if (keepWalked && !Strings.isNullOrEmpty(currentKey)) {\n                        walkedLanes[lane] = currentKey;\n                    }\n                }\n            }\n        } while (((!Strings.isNullOrEmpty(nextkey) && walkingPredicate.apply(nextkey)) || stillLaning) && (found == null));\n    } else {\n        LOG.debug(\"seek() - plain case\");\n        lane = OrderedIndex.LANES - 1;\n        do {\n            stillLaning = lane > 0;\n            nextkey = getPropertyNext(index.getChildNode(currentKey), lane);\n            if ((Strings.isNullOrEmpty(nextkey) || !walkingPredicate.apply(nextkey)) && lane > 0) {\n                // if we're currently pointing to NIL or the next element does not fit the search\n                // but we still have lanes left, let's lower the lane;\n                lane--;\n            } else {\n                if (condition.apply(nextkey)) {\n                    found = nextkey;\n                } else {\n                    currentKey = nextkey;\n                    if (keepWalked && !Strings.isNullOrEmpty(currentKey)) {\n                        for (int l = lane; l >= 0; l--) {\n                            walkedLanes[l] = currentKey;\n                        }\n                    }\n                }\n            }\n        } while (((!Strings.isNullOrEmpty(nextkey) && walkingPredicate.apply(nextkey)) || stillLaning) && (found == null));\n    }\n    return found;\n}", "code_comment": "/**\n * seek for an element in the index given the provided Predicate. If {@code walkedLanes} won't\n * be null it will have on the way out the last elements of each lane walked through during the\n * seek.\n *\n * @param index the index content node {@code :index}\n * @param condition the predicate to evaluate\n * @param walkedLanes if not null will contain the last element of the walked lanes with each\n *            lane represented by the corresponding position in the array. <b>You have</b> to\n *            pass in an array already sized as {@link OrderedIndex#LANES} or an\n *            {@link IllegalArgumentException} will be raised\n * @return the entry or null if not found\n */\n", "code_no_comment": "String seek(@Nonnull final NodeBuilder index, @Nonnull final Predicate<String> condition, @Nullable final String[] walkedLanes) {\n    boolean keepWalked = false;\n    String searchfor = condition.getSearchFor();\n    if (LOG.isDebugEnabled()) {\n        LOG.debug(\"seek() - Searching for: {}\", condition.getSearchFor());\n        LOG.debug(\"seek() - condition: {}\", condition);\n    }\n    Predicate<String> walkingPredicate = direction.isAscending() ? new PredicateLessThan(searchfor, true) : new PredicateGreaterThan(searchfor, true);\n        String currentKey = START;\n    String found = null;\n    if (walkedLanes != null) {\n        if (walkedLanes.length != OrderedIndex.LANES) {\n            throw new IllegalArgumentException(String.format(\"Wrong size for keeping track of the Walked Lanes. Expected %d but was %d\", OrderedIndex.LANES, walkedLanes.length));\n        }\n                for (int i = 0; i < walkedLanes.length; i++) {\n            walkedLanes[i] = currentKey;\n        }\n        keepWalked = true;\n    }\n    int lane;\n    boolean stillLaning;\n    String nextkey;\n    if ((direction.isAscending() && condition instanceof PredicateLessThan) || (direction.isDescending() && condition instanceof PredicateGreaterThan)) {\n                        LOG.debug(\"seek() - cross case\");\n        lane = 0;\n        do {\n            stillLaning = lane < OrderedIndex.LANES;\n            nextkey = getPropertyNext(index.getChildNode(currentKey), lane);\n            if ((Strings.isNullOrEmpty(nextkey) || !walkingPredicate.apply(nextkey)) && lane < OrderedIndex.LANES) {\n                                                lane++;\n            } else {\n                if (condition.apply(nextkey)) {\n                    found = nextkey;\n                } else {\n                    currentKey = nextkey;\n                    if (keepWalked && !Strings.isNullOrEmpty(currentKey)) {\n                        walkedLanes[lane] = currentKey;\n                    }\n                }\n            }\n        } while (((!Strings.isNullOrEmpty(nextkey) && walkingPredicate.apply(nextkey)) || stillLaning) && (found == null));\n    } else {\n        LOG.debug(\"seek() - plain case\");\n        lane = OrderedIndex.LANES - 1;\n        do {\n            stillLaning = lane > 0;\n            nextkey = getPropertyNext(index.getChildNode(currentKey), lane);\n            if ((Strings.isNullOrEmpty(nextkey) || !walkingPredicate.apply(nextkey)) && lane > 0) {\n                                                lane--;\n            } else {\n                if (condition.apply(nextkey)) {\n                    found = nextkey;\n                } else {\n                    currentKey = nextkey;\n                    if (keepWalked && !Strings.isNullOrEmpty(currentKey)) {\n                        for (int l = lane; l >= 0; l--) {\n                            walkedLanes[l] = currentKey;\n                        }\n                    }\n                }\n            }\n        } while (((!Strings.isNullOrEmpty(nextkey) && walkingPredicate.apply(nextkey)) || stillLaning) && (found == null));\n    }\n    return found;\n}", "lc": 2.3181818181818183, "pi": 1.7177033492822966, "ma": 2.6, "nbd": 2.0, "ml": 3.5833333333333335, "d": 4.063492063492063, "mi": -1.1057082452431288, "fo": 1.75, "r": -0.02631578947368421, "e": 14.725898007756895}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3965_6051019b", "label": 1, "code": "/**\n *  Gets a URL for the listener interface on a behavior (e.g. IBehaviorListener on\n *  AjaxPagingNavigationBehavior).\n *\n *  @param behaviour\n *             The behavior that the URL should point to\n *  @param listener\n *             The listener interface that the URL should call\n *  @return The URL\n */\npublic final CharSequence urlFor(final Behavior behaviour, final RequestListenerInterface listener) {\n    PageAndComponentProvider provider = new PageAndComponentProvider(getPage(), this);\n    int id = getBehaviorId(behaviour);\n    IRequestHandler handler;\n    if (getPage().isPageStateless()) {\n        handler = new BookmarkableListenerInterfaceRequestHandler(provider, listener, id);\n    } else {\n        handler = new ListenerInterfaceRequestHandler(provider, listener, id);\n    }\n    return getRequestCycle().urlFor(handler);\n}", "code_comment": "/**\n *  Gets a URL for the listener interface on a behavior (e.g. IBehaviorListener on\n *  AjaxPagingNavigationBehavior).\n *\n *  @param behaviour\n *             The behavior that the URL should point to\n *  @param listener\n *             The listener interface that the URL should call\n *  @return The URL\n */\n", "code_no_comment": "public final CharSequence urlFor(final Behavior behaviour, final RequestListenerInterface listener) {\n    PageAndComponentProvider provider = new PageAndComponentProvider(getPage(), this);\n    int id = getBehaviorId(behaviour);\n    IRequestHandler handler;\n    if (getPage().isPageStateless()) {\n        handler = new BookmarkableListenerInterfaceRequestHandler(provider, listener, id);\n    } else {\n        handler = new ListenerInterfaceRequestHandler(provider, listener, id);\n    }\n    return getRequestCycle().urlFor(handler);\n}", "lc": -0.13636363636363635, "pi": -0.2775119617224881, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": -0.3650793650793651, "mi": 0.13629316420014115, "fo": 0.0, "r": 0.39473684210526316, "e": -0.16279340490885932}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-554_3f51fb09", "label": 1, "code": "/**\n * Create a {@code PropertyState} based on a {@link Value}. The\n * {@link Type} of the property state is determined by the\n * type of the value.\n * @param name  The name of the property state\n * @param value  The value of the property state\n * @return  The new property state\n * @throws RepositoryException forwarded from {@code value}\n */\n@Nonnull\npublic static PropertyState createProperty(String name, Value value) throws RepositoryException {\n    int type = value.getType();\n    switch(type) {\n        case PropertyType.STRING:\n            return StringPropertyState.stringProperty(name, value.getString());\n        case PropertyType.BINARY:\n            return BinaryPropertyState.binaryProperty(name, value);\n        case PropertyType.LONG:\n            return LongPropertyState.createLongProperty(name, value.getLong());\n        case PropertyType.DOUBLE:\n            return DoublePropertyState.doubleProperty(name, value.getDouble());\n        case PropertyType.DATE:\n            return LongPropertyState.createDateProperty(name, value.getLong());\n        case PropertyType.BOOLEAN:\n            return BooleanPropertyState.booleanProperty(name, value.getBoolean());\n        case PropertyType.DECIMAL:\n            return DecimalPropertyState.decimalProperty(name, value.getDecimal());\n        default:\n            return new GenericPropertyState(name, value.getString(), Type.fromTag(type, false));\n    }\n}", "code_comment": "/**\n * Create a {@code PropertyState} based on a {@link Value}. The\n * {@link Type} of the property state is determined by the\n * type of the value.\n * @param name  The name of the property state\n * @param value  The value of the property state\n * @return  The new property state\n * @throws RepositoryException forwarded from {@code value}\n */\n", "code_no_comment": "@Nonnull\npublic static PropertyState createProperty(String name, Value value) throws RepositoryException {\n    int type = value.getType();\n    switch(type) {\n        case PropertyType.STRING:\n            return StringPropertyState.stringProperty(name, value.getString());\n        case PropertyType.BINARY:\n            return BinaryPropertyState.binaryProperty(name, value);\n        case PropertyType.LONG:\n            return LongPropertyState.createLongProperty(name, value.getLong());\n        case PropertyType.DOUBLE:\n            return DoublePropertyState.doubleProperty(name, value.getDouble());\n        case PropertyType.DATE:\n            return LongPropertyState.createDateProperty(name, value.getLong());\n        case PropertyType.BOOLEAN:\n            return BooleanPropertyState.booleanProperty(name, value.getBoolean());\n        case PropertyType.DECIMAL:\n            return DecimalPropertyState.decimalProperty(name, value.getDecimal());\n        default:\n            return new GenericPropertyState(name, value.getString(), Type.fromTag(type, false));\n    }\n}", "lc": 0.36363636363636365, "pi": 0.5263157894736841, "ma": 1.0, "nbd": 0.0, "ml": 0.25, "d": -0.3650793650793651, "mi": -0.3620859760394643, "fo": 0.8333333333333334, "r": -0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-217_46f62443", "label": 1, "code": "@Override\npublic Set<String> listIterators(String tableName) throws AccumuloSecurityException, AccumuloException, TableNotFoundException {\n    Set<String> result = new HashSet<String>();\n    Set<String> lifecycles = new HashSet<String>();\n    for (IteratorScope scope : IteratorScope.values()) lifecycles.add(scope.name().toLowerCase());\n    for (Entry<String, String> property : this.getProperties(tableName)) {\n        String name = property.getKey();\n        String[] parts = name.split(\"\\\\.\");\n        if (parts.length == 4) {\n            if (parts[0].equals(\"table\") && parts[1].equals(\"iterator\") && lifecycles.contains(parts[2]))\n                result.add(parts[3]);\n        }\n    }\n    return result;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic Set<String> listIterators(String tableName) throws AccumuloSecurityException, AccumuloException, TableNotFoundException {\n    Set<String> result = new HashSet<String>();\n    Set<String> lifecycles = new HashSet<String>();\n    for (IteratorScope scope : IteratorScope.values()) lifecycles.add(scope.name().toLowerCase());\n    for (Entry<String, String> property : this.getProperties(tableName)) {\n        String name = property.getKey();\n        String[] parts = name.split(\"\\\\.\");\n        if (parts.length == 4) {\n            if (parts[0].equals(\"table\") && parts[1].equals(\"iterator\") && lifecycles.contains(parts[2]))\n                result.add(parts[3]);\n        }\n    }\n    return result;\n}", "lc": 0.045454545454545456, "pi": 0.6411483253588517, "ma": 0.2, "nbd": 0.0, "ml": 0.25, "d": -0.0019841269841269858, "mi": -0.1571529245947851, "fo": 0.4166666666666667, "r": -0.02631578947368421, "e": 0.14689695314165843}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-2506_0f8a2990", "label": 1, "code": "@Override\nprotected void onDetach() {\n    restoreOriginalChildVisibility();\n    super.onDetach();\n}", "code_comment": NaN, "code_no_comment": "@Override\nprotected void onDetach() {\n    restoreOriginalChildVisibility();\n    super.onDetach();\n}", "lc": -0.4090909090909091, "pi": -0.49282296650717716, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.8985200845665959, "fo": -0.3333333333333333, "r": 0.9736842105263158, "e": -0.16279340490885932}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1655_c91bfa54", "label": 1, "code": "@Override\npublic Iterator<String> getAllChunkIds(final long maxLastModifiedTime) throws Exception {\n    return transform(filter(delegate.getAllIdentifiers(), new Predicate<DataIdentifier>() {\n\n        @Override\n        public boolean apply(DataIdentifier input) {\n            try {\n                DataRecord dr = delegate.getRecord(input);\n                if (dr != null && dr.getLastModified() < maxLastModifiedTime) {\n                    return true;\n                }\n            } catch (DataStoreException e) {\n                log.warn(\"Error occurred while fetching DataRecord for identifier {}\", input, e);\n            }\n            return false;\n        }\n    }), new Function<DataIdentifier, String>() {\n\n        @Override\n        public String apply(DataIdentifier input) {\n            return input.toString();\n        }\n    });\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic Iterator<String> getAllChunkIds(final long maxLastModifiedTime) throws Exception {\n    return transform(filter(delegate.getAllIdentifiers(), new Predicate<DataIdentifier>() {\n\n        @Override\n        public boolean apply(DataIdentifier input) {\n            try {\n                DataRecord dr = delegate.getRecord(input);\n                if (dr != null && dr.getLastModified() < maxLastModifiedTime) {\n                    return true;\n                }\n            } catch (DataStoreException e) {\n                log.warn(\"Error occurred while fetching DataRecord for identifier {}\", input, e);\n            }\n            return false;\n        }\n    }), new Function<DataIdentifier, String>() {\n\n        @Override\n        public String apply(DataIdentifier input) {\n            return input.toString();\n        }\n    });\n}", "lc": 0.36363636363636365, "pi": 1.2392344497607655, "ma": -0.2, "nbd": 0.5, "ml": 0.0, "d": 0.26388888888888884, "mi": -0.26398872445384053, "fo": 0.08333333333333333, "r": 0.0, "e": 0.2061029373627703}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1822_016df669", "label": 1, "code": "/**\n * Remove a map entry.\n * The property is a map of revisions / values.\n *\n * @param property the property\n * @param revision the revision\n */\npublic void removeMapEntry(@Nonnull String property, @Nonnull Revision revision) {\n    Operation op = new Operation();\n    op.type = Operation.Type.REMOVE_MAP_ENTRY;\n    changes.put(new Key(property, checkNotNull(revision)), op);\n}", "code_comment": "/**\n * Remove a map entry.\n * The property is a map of revisions / values.\n *\n * @param property the property\n * @param revision the revision\n */\n", "code_no_comment": "public void removeMapEntry(@Nonnull String property, @Nonnull Revision revision) {\n    Operation op = new Operation();\n    op.type = Operation.Type.REMOVE_MAP_ENTRY;\n    changes.put(new Key(property, checkNotNull(revision)), op);\n}", "lc": -0.4090909090909091, "pi": -0.49282296650717716, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.55799859055673, "fo": -0.3333333333333333, "r": 2.289473684210526, "e": -0.16279340490885932}
{"project_name": "Closure", "project_version": 3, "label": 1, "code": "private boolean canInline() {\n    // Cannot inline a parameter.\n    if (getDefCfgNode().isFunction()) {\n        return false;\n    }\n    // so we just back off for now.\n    for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n            return false;\n        }\n    }\n    getDefinition(getDefCfgNode(), null);\n    getNumUseInUseCfgNode(useCfgNode, null);\n    // Definition was not found.\n    if (def == null) {\n        return false;\n    }\n    // TODO(user): Certain cases we can still inline.\n    if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n        return false;\n    }\n    // x = readProp(b), modifyProp(b); print(x);\n    if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // x = readProp(b); modifyProp(b), print(x);\n    if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // side-effect analysis tool.\n    if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n        return false;\n    }\n    // correctly inlining twice increases code size.\n    if (numUseWithinUseCfgNode != 1) {\n        return false;\n    }\n    // Make sure that the name is not within a loop\n    if (NodeUtil.isWithinLoop(use)) {\n        return false;\n    }\n    Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n    if (uses.size() != 1) {\n        return false;\n    }\n    // need to be special cased.\n    if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            switch(input.getType()) {\n                case Token.GETELEM:\n                case Token.GETPROP:\n                case Token.ARRAYLIT:\n                case Token.OBJECTLIT:\n                case Token.REGEXP:\n                case Token.NEW:\n                    return true;\n            }\n            return false;\n        }\n    }, new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            // Recurse if the node is not a function.\n            return !input.isFunction();\n        }\n    })) {\n        return false;\n    }\n    // they are just next to each other.\n    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n        // Similar side effect check as above but this time the side effect is\n        // else where along the path.\n        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n        if (pathCheck.somePathsSatisfyPredicate()) {\n            return false;\n        }\n    }\n    return true;\n}", "code_comment": NaN, "code_no_comment": "private boolean canInline() {\n        if (getDefCfgNode().isFunction()) {\n        return false;\n    }\n        for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n            return false;\n        }\n    }\n    getDefinition(getDefCfgNode(), null);\n    getNumUseInUseCfgNode(useCfgNode, null);\n        if (def == null) {\n        return false;\n    }\n        if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n        return false;\n    }\n        if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n        if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n        if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n        return false;\n    }\n        if (numUseWithinUseCfgNode != 1) {\n        return false;\n    }\n        if (NodeUtil.isWithinLoop(use)) {\n        return false;\n    }\n    Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n    if (uses.size() != 1) {\n        return false;\n    }\n        if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            switch(input.getType()) {\n                case Token.GETELEM:\n                case Token.GETPROP:\n                case Token.ARRAYLIT:\n                case Token.OBJECTLIT:\n                case Token.REGEXP:\n                case Token.NEW:\n                    return true;\n            }\n            return false;\n        }\n    }, new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n                        return !input.isFunction();\n        }\n    })) {\n        return false;\n    }\n        if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n                                CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n        if (pathCheck.somePathsSatisfyPredicate()) {\n            return false;\n        }\n    }\n    return true;\n}", "lc": 2.3636363636363638, "pi": 0.6028708133971291, "ma": 3.4, "nbd": 1.0, "ml": 3.3333333333333335, "d": 0.4722222222222222, "mi": -1.0639887244538404, "fo": 2.1666666666666665, "r": -0.02631578947368421, "e": 1.5317231721443263}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1363_69b68890", "label": 0, "code": "/**\n * Create the {@code AuthInfo} for the specified {@code tokenInfo} as well as\n * userId and principals, that have been set upon {@link #login}.\n *\n * @param tokenInfo The tokenInfo to retrieve attributes from.\n * @return The {@code AuthInfo} resulting from the successful login.\n */\n@Nonnull\nprivate AuthInfo getAuthInfo(TokenInfo tokenInfo) {\n    Map<String, Object> attributes = new HashMap<String, Object>();\n    if (tokenProvider != null && tokenInfo != null) {\n        Map<String, String> publicAttributes = tokenInfo.getPublicAttributes();\n        for (String attrName : publicAttributes.keySet()) {\n            attributes.put(attrName, publicAttributes.get(attrName));\n        }\n    }\n    return new AuthInfoImpl(userId, attributes, principals);\n}", "code_comment": "/**\n * Create the {@code AuthInfo} for the specified {@code tokenInfo} as well as\n * userId and principals, that have been set upon {@link #login}.\n *\n * @param tokenInfo The tokenInfo to retrieve attributes from.\n * @return The {@code AuthInfo} resulting from the successful login.\n */\n", "code_no_comment": "@Nonnull\nprivate AuthInfo getAuthInfo(TokenInfo tokenInfo) {\n    Map<String, Object> attributes = new HashMap<String, Object>();\n    if (tokenProvider != null && tokenInfo != null) {\n        Map<String, String> publicAttributes = tokenInfo.getPublicAttributes();\n        for (String attrName : publicAttributes.keySet()) {\n            attributes.put(attrName, publicAttributes.get(attrName));\n        }\n    }\n    return new AuthInfoImpl(userId, attributes, principals);\n}", "lc": -0.13636363636363635, "pi": 0.35885167464114837, "ma": -0.2, "nbd": 0.0, "ml": -0.08333333333333333, "d": -0.03174603174603177, "mi": 0.09006342494714606, "fo": -0.16666666666666666, "r": 0.05263157894736841, "e": -0.011560427147986165}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-217_46f62443", "label": 1, "code": "@Override\npublic void addSplits(String tableName, SortedSet<Text> partitionKeys) throws TableNotFoundException, AccumuloException, AccumuloSecurityException {\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void addSplits(String tableName, SortedSet<Text> partitionKeys) throws TableNotFoundException, AccumuloException, AccumuloSecurityException {\n}", "lc": -0.5, "pi": -1.4306220095693782, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.9360112755461594, "fo": -0.5, "r": 0.10526315789473684, "e": -0.16279340490885932}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-3757_c1b2f2f8", "label": 3, "code": "public void process(Exchange exchange) throws Exception {\n    // process the detour so we do the detour routing\n    if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Sending to endpoint: \" + getEndpointUri() + \" is intercepted and detoured to: \" + detour + \" for exchange: \" + exchange);\n    }\n    // add header with the real endpoint uri\n    exchange.getIn().setHeader(Exchange.INTERCEPTED_ENDPOINT, delegate.getEndpointUri());\n    try {\n        detour.process(exchange);\n    } catch (Exception e) {\n        exchange.setException(e);\n    }\n    // check for error if so we should break out\n    if (!continueProcessing(exchange, \"skip sending to original intended destination: \" + getEndpointUri(), LOG)) {\n        return;\n    }\n    if (!skip) {\n        if (exchange.hasOut()) {\n            // replace OUT with IN as detour changed something\n            exchange.setIn(exchange.getOut());\n            exchange.setOut(null);\n        }\n        // route to original destination\n        producer.process(exchange);\n    } else {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Stop() means skip sending exchange to original intended destination: \" + getEndpointUri() + \" for exchange: \" + exchange);\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "public void process(Exchange exchange) throws Exception {\n        if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Sending to endpoint: \" + getEndpointUri() + \" is intercepted and detoured to: \" + detour + \" for exchange: \" + exchange);\n    }\n        exchange.getIn().setHeader(Exchange.INTERCEPTED_ENDPOINT, delegate.getEndpointUri());\n    try {\n        detour.process(exchange);\n    } catch (Exception e) {\n        exchange.setException(e);\n    }\n        if (!continueProcessing(exchange, \"skip sending to original intended destination: \" + getEndpointUri(), LOG)) {\n        return;\n    }\n    if (!skip) {\n        if (exchange.hasOut()) {\n                        exchange.setIn(exchange.getOut());\n            exchange.setOut(null);\n        }\n                producer.process(exchange);\n    } else {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Stop() means skip sending exchange to original intended destination: \" + getEndpointUri() + \" for exchange: \" + exchange);\n        }\n    }\n}", "lc": 0.5, "pi": 0.11004784688995216, "ma": 0.6, "nbd": 0.0, "ml": 0.5, "d": 0.01785714285714283, "mi": -0.37477096546863986, "fo": 1.0, "r": -0.02631578947368421, "e": 0.10625219711507984}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-225_e33328e0", "label": 3, "code": "private Expression parseFunction(String functionName) throws ParseException {\n    if (\"jcr:like\".equals(functionName)) {\n        Condition c = new Condition(parseExpression(), \"like\", null);\n        read(\",\");\n        c.right = parseExpression();\n        read(\")\");\n        return c;\n    } else if (\"jcr:contains\".equals(functionName)) {\n        Function f = new Function(\"contains\");\n        if (readIf(\".\")) {\n            // special case: jcr:contains(., expr)\n            f.params.add(new Literal(\"*\"));\n        } else {\n            f.params.add(parseExpression());\n        }\n        read(\",\");\n        f.params.add(parseExpression());\n        read(\")\");\n        return f;\n    } else if (\"jcr:score\".equals(functionName)) {\n        Function f = new Function(\"score\");\n        // TODO score: support parameters?\n        read(\")\");\n        return f;\n    } else if (\"xs:dateTime\".equals(functionName)) {\n        Expression expr = parseExpression();\n        Cast c = new Cast(expr, \"date\");\n        read(\")\");\n        return c;\n    // } else if (\"jcr:deref\".equals(functionName)) {\n    // TODO support jcr:deref?\n    } else {\n        throw getSyntaxError(\"jcr:like | jcr:contains | jcr:score | jcr:deref\");\n    }\n}", "code_comment": NaN, "code_no_comment": "private Expression parseFunction(String functionName) throws ParseException {\n    if (\"jcr:like\".equals(functionName)) {\n        Condition c = new Condition(parseExpression(), \"like\", null);\n        read(\",\");\n        c.right = parseExpression();\n        read(\")\");\n        return c;\n    } else if (\"jcr:contains\".equals(functionName)) {\n        Function f = new Function(\"contains\");\n        if (readIf(\".\")) {\n                        f.params.add(new Literal(\"*\"));\n        } else {\n            f.params.add(parseExpression());\n        }\n        read(\",\");\n        f.params.add(parseExpression());\n        read(\")\");\n        return f;\n    } else if (\"jcr:score\".equals(functionName)) {\n        Function f = new Function(\"score\");\n                read(\")\");\n        return f;\n    } else if (\"xs:dateTime\".equals(functionName)) {\n        Expression expr = parseExpression();\n        Cast c = new Cast(expr, \"date\");\n        read(\")\");\n        return c;\n            } else {\n        throw getSyntaxError(\"jcr:like | jcr:contains | jcr:score | jcr:deref\");\n    }\n}", "lc": 0.7727272727272727, "pi": -0.14832535885167467, "ma": 0.6, "nbd": 1.0, "ml": 0.5, "d": -0.3650793650793651, "mi": -0.5227625088090203, "fo": 1.1666666666666667, "r": -0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5460_a3a5a40f", "label": 1, "code": "/**\n *  @param setRenderingFlag\n *             rendering flag\n */\nvoid internalMarkRendering(boolean setRenderingFlag) {\n    if (setRenderingFlag) {\n        setFlag(FLAG_PREPARED_FOR_RENDER, false);\n        setFlag(FLAG_RENDERING, true);\n    } else {\n        setFlag(FLAG_RENDERING, false);\n    }\n}", "code_comment": "/**\n *  @param setRenderingFlag\n *             rendering flag\n */\n", "code_no_comment": "void internalMarkRendering(boolean setRenderingFlag) {\n    if (setRenderingFlag) {\n        setFlag(FLAG_PREPARED_FOR_RENDER, false);\n        setFlag(FLAG_RENDERING, true);\n    } else {\n        setFlag(FLAG_RENDERING, false);\n    }\n}", "lc": -0.2727272727272727, "pi": 0.06220095693779899, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": -0.3650793650793651, "mi": 0.4779422128259336, "fo": -0.25, "r": 2.3421052631578947, "e": -0.16279340490885932}
{"project_name": "Closure", "project_version": 158, "label": 2, "code": "/**\n * Sets options based on the configurations set flags API.\n * Called during the run() run() method.\n * If you want to ignore the flags API, or intepret flags your own way,\n * then you should override this method.\n */\nprotected final void setRunOptions(CompilerOptions options) throws FlagUsageException, IOException {\n    DiagnosticGroups diagnosticGroups = getDiagnosticGroups();\n    diagnosticGroups.setWarningLevels(options, config.jscompError, CheckLevel.ERROR);\n    diagnosticGroups.setWarningLevels(options, config.jscompWarning, CheckLevel.WARNING);\n    diagnosticGroups.setWarningLevels(options, config.jscompOff, CheckLevel.OFF);\n    createDefineOrTweakReplacements(config.define, options, false);\n    options.setTweakProcessing(config.tweakProcessing);\n    createDefineOrTweakReplacements(config.tweak, options, true);\n    options.manageClosureDependencies = config.manageClosureDependencies;\n    if (config.closureEntryPoints.size() > 0) {\n        options.setManageClosureDependencies(config.closureEntryPoints);\n    }\n    options.devMode = config.jscompDevMode;\n    options.setCodingConvention(config.codingConvention);\n    options.setSummaryDetailLevel(config.summaryDetailLevel);\n    outputCharset = options.outputCharset = getOutputCharset();\n    inputCharset = getInputCharset();\n    if (config.jsOutputFile.length() > 0) {\n        options.jsOutputFile = config.jsOutputFile;\n    }\n    if (config.createSourceMap.length() > 0) {\n        options.sourceMapOutputPath = config.createSourceMap;\n    }\n    options.sourceMapDetailLevel = config.sourceMapDetailLevel;\n    options.sourceMapFormat = config.sourceMapFormat;\n    if (!config.variableMapInputFile.equals(\"\")) {\n        options.inputVariableMapSerialized = VariableMap.load(config.variableMapInputFile).toBytes();\n    }\n    if (!config.propertyMapInputFile.equals(\"\")) {\n        options.inputPropertyMapSerialized = VariableMap.load(config.propertyMapInputFile).toBytes();\n    }\n    if (config.languageIn.length() > 0) {\n        if (config.languageIn.equals(\"ECMASCRIPT5_STRICT\") || config.languageIn.equals(\"ES5_STRICT\")) {\n            options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT5);\n        } else if (config.languageIn.equals(\"ECMASCRIPT5\") || config.languageIn.equals(\"ES5\")) {\n            options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT5);\n        } else if (config.languageIn.equals(\"ECMASCRIPT3\") || config.languageIn.equals(\"ES3\")) {\n            options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT3);\n        } else {\n            throw new FlagUsageException(\"Unknown language `\" + config.languageIn + \"' specified.\");\n        }\n    }\n    options.acceptConstKeyword = config.acceptConstKeyword;\n}", "code_comment": "/**\n * Sets options based on the configurations set flags API.\n * Called during the run() run() method.\n * If you want to ignore the flags API, or intepret flags your own way,\n * then you should override this method.\n */\n", "code_no_comment": "protected final void setRunOptions(CompilerOptions options) throws FlagUsageException, IOException {\n    DiagnosticGroups diagnosticGroups = getDiagnosticGroups();\n    diagnosticGroups.setWarningLevels(options, config.jscompError, CheckLevel.ERROR);\n    diagnosticGroups.setWarningLevels(options, config.jscompWarning, CheckLevel.WARNING);\n    diagnosticGroups.setWarningLevels(options, config.jscompOff, CheckLevel.OFF);\n    createDefineOrTweakReplacements(config.define, options, false);\n    options.setTweakProcessing(config.tweakProcessing);\n    createDefineOrTweakReplacements(config.tweak, options, true);\n    options.manageClosureDependencies = config.manageClosureDependencies;\n    if (config.closureEntryPoints.size() > 0) {\n        options.setManageClosureDependencies(config.closureEntryPoints);\n    }\n    options.devMode = config.jscompDevMode;\n    options.setCodingConvention(config.codingConvention);\n    options.setSummaryDetailLevel(config.summaryDetailLevel);\n    outputCharset = options.outputCharset = getOutputCharset();\n    inputCharset = getInputCharset();\n    if (config.jsOutputFile.length() > 0) {\n        options.jsOutputFile = config.jsOutputFile;\n    }\n    if (config.createSourceMap.length() > 0) {\n        options.sourceMapOutputPath = config.createSourceMap;\n    }\n    options.sourceMapDetailLevel = config.sourceMapDetailLevel;\n    options.sourceMapFormat = config.sourceMapFormat;\n    if (!config.variableMapInputFile.equals(\"\")) {\n        options.inputVariableMapSerialized = VariableMap.load(config.variableMapInputFile).toBytes();\n    }\n    if (!config.propertyMapInputFile.equals(\"\")) {\n        options.inputPropertyMapSerialized = VariableMap.load(config.propertyMapInputFile).toBytes();\n    }\n    if (config.languageIn.length() > 0) {\n        if (config.languageIn.equals(\"ECMASCRIPT5_STRICT\") || config.languageIn.equals(\"ES5_STRICT\")) {\n            options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT5);\n        } else if (config.languageIn.equals(\"ECMASCRIPT5\") || config.languageIn.equals(\"ES5\")) {\n            options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT5);\n        } else if (config.languageIn.equals(\"ECMASCRIPT3\") || config.languageIn.equals(\"ES3\")) {\n            options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT3);\n        } else {\n            throw new FlagUsageException(\"Unknown language `\" + config.languageIn + \"' specified.\");\n        }\n    }\n    options.acceptConstKeyword = config.acceptConstKeyword;\n}", "lc": 1.3636363636363635, "pi": -0.07177033492822985, "ma": 1.4, "nbd": 1.0, "ml": 1.5833333333333333, "d": 0.6527777777777778, "mi": -0.8615926708949962, "fo": 2.0833333333333335, "r": -0.02631578947368421, "e": 2.685147213914005}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4365_1485a856", "label": 1, "code": "/**\n *  Process the form. Though you can override this method to provide your own algorithm, it is\n *  not recommended to do so.\n *\n *  <p>\n *  See the class documentation for further details on the form processing\n *  </p>\n *\n *  @param submittingComponent\n *             component responsible for submitting the form, or <code>null</code> if none (eg\n *             the form has been submitted via the enter key or javascript calling\n *             form.onsubmit())\n *\n *  @see #delegateSubmit(IFormSubmitter) for an easy way to process submitting component in the\n *       default manner\n */\npublic void process(IFormSubmitter submittingComponent) {\n    // save the page in case the component is removed during submit\n    final Page page = getPage();\n    String hiddenFieldId = getHiddenFieldId();\n    if (!isEnabledInHierarchy() || !isVisibleInHierarchy()) {\n        // FIXME throw listener exception\n        return;\n    }\n    // run validation\n    validate();\n    // If a validation error occurred\n    if (hasError()) {\n        // mark all children as invalid\n        markFormComponentsInvalid();\n        // let subclass handle error\n        callOnError(submittingComponent);\n    } else {\n        // mark all children as valid\n        markFormComponentsValid();\n        // before updating, call the interception method for clients\n        beforeUpdateFormComponentModels();\n        // Update model using form data\n        updateFormComponentModels();\n        // validate model objects after input values have been bound\n        onValidateModelObjects();\n        if (hasError()) {\n            callOnError(submittingComponent);\n            return;\n        }\n        // Form has no error\n        delegateSubmit(submittingComponent);\n    }\n}", "code_comment": "/**\n *  Process the form. Though you can override this method to provide your own algorithm, it is\n *  not recommended to do so.\n *\n *  <p>\n *  See the class documentation for further details on the form processing\n *  </p>\n *\n *  @param submittingComponent\n *             component responsible for submitting the form, or <code>null</code> if none (eg\n *             the form has been submitted via the enter key or javascript calling\n *             form.onsubmit())\n *\n *  @see #delegateSubmit(IFormSubmitter) for an easy way to process submitting component in the\n *       default manner\n */\n", "code_no_comment": "public void process(IFormSubmitter submittingComponent) {\n        final Page page = getPage();\n    String hiddenFieldId = getHiddenFieldId();\n    if (!isEnabledInHierarchy() || !isVisibleInHierarchy()) {\n                return;\n    }\n        validate();\n        if (hasError()) {\n                markFormComponentsInvalid();\n                callOnError(submittingComponent);\n    } else {\n                markFormComponentsValid();\n                beforeUpdateFormComponentModels();\n                updateFormComponentModels();\n                onValidateModelObjects();\n        if (hasError()) {\n            callOnError(submittingComponent);\n            return;\n        }\n                delegateSubmit(submittingComponent);\n    }\n}", "lc": 0.36363636363636365, "pi": 0.0669856459330142, "ma": 0.0, "nbd": 0.0, "ml": 0.16666666666666666, "d": -0.11904761904761907, "mi": -0.18646934460887932, "fo": 0.75, "r": 0.0, "e": -0.08166064441025109}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-5515_b3bb8670", "label": 1, "code": "/**\n * Continues processing the {@link org.apache.camel.Exchange} using asynchronous routing engine.\n *\n * @param poolSize    the core pool size\n * @param maxPoolSize the maximum pool size\n * @param threadName the thread pool name\n * @return the builder\n */\npublic ThreadsDefinition threads(int poolSize, int maxPoolSize, String threadName) {\n    ThreadsDefinition answer = threads();\n    answer.setPoolSize(poolSize);\n    answer.setMaxPoolSize(maxPoolSize);\n    answer.setThreadName(threadName);\n    addOutput(answer);\n    return answer;\n}", "code_comment": "/**\n * Continues processing the {@link org.apache.camel.Exchange} using asynchronous routing engine.\n *\n * @param poolSize    the core pool size\n * @param maxPoolSize the maximum pool size\n * @param threadName the thread pool name\n * @return the builder\n */\n", "code_no_comment": "public ThreadsDefinition threads(int poolSize, int maxPoolSize, String threadName) {\n    ThreadsDefinition answer = threads();\n    answer.setPoolSize(poolSize);\n    answer.setMaxPoolSize(maxPoolSize);\n    answer.setThreadName(threadName);\n    addOutput(answer);\n    return answer;\n}", "lc": -0.2727272727272727, "pi": -0.6028708133971293, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.3699788583509513, "fo": -0.08333333333333333, "r": 1.4999999999999998, "e": -0.16279340490885932}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-290_b01fcc31", "label": 1, "code": "/**\n * Create the tableau by itself.\n * @param maximize if true, goal is to maximize the objective function\n * @return created tableau\n */\nprotected double[][] createTableau(final boolean maximize) {\n    // create a matrix of the correct size\n    List<LinearConstraint> constraints = getNormalizedConstraints();\n    int width = numDecisionVariables + numSlackVariables + numArtificialVariables + getNumObjectiveFunctions() + // + 1 is for RHS\n    1;\n    int height = constraints.size() + getNumObjectiveFunctions();\n    double[][] matrix = new double[height][width];\n    // initialize the objective function rows\n    if (getNumObjectiveFunctions() == 2) {\n        matrix[0][0] = -1;\n    }\n    int zIndex = (getNumObjectiveFunctions() == 1) ? 0 : 1;\n    matrix[zIndex][zIndex] = maximize ? 1 : -1;\n    RealVector objectiveCoefficients = maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients();\n    copyArray(objectiveCoefficients.getData(), matrix[zIndex], getNumObjectiveFunctions());\n    matrix[zIndex][width - 1] = maximize ? f.getConstantTerm() : -1 * f.getConstantTerm();\n    if (!restrictToNonNegative) {\n        matrix[zIndex][getSlackVariableOffset() - 1] = getInvertedCoeffiecientSum(objectiveCoefficients);\n    }\n    // initialize the constraint rows\n    int slackVar = 0;\n    int artificialVar = 0;\n    for (int i = 0; i < constraints.size(); i++) {\n        LinearConstraint constraint = constraints.get(i);\n        int row = getNumObjectiveFunctions() + i;\n        // decision variable coefficients\n        copyArray(constraint.getCoefficients().getData(), matrix[row], 1);\n        // x-\n        if (!restrictToNonNegative) {\n            matrix[row][getSlackVariableOffset() - 1] = getInvertedCoeffiecientSum(constraint.getCoefficients());\n        }\n        // RHS\n        matrix[row][width - 1] = constraint.getValue();\n        // slack variables\n        if (constraint.getRelationship() == Relationship.LEQ) {\n            // slack\n            matrix[row][getSlackVariableOffset() + slackVar++] = 1;\n        } else if (constraint.getRelationship() == Relationship.GEQ) {\n            // excess\n            matrix[row][getSlackVariableOffset() + slackVar++] = -1;\n        }\n        // artificial variables\n        if ((constraint.getRelationship() == Relationship.EQ) || (constraint.getRelationship() == Relationship.GEQ)) {\n            matrix[0][getArtificialVariableOffset() + artificialVar] = 1;\n            matrix[row][getArtificialVariableOffset() + artificialVar++] = 1;\n        }\n    }\n    return matrix;\n}", "code_comment": "/**\n * Create the tableau by itself.\n * @param maximize if true, goal is to maximize the objective function\n * @return created tableau\n */\n", "code_no_comment": "protected double[][] createTableau(final boolean maximize) {\n        List<LinearConstraint> constraints = getNormalizedConstraints();\n    int width = numDecisionVariables + numSlackVariables + numArtificialVariables + getNumObjectiveFunctions() +     1;\n    int height = constraints.size() + getNumObjectiveFunctions();\n    double[][] matrix = new double[height][width];\n        if (getNumObjectiveFunctions() == 2) {\n        matrix[0][0] = -1;\n    }\n    int zIndex = (getNumObjectiveFunctions() == 1) ? 0 : 1;\n    matrix[zIndex][zIndex] = maximize ? 1 : -1;\n    RealVector objectiveCoefficients = maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients();\n    copyArray(objectiveCoefficients.getData(), matrix[zIndex], getNumObjectiveFunctions());\n    matrix[zIndex][width - 1] = maximize ? f.getConstantTerm() : -1 * f.getConstantTerm();\n    if (!restrictToNonNegative) {\n        matrix[zIndex][getSlackVariableOffset() - 1] = getInvertedCoeffiecientSum(objectiveCoefficients);\n    }\n        int slackVar = 0;\n    int artificialVar = 0;\n    for (int i = 0; i < constraints.size(); i++) {\n        LinearConstraint constraint = constraints.get(i);\n        int row = getNumObjectiveFunctions() + i;\n                copyArray(constraint.getCoefficients().getData(), matrix[row], 1);\n                if (!restrictToNonNegative) {\n            matrix[row][getSlackVariableOffset() - 1] = getInvertedCoeffiecientSum(constraint.getCoefficients());\n        }\n                matrix[row][width - 1] = constraint.getValue();\n                if (constraint.getRelationship() == Relationship.LEQ) {\n                        matrix[row][getSlackVariableOffset() + slackVar++] = 1;\n        } else if (constraint.getRelationship() == Relationship.GEQ) {\n                        matrix[row][getSlackVariableOffset() + slackVar++] = -1;\n        }\n                if ((constraint.getRelationship() == Relationship.EQ) || (constraint.getRelationship() == Relationship.GEQ)) {\n            matrix[0][getArtificialVariableOffset() + artificialVar] = 1;\n            matrix[row][getArtificialVariableOffset() + artificialVar++] = 1;\n        }\n    }\n    return matrix;\n}", "lc": 1.1363636363636365, "pi": 0.06220095693779899, "ma": 1.6, "nbd": 0.5, "ml": 1.0833333333333333, "d": 2.3115079365079367, "mi": -0.8026779422128256, "fo": 2.3333333333333335, "r": -0.02631578947368421, "e": 6.820608219083348}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-172_99e22ce4", "label": 1, "code": "/**\n *  @return iterator over item instances that exist as children of this view\n */\npublic Iterator<Item<T>> getItems() {\n    final Iterator<Component> iterator = iterator();\n    return new Iterator<Item<T>>() {\n\n        public boolean hasNext() {\n            return iterator.hasNext();\n        }\n\n        public Item<T> next() {\n            return (Item<T>) iterator.next();\n        }\n\n        public void remove() {\n            iterator.remove();\n        }\n    };\n}", "code_comment": "/**\n *  @return iterator over item instances that exist as children of this view\n */\n", "code_no_comment": "public Iterator<Item<T>> getItems() {\n    final Iterator<Component> iterator = iterator();\n    return new Iterator<Item<T>>() {\n\n        public boolean hasNext() {\n            return iterator.hasNext();\n        }\n\n        public Item<T> next() {\n            return (Item<T>) iterator.next();\n        }\n\n        public void remove() {\n            iterator.remove();\n        }\n    };\n}", "lc": 0.0, "pi": 0.40191387559808606, "ma": -0.6, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.1064129668780833, "fo": -0.16666666666666666, "r": 1.0526315789473684, "e": -0.16279340490885932}
{"project_name": "Compress", "project_version": 45, "label": 3, "code": "/**\n * Write an long integer into a buffer as an octal string if this\n * will fit, or as a binary number otherwise.\n *\n * Uses {@link #formatUnsignedOctalString} to format\n * the value as an octal string with leading zeros.\n * The converted number is followed by a space.\n *\n * @param value The value to write into the buffer.\n * @param buf The destination buffer.\n * @param offset The starting offset into the buffer.\n * @param length The length of the buffer.\n * @return The updated offset.\n * @throws IllegalArgumentException if the value (and trailer)\n * will not fit in the buffer.\n * @since 1.4\n */\npublic static int formatLongOctalOrBinaryBytes(final long value, final byte[] buf, final int offset, final int length) {\n    // Check whether we are dealing with UID/GID or SIZE field\n    final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;\n    final boolean negative = value < 0;\n    if (!negative && value <= maxAsOctalChar) {\n        // OK to store as octal chars\n        return formatLongOctalBytes(value, buf, offset, length);\n    }\n    if (length < 9) {\n        formatLongBinary(value, buf, offset, length, negative);\n    }\n    formatBigIntegerBinary(value, buf, offset, length, negative);\n    buf[offset] = (byte) (negative ? 0xff : 0x80);\n    return offset + length;\n}", "code_comment": "/**\n * Write an long integer into a buffer as an octal string if this\n * will fit, or as a binary number otherwise.\n *\n * Uses {@link #formatUnsignedOctalString} to format\n * the value as an octal string with leading zeros.\n * The converted number is followed by a space.\n *\n * @param value The value to write into the buffer.\n * @param buf The destination buffer.\n * @param offset The starting offset into the buffer.\n * @param length The length of the buffer.\n * @return The updated offset.\n * @throws IllegalArgumentException if the value (and trailer)\n * will not fit in the buffer.\n * @since 1.4\n */\n", "code_no_comment": "public static int formatLongOctalOrBinaryBytes(final long value, final byte[] buf, final int offset, final int length) {\n        final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;\n    final boolean negative = value < 0;\n    if (!negative && value <= maxAsOctalChar) {\n                return formatLongOctalBytes(value, buf, offset, length);\n    }\n    if (length < 9) {\n        formatLongBinary(value, buf, offset, length, negative);\n    }\n    formatBigIntegerBinary(value, buf, offset, length, negative);\n    buf[offset] = (byte) (negative ? 0xff : 0x80);\n    return offset + length;\n}", "lc": -0.045454545454545456, "pi": -0.368421052631579, "ma": 0.2, "nbd": -0.5, "ml": 0.3333333333333333, "d": 1.0753968253968254, "mi": -0.04298801973220593, "fo": -0.25, "r": -0.02631578947368421, "e": 0.7186298069996483}
{"project_name": "Closure", "project_version": 148, "label": 2, "code": "/**\n * Adds a mapping for the given node.  Mappings must be added in order.\n *\n * @param node The node that the new mapping represents.\n * @param startPosition The position on the starting line\n * @param endPosition The position on the ending line.\n */\nvoid addMapping(Node node, Position startPosition, Position endPosition) {\n    String sourceFile = (String) node.getProp(Node.SOURCEFILE_PROP);\n    // information for a mapping to be useful.\n    if (sourceFile == null || node.getLineno() < 0) {\n        return;\n    }\n    String escapedSourceFile;\n    if (lastSourceFile != sourceFile) {\n        // yes, \"s1 != s2\" not \"!s1.equals(s2)\"\n        lastSourceFile = sourceFile;\n        lastSourceFileEscaped = escapeString(sourceFile);\n    }\n    escapedSourceFile = lastSourceFileEscaped;\n    // Create the new mapping.\n    Mapping mapping = new Mapping();\n    mapping.id = mappings.size();\n    mapping.sourceFile = escapedSourceFile;\n    mapping.originalPosition = new Position(node.getLineno(), node.getCharno());\n    String originalName = (String) node.getProp(Node.ORIGINALNAME_PROP);\n    if (originalName != null) {\n        mapping.originalName = escapeString(originalName);\n    }\n    // If the mapping is found on the first line, we need to offset\n    // its character position by the number of characters found on\n    // the *last* line of the source file to which the code is\n    // being generated.\n    int offsetLine = offsetPosition.getLineNumber();\n    int startOffsetPosition = offsetPosition.getCharacterIndex();\n    int endOffsetPosition = offsetPosition.getCharacterIndex();\n    if (startPosition.getLineNumber() > 0) {\n        startOffsetPosition = 0;\n    }\n    if (endPosition.getLineNumber() > 0) {\n        endOffsetPosition = 0;\n    }\n    mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition);\n    mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition);\n    mappings.add(mapping);\n}", "code_comment": "/**\n * Adds a mapping for the given node.  Mappings must be added in order.\n *\n * @param node The node that the new mapping represents.\n * @param startPosition The position on the starting line\n * @param endPosition The position on the ending line.\n */\n", "code_no_comment": "void addMapping(Node node, Position startPosition, Position endPosition) {\n    String sourceFile = (String) node.getProp(Node.SOURCEFILE_PROP);\n        if (sourceFile == null || node.getLineno() < 0) {\n        return;\n    }\n    String escapedSourceFile;\n    if (lastSourceFile != sourceFile) {\n                lastSourceFile = sourceFile;\n        lastSourceFileEscaped = escapeString(sourceFile);\n    }\n    escapedSourceFile = lastSourceFileEscaped;\n        Mapping mapping = new Mapping();\n    mapping.id = mappings.size();\n    mapping.sourceFile = escapedSourceFile;\n    mapping.originalPosition = new Position(node.getLineno(), node.getCharno());\n    String originalName = (String) node.getProp(Node.ORIGINALNAME_PROP);\n    if (originalName != null) {\n        mapping.originalName = escapeString(originalName);\n    }\n                    int offsetLine = offsetPosition.getLineNumber();\n    int startOffsetPosition = offsetPosition.getCharacterIndex();\n    int endOffsetPosition = offsetPosition.getCharacterIndex();\n    if (startPosition.getLineNumber() > 0) {\n        startOffsetPosition = 0;\n    }\n    if (endPosition.getLineNumber() > 0) {\n        endOffsetPosition = 0;\n    }\n    mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition);\n    mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition);\n    mappings.add(mapping);\n}", "lc": 0.8181818181818182, "pi": -0.5023923444976078, "ma": 0.4, "nbd": -0.5, "ml": 0.5833333333333334, "d": 1.402777777777778, "mi": -0.6022551092318531, "fo": 1.0, "r": -0.02631578947368421, "e": 2.676779447104994}
{"project_name": "Csv", "project_version": 4, "label": 1, "code": "/**\n * Returns a copy of the header map that iterates in column order.\n * <p>\n * The map keys are column names. The map values are 0-based indices.\n * </p>\n * @return a copy of the header map that iterates in column order.\n */\npublic Map<String, Integer> getHeaderMap() {\n    return new LinkedHashMap<String, Integer>(this.headerMap);\n}", "code_comment": "/**\n * Returns a copy of the header map that iterates in column order.\n * <p>\n * The map keys are column names. The map values are 0-based indices.\n * </p>\n * @return a copy of the header map that iterates in column order.\n */\n", "code_no_comment": "public Map<String, Integer> getHeaderMap() {\n    return new LinkedHashMap<String, Integer>(this.headerMap);\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.9960535588442565, "fo": -0.5, "r": 2.131578947368421, "e": -0.16279340490885932}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1199_813109d7", "label": 3, "code": "public void read(org.apache.thrift.protocol.TProtocol iprot, removeConstraint_result struct) throws org.apache.thrift.TException {\n    org.apache.thrift.protocol.TField schemeField;\n    iprot.readStructBegin();\n    while (true) {\n        schemeField = iprot.readFieldBegin();\n        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {\n            break;\n        }\n        switch(schemeField.id) {\n            case // OUCH1\n            1:\n                if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {\n                    struct.ouch1 = new AccumuloException();\n                    struct.ouch1.read(iprot);\n                    struct.setOuch1IsSet(true);\n                } else {\n                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);\n                }\n                break;\n            case // OUCH2\n            2:\n                if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {\n                    struct.ouch2 = new AccumuloSecurityException();\n                    struct.ouch2.read(iprot);\n                    struct.setOuch2IsSet(true);\n                } else {\n                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);\n                }\n                break;\n            default:\n                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);\n        }\n        iprot.readFieldEnd();\n    }\n    iprot.readStructEnd();\n    // check for required fields of primitive type, which can't be checked in the validate method\n    struct.validate();\n}", "code_comment": NaN, "code_no_comment": "public void read(org.apache.thrift.protocol.TProtocol iprot, removeConstraint_result struct) throws org.apache.thrift.TException {\n    org.apache.thrift.protocol.TField schemeField;\n    iprot.readStructBegin();\n    while (true) {\n        schemeField = iprot.readFieldBegin();\n        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {\n            break;\n        }\n        switch(schemeField.id) {\n            case             1:\n                if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {\n                    struct.ouch1 = new AccumuloException();\n                    struct.ouch1.read(iprot);\n                    struct.setOuch1IsSet(true);\n                } else {\n                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);\n                }\n                break;\n            case             2:\n                if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {\n                    struct.ouch2 = new AccumuloSecurityException();\n                    struct.ouch2.read(iprot);\n                    struct.setOuch2IsSet(true);\n                } else {\n                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);\n                }\n                break;\n            default:\n                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);\n        }\n        iprot.readFieldEnd();\n    }\n    iprot.readStructEnd();\n        struct.validate();\n}", "lc": 1.0454545454545454, "pi": 1.535885167464115, "ma": 1.4, "nbd": 1.0, "ml": 0.25, "d": 0.2599206349206349, "mi": -0.6763918252290345, "fo": 0.5, "r": -0.02631578947368421, "e": 0.6848267952951481}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-776_dc9f23d9", "label": 3, "code": "@Override\npublic IteratorOptions describeOptions() {\n    IteratorOptions io = super.describeOptions();\n    io.setName(\"tsfilter\");\n    io.setDescription(\"TimestampFilter displays entries with timestamps between specified values\");\n    io.addNamedOption(\"start\", \"start timestamp (yyyyMMddHHmmssz)\");\n    io.addNamedOption(\"end\", \"end timestamp (yyyyMMddHHmmssz)\");\n    io.addNamedOption(\"startInclusive\", \"true or false\");\n    io.addNamedOption(\"endInclusive\", \"true or false\");\n    return io;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic IteratorOptions describeOptions() {\n    IteratorOptions io = super.describeOptions();\n    io.setName(\"tsfilter\");\n    io.setDescription(\"TimestampFilter displays entries with timestamps between specified values\");\n    io.addNamedOption(\"start\", \"start timestamp (yyyyMMddHHmmssz)\");\n    io.addNamedOption(\"end\", \"end timestamp (yyyyMMddHHmmssz)\");\n    io.addNamedOption(\"startInclusive\", \"true or false\");\n    io.addNamedOption(\"endInclusive\", \"true or false\");\n    return io;\n}", "lc": -0.13636363636363635, "pi": -0.5789473684210528, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.16335447498238198, "fo": 0.08333333333333333, "r": -0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "Lang", "project_version": 20, "label": 1, "code": "/**\n * <p>Joins the elements of the provided array into a single String\n * containing the provided list of elements.</p>\n *\n * <p>No delimiter is added before or after the list.\n * Null objects or empty strings within the array are represented by\n * empty strings.</p>\n *\n * <pre>\n * StringUtils.join(null, *)               = null\n * StringUtils.join([], *)                 = \"\"\n * StringUtils.join([null], *)             = \"\"\n * StringUtils.join([\"a\", \"b\", \"c\"], ';')  = \"a;b;c\"\n * StringUtils.join([\"a\", \"b\", \"c\"], null) = \"abc\"\n * StringUtils.join([null, \"\", \"a\"], ';')  = \";;a\"\n * </pre>\n *\n * @param array  the array of values to join together, may be null\n * @param separator  the separator character to use\n * @param startIndex the first index to start joining from.  It is\n * an error to pass in an end index past the end of the array\n * @param endIndex the index to stop joining from (exclusive). It is\n * an error to pass in an end index past the end of the array\n * @return the joined String, {@code null} if null array input\n * @since 2.0\n */\npublic static String join(Object[] array, char separator, int startIndex, int endIndex) {\n    if (array == null) {\n        return null;\n    }\n    int noOfItems = (endIndex - startIndex);\n    if (noOfItems <= 0) {\n        return EMPTY;\n    }\n    StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);\n    for (int i = startIndex; i < endIndex; i++) {\n        if (i > startIndex) {\n            buf.append(separator);\n        }\n        if (array[i] != null) {\n            buf.append(array[i]);\n        }\n    }\n    return buf.toString();\n}", "code_comment": "/**\n * <p>Joins the elements of the provided array into a single String\n * containing the provided list of elements.</p>\n *\n * <p>No delimiter is added before or after the list.\n * Null objects or empty strings within the array are represented by\n * empty strings.</p>\n *\n * <pre>\n * StringUtils.join(null, *)               = null\n * StringUtils.join([], *)                 = \"\"\n * StringUtils.join([null], *)             = \"\"\n * StringUtils.join([\"a\", \"b\", \"c\"], ';')  = \"a;b;c\"\n * StringUtils.join([\"a\", \"b\", \"c\"], null) = \"abc\"\n * StringUtils.join([null, \"\", \"a\"], ';')  = \";;a\"\n * </pre>\n *\n * @param array  the array of values to join together, may be null\n * @param separator  the separator character to use\n * @param startIndex the first index to start joining from.  It is\n * an error to pass in an end index past the end of the array\n * @param endIndex the index to stop joining from (exclusive). It is\n * an error to pass in an end index past the end of the array\n * @return the joined String, {@code null} if null array input\n * @since 2.0\n */\n", "code_no_comment": "public static String join(Object[] array, char separator, int startIndex, int endIndex) {\n    if (array == null) {\n        return null;\n    }\n    int noOfItems = (endIndex - startIndex);\n    if (noOfItems <= 0) {\n        return EMPTY;\n    }\n    StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);\n    for (int i = startIndex; i < endIndex; i++) {\n        if (i > startIndex) {\n            buf.append(separator);\n        }\n        if (array[i] != null) {\n            buf.append(array[i]);\n        }\n    }\n    return buf.toString();\n}", "lc": 0.22727272727272727, "pi": 0.1291866028708132, "ma": 0.6, "nbd": 0.0, "ml": 0.5, "d": 1.5396825396825395, "mi": -0.24425651867512305, "fo": -0.08333333333333333, "r": -0.02631578947368421, "e": 1.1272718890291198}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-366_db4a291f", "label": 1, "code": "private synchronized void retry(ZooRunnable op) {\n    int sleepTime = 100;\n    while (true) {\n        ZooKeeper zooKeeper = getZooKeeper();\n        try {\n            op.run(zooKeeper);\n            return;\n        } catch (KeeperException e) {\n            if (e.code() == Code.NONODE) {\n                log.error(\"Looked up non existant node in cache \" + e.getPath(), e);\n            }\n            log.warn(\"Zookeeper error, will retry\", e);\n        } catch (InterruptedException e) {\n            log.warn(\"Zookeeper error, will retry\", e);\n        } catch (ConcurrentModificationException e) {\n            log.debug(\"Zookeeper was modified, will retry\");\n        }\n        try {\n            // do not hold lock while sleeping\n            wait(sleepTime);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        if (sleepTime < 10000)\n            sleepTime = (int) (sleepTime + sleepTime * Math.random());\n    }\n}", "code_comment": NaN, "code_no_comment": "private synchronized void retry(ZooRunnable op) {\n    int sleepTime = 100;\n    while (true) {\n        ZooKeeper zooKeeper = getZooKeeper();\n        try {\n            op.run(zooKeeper);\n            return;\n        } catch (KeeperException e) {\n            if (e.code() == Code.NONODE) {\n                log.error(\"Looked up non existant node in cache \" + e.getPath(), e);\n            }\n            log.warn(\"Zookeeper error, will retry\", e);\n        } catch (InterruptedException e) {\n            log.warn(\"Zookeeper error, will retry\", e);\n        } catch (ConcurrentModificationException e) {\n            log.debug(\"Zookeeper was modified, will retry\");\n        }\n        try {\n                        wait(sleepTime);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        if (sleepTime < 10000)\n            sleepTime = (int) (sleepTime + sleepTime * Math.random());\n    }\n}", "lc": 0.5454545454545454, "pi": 0.41148325358851673, "ma": 0.8, "nbd": 0.5, "ml": 0.0, "d": 0.31349206349206343, "mi": -0.40549682875264276, "fo": 0.4166666666666667, "r": -0.02631578947368421, "e": 0.3343625917025408}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-276_1bf5c550", "label": 1, "code": "public Id readHead() throws Exception {\n    Connection con = cp.getConnection();\n    try {\n        PreparedStatement stmt = con.prepareStatement(\"select * from HEAD\");\n        ResultSet rs = stmt.executeQuery();\n        byte[] rawId = null;\n        if (rs.next()) {\n            rawId = rs.getBytes(1);\n        }\n        stmt.close();\n        return rawId == null ? null : new Id(rawId);\n    } finally {\n        con.close();\n    }\n}", "code_comment": NaN, "code_no_comment": "public Id readHead() throws Exception {\n    Connection con = cp.getConnection();\n    try {\n        PreparedStatement stmt = con.prepareStatement(\"select * from HEAD\");\n        ResultSet rs = stmt.executeQuery();\n        byte[] rawId = null;\n        if (rs.next()) {\n            rawId = rs.getBytes(1);\n        }\n        stmt.close();\n        return rawId == null ? null : new Id(rawId);\n    } finally {\n        con.close();\n    }\n}", "lc": 0.045454545454545456, "pi": 0.11004784688995216, "ma": -0.2, "nbd": 0.0, "ml": -0.08333333333333333, "d": -0.04365079365079365, "mi": -0.04045102184637074, "fo": 0.08333333333333333, "r": 0.7105263157894737, "e": -0.02773349930556757}
{"project_name": "Closure", "project_version": 169, "label": 2, "code": "JSType getGreatestSubtypeHelper(JSType that) {\n    if (that.isRecordType()) {\n        RecordType thatRecord = that.toMaybeRecordType();\n        RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n        builder.setSynthesized(true);\n        // is returned.\n        for (String property : properties.keySet()) {\n            if (thatRecord.hasProperty(property) && !thatRecord.getPropertyType(property).isInvariant(getPropertyType(property))) {\n                return registry.getNativeObjectType(JSTypeNative.NO_TYPE);\n            }\n            builder.addProperty(property, getPropertyType(property), getPropertyNode(property));\n        }\n        for (String property : thatRecord.properties.keySet()) {\n            if (!hasProperty(property)) {\n                builder.addProperty(property, thatRecord.getPropertyType(property), thatRecord.getPropertyNode(property));\n            }\n        }\n        return builder.build();\n    }\n    JSType greatestSubtype = registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n    JSType thatRestrictedToObj = registry.getNativeType(JSTypeNative.OBJECT_TYPE).getGreatestSubtype(that);\n    if (!thatRestrictedToObj.isEmptyType()) {\n        // 2) Take the intersection of all of these unions.\n        for (Map.Entry<String, JSType> entry : properties.entrySet()) {\n            String propName = entry.getKey();\n            JSType propType = entry.getValue();\n            UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n            for (ObjectType alt : registry.getEachReferenceTypeWithProperty(propName)) {\n                JSType altPropType = alt.getPropertyType(propName);\n                if (altPropType != null && !alt.isEquivalentTo(this) && alt.isSubtype(that) && (propType.isUnknownType() || altPropType.isUnknownType() || altPropType.isEquivalentTo(propType))) {\n                    builder.addAlternate(alt);\n                }\n            }\n            greatestSubtype = greatestSubtype.getLeastSupertype(builder.build());\n        }\n    }\n    return greatestSubtype;\n}", "code_comment": NaN, "code_no_comment": "JSType getGreatestSubtypeHelper(JSType that) {\n    if (that.isRecordType()) {\n        RecordType thatRecord = that.toMaybeRecordType();\n        RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n        builder.setSynthesized(true);\n                for (String property : properties.keySet()) {\n            if (thatRecord.hasProperty(property) && !thatRecord.getPropertyType(property).isInvariant(getPropertyType(property))) {\n                return registry.getNativeObjectType(JSTypeNative.NO_TYPE);\n            }\n            builder.addProperty(property, getPropertyType(property), getPropertyNode(property));\n        }\n        for (String property : thatRecord.properties.keySet()) {\n            if (!hasProperty(property)) {\n                builder.addProperty(property, thatRecord.getPropertyType(property), thatRecord.getPropertyNode(property));\n            }\n        }\n        return builder.build();\n    }\n    JSType greatestSubtype = registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n    JSType thatRestrictedToObj = registry.getNativeType(JSTypeNative.OBJECT_TYPE).getGreatestSubtype(that);\n    if (!thatRestrictedToObj.isEmptyType()) {\n                for (Map.Entry<String, JSType> entry : properties.entrySet()) {\n            String propName = entry.getKey();\n            JSType propType = entry.getValue();\n            UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n            for (ObjectType alt : registry.getEachReferenceTypeWithProperty(propName)) {\n                JSType altPropType = alt.getPropertyType(propName);\n                if (altPropType != null && !alt.isEquivalentTo(this) && alt.isSubtype(that) && (propType.isUnknownType() || altPropType.isUnknownType() || altPropType.isEquivalentTo(propType))) {\n                    builder.addAlternate(alt);\n                }\n            }\n            greatestSubtype = greatestSubtype.getLeastSupertype(builder.build());\n        }\n    }\n    return greatestSubtype;\n}", "lc": 1.0, "pi": 0.8325358851674642, "ma": 1.2, "nbd": 1.0, "ml": 1.75, "d": 0.6111111111111112, "mi": -0.7136011275546157, "fo": 2.4166666666666665, "r": -0.02631578947368421, "e": 1.7833324688946133}
{"project_name": "Closure", "project_version": 14, "label": 2, "code": "/**\n * Computes the follow() node of a given node and its parent. There is a side\n * effect when calling this function. If this function computed an edge that\n * exists a FINALLY, it'll attempt to connect the fromNode to the outer\n * FINALLY according to the finallyMap.\n *\n * @param fromNode The original source node since {@code node} is changed\n *        during recursion.\n * @param node The node that follow() should compute.\n */\nprivate static Node computeFollowNode(Node fromNode, Node node, ControlFlowAnalysis cfa) {\n    /*\n     * This is the case where:\n     *\n     * 1. Parent is null implies that we are transferring control to the end of\n     * the script.\n     *\n     * 2. Parent is a function implies that we are transferring control back to\n     * the caller of the function.\n     *\n     * 3. If the node is a return statement, we should also transfer control\n     * back to the caller of the function.\n     *\n     * 4. If the node is root then we have reached the end of what we have been\n     * asked to traverse.\n     *\n     * In all cases we should transfer control to a \"symbolic return\" node.\n     * This will make life easier for DFAs.\n     */\n    Node parent = node.getParent();\n    if (parent == null || parent.isFunction() || (cfa != null && node == cfa.root)) {\n        return null;\n    }\n    // If we are just before a IF/WHILE/DO/FOR:\n    switch(parent.getType()) {\n        // The follow() of any of the path from IF would be what follows IF.\n        case Token.IF:\n            return computeFollowNode(fromNode, parent, cfa);\n        case Token.CASE:\n        case Token.DEFAULT_CASE:\n            // case, without having to go to the case condition.\n            if (parent.getNext() != null) {\n                if (parent.getNext().isCase()) {\n                    return parent.getNext().getFirstChild().getNext();\n                } else if (parent.getNext().isDefaultCase()) {\n                    return parent.getNext().getFirstChild();\n                } else {\n                    Preconditions.checkState(false, \"Not reachable\");\n                }\n            } else {\n                return computeFollowNode(fromNode, parent, cfa);\n            }\n            break;\n        case Token.FOR:\n            if (NodeUtil.isForIn(parent)) {\n                return parent;\n            } else {\n                return parent.getFirstChild().getNext().getNext();\n            }\n        case Token.WHILE:\n        case Token.DO:\n            return parent;\n        case Token.TRY:\n            // If we are coming out of the TRY block...\n            if (parent.getFirstChild() == node) {\n                if (NodeUtil.hasFinally(parent)) {\n                    // and have FINALLY block.\n                    return computeFallThrough(parent.getLastChild());\n                } else {\n                    // and have no FINALLY.\n                    return computeFollowNode(fromNode, parent, cfa);\n                }\n            // CATCH block.\n            } else if (NodeUtil.getCatchBlock(parent) == node) {\n                if (NodeUtil.hasFinally(parent)) {\n                    // and have FINALLY block.\n                    return computeFallThrough(node.getNext());\n                } else {\n                    return computeFollowNode(fromNode, parent, cfa);\n                }\n            // If we are coming out of the FINALLY block...\n            } else if (parent.getLastChild() == node) {\n                if (cfa != null) {\n                    for (Node finallyNode : cfa.finallyMap.get(parent)) {\n                        cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n                    }\n                }\n                return computeFollowNode(fromNode, parent, cfa);\n            }\n    }\n    // Now that we are done with the special cases follow should be its\n    // immediate sibling, unless its sibling is a function\n    Node nextSibling = node.getNext();\n    // Skip function declarations because control doesn't get pass into it.\n    while (nextSibling != null && nextSibling.isFunction()) {\n        nextSibling = nextSibling.getNext();\n    }\n    if (nextSibling != null) {\n        return computeFallThrough(nextSibling);\n    } else {\n        // If there are no more siblings, control is transferred up the AST.\n        return computeFollowNode(fromNode, parent, cfa);\n    }\n}", "code_comment": "/**\n * Computes the follow() node of a given node and its parent. There is a side\n * effect when calling this function. If this function computed an edge that\n * exists a FINALLY, it'll attempt to connect the fromNode to the outer\n * FINALLY according to the finallyMap.\n *\n * @param fromNode The original source node since {@code node} is changed\n *        during recursion.\n * @param node The node that follow() should compute.\n */\n", "code_no_comment": "private static Node computeFollowNode(Node fromNode, Node node, ControlFlowAnalysis cfa) {\n        Node parent = node.getParent();\n    if (parent == null || parent.isFunction() || (cfa != null && node == cfa.root)) {\n        return null;\n    }\n        switch(parent.getType()) {\n                case Token.IF:\n            return computeFollowNode(fromNode, parent, cfa);\n        case Token.CASE:\n        case Token.DEFAULT_CASE:\n                        if (parent.getNext() != null) {\n                if (parent.getNext().isCase()) {\n                    return parent.getNext().getFirstChild().getNext();\n                } else if (parent.getNext().isDefaultCase()) {\n                    return parent.getNext().getFirstChild();\n                } else {\n                    Preconditions.checkState(false, \"Not reachable\");\n                }\n            } else {\n                return computeFollowNode(fromNode, parent, cfa);\n            }\n            break;\n        case Token.FOR:\n            if (NodeUtil.isForIn(parent)) {\n                return parent;\n            } else {\n                return parent.getFirstChild().getNext().getNext();\n            }\n        case Token.WHILE:\n        case Token.DO:\n            return parent;\n        case Token.TRY:\n                        if (parent.getFirstChild() == node) {\n                if (NodeUtil.hasFinally(parent)) {\n                                        return computeFallThrough(parent.getLastChild());\n                } else {\n                                        return computeFollowNode(fromNode, parent, cfa);\n                }\n                        } else if (NodeUtil.getCatchBlock(parent) == node) {\n                if (NodeUtil.hasFinally(parent)) {\n                                        return computeFallThrough(node.getNext());\n                } else {\n                    return computeFollowNode(fromNode, parent, cfa);\n                }\n                        } else if (parent.getLastChild() == node) {\n                if (cfa != null) {\n                    for (Node finallyNode : cfa.finallyMap.get(parent)) {\n                        cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n                    }\n                }\n                return computeFollowNode(fromNode, parent, cfa);\n            }\n    }\n            Node nextSibling = node.getNext();\n        while (nextSibling != null && nextSibling.isFunction()) {\n        nextSibling = nextSibling.getNext();\n    }\n    if (nextSibling != null) {\n        return computeFallThrough(nextSibling);\n    } else {\n                return computeFollowNode(fromNode, parent, cfa);\n    }\n}", "lc": 2.227272727272727, "pi": 1.3588516746411483, "ma": 3.8, "nbd": 2.5, "ml": 2.9166666666666665, "d": 0.986111111111111, "mi": -1.0589147286821703, "fo": 2.75, "r": -0.02631578947368421, "e": 2.6273197213049557}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-320_c06cc933", "label": 1, "code": "/**\n * Solve the linear equation A &times; X = B in least square sense.\n * <p>The m&times;n matrix A may not be square, the solution X is\n * such that ||A &times; X - B|| is minimal.</p>\n * @param b right-hand side of the equation A &times; X = B\n * @return a vector X that minimizes the two norm of A &times; X - B\n * @exception IllegalArgumentException if matrices dimensions don't match\n * @exception InvalidMatrixException if decomposed matrix is singular\n */\npublic RealVector solve(final RealVector b) throws IllegalArgumentException, InvalidMatrixException {\n    if (b.getDimension() != uT.getColumnDimension()) {\n        throw MathRuntimeException.createIllegalArgumentException(\"vector length mismatch: got {0} but expected {1}\", b.getDimension(), uT.getColumnDimension());\n    }\n    final RealVector w = uT.operate(b);\n    for (int i = 0; i < singularValues.length; ++i) {\n        final double si = singularValues[i];\n        if (si == 0) {\n            throw new SingularMatrixException();\n        }\n        w.setEntry(i, w.getEntry(i) / si);\n    }\n    return v.operate(w);\n}", "code_comment": "/**\n * Solve the linear equation A &times; X = B in least square sense.\n * <p>The m&times;n matrix A may not be square, the solution X is\n * such that ||A &times; X - B|| is minimal.</p>\n * @param b right-hand side of the equation A &times; X = B\n * @return a vector X that minimizes the two norm of A &times; X - B\n * @exception IllegalArgumentException if matrices dimensions don't match\n * @exception InvalidMatrixException if decomposed matrix is singular\n */\n", "code_no_comment": "public RealVector solve(final RealVector b) throws IllegalArgumentException, InvalidMatrixException {\n    if (b.getDimension() != uT.getColumnDimension()) {\n        throw MathRuntimeException.createIllegalArgumentException(\"vector length mismatch: got {0} but expected {1}\", b.getDimension(), uT.getColumnDimension());\n    }\n    final RealVector w = uT.operate(b);\n    for (int i = 0; i < singularValues.length; ++i) {\n        final double si = singularValues[i];\n        if (si == 0) {\n            throw new SingularMatrixException();\n        }\n        w.setEntry(i, w.getEntry(i) / si);\n    }\n    return v.operate(w);\n}", "lc": 0.0, "pi": 0.12440191387559799, "ma": 0.4, "nbd": 0.0, "ml": 0.25, "d": 0.7996031746031746, "mi": -0.08019732205778712, "fo": 0.25, "r": 0.13157894736842105, "e": 0.5339442033620903}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-1067_4786a739", "label": 3, "code": "@SuppressWarnings(\"ThrowableResultOfMethodCallIgnored\")\nprivate void formatCause(final StringBuilder sb, final ThrowableProxy cause, final List<String> ignorePackages) {\n    if (cause == null) {\n        return;\n    }\n    sb.append(\"Caused by: \").append(cause).append(EOL);\n    this.formatElements(sb, cause.commonElementCount, cause.getThrowable().getStackTrace(), cause.extendedStackTrace, ignorePackages);\n    this.formatCause(sb, cause.causeProxy, ignorePackages);\n}", "code_comment": NaN, "code_no_comment": "@SuppressWarnings(\"ThrowableResultOfMethodCallIgnored\")\nprivate void formatCause(final StringBuilder sb, final ThrowableProxy cause, final List<String> ignorePackages) {\n    if (cause == null) {\n        return;\n    }\n    sb.append(\"Caused by: \").append(cause).append(EOL);\n    this.formatElements(sb, cause.commonElementCount, cause.getThrowable().getStackTrace(), cause.extendedStackTrace, ignorePackages);\n    this.formatCause(sb, cause.causeProxy, ignorePackages);\n}", "lc": -0.22727272727272727, "pi": -0.22966507177033516, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": -0.3650793650793651, "mi": 0.21691331923890078, "fo": 0.08333333333333333, "r": -0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "Cli", "project_version": 37, "label": 1, "code": "/**\n * Tells if the token looks like a short option.\n *\n * @param token\n */\nprivate boolean isShortOption(String token) {\n    // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n    return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n// remove leading \"-\" and \"=value\"\n}", "code_comment": "/**\n * Tells if the token looks like a short option.\n *\n * @param token\n */\n", "code_no_comment": "private boolean isShortOption(String token) {\n        return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.10119047619047619, "mi": 0.8418604651162791, "fo": -0.16666666666666666, "r": 2.263157894736842, "e": -0.1183266771551898}
{"project_name": "Closure", "project_version": 112, "label": 2, "code": "/**\n * For functions with function(this: T, ...) and T as parameters, type\n * inference will set the type of this on a function literal argument to the\n * the actual type of T.\n */\nprivate boolean inferTemplatedTypesForCall(Node n, FunctionType fnType) {\n    final ImmutableList<TemplateType> keys = fnType.getTemplateTypeMap().getTemplateKeys();\n    if (keys.isEmpty()) {\n        return false;\n    }\n    // Try to infer the template types\n    Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(fnType, n);\n    // Replace all template types. If we couldn't find a replacement, we\n    // replace it with UNKNOWN.\n    TemplateTypeReplacer replacer = new TemplateTypeReplacer(registry, inferred);\n    Node callTarget = n.getFirstChild();\n    FunctionType replacementFnType = fnType.visit(replacer).toMaybeFunctionType();\n    Preconditions.checkNotNull(replacementFnType);\n    callTarget.setJSType(replacementFnType);\n    n.setJSType(replacementFnType.getReturnType());\n    return replacer.madeChanges;\n}", "code_comment": "/**\n * For functions with function(this: T, ...) and T as parameters, type\n * inference will set the type of this on a function literal argument to the\n * the actual type of T.\n */\n", "code_no_comment": "private boolean inferTemplatedTypesForCall(Node n, FunctionType fnType) {\n    final ImmutableList<TemplateType> keys = fnType.getTemplateTypeMap().getTemplateKeys();\n    if (keys.isEmpty()) {\n        return false;\n    }\n        Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(fnType, n);\n            TemplateTypeReplacer replacer = new TemplateTypeReplacer(registry, inferred);\n    Node callTarget = n.getFirstChild();\n    FunctionType replacementFnType = fnType.visit(replacer).toMaybeFunctionType();\n    Preconditions.checkNotNull(replacementFnType);\n    callTarget.setJSType(replacementFnType);\n    n.setJSType(replacementFnType.getReturnType());\n    return replacer.madeChanges;\n}", "lc": 0.0, "pi": -0.5550239234449762, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": -0.3650793650793651, "mi": -0.059901338971106395, "fo": 0.4166666666666667, "r": -0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-3474_cfb832a1", "label": 3, "code": "private void addCellsToWriter(Map<ByteBuffer, List<ColumnUpdate>> cells, BatchWriterPlusException bwpe) {\n    if (bwpe.exception != null)\n        return;\n    HashMap<Text, ColumnVisibility> vizMap = new HashMap<Text, ColumnVisibility>();\n    for (Map.Entry<ByteBuffer, List<ColumnUpdate>> entry : cells.entrySet()) {\n        Mutation m = new Mutation(ByteBufferUtil.toBytes(entry.getKey()));\n        for (ColumnUpdate update : entry.getValue()) {\n            ColumnVisibility viz = EMPTY_VIS;\n            if (update.isSetColVisibility()) {\n                Text vizText = new Text(update.getColVisibility());\n                viz = vizMap.get(vizText);\n                if (viz == null) {\n                    vizMap.put(vizText, viz = new ColumnVisibility(vizText));\n                }\n            }\n            byte[] value = new byte[0];\n            if (update.isSetValue())\n                value = update.getValue();\n            if (update.isSetTimestamp()) {\n                if (update.isSetDeleteCell()) {\n                    m.putDelete(update.getColFamily(), update.getColQualifier(), viz, update.getTimestamp());\n                } else {\n                    m.put(new Text(update.getColFamily()), new Text(update.getColQualifier()), viz, update.getTimestamp(), new Value(value));\n                }\n            } else {\n                if (update.isSetDeleteCell()) {\n                    m.putDelete(new Text(update.getColFamily()), new Text(update.getColQualifier()), viz);\n                } else {\n                    m.put(new Text(update.getColFamily()), new Text(update.getColQualifier()), viz, new Value(value));\n                }\n            }\n        }\n        try {\n            bwpe.writer.addMutation(m);\n        } catch (MutationsRejectedException mre) {\n            bwpe.exception = mre;\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "private void addCellsToWriter(Map<ByteBuffer, List<ColumnUpdate>> cells, BatchWriterPlusException bwpe) {\n    if (bwpe.exception != null)\n        return;\n    HashMap<Text, ColumnVisibility> vizMap = new HashMap<Text, ColumnVisibility>();\n    for (Map.Entry<ByteBuffer, List<ColumnUpdate>> entry : cells.entrySet()) {\n        Mutation m = new Mutation(ByteBufferUtil.toBytes(entry.getKey()));\n        for (ColumnUpdate update : entry.getValue()) {\n            ColumnVisibility viz = EMPTY_VIS;\n            if (update.isSetColVisibility()) {\n                Text vizText = new Text(update.getColVisibility());\n                viz = vizMap.get(vizText);\n                if (viz == null) {\n                    vizMap.put(vizText, viz = new ColumnVisibility(vizText));\n                }\n            }\n            byte[] value = new byte[0];\n            if (update.isSetValue())\n                value = update.getValue();\n            if (update.isSetTimestamp()) {\n                if (update.isSetDeleteCell()) {\n                    m.putDelete(update.getColFamily(), update.getColQualifier(), viz, update.getTimestamp());\n                } else {\n                    m.put(new Text(update.getColFamily()), new Text(update.getColQualifier()), viz, update.getTimestamp(), new Value(value));\n                }\n            } else {\n                if (update.isSetDeleteCell()) {\n                    m.putDelete(new Text(update.getColFamily()), new Text(update.getColQualifier()), viz);\n                } else {\n                    m.put(new Text(update.getColFamily()), new Text(update.getColQualifier()), viz, new Value(value));\n                }\n            }\n        }\n        try {\n            bwpe.writer.addMutation(m);\n        } catch (MutationsRejectedException mre) {\n            bwpe.exception = mre;\n        }\n    }\n}", "lc": 1.1363636363636365, "pi": 1.1674641148325358, "ma": 1.4, "nbd": 1.0, "ml": 0.6666666666666666, "d": 0.17063492063492064, "mi": -0.738689217758985, "fo": 1.8333333333333333, "r": -0.02631578947368421, "e": 0.7792235035125025}
{"project_name": "Closure", "project_version": 32, "label": 2, "code": "/**\n * Extracts the text found on the current line and all subsequent\n * until either an annotation, end of comment or end of file is reached.\n * Note that if this method detects an end of line as the first token, it\n * will quit immediately (indicating that there is no text where it was\n * expected).  Note that token = info.token; should be called after this\n * method is used to update the token properly in the parser.\n *\n * @param token The start token.\n * @param option How to handle whitespace.\n *\n * @return The extraction information.\n */\n@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n        line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n    do {\n        switch(token) {\n            case STAR:\n                if (ignoreStar) {\n                // Mark the position after the star as the new start of the line.\n                } else {\n                    // The star is part of the comment.\n                    if (builder.length() > 0) {\n                        builder.append(' ');\n                    }\n                    builder.append('*');\n                }\n                token = next();\n                continue;\n            case EOL:\n                if (option != WhitespaceOption.SINGLE_LINE) {\n                    builder.append(\"\\n\");\n                }\n                ignoreStar = true;\n                token = next();\n                continue;\n            default:\n                ignoreStar = false;\n                state = State.SEARCHING_ANNOTATION;\n                if (token == JsDocToken.EOC || token == JsDocToken.EOF || // in the block are ok.\n                (token == JsDocToken.ANNOTATION && option != WhitespaceOption.PRESERVE)) {\n                    String multilineText = builder.toString();\n                    if (option != WhitespaceOption.PRESERVE) {\n                        multilineText = multilineText.trim();\n                    }\n                    int endLineno = stream.getLineno();\n                    int endCharno = stream.getCharno();\n                    if (multilineText.length() > 0) {\n                        jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                    }\n                    return new ExtractionInfo(multilineText, token);\n                }\n                if (builder.length() > 0) {\n                    builder.append(' ');\n                }\n                builder.append(toString(token));\n                line = stream.getRemainingJSDocLine();\n                if (option != WhitespaceOption.PRESERVE) {\n                    line = trimEnd(line);\n                }\n                builder.append(line);\n                token = next();\n        }\n    } while (true);\n}", "code_comment": "/**\n * Extracts the text found on the current line and all subsequent\n * until either an annotation, end of comment or end of file is reached.\n * Note that if this method detects an end of line as the first token, it\n * will quit immediately (indicating that there is no text where it was\n * expected).  Note that token = info.token; should be called after this\n * method is used to update the token properly in the parser.\n *\n * @param token The start token.\n * @param option How to handle whitespace.\n *\n * @return The extraction information.\n */\n", "code_no_comment": "@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n        String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n        line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n    do {\n        switch(token) {\n            case STAR:\n                if (ignoreStar) {\n                                } else {\n                                        if (builder.length() > 0) {\n                        builder.append(' ');\n                    }\n                    builder.append('*');\n                }\n                token = next();\n                continue;\n            case EOL:\n                if (option != WhitespaceOption.SINGLE_LINE) {\n                    builder.append(\"\\n\");\n                }\n                ignoreStar = true;\n                token = next();\n                continue;\n            default:\n                ignoreStar = false;\n                state = State.SEARCHING_ANNOTATION;\n                if (token == JsDocToken.EOC || token == JsDocToken.EOF ||                 (token == JsDocToken.ANNOTATION && option != WhitespaceOption.PRESERVE)) {\n                    String multilineText = builder.toString();\n                    if (option != WhitespaceOption.PRESERVE) {\n                        multilineText = multilineText.trim();\n                    }\n                    int endLineno = stream.getLineno();\n                    int endCharno = stream.getCharno();\n                    if (multilineText.length() > 0) {\n                        jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                    }\n                    return new ExtractionInfo(multilineText, token);\n                }\n                if (builder.length() > 0) {\n                    builder.append(' ');\n                }\n                builder.append(toString(token));\n                line = stream.getRemainingJSDocLine();\n                if (option != WhitespaceOption.PRESERVE) {\n                    line = trimEnd(line);\n                }\n                builder.append(line);\n                token = next();\n        }\n    } while (true);\n}", "lc": 2.3181818181818183, "pi": 1.861244019138756, "ma": 2.6, "nbd": 1.5, "ml": 1.5, "d": 1.4087301587301586, "mi": -1.0656800563777304, "fo": 1.75, "r": -0.02631578947368421, "e": 4.380973127481659}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-3260_6968a57a", "label": 0, "code": "// --------------------------------------------------------------------------------------------\n// Internal Actions\n// --------------------------------------------------------------------------------------------\nprivate boolean processFail(Throwable t, boolean isCallback) {\n    // atomically switch to failed\n    while (true) {\n        ExecutionState current = this.state;\n        if (current == FAILED) {\n            // already failed. It is enough to remember once that we failed (its sad enough)\n            return false;\n        }\n        if (current == CANCELED) {\n            // we are already aborting or are already aborted\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(String.format(\"Ignoring transition of vertex %s to %s while being %s\", getVertexWithAttempt(), FAILED, CANCELED));\n            }\n            return false;\n        }\n        if (transitionState(current, FAILED, t)) {\n            // success (in a manner of speaking)\n            this.failureCause = t;\n            try {\n                if (assignedResource != null) {\n                    assignedResource.releaseSlot();\n                }\n                vertex.getExecutionGraph().deregisterExecution(this);\n            } finally {\n                vertex.executionFailed(t);\n            }\n            if (!isCallback && (current == RUNNING || current == DEPLOYING)) {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Sending out cancel request, to remove task execution from TaskManager.\");\n                }\n                try {\n                    if (assignedResource != null) {\n                        sendCancelRpcCall();\n                    }\n                } catch (Throwable tt) {\n                    // no reason this should ever happen, but log it to be safe\n                    LOG.error(\"Error triggering cancel call while marking task as failed.\", tt);\n                }\n            }\n            // leave the loop\n            return true;\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "private boolean processFail(Throwable t, boolean isCallback) {\n        while (true) {\n        ExecutionState current = this.state;\n        if (current == FAILED) {\n                        return false;\n        }\n        if (current == CANCELED) {\n                        if (LOG.isDebugEnabled()) {\n                LOG.debug(String.format(\"Ignoring transition of vertex %s to %s while being %s\", getVertexWithAttempt(), FAILED, CANCELED));\n            }\n            return false;\n        }\n        if (transitionState(current, FAILED, t)) {\n                        this.failureCause = t;\n            try {\n                if (assignedResource != null) {\n                    assignedResource.releaseSlot();\n                }\n                vertex.getExecutionGraph().deregisterExecution(this);\n            } finally {\n                vertex.executionFailed(t);\n            }\n            if (!isCallback && (current == RUNNING || current == DEPLOYING)) {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Sending out cancel request, to remove task execution from TaskManager.\");\n                }\n                try {\n                    if (assignedResource != null) {\n                        sendCancelRpcCall();\n                    }\n                } catch (Throwable tt) {\n                                        LOG.error(\"Error triggering cancel call while marking task as failed.\", tt);\n                }\n            }\n                        return true;\n        }\n    }\n}", "lc": 1.0909090909090908, "pi": 1.1866028708133969, "ma": 1.4, "nbd": 1.5, "ml": 1.0, "d": 0.6726190476190477, "mi": -0.627906976744186, "fo": 0.5833333333333334, "r": -0.02631578947368421, "e": 0.7670614270154388}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-704_3f645310", "label": 1, "code": "/**\n * Returns the weighted variance of the entries in the specified portion of\n * the input array, using the precomputed weighted mean value.  Returns\n * <code>Double.NaN</code> if the designated subarray is empty.\n * <p>\n * Uses the formula <pre>\n *   &Sigma;(weights[i]*(values[i] - mean)<sup>2</sup>)/(&Sigma;(weights[i]) - 1)\n * </pre></p>\n * <p>\n * The formula used assumes that the supplied mean value is the weighted arithmetic\n * mean of the sample data, not a known population parameter. This method\n * is supplied only to save computation when the mean has already been\n * computed.</p>\n * <p>\n * This formula will not return the same result as the unweighted variance when all\n * weights are equal, unless all weights are equal to 1. The formula assumes that\n * weights are to be treated as \"expansion values,\" as will be the case if for example\n * the weights represent frequency counts. To normalize weights so that the denominator\n * in the variance computation equals the length of the input vector minus one, use <pre>\n *   <code>evaluate(values, MathArrays.normalizeArray(weights, values.length), mean); </code>\n * </pre>\n * <p>\n * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n * <p>\n * Throws <code>IllegalArgumentException</code> if any of the following are true:\n * <ul><li>the values array is null</li>\n *     <li>the weights array is null</li>\n *     <li>the weights array does not have the same length as the values array</li>\n *     <li>the weights array contains one or more infinite values</li>\n *     <li>the weights array contains one or more NaN values</li>\n *     <li>the weights array contains negative values</li>\n *     <li>the start and length arguments do not determine a valid array</li>\n * </ul></p>\n * <p>\n * Does not change the internal state of the statistic.</p>\n *\n * @param values the input array\n * @param weights the weights array\n * @param mean the precomputed weighted mean value\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return the variance of the values or Double.NaN if length = 0\n * @throws IllegalArgumentException if the parameters are not valid\n * @since 2.1\n */\npublic double evaluate(final double[] values, final double[] weights, final double mean, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n        if (length == 1) {\n            var = 0.0;\n        } else if (length > 1) {\n            double accum = 0.0;\n            double dev = 0.0;\n            double accum2 = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                dev = values[i] - mean;\n                accum += weights[i] * (dev * dev);\n                accum2 += weights[i] * dev;\n            }\n            double sumWts = 0;\n            for (int i = 0; i < weights.length; i++) {\n                sumWts += weights[i];\n            }\n            if (isBiasCorrected) {\n                var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);\n            } else {\n                var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n            }\n        }\n    }\n    return var;\n}", "code_comment": "/**\n * Returns the weighted variance of the entries in the specified portion of\n * the input array, using the precomputed weighted mean value.  Returns\n * <code>Double.NaN</code> if the designated subarray is empty.\n * <p>\n * Uses the formula <pre>\n *   &Sigma;(weights[i]*(values[i] - mean)<sup>2</sup>)/(&Sigma;(weights[i]) - 1)\n * </pre></p>\n * <p>\n * The formula used assumes that the supplied mean value is the weighted arithmetic\n * mean of the sample data, not a known population parameter. This method\n * is supplied only to save computation when the mean has already been\n * computed.</p>\n * <p>\n * This formula will not return the same result as the unweighted variance when all\n * weights are equal, unless all weights are equal to 1. The formula assumes that\n * weights are to be treated as \"expansion values,\" as will be the case if for example\n * the weights represent frequency counts. To normalize weights so that the denominator\n * in the variance computation equals the length of the input vector minus one, use <pre>\n *   <code>evaluate(values, MathArrays.normalizeArray(weights, values.length), mean); </code>\n * </pre>\n * <p>\n * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n * <p>\n * Throws <code>IllegalArgumentException</code> if any of the following are true:\n * <ul><li>the values array is null</li>\n *     <li>the weights array is null</li>\n *     <li>the weights array does not have the same length as the values array</li>\n *     <li>the weights array contains one or more infinite values</li>\n *     <li>the weights array contains one or more NaN values</li>\n *     <li>the weights array contains negative values</li>\n *     <li>the start and length arguments do not determine a valid array</li>\n * </ul></p>\n * <p>\n * Does not change the internal state of the statistic.</p>\n *\n * @param values the input array\n * @param weights the weights array\n * @param mean the precomputed weighted mean value\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return the variance of the values or Double.NaN if length = 0\n * @throws IllegalArgumentException if the parameters are not valid\n * @since 2.1\n */\n", "code_no_comment": "public double evaluate(final double[] values, final double[] weights, final double mean, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n        if (length == 1) {\n            var = 0.0;\n        } else if (length > 1) {\n            double accum = 0.0;\n            double dev = 0.0;\n            double accum2 = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                dev = values[i] - mean;\n                accum += weights[i] * (dev * dev);\n                accum2 += weights[i] * dev;\n            }\n            double sumWts = 0;\n            for (int i = 0; i < weights.length; i++) {\n                sumWts += weights[i];\n            }\n            if (isBiasCorrected) {\n                var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);\n            } else {\n                var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n            }\n        }\n    }\n    return var;\n}", "lc": 0.5909090909090909, "pi": 0.8564593301435407, "ma": 0.6, "nbd": 1.0, "ml": 0.75, "d": 3.035714285714286, "mi": -0.4909090909090906, "fo": -0.4166666666666667, "r": -0.02631578947368421, "e": 3.9876558150792683}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-3757_c1b2f2f8", "label": 3, "code": "/**\n * Mock all endpoints matching the given pattern.\n *\n * @param pattern the pattern.\n * @throws Exception can be thrown if error occurred\n * @see org.apache.camel.util.EndpointHelper#matchEndpoint(String, String)\n */\npublic void mockEndpoints(String pattern) throws Exception {\n    getContext().removeEndpoints(pattern);\n    getContext().addRegisterEndpointCallback(new InterceptSendToMockEndpointStrategy(pattern));\n}", "code_comment": "/**\n * Mock all endpoints matching the given pattern.\n *\n * @param pattern the pattern.\n * @throws Exception can be thrown if error occurred\n * @see org.apache.camel.util.EndpointHelper#matchEndpoint(String, String)\n */\n", "code_no_comment": "public void mockEndpoints(String pattern) throws Exception {\n    getContext().removeEndpoints(pattern);\n    getContext().addRegisterEndpointCallback(new InterceptSendToMockEndpointStrategy(pattern));\n}", "lc": -0.45454545454545453, "pi": -0.47368421052631593, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.8046511627906971, "fo": -0.16666666666666666, "r": 2.2105263157894735, "e": -0.16279340490885932}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-2442_30761572", "label": 0, "code": "/**\n *  Recursively add all fields in this tuple type. We need this in particular to get all\n *  the types.\n *  @param startKeyId\n *  @param keyFields\n */\npublic void addAllFields(int startKeyId, List<FlatFieldDescriptor> keyFields) {\n    for (int i = 0; i < this.getArity(); i++) {\n        TypeInformation<?> type = this.types[i];\n        if (type instanceof AtomicType) {\n            keyFields.add(new FlatFieldDescriptor(startKeyId, type));\n        } else if (type instanceof TupleTypeInfoBase<?>) {\n            TupleTypeInfoBase<?> ttb = (TupleTypeInfoBase<?>) type;\n            ttb.addAllFields(startKeyId, keyFields);\n        }\n        startKeyId += type.getTotalFields();\n    }\n}", "code_comment": "/**\n *  Recursively add all fields in this tuple type. We need this in particular to get all\n *  the types.\n *  @param startKeyId\n *  @param keyFields\n */\n", "code_no_comment": "public void addAllFields(int startKeyId, List<FlatFieldDescriptor> keyFields) {\n    for (int i = 0; i < this.getArity(); i++) {\n        TypeInformation<?> type = this.types[i];\n        if (type instanceof AtomicType) {\n            keyFields.add(new FlatFieldDescriptor(startKeyId, type));\n        } else if (type instanceof TupleTypeInfoBase<?>) {\n            TupleTypeInfoBase<?> ttb = (TupleTypeInfoBase<?>) type;\n            ttb.addAllFields(startKeyId, keyFields);\n        }\n        startKeyId += type.getTotalFields();\n    }\n}", "lc": -0.09090909090909091, "pi": 0.5023923444976076, "ma": 0.0, "nbd": 0.5, "ml": 0.08333333333333333, "d": 0.45238095238095244, "mi": 0.05567300916138108, "fo": -0.16666666666666666, "r": 0.07894736842105263, "e": 0.17907712522259292}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-631_c0b49542", "label": 1, "code": "/**\n * {@inheritDoc}\n */\nprotected final double doSolve() {\n    // Get initial solution\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    // regardless of the allowed solutions.\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    // Verify bracketing of initial solution.\n    verifyBracketing(x0, x1);\n    // Get accuracies.\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    // Keep track of inverted intervals, meaning that the left bound is\n    // larger than the right bound.\n    boolean inverted = false;\n    // Keep finding better approximations.\n    while (true) {\n        // Calculate the next approximation.\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        // we can return it regardless of the allowed solutions.\n        if (fx == 0.0) {\n            return x;\n        }\n        // Update the bounds with the new approximation.\n        if (f1 * fx < 0) {\n            // The value of x1 has switched to the other bound, thus inverting\n            // the interval.\n            x0 = x1;\n            f0 = f1;\n            inverted = !inverted;\n        } else {\n            switch(method) {\n                case ILLINOIS:\n                    f0 *= 0.5;\n                    break;\n                case PEGASUS:\n                    f0 *= f1 / (f1 + fx);\n                    break;\n                case REGULA_FALSI:\n                    // Nothing.\n                    break;\n                default:\n                    // Should never happen.\n                    throw new MathInternalError();\n            }\n        }\n        // Update from [x0, x1] to [x0, x].\n        x1 = x;\n        f1 = fx;\n        // the root than we already are.\n        if (FastMath.abs(f1) <= ftol) {\n            switch(allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                case BELOW_SIDE:\n                    if (f1 <= 0) {\n                        return x1;\n                    }\n                    break;\n                case ABOVE_SIDE:\n                    if (f1 >= 0) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n        // are satisfied with the current approximation.\n        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {\n            switch(allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                case BELOW_SIDE:\n                    return (f1 <= 0) ? x1 : x0;\n                case ABOVE_SIDE:\n                    return (f1 >= 0) ? x1 : x0;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n    }\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "protected final double doSolve() {\n        double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n        if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n        verifyBracketing(x0, x1);\n        final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n            boolean inverted = false;\n        while (true) {\n                final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n                if (fx == 0.0) {\n            return x;\n        }\n                if (f1 * fx < 0) {\n                                    x0 = x1;\n            f0 = f1;\n            inverted = !inverted;\n        } else {\n            switch(method) {\n                case ILLINOIS:\n                    f0 *= 0.5;\n                    break;\n                case PEGASUS:\n                    f0 *= f1 / (f1 + fx);\n                    break;\n                case REGULA_FALSI:\n                                        break;\n                default:\n                                        throw new MathInternalError();\n            }\n        }\n                x1 = x;\n        f1 = fx;\n                if (FastMath.abs(f1) <= ftol) {\n            switch(allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                case BELOW_SIDE:\n                    if (f1 <= 0) {\n                        return x1;\n                    }\n                    break;\n                case ABOVE_SIDE:\n                    if (f1 >= 0) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n                if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {\n            switch(allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                case BELOW_SIDE:\n                    return (f1 <= 0) ? x1 : x0;\n                case ABOVE_SIDE:\n                    return (f1 >= 0) ? x1 : x0;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n    }\n}", "lc": 3.3636363636363638, "pi": 1.727272727272727, "ma": 7.6, "nbd": 1.5, "ml": 3.1666666666666665, "d": 2.8194444444444446, "mi": -1.3371388301620857, "fo": 0.5833333333333334, "r": -0.02631578947368421, "e": 6.527303008823037}
{"project_name": "Math", "project_version": 18, "label": 1, "code": "/**\n * @param x Normalized objective variables.\n * @return {@code true} if in bounds.\n */\npublic boolean isFeasible(final double[] x) {\n    if (boundaries == null) {\n        return true;\n    }\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < 0) {\n            return false;\n        }\n        if (x[i] > 1.0) {\n            return false;\n        }\n    }\n    return true;\n}", "code_comment": "/**\n * @param x Normalized objective variables.\n * @return {@code true} if in bounds.\n */\n", "code_no_comment": "public boolean isFeasible(final double[] x) {\n    if (boundaries == null) {\n        return true;\n    }\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < 0) {\n            return false;\n        }\n        if (x[i] > 1.0) {\n            return false;\n        }\n    }\n    return true;\n}", "lc": 0.0, "pi": 0.3062200956937798, "ma": 0.2, "nbd": 0.0, "ml": 0.16666666666666666, "d": 0.3928571428571428, "mi": 0.05369978858350953, "fo": -0.5, "r": 1.6842105263157894, "e": 0.027318568719996765}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3076_d3dc9a50", "label": 1, "code": "/**\n *  Checks if the url is relative or absolute\n *\n *  @param url\n *  @return <code>true</code> if url is relative, <code>false</code> otherwise\n */\npublic static boolean isRelative(String url) {\n    if ((url != null) && (url.startsWith(\"/\") == false) && (url.indexOf(\"://\") < 0) && !(url.startsWith(\"#\"))) {\n        return true;\n    } else {\n        return false;\n    }\n}", "code_comment": "/**\n *  Checks if the url is relative or absolute\n *\n *  @param url\n *  @return <code>true</code> if url is relative, <code>false</code> otherwise\n */\n", "code_no_comment": "public static boolean isRelative(String url) {\n    if ((url != null) && (url.startsWith(\"/\") == false) && (url.indexOf(\"://\") < 0) && !(url.startsWith(\"#\"))) {\n        return true;\n    } else {\n        return false;\n    }\n}", "lc": -0.3181818181818182, "pi": 0.01435406698564584, "ma": -0.4, "nbd": -0.5, "ml": 0.25, "d": 0.21428571428571425, "mi": 0.4009866102889356, "fo": -0.25, "r": 1.6052631578947367, "e": -0.02792252323899425}
{"project_name": "Closure", "project_version": 154, "label": 2, "code": "/**\n * Given a constructor type and a property name, check that the property has\n * the JSDoc annotation @override iff the property is declared on a\n * superclass. Several checks regarding inheritance correctness are also\n * performed.\n */\nprivate void checkDeclaredPropertyInheritance(NodeTraversal t, Node n, FunctionType ctorType, String propertyName, JSDocInfo info, JSType propertyType) {\n    // already.\n    if (hasUnknownOrEmptySupertype(ctorType)) {\n        return;\n    }\n    FunctionType superClass = ctorType.getSuperClassConstructor();\n    boolean superClassHasProperty = superClass != null && superClass.getPrototype().hasProperty(propertyName);\n    boolean declaredOverride = info != null && info.isOverride();\n    boolean foundInterfaceProperty = false;\n    if (ctorType.isConstructor()) {\n        for (JSType implementedInterface : ctorType.getImplementedInterfaces()) {\n            if (implementedInterface.isUnknownType() || implementedInterface.isEmptyType()) {\n                continue;\n            }\n            FunctionType interfaceType = implementedInterface.toObjectType().getConstructor();\n            Preconditions.checkNotNull(interfaceType);\n            boolean interfaceHasProperty = interfaceType.getPrototype().hasProperty(propertyName);\n            foundInterfaceProperty = foundInterfaceProperty || interfaceHasProperty;\n            if (reportMissingOverride.isOn() && !declaredOverride && interfaceHasProperty) {\n                // @override not present, but the property does override an interface\n                // property\n                compiler.report(t.makeError(n, reportMissingOverride, HIDDEN_INTERFACE_PROPERTY, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString()));\n            }\n            if (interfaceHasProperty) {\n                JSType interfacePropType = interfaceType.getPrototype().getPropertyType(propertyName);\n                if (!propertyType.canAssignTo(interfacePropType)) {\n                    compiler.report(t.makeError(n, HIDDEN_INTERFACE_PROPERTY_MISMATCH, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString(), interfacePropType.toString(), propertyType.toString()));\n                }\n            }\n        }\n    }\n    if (!declaredOverride && !superClassHasProperty) {\n        // nothing to do here, it's just a plain new property\n        return;\n    }\n    JSType topInstanceType = superClassHasProperty ? superClass.getTopMostDefiningType(propertyName) : null;\n    if (reportMissingOverride.isOn() && ctorType.isConstructor() && !declaredOverride && superClassHasProperty) {\n        // @override not present, but the property does override a superclass\n        // property\n        compiler.report(t.makeError(n, reportMissingOverride, HIDDEN_SUPERCLASS_PROPERTY, propertyName, topInstanceType.toString()));\n    }\n    if (!declaredOverride) {\n        // there's no @override to check\n        return;\n    }\n    // @override is present and we have to check that it is ok\n    if (superClassHasProperty) {\n        // there is a superclass implementation\n        JSType superClassPropType = superClass.getPrototype().getPropertyType(propertyName);\n        if (!propertyType.canAssignTo(superClassPropType)) {\n            compiler.report(t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH, propertyName, topInstanceType.toString(), superClassPropType.toString(), propertyType.toString()));\n        }\n    } else if (!foundInterfaceProperty) {\n        // there is no superclass nor interface implementation\n        compiler.report(t.makeError(n, UNKNOWN_OVERRIDE, propertyName, ctorType.getInstanceType().toString()));\n    }\n}", "code_comment": "/**\n * Given a constructor type and a property name, check that the property has\n * the JSDoc annotation @override iff the property is declared on a\n * superclass. Several checks regarding inheritance correctness are also\n * performed.\n */\n", "code_no_comment": "private void checkDeclaredPropertyInheritance(NodeTraversal t, Node n, FunctionType ctorType, String propertyName, JSDocInfo info, JSType propertyType) {\n        if (hasUnknownOrEmptySupertype(ctorType)) {\n        return;\n    }\n    FunctionType superClass = ctorType.getSuperClassConstructor();\n    boolean superClassHasProperty = superClass != null && superClass.getPrototype().hasProperty(propertyName);\n    boolean declaredOverride = info != null && info.isOverride();\n    boolean foundInterfaceProperty = false;\n    if (ctorType.isConstructor()) {\n        for (JSType implementedInterface : ctorType.getImplementedInterfaces()) {\n            if (implementedInterface.isUnknownType() || implementedInterface.isEmptyType()) {\n                continue;\n            }\n            FunctionType interfaceType = implementedInterface.toObjectType().getConstructor();\n            Preconditions.checkNotNull(interfaceType);\n            boolean interfaceHasProperty = interfaceType.getPrototype().hasProperty(propertyName);\n            foundInterfaceProperty = foundInterfaceProperty || interfaceHasProperty;\n            if (reportMissingOverride.isOn() && !declaredOverride && interfaceHasProperty) {\n                                                compiler.report(t.makeError(n, reportMissingOverride, HIDDEN_INTERFACE_PROPERTY, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString()));\n            }\n            if (interfaceHasProperty) {\n                JSType interfacePropType = interfaceType.getPrototype().getPropertyType(propertyName);\n                if (!propertyType.canAssignTo(interfacePropType)) {\n                    compiler.report(t.makeError(n, HIDDEN_INTERFACE_PROPERTY_MISMATCH, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString(), interfacePropType.toString(), propertyType.toString()));\n                }\n            }\n        }\n    }\n    if (!declaredOverride && !superClassHasProperty) {\n                return;\n    }\n    JSType topInstanceType = superClassHasProperty ? superClass.getTopMostDefiningType(propertyName) : null;\n    if (reportMissingOverride.isOn() && ctorType.isConstructor() && !declaredOverride && superClassHasProperty) {\n                        compiler.report(t.makeError(n, reportMissingOverride, HIDDEN_SUPERCLASS_PROPERTY, propertyName, topInstanceType.toString()));\n    }\n    if (!declaredOverride) {\n                return;\n    }\n        if (superClassHasProperty) {\n                JSType superClassPropType = superClass.getPrototype().getPropertyType(propertyName);\n        if (!propertyType.canAssignTo(superClassPropType)) {\n            compiler.report(t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH, propertyName, topInstanceType.toString(), superClassPropType.toString(), propertyType.toString()));\n        }\n    } else if (!foundInterfaceProperty) {\n                compiler.report(t.makeError(n, UNKNOWN_OVERRIDE, propertyName, ctorType.getInstanceType().toString()));\n    }\n}", "lc": 1.5, "pi": 0.8373205741626795, "ma": 2.4, "nbd": 1.0, "ml": 2.4166666666666665, "d": 0.8174603174603174, "mi": -0.9117688513037348, "fo": 3.3333333333333335, "r": -0.02631578947368421, "e": 2.8775689678025387}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4138_7c89598a", "label": 1, "code": "/**\n *  Returns base url without context or filter mapping.\n *  <p>\n *  Example: if current url is\n *\n *  <pre>\n *  http://localhost:8080/context/filter/mapping/wicket/bookmarkable/com.foo.Page?1&id=2\n *  </pre>\n *\n *  the base url is <em>wicket/bookmarkable/com.foo.Page</em>\n *  </p>\n *\n *  @see org.apache.wicket.request.Request#getClientUrl()\n */\n@Override\npublic Url getClientUrl() {\n    if (errorAttributes != null && !Strings.isEmpty(errorAttributes.getRequestUri())) {\n        String problematicURI = Url.parse(errorAttributes.getRequestUri(), getCharset()).toString();\n        return getContextRelativeUrl(problematicURI, filterPrefix);\n    } else if (!isAjax()) {\n        return getContextRelativeUrl(httpServletRequest.getRequestURI(), filterPrefix);\n    } else {\n        String base = null;\n        base = getHeader(HEADER_AJAX_BASE_URL);\n        if (base == null) {\n            base = getRequestParameters().getParameterValue(PARAM_AJAX_BASE_URL).toString(null);\n        }\n        Checks.notNull(base, \"Current ajax request is missing the base url header or parameter\");\n        return setParameters(Url.parse(base, getCharset()));\n    }\n}", "code_comment": "/**\n *  Returns base url without context or filter mapping.\n *  <p>\n *  Example: if current url is\n *\n *  <pre>\n *  http://localhost:8080/context/filter/mapping/wicket/bookmarkable/com.foo.Page?1&id=2\n *  </pre>\n *\n *  the base url is <em>wicket/bookmarkable/com.foo.Page</em>\n *  </p>\n *\n *  @see org.apache.wicket.request.Request#getClientUrl()\n */\n", "code_no_comment": "@Override\npublic Url getClientUrl() {\n    if (errorAttributes != null && !Strings.isEmpty(errorAttributes.getRequestUri())) {\n        String problematicURI = Url.parse(errorAttributes.getRequestUri(), getCharset()).toString();\n        return getContextRelativeUrl(problematicURI, filterPrefix);\n    } else if (!isAjax()) {\n        return getContextRelativeUrl(httpServletRequest.getRequestURI(), filterPrefix);\n    } else {\n        String base = null;\n        base = getHeader(HEADER_AJAX_BASE_URL);\n        if (base == null) {\n            base = getRequestParameters().getParameterValue(PARAM_AJAX_BASE_URL).toString(null);\n        }\n        Checks.notNull(base, \"Current ajax request is missing the base url header or parameter\");\n        return setParameters(Url.parse(base, getCharset()));\n    }\n}", "lc": 0.13636363636363635, "pi": 0.1913875598086124, "ma": 0.0, "nbd": 0.5, "ml": 0.3333333333333333, "d": 0.3055555555555555, "mi": -0.1757575757575757, "fo": 1.0, "r": -0.02631578947368421, "e": 0.29692202186453664}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-172_99e22ce4", "label": 1, "code": "/**\n *  @see wicket.Component#renderHead(wicket.markup.html.IHeaderResponse)\n */\n@Override\npublic void renderHead(final IHeaderResponse response) {\n    if (isVisible()) {\n        super.renderHead(response);\n        for (Component child : this) {\n            child.renderHead(response);\n        }\n    }\n}", "code_comment": "/**\n *  @see wicket.Component#renderHead(wicket.markup.html.IHeaderResponse)\n */\n", "code_no_comment": "@Override\npublic void renderHead(final IHeaderResponse response) {\n    if (isVisible()) {\n        super.renderHead(response);\n        for (Component child : this) {\n            child.renderHead(response);\n        }\n    }\n}", "lc": -0.22727272727272727, "pi": 0.5406698564593301, "ma": -0.2, "nbd": 0.0, "ml": -0.25, "d": -0.3650793650793651, "mi": 0.4176180408738547, "fo": -0.25, "r": 0.7894736842105263, "e": -0.16279340490885932}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-4432_c9765c21", "label": 3, "code": "@Override\npublic Iterator<DataIdentifier> getAllIdentifiers() {\n    final String path = FilenameUtils.normalizeNoEndSeparator(getPath());\n    return Files.fileTreeTraverser().postOrderTraversal(new File(getPath())).filter(new Predicate<File>() {\n\n        @Override\n        public boolean apply(File input) {\n            return input.isFile() && !input.getParent().equals(path);\n        }\n    }).transform(new Function<File, DataIdentifier>() {\n\n        @Override\n        public DataIdentifier apply(File input) {\n            return new DataIdentifier(input.getName());\n        }\n    }).iterator();\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic Iterator<DataIdentifier> getAllIdentifiers() {\n    final String path = FilenameUtils.normalizeNoEndSeparator(getPath());\n    return Files.fileTreeTraverser().postOrderTraversal(new File(getPath())).filter(new Predicate<File>() {\n\n        @Override\n        public boolean apply(File input) {\n            return input.isFile() && !input.getParent().equals(path);\n        }\n    }).transform(new Function<File, DataIdentifier>() {\n\n        @Override\n        public DataIdentifier apply(File input) {\n            return new DataIdentifier(input.getName());\n        }\n    }).iterator();\n}", "lc": 0.045454545454545456, "pi": 0.40191387559808606, "ma": -0.6, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.039682539682539715, "mi": -0.05031712473572928, "fo": 0.5, "r": 0.02631578947368421, "e": -0.002860715870518624}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1874_3ae276c1", "label": 1, "code": "private void collectIndexEditors(NodeBuilder definitions) throws CommitFailedException {\n    for (String name : definitions.getChildNodeNames()) {\n        NodeBuilder definition = definitions.getChildNode(name);\n        if (Objects.equal(async, definition.getString(ASYNC_PROPERTY_NAME))) {\n            String type = definition.getString(TYPE_PROPERTY_NAME);\n            Editor editor = provider.getIndexEditor(type, definition, root, updateCallback);\n            if (editor == null) {\n                // trigger reindexing when an indexer becomes available\n                definition.setProperty(REINDEX_PROPERTY_NAME, true);\n            } else if (definition.getBoolean(REINDEX_PROPERTY_NAME)) {\n                if (definition.getBoolean(REINDEX_ASYNC_PROPERTY_NAME) && definition.getString(ASYNC_PROPERTY_NAME) == null) {\n                    // switch index to an async update mode\n                    definition.setProperty(ASYNC_PROPERTY_NAME, ASYNC_REINDEX_VALUE);\n                } else {\n                    definition.setProperty(REINDEX_PROPERTY_NAME, false);\n                    // beforehand, we'll remove all child nodes\n                    for (String rm : definition.getChildNodeNames()) {\n                        definition.getChildNode(rm).remove();\n                    }\n                    reindex.put(concat(getPath(), INDEX_DEFINITIONS_NAME, name), wrap(editor));\n                }\n            } else {\n                editors.add(wrap(editor));\n            }\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "private void collectIndexEditors(NodeBuilder definitions) throws CommitFailedException {\n    for (String name : definitions.getChildNodeNames()) {\n        NodeBuilder definition = definitions.getChildNode(name);\n        if (Objects.equal(async, definition.getString(ASYNC_PROPERTY_NAME))) {\n            String type = definition.getString(TYPE_PROPERTY_NAME);\n            Editor editor = provider.getIndexEditor(type, definition, root, updateCallback);\n            if (editor == null) {\n                                definition.setProperty(REINDEX_PROPERTY_NAME, true);\n            } else if (definition.getBoolean(REINDEX_PROPERTY_NAME)) {\n                if (definition.getBoolean(REINDEX_ASYNC_PROPERTY_NAME) && definition.getString(ASYNC_PROPERTY_NAME) == null) {\n                                        definition.setProperty(ASYNC_PROPERTY_NAME, ASYNC_REINDEX_VALUE);\n                } else {\n                    definition.setProperty(REINDEX_PROPERTY_NAME, false);\n                                        for (String rm : definition.getChildNodeNames()) {\n                        definition.getChildNode(rm).remove();\n                    }\n                    reindex.put(concat(getPath(), INDEX_DEFINITIONS_NAME, name), wrap(editor));\n                }\n            } else {\n                editors.add(wrap(editor));\n            }\n        }\n    }\n}", "lc": 0.45454545454545453, "pi": 1.645933014354067, "ma": 0.6, "nbd": 2.0, "ml": 0.5, "d": 0.0079365079365079, "mi": -0.4156448202959831, "fo": 1.25, "r": -0.02631578947368421, "e": 0.22955112578735956}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-1127_ba62c59d", "label": 1, "code": "/**\n * Returns true if both arguments are equal or within the range of allowed\n * error (inclusive).\n * Two float numbers are considered equal if there are {@code (maxUlps - 1)}\n * (or fewer) floating point numbers between them, i.e. two adjacent floating\n * point numbers are considered equal.\n * Adapted from <a\n * href=\"http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm\">\n * Bruce Dawson</a>\n *\n * @param x first value\n * @param y second value\n * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n * values between {@code x} and {@code y}.\n * @return {@code true} if there are fewer than {@code maxUlps} floating\n * point values between {@code x} and {@code y}.\n */\npublic static boolean equals(double x, double y, int maxUlps) {\n    long xInt = Double.doubleToLongBits(x);\n    long yInt = Double.doubleToLongBits(y);\n    // Make lexicographically ordered as a two's-complement integer.\n    if (xInt < 0) {\n        xInt = SGN_MASK - xInt;\n    }\n    if (yInt < 0) {\n        yInt = SGN_MASK - yInt;\n    }\n    final boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\n    return isEqual && !Double.isNaN(x) && !Double.isNaN(y);\n}", "code_comment": "/**\n * Returns true if both arguments are equal or within the range of allowed\n * error (inclusive).\n * Two float numbers are considered equal if there are {@code (maxUlps - 1)}\n * (or fewer) floating point numbers between them, i.e. two adjacent floating\n * point numbers are considered equal.\n * Adapted from <a\n * href=\"http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm\">\n * Bruce Dawson</a>\n *\n * @param x first value\n * @param y second value\n * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n * values between {@code x} and {@code y}.\n * @return {@code true} if there are fewer than {@code maxUlps} floating\n * point values between {@code x} and {@code y}.\n */\n", "code_no_comment": "public static boolean equals(double x, double y, int maxUlps) {\n    long xInt = Double.doubleToLongBits(x);\n    long yInt = Double.doubleToLongBits(y);\n        if (xInt < 0) {\n        xInt = SGN_MASK - xInt;\n    }\n    if (yInt < 0) {\n        yInt = SGN_MASK - yInt;\n    }\n    final boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\n    return isEqual && !Double.isNaN(x) && !Double.isNaN(y);\n}", "lc": -0.09090909090909091, "pi": -0.32535885167464124, "ma": -0.2, "nbd": -0.5, "ml": -0.08333333333333333, "d": 1.0634920634920635, "mi": 0.03312191684284699, "fo": -0.08333333333333333, "r": 0.2368421052631579, "e": 0.566207361560139}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-7586_1f92fa42", "label": 3, "code": "@ManagedAttribute(description = \"Message History\")\nBoolean getMessageHistory();", "code_comment": NaN, "code_no_comment": "@ManagedAttribute(description = \"Message History\")\nBoolean getMessageHistory();", "lc": -0.5454545454545454, "pi": -1.4306220095693782, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.252854122621564, "fo": -0.5, "r": 2.5789473684210527, "e": -0.16279340490885932}
{"project_name": "JxPath", "project_version": 4, "label": 1, "code": "protected String getLanguage() {\n    Object n = node;\n    while (n != null) {\n        if (n instanceof Element) {\n            Element e = (Element) n;\n            String attr = e.getAttributeValue(\"lang\", Namespace.XML_NAMESPACE);\n            if (attr != null && !attr.equals(\"\")) {\n                return attr;\n            }\n        }\n        n = nodeParent(n);\n    }\n    return null;\n}", "code_comment": NaN, "code_no_comment": "protected String getLanguage() {\n    Object n = node;\n    while (n != null) {\n        if (n instanceof Element) {\n            Element e = (Element) n;\n            String attr = e.getAttributeValue(\"lang\", Namespace.XML_NAMESPACE);\n            if (attr != null && !attr.equals(\"\")) {\n                return attr;\n            }\n        }\n        n = nodeParent(n);\n    }\n    return null;\n}", "lc": 0.0, "pi": 0.8421052631578947, "ma": 0.0, "nbd": 0.5, "ml": 0.16666666666666666, "d": 0.3591269841269841, "mi": -0.007470049330514461, "fo": -0.25, "r": 1.0263157894736843, "e": 0.12523296623502359}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-1226_c44bfe00", "label": 3, "code": "/**\n * Evaluate the impact of the proposed step on the event handler.\n * @param interpolator step interpolator for the proposed step\n * @return true if the event handler triggers an event before\n * the end of the proposed step\n * @exception MaxCountExceededException if the interpolator throws one because\n * the number of functions evaluations is exceeded\n * @exception NoBracketingException if the event cannot be bracketed\n */\npublic boolean evaluateStep(final StepInterpolator interpolator) throws MaxCountExceededException, NoBracketingException {\n    try {\n        forward = interpolator.isForward();\n        final double t1 = interpolator.getCurrentTime();\n        final double dt = t1 - t0;\n        if (FastMath.abs(dt) < convergence) {\n            // we cannot do anything on such a small step, don't trigger any events\n            return false;\n        }\n        final int n = FastMath.max(1, (int) FastMath.ceil(FastMath.abs(dt) / maxCheckInterval));\n        final double h = dt / n;\n        final UnivariateFunction f = new UnivariateFunction() {\n\n            public double value(final double t) throws LocalMaxCountExceededException {\n                try {\n                    interpolator.setInterpolatedTime(t);\n                    return handler.g(t, getCompleteState(interpolator));\n                } catch (MaxCountExceededException mcee) {\n                    throw new LocalMaxCountExceededException(mcee);\n                }\n            }\n        };\n        double ta = t0;\n        double ga = g0;\n        for (int i = 0; i < n; ++i) {\n            // evaluate handler value at the end of the substep\n            final double tb = t0 + (i + 1) * h;\n            interpolator.setInterpolatedTime(tb);\n            final double gb = handler.g(tb, getCompleteState(interpolator));\n            // check events occurrence\n            if (g0Positive ^ (gb >= 0)) {\n                // there is a sign change: an event is expected during this step\n                // variation direction, with respect to the integration direction\n                increasing = gb >= ga;\n                // find the event time making sure we select a solution just at or past the exact root\n                final double root;\n                if (solver instanceof BracketedUnivariateSolver<?>) {\n                    @SuppressWarnings(\"unchecked\")\n                    BracketedUnivariateSolver<UnivariateFunction> bracketing = (BracketedUnivariateSolver<UnivariateFunction>) solver;\n                    root = forward ? bracketing.solve(maxIterationCount, f, ta, tb, AllowedSolution.RIGHT_SIDE) : bracketing.solve(maxIterationCount, f, tb, ta, AllowedSolution.LEFT_SIDE);\n                } else {\n                    final double baseRoot = forward ? solver.solve(maxIterationCount, f, ta, tb) : solver.solve(maxIterationCount, f, tb, ta);\n                    final int remainingEval = maxIterationCount - solver.getEvaluations();\n                    BracketedUnivariateSolver<UnivariateFunction> bracketing = new PegasusSolver(solver.getRelativeAccuracy(), solver.getAbsoluteAccuracy());\n                    root = forward ? UnivariateSolverUtils.forceSide(remainingEval, f, bracketing, baseRoot, ta, tb, AllowedSolution.RIGHT_SIDE) : UnivariateSolverUtils.forceSide(remainingEval, f, bracketing, baseRoot, tb, ta, AllowedSolution.LEFT_SIDE);\n                }\n                if ((!Double.isNaN(previousEventTime)) && (FastMath.abs(root - ta) <= convergence) && (FastMath.abs(root - previousEventTime) <= convergence)) {\n                    // crosses the axis several times\n                    do {\n                        ta = forward ? ta + convergence : ta - convergence;\n                        ga = f.value(ta);\n                    } while ((g0Positive ^ (ga >= 0)) && (forward ^ (ta >= tb)));\n                    --i;\n                } else if (Double.isNaN(previousEventTime) || (FastMath.abs(previousEventTime - root) > convergence)) {\n                    pendingEventTime = root;\n                    pendingEvent = true;\n                    return true;\n                } else {\n                    // no sign change: there is no event for now\n                    ta = tb;\n                    ga = gb;\n                }\n            } else {\n                // no sign change: there is no event for now\n                ta = tb;\n                ga = gb;\n            }\n        }\n        // no event during the whole step\n        pendingEvent = false;\n        pendingEventTime = Double.NaN;\n        return false;\n    } catch (LocalMaxCountExceededException lmcee) {\n        throw lmcee.getException();\n    }\n}", "code_comment": "/**\n * Evaluate the impact of the proposed step on the event handler.\n * @param interpolator step interpolator for the proposed step\n * @return true if the event handler triggers an event before\n * the end of the proposed step\n * @exception MaxCountExceededException if the interpolator throws one because\n * the number of functions evaluations is exceeded\n * @exception NoBracketingException if the event cannot be bracketed\n */\n", "code_no_comment": "public boolean evaluateStep(final StepInterpolator interpolator) throws MaxCountExceededException, NoBracketingException {\n    try {\n        forward = interpolator.isForward();\n        final double t1 = interpolator.getCurrentTime();\n        final double dt = t1 - t0;\n        if (FastMath.abs(dt) < convergence) {\n                        return false;\n        }\n        final int n = FastMath.max(1, (int) FastMath.ceil(FastMath.abs(dt) / maxCheckInterval));\n        final double h = dt / n;\n        final UnivariateFunction f = new UnivariateFunction() {\n\n            public double value(final double t) throws LocalMaxCountExceededException {\n                try {\n                    interpolator.setInterpolatedTime(t);\n                    return handler.g(t, getCompleteState(interpolator));\n                } catch (MaxCountExceededException mcee) {\n                    throw new LocalMaxCountExceededException(mcee);\n                }\n            }\n        };\n        double ta = t0;\n        double ga = g0;\n        for (int i = 0; i < n; ++i) {\n                        final double tb = t0 + (i + 1) * h;\n            interpolator.setInterpolatedTime(tb);\n            final double gb = handler.g(tb, getCompleteState(interpolator));\n                        if (g0Positive ^ (gb >= 0)) {\n                                                increasing = gb >= ga;\n                                final double root;\n                if (solver instanceof BracketedUnivariateSolver<?>) {\n                    @SuppressWarnings(\"unchecked\")\n                    BracketedUnivariateSolver<UnivariateFunction> bracketing = (BracketedUnivariateSolver<UnivariateFunction>) solver;\n                    root = forward ? bracketing.solve(maxIterationCount, f, ta, tb, AllowedSolution.RIGHT_SIDE) : bracketing.solve(maxIterationCount, f, tb, ta, AllowedSolution.LEFT_SIDE);\n                } else {\n                    final double baseRoot = forward ? solver.solve(maxIterationCount, f, ta, tb) : solver.solve(maxIterationCount, f, tb, ta);\n                    final int remainingEval = maxIterationCount - solver.getEvaluations();\n                    BracketedUnivariateSolver<UnivariateFunction> bracketing = new PegasusSolver(solver.getRelativeAccuracy(), solver.getAbsoluteAccuracy());\n                    root = forward ? UnivariateSolverUtils.forceSide(remainingEval, f, bracketing, baseRoot, ta, tb, AllowedSolution.RIGHT_SIDE) : UnivariateSolverUtils.forceSide(remainingEval, f, bracketing, baseRoot, tb, ta, AllowedSolution.LEFT_SIDE);\n                }\n                if ((!Double.isNaN(previousEventTime)) && (FastMath.abs(root - ta) <= convergence) && (FastMath.abs(root - previousEventTime) <= convergence)) {\n                                        do {\n                        ta = forward ? ta + convergence : ta - convergence;\n                        ga = f.value(ta);\n                    } while ((g0Positive ^ (ga >= 0)) && (forward ^ (ta >= tb)));\n                    --i;\n                } else if (Double.isNaN(previousEventTime) || (FastMath.abs(previousEventTime - root) > convergence)) {\n                    pendingEventTime = root;\n                    pendingEvent = true;\n                    return true;\n                } else {\n                                        ta = tb;\n                    ga = gb;\n                }\n            } else {\n                                ta = tb;\n                ga = gb;\n            }\n        }\n                pendingEvent = false;\n        pendingEventTime = Double.NaN;\n        return false;\n    } catch (LocalMaxCountExceededException lmcee) {\n        throw lmcee.getException();\n    }\n}", "lc": 2.3181818181818183, "pi": 1.3779904306220097, "ma": 2.4, "nbd": 1.5, "ml": 2.3333333333333335, "d": 4.023809523809524, "mi": -1.1282593375616627, "fo": 1.8333333333333333, "r": -0.02631578947368421, "e": 17.826157915665355}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2260_0ac7ff20", "label": 1, "code": "// implementation of RemoteSegmentLoader\npublic Segment getSegment() {\n    boolean interrupted = false;\n    try {\n        for (; ; ) {\n            try {\n                // log.debug(\"polling segment\");\n                Segment s = segment.poll(timeoutMs, TimeUnit.MILLISECONDS);\n                // log.debug(\"returning segment \" + s.getSegmentId());\n                return s;\n            } catch (InterruptedException ignore) {\n                interrupted = true;\n            }\n        }\n    } finally {\n        if (interrupted) {\n            Thread.currentThread().interrupt();\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "public Segment getSegment() {\n    boolean interrupted = false;\n    try {\n        for (; ; ) {\n            try {\n                                Segment s = segment.poll(timeoutMs, TimeUnit.MILLISECONDS);\n                                return s;\n            } catch (InterruptedException ignore) {\n                interrupted = true;\n            }\n        }\n    } finally {\n        if (interrupted) {\n            Thread.currentThread().interrupt();\n        }\n    }\n}", "lc": 0.13636363636363635, "pi": 1.0143540669856461, "ma": 0.0, "nbd": 0.5, "ml": -0.25, "d": -0.3650793650793651, "mi": -0.017336152219873002, "fo": -0.25, "r": 0.8421052631578947, "e": -0.16279340490885932}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-4354_96e40c3c", "label": 1, "code": "/**\n * Sends an exchange to an endpoint using a supplied callback supporting the asynchronous routing engine.\n * <p/>\n * If an exception was thrown during processing, it would be set on the given Exchange\n *\n * @param endpoint         the endpoint to send the exchange to\n * @param exchange         the exchange, can be <tt>null</tt> if so then create a new exchange from the producer\n * @param pattern          the exchange pattern, can be <tt>null</tt>\n * @param callback         the asynchronous callback\n * @param producerCallback the producer template callback to be executed\n * @return (doneSync) <tt>true</tt> to continue execute synchronously, <tt>false</tt> to continue being executed asynchronously\n */\npublic boolean doInAsyncProducer(Endpoint endpoint, Exchange exchange, ExchangePattern pattern, AsyncCallback callback, AsyncProducerCallback producerCallback) {\n    boolean sync = true;\n    // get the producer and we do not mind if its pooled as we can handle returning it back to the pool\n    Producer producer = doGetProducer(endpoint, true);\n    if (producer == null) {\n        if (isStopped()) {\n            LOG.warn(\"Ignoring exchange sent after processor is stopped: \" + exchange);\n            return false;\n        } else {\n            throw new IllegalStateException(\"No producer, this processor has not been started: \" + this);\n        }\n    }\n    StopWatch watch = null;\n    if (exchange != null) {\n        // record timing for sending the exchange using the producer\n        watch = new StopWatch();\n    }\n    try {\n        // invoke the callback\n        AsyncProcessor asyncProcessor = AsyncProcessorTypeConverter.convert(producer);\n        sync = producerCallback.doInAsyncProducer(producer, asyncProcessor, exchange, pattern, callback);\n    } catch (Throwable e) {\n        // ensure exceptions is caught and set on the exchange\n        if (exchange != null) {\n            exchange.setException(e);\n        }\n    } finally {\n        if (exchange != null && exchange.getException() == null) {\n            long timeTaken = watch.stop();\n            // emit event that the exchange was sent to the endpoint\n            EventHelper.notifyExchangeSent(exchange.getContext(), exchange, endpoint, timeTaken);\n        }\n        if (producer instanceof ServicePoolAware) {\n            // release back to the pool\n            pool.release(endpoint, producer);\n        } else if (!producer.isSingleton()) {\n            // stop non singleton producers as we should not leak resources\n            try {\n                ServiceHelper.stopService(producer);\n            } catch (Exception e) {\n                // ignore and continue\n                LOG.warn(\"Error stopping producer: \" + producer, e);\n            }\n        }\n    }\n    return sync;\n}", "code_comment": "/**\n * Sends an exchange to an endpoint using a supplied callback supporting the asynchronous routing engine.\n * <p/>\n * If an exception was thrown during processing, it would be set on the given Exchange\n *\n * @param endpoint         the endpoint to send the exchange to\n * @param exchange         the exchange, can be <tt>null</tt> if so then create a new exchange from the producer\n * @param pattern          the exchange pattern, can be <tt>null</tt>\n * @param callback         the asynchronous callback\n * @param producerCallback the producer template callback to be executed\n * @return (doneSync) <tt>true</tt> to continue execute synchronously, <tt>false</tt> to continue being executed asynchronously\n */\n", "code_no_comment": "public boolean doInAsyncProducer(Endpoint endpoint, Exchange exchange, ExchangePattern pattern, AsyncCallback callback, AsyncProducerCallback producerCallback) {\n    boolean sync = true;\n        Producer producer = doGetProducer(endpoint, true);\n    if (producer == null) {\n        if (isStopped()) {\n            LOG.warn(\"Ignoring exchange sent after processor is stopped: \" + exchange);\n            return false;\n        } else {\n            throw new IllegalStateException(\"No producer, this processor has not been started: \" + this);\n        }\n    }\n    StopWatch watch = null;\n    if (exchange != null) {\n                watch = new StopWatch();\n    }\n    try {\n                AsyncProcessor asyncProcessor = AsyncProcessorTypeConverter.convert(producer);\n        sync = producerCallback.doInAsyncProducer(producer, asyncProcessor, exchange, pattern, callback);\n    } catch (Throwable e) {\n                if (exchange != null) {\n            exchange.setException(e);\n        }\n    } finally {\n        if (exchange != null && exchange.getException() == null) {\n            long timeTaken = watch.stop();\n                        EventHelper.notifyExchangeSent(exchange.getContext(), exchange, endpoint, timeTaken);\n        }\n        if (producer instanceof ServicePoolAware) {\n                        pool.release(endpoint, producer);\n        } else if (!producer.isSingleton()) {\n                        try {\n                ServiceHelper.stopService(producer);\n            } catch (Exception e) {\n                                LOG.warn(\"Error stopping producer: \" + producer, e);\n            }\n        }\n    }\n    return sync;\n}", "lc": 1.1363636363636365, "pi": 0.4545454545454545, "ma": 1.4, "nbd": 1.0, "ml": 0.6666666666666666, "d": 0.75, "mi": -0.7082452431289639, "fo": 0.6666666666666666, "r": -0.02631578947368421, "e": 1.4340992260391991}
{"project_name": "Csv", "project_version": 3, "label": 1, "code": "// TODO escape handling needs more work\n/**\n * Handle an escape sequence.\n * The current character must be the escape character.\n * On return, the next character is available by calling {@link ExtendedBufferedReader#getLastChar()}\n * on the input stream.\n *\n * @return the unescaped character (as an int) or {@link END_OF_STREAM} if char following the escape is invalid.\n * @throws IOException if there is a problem reading the stream or the end of stream is detected:\n * the escape character is not allowed at end of strem\n */\nint readEscape() throws IOException {\n    // the escape char has just been read (normally a backslash)\n    final int c = in.read();\n    switch(c) {\n        case 'r':\n            return CR;\n        case 'n':\n            return LF;\n        case 't':\n            return TAB;\n        case 'b':\n            return BACKSPACE;\n        case 'f':\n            return FF;\n        case CR:\n        case LF:\n        // TODO is this correct?\n        case FF:\n        // TODO is this correct? Do tabs need to be escaped?\n        case TAB:\n        case // TODO is this correct?\n        BACKSPACE:\n            return c;\n        case END_OF_STREAM:\n            throw new IOException(\"EOF whilst processing escape sequence\");\n        default:\n            // Now check for meta-characters\n            return c;\n    }\n}", "code_comment": "/**\n * Handle an escape sequence.\n * The current character must be the escape character.\n * On return, the next character is available by calling {@link ExtendedBufferedReader#getLastChar()}\n * on the input stream.\n *\n * @return the unescaped character (as an int) or {@link END_OF_STREAM} if char following the escape is invalid.\n * @throws IOException if there is a problem reading the stream or the end of stream is detected:\n * the escape character is not allowed at end of strem\n */\n", "code_no_comment": "int readEscape() throws IOException {\n        final int c = in.read();\n    switch(c) {\n        case 'r':\n            return CR;\n        case 'n':\n            return LF;\n        case 't':\n            return TAB;\n        case 'b':\n            return BACKSPACE;\n        case 'f':\n            return FF;\n        case CR:\n        case LF:\n                case FF:\n                case TAB:\n        case         BACKSPACE:\n            return c;\n        case END_OF_STREAM:\n            throw new IOException(\"EOF whilst processing escape sequence\");\n        default:\n                        return c;\n    }\n}", "lc": 0.5454545454545454, "pi": 0.20574162679425825, "ma": 2.0, "nbd": 0.0, "ml": 0.5833333333333334, "d": -0.3650793650793651, "mi": -0.3014799154334035, "fo": -0.4166666666666667, "r": -0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-5704_708e756d", "label": 1, "code": "/**\n * Sets the given {@link org.apache.camel.processor.aggregate.AggregationStrategy} on the {@link Exchange}.\n *\n * @param exchange            the exchange\n * @param aggregationStrategy the strategy\n */\nprotected void setAggregationStrategyOnExchange(Exchange exchange, AggregationStrategy aggregationStrategy) {\n    Map<?, ?> property = exchange.getProperty(Exchange.AGGREGATION_STRATEGY, Map.class);\n    Map<Object, AggregationStrategy> map = CastUtils.cast(property);\n    if (map == null) {\n        map = new HashMap<Object, AggregationStrategy>();\n    }\n    // store the strategy using this processor as the key\n    // (so we can store multiple strategies on the same exchange)\n    map.put(this, aggregationStrategy);\n    exchange.setProperty(Exchange.AGGREGATION_STRATEGY, map);\n}", "code_comment": "/**\n * Sets the given {@link org.apache.camel.processor.aggregate.AggregationStrategy} on the {@link Exchange}.\n *\n * @param exchange            the exchange\n * @param aggregationStrategy the strategy\n */\n", "code_no_comment": "protected void setAggregationStrategyOnExchange(Exchange exchange, AggregationStrategy aggregationStrategy) {\n    Map<?, ?> property = exchange.getProperty(Exchange.AGGREGATION_STRATEGY, Map.class);\n    Map<Object, AggregationStrategy> map = CastUtils.cast(property);\n    if (map == null) {\n        map = new HashMap<Object, AggregationStrategy>();\n    }\n            map.put(this, aggregationStrategy);\n    exchange.setProperty(Exchange.AGGREGATION_STRATEGY, map);\n}", "lc": -0.22727272727272727, "pi": -0.3444976076555025, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": 0.009920634920634885, "mi": 0.21353065539112054, "fo": -0.16666666666666666, "r": 0.05263157894736841, "e": -0.019771442402448082}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-705_645d642b", "label": 1, "code": "/**\n * Reinitialize the instance\n * <p>Some Runge-Kutta integrators need fewer functions evaluations\n * than their counterpart step interpolators. So the interpolator\n * should perform the last evaluations they need by themselves. The\n * {@link RungeKuttaIntegrator RungeKuttaIntegrator} and {@link\n * EmbeddedRungeKuttaIntegrator EmbeddedRungeKuttaIntegrator}\n * abstract classes call this method in order to let the step\n * interpolator perform the evaluations it needs. These evaluations\n * will be performed during the call to <code>doFinalize</code> if\n * any, i.e. only if the step handler either calls the {@link\n * AbstractStepInterpolator#finalizeStep finalizeStep} method or the\n * {@link AbstractStepInterpolator#getInterpolatedState\n * getInterpolatedState} method (for an interpolator which needs a\n * finalization) or if it clones the step interpolator.</p>\n * @param rkIntegrator integrator being used\n * @param y reference to the integrator array holding the state at\n * the end of the step\n * @param yDotArray reference to the integrator array holding all the\n * intermediate slopes\n * @param forward integration direction indicator\n * @param primaryMapper equations mapper for the primary equations set\n * @param secondaryMappers equations mappers for the secondary equations sets\n */\npublic void reinitialize(final AbstractIntegrator rkIntegrator, final double[] y, final double[][] yDotArray, final boolean forward, final EquationsMapper primaryMapper, final EquationsMapper[] secondaryMappers) {\n    reinitialize(y, forward, primaryMapper, secondaryMappers);\n    this.yDotK = yDotArray;\n    this.integrator = rkIntegrator;\n}", "code_comment": "/**\n * Reinitialize the instance\n * <p>Some Runge-Kutta integrators need fewer functions evaluations\n * than their counterpart step interpolators. So the interpolator\n * should perform the last evaluations they need by themselves. The\n * {@link RungeKuttaIntegrator RungeKuttaIntegrator} and {@link\n * EmbeddedRungeKuttaIntegrator EmbeddedRungeKuttaIntegrator}\n * abstract classes call this method in order to let the step\n * interpolator perform the evaluations it needs. These evaluations\n * will be performed during the call to <code>doFinalize</code> if\n * any, i.e. only if the step handler either calls the {@link\n * AbstractStepInterpolator#finalizeStep finalizeStep} method or the\n * {@link AbstractStepInterpolator#getInterpolatedState\n * getInterpolatedState} method (for an interpolator which needs a\n * finalization) or if it clones the step interpolator.</p>\n * @param rkIntegrator integrator being used\n * @param y reference to the integrator array holding the state at\n * the end of the step\n * @param yDotArray reference to the integrator array holding all the\n * intermediate slopes\n * @param forward integration direction indicator\n * @param primaryMapper equations mapper for the primary equations set\n * @param secondaryMappers equations mappers for the secondary equations sets\n */\n", "code_no_comment": "public void reinitialize(final AbstractIntegrator rkIntegrator, final double[] y, final double[][] yDotArray, final boolean forward, final EquationsMapper primaryMapper, final EquationsMapper[] secondaryMappers) {\n    reinitialize(y, forward, primaryMapper, secondaryMappers);\n    this.yDotK = yDotArray;\n    this.integrator = rkIntegrator;\n}", "lc": -0.4090909090909091, "pi": -0.49282296650717716, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.5912614517265677, "fo": -0.4166666666666667, "r": -0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "Closure", "project_version": 169, "label": 2, "code": "/**\n * Checks if two types are equivalent.\n */\npublic final boolean isEquivalentTo(JSType that) {\n    return checkEquivalenceHelper(that, false);\n}", "code_comment": "/**\n * Checks if two types are equivalent.\n */\n", "code_no_comment": "public final boolean isEquivalentTo(JSType that) {\n    return checkEquivalenceHelper(that, false);\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.0451021846370678, "fo": -0.4166666666666667, "r": 2.5789473684210527, "e": -0.16279340490885932}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1822_3e83a4c1", "label": 1, "code": "/**\n * Apply the changes to the in-memory document.\n *\n * @param doc\n *            the target document.\n * @param update\n *            the changes to apply.\n * @param comparator\n *            the revision comparator.\n */\npublic static void applyChanges(@Nonnull Document doc, @Nonnull UpdateOp update, @Nonnull Comparator<Revision> comparator) {\n    for (Entry<Key, Operation> e : checkNotNull(update).getChanges().entrySet()) {\n        Key k = e.getKey();\n        Operation op = e.getValue();\n        switch(op.type) {\n            case SET:\n                {\n                    doc.put(k.toString(), op.value);\n                    break;\n                }\n            case INCREMENT:\n                {\n                    Object old = doc.get(k.toString());\n                    Long x = (Long) op.value;\n                    if (old == null) {\n                        old = 0L;\n                    }\n                    doc.put(k.toString(), ((Long) old) + x);\n                    break;\n                }\n            case SET_MAP_ENTRY:\n                {\n                    Object old = doc.get(k.getName());\n                    @SuppressWarnings(\"unchecked\")\n                    Map<Revision, Object> m = (Map<Revision, Object>) old;\n                    if (m == null) {\n                        m = new TreeMap<Revision, Object>(comparator);\n                        doc.put(k.getName(), m);\n                    }\n                    if (k.getRevision() == null) {\n                        throw new IllegalArgumentException(\"Cannot set map entry \" + k.getName() + \" with null revision\");\n                    }\n                    m.put(k.getRevision(), op.value);\n                    break;\n                }\n            case REMOVE_MAP_ENTRY:\n                {\n                    Object old = doc.get(k.getName());\n                    @SuppressWarnings(\"unchecked\")\n                    Map<Revision, Object> m = (Map<Revision, Object>) old;\n                    if (m != null) {\n                        m.remove(k.getRevision());\n                    }\n                    break;\n                }\n            case CONTAINS_MAP_ENTRY:\n                // no effect\n                break;\n        }\n    }\n}", "code_comment": "/**\n * Apply the changes to the in-memory document.\n *\n * @param doc\n *            the target document.\n * @param update\n *            the changes to apply.\n * @param comparator\n *            the revision comparator.\n */\n", "code_no_comment": "public static void applyChanges(@Nonnull Document doc, @Nonnull UpdateOp update, @Nonnull Comparator<Revision> comparator) {\n    for (Entry<Key, Operation> e : checkNotNull(update).getChanges().entrySet()) {\n        Key k = e.getKey();\n        Operation op = e.getValue();\n        switch(op.type) {\n            case SET:\n                {\n                    doc.put(k.toString(), op.value);\n                    break;\n                }\n            case INCREMENT:\n                {\n                    Object old = doc.get(k.toString());\n                    Long x = (Long) op.value;\n                    if (old == null) {\n                        old = 0L;\n                    }\n                    doc.put(k.toString(), ((Long) old) + x);\n                    break;\n                }\n            case SET_MAP_ENTRY:\n                {\n                    Object old = doc.get(k.getName());\n                    @SuppressWarnings(\"unchecked\")\n                    Map<Revision, Object> m = (Map<Revision, Object>) old;\n                    if (m == null) {\n                        m = new TreeMap<Revision, Object>(comparator);\n                        doc.put(k.getName(), m);\n                    }\n                    if (k.getRevision() == null) {\n                        throw new IllegalArgumentException(\"Cannot set map entry \" + k.getName() + \" with null revision\");\n                    }\n                    m.put(k.getRevision(), op.value);\n                    break;\n                }\n            case REMOVE_MAP_ENTRY:\n                {\n                    Object old = doc.get(k.getName());\n                    @SuppressWarnings(\"unchecked\")\n                    Map<Revision, Object> m = (Map<Revision, Object>) old;\n                    if (m != null) {\n                        m.remove(k.getRevision());\n                    }\n                    break;\n                }\n            case CONTAINS_MAP_ENTRY:\n                                break;\n        }\n    }\n}", "lc": 1.6363636363636365, "pi": 1.449760765550239, "ma": 2.6, "nbd": 1.0, "ml": 0.6666666666666666, "d": 0.6845238095238095, "mi": -0.9016208597603944, "fo": 1.4166666666666667, "r": -0.02631578947368421, "e": 1.8259089573140155}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-631_ebc61de9", "label": 1, "code": "/**\n * {@inheritDoc}\n */\nprotected final double doSolve() {\n    // Get initial solution\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    // regardless of the allowed solutions.\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    // Verify bracketing of initial solution.\n    verifyBracketing(x0, x1);\n    // Get accuracies.\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    // Keep track of inverted intervals, meaning that the left bound is\n    // larger than the right bound.\n    boolean inverted = false;\n    // Keep finding better approximations.\n    while (true) {\n        // Calculate the next approximation.\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        // we can return it regardless of the allowed solutions.\n        if (fx == 0.0) {\n            return x;\n        }\n        // Update the bounds with the new approximation.\n        if (f1 * fx < 0) {\n            // The value of x1 has switched to the other bound, thus inverting\n            // the interval.\n            x0 = x1;\n            f0 = f1;\n            inverted = !inverted;\n        } else {\n            switch(method) {\n                case ILLINOIS:\n                    f0 *= 0.5;\n                    break;\n                case PEGASUS:\n                    f0 *= f1 / (f1 + fx);\n                    break;\n                case REGULA_FALSI:\n                    if (x == x1) {\n                        final double delta = FastMath.max(rtol * FastMath.abs(x1), atol);\n                        // Update formula cannot make any progress: Update the\n                        // search interval.\n                        x0 = 0.5 * (x0 + x1 - delta);\n                        f0 = computeObjectiveValue(x0);\n                    }\n                    break;\n                default:\n                    // Should never happen.\n                    throw new MathInternalError();\n            }\n        }\n        // Update from [x0, x1] to [x0, x].\n        x1 = x;\n        f1 = fx;\n        // the root than we already are.\n        if (FastMath.abs(f1) <= ftol) {\n            switch(allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                case BELOW_SIDE:\n                    if (f1 <= 0) {\n                        return x1;\n                    }\n                    break;\n                case ABOVE_SIDE:\n                    if (f1 >= 0) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n        // are satisfied with the current approximation.\n        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {\n            switch(allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                case BELOW_SIDE:\n                    return (f1 <= 0) ? x1 : x0;\n                case ABOVE_SIDE:\n                    return (f1 >= 0) ? x1 : x0;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n    }\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "protected final double doSolve() {\n        double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n        if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n        verifyBracketing(x0, x1);\n        final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n            boolean inverted = false;\n        while (true) {\n                final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n                if (fx == 0.0) {\n            return x;\n        }\n                if (f1 * fx < 0) {\n                                    x0 = x1;\n            f0 = f1;\n            inverted = !inverted;\n        } else {\n            switch(method) {\n                case ILLINOIS:\n                    f0 *= 0.5;\n                    break;\n                case PEGASUS:\n                    f0 *= f1 / (f1 + fx);\n                    break;\n                case REGULA_FALSI:\n                    if (x == x1) {\n                        final double delta = FastMath.max(rtol * FastMath.abs(x1), atol);\n                                                                        x0 = 0.5 * (x0 + x1 - delta);\n                        f0 = computeObjectiveValue(x0);\n                    }\n                    break;\n                default:\n                                        throw new MathInternalError();\n            }\n        }\n                x1 = x;\n        f1 = fx;\n                if (FastMath.abs(f1) <= ftol) {\n            switch(allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                case BELOW_SIDE:\n                    if (f1 <= 0) {\n                        return x1;\n                    }\n                    break;\n                case ABOVE_SIDE:\n                    if (f1 >= 0) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n                if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {\n            switch(allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                case BELOW_SIDE:\n                    return (f1 <= 0) ? x1 : x0;\n                case ABOVE_SIDE:\n                    return (f1 >= 0) ? x1 : x0;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n    }\n}", "lc": 3.590909090909091, "pi": 1.799043062200957, "ma": 7.8, "nbd": 1.5, "ml": 3.3333333333333335, "d": 3.196428571428571, "mi": -1.3915433403805495, "fo": 0.8333333333333334, "r": -0.02631578947368421, "e": 8.570619456786707}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-9340_1cab39f6", "label": 3, "code": "/**\n * Loads the given file store into the 1st level cache\n */\nprotected void loadStore() throws IOException {\n    // auto create starting directory if needed\n    if (!fileStore.exists()) {\n        LOG.debug(\"Creating filestore: {}\", fileStore);\n        File parent = fileStore.getParentFile();\n        parent.mkdirs();\n        boolean created = FileUtil.createNewFile(fileStore);\n        if (!created) {\n            throw new IOException(\"Cannot create filestore: \" + fileStore);\n        }\n    }\n    LOG.trace(\"Loading to 1st level cache from idempotent filestore: {}\", fileStore);\n    cache.clear();\n    Scanner scanner = null;\n    try {\n        scanner = new Scanner(fileStore);\n        scanner.useDelimiter(STORE_DELIMITER);\n        while (scanner.hasNextLine()) {\n            String line = scanner.nextLine();\n            cache.put(line, line);\n        }\n    } catch (IOException e) {\n        throw ObjectHelper.wrapRuntimeCamelException(e);\n    } finally {\n        if (scanner != null) {\n            scanner.close();\n        }\n    }\n    LOG.debug(\"Loaded {} to the 1st level cache from idempotent filestore: {}\", cache.size(), fileStore);\n}", "code_comment": "/**\n * Loads the given file store into the 1st level cache\n */\n", "code_no_comment": "protected void loadStore() throws IOException {\n        if (!fileStore.exists()) {\n        LOG.debug(\"Creating filestore: {}\", fileStore);\n        File parent = fileStore.getParentFile();\n        parent.mkdirs();\n        boolean created = FileUtil.createNewFile(fileStore);\n        if (!created) {\n            throw new IOException(\"Cannot create filestore: \" + fileStore);\n        }\n    }\n    LOG.trace(\"Loading to 1st level cache from idempotent filestore: {}\", fileStore);\n    cache.clear();\n    Scanner scanner = null;\n    try {\n        scanner = new Scanner(fileStore);\n        scanner.useDelimiter(STORE_DELIMITER);\n        while (scanner.hasNextLine()) {\n            String line = scanner.nextLine();\n            cache.put(line, line);\n        }\n    } catch (IOException e) {\n        throw ObjectHelper.wrapRuntimeCamelException(e);\n    } finally {\n        if (scanner != null) {\n            scanner.close();\n        }\n    }\n    LOG.debug(\"Loaded {} to the 1st level cache from idempotent filestore: {}\", cache.size(), fileStore);\n}", "lc": 0.6818181818181818, "pi": 0.10047846889952151, "ma": 0.8, "nbd": 0.0, "ml": 0.25, "d": 0.32936507936507936, "mi": -0.48386187455954865, "fo": 0.75, "r": -0.02631578947368421, "e": 0.4555131020095318}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-2121_03340919", "label": 3, "code": "/**\n *  Computes the input splits for the file. By default, one file block is one split. If more splits\n *  are requested than blocks are available, then a split may be a fraction of a block and splits may cross\n *  block boundaries.\n *\n *  @param minNumSplits The minimum desired number of file splits.\n *  @return The computed file splits.\n *\n *  @see org.apache.flink.api.common.io.InputFormat#createInputSplits(int)\n */\n@Override\npublic FileInputSplit[] createInputSplits(int minNumSplits) throws IOException {\n    if (minNumSplits < 1) {\n        throw new IllegalArgumentException(\"Number of input splits has to be at least 1.\");\n    }\n    // take the desired number of splits into account\n    minNumSplits = Math.max(minNumSplits, this.numSplits);\n    final Path path = this.filePath;\n    final List<FileInputSplit> inputSplits = new ArrayList<FileInputSplit>(minNumSplits);\n    // get all the files that are involved in the splits\n    List<FileStatus> files = new ArrayList<FileStatus>();\n    long totalLength = 0;\n    final FileSystem fs = path.getFileSystem();\n    final FileStatus pathFile = fs.getFileStatus(path);\n    if (pathFile.isDir()) {\n        totalLength += addFilesInDir(path, files, totalLength, true);\n    } else {\n        testForUnsplittable(pathFile);\n        files.add(pathFile);\n        totalLength += pathFile.getLen();\n    }\n    // returns if unsplittable\n    if (unsplittable) {\n        int splitNum = 0;\n        for (final FileStatus file : files) {\n            final BlockLocation[] blocks = fs.getFileBlockLocations(file, 0, file.getLen());\n            Set<String> hosts = new HashSet<String>();\n            for (BlockLocation block : blocks) {\n                hosts.addAll(Arrays.asList(block.getHosts()));\n            }\n            long len = file.getLen();\n            if (testForUnsplittable(file)) {\n                len = READ_WHOLE_SPLIT_FLAG;\n            }\n            FileInputSplit fis = new FileInputSplit(splitNum++, file.getPath(), 0, len, hosts.toArray(new String[hosts.size()]));\n            inputSplits.add(fis);\n        }\n        return inputSplits.toArray(new FileInputSplit[inputSplits.size()]);\n    }\n    final long maxSplitSize = (minNumSplits < 1) ? Long.MAX_VALUE : (totalLength / minNumSplits + (totalLength % minNumSplits == 0 ? 0 : 1));\n    // now that we have the files, generate the splits\n    int splitNum = 0;\n    for (final FileStatus file : files) {\n        final long len = file.getLen();\n        final long blockSize = file.getBlockSize();\n        final long minSplitSize;\n        if (this.minSplitSize <= blockSize) {\n            minSplitSize = this.minSplitSize;\n        } else {\n            if (LOG.isWarnEnabled()) {\n                LOG.warn(\"Minimal split size of \" + this.minSplitSize + \" is larger than the block size of \" + blockSize + \". Decreasing minimal split size to block size.\");\n            }\n            minSplitSize = blockSize;\n        }\n        final long splitSize = Math.max(minSplitSize, Math.min(maxSplitSize, blockSize));\n        final long halfSplit = splitSize >>> 1;\n        final long maxBytesForLastSplit = (long) (splitSize * MAX_SPLIT_SIZE_DISCREPANCY);\n        if (len > 0) {\n            // get the block locations and make sure they are in order with respect to their offset\n            final BlockLocation[] blocks = fs.getFileBlockLocations(file, 0, len);\n            Arrays.sort(blocks);\n            long bytesUnassigned = len;\n            long position = 0;\n            int blockIndex = 0;\n            while (bytesUnassigned > maxBytesForLastSplit) {\n                // get the block containing the majority of the data\n                blockIndex = getBlockIndexForPosition(blocks, position, halfSplit, blockIndex);\n                // create a new split\n                FileInputSplit fis = new FileInputSplit(splitNum++, file.getPath(), position, splitSize, blocks[blockIndex].getHosts());\n                inputSplits.add(fis);\n                // adjust the positions\n                position += splitSize;\n                bytesUnassigned -= splitSize;\n            }\n            // assign the last split\n            if (bytesUnassigned > 0) {\n                blockIndex = getBlockIndexForPosition(blocks, position, halfSplit, blockIndex);\n                final FileInputSplit fis = new FileInputSplit(splitNum++, file.getPath(), position, bytesUnassigned, blocks[blockIndex].getHosts());\n                inputSplits.add(fis);\n            }\n        } else {\n            // special case with a file of zero bytes size\n            final BlockLocation[] blocks = fs.getFileBlockLocations(file, 0, 0);\n            String[] hosts;\n            if (blocks.length > 0) {\n                hosts = blocks[0].getHosts();\n            } else {\n                hosts = new String[0];\n            }\n            final FileInputSplit fis = new FileInputSplit(splitNum++, file.getPath(), 0, 0, hosts);\n            inputSplits.add(fis);\n        }\n    }\n    return inputSplits.toArray(new FileInputSplit[inputSplits.size()]);\n}", "code_comment": "/**\n *  Computes the input splits for the file. By default, one file block is one split. If more splits\n *  are requested than blocks are available, then a split may be a fraction of a block and splits may cross\n *  block boundaries.\n *\n *  @param minNumSplits The minimum desired number of file splits.\n *  @return The computed file splits.\n *\n *  @see org.apache.flink.api.common.io.InputFormat#createInputSplits(int)\n */\n", "code_no_comment": "@Override\npublic FileInputSplit[] createInputSplits(int minNumSplits) throws IOException {\n    if (minNumSplits < 1) {\n        throw new IllegalArgumentException(\"Number of input splits has to be at least 1.\");\n    }\n        minNumSplits = Math.max(minNumSplits, this.numSplits);\n    final Path path = this.filePath;\n    final List<FileInputSplit> inputSplits = new ArrayList<FileInputSplit>(minNumSplits);\n        List<FileStatus> files = new ArrayList<FileStatus>();\n    long totalLength = 0;\n    final FileSystem fs = path.getFileSystem();\n    final FileStatus pathFile = fs.getFileStatus(path);\n    if (pathFile.isDir()) {\n        totalLength += addFilesInDir(path, files, totalLength, true);\n    } else {\n        testForUnsplittable(pathFile);\n        files.add(pathFile);\n        totalLength += pathFile.getLen();\n    }\n        if (unsplittable) {\n        int splitNum = 0;\n        for (final FileStatus file : files) {\n            final BlockLocation[] blocks = fs.getFileBlockLocations(file, 0, file.getLen());\n            Set<String> hosts = new HashSet<String>();\n            for (BlockLocation block : blocks) {\n                hosts.addAll(Arrays.asList(block.getHosts()));\n            }\n            long len = file.getLen();\n            if (testForUnsplittable(file)) {\n                len = READ_WHOLE_SPLIT_FLAG;\n            }\n            FileInputSplit fis = new FileInputSplit(splitNum++, file.getPath(), 0, len, hosts.toArray(new String[hosts.size()]));\n            inputSplits.add(fis);\n        }\n        return inputSplits.toArray(new FileInputSplit[inputSplits.size()]);\n    }\n    final long maxSplitSize = (minNumSplits < 1) ? Long.MAX_VALUE : (totalLength / minNumSplits + (totalLength % minNumSplits == 0 ? 0 : 1));\n        int splitNum = 0;\n    for (final FileStatus file : files) {\n        final long len = file.getLen();\n        final long blockSize = file.getBlockSize();\n        final long minSplitSize;\n        if (this.minSplitSize <= blockSize) {\n            minSplitSize = this.minSplitSize;\n        } else {\n            if (LOG.isWarnEnabled()) {\n                LOG.warn(\"Minimal split size of \" + this.minSplitSize + \" is larger than the block size of \" + blockSize + \". Decreasing minimal split size to block size.\");\n            }\n            minSplitSize = blockSize;\n        }\n        final long splitSize = Math.max(minSplitSize, Math.min(maxSplitSize, blockSize));\n        final long halfSplit = splitSize >>> 1;\n        final long maxBytesForLastSplit = (long) (splitSize * MAX_SPLIT_SIZE_DISCREPANCY);\n        if (len > 0) {\n                        final BlockLocation[] blocks = fs.getFileBlockLocations(file, 0, len);\n            Arrays.sort(blocks);\n            long bytesUnassigned = len;\n            long position = 0;\n            int blockIndex = 0;\n            while (bytesUnassigned > maxBytesForLastSplit) {\n                                blockIndex = getBlockIndexForPosition(blocks, position, halfSplit, blockIndex);\n                                FileInputSplit fis = new FileInputSplit(splitNum++, file.getPath(), position, splitSize, blocks[blockIndex].getHosts());\n                inputSplits.add(fis);\n                                position += splitSize;\n                bytesUnassigned -= splitSize;\n            }\n                        if (bytesUnassigned > 0) {\n                blockIndex = getBlockIndexForPosition(blocks, position, halfSplit, blockIndex);\n                final FileInputSplit fis = new FileInputSplit(splitNum++, file.getPath(), position, bytesUnassigned, blocks[blockIndex].getHosts());\n                inputSplits.add(fis);\n            }\n        } else {\n                        final BlockLocation[] blocks = fs.getFileBlockLocations(file, 0, 0);\n            String[] hosts;\n            if (blocks.length > 0) {\n                hosts = blocks[0].getHosts();\n            } else {\n                hosts = new String[0];\n            }\n            final FileInputSplit fis = new FileInputSplit(splitNum++, file.getPath(), 0, 0, hosts);\n            inputSplits.add(fis);\n        }\n    }\n    return inputSplits.toArray(new FileInputSplit[inputSplits.size()]);\n}", "lc": 3.227272727272727, "pi": 0.6602870813397129, "ma": 2.6, "nbd": 0.5, "ml": 1.6666666666666667, "d": 3.763888888888889, "mi": -1.2824524312896401, "fo": 3.0833333333333335, "r": -0.02631578947368421, "e": 19.950164531503024}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-914_f8a42197", "label": 3, "code": "/**\n * Format the stack trace including packaging information.\n *\n * @param ignorePackages\n *        List of packages to be ignored in the trace.\n * @return The formatted stack trace including packaging information.\n */\npublic String getExtendedStackTraceAsString(final List<String> ignorePackages) {\n    final StringBuilder sb = new StringBuilder(this.name);\n    final String msg = this.message;\n    if (msg != null) {\n        sb.append(\": \").append(msg);\n    }\n    sb.append(EOL);\n    this.formatElements(sb, 0, this.throwable.getStackTrace(), this.extendedStackTrace, ignorePackages);\n    this.formatCause(sb, this.causeProxy, ignorePackages);\n    return sb.toString();\n}", "code_comment": "/**\n * Format the stack trace including packaging information.\n *\n * @param ignorePackages\n *        List of packages to be ignored in the trace.\n * @return The formatted stack trace including packaging information.\n */\n", "code_no_comment": "public String getExtendedStackTraceAsString(final List<String> ignorePackages) {\n    final StringBuilder sb = new StringBuilder(this.name);\n    final String msg = this.message;\n    if (msg != null) {\n        sb.append(\": \").append(msg);\n    }\n    sb.append(EOL);\n    this.formatElements(sb, 0, this.throwable.getStackTrace(), this.extendedStackTrace, ignorePackages);\n    this.formatCause(sb, this.causeProxy, ignorePackages);\n    return sb.toString();\n}", "lc": -0.13636363636363635, "pi": -0.444976076555024, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": -0.039682539682539715, "mi": 0.10951374207188172, "fo": 0.08333333333333333, "r": 0.0, "e": -0.027894861199956194}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-276_1bf5c550", "label": 1, "code": "public Id readHead() {\n    return head;\n}", "code_comment": NaN, "code_no_comment": "public Id readHead() {\n    return head;\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.1646229739252991, "fo": -0.5, "r": 2.4736842105263155, "e": -0.16279340490885932}
{"project_name": "Compress", "project_version": 35, "label": 1, "code": "/**\n * Wikipedia <a href=\"http://en.wikipedia.org/wiki/Tar_(file_format)#File_header\">says</a>:\n * <blockquote>\n * The checksum is calculated by taking the sum of the unsigned byte values\n * of the header block with the eight checksum bytes taken to be ascii\n * spaces (decimal value 32). It is stored as a six digit octal number with\n * leading zeroes followed by a NUL and then a space. Various\n * implementations do not adhere to this format. For better compatibility,\n * ignore leading and trailing whitespace, and get the first six digits. In\n * addition, some historic tar implementations treated bytes as signed.\n * Implementations typically calculate the checksum both ways, and treat it\n * as good if either the signed or unsigned sum matches the included\n * checksum.\n * </blockquote>\n * <p>\n * The return value of this method should be treated as a best-effort\n * heuristic rather than an absolute and final truth. The checksum\n * verification logic may well evolve over time as more special cases\n * are encountered.\n *\n * @param header tar header\n * @return whether the checksum is reasonably good\n * @see <a href=\"https://issues.apache.org/jira/browse/COMPRESS-191\">COMPRESS-191</a>\n * @since 1.5\n */\npublic static boolean verifyCheckSum(byte[] header) {\n    long storedSum = 0;\n    long unsignedSum = 0;\n    long signedSum = 0;\n    int digits = 0;\n    for (int i = 0; i < header.length; i++) {\n        byte b = header[i];\n        if (CHKSUM_OFFSET <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n            if ('0' <= b && b <= '7' && digits++ < 6) {\n                storedSum = storedSum * 8 + b - '0';\n            } else if (digits > 0) {\n                digits = 6;\n            }\n            b = ' ';\n        }\n        unsignedSum += 0xff & b;\n        signedSum += b;\n    }\n    return storedSum == unsignedSum || storedSum == signedSum;\n}", "code_comment": "/**\n * Wikipedia <a href=\"http://en.wikipedia.org/wiki/Tar_(file_format)#File_header\">says</a>:\n * <blockquote>\n * The checksum is calculated by taking the sum of the unsigned byte values\n * of the header block with the eight checksum bytes taken to be ascii\n * spaces (decimal value 32). It is stored as a six digit octal number with\n * leading zeroes followed by a NUL and then a space. Various\n * implementations do not adhere to this format. For better compatibility,\n * ignore leading and trailing whitespace, and get the first six digits. In\n * addition, some historic tar implementations treated bytes as signed.\n * Implementations typically calculate the checksum both ways, and treat it\n * as good if either the signed or unsigned sum matches the included\n * checksum.\n * </blockquote>\n * <p>\n * The return value of this method should be treated as a best-effort\n * heuristic rather than an absolute and final truth. The checksum\n * verification logic may well evolve over time as more special cases\n * are encountered.\n *\n * @param header tar header\n * @return whether the checksum is reasonably good\n * @see <a href=\"https://issues.apache.org/jira/browse/COMPRESS-191\">COMPRESS-191</a>\n * @since 1.5\n */\n", "code_no_comment": "public static boolean verifyCheckSum(byte[] header) {\n    long storedSum = 0;\n    long unsignedSum = 0;\n    long signedSum = 0;\n    int digits = 0;\n    for (int i = 0; i < header.length; i++) {\n        byte b = header[i];\n        if (CHKSUM_OFFSET <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n            if ('0' <= b && b <= '7' && digits++ < 6) {\n                storedSum = storedSum * 8 + b - '0';\n            } else if (digits > 0) {\n                digits = 6;\n            }\n            b = ' ';\n        }\n        unsignedSum += 0xff & b;\n        signedSum += b;\n    }\n    return storedSum == unsignedSum || storedSum == signedSum;\n}", "lc": 0.2727272727272727, "pi": 0.7751196172248805, "ma": 0.2, "nbd": 1.0, "ml": 0.5, "d": 3.007936507936508, "mi": -0.3034531360112755, "fo": -0.5, "r": -0.02631578947368421, "e": 3.0211764434685886}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-334_9d8cc45d", "label": 1, "code": "@Override\npublic SortedKeyValueIterator<Key, Value> deepCopy(IteratorEnvironment env) {\n    return new TimestampFilter(getSource(), hasStart, start, startInclusive, hasEnd, end, endInclusive);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic SortedKeyValueIterator<Key, Value> deepCopy(IteratorEnvironment env) {\n    return new TimestampFilter(getSource(), hasStart, start, startInclusive, hasEnd, end, endInclusive);\n}", "lc": -0.45454545454545453, "pi": -0.6028708133971293, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.7285412262156447, "fo": -0.4166666666666667, "r": -0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-3395_8433e6db", "label": 3, "code": "public Iterator iterator() {\n    return new Iterator() {\n\n        private int index;\n\n        private boolean closed;\n\n        public boolean hasNext() {\n            if (closed) {\n                return false;\n            }\n            boolean answer = iterator.hasNext();\n            if (!answer) {\n                // we are now closed\n                closed = true;\n                // nothing more so we need to close the expression value in case it needs to be\n                if (value instanceof Closeable) {\n                    IOHelper.close((Closeable) value, value.getClass().getName(), LOG);\n                } else if (value instanceof Scanner) {\n                    // special for Scanner as it does not implement Closeable\n                    ((Scanner) value).close();\n                }\n            }\n            return answer;\n        }\n\n        public Object next() {\n            Object part = iterator.next();\n            Exchange newExchange = exchange.copy();\n            if (part instanceof Message) {\n                newExchange.setIn((Message) part);\n            } else {\n                Message in = newExchange.getIn();\n                in.setBody(part);\n            }\n            return createProcessorExchangePair(index++, getProcessors().iterator().next(), newExchange);\n        }\n\n        public void remove() {\n            throw new UnsupportedOperationException(\"Remove is not supported by this iterator\");\n        }\n    };\n}", "code_comment": NaN, "code_no_comment": "public Iterator iterator() {\n    return new Iterator() {\n\n        private int index;\n\n        private boolean closed;\n\n        public boolean hasNext() {\n            if (closed) {\n                return false;\n            }\n            boolean answer = iterator.hasNext();\n            if (!answer) {\n                                closed = true;\n                                if (value instanceof Closeable) {\n                    IOHelper.close((Closeable) value, value.getClass().getName(), LOG);\n                } else if (value instanceof Scanner) {\n                                        ((Scanner) value).close();\n                }\n            }\n            return answer;\n        }\n\n        public Object next() {\n            Object part = iterator.next();\n            Exchange newExchange = exchange.copy();\n            if (part instanceof Message) {\n                newExchange.setIn((Message) part);\n            } else {\n                Message in = newExchange.getIn();\n                in.setBody(part);\n            }\n            return createProcessorExchangePair(index++, getProcessors().iterator().next(), newExchange);\n        }\n\n        public void remove() {\n            throw new UnsupportedOperationException(\"Remove is not supported by this iterator\");\n        }\n    };\n}", "lc": 0.9545454545454546, "pi": 0.8325358851674642, "ma": 0.6, "nbd": 1.0, "ml": 0.3333333333333333, "d": 0.0019841269841269858, "mi": -0.5560253699788581, "fo": 0.6666666666666666, "r": -0.02631578947368421, "e": 0.1487272580580096}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-2713_63d9800e", "label": 1, "code": "@Override\npublic StateHandle<Serializable> snapshotState(long checkpointId, long checkpointTimestamp) throws Exception {\n    return stateStore.snapshotStates(checkpointId, checkpointTimestamp);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic StateHandle<Serializable> snapshotState(long checkpointId, long checkpointTimestamp) throws Exception {\n    return stateStore.snapshotStates(checkpointId, checkpointTimestamp);\n}", "lc": -0.45454545454545453, "pi": -0.6028708133971293, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.7978858350951374, "fo": -0.4166666666666667, "r": 0.1842105263157895, "e": -0.16279340490885932}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-294_2c8a114f", "label": 1, "code": "/**\n * {@inheritDoc}\n * <p>\n * <strong>Algorithm Description</strong>: For small means, uses simulation\n * of a Poisson process using Uniform deviates, as described <a\n * href=\"http://irmi.epfl.ch/cmos/Pmmi/interactive/rng7.htm\"> here.</a>\n * </p>\n * <p>\n * The Poisson process (and hence value returned) is bounded by 1000 * mean.\n * </p>\n *\n * <p>\n * For large means, uses a reject method as described in <a\n * href=\"http://cg.scs.carleton.ca/~luc/rnbookindex.html\">Non-Uniform Random\n * Variate Generation</a>\n * </p>\n *\n * <p>\n * References:\n * <ul>\n * <li>Devroye, Luc. (1986). <i>Non-Uniform Random Variate Generation</i>.\n * New York, NY. Springer-Verlag</li>\n * </ul>\n * </p>\n *\n * @param mean\n *            mean of the Poisson distribution.\n * @return the random Poisson value.\n */\npublic long nextPoisson(double mean) {\n    if (mean <= 0) {\n        throw MathRuntimeException.createIllegalArgumentException(\"the Poisson mean must be positive ({0})\", mean);\n    }\n    final RandomGenerator generator = getRan();\n    double pivot = 6.0;\n    if (mean < pivot) {\n        double p = Math.exp(-mean);\n        long n = 0;\n        double r = 1.0d;\n        double rnd = 1.0d;\n        while (n < 1000 * mean) {\n            rnd = generator.nextDouble();\n            r = r * rnd;\n            if (r >= p) {\n                n++;\n            } else {\n                return n;\n            }\n        }\n        return n;\n    } else {\n        double mu = Math.floor(mean);\n        // integer\n        double delta = Math.floor(pivot + (mu - pivot) / 2.0);\n        // between 6\n        // and mean\n        double mu2delta = 2.0 * mu + delta;\n        double muDeltaHalf = mu + delta / 2.0;\n        double logMeanMu = Math.log(mean / mu);\n        double muFactorialLog = MathUtils.factorialLog((int) mu);\n        double c1 = Math.sqrt(Math.PI * mu / 2.0);\n        double c2 = c1 + Math.sqrt(Math.PI * muDeltaHalf / (2.0 * Math.exp(1.0 / mu2delta)));\n        double c3 = c2 + 2.0;\n        double c4 = c3 + Math.exp(1.0 / 78.0);\n        double c = c4 + 2.0 / delta * mu2delta * Math.exp(-delta / mu2delta * (1.0 + delta / 2.0));\n        double y = 0.0;\n        double x = 0.0;\n        double w = Double.POSITIVE_INFINITY;\n        boolean accept = false;\n        while (!accept) {\n            double u = nextUniform(0.0, c);\n            double e = nextExponential(mean);\n            if (u <= c1) {\n                double z = nextGaussian(0.0, 1.0);\n                y = -Math.abs(z) * Math.sqrt(mu) - 1.0;\n                x = Math.floor(y);\n                w = -z * z / 2.0 - e - x * logMeanMu;\n                if (x < -mu) {\n                    w = Double.POSITIVE_INFINITY;\n                }\n            } else if (c1 < u && u <= c2) {\n                double z = nextGaussian(0.0, 1.0);\n                y = 1.0 + Math.abs(z) * Math.sqrt(muDeltaHalf);\n                x = Math.ceil(y);\n                w = (-y * y + 2.0 * y) / mu2delta - e - x * logMeanMu;\n                if (x > delta) {\n                    w = Double.POSITIVE_INFINITY;\n                }\n            } else if (c2 < u && u <= c3) {\n                x = 0.0;\n                w = -e;\n            } else if (c3 < u && u <= c4) {\n                x = 1.0;\n                w = -e - logMeanMu;\n            } else if (c4 < u) {\n                double v = nextExponential(mean);\n                y = delta + v * 2.0 / delta * mu2delta;\n                x = Math.ceil(y);\n                w = -delta / mu2delta * (1.0 + y / 2.0) - e - x * logMeanMu;\n            }\n            accept = w <= x * Math.log(mu) - MathUtils.factorialLog((int) (mu + x)) / muFactorialLog;\n        }\n        // numbers.\n        return (long) (x + mu);\n    }\n}", "code_comment": "/**\n * {@inheritDoc}\n * <p>\n * <strong>Algorithm Description</strong>: For small means, uses simulation\n * of a Poisson process using Uniform deviates, as described <a\n * href=\"http://irmi.epfl.ch/cmos/Pmmi/interactive/rng7.htm\"> here.</a>\n * </p>\n * <p>\n * The Poisson process (and hence value returned) is bounded by 1000 * mean.\n * </p>\n *\n * <p>\n * For large means, uses a reject method as described in <a\n * href=\"http://cg.scs.carleton.ca/~luc/rnbookindex.html\">Non-Uniform Random\n * Variate Generation</a>\n * </p>\n *\n * <p>\n * References:\n * <ul>\n * <li>Devroye, Luc. (1986). <i>Non-Uniform Random Variate Generation</i>.\n * New York, NY. Springer-Verlag</li>\n * </ul>\n * </p>\n *\n * @param mean\n *            mean of the Poisson distribution.\n * @return the random Poisson value.\n */\n", "code_no_comment": "public long nextPoisson(double mean) {\n    if (mean <= 0) {\n        throw MathRuntimeException.createIllegalArgumentException(\"the Poisson mean must be positive ({0})\", mean);\n    }\n    final RandomGenerator generator = getRan();\n    double pivot = 6.0;\n    if (mean < pivot) {\n        double p = Math.exp(-mean);\n        long n = 0;\n        double r = 1.0d;\n        double rnd = 1.0d;\n        while (n < 1000 * mean) {\n            rnd = generator.nextDouble();\n            r = r * rnd;\n            if (r >= p) {\n                n++;\n            } else {\n                return n;\n            }\n        }\n        return n;\n    } else {\n        double mu = Math.floor(mean);\n                double delta = Math.floor(pivot + (mu - pivot) / 2.0);\n                        double mu2delta = 2.0 * mu + delta;\n        double muDeltaHalf = mu + delta / 2.0;\n        double logMeanMu = Math.log(mean / mu);\n        double muFactorialLog = MathUtils.factorialLog((int) mu);\n        double c1 = Math.sqrt(Math.PI * mu / 2.0);\n        double c2 = c1 + Math.sqrt(Math.PI * muDeltaHalf / (2.0 * Math.exp(1.0 / mu2delta)));\n        double c3 = c2 + 2.0;\n        double c4 = c3 + Math.exp(1.0 / 78.0);\n        double c = c4 + 2.0 / delta * mu2delta * Math.exp(-delta / mu2delta * (1.0 + delta / 2.0));\n        double y = 0.0;\n        double x = 0.0;\n        double w = Double.POSITIVE_INFINITY;\n        boolean accept = false;\n        while (!accept) {\n            double u = nextUniform(0.0, c);\n            double e = nextExponential(mean);\n            if (u <= c1) {\n                double z = nextGaussian(0.0, 1.0);\n                y = -Math.abs(z) * Math.sqrt(mu) - 1.0;\n                x = Math.floor(y);\n                w = -z * z / 2.0 - e - x * logMeanMu;\n                if (x < -mu) {\n                    w = Double.POSITIVE_INFINITY;\n                }\n            } else if (c1 < u && u <= c2) {\n                double z = nextGaussian(0.0, 1.0);\n                y = 1.0 + Math.abs(z) * Math.sqrt(muDeltaHalf);\n                x = Math.ceil(y);\n                w = (-y * y + 2.0 * y) / mu2delta - e - x * logMeanMu;\n                if (x > delta) {\n                    w = Double.POSITIVE_INFINITY;\n                }\n            } else if (c2 < u && u <= c3) {\n                x = 0.0;\n                w = -e;\n            } else if (c3 < u && u <= c4) {\n                x = 1.0;\n                w = -e - logMeanMu;\n            } else if (c4 < u) {\n                double v = nextExponential(mean);\n                y = delta + v * 2.0 / delta * mu2delta;\n                x = Math.ceil(y);\n                w = -delta / mu2delta * (1.0 + y / 2.0) - e - x * logMeanMu;\n            }\n            accept = w <= x * Math.log(mu) - MathUtils.factorialLog((int) (mu + x)) / muFactorialLog;\n        }\n                return (long) (x + mu);\n    }\n}", "lc": 2.6818181818181817, "pi": 0.7703349282296649, "ma": 2.0, "nbd": 2.5, "ml": 2.0, "d": 4.6230158730158735, "mi": -1.2077519379844959, "fo": 1.75, "r": -0.02631578947368421, "e": 26.617389049290292}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-428_4a6a573b", "label": 3, "code": "/**\n *  @see java.util.Map#values()\n */\npublic Collection values() {\n    return new AbstractList() {\n\n        public Object get(final int index) {\n            int keyIndex = nextKey(0);\n            for (int i = 0; i < index; i++) {\n                keyIndex = nextKey(keyIndex + 1);\n            }\n            return values[keyIndex];\n        }\n\n        public int size() {\n            return size;\n        }\n    };\n}", "code_comment": "/**\n *  @see java.util.Map#values()\n */\n", "code_no_comment": "public Collection values() {\n    return new AbstractList() {\n\n        public Object get(final int index) {\n            int keyIndex = nextKey(0);\n            for (int i = 0; i < index; i++) {\n                keyIndex = nextKey(keyIndex + 1);\n            }\n            return values[keyIndex];\n        }\n\n        public int size() {\n            return size;\n        }\n    };\n}", "lc": 0.0, "pi": 0.7942583732057418, "ma": -0.4, "nbd": 0.0, "ml": -0.16666666666666666, "d": 0.33730158730158727, "mi": 0.059619450317124574, "fo": -0.3333333333333333, "r": 2.236842105263158, "e": 0.030582689326486966}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-1297_56434517", "label": 1, "code": "/**\n * Start the integration.\n * <p>This method computes one step using the underlying starter integrator,\n * and initializes the Nordsieck vector at step start. The starter integrator\n * purpose is only to establish initial conditions, it does not really change\n * time by itself. The top level multistep integrator remains in charge of\n * handling time propagation and events handling as it will starts its own\n * computation right from the beginning. In a sense, the starter integrator\n * can be seen as a dummy one and so it will never trigger any user event nor\n * call any user step handler.</p>\n * @param t0 initial time\n * @param y0 initial value of the state vector at t0\n * @param t target time for the integration\n * (can be set to a value smaller than <code>t0</code> for backward integration)\n * @exception DimensionMismatchException if arrays dimension do not match equations settings\n * @exception NumberIsTooSmallException if integration step is too small\n * @exception MaxCountExceededException if the number of functions evaluations is exceeded\n * @exception NoBracketingException if the location of an event cannot be bracketed\n */\nprotected void start(final double t0, final double[] y0, final double t) throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException {\n    // make sure NO user event nor user step handler is triggered,\n    // this is the task of the top level integrator, not the task\n    // of the starter integrator\n    starter.clearEventHandlers();\n    starter.clearStepHandlers();\n    // set up one specific step handler to extract initial Nordsieck vector\n    starter.addStepHandler(new NordsieckInitializer((nSteps + 3) / 2, y0.length));\n    // start integration, expecting a InitializationCompletedMarkerException\n    try {\n        if (starter instanceof AbstractIntegrator) {\n            ((AbstractIntegrator) starter).integrate(getExpandable(), t);\n        } else {\n            starter.integrate(new FirstOrderDifferentialEquations() {\n\n                /**\n                 * {@inheritDoc}\n                 */\n                @Override\n                public int getDimension() {\n                    return getExpandable().getTotalDimension();\n                }\n\n                /**\n                 * {@inheritDoc}\n                 */\n                @Override\n                public void computeDerivatives(double t, double[] y, double[] yDot) {\n                    getExpandable().computeDerivatives(t, y, yDot);\n                }\n            }, t0, y0, t, new double[y0.length]);\n        }\n    } catch (InitializationCompletedMarkerException icme) {\n        // NOPMD\n        // this is the expected nominal interruption of the start integrator\n        // count the evaluations used by the starter\n        getCounter().increment(starter.getEvaluations());\n    }\n    // remove the specific step handler\n    starter.clearStepHandlers();\n}", "code_comment": "/**\n * Start the integration.\n * <p>This method computes one step using the underlying starter integrator,\n * and initializes the Nordsieck vector at step start. The starter integrator\n * purpose is only to establish initial conditions, it does not really change\n * time by itself. The top level multistep integrator remains in charge of\n * handling time propagation and events handling as it will starts its own\n * computation right from the beginning. In a sense, the starter integrator\n * can be seen as a dummy one and so it will never trigger any user event nor\n * call any user step handler.</p>\n * @param t0 initial time\n * @param y0 initial value of the state vector at t0\n * @param t target time for the integration\n * (can be set to a value smaller than <code>t0</code> for backward integration)\n * @exception DimensionMismatchException if arrays dimension do not match equations settings\n * @exception NumberIsTooSmallException if integration step is too small\n * @exception MaxCountExceededException if the number of functions evaluations is exceeded\n * @exception NoBracketingException if the location of an event cannot be bracketed\n */\n/**\n * {@inheritDoc}\n */\n/**\n * {@inheritDoc}\n */\n", "code_no_comment": "protected void start(final double t0, final double[] y0, final double t) throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException {\n                starter.clearEventHandlers();\n    starter.clearStepHandlers();\n        starter.addStepHandler(new NordsieckInitializer((nSteps + 3) / 2, y0.length));\n        try {\n        if (starter instanceof AbstractIntegrator) {\n            ((AbstractIntegrator) starter).integrate(getExpandable(), t);\n        } else {\n            starter.integrate(new FirstOrderDifferentialEquations() {\n\n                /**\n                 * {@inheritDoc}\n                 */\n                @Override\n                public int getDimension() {\n                    return getExpandable().getTotalDimension();\n                }\n\n                /**\n                 * {@inheritDoc}\n                 */\n                @Override\n                public void computeDerivatives(double t, double[] y, double[] yDot) {\n                    getExpandable().computeDerivatives(t, y, yDot);\n                }\n            }, t0, y0, t, new double[y0.length]);\n        }\n    } catch (InitializationCompletedMarkerException icme) {\n                                getCounter().increment(starter.getEvaluations());\n    }\n        starter.clearStepHandlers();\n}", "lc": 0.7272727272727273, "pi": 1.5071770334928227, "ma": -0.2, "nbd": 0.5, "ml": -0.25, "d": -0.015873015873015886, "mi": -0.43481324876673694, "fo": 0.6666666666666666, "r": -0.02631578947368421, "e": 0.08658448735902441}
{"project_name": "Closure", "project_version": 167, "label": 2, "code": "private FlowScope caseNameOrGetProp(Node name, FlowScope blindScope, boolean outcome) {\n    JSType type = getTypeIfRefinable(name, blindScope);\n    if (type != null) {\n        JSType restrictedType = type.getRestrictedTypeGivenToBooleanOutcome(outcome);\n        FlowScope informed = blindScope.createChildFlowScope();\n        declareNameInScope(informed, name, restrictedType);\n        return informed;\n    }\n    return blindScope;\n}", "code_comment": NaN, "code_no_comment": "private FlowScope caseNameOrGetProp(Node name, FlowScope blindScope, boolean outcome) {\n    JSType type = getTypeIfRefinable(name, blindScope);\n    if (type != null) {\n        JSType restrictedType = type.getRestrictedTypeGivenToBooleanOutcome(outcome);\n        FlowScope informed = blindScope.createChildFlowScope();\n        declareNameInScope(informed, name, restrictedType);\n        return informed;\n    }\n    return blindScope;\n}", "lc": -0.18181818181818182, "pi": 0.0, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": 0.0079365079365079, "mi": 0.18703312191684296, "fo": -0.16666666666666666, "r": 0.0, "e": -0.04023674095076734}
{"project_name": "Closure", "project_version": 78, "label": 2, "code": "/**\n * Try to fold arithmetic binary operators\n */\nprivate Node performArithmeticOp(int opType, Node left, Node right) {\n    // to Number.\n    if (opType == Token.ADD && (NodeUtil.mayBeString(left, false) || NodeUtil.mayBeString(right, false))) {\n        return null;\n    }\n    double result;\n    // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN\n    // to zero so this is a little akward here.\n    Double lValObj = NodeUtil.getNumberValue(left);\n    if (lValObj == null) {\n        return null;\n    }\n    Double rValObj = NodeUtil.getNumberValue(right);\n    if (rValObj == null) {\n        return null;\n    }\n    double lval = lValObj;\n    double rval = rValObj;\n    switch(opType) {\n        case Token.BITAND:\n            result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);\n            break;\n        case Token.BITOR:\n            result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);\n            break;\n        case Token.BITXOR:\n            result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n            break;\n        case Token.ADD:\n            result = lval + rval;\n            break;\n        case Token.SUB:\n            result = lval - rval;\n            break;\n        case Token.MUL:\n            result = lval * rval;\n            break;\n        case Token.MOD:\n            if (rval == 0) {\n                error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n                return null;\n            }\n            result = lval % rval;\n            break;\n        case Token.DIV:\n            if (rval == 0) {\n                error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n                return null;\n            }\n            result = lval / rval;\n            break;\n        default:\n            throw new Error(\"Unexpected arithmetic operator\");\n    }\n    // length of the left and right value plus 1 byte for the operator.\n    if (String.valueOf(result).length() <= String.valueOf(lval).length() + String.valueOf(rval).length() + 1 && // point, fixed-point math starts to break down and become inaccurate.\n    Math.abs(result) <= MAX_FOLD_NUMBER) {\n        Node newNumber = Node.newNumber(result);\n        return newNumber;\n    } else if (Double.isNaN(result)) {\n        return Node.newString(Token.NAME, \"NaN\");\n    } else if (result == Double.POSITIVE_INFINITY) {\n        return Node.newString(Token.NAME, \"Infinity\");\n    } else if (result == Double.NEGATIVE_INFINITY) {\n        return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n    }\n    return null;\n}", "code_comment": "/**\n * Try to fold arithmetic binary operators\n */\n", "code_no_comment": "private Node performArithmeticOp(int opType, Node left, Node right) {\n        if (opType == Token.ADD && (NodeUtil.mayBeString(left, false) || NodeUtil.mayBeString(right, false))) {\n        return null;\n    }\n    double result;\n            Double lValObj = NodeUtil.getNumberValue(left);\n    if (lValObj == null) {\n        return null;\n    }\n    Double rValObj = NodeUtil.getNumberValue(right);\n    if (rValObj == null) {\n        return null;\n    }\n    double lval = lValObj;\n    double rval = rValObj;\n    switch(opType) {\n        case Token.BITAND:\n            result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);\n            break;\n        case Token.BITOR:\n            result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);\n            break;\n        case Token.BITXOR:\n            result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n            break;\n        case Token.ADD:\n            result = lval + rval;\n            break;\n        case Token.SUB:\n            result = lval - rval;\n            break;\n        case Token.MUL:\n            result = lval * rval;\n            break;\n        case Token.MOD:\n            if (rval == 0) {\n                error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n                return null;\n            }\n            result = lval % rval;\n            break;\n        case Token.DIV:\n            if (rval == 0) {\n                error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n                return null;\n            }\n            result = lval / rval;\n            break;\n        default:\n            throw new Error(\"Unexpected arithmetic operator\");\n    }\n        if (String.valueOf(result).length() <= String.valueOf(lval).length() + String.valueOf(rval).length() + 1 &&     Math.abs(result) <= MAX_FOLD_NUMBER) {\n        Node newNumber = Node.newNumber(result);\n        return newNumber;\n    } else if (Double.isNaN(result)) {\n        return Node.newString(Token.NAME, \"NaN\");\n    } else if (result == Double.POSITIVE_INFINITY) {\n        return Node.newString(Token.NAME, \"Infinity\");\n    } else if (result == Double.NEGATIVE_INFINITY) {\n        return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n    }\n    return null;\n}", "lc": 2.272727272727273, "pi": 0.4928229665071768, "ma": 4.8, "nbd": 1.0, "ml": 2.4166666666666665, "d": 3.486111111111111, "mi": -1.1417899929527833, "fo": 1.6666666666666667, "r": -0.02631578947368421, "e": 10.522890913596468}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5259_a9e56e1e", "label": 1, "code": "/**\n *  Parses the given URL string.\n *\n *  @param _url\n *             absolute or relative url with query string\n *  @param charset\n *  @return Url object\n */\npublic static Url parse(CharSequence _url, Charset charset) {\n    Args.notNull(_url, \"_url\");\n    final Url result = new Url(charset);\n    // the url object resolved the charset, use that\n    charset = result.getCharset();\n    String url = _url.toString();\n    // extract query string part\n    final String queryString;\n    final String absoluteUrl;\n    final int queryAt = url.indexOf('?');\n    if (queryAt == -1) {\n        queryString = \"\";\n        absoluteUrl = url;\n    } else {\n        absoluteUrl = url.substring(0, queryAt);\n        queryString = url.substring(queryAt + 1);\n    }\n    // get absolute / relative part of url\n    String relativeUrl;\n    final int idxOfFirstSlash = absoluteUrl.indexOf('/');\n    final int protocolAt = absoluteUrl.indexOf(\"://\");\n    // full urls start either with a \"scheme://\" or with \"//\"\n    boolean protocolLess = absoluteUrl.startsWith(\"//\");\n    final boolean isFull = (protocolAt > 1 && (protocolAt < idxOfFirstSlash)) || protocolLess;\n    if (isFull) {\n        if (protocolLess == false) {\n            result.protocol = absoluteUrl.substring(0, protocolAt).toLowerCase(Locale.US);\n        }\n        final String afterProto = absoluteUrl.substring(protocolAt + 3);\n        final String hostAndPort;\n        int relativeAt = afterProto.indexOf('/');\n        if (relativeAt == -1) {\n            relativeAt = afterProto.indexOf(';');\n        }\n        if (relativeAt == -1) {\n            relativeUrl = \"\";\n            hostAndPort = afterProto;\n        } else {\n            relativeUrl = afterProto.substring(relativeAt);\n            hostAndPort = afterProto.substring(0, relativeAt);\n        }\n        final int portAt = hostAndPort.lastIndexOf(':');\n        if (portAt == -1) {\n            result.host = hostAndPort;\n            result.port = getDefaultPortForProtocol(result.protocol);\n        } else {\n            result.host = hostAndPort.substring(0, portAt);\n            result.port = Integer.parseInt(hostAndPort.substring(portAt + 1));\n        }\n        if (relativeAt < 0) {\n            relativeUrl = \"/\";\n        }\n    } else {\n        relativeUrl = absoluteUrl;\n    }\n    if (relativeUrl.length() > 0) {\n        boolean removeLast = false;\n        if (relativeUrl.endsWith(\"/\")) {\n            // we need to append something and remove it after splitting\n            // because otherwise the\n            // trailing slashes will be lost\n            relativeUrl += \"/x\";\n            removeLast = true;\n        }\n        String[] segmentArray = Strings.split(relativeUrl, '/');\n        if (removeLast) {\n            segmentArray[segmentArray.length - 1] = null;\n        }\n        for (String s : segmentArray) {\n            if (s != null) {\n                result.segments.add(decodeSegment(s, charset));\n            }\n        }\n    }\n    if (queryString.length() > 0) {\n        String[] queryArray = Strings.split(queryString, '&');\n        for (String s : queryArray) {\n            if (Strings.isEmpty(s) == false) {\n                result.parameters.add(parseQueryParameter(s, charset));\n            }\n        }\n    }\n    return result;\n}", "code_comment": "/**\n *  Parses the given URL string.\n *\n *  @param _url\n *             absolute or relative url with query string\n *  @param charset\n *  @return Url object\n */\n", "code_no_comment": "public static Url parse(CharSequence _url, Charset charset) {\n    Args.notNull(_url, \"_url\");\n    final Url result = new Url(charset);\n        charset = result.getCharset();\n    String url = _url.toString();\n        final String queryString;\n    final String absoluteUrl;\n    final int queryAt = url.indexOf('?');\n    if (queryAt == -1) {\n        queryString = \"\";\n        absoluteUrl = url;\n    } else {\n        absoluteUrl = url.substring(0, queryAt);\n        queryString = url.substring(queryAt + 1);\n    }\n        String relativeUrl;\n    final int idxOfFirstSlash = absoluteUrl.indexOf('/');\n    final int protocolAt = absoluteUrl.indexOf(\"://\");\n        boolean protocolLess = absoluteUrl.startsWith(\"//\");\n    final boolean isFull = (protocolAt > 1 && (protocolAt < idxOfFirstSlash)) || protocolLess;\n    if (isFull) {\n        if (protocolLess == false) {\n            result.protocol = absoluteUrl.substring(0, protocolAt).toLowerCase(Locale.US);\n        }\n        final String afterProto = absoluteUrl.substring(protocolAt + 3);\n        final String hostAndPort;\n        int relativeAt = afterProto.indexOf('/');\n        if (relativeAt == -1) {\n            relativeAt = afterProto.indexOf(';');\n        }\n        if (relativeAt == -1) {\n            relativeUrl = \"\";\n            hostAndPort = afterProto;\n        } else {\n            relativeUrl = afterProto.substring(relativeAt);\n            hostAndPort = afterProto.substring(0, relativeAt);\n        }\n        final int portAt = hostAndPort.lastIndexOf(':');\n        if (portAt == -1) {\n            result.host = hostAndPort;\n            result.port = getDefaultPortForProtocol(result.protocol);\n        } else {\n            result.host = hostAndPort.substring(0, portAt);\n            result.port = Integer.parseInt(hostAndPort.substring(portAt + 1));\n        }\n        if (relativeAt < 0) {\n            relativeUrl = \"/\";\n        }\n    } else {\n        relativeUrl = absoluteUrl;\n    }\n    if (relativeUrl.length() > 0) {\n        boolean removeLast = false;\n        if (relativeUrl.endsWith(\"/\")) {\n                                                relativeUrl += \"/x\";\n            removeLast = true;\n        }\n        String[] segmentArray = Strings.split(relativeUrl, '/');\n        if (removeLast) {\n            segmentArray[segmentArray.length - 1] = null;\n        }\n        for (String s : segmentArray) {\n            if (s != null) {\n                result.segments.add(decodeSegment(s, charset));\n            }\n        }\n    }\n    if (queryString.length() > 0) {\n        String[] queryArray = Strings.split(queryString, '&');\n        for (String s : queryArray) {\n            if (Strings.isEmpty(s) == false) {\n                result.parameters.add(parseQueryParameter(s, charset));\n            }\n        }\n    }\n    return result;\n}", "lc": 2.8636363636363638, "pi": 0.21052631578947367, "ma": 2.4, "nbd": 0.5, "ml": 1.5833333333333333, "d": 2.5972222222222223, "mi": -1.1930937279774485, "fo": 2.0833333333333335, "r": -0.02631578947368421, "e": 10.996658656201193}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-2962_2fd7633f", "label": 0, "code": "@Override\npublic void write(DataOutput out) throws IOException {\n    range.write(out);\n    out.writeInt(locations.length);\n    for (int i = 0; i < locations.length; ++i) out.writeUTF(locations[i]);\n    out.writeBoolean(null != isolatedScan);\n    if (null != isolatedScan) {\n        out.writeBoolean(isolatedScan);\n    }\n    out.writeBoolean(null != offline);\n    if (null != offline) {\n        out.writeBoolean(offline);\n    }\n    out.writeBoolean(null != localIterators);\n    if (null != localIterators) {\n        out.writeBoolean(localIterators);\n    }\n    out.writeBoolean(null != mockInstance);\n    if (null != mockInstance) {\n        out.writeBoolean(mockInstance);\n    }\n    out.writeBoolean(null != fetchedColumns);\n    if (null != fetchedColumns) {\n        String[] cols = InputConfigurator.serializeColumns(fetchedColumns);\n        out.writeInt(cols.length);\n        for (String col : cols) {\n            out.writeUTF(col);\n        }\n    }\n    out.writeBoolean(null != auths);\n    if (null != auths) {\n        out.writeUTF(auths.serialize());\n    }\n    out.writeBoolean(null != principal);\n    if (null != principal) {\n        out.writeUTF(principal);\n    }\n    out.writeBoolean(null != token);\n    if (null != token) {\n        out.writeUTF(token.getClass().getCanonicalName());\n        try {\n            out.writeUTF(CredentialHelper.tokenAsBase64(token));\n        } catch (AccumuloSecurityException e) {\n            throw new IOException(e);\n        }\n    }\n    out.writeBoolean(null != instanceName);\n    if (null != instanceName) {\n        out.writeUTF(instanceName);\n    }\n    out.writeBoolean(null != zooKeepers);\n    if (null != zooKeepers) {\n        out.writeUTF(zooKeepers);\n    }\n    out.writeBoolean(null != level);\n    if (null != level) {\n        out.writeInt(level.toInt());\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void write(DataOutput out) throws IOException {\n    range.write(out);\n    out.writeInt(locations.length);\n    for (int i = 0; i < locations.length; ++i) out.writeUTF(locations[i]);\n    out.writeBoolean(null != isolatedScan);\n    if (null != isolatedScan) {\n        out.writeBoolean(isolatedScan);\n    }\n    out.writeBoolean(null != offline);\n    if (null != offline) {\n        out.writeBoolean(offline);\n    }\n    out.writeBoolean(null != localIterators);\n    if (null != localIterators) {\n        out.writeBoolean(localIterators);\n    }\n    out.writeBoolean(null != mockInstance);\n    if (null != mockInstance) {\n        out.writeBoolean(mockInstance);\n    }\n    out.writeBoolean(null != fetchedColumns);\n    if (null != fetchedColumns) {\n        String[] cols = InputConfigurator.serializeColumns(fetchedColumns);\n        out.writeInt(cols.length);\n        for (String col : cols) {\n            out.writeUTF(col);\n        }\n    }\n    out.writeBoolean(null != auths);\n    if (null != auths) {\n        out.writeUTF(auths.serialize());\n    }\n    out.writeBoolean(null != principal);\n    if (null != principal) {\n        out.writeUTF(principal);\n    }\n    out.writeBoolean(null != token);\n    if (null != token) {\n        out.writeUTF(token.getClass().getCanonicalName());\n        try {\n            out.writeUTF(CredentialHelper.tokenAsBase64(token));\n        } catch (AccumuloSecurityException e) {\n            throw new IOException(e);\n        }\n    }\n    out.writeBoolean(null != instanceName);\n    if (null != instanceName) {\n        out.writeUTF(instanceName);\n    }\n    out.writeBoolean(null != zooKeepers);\n    if (null != zooKeepers) {\n        out.writeUTF(zooKeepers);\n    }\n    out.writeBoolean(null != level);\n    if (null != level) {\n        out.writeInt(level.toInt());\n    }\n}", "lc": 2.0454545454545454, "pi": -0.17703349282296657, "ma": 2.4, "nbd": 0.0, "ml": 1.6666666666666667, "d": 1.130952380952381, "mi": -0.9915433403805494, "fo": 2.25, "r": -0.02631578947368421, "e": 3.099796568754574}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-7018_3244c1e5", "label": 1, "code": "public ModelMBean assemble(MBeanServer mBeanServer, Object obj, ObjectName name) throws JMException {\n    ModelMBeanInfo mbi = null;\n    // prefer to use the managed instance if it has been annotated with JMX annotations\n    if (obj instanceof ManagedInstance) {\n        // there may be a custom embedded instance which have additional methods\n        Object custom = ((ManagedInstance) obj).getInstance();\n        if (custom != null && ObjectHelper.hasAnnotation(custom.getClass().getAnnotations(), ManagedResource.class)) {\n            LOG.trace(\"Assembling MBeanInfo for: {} from custom @ManagedResource object: {}\", name, custom);\n            // get the mbean info from the custom managed object\n            mbi = assembler.getMBeanInfo(obj, custom, name.toString());\n            // and let the custom object be registered in JMX\n            obj = custom;\n        }\n    }\n    if (mbi == null) {\n        // use the default provided mbean which has been annotated with JMX annotations\n        LOG.trace(\"Assembling MBeanInfo for: {} from @ManagedResource object: {}\", name, obj);\n        mbi = assembler.getMBeanInfo(obj, null, name.toString());\n    }\n    if (mbi == null) {\n        return null;\n    }\n    RequiredModelMBean mbean;\n    boolean sanitize = camelContext.getManagementStrategy().getManagementAgent().getMask() != null && camelContext.getManagementStrategy().getManagementAgent().getMask();\n    if (sanitize) {\n        mbean = new MaskRequiredModelMBean(mbi, sanitize);\n    } else {\n        mbean = (RequiredModelMBean) mBeanServer.instantiate(RequiredModelMBean.class.getName());\n        mbean.setModelMBeanInfo(mbi);\n    }\n    try {\n        mbean.setManagedResource(obj, \"ObjectReference\");\n    } catch (InvalidTargetObjectTypeException e) {\n        throw new JMException(e.getMessage());\n    }\n    // Allows the managed object to send notifications\n    if (obj instanceof NotificationSenderAware) {\n        ((NotificationSenderAware) obj).setNotificationSender(new NotificationSenderAdapter(mbean));\n    }\n    return mbean;\n}", "code_comment": NaN, "code_no_comment": "public ModelMBean assemble(MBeanServer mBeanServer, Object obj, ObjectName name) throws JMException {\n    ModelMBeanInfo mbi = null;\n        if (obj instanceof ManagedInstance) {\n                Object custom = ((ManagedInstance) obj).getInstance();\n        if (custom != null && ObjectHelper.hasAnnotation(custom.getClass().getAnnotations(), ManagedResource.class)) {\n            LOG.trace(\"Assembling MBeanInfo for: {} from custom @ManagedResource object: {}\", name, custom);\n                        mbi = assembler.getMBeanInfo(obj, custom, name.toString());\n                        obj = custom;\n        }\n    }\n    if (mbi == null) {\n                LOG.trace(\"Assembling MBeanInfo for: {} from @ManagedResource object: {}\", name, obj);\n        mbi = assembler.getMBeanInfo(obj, null, name.toString());\n    }\n    if (mbi == null) {\n        return null;\n    }\n    RequiredModelMBean mbean;\n    boolean sanitize = camelContext.getManagementStrategy().getManagementAgent().getMask() != null && camelContext.getManagementStrategy().getManagementAgent().getMask();\n    if (sanitize) {\n        mbean = new MaskRequiredModelMBean(mbi, sanitize);\n    } else {\n        mbean = (RequiredModelMBean) mBeanServer.instantiate(RequiredModelMBean.class.getName());\n        mbean.setModelMBeanInfo(mbi);\n    }\n    try {\n        mbean.setManagedResource(obj, \"ObjectReference\");\n    } catch (InvalidTargetObjectTypeException e) {\n        throw new JMException(e.getMessage());\n    }\n        if (obj instanceof NotificationSenderAware) {\n        ((NotificationSenderAware) obj).setNotificationSender(new NotificationSenderAdapter(mbean));\n    }\n    return mbean;\n}", "lc": 0.9545454545454546, "pi": -0.03349282296650732, "ma": 1.0, "nbd": 0.0, "ml": 0.6666666666666666, "d": 0.49603174603174605, "mi": -0.6555320648343901, "fo": 1.3333333333333333, "r": -0.02631578947368421, "e": 1.1539242636422837}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-867_bfbb156d", "label": 1, "code": "/**\n * @param x Normalized objective variables.\n * @return {@code true} if in bounds.\n */\npublic boolean isFeasible(final double[] x) {\n    if (boundaries == null) {\n        return true;\n    }\n    final double[] bLoEnc = encode(boundaries[0]);\n    final double[] bHiEnc = encode(boundaries[1]);\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < bLoEnc[i]) {\n            return false;\n        }\n        if (x[i] > bHiEnc[i]) {\n            return false;\n        }\n    }\n    return true;\n}", "code_comment": "/**\n * @param x Normalized objective variables.\n * @return {@code true} if in bounds.\n */\n", "code_no_comment": "public boolean isFeasible(final double[] x) {\n    if (boundaries == null) {\n        return true;\n    }\n    final double[] bLoEnc = encode(boundaries[0]);\n    final double[] bHiEnc = encode(boundaries[1]);\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < bLoEnc[i]) {\n            return false;\n        }\n        if (x[i] > bHiEnc[i]) {\n            return false;\n        }\n    }\n    return true;\n}", "lc": 0.09090909090909091, "pi": 0.22488038277511951, "ma": 0.2, "nbd": 0.0, "ml": 0.16666666666666666, "d": 0.5138888888888888, "mi": -0.07004933051444676, "fo": -0.3333333333333333, "r": 1.6052631578947367, "e": 0.1754580084484477}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-6667_1fc7bd7a", "label": 1, "code": "/**\n * Prepares the exchange for the next iteration\n *\n * @param exchange the exchange\n * @param index the index of the next iteration\n * @return the exchange to use\n */\nprotected Exchange prepareExchange(Exchange exchange, int index) {\n    if (copy) {\n        // use a copy but let it reuse the same exchange id so it appear as one exchange\n        return ExchangeHelper.createCopy(exchange, true);\n    } else {\n        ExchangeHelper.prepareOutToIn(exchange);\n        return exchange;\n    }\n}", "code_comment": "/**\n * Prepares the exchange for the next iteration\n *\n * @param exchange the exchange\n * @param index the index of the next iteration\n * @return the exchange to use\n */\n", "code_no_comment": "protected Exchange prepareExchange(Exchange exchange, int index) {\n    if (copy) {\n                return ExchangeHelper.createCopy(exchange, true);\n    } else {\n        ExchangeHelper.prepareOutToIn(exchange);\n        return exchange;\n    }\n}", "lc": -0.2727272727272727, "pi": 0.06220095693779899, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": -0.3650793650793651, "mi": 0.44214235377026073, "fo": -0.3333333333333333, "r": 0.1842105263157895, "e": -0.16279340490885932}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-612_df9e6913", "label": 1, "code": "@Override\n@Nonnull\npublic Node addNode(final String relPath, final String primaryNodeTypeName) throws RepositoryException {\n    checkStatus();\n    checkProtected();\n    return sessionDelegate.perform(new SessionOperation<Node>() {\n\n        @Override\n        public Node perform() throws RepositoryException {\n            String oakPath = sessionDelegate.getOakPathKeepIndexOrThrowNotFound(relPath);\n            String oakName = PathUtils.getName(oakPath);\n            String parentPath = sessionDelegate.getOakPath(PathUtils.getParentPath(oakPath));\n            // handle index\n            if (oakName.contains(\"[\")) {\n                throw new RepositoryException(\"Cannot create a new node using a name including an index\");\n            }\n            NodeDelegate parent = dlg.getChild(parentPath);\n            if (parent == null) {\n                // is it a property?\n                String grandParentPath = PathUtils.getParentPath(parentPath);\n                NodeDelegate grandParent = dlg.getChild(grandParentPath);\n                if (grandParent != null) {\n                    String propName = PathUtils.getName(parentPath);\n                    if (grandParent.getProperty(propName) != null) {\n                        throw new ConstraintViolationException(\"Can't add new node to property.\");\n                    }\n                }\n                throw new PathNotFoundException(relPath);\n            }\n            if (parent.getChild(oakName) != null) {\n                throw new ItemExistsException(relPath);\n            }\n            String ntName = primaryNodeTypeName;\n            if (ntName == null) {\n                DefinitionProvider dp = sessionDelegate.getDefinitionProvider();\n                try {\n                    String childName = sessionDelegate.getOakName(PathUtils.getName(relPath));\n                    NodeDefinition def = dp.getDefinition(new NodeImpl<NodeDelegate>(parent), childName);\n                    ntName = def.getDefaultPrimaryTypeName();\n                } catch (RepositoryException e) {\n                    throw new ConstraintViolationException(\"no matching child node definition found for \" + relPath);\n                }\n            }\n            // TODO: figure out the right place for this check\n            NodeTypeManager ntm = sessionDelegate.getNodeTypeManager();\n            // throws on not found\n            NodeType nt = ntm.getNodeType(ntName);\n            if (nt.isAbstract() || nt.isMixin()) {\n                throw new ConstraintViolationException();\n            }\n            // TODO: END\n            NodeDelegate added = parent.addChild(oakName);\n            if (added == null) {\n                throw new ItemExistsException();\n            }\n            NodeImpl<?> childNode = new NodeImpl<NodeDelegate>(added);\n            childNode.internalSetPrimaryType(ntName);\n            childNode.autoCreateItems();\n            return childNode;\n        }\n    });\n}", "code_comment": NaN, "code_no_comment": "@Override\n@Nonnull\npublic Node addNode(final String relPath, final String primaryNodeTypeName) throws RepositoryException {\n    checkStatus();\n    checkProtected();\n    return sessionDelegate.perform(new SessionOperation<Node>() {\n\n        @Override\n        public Node perform() throws RepositoryException {\n            String oakPath = sessionDelegate.getOakPathKeepIndexOrThrowNotFound(relPath);\n            String oakName = PathUtils.getName(oakPath);\n            String parentPath = sessionDelegate.getOakPath(PathUtils.getParentPath(oakPath));\n                        if (oakName.contains(\"[\")) {\n                throw new RepositoryException(\"Cannot create a new node using a name including an index\");\n            }\n            NodeDelegate parent = dlg.getChild(parentPath);\n            if (parent == null) {\n                                String grandParentPath = PathUtils.getParentPath(parentPath);\n                NodeDelegate grandParent = dlg.getChild(grandParentPath);\n                if (grandParent != null) {\n                    String propName = PathUtils.getName(parentPath);\n                    if (grandParent.getProperty(propName) != null) {\n                        throw new ConstraintViolationException(\"Can't add new node to property.\");\n                    }\n                }\n                throw new PathNotFoundException(relPath);\n            }\n            if (parent.getChild(oakName) != null) {\n                throw new ItemExistsException(relPath);\n            }\n            String ntName = primaryNodeTypeName;\n            if (ntName == null) {\n                DefinitionProvider dp = sessionDelegate.getDefinitionProvider();\n                try {\n                    String childName = sessionDelegate.getOakName(PathUtils.getName(relPath));\n                    NodeDefinition def = dp.getDefinition(new NodeImpl<NodeDelegate>(parent), childName);\n                    ntName = def.getDefaultPrimaryTypeName();\n                } catch (RepositoryException e) {\n                    throw new ConstraintViolationException(\"no matching child node definition found for \" + relPath);\n                }\n            }\n                        NodeTypeManager ntm = sessionDelegate.getNodeTypeManager();\n                        NodeType nt = ntm.getNodeType(ntName);\n            if (nt.isAbstract() || nt.isMixin()) {\n                throw new ConstraintViolationException();\n            }\n                        NodeDelegate added = parent.addChild(oakName);\n            if (added == null) {\n                throw new ItemExistsException();\n            }\n            NodeImpl<?> childNode = new NodeImpl<NodeDelegate>(added);\n            childNode.internalSetPrimaryType(ntName);\n            childNode.autoCreateItems();\n            return childNode;\n        }\n    });\n}", "lc": 1.9090909090909092, "pi": 1.1770334928229667, "ma": 2.6, "nbd": 1.0, "ml": 1.25, "d": 0.5337301587301588, "mi": -0.9881606765327691, "fo": 1.6666666666666667, "r": -0.02631578947368421, "e": 1.993826754954674}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1199_813109d7", "label": 3, "code": "@Override\npublic void read(org.apache.thrift.protocol.TProtocol prot, setTableProperty_result struct) throws org.apache.thrift.TException {\n    TTupleProtocol iprot = (TTupleProtocol) prot;\n    BitSet incoming = iprot.readBitSet(2);\n    if (incoming.get(0)) {\n        struct.ouch1 = new AccumuloException();\n        struct.ouch1.read(iprot);\n        struct.setOuch1IsSet(true);\n    }\n    if (incoming.get(1)) {\n        struct.ouch2 = new AccumuloSecurityException();\n        struct.ouch2.read(iprot);\n        struct.setOuch2IsSet(true);\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void read(org.apache.thrift.protocol.TProtocol prot, setTableProperty_result struct) throws org.apache.thrift.TException {\n    TTupleProtocol iprot = (TTupleProtocol) prot;\n    BitSet incoming = iprot.readBitSet(2);\n    if (incoming.get(0)) {\n        struct.ouch1 = new AccumuloException();\n        struct.ouch1.read(iprot);\n        struct.setOuch1IsSet(true);\n    }\n    if (incoming.get(1)) {\n        struct.ouch2 = new AccumuloSecurityException();\n        struct.ouch2.read(iprot);\n        struct.setOuch2IsSet(true);\n    }\n}", "lc": 0.045454545454545456, "pi": 0.0, "ma": -0.2, "nbd": -0.5, "ml": -0.08333333333333333, "d": -0.3650793650793651, "mi": -0.09485553206483423, "fo": 0.08333333333333333, "r": -0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-393_d4b02f6a", "label": 3, "code": "/**\n * Find an optimum in the given interval.\n * <p>\n * An optimizer may require that the interval brackets a single optimum.\n * </p>\n * @param f the function to optimize.\n * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}\n * or {@link GoalType#MINIMIZE}\n * @param min the lower bound for the interval.\n * @param max the upper bound for the interval.\n * @return a value where the function is optimum\n * @throws ConvergenceException if the maximum iteration count is exceeded\n * or the optimizer detects convergence problems otherwise.\n * @throws FunctionEvaluationException if an error occurs evaluating the\n * function\n * @throws IllegalArgumentException if min > max or the endpoints do not\n * satisfy the requirements specified by the optimizer\n */\ndouble optimize(UnivariateRealFunction f, GoalType goalType, double min, double max) throws ConvergenceException, FunctionEvaluationException;", "code_comment": "/**\n * Find an optimum in the given interval.\n * <p>\n * An optimizer may require that the interval brackets a single optimum.\n * </p>\n * @param f the function to optimize.\n * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}\n * or {@link GoalType#MINIMIZE}\n * @param min the lower bound for the interval.\n * @param max the upper bound for the interval.\n * @return a value where the function is optimum\n * @throws ConvergenceException if the maximum iteration count is exceeded\n * or the optimizer detects convergence problems otherwise.\n * @throws FunctionEvaluationException if an error occurs evaluating the\n * function\n * @throws IllegalArgumentException if min > max or the endpoints do not\n * satisfy the requirements specified by the optimizer\n */\n", "code_no_comment": "double optimize(UnivariateRealFunction f, GoalType goalType, double min, double max) throws ConvergenceException, FunctionEvaluationException;", "lc": -0.5909090909090909, "pi": -1.4306220095693782, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.457505285412262, "fo": -0.5, "r": 0.1842105263157895, "e": -0.16279340490885932}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4030_5f69685d", "label": 3, "code": "/**\n *  @param location\n *  @return relative path\n */\nprivate String relative(final String location) {\n    Args.notEmpty(location, \"location\");\n    if (location.startsWith(\"http://\") || location.startsWith(\"https://\") || location.startsWith(\"/\")) {\n        return location;\n    }\n    RequestCycle rc = RequestCycle.get();\n    return rc.getUrlRenderer().renderUrl(Url.parse(location, rc.getRequest().getCharset()));\n}", "code_comment": "/**\n *  @param location\n *  @return relative path\n */\n", "code_no_comment": "private String relative(final String location) {\n    Args.notEmpty(location, \"location\");\n    if (location.startsWith(\"http://\") || location.startsWith(\"https://\") || location.startsWith(\"/\")) {\n        return location;\n    }\n    RequestCycle rc = RequestCycle.get();\n    return rc.getUrlRenderer().renderUrl(Url.parse(location, rc.getRequest().getCharset()));\n}", "lc": -0.2727272727272727, "pi": -0.2822966507177035, "ma": -0.4, "nbd": -0.5, "ml": 0.08333333333333333, "d": -0.03174603174603177, "mi": 0.28118393234672284, "fo": 0.3333333333333333, "r": 0.05263157894736841, "e": -0.046834137261342876}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-373_bfe4623c", "label": 1, "code": "/**\n * {@inheritDoc}\n */\n@Override\npublic void increment(final double d) {\n    if (n == 0) {\n        value = d * d;\n    } else {\n        value += d * d;\n    }\n    n++;\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "@Override\npublic void increment(final double d) {\n    if (n == 0) {\n        value = d * d;\n    } else {\n        value += d * d;\n    }\n    n++;\n}", "lc": -0.22727272727272727, "pi": -0.01913875598086126, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": 0.371031746031746, "mi": 0.3423537702607468, "fo": -0.5, "r": 2.5789473684210527, "e": -0.046151806965070916}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-43_668f08f2", "label": 1, "code": "public void addNode(String parentNodePath, String nodeName, Map<String, String> properties) throws Exception {\n    MutableNode modParent = getOrCreateStagedNode(parentNodePath);\n    if (modParent.getChildNodeEntry(nodeName) != null) {\n        throw new Exception(\"there's already a child node with name '\" + nodeName + \"'\");\n    }\n    String newPath = PathUtils.concat(parentNodePath, nodeName);\n    MutableNode newChild = new MutableNode(store, newPath);\n    newChild.getProperties().putAll(properties);\n    // id will be computed on commit\n    modParent.add(new ChildNode(nodeName, null));\n    staged.put(newPath, newChild);\n    // update change log\n    changeLog.add(new AddNode(parentNodePath, nodeName, properties));\n}", "code_comment": NaN, "code_no_comment": "public void addNode(String parentNodePath, String nodeName, Map<String, String> properties) throws Exception {\n    MutableNode modParent = getOrCreateStagedNode(parentNodePath);\n    if (modParent.getChildNodeEntry(nodeName) != null) {\n        throw new Exception(\"there's already a child node with name '\" + nodeName + \"'\");\n    }\n    String newPath = PathUtils.concat(parentNodePath, nodeName);\n    MutableNode newChild = new MutableNode(store, newPath);\n    newChild.getProperties().putAll(properties);\n        modParent.add(new ChildNode(nodeName, null));\n    staged.put(newPath, newChild);\n        changeLog.add(new AddNode(parentNodePath, nodeName, properties));\n}", "lc": -0.09090909090909091, "pi": -0.4880382775119619, "ma": -0.2, "nbd": -0.5, "ml": -0.16666666666666666, "d": 0.009920634920634885, "mi": -0.006342494714587576, "fo": 0.16666666666666666, "r": -0.02631578947368421, "e": 0.08796297897108737}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1174_342809f7", "label": 3, "code": "/**\n * Parse the specified jcr name and inform the specified {@code listener}\n * about the result or any error that may occur during parsing.\n *\n * @param jcrName The jcr name to be parsed.\n * @param listener The listener to be informed about success or failure.\n * @param index index, or {@code 0} when not specified\n * @return whether parsing was successful\n */\npublic static boolean parse(String jcrName, Listener listener, int index) {\n    // trivial check\n    int len = jcrName == null ? 0 : jcrName.length();\n    if (len == 0) {\n        listener.error(\"Empty name\");\n        return false;\n    }\n    if (\".\".equals(jcrName) || \"..\".equals(jcrName)) {\n        listener.error(\"Illegal name:\" + jcrName);\n        return false;\n    }\n    // parse the name\n    String prefix;\n    int nameStart = 0;\n    int state = STATE_PREFIX_START;\n    boolean trailingSpaces = false;\n    for (int i = 0; i < len; i++) {\n        char c = jcrName.charAt(i);\n        if (c == ':') {\n            if (state == STATE_PREFIX_START) {\n                listener.error(\"Prefix must not be empty\");\n                return false;\n            } else if (state == STATE_PREFIX) {\n                if (trailingSpaces) {\n                    listener.error(\"Trailing spaces not allowed\");\n                    return false;\n                }\n                prefix = jcrName.substring(0, i);\n                if (!XMLChar.isValidNCName(prefix)) {\n                    listener.error(\"Invalid name prefix: \" + prefix);\n                    return false;\n                }\n                state = STATE_NAME_START;\n            } else if (state == STATE_URI) {\n            // ignore -> validation of uri later on.\n            } else {\n                listener.error(\"'\" + c + \"' not allowed in name\");\n                return false;\n            }\n            trailingSpaces = false;\n        } else if (c == ' ') {\n            if (state == STATE_PREFIX_START || state == STATE_NAME_START) {\n                listener.error(\"'\" + c + \"' not valid name start\");\n                return false;\n            }\n            trailingSpaces = true;\n        } else if (Character.isWhitespace(c) || c == '[' || c == ']' || c == '*' || c == '|') {\n            listener.error(\"'\" + c + \"' not allowed in name\");\n            return false;\n        } else if (c == '/') {\n            if (state == STATE_URI_START) {\n                state = STATE_URI;\n            } else if (state != STATE_URI) {\n                listener.error(\"'\" + c + \"' not allowed in name\");\n                return false;\n            }\n            trailingSpaces = false;\n        } else if (c == '{') {\n            if (state == STATE_PREFIX_START) {\n                state = STATE_URI_START;\n            } else if (state == STATE_URI_START || state == STATE_URI) {\n                // second '{' in the uri-part -> no valid expanded jcr-name.\n                // therefore reset the nameStart and change state.\n                state = STATE_NAME;\n                nameStart = 0;\n            } else if (state == STATE_NAME_START) {\n                state = STATE_NAME;\n                nameStart = i;\n            }\n            trailingSpaces = false;\n        } else if (c == '}') {\n            if (state == STATE_URI_START || state == STATE_URI) {\n                String tmp = jcrName.substring(1, i);\n                if (tmp.isEmpty() || tmp.indexOf(':') != -1) {\n                    // The leading \"{...}\" part is empty or contains\n                    // a colon, so we treat it as a valid namespace URI.\n                    // More detailed validity checks (is it well formed,\n                    // registered, etc.) are not needed here.\n                    state = STATE_NAME_START;\n                } else if (tmp.equals(\"internal\")) {\n                    // As a special Jackrabbit backwards compatibility\n                    // feature, support {internal} as a valid URI prefix\n                    state = STATE_NAME_START;\n                } else if (tmp.indexOf('/') == -1) {\n                    // The leading \"{...}\" contains neither a colon nor\n                    // a slash, so we can interpret it as a a part of a\n                    // normal local name.\n                    state = STATE_NAME;\n                    nameStart = 0;\n                } else {\n                    listener.error(\"The URI prefix of the name \" + jcrName + \" is \" + \"neither a valid URI nor a valid part of a local name.\");\n                    return false;\n                }\n            } else if (state == STATE_PREFIX_START) {\n                // prefix start -> validation later on will fail.\n                state = STATE_PREFIX;\n            } else if (state == STATE_NAME_START) {\n                state = STATE_NAME;\n                nameStart = i;\n            }\n            trailingSpaces = false;\n        } else {\n            if (state == STATE_PREFIX_START) {\n                // prefix start\n                state = STATE_PREFIX;\n            } else if (state == STATE_NAME_START) {\n                state = STATE_NAME;\n                nameStart = i;\n            } else if (state == STATE_URI_START) {\n                state = STATE_URI;\n            }\n            trailingSpaces = false;\n        }\n    }\n    // a terminating '}' -> make sure there are no illegal characters present.\n    if (state == STATE_URI && (jcrName.indexOf(':') > -1 || jcrName.indexOf('/') > -1)) {\n        listener.error(\"Local name may not contain ':' nor '/'\");\n        return false;\n    }\n    if (nameStart == len || state == STATE_NAME_START) {\n        listener.error(\"Local name must not be empty\");\n        return false;\n    }\n    if (trailingSpaces) {\n        listener.error(\"Trailing spaces not allowed\");\n        return false;\n    }\n    return listener.name(jcrName, index);\n}", "code_comment": "/**\n * Parse the specified jcr name and inform the specified {@code listener}\n * about the result or any error that may occur during parsing.\n *\n * @param jcrName The jcr name to be parsed.\n * @param listener The listener to be informed about success or failure.\n * @param index index, or {@code 0} when not specified\n * @return whether parsing was successful\n */\n", "code_no_comment": "public static boolean parse(String jcrName, Listener listener, int index) {\n        int len = jcrName == null ? 0 : jcrName.length();\n    if (len == 0) {\n        listener.error(\"Empty name\");\n        return false;\n    }\n    if (\".\".equals(jcrName) || \"..\".equals(jcrName)) {\n        listener.error(\"Illegal name:\" + jcrName);\n        return false;\n    }\n        String prefix;\n    int nameStart = 0;\n    int state = STATE_PREFIX_START;\n    boolean trailingSpaces = false;\n    for (int i = 0; i < len; i++) {\n        char c = jcrName.charAt(i);\n        if (c == ':') {\n            if (state == STATE_PREFIX_START) {\n                listener.error(\"Prefix must not be empty\");\n                return false;\n            } else if (state == STATE_PREFIX) {\n                if (trailingSpaces) {\n                    listener.error(\"Trailing spaces not allowed\");\n                    return false;\n                }\n                prefix = jcrName.substring(0, i);\n                if (!XMLChar.isValidNCName(prefix)) {\n                    listener.error(\"Invalid name prefix: \" + prefix);\n                    return false;\n                }\n                state = STATE_NAME_START;\n            } else if (state == STATE_URI) {\n                        } else {\n                listener.error(\"'\" + c + \"' not allowed in name\");\n                return false;\n            }\n            trailingSpaces = false;\n        } else if (c == ' ') {\n            if (state == STATE_PREFIX_START || state == STATE_NAME_START) {\n                listener.error(\"'\" + c + \"' not valid name start\");\n                return false;\n            }\n            trailingSpaces = true;\n        } else if (Character.isWhitespace(c) || c == '[' || c == ']' || c == '*' || c == '|') {\n            listener.error(\"'\" + c + \"' not allowed in name\");\n            return false;\n        } else if (c == '/') {\n            if (state == STATE_URI_START) {\n                state = STATE_URI;\n            } else if (state != STATE_URI) {\n                listener.error(\"'\" + c + \"' not allowed in name\");\n                return false;\n            }\n            trailingSpaces = false;\n        } else if (c == '{') {\n            if (state == STATE_PREFIX_START) {\n                state = STATE_URI_START;\n            } else if (state == STATE_URI_START || state == STATE_URI) {\n                                                state = STATE_NAME;\n                nameStart = 0;\n            } else if (state == STATE_NAME_START) {\n                state = STATE_NAME;\n                nameStart = i;\n            }\n            trailingSpaces = false;\n        } else if (c == '}') {\n            if (state == STATE_URI_START || state == STATE_URI) {\n                String tmp = jcrName.substring(1, i);\n                if (tmp.isEmpty() || tmp.indexOf(':') != -1) {\n                                                                                                    state = STATE_NAME_START;\n                } else if (tmp.equals(\"internal\")) {\n                                                            state = STATE_NAME_START;\n                } else if (tmp.indexOf('/') == -1) {\n                                                                                state = STATE_NAME;\n                    nameStart = 0;\n                } else {\n                    listener.error(\"The URI prefix of the name \" + jcrName + \" is \" + \"neither a valid URI nor a valid part of a local name.\");\n                    return false;\n                }\n            } else if (state == STATE_PREFIX_START) {\n                                state = STATE_PREFIX;\n            } else if (state == STATE_NAME_START) {\n                state = STATE_NAME;\n                nameStart = i;\n            }\n            trailingSpaces = false;\n        } else {\n            if (state == STATE_PREFIX_START) {\n                                state = STATE_PREFIX;\n            } else if (state == STATE_NAME_START) {\n                state = STATE_NAME;\n                nameStart = i;\n            } else if (state == STATE_URI_START) {\n                state = STATE_URI;\n            }\n            trailingSpaces = false;\n        }\n    }\n        if (state == STATE_URI && (jcrName.indexOf(':') > -1 || jcrName.indexOf('/') > -1)) {\n        listener.error(\"Local name may not contain ':' nor '/'\");\n        return false;\n    }\n    if (nameStart == len || state == STATE_NAME_START) {\n        listener.error(\"Local name must not be empty\");\n        return false;\n    }\n    if (trailingSpaces) {\n        listener.error(\"Trailing spaces not allowed\");\n        return false;\n    }\n    return listener.name(jcrName, index);\n}", "lc": 4.454545454545454, "pi": 1.0047846889952152, "ma": 6.0, "nbd": 4.5, "ml": 4.833333333333333, "d": 3.6507936507936507, "mi": -1.5234672304439743, "fo": 1.8333333333333333, "r": -0.02631578947368421, "e": 20.057216622580288}
{"project_name": "Closure", "project_version": 136, "label": 2, "code": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() != Token.NAME) {\n        return;\n    }\n    String name = n.getString();\n    // Ignore anonymous functions\n    if (name.length() == 0) {\n        return;\n    }\n    // Is this local or Global?\n    Scope.Var var = t.getScope().getVar(name);\n    boolean local = (var != null) && var.isLocal();\n    // Are we renaming global variables?\n    if (!local && localRenamingOnly) {\n        reservedNames.add(name);\n        return;\n    }\n    // Are we renaming anonymous function names?\n    if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n        reservedNames.add(name);\n        return;\n    }\n    // Check if we can rename this.\n    if (!okToRenameVar(name, local)) {\n        // Blindly de-uniquify for the Prototype library for issue 103.\n        return;\n    }\n    if (isExternsPass_) {\n        // Keep track of extern globals.\n        if (!local) {\n            externNames.add(name);\n        }\n        return;\n    }\n    if (local) {\n        // Local var: assign a new name\n        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n        incCount(tempName, null);\n        localNameNodes.add(n);\n        localTempNames.add(tempName);\n    } else if (var != null) {\n        // Not an extern\n        // If it's global, increment global count\n        incCount(name, var.input);\n        globalNameNodes.add(n);\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() != Token.NAME) {\n        return;\n    }\n    String name = n.getString();\n        if (name.length() == 0) {\n        return;\n    }\n        Scope.Var var = t.getScope().getVar(name);\n    boolean local = (var != null) && var.isLocal();\n        if (!local && localRenamingOnly) {\n        reservedNames.add(name);\n        return;\n    }\n        if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n        reservedNames.add(name);\n        return;\n    }\n        if (!okToRenameVar(name, local)) {\n                return;\n    }\n    if (isExternsPass_) {\n                if (!local) {\n            externNames.add(name);\n        }\n        return;\n    }\n    if (local) {\n                String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n        incCount(tempName, null);\n        localNameNodes.add(n);\n        localTempNames.add(tempName);\n    } else if (var != null) {\n                        incCount(name, var.input);\n        globalNameNodes.add(n);\n    }\n}", "lc": 1.0909090909090908, "pi": -0.14832535885167467, "ma": 1.2, "nbd": 0.0, "ml": 1.5, "d": 0.753968253968254, "mi": -0.669626497533474, "fo": 1.0, "r": -0.02631578947368421, "e": 1.232041861885744}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2330_408a566e", "label": 3, "code": "private boolean indexProperty(String path, List<Field> fields, NodeState state, PropertyState property, String pname, boolean aggregateMode, PropertyDefinition pd) throws CommitFailedException {\n    boolean includeTypeForFullText = indexingRule.includePropertyType(property.getType().tag());\n    if (Type.BINARY.tag() == property.getType().tag() && includeTypeForFullText) {\n        this.context.indexUpdate();\n        fields.addAll(newBinary(property, state, null, path + \"@\" + pname));\n        return true;\n    } else {\n        boolean dirty = false;\n        if (pd.propertyIndex && pd.includePropertyType(property.getType().tag())) {\n            dirty |= addTypedFields(fields, property, pname);\n        }\n        if (pd.fulltextEnabled() && includeTypeForFullText) {\n            for (String value : property.getValue(Type.STRINGS)) {\n                this.context.indexUpdate();\n                if (pd.analyzed && pd.includePropertyType(property.getType().tag())) {\n                    String analyzedPropName = constructAnalyzedPropertyName(pname);\n                    fields.add(newPropertyField(analyzedPropName, value, !pd.skipTokenization(pname), pd.stored));\n                }\n                if (pd.nodeScopeIndex && !aggregateMode) {\n                    Field field = newFulltextField(value);\n                    field.setBoost(pd.boost);\n                    fields.add(field);\n                }\n                dirty = true;\n            }\n        }\n        return dirty;\n    }\n}", "code_comment": NaN, "code_no_comment": "private boolean indexProperty(String path, List<Field> fields, NodeState state, PropertyState property, String pname, boolean aggregateMode, PropertyDefinition pd) throws CommitFailedException {\n    boolean includeTypeForFullText = indexingRule.includePropertyType(property.getType().tag());\n    if (Type.BINARY.tag() == property.getType().tag() && includeTypeForFullText) {\n        this.context.indexUpdate();\n        fields.addAll(newBinary(property, state, null, path + \"@\" + pname));\n        return true;\n    } else {\n        boolean dirty = false;\n        if (pd.propertyIndex && pd.includePropertyType(property.getType().tag())) {\n            dirty |= addTypedFields(fields, property, pname);\n        }\n        if (pd.fulltextEnabled() && includeTypeForFullText) {\n            for (String value : property.getValue(Type.STRINGS)) {\n                this.context.indexUpdate();\n                if (pd.analyzed && pd.includePropertyType(property.getType().tag())) {\n                    String analyzedPropName = constructAnalyzedPropertyName(pname);\n                    fields.add(newPropertyField(analyzedPropName, value, !pd.skipTokenization(pname), pd.stored));\n                }\n                if (pd.nodeScopeIndex && !aggregateMode) {\n                    Field field = newFulltextField(value);\n                    field.setBoost(pd.boost);\n                    fields.add(field);\n                }\n                dirty = true;\n            }\n        }\n        return dirty;\n    }\n}", "lc": 0.6818181818181818, "pi": 1.4832535885167464, "ma": 0.6, "nbd": 1.0, "ml": 1.1666666666666667, "d": 0.8849206349206349, "mi": -0.5650458069062719, "fo": 1.6666666666666667, "r": -0.02631578947368421, "e": 1.8613117569428832}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-757_76b7413d", "label": 1, "code": "/**\n * Sets the contraction criteria.\n *\n * @param contractionCriteria contraction criteria\n * @throws MathIllegalArgumentException if the contractionCriteria is less than\n *         the expansionCriteria.\n * @deprecated As of 3.1 (to be removed in 4.0 as field will become \"final\").\n */\n@Deprecated\npublic void setContractionCriteria(float contractionCriteria) throws MathIllegalArgumentException {\n    checkContractExpand(contractionCriteria, getExpansionFactor());\n    synchronized (this) {\n        this.contractionCriterion = contractionCriteria;\n    }\n}", "code_comment": "/**\n * Sets the contraction criteria.\n *\n * @param contractionCriteria contraction criteria\n * @throws MathIllegalArgumentException if the contractionCriteria is less than\n *         the expansionCriteria.\n * @deprecated As of 3.1 (to be removed in 4.0 as field will become \"final\").\n */\n", "code_no_comment": "@Deprecated\npublic void setContractionCriteria(float contractionCriteria) throws MathIllegalArgumentException {\n    checkContractExpand(contractionCriteria, getExpansionFactor());\n    synchronized (this) {\n        this.contractionCriterion = contractionCriteria;\n    }\n}", "lc": -0.3181818181818182, "pi": -0.0909090909090911, "ma": -0.6, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.5619450317124735, "fo": -0.3333333333333333, "r": 2.026315789473684, "e": -0.16279340490885932}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-7167_1e33fcbc", "label": 3, "code": "/**\n * Common work which must be done when we are done multicasting.\n * <p/>\n * This logic applies for both running synchronous and asynchronous as there are multiple exist points\n * when using the asynchronous routing engine. And therefore we want the logic in one method instead\n * of being scattered.\n *\n * @param original     the original exchange\n * @param subExchange  the current sub exchange, can be <tt>null</tt> for the synchronous part\n * @param pairs        the pairs with the exchanges to process\n * @param callback     the callback\n * @param doneSync     the <tt>doneSync</tt> parameter to call on callback\n * @param forceExhaust whether or not error handling is exhausted\n */\nprotected void doDone(Exchange original, Exchange subExchange, final Iterable<ProcessorExchangePair> pairs, AsyncCallback callback, boolean doneSync, boolean forceExhaust) {\n    // we are done so close the pairs iterator\n    if (pairs != null && pairs instanceof Closeable) {\n        IOHelper.close((Closeable) pairs, \"pairs\", LOG);\n    }\n    // cleanup any per exchange aggregation strategy\n    removeAggregationStrategyFromExchange(original);\n    // we need to know if there was an exception, and if the stopOnException option was enabled\n    // also we would need to know if any error handler has attempted redelivery and exhausted\n    boolean stoppedOnException = false;\n    boolean exception = false;\n    boolean exhaust = forceExhaust || subExchange != null && (subExchange.getException() != null || ExchangeHelper.isRedeliveryExhausted(subExchange));\n    if (original.getException() != null || subExchange != null && subExchange.getException() != null) {\n        // there was an exception and we stopped\n        stoppedOnException = isStopOnException();\n        exception = true;\n    }\n    // must copy results at this point\n    if (subExchange != null) {\n        if (stoppedOnException) {\n            // if we stopped due an exception then only propagte the exception\n            original.setException(subExchange.getException());\n        } else {\n            // copy the current result to original so it will contain this result of this eip\n            ExchangeHelper.copyResults(original, subExchange);\n        }\n    }\n    // handled has been in use, then the exhaust would be false (if not forced)\n    if (exception) {\n        // multicast uses error handling on its output processors and they have tried to redeliver\n        // so we shall signal back to the other error handlers that we are exhausted and they should not\n        // also try to redeliver as we will then do that twice\n        original.setProperty(Exchange.REDELIVERY_EXHAUSTED, exhaust);\n    }\n    callback.done(doneSync);\n}", "code_comment": "/**\n * Common work which must be done when we are done multicasting.\n * <p/>\n * This logic applies for both running synchronous and asynchronous as there are multiple exist points\n * when using the asynchronous routing engine. And therefore we want the logic in one method instead\n * of being scattered.\n *\n * @param original     the original exchange\n * @param subExchange  the current sub exchange, can be <tt>null</tt> for the synchronous part\n * @param pairs        the pairs with the exchanges to process\n * @param callback     the callback\n * @param doneSync     the <tt>doneSync</tt> parameter to call on callback\n * @param forceExhaust whether or not error handling is exhausted\n */\n", "code_no_comment": "protected void doDone(Exchange original, Exchange subExchange, final Iterable<ProcessorExchangePair> pairs, AsyncCallback callback, boolean doneSync, boolean forceExhaust) {\n        if (pairs != null && pairs instanceof Closeable) {\n        IOHelper.close((Closeable) pairs, \"pairs\", LOG);\n    }\n        removeAggregationStrategyFromExchange(original);\n            boolean stoppedOnException = false;\n    boolean exception = false;\n    boolean exhaust = forceExhaust || subExchange != null && (subExchange.getException() != null || ExchangeHelper.isRedeliveryExhausted(subExchange));\n    if (original.getException() != null || subExchange != null && subExchange.getException() != null) {\n                stoppedOnException = isStopOnException();\n        exception = true;\n    }\n        if (subExchange != null) {\n        if (stoppedOnException) {\n                        original.setException(subExchange.getException());\n        } else {\n                        ExchangeHelper.copyResults(original, subExchange);\n        }\n    }\n        if (exception) {\n                                original.setProperty(Exchange.REDELIVERY_EXHAUSTED, exhaust);\n    }\n    callback.done(doneSync);\n}", "lc": 0.45454545454545453, "pi": 0.009569377990430419, "ma": 0.4, "nbd": 0.0, "ml": 0.75, "d": 0.5158730158730159, "mi": -0.4114164904862578, "fo": 0.5, "r": -0.02631578947368421, "e": 0.7785457835560702}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-8592_57f72cd9", "label": 3, "code": "@SuppressWarnings(\"unchecked\")\npublic void onCompletion(Exchange exchange) {\n    if (isStoreAsBodyOnCompletion()) {\n        List<V> list = (List<V>) exchange.removeProperty(Exchange.GROUPED_EXCHANGE);\n        if (list != null) {\n            exchange.getIn().setBody(list);\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "@SuppressWarnings(\"unchecked\")\npublic void onCompletion(Exchange exchange) {\n    if (isStoreAsBodyOnCompletion()) {\n        List<V> list = (List<V>) exchange.removeProperty(Exchange.GROUPED_EXCHANGE);\n        if (list != null) {\n            exchange.getIn().setBody(list);\n        }\n    }\n}", "lc": -0.22727272727272727, "pi": 0.5406698564593301, "ma": -0.2, "nbd": 0.0, "ml": -0.08333333333333333, "d": -0.07341269841269843, "mi": 0.2825933756166315, "fo": -0.16666666666666666, "r": 0.8157894736842105, "e": -0.09645983529560923}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-1820_39d526e6", "label": 0, "code": "/**\n *  Static utility to parse a field of type double from a byte sequence that represents text characters\n *  (such as when read from a file stream).\n *\n *  @param bytes The bytes containing the text data that should be parsed.\n *  @param startPos The offset to start the parsing.\n *  @param length The length of the byte sequence (counting from the offset).\n *  @param delimiter The delimiter that terminates the field.\n *\n *  @return The parsed value.\n *\n *  @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\n */\npublic static final double parseField(byte[] bytes, int startPos, int length, char delimiter) {\n    if (length <= 0) {\n        throw new NumberFormatException(\"Invalid input: Empty string\");\n    }\n    int i = 0;\n    final byte delByte = (byte) delimiter;\n    while (i < length && bytes[i] != delByte) {\n        i++;\n    }\n    String str = new String(bytes, startPos, i);\n    return Double.parseDouble(str);\n}", "code_comment": "/**\n *  Static utility to parse a field of type double from a byte sequence that represents text characters\n *  (such as when read from a file stream).\n *\n *  @param bytes The bytes containing the text data that should be parsed.\n *  @param startPos The offset to start the parsing.\n *  @param length The length of the byte sequence (counting from the offset).\n *  @param delimiter The delimiter that terminates the field.\n *\n *  @return The parsed value.\n *\n *  @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\n */\n", "code_no_comment": "public static final double parseField(byte[] bytes, int startPos, int length, char delimiter) {\n    if (length <= 0) {\n        throw new NumberFormatException(\"Invalid input: Empty string\");\n    }\n    int i = 0;\n    final byte delByte = (byte) delimiter;\n    while (i < length && bytes[i] != delByte) {\n        i++;\n    }\n    String str = new String(bytes, startPos, i);\n    return Double.parseDouble(str);\n}", "lc": -0.09090909090909091, "pi": -0.32535885167464124, "ma": 0.0, "nbd": -0.5, "ml": 0.08333333333333333, "d": 0.7857142857142857, "mi": 0.07061310782241001, "fo": -0.4166666666666667, "r": 0.13157894736842105, "e": 0.2717726180391072}
{"project_name": "Compress", "project_version": 17, "label": 1, "code": "/**\n * Parse an octal string from a buffer.\n *\n * <p>Leading spaces are ignored.\n * The buffer must contain a trailing space or NUL,\n * and may contain an additional trailing space or NUL.</p>\n *\n * <p>The input buffer is allowed to contain all NULs,\n * in which case the method returns 0L\n * (this allows for missing fields).</p>\n *\n * <p>To work-around some tar implementations that insert a\n * leading NUL this method returns 0 if it detects a leading NUL\n * since Commons Compress 1.4.</p>\n *\n * @param buffer The buffer from which to parse.\n * @param offset The offset into the buffer from which to parse.\n * @param length The maximum number of bytes to parse - must be at least 2 bytes.\n * @return The long value of the octal string.\n * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n */\npublic static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long result = 0;\n    int end = offset + length;\n    int start = offset;\n    if (length < 2) {\n        throw new IllegalArgumentException(\"Length \" + length + \" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    // Skip leading spaces\n    while (start < end) {\n        if (buffer[start] == ' ') {\n            start++;\n        } else {\n            break;\n        }\n    }\n    // Must have trailing NUL or space\n    byte trailer;\n    trailer = buffer[end - 1];\n    if (trailer == 0 || trailer == ' ') {\n        end--;\n    } else {\n        throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, end - 1, trailer));\n    }\n    // May have additional NULs or spaces\n    trailer = buffer[end - 1];\n    if (trailer == 0 || trailer == ' ') {\n        end--;\n    }\n    for (; start < end; start++) {\n        final byte currentByte = buffer[start];\n        // CheckStyle:MagicNumber OFF\n        if (currentByte < '0' || currentByte > '7') {\n            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));\n        }\n        // convert from ASCII\n        result = (result << 3) + (currentByte - '0');\n    // CheckStyle:MagicNumber ON\n    }\n    return result;\n}", "code_comment": "/**\n * Parse an octal string from a buffer.\n *\n * <p>Leading spaces are ignored.\n * The buffer must contain a trailing space or NUL,\n * and may contain an additional trailing space or NUL.</p>\n *\n * <p>The input buffer is allowed to contain all NULs,\n * in which case the method returns 0L\n * (this allows for missing fields).</p>\n *\n * <p>To work-around some tar implementations that insert a\n * leading NUL this method returns 0 if it detects a leading NUL\n * since Commons Compress 1.4.</p>\n *\n * @param buffer The buffer from which to parse.\n * @param offset The offset into the buffer from which to parse.\n * @param length The maximum number of bytes to parse - must be at least 2 bytes.\n * @return The long value of the octal string.\n * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n */\n", "code_no_comment": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long result = 0;\n    int end = offset + length;\n    int start = offset;\n    if (length < 2) {\n        throw new IllegalArgumentException(\"Length \" + length + \" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n        while (start < end) {\n        if (buffer[start] == ' ') {\n            start++;\n        } else {\n            break;\n        }\n    }\n        byte trailer;\n    trailer = buffer[end - 1];\n    if (trailer == 0 || trailer == ' ') {\n        end--;\n    } else {\n        throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, end - 1, trailer));\n    }\n        trailer = buffer[end - 1];\n    if (trailer == 0 || trailer == ' ') {\n        end--;\n    }\n    for (; start < end; start++) {\n        final byte currentByte = buffer[start];\n                if (currentByte < '0' || currentByte > '7') {\n            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));\n        }\n                result = (result << 3) + (currentByte - '0');\n        }\n    return result;\n}", "lc": 1.0454545454545454, "pi": -0.05741626794258379, "ma": 1.8, "nbd": 0.0, "ml": 0.9166666666666666, "d": 3.3194444444444446, "mi": -0.6806201550387594, "fo": -0.3333333333333333, "r": -0.02631578947368421, "e": 4.5456175838361474}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-1496_0a4c7694", "label": 1, "code": "// ------------------------------------------------------------------------\n// Task events\n// ------------------------------------------------------------------------\n@Override\npublic void sendTaskEvent(TaskEvent event) throws IOException, InterruptedException {\n    // remote input channels.\n    synchronized (requestLock) {\n        for (InputChannel inputChannel : inputChannels.values()) {\n            inputChannel.sendTaskEvent(event);\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void sendTaskEvent(TaskEvent event) throws IOException, InterruptedException {\n        synchronized (requestLock) {\n        for (InputChannel inputChannel : inputChannels.values()) {\n            inputChannel.sendTaskEvent(event);\n        }\n    }\n}", "lc": -0.2727272727272727, "pi": 0.5837320574162679, "ma": -0.4, "nbd": 0.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.43086680761099344, "fo": -0.3333333333333333, "r": 2.3157894736842106, "e": -0.16279340490885932}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-6987_37e0e6bb", "label": 3, "code": "/**\n * Extracts the body for logging purpose.\n * <p/>\n * Will clip the body if its too big for logging.\n *\n * @see org.apache.camel.Exchange#LOG_DEBUG_BODY_MAX_CHARS\n * @param message the message\n * @param prepend a message to prepend\n * @param allowStreams whether or not streams is allowed\n * @param allowFiles whether or not files is allowed (currently not in use)\n * @param maxChars limit to maximum number of chars. Use 0 for not limit, and -1 for turning logging message body off.\n * @return the logging message\n */\npublic static String extractBodyForLogging(Message message, String prepend, boolean allowStreams, boolean allowFiles, int maxChars) {\n    if (maxChars < 0) {\n        return prepend + \"[Body is not logged]\";\n    }\n    Object obj = message.getBody();\n    if (obj == null) {\n        return prepend + \"[Body is null]\";\n    }\n    if (!allowStreams) {\n        if (obj instanceof Source && !(obj instanceof StringSource || obj instanceof BytesSource)) {\n            // all other kinds we should not touch the body\n            return prepend + \"[Body is instance of java.xml.transform.Source]\";\n        } else if (obj instanceof StreamCache) {\n            return prepend + \"[Body is instance of org.apache.camel.StreamCache]\";\n        } else if (obj instanceof InputStream) {\n            return prepend + \"[Body is instance of java.io.InputStream]\";\n        } else if (obj instanceof OutputStream) {\n            return prepend + \"[Body is instance of java.io.OutputStream]\";\n        } else if (obj instanceof Reader) {\n            return prepend + \"[Body is instance of java.io.Reader]\";\n        } else if (obj instanceof Writer) {\n            return prepend + \"[Body is instance of java.io.Writer]\";\n        } else if (obj instanceof WrappedFile || obj instanceof File) {\n            return prepend + \"[Body is file based: \" + obj + \"]\";\n        }\n    }\n    if (!allowFiles) {\n        if (obj instanceof WrappedFile || obj instanceof File) {\n            return prepend + \"[Body is file based: \" + obj + \"]\";\n        }\n    }\n    // is the body a stream cache\n    StreamCache cache;\n    if (obj instanceof StreamCache) {\n        cache = (StreamCache) obj;\n    } else {\n        cache = null;\n    }\n    // grab the message body as a string\n    String body = null;\n    if (message.getExchange() != null) {\n        try {\n            body = message.getExchange().getContext().getTypeConverter().convertTo(String.class, message.getExchange(), obj);\n        } catch (Exception e) {\n        // ignore as the body is for logging purpose\n        }\n    }\n    if (body == null) {\n        body = obj.toString();\n    }\n    // reset stream cache after use\n    if (cache != null) {\n        cache.reset();\n    }\n    if (body == null) {\n        return prepend + \"[Body is null]\";\n    }\n    // clip body if length enabled and the body is too big\n    if (maxChars > 0 && body.length() > maxChars) {\n        body = body.substring(0, maxChars) + \"... [Body clipped after \" + maxChars + \" chars, total length is \" + body.length() + \"]\";\n    }\n    return prepend + body;\n}", "code_comment": "/**\n * Extracts the body for logging purpose.\n * <p/>\n * Will clip the body if its too big for logging.\n *\n * @see org.apache.camel.Exchange#LOG_DEBUG_BODY_MAX_CHARS\n * @param message the message\n * @param prepend a message to prepend\n * @param allowStreams whether or not streams is allowed\n * @param allowFiles whether or not files is allowed (currently not in use)\n * @param maxChars limit to maximum number of chars. Use 0 for not limit, and -1 for turning logging message body off.\n * @return the logging message\n */\n", "code_no_comment": "public static String extractBodyForLogging(Message message, String prepend, boolean allowStreams, boolean allowFiles, int maxChars) {\n    if (maxChars < 0) {\n        return prepend + \"[Body is not logged]\";\n    }\n    Object obj = message.getBody();\n    if (obj == null) {\n        return prepend + \"[Body is null]\";\n    }\n    if (!allowStreams) {\n        if (obj instanceof Source && !(obj instanceof StringSource || obj instanceof BytesSource)) {\n                        return prepend + \"[Body is instance of java.xml.transform.Source]\";\n        } else if (obj instanceof StreamCache) {\n            return prepend + \"[Body is instance of org.apache.camel.StreamCache]\";\n        } else if (obj instanceof InputStream) {\n            return prepend + \"[Body is instance of java.io.InputStream]\";\n        } else if (obj instanceof OutputStream) {\n            return prepend + \"[Body is instance of java.io.OutputStream]\";\n        } else if (obj instanceof Reader) {\n            return prepend + \"[Body is instance of java.io.Reader]\";\n        } else if (obj instanceof Writer) {\n            return prepend + \"[Body is instance of java.io.Writer]\";\n        } else if (obj instanceof WrappedFile || obj instanceof File) {\n            return prepend + \"[Body is file based: \" + obj + \"]\";\n        }\n    }\n    if (!allowFiles) {\n        if (obj instanceof WrappedFile || obj instanceof File) {\n            return prepend + \"[Body is file based: \" + obj + \"]\";\n        }\n    }\n        StreamCache cache;\n    if (obj instanceof StreamCache) {\n        cache = (StreamCache) obj;\n    } else {\n        cache = null;\n    }\n        String body = null;\n    if (message.getExchange() != null) {\n        try {\n            body = message.getExchange().getContext().getTypeConverter().convertTo(String.class, message.getExchange(), obj);\n        } catch (Exception e) {\n                }\n    }\n    if (body == null) {\n        body = obj.toString();\n    }\n        if (cache != null) {\n        cache.reset();\n    }\n    if (body == null) {\n        return prepend + \"[Body is null]\";\n    }\n        if (maxChars > 0 && body.length() > maxChars) {\n        body = body.substring(0, maxChars) + \"... [Body clipped after \" + maxChars + \" chars, total length is \" + body.length() + \"]\";\n    }\n    return prepend + body;\n}", "lc": 1.9545454545454546, "pi": 0.0669856459330142, "ma": 3.2, "nbd": 3.0, "ml": 2.1666666666666665, "d": 1.7182539682539684, "mi": -1.0025369978858347, "fo": 0.5, "r": -0.02631578947368421, "e": 4.4114705255211115}
{"project_name": "Closure", "project_version": 134, "label": 2, "code": "/**\n * Adds the node to the sub graph, adding all of its types to the set of\n * types in the sub graph and all of its related types to the related types\n * for the sub graph.\n */\npublic void addNode(Property prop) {\n    typesInSet.or(prop.typesSet);\n    typesRelatedToSet.or(getRelated(prop.type));\n}", "code_comment": "/**\n * Adds the node to the sub graph, adding all of its types to the set of\n * types in the sub graph and all of its related types to the related types\n * for the sub graph.\n */\n", "code_no_comment": "public void addNode(Property prop) {\n    typesInSet.or(prop.typesSet);\n    typesRelatedToSet.or(getRelated(prop.type));\n}", "lc": -0.45454545454545453, "pi": -0.47368421052631593, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.7860465116279065, "fo": -0.25, "r": 1.368421052631579, "e": -0.16279340490885932}
{"project_name": "maven", "project_version": "remotes/origin/bugs-dot-jar_MNG-4695_bb39b480", "label": 1, "code": "private void validateRawPlugins(ModelProblemCollector problems, List<Plugin> plugins, boolean managed, ModelBuildingRequest request) {\n    Severity errOn31 = getSeverity(request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_1);\n    String prefix = (managed ? \"build.pluginManagement.\" : \"build.\") + \"plugins.plugin.\";\n    Map<String, Plugin> index = new HashMap<String, Plugin>();\n    for (Plugin plugin : plugins) {\n        String key = plugin.getKey();\n        Plugin existing = index.get(key);\n        if (existing != null) {\n            addViolation(problems, errOn31, prefix + \"(groupId:artifactId)\", null, \"must be unique but found duplicate declaration of plugin \" + key, plugin);\n        } else {\n            index.put(key, plugin);\n        }\n        Set<String> executionIds = new HashSet<String>();\n        for (PluginExecution exec : plugin.getExecutions()) {\n            if (!executionIds.add(exec.getId())) {\n                addViolation(problems, Severity.ERROR, \"build.plugins.plugin[\" + plugin.getKey() + \"].executions.execution.id\", null, \"must be unique but found duplicate execution with id \" + exec.getId(), exec);\n            }\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "private void validateRawPlugins(ModelProblemCollector problems, List<Plugin> plugins, boolean managed, ModelBuildingRequest request) {\n    Severity errOn31 = getSeverity(request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_1);\n    String prefix = (managed ? \"build.pluginManagement.\" : \"build.\") + \"plugins.plugin.\";\n    Map<String, Plugin> index = new HashMap<String, Plugin>();\n    for (Plugin plugin : plugins) {\n        String key = plugin.getKey();\n        Plugin existing = index.get(key);\n        if (existing != null) {\n            addViolation(problems, errOn31, prefix + \"(groupId:artifactId)\", null, \"must be unique but found duplicate declaration of plugin \" + key, plugin);\n        } else {\n            index.put(key, plugin);\n        }\n        Set<String> executionIds = new HashSet<String>();\n        for (PluginExecution exec : plugin.getExecutions()) {\n            if (!executionIds.add(exec.getId())) {\n                addViolation(problems, Severity.ERROR, \"build.plugins.plugin[\" + plugin.getKey() + \"].executions.execution.id\", null, \"must be unique but found duplicate execution with id \" + exec.getId(), exec);\n            }\n        }\n    }\n}", "lc": 0.2727272727272727, "pi": 0.5071770334928228, "ma": 0.4, "nbd": 0.5, "ml": 0.16666666666666666, "d": 0.375, "mi": -0.3491190979563073, "fo": 0.4166666666666667, "r": -0.02631578947368421, "e": 0.7489381811056746}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-1382_9cd96df7", "label": 3, "code": "@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\nprivate static TypeInformation<?> parse(StringBuilder sb) throws ClassNotFoundException {\n    String infoString = sb.toString();\n    final Matcher tupleMatcher = tuplePattern.matcher(infoString);\n    final Matcher writableMatcher = writablePattern.matcher(infoString);\n    final Matcher enumMatcher = enumPattern.matcher(infoString);\n    final Matcher basicTypeMatcher = basicTypePattern.matcher(infoString);\n    final Matcher basicType2Matcher = basicType2Pattern.matcher(infoString);\n    final Matcher valueTypeMatcher = valueTypePattern.matcher(infoString);\n    final Matcher basicArrayTypeMatcher = basicArrayTypePattern.matcher(infoString);\n    final Matcher basicArrayType2Matcher = basicArrayType2Pattern.matcher(infoString);\n    final Matcher pojoGenericMatcher = pojoGenericObjectPattern.matcher(infoString);\n    if (infoString.length() == 0) {\n        return null;\n    }\n    TypeInformation<?> returnType = null;\n    // tuples\n    if (tupleMatcher.find()) {\n        String className = tupleMatcher.group(1);\n        sb.delete(0, className.length() + 1);\n        int arity = Integer.parseInt(className.replaceAll(\"\\\\D\", \"\"));\n        Class<?> clazz;\n        // check if fully qualified\n        if (className.startsWith(TUPLE_PACKAGE)) {\n            clazz = Class.forName(className);\n        } else {\n            clazz = Class.forName(TUPLE_PACKAGE + \".\" + className);\n        }\n        TypeInformation<?>[] types = new TypeInformation<?>[arity];\n        for (int i = 0; i < arity; i++) {\n            types[i] = parse(sb);\n            if (types[i] == null) {\n                throw new IllegalArgumentException(\"Tuple arity does not match given parameters.\");\n            }\n        }\n        if (sb.charAt(0) != '>') {\n            throw new IllegalArgumentException(\"Tuple arity does not match given parameters.\");\n        }\n        // remove '>'\n        sb.deleteCharAt(0);\n        // tuple arrays\n        if (sb.length() > 0) {\n            if (sb.length() >= 2 && sb.charAt(0) == '[' && sb.charAt(1) == ']') {\n                Class<?> arrayClazz;\n                // check if fully qualified\n                if (className.startsWith(TUPLE_PACKAGE)) {\n                    arrayClazz = Class.forName(\"[L\" + className + \";\");\n                } else {\n                    arrayClazz = Class.forName(\"[L\" + TUPLE_PACKAGE + \".\" + className + \";\");\n                }\n                returnType = ObjectArrayTypeInfo.getInfoFor(arrayClazz, new TupleTypeInfo(clazz, types));\n            } else if (sb.length() < 1 || sb.charAt(0) != '[') {\n                returnType = new TupleTypeInfo(clazz, types);\n            }\n        } else {\n            returnType = new TupleTypeInfo(clazz, types);\n        }\n    } else // writable types\n    if (writableMatcher.find()) {\n        String className = writableMatcher.group(1);\n        String fullyQualifiedName = writableMatcher.group(3);\n        sb.delete(0, className.length() + 1 + fullyQualifiedName.length() + 1);\n        Class<?> clazz = loadClass(fullyQualifiedName);\n        returnType = WritableTypeInfo.getWritableTypeInfo((Class) clazz);\n    } else // enum types\n    if (enumMatcher.find()) {\n        String className = enumMatcher.group(1);\n        String fullyQualifiedName = enumMatcher.group(3);\n        sb.delete(0, className.length() + 1 + fullyQualifiedName.length() + 1);\n        Class<?> clazz = loadClass(fullyQualifiedName);\n        returnType = new EnumTypeInfo(clazz);\n    } else // basic types of classes\n    if (basicTypeMatcher.find()) {\n        String className = basicTypeMatcher.group(1);\n        sb.delete(0, className.length());\n        Class<?> clazz;\n        // check if fully qualified\n        if (className.startsWith(\"java.lang\")) {\n            clazz = Class.forName(className);\n        } else {\n            clazz = Class.forName(\"java.lang.\" + className);\n        }\n        returnType = BasicTypeInfo.getInfoFor(clazz);\n    } else // basic type of primitives\n    if (basicType2Matcher.find()) {\n        String className = basicType2Matcher.group(1);\n        sb.delete(0, className.length());\n        Class<?> clazz = null;\n        if (className.equals(\"int\")) {\n            clazz = Integer.class;\n        } else if (className.equals(\"byte\")) {\n            clazz = Byte.class;\n        } else if (className.equals(\"short\")) {\n            clazz = Short.class;\n        } else if (className.equals(\"char\")) {\n            clazz = Character.class;\n        } else if (className.equals(\"double\")) {\n            clazz = Double.class;\n        } else if (className.equals(\"float\")) {\n            clazz = Float.class;\n        } else if (className.equals(\"long\")) {\n            clazz = Long.class;\n        } else if (className.equals(\"boolean\")) {\n            clazz = Boolean.class;\n        }\n        returnType = BasicTypeInfo.getInfoFor(clazz);\n    } else // values\n    if (valueTypeMatcher.find()) {\n        String className = valueTypeMatcher.group(1);\n        sb.delete(0, className.length() + 5);\n        Class<?> clazz;\n        // check if fully qualified\n        if (className.startsWith(VALUE_PACKAGE)) {\n            clazz = Class.forName(className + \"Value\");\n        } else {\n            clazz = Class.forName(VALUE_PACKAGE + \".\" + className + \"Value\");\n        }\n        returnType = ValueTypeInfo.getValueTypeInfo((Class<Value>) clazz);\n    } else // array of basic classes\n    if (basicArrayTypeMatcher.find()) {\n        String className = basicArrayTypeMatcher.group(1);\n        sb.delete(0, className.length() + 2);\n        Class<?> clazz;\n        if (className.startsWith(\"java.lang\")) {\n            clazz = Class.forName(\"[L\" + className + \";\");\n        } else {\n            clazz = Class.forName(\"[Ljava.lang.\" + className + \";\");\n        }\n        returnType = BasicArrayTypeInfo.getInfoFor(clazz);\n    } else // array of primitives\n    if (basicArrayType2Matcher.find()) {\n        String className = basicArrayType2Matcher.group(1);\n        sb.delete(0, className.length() + 2);\n        Class<?> clazz = null;\n        if (className.equals(\"int\")) {\n            clazz = int[].class;\n        } else if (className.equals(\"byte\")) {\n            clazz = byte[].class;\n        } else if (className.equals(\"short\")) {\n            clazz = short[].class;\n        } else if (className.equals(\"char\")) {\n            clazz = char[].class;\n        } else if (className.equals(\"double\")) {\n            clazz = double[].class;\n        } else if (className.equals(\"float\")) {\n            clazz = float[].class;\n        } else if (className.equals(\"long\")) {\n            clazz = long[].class;\n        } else if (className.equals(\"boolean\")) {\n            clazz = boolean[].class;\n        }\n        returnType = PrimitiveArrayTypeInfo.getInfoFor(clazz);\n    } else // pojo objects or generic types\n    if (pojoGenericMatcher.find()) {\n        String fullyQualifiedName = pojoGenericMatcher.group(1);\n        sb.delete(0, fullyQualifiedName.length());\n        boolean isPojo = pojoGenericMatcher.group(2) != null;\n        if (isPojo) {\n            sb.deleteCharAt(0);\n            Class<?> clazz = loadClass(fullyQualifiedName);\n            ArrayList<PojoField> fields = new ArrayList<PojoField>();\n            while (sb.charAt(0) != '>') {\n                final Matcher fieldMatcher = fieldPattern.matcher(sb);\n                if (!fieldMatcher.find()) {\n                    throw new IllegalArgumentException(\"Field name missing.\");\n                }\n                String fieldName = fieldMatcher.group(1);\n                sb.delete(0, fieldName.length() + 1);\n                Field field = null;\n                try {\n                    field = clazz.getDeclaredField(fieldName);\n                } catch (Exception e) {\n                    throw new IllegalArgumentException(\"Field '\" + fieldName + \"'could not be accessed.\");\n                }\n                fields.add(new PojoField(field, parse(sb)));\n            }\n            returnType = new PojoTypeInfo(clazz, fields);\n        } else {\n            // custom object array\n            if (fullyQualifiedName.endsWith(\"[]\")) {\n                fullyQualifiedName = fullyQualifiedName.substring(0, fullyQualifiedName.length() - 2);\n                returnType = ObjectArrayTypeInfo.getInfoFor(loadClass(\"[L\" + fullyQualifiedName + \";\"));\n            } else {\n                returnType = new GenericTypeInfo(loadClass(fullyQualifiedName));\n            }\n        }\n    }\n    if (returnType == null) {\n        throw new IllegalArgumentException(\"Error at '\" + infoString + \"'\");\n    } else {\n        // remove possible ','\n        if (sb.length() > 0 && sb.charAt(0) == ',') {\n            sb.deleteCharAt(0);\n        }\n        return returnType;\n    }\n}", "code_comment": NaN, "code_no_comment": "@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\nprivate static TypeInformation<?> parse(StringBuilder sb) throws ClassNotFoundException {\n    String infoString = sb.toString();\n    final Matcher tupleMatcher = tuplePattern.matcher(infoString);\n    final Matcher writableMatcher = writablePattern.matcher(infoString);\n    final Matcher enumMatcher = enumPattern.matcher(infoString);\n    final Matcher basicTypeMatcher = basicTypePattern.matcher(infoString);\n    final Matcher basicType2Matcher = basicType2Pattern.matcher(infoString);\n    final Matcher valueTypeMatcher = valueTypePattern.matcher(infoString);\n    final Matcher basicArrayTypeMatcher = basicArrayTypePattern.matcher(infoString);\n    final Matcher basicArrayType2Matcher = basicArrayType2Pattern.matcher(infoString);\n    final Matcher pojoGenericMatcher = pojoGenericObjectPattern.matcher(infoString);\n    if (infoString.length() == 0) {\n        return null;\n    }\n    TypeInformation<?> returnType = null;\n        if (tupleMatcher.find()) {\n        String className = tupleMatcher.group(1);\n        sb.delete(0, className.length() + 1);\n        int arity = Integer.parseInt(className.replaceAll(\"\\\\D\", \"\"));\n        Class<?> clazz;\n                if (className.startsWith(TUPLE_PACKAGE)) {\n            clazz = Class.forName(className);\n        } else {\n            clazz = Class.forName(TUPLE_PACKAGE + \".\" + className);\n        }\n        TypeInformation<?>[] types = new TypeInformation<?>[arity];\n        for (int i = 0; i < arity; i++) {\n            types[i] = parse(sb);\n            if (types[i] == null) {\n                throw new IllegalArgumentException(\"Tuple arity does not match given parameters.\");\n            }\n        }\n        if (sb.charAt(0) != '>') {\n            throw new IllegalArgumentException(\"Tuple arity does not match given parameters.\");\n        }\n                sb.deleteCharAt(0);\n                if (sb.length() > 0) {\n            if (sb.length() >= 2 && sb.charAt(0) == '[' && sb.charAt(1) == ']') {\n                Class<?> arrayClazz;\n                                if (className.startsWith(TUPLE_PACKAGE)) {\n                    arrayClazz = Class.forName(\"[L\" + className + \";\");\n                } else {\n                    arrayClazz = Class.forName(\"[L\" + TUPLE_PACKAGE + \".\" + className + \";\");\n                }\n                returnType = ObjectArrayTypeInfo.getInfoFor(arrayClazz, new TupleTypeInfo(clazz, types));\n            } else if (sb.length() < 1 || sb.charAt(0) != '[') {\n                returnType = new TupleTypeInfo(clazz, types);\n            }\n        } else {\n            returnType = new TupleTypeInfo(clazz, types);\n        }\n    } else     if (writableMatcher.find()) {\n        String className = writableMatcher.group(1);\n        String fullyQualifiedName = writableMatcher.group(3);\n        sb.delete(0, className.length() + 1 + fullyQualifiedName.length() + 1);\n        Class<?> clazz = loadClass(fullyQualifiedName);\n        returnType = WritableTypeInfo.getWritableTypeInfo((Class) clazz);\n    } else     if (enumMatcher.find()) {\n        String className = enumMatcher.group(1);\n        String fullyQualifiedName = enumMatcher.group(3);\n        sb.delete(0, className.length() + 1 + fullyQualifiedName.length() + 1);\n        Class<?> clazz = loadClass(fullyQualifiedName);\n        returnType = new EnumTypeInfo(clazz);\n    } else     if (basicTypeMatcher.find()) {\n        String className = basicTypeMatcher.group(1);\n        sb.delete(0, className.length());\n        Class<?> clazz;\n                if (className.startsWith(\"java.lang\")) {\n            clazz = Class.forName(className);\n        } else {\n            clazz = Class.forName(\"java.lang.\" + className);\n        }\n        returnType = BasicTypeInfo.getInfoFor(clazz);\n    } else     if (basicType2Matcher.find()) {\n        String className = basicType2Matcher.group(1);\n        sb.delete(0, className.length());\n        Class<?> clazz = null;\n        if (className.equals(\"int\")) {\n            clazz = Integer.class;\n        } else if (className.equals(\"byte\")) {\n            clazz = Byte.class;\n        } else if (className.equals(\"short\")) {\n            clazz = Short.class;\n        } else if (className.equals(\"char\")) {\n            clazz = Character.class;\n        } else if (className.equals(\"double\")) {\n            clazz = Double.class;\n        } else if (className.equals(\"float\")) {\n            clazz = Float.class;\n        } else if (className.equals(\"long\")) {\n            clazz = Long.class;\n        } else if (className.equals(\"boolean\")) {\n            clazz = Boolean.class;\n        }\n        returnType = BasicTypeInfo.getInfoFor(clazz);\n    } else     if (valueTypeMatcher.find()) {\n        String className = valueTypeMatcher.group(1);\n        sb.delete(0, className.length() + 5);\n        Class<?> clazz;\n                if (className.startsWith(VALUE_PACKAGE)) {\n            clazz = Class.forName(className + \"Value\");\n        } else {\n            clazz = Class.forName(VALUE_PACKAGE + \".\" + className + \"Value\");\n        }\n        returnType = ValueTypeInfo.getValueTypeInfo((Class<Value>) clazz);\n    } else     if (basicArrayTypeMatcher.find()) {\n        String className = basicArrayTypeMatcher.group(1);\n        sb.delete(0, className.length() + 2);\n        Class<?> clazz;\n        if (className.startsWith(\"java.lang\")) {\n            clazz = Class.forName(\"[L\" + className + \";\");\n        } else {\n            clazz = Class.forName(\"[Ljava.lang.\" + className + \";\");\n        }\n        returnType = BasicArrayTypeInfo.getInfoFor(clazz);\n    } else     if (basicArrayType2Matcher.find()) {\n        String className = basicArrayType2Matcher.group(1);\n        sb.delete(0, className.length() + 2);\n        Class<?> clazz = null;\n        if (className.equals(\"int\")) {\n            clazz = int[].class;\n        } else if (className.equals(\"byte\")) {\n            clazz = byte[].class;\n        } else if (className.equals(\"short\")) {\n            clazz = short[].class;\n        } else if (className.equals(\"char\")) {\n            clazz = char[].class;\n        } else if (className.equals(\"double\")) {\n            clazz = double[].class;\n        } else if (className.equals(\"float\")) {\n            clazz = float[].class;\n        } else if (className.equals(\"long\")) {\n            clazz = long[].class;\n        } else if (className.equals(\"boolean\")) {\n            clazz = boolean[].class;\n        }\n        returnType = PrimitiveArrayTypeInfo.getInfoFor(clazz);\n    } else     if (pojoGenericMatcher.find()) {\n        String fullyQualifiedName = pojoGenericMatcher.group(1);\n        sb.delete(0, fullyQualifiedName.length());\n        boolean isPojo = pojoGenericMatcher.group(2) != null;\n        if (isPojo) {\n            sb.deleteCharAt(0);\n            Class<?> clazz = loadClass(fullyQualifiedName);\n            ArrayList<PojoField> fields = new ArrayList<PojoField>();\n            while (sb.charAt(0) != '>') {\n                final Matcher fieldMatcher = fieldPattern.matcher(sb);\n                if (!fieldMatcher.find()) {\n                    throw new IllegalArgumentException(\"Field name missing.\");\n                }\n                String fieldName = fieldMatcher.group(1);\n                sb.delete(0, fieldName.length() + 1);\n                Field field = null;\n                try {\n                    field = clazz.getDeclaredField(fieldName);\n                } catch (Exception e) {\n                    throw new IllegalArgumentException(\"Field '\" + fieldName + \"'could not be accessed.\");\n                }\n                fields.add(new PojoField(field, parse(sb)));\n            }\n            returnType = new PojoTypeInfo(clazz, fields);\n        } else {\n                        if (fullyQualifiedName.endsWith(\"[]\")) {\n                fullyQualifiedName = fullyQualifiedName.substring(0, fullyQualifiedName.length() - 2);\n                returnType = ObjectArrayTypeInfo.getInfoFor(loadClass(\"[L\" + fullyQualifiedName + \";\"));\n            } else {\n                returnType = new GenericTypeInfo(loadClass(fullyQualifiedName));\n            }\n        }\n    }\n    if (returnType == null) {\n        throw new IllegalArgumentException(\"Error at '\" + infoString + \"'\");\n    } else {\n                if (sb.length() > 0 && sb.charAt(0) == ',') {\n            sb.deleteCharAt(0);\n        }\n        return returnType;\n    }\n}", "lc": 7.909090909090909, "pi": 0.5215311004784688, "ma": 9.2, "nbd": 7.0, "ml": 6.0, "d": 4.982142857142857, "mi": -1.982100070472163, "fo": 9.75, "r": -0.02631578947368421, "e": 60.16677673853033}
{"project_name": "Lang", "project_version": 38, "label": 1, "code": "/**\n * <p>Formats a <code>Calendar</code> object into the\n * supplied <code>StringBuffer</code>.</p>\n *\n * @param calendar  the calendar to format\n * @param buf  the buffer to format into\n * @return the specified string buffer\n */\npublic StringBuffer format(Calendar calendar, StringBuffer buf) {\n    if (mTimeZoneForced) {\n        calendar = (Calendar) calendar.clone();\n        calendar.setTimeZone(mTimeZone);\n    }\n    return applyRules(calendar, buf);\n}", "code_comment": "/**\n * <p>Formats a <code>Calendar</code> object into the\n * supplied <code>StringBuffer</code>.</p>\n *\n * @param calendar  the calendar to format\n * @param buf  the buffer to format into\n * @return the specified string buffer\n */\n", "code_no_comment": "public StringBuffer format(Calendar calendar, StringBuffer buf) {\n    if (mTimeZoneForced) {\n        calendar = (Calendar) calendar.clone();\n        calendar.setTimeZone(mTimeZone);\n    }\n    return applyRules(calendar, buf);\n}", "lc": -0.3181818181818182, "pi": 0.01435406698564584, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": -0.3650793650793651, "mi": 0.457364341085271, "fo": -0.25, "r": 0.631578947368421, "e": -0.16279340490885932}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1674_073b814c", "label": 1, "code": "@Override\npublic Status getStatus() {\n    if (nodeBuilder.isNew()) {\n        return NEW;\n    } else if (nodeBuilder.isModified()) {\n        return MODIFIED;\n    } else {\n        return UNCHANGED;\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic Status getStatus() {\n    if (nodeBuilder.isNew()) {\n        return NEW;\n    } else if (nodeBuilder.isModified()) {\n        return MODIFIED;\n    } else {\n        return UNCHANGED;\n    }\n}", "lc": -0.18181818181818182, "pi": 0.05263157894736836, "ma": -0.2, "nbd": 0.0, "ml": -0.08333333333333333, "d": -0.3650793650793651, "mi": 0.3792811839323466, "fo": -0.3333333333333333, "r": 1.0526315789473684, "e": -0.16279340490885932}
{"project_name": "Math", "project_version": 75, "label": 3, "code": "// -------------------------------------------------------------\n/**\n * Returns the percentage of values that are equal to v\n * (as a proportion between 0 and 1).\n * <p>\n * Returns <code>Double.NaN</code> if no values have been added.</p>\n *\n * @param v the value to lookup\n * @return the proportion of values equal to v\n * @deprecated replaced by {@link #getPct(Comparable)} as of 2.0\n */\n@Deprecated\npublic double getPct(Object v) {\n    return getCumPct((Comparable<?>) v);\n}", "code_comment": "/**\n * Returns the percentage of values that are equal to v\n * (as a proportion between 0 and 1).\n * <p>\n * Returns <code>Double.NaN</code> if no values have been added.</p>\n *\n * @param v the value to lookup\n * @return the proportion of values equal to v\n * @deprecated replaced by {@link #getPct(Comparable)} as of 2.0\n */\n", "code_no_comment": "@Deprecated\npublic double getPct(Object v) {\n    return getCumPct((Comparable<?>) v);\n}", "lc": -0.45454545454545453, "pi": -0.6028708133971293, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.8818886539816769, "fo": -0.4166666666666667, "r": 2.5789473684210527, "e": -0.16279340490885932}
{"project_name": "Math", "project_version": 38, "label": 1, "code": "// altmov\n// ----------------------------------------------------------------------------------------\n/**\n *     SUBROUTINE PRELIM sets the elements of XBASE, XPT, FVAL, GOPT, HQ, PQ,\n *     BMAT and ZMAT for the first iteration, and it maintains the values of\n *     NF and KOPT. The vector X is also changed by PRELIM.\n *\n *     The arguments N, NPT, X, XL, XU, RHOBEG, IPRINT and MAXFUN are the\n *       same as the corresponding arguments in SUBROUTINE BOBYQA.\n *     The arguments XBASE, XPT, FVAL, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU\n *       are the same as the corresponding arguments in BOBYQB, the elements\n *       of SL and SU being set in BOBYQA.\n *     GOPT is usually the gradient of the quadratic model at XOPT+XBASE, but\n *       it is set by PRELIM to the gradient of the quadratic model at XBASE.\n *       If XOPT is nonzero, BOBYQB will change it to its usual value later.\n *     NF is maintaned as the number of calls of CALFUN so far.\n *     KOPT will be such that the least calculated value of F so far is at\n *       the point XPT(KOPT,.)+XBASE in the space of the variables.\n *\n * @param lowerBound Lower bounds.\n * @param upperBound Upper bounds.\n */\nprivate void prelim(double[] lowerBound, double[] upperBound) {\n    // XXX\n    printMethod();\n    final int n = currentBest.getDimension();\n    final int npt = numberOfInterpolationPoints;\n    final int ndim = bMatrix.getRowDimension();\n    final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;\n    final double recip = 1d / rhosq;\n    final int np = n + 1;\n    for (int j = 0; j < n; j++) {\n        originShift.setEntry(j, currentBest.getEntry(j));\n        for (int k = 0; k < npt; k++) {\n            interpolationPoints.setEntry(k, j, ZERO);\n        }\n        for (int i = 0; i < ndim; i++) {\n            bMatrix.setEntry(i, j, ZERO);\n        }\n    }\n    for (int i = 0, max = n * np / 2; i < max; i++) {\n        modelSecondDerivativesValues.setEntry(i, ZERO);\n    }\n    for (int k = 0; k < npt; k++) {\n        modelSecondDerivativesParameters.setEntry(k, ZERO);\n        for (int j = 0, max = npt - np; j < max; j++) {\n            zMatrix.setEntry(k, j, ZERO);\n        }\n    }\n    // Begin the initialization procedure. NF becomes one more than the number\n    // of function values so far. The coordinates of the displacement of the\n    // next initial interpolation point from XBASE are set in XPT(NF+1,.).\n    int ipt = 0;\n    int jpt = 0;\n    double fbeg = Double.NaN;\n    do {\n        final int nfm = getEvaluations();\n        final int nfx = nfm - n;\n        final int nfmm = nfm - 1;\n        final int nfxm = nfx - 1;\n        double stepa = 0;\n        double stepb = 0;\n        if (nfm <= 2 * n) {\n            if (nfm >= 1 && nfm <= n) {\n                stepa = initialTrustRegionRadius;\n                if (upperDifference.getEntry(nfmm) == ZERO) {\n                    stepa = -stepa;\n                    // XXX\n                    throw new PathIsExploredException();\n                }\n                interpolationPoints.setEntry(nfm, nfmm, stepa);\n            } else if (nfm > n) {\n                stepa = interpolationPoints.getEntry(nfx, nfxm);\n                stepb = -initialTrustRegionRadius;\n                if (lowerDifference.getEntry(nfxm) == ZERO) {\n                    stepb = Math.min(TWO * initialTrustRegionRadius, upperDifference.getEntry(nfxm));\n                    // XXX\n                    throw new PathIsExploredException();\n                }\n                if (upperDifference.getEntry(nfxm) == ZERO) {\n                    stepb = Math.max(-TWO * initialTrustRegionRadius, lowerDifference.getEntry(nfxm));\n                    // XXX\n                    throw new PathIsExploredException();\n                }\n                interpolationPoints.setEntry(nfm, nfxm, stepb);\n            }\n        } else {\n            final int tmp1 = (nfm - np) / n;\n            jpt = nfm - tmp1 * n - n;\n            ipt = jpt + tmp1;\n            if (ipt > n) {\n                final int tmp2 = jpt;\n                jpt = ipt - n;\n                ipt = tmp2;\n                // XXX\n                throw new PathIsExploredException();\n            }\n            final int iptMinus1 = ipt;\n            final int jptMinus1 = jpt;\n            interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));\n            interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));\n        }\n        for (int j = 0; j < n; j++) {\n            currentBest.setEntry(j, Math.min(Math.max(lowerBound[j], originShift.getEntry(j) + interpolationPoints.getEntry(nfm, j)), upperBound[j]));\n            if (interpolationPoints.getEntry(nfm, j) == lowerDifference.getEntry(j)) {\n                currentBest.setEntry(j, lowerBound[j]);\n            }\n            if (interpolationPoints.getEntry(nfm, j) == upperDifference.getEntry(j)) {\n                currentBest.setEntry(j, upperBound[j]);\n            }\n        }\n        final double objectiveValue = computeObjectiveValue(currentBest.toArray());\n        final double f = isMinimize ? objectiveValue : -objectiveValue;\n        // nfm + 1\n        final int numEval = getEvaluations();\n        fAtInterpolationPoints.setEntry(nfm, f);\n        if (numEval == 1) {\n            fbeg = f;\n            trustRegionCenterInterpolationPointIndex = 0;\n        } else if (f < fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex)) {\n            trustRegionCenterInterpolationPointIndex = nfm;\n        }\n        if (numEval <= 2 * n + 1) {\n            if (numEval >= 2 && numEval <= n + 1) {\n                gradientAtTrustRegionCenter.setEntry(nfmm, (f - fbeg) / stepa);\n                if (npt < numEval + n) {\n                    final double oneOverStepA = ONE / stepa;\n                    bMatrix.setEntry(0, nfmm, -oneOverStepA);\n                    bMatrix.setEntry(nfm, nfmm, oneOverStepA);\n                    bMatrix.setEntry(npt + nfmm, nfmm, -HALF * rhosq);\n                    // XXX\n                    throw new PathIsExploredException();\n                }\n            } else if (numEval >= n + 2) {\n                final int ih = nfx * (nfx + 1) / 2 - 1;\n                final double tmp = (f - fbeg) / stepb;\n                final double diff = stepb - stepa;\n                modelSecondDerivativesValues.setEntry(ih, TWO * (tmp - gradientAtTrustRegionCenter.getEntry(nfxm)) / diff);\n                gradientAtTrustRegionCenter.setEntry(nfxm, (gradientAtTrustRegionCenter.getEntry(nfxm) * stepb - tmp * stepa) / diff);\n                if (stepa * stepb < ZERO) {\n                    if (f < fAtInterpolationPoints.getEntry(nfm - n)) {\n                        fAtInterpolationPoints.setEntry(nfm, fAtInterpolationPoints.getEntry(nfm - n));\n                        fAtInterpolationPoints.setEntry(nfm - n, f);\n                        if (trustRegionCenterInterpolationPointIndex == nfm) {\n                            trustRegionCenterInterpolationPointIndex = nfm - n;\n                        }\n                        interpolationPoints.setEntry(nfm - n, nfxm, stepb);\n                        interpolationPoints.setEntry(nfm, nfxm, stepa);\n                    }\n                }\n                bMatrix.setEntry(0, nfxm, -(stepa + stepb) / (stepa * stepb));\n                bMatrix.setEntry(nfm, nfxm, -HALF / interpolationPoints.getEntry(nfm - n, nfxm));\n                bMatrix.setEntry(nfm - n, nfxm, -bMatrix.getEntry(0, nfxm) - bMatrix.getEntry(nfm, nfxm));\n                zMatrix.setEntry(0, nfxm, Math.sqrt(TWO) / (stepa * stepb));\n                zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) / rhosq);\n                // zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) * recip); // XXX \"testAckley\" and \"testDiffPow\" fail.\n                zMatrix.setEntry(nfm - n, nfxm, -zMatrix.getEntry(0, nfxm) - zMatrix.getEntry(nfm, nfxm));\n            }\n        // Set the off-diagonal second derivatives of the Lagrange functions and\n        // the initial quadratic model.\n        } else {\n            zMatrix.setEntry(0, nfxm, recip);\n            zMatrix.setEntry(nfm, nfxm, recip);\n            zMatrix.setEntry(ipt, nfxm, -recip);\n            zMatrix.setEntry(jpt, nfxm, -recip);\n            final int ih = ipt * (ipt - 1) / 2 + jpt - 1;\n            final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);\n            modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);\n            // XXX\n            throw new PathIsExploredException();\n        }\n    } while (getEvaluations() < npt);\n}", "code_comment": "/**\n *     SUBROUTINE PRELIM sets the elements of XBASE, XPT, FVAL, GOPT, HQ, PQ,\n *     BMAT and ZMAT for the first iteration, and it maintains the values of\n *     NF and KOPT. The vector X is also changed by PRELIM.\n *\n *     The arguments N, NPT, X, XL, XU, RHOBEG, IPRINT and MAXFUN are the\n *       same as the corresponding arguments in SUBROUTINE BOBYQA.\n *     The arguments XBASE, XPT, FVAL, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU\n *       are the same as the corresponding arguments in BOBYQB, the elements\n *       of SL and SU being set in BOBYQA.\n *     GOPT is usually the gradient of the quadratic model at XOPT+XBASE, but\n *       it is set by PRELIM to the gradient of the quadratic model at XBASE.\n *       If XOPT is nonzero, BOBYQB will change it to its usual value later.\n *     NF is maintaned as the number of calls of CALFUN so far.\n *     KOPT will be such that the least calculated value of F so far is at\n *       the point XPT(KOPT,.)+XBASE in the space of the variables.\n *\n * @param lowerBound Lower bounds.\n * @param upperBound Upper bounds.\n */\n", "code_no_comment": "private void prelim(double[] lowerBound, double[] upperBound) {\n        printMethod();\n    final int n = currentBest.getDimension();\n    final int npt = numberOfInterpolationPoints;\n    final int ndim = bMatrix.getRowDimension();\n    final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;\n    final double recip = 1d / rhosq;\n    final int np = n + 1;\n    for (int j = 0; j < n; j++) {\n        originShift.setEntry(j, currentBest.getEntry(j));\n        for (int k = 0; k < npt; k++) {\n            interpolationPoints.setEntry(k, j, ZERO);\n        }\n        for (int i = 0; i < ndim; i++) {\n            bMatrix.setEntry(i, j, ZERO);\n        }\n    }\n    for (int i = 0, max = n * np / 2; i < max; i++) {\n        modelSecondDerivativesValues.setEntry(i, ZERO);\n    }\n    for (int k = 0; k < npt; k++) {\n        modelSecondDerivativesParameters.setEntry(k, ZERO);\n        for (int j = 0, max = npt - np; j < max; j++) {\n            zMatrix.setEntry(k, j, ZERO);\n        }\n    }\n                int ipt = 0;\n    int jpt = 0;\n    double fbeg = Double.NaN;\n    do {\n        final int nfm = getEvaluations();\n        final int nfx = nfm - n;\n        final int nfmm = nfm - 1;\n        final int nfxm = nfx - 1;\n        double stepa = 0;\n        double stepb = 0;\n        if (nfm <= 2 * n) {\n            if (nfm >= 1 && nfm <= n) {\n                stepa = initialTrustRegionRadius;\n                if (upperDifference.getEntry(nfmm) == ZERO) {\n                    stepa = -stepa;\n                                        throw new PathIsExploredException();\n                }\n                interpolationPoints.setEntry(nfm, nfmm, stepa);\n            } else if (nfm > n) {\n                stepa = interpolationPoints.getEntry(nfx, nfxm);\n                stepb = -initialTrustRegionRadius;\n                if (lowerDifference.getEntry(nfxm) == ZERO) {\n                    stepb = Math.min(TWO * initialTrustRegionRadius, upperDifference.getEntry(nfxm));\n                                        throw new PathIsExploredException();\n                }\n                if (upperDifference.getEntry(nfxm) == ZERO) {\n                    stepb = Math.max(-TWO * initialTrustRegionRadius, lowerDifference.getEntry(nfxm));\n                                        throw new PathIsExploredException();\n                }\n                interpolationPoints.setEntry(nfm, nfxm, stepb);\n            }\n        } else {\n            final int tmp1 = (nfm - np) / n;\n            jpt = nfm - tmp1 * n - n;\n            ipt = jpt + tmp1;\n            if (ipt > n) {\n                final int tmp2 = jpt;\n                jpt = ipt - n;\n                ipt = tmp2;\n                                throw new PathIsExploredException();\n            }\n            final int iptMinus1 = ipt;\n            final int jptMinus1 = jpt;\n            interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));\n            interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));\n        }\n        for (int j = 0; j < n; j++) {\n            currentBest.setEntry(j, Math.min(Math.max(lowerBound[j], originShift.getEntry(j) + interpolationPoints.getEntry(nfm, j)), upperBound[j]));\n            if (interpolationPoints.getEntry(nfm, j) == lowerDifference.getEntry(j)) {\n                currentBest.setEntry(j, lowerBound[j]);\n            }\n            if (interpolationPoints.getEntry(nfm, j) == upperDifference.getEntry(j)) {\n                currentBest.setEntry(j, upperBound[j]);\n            }\n        }\n        final double objectiveValue = computeObjectiveValue(currentBest.toArray());\n        final double f = isMinimize ? objectiveValue : -objectiveValue;\n                final int numEval = getEvaluations();\n        fAtInterpolationPoints.setEntry(nfm, f);\n        if (numEval == 1) {\n            fbeg = f;\n            trustRegionCenterInterpolationPointIndex = 0;\n        } else if (f < fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex)) {\n            trustRegionCenterInterpolationPointIndex = nfm;\n        }\n        if (numEval <= 2 * n + 1) {\n            if (numEval >= 2 && numEval <= n + 1) {\n                gradientAtTrustRegionCenter.setEntry(nfmm, (f - fbeg) / stepa);\n                if (npt < numEval + n) {\n                    final double oneOverStepA = ONE / stepa;\n                    bMatrix.setEntry(0, nfmm, -oneOverStepA);\n                    bMatrix.setEntry(nfm, nfmm, oneOverStepA);\n                    bMatrix.setEntry(npt + nfmm, nfmm, -HALF * rhosq);\n                                        throw new PathIsExploredException();\n                }\n            } else if (numEval >= n + 2) {\n                final int ih = nfx * (nfx + 1) / 2 - 1;\n                final double tmp = (f - fbeg) / stepb;\n                final double diff = stepb - stepa;\n                modelSecondDerivativesValues.setEntry(ih, TWO * (tmp - gradientAtTrustRegionCenter.getEntry(nfxm)) / diff);\n                gradientAtTrustRegionCenter.setEntry(nfxm, (gradientAtTrustRegionCenter.getEntry(nfxm) * stepb - tmp * stepa) / diff);\n                if (stepa * stepb < ZERO) {\n                    if (f < fAtInterpolationPoints.getEntry(nfm - n)) {\n                        fAtInterpolationPoints.setEntry(nfm, fAtInterpolationPoints.getEntry(nfm - n));\n                        fAtInterpolationPoints.setEntry(nfm - n, f);\n                        if (trustRegionCenterInterpolationPointIndex == nfm) {\n                            trustRegionCenterInterpolationPointIndex = nfm - n;\n                        }\n                        interpolationPoints.setEntry(nfm - n, nfxm, stepb);\n                        interpolationPoints.setEntry(nfm, nfxm, stepa);\n                    }\n                }\n                bMatrix.setEntry(0, nfxm, -(stepa + stepb) / (stepa * stepb));\n                bMatrix.setEntry(nfm, nfxm, -HALF / interpolationPoints.getEntry(nfm - n, nfxm));\n                bMatrix.setEntry(nfm - n, nfxm, -bMatrix.getEntry(0, nfxm) - bMatrix.getEntry(nfm, nfxm));\n                zMatrix.setEntry(0, nfxm, Math.sqrt(TWO) / (stepa * stepb));\n                zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) / rhosq);\n                                zMatrix.setEntry(nfm - n, nfxm, -zMatrix.getEntry(0, nfxm) - zMatrix.getEntry(nfm, nfxm));\n            }\n                        } else {\n            zMatrix.setEntry(0, nfxm, recip);\n            zMatrix.setEntry(nfm, nfxm, recip);\n            zMatrix.setEntry(ipt, nfxm, -recip);\n            zMatrix.setEntry(jpt, nfxm, -recip);\n            final int ih = ipt * (ipt - 1) / 2 + jpt - 1;\n            final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);\n            modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);\n                        throw new PathIsExploredException();\n        }\n    } while (getEvaluations() < npt);\n}", "lc": 5.590909090909091, "pi": 1.2775119617224882, "ma": 6.0, "nbd": 2.5, "ml": 4.166666666666667, "d": 8.186507936507937, "mi": -1.7176885130373498, "fo": 6.0, "r": -0.02631578947368421, "e": 86.35383897235523}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4520_b91154ea", "label": 1, "code": "/**\n *  Initialize Wicket's MarkupParser with all necessary markup filters. You may subclass this\n *  method, to add your own filters to the list.\n *\n *  @param markup\n *  @return The list of markup filter\n */\n@Override\nprotected MarkupFilterList initializeMarkupFilters(final Markup markup) {\n    // MarkupFilterList is a simple extension of ArrayList providing few additional helpers\n    final MarkupFilterList filters = new MarkupFilterList();\n    MarkupResourceStream markupResourceStream = markup.getMarkupResourceStream();\n    filters.add(new WicketTagIdentifier(markupResourceStream));\n    filters.add(new HtmlHandler());\n    filters.add(new WicketRemoveTagHandler());\n    filters.add(new WicketLinkTagHandler());\n    filters.add(new AutoLabelTagHandler());\n    filters.add(new WicketNamespaceHandler(markupResourceStream));\n    // Provided the wicket component requesting the markup is known ...\n    if ((markupResourceStream != null) && (markupResourceStream.getResource() != null)) {\n        final ContainerInfo containerInfo = markupResourceStream.getContainerInfo();\n        if (containerInfo != null) {\n            filters.add(new WicketMessageTagHandler(markupResourceStream));\n            // Pages require additional handlers\n            if (Page.class.isAssignableFrom(containerInfo.getContainerClass())) {\n                filters.add(new HtmlHeaderSectionHandler(markup));\n            }\n            filters.add(new HeadForceTagIdHandler(containerInfo.getContainerClass()));\n        }\n    }\n    filters.add(new OpenCloseTagExpander());\n    filters.add(new RelativePathPrefixHandler(markupResourceStream));\n    filters.add(new EnclosureHandler());\n    filters.add(new InlineEnclosureHandler());\n    // Append it. See WICKET-4390\n    filters.add(new StyleAndScriptIdentifier(), StyleAndScriptIdentifier.class);\n    filters.add(new ConditionalCommentFilter());\n    return filters;\n}", "code_comment": "/**\n *  Initialize Wicket's MarkupParser with all necessary markup filters. You may subclass this\n *  method, to add your own filters to the list.\n *\n *  @param markup\n *  @return The list of markup filter\n */\n", "code_no_comment": "@Override\nprotected MarkupFilterList initializeMarkupFilters(final Markup markup) {\n        final MarkupFilterList filters = new MarkupFilterList();\n    MarkupResourceStream markupResourceStream = markup.getMarkupResourceStream();\n    filters.add(new WicketTagIdentifier(markupResourceStream));\n    filters.add(new HtmlHandler());\n    filters.add(new WicketRemoveTagHandler());\n    filters.add(new WicketLinkTagHandler());\n    filters.add(new AutoLabelTagHandler());\n    filters.add(new WicketNamespaceHandler(markupResourceStream));\n        if ((markupResourceStream != null) && (markupResourceStream.getResource() != null)) {\n        final ContainerInfo containerInfo = markupResourceStream.getContainerInfo();\n        if (containerInfo != null) {\n            filters.add(new WicketMessageTagHandler(markupResourceStream));\n                        if (Page.class.isAssignableFrom(containerInfo.getContainerClass())) {\n                filters.add(new HtmlHeaderSectionHandler(markup));\n            }\n            filters.add(new HeadForceTagIdHandler(containerInfo.getContainerClass()));\n        }\n    }\n    filters.add(new OpenCloseTagExpander());\n    filters.add(new RelativePathPrefixHandler(markupResourceStream));\n    filters.add(new EnclosureHandler());\n    filters.add(new InlineEnclosureHandler());\n        filters.add(new StyleAndScriptIdentifier(), StyleAndScriptIdentifier.class);\n    filters.add(new ConditionalCommentFilter());\n    return filters;\n}", "lc": 0.6363636363636364, "pi": 0.4354066985645932, "ma": 0.0, "nbd": 0.5, "ml": 0.3333333333333333, "d": 0.11309523809523811, "mi": -0.4700493305144466, "fo": 1.25, "r": -0.02631578947368421, "e": 0.35273018562380776}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-412_be2fdba7", "label": 1, "code": "public AssignmentStats importFiles(List<String> files, Path failureDir) throws IOException, AccumuloException, AccumuloSecurityException, ThriftTableOperationException {\n    int numThreads = acuConf.getCount(Property.TSERV_BULK_PROCESS_THREADS);\n    int numAssignThreads = acuConf.getCount(Property.TSERV_BULK_ASSIGNMENT_THREADS);\n    timer = new StopWatch<Timers>(Timers.class);\n    timer.start(Timers.TOTAL);\n    Configuration conf = CachedConfiguration.getInstance();\n    final FileSystem fs = FileSystem.get(conf);\n    Set<Path> paths = new HashSet<Path>();\n    for (String file : files) {\n        paths.add(new Path(file));\n    }\n    AssignmentStats assignmentStats = new AssignmentStats(paths.size());\n    final Map<Path, List<KeyExtent>> completeFailures = Collections.synchronizedSortedMap(new TreeMap<Path, List<KeyExtent>>());\n    if (!fs.exists(failureDir)) {\n        log.error(failureDir + \" does not exist\");\n        throw new RuntimeException(\"Directory does not exist \" + failureDir);\n    }\n    ClientService.Iface client = null;\n    final TabletLocator locator = TabletLocator.getInstance(instance, credentials, new Text(tableId));\n    try {\n        final Map<Path, List<TabletLocation>> assignments = Collections.synchronizedSortedMap(new TreeMap<Path, List<TabletLocation>>());\n        timer.start(Timers.EXAMINE_MAP_FILES);\n        ExecutorService threadPool = Executors.newFixedThreadPool(numThreads);\n        for (Path path : paths) {\n            final Path mapFile = path;\n            Runnable getAssignments = new Runnable() {\n\n                public void run() {\n                    List<TabletLocation> tabletsToAssignMapFileTo = Collections.emptyList();\n                    try {\n                        tabletsToAssignMapFileTo = findOverlappingTablets(instance.getConfiguration(), fs, locator, mapFile);\n                    } catch (Exception ex) {\n                        log.warn(\"Unable to find tablets that overlap file \" + mapFile.toString());\n                    }\n                    if (tabletsToAssignMapFileTo.size() == 0) {\n                        List<KeyExtent> empty = Collections.emptyList();\n                        completeFailures.put(mapFile, empty);\n                    } else\n                        assignments.put(mapFile, tabletsToAssignMapFileTo);\n                }\n            };\n            threadPool.submit(new TraceRunnable(new LoggingRunnable(log, getAssignments)));\n        }\n        threadPool.shutdown();\n        while (!threadPool.isTerminated()) {\n            try {\n                threadPool.awaitTermination(60, TimeUnit.SECONDS);\n            } catch (InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        timer.stop(Timers.EXAMINE_MAP_FILES);\n        assignmentStats.attemptingAssignments(assignments);\n        Map<Path, List<KeyExtent>> assignmentFailures = assignMapFiles(acuConf, instance, conf, credentials, fs, tableId, assignments, paths, numAssignThreads, numThreads);\n        assignmentStats.assignmentsFailed(assignmentFailures);\n        Map<Path, Integer> failureCount = new TreeMap<Path, Integer>();\n        for (Entry<Path, List<KeyExtent>> entry : assignmentFailures.entrySet()) failureCount.put(entry.getKey(), 1);\n        while (assignmentFailures.size() > 0) {\n            locator.invalidateCache();\n            // assumption about assignment failures is that it caused by a split\n            // happening or a missing location\n            // \n            // for splits we need to find children key extents that cover the\n            // same key range and are contiguous (no holes, no overlap)\n            timer.start(Timers.SLEEP);\n            UtilWaitThread.sleep(4000);\n            timer.stop(Timers.SLEEP);\n            log.debug(\"Trying to assign \" + assignmentFailures.size() + \" map files that previously failed on some key extents\");\n            assignments.clear();\n            // assign to\n            for (Entry<Path, List<KeyExtent>> entry : assignmentFailures.entrySet()) {\n                Iterator<KeyExtent> keListIter = entry.getValue().iterator();\n                List<TabletLocation> tabletsToAssignMapFileTo = new ArrayList<TabletLocation>();\n                while (keListIter.hasNext()) {\n                    KeyExtent ke = keListIter.next();\n                    try {\n                        timer.start(Timers.QUERY_METADATA);\n                        tabletsToAssignMapFileTo.addAll(findOverlappingTablets(instance.getConfiguration(), fs, locator, entry.getKey(), ke));\n                        timer.stop(Timers.QUERY_METADATA);\n                        keListIter.remove();\n                    } catch (Exception ex) {\n                        log.warn(\"Exception finding overlapping tablets, will retry tablet \" + ke);\n                    }\n                }\n                if (tabletsToAssignMapFileTo.size() > 0)\n                    assignments.put(entry.getKey(), tabletsToAssignMapFileTo);\n            }\n            assignmentStats.attemptingAssignments(assignments);\n            Map<Path, List<KeyExtent>> assignmentFailures2 = assignMapFiles(acuConf, instance, conf, credentials, fs, tableId, assignments, paths, numAssignThreads, numThreads);\n            assignmentStats.assignmentsFailed(assignmentFailures2);\n            // merge assignmentFailures2 into assignmentFailures\n            for (Entry<Path, List<KeyExtent>> entry : assignmentFailures2.entrySet()) {\n                assignmentFailures.get(entry.getKey()).addAll(entry.getValue());\n                Integer fc = failureCount.get(entry.getKey());\n                if (fc == null)\n                    fc = 0;\n                failureCount.put(entry.getKey(), fc + 1);\n            }\n            // remove map files that have no more key extents to assign\n            Iterator<Entry<Path, List<KeyExtent>>> afIter = assignmentFailures.entrySet().iterator();\n            while (afIter.hasNext()) {\n                Entry<Path, List<KeyExtent>> entry = afIter.next();\n                if (entry.getValue().size() == 0)\n                    afIter.remove();\n            }\n            Set<Entry<Path, Integer>> failureIter = failureCount.entrySet();\n            for (Entry<Path, Integer> entry : failureIter) {\n                if (entry.getValue() > acuConf.getCount(Property.TSERV_BULK_RETRY) && assignmentFailures.get(entry.getKey()) != null) {\n                    log.error(\"Map file \" + entry.getKey() + \" failed more than three times, giving up.\");\n                    completeFailures.put(entry.getKey(), assignmentFailures.get(entry.getKey()));\n                    assignmentFailures.remove(entry.getKey());\n                }\n            }\n        }\n        assignmentStats.assignmentsAbandoned(completeFailures);\n        Set<Path> failedFailures = processFailures(conf, fs, failureDir, completeFailures);\n        assignmentStats.unrecoveredMapFiles(failedFailures);\n        timer.stop(Timers.TOTAL);\n        printReport();\n        return assignmentStats;\n    } finally {\n        if (client != null)\n            ServerClient.close(client);\n        locator.invalidateCache();\n    }\n}", "code_comment": NaN, "code_no_comment": "public AssignmentStats importFiles(List<String> files, Path failureDir) throws IOException, AccumuloException, AccumuloSecurityException, ThriftTableOperationException {\n    int numThreads = acuConf.getCount(Property.TSERV_BULK_PROCESS_THREADS);\n    int numAssignThreads = acuConf.getCount(Property.TSERV_BULK_ASSIGNMENT_THREADS);\n    timer = new StopWatch<Timers>(Timers.class);\n    timer.start(Timers.TOTAL);\n    Configuration conf = CachedConfiguration.getInstance();\n    final FileSystem fs = FileSystem.get(conf);\n    Set<Path> paths = new HashSet<Path>();\n    for (String file : files) {\n        paths.add(new Path(file));\n    }\n    AssignmentStats assignmentStats = new AssignmentStats(paths.size());\n    final Map<Path, List<KeyExtent>> completeFailures = Collections.synchronizedSortedMap(new TreeMap<Path, List<KeyExtent>>());\n    if (!fs.exists(failureDir)) {\n        log.error(failureDir + \" does not exist\");\n        throw new RuntimeException(\"Directory does not exist \" + failureDir);\n    }\n    ClientService.Iface client = null;\n    final TabletLocator locator = TabletLocator.getInstance(instance, credentials, new Text(tableId));\n    try {\n        final Map<Path, List<TabletLocation>> assignments = Collections.synchronizedSortedMap(new TreeMap<Path, List<TabletLocation>>());\n        timer.start(Timers.EXAMINE_MAP_FILES);\n        ExecutorService threadPool = Executors.newFixedThreadPool(numThreads);\n        for (Path path : paths) {\n            final Path mapFile = path;\n            Runnable getAssignments = new Runnable() {\n\n                public void run() {\n                    List<TabletLocation> tabletsToAssignMapFileTo = Collections.emptyList();\n                    try {\n                        tabletsToAssignMapFileTo = findOverlappingTablets(instance.getConfiguration(), fs, locator, mapFile);\n                    } catch (Exception ex) {\n                        log.warn(\"Unable to find tablets that overlap file \" + mapFile.toString());\n                    }\n                    if (tabletsToAssignMapFileTo.size() == 0) {\n                        List<KeyExtent> empty = Collections.emptyList();\n                        completeFailures.put(mapFile, empty);\n                    } else\n                        assignments.put(mapFile, tabletsToAssignMapFileTo);\n                }\n            };\n            threadPool.submit(new TraceRunnable(new LoggingRunnable(log, getAssignments)));\n        }\n        threadPool.shutdown();\n        while (!threadPool.isTerminated()) {\n            try {\n                threadPool.awaitTermination(60, TimeUnit.SECONDS);\n            } catch (InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        timer.stop(Timers.EXAMINE_MAP_FILES);\n        assignmentStats.attemptingAssignments(assignments);\n        Map<Path, List<KeyExtent>> assignmentFailures = assignMapFiles(acuConf, instance, conf, credentials, fs, tableId, assignments, paths, numAssignThreads, numThreads);\n        assignmentStats.assignmentsFailed(assignmentFailures);\n        Map<Path, Integer> failureCount = new TreeMap<Path, Integer>();\n        for (Entry<Path, List<KeyExtent>> entry : assignmentFailures.entrySet()) failureCount.put(entry.getKey(), 1);\n        while (assignmentFailures.size() > 0) {\n            locator.invalidateCache();\n                                                                        timer.start(Timers.SLEEP);\n            UtilWaitThread.sleep(4000);\n            timer.stop(Timers.SLEEP);\n            log.debug(\"Trying to assign \" + assignmentFailures.size() + \" map files that previously failed on some key extents\");\n            assignments.clear();\n                        for (Entry<Path, List<KeyExtent>> entry : assignmentFailures.entrySet()) {\n                Iterator<KeyExtent> keListIter = entry.getValue().iterator();\n                List<TabletLocation> tabletsToAssignMapFileTo = new ArrayList<TabletLocation>();\n                while (keListIter.hasNext()) {\n                    KeyExtent ke = keListIter.next();\n                    try {\n                        timer.start(Timers.QUERY_METADATA);\n                        tabletsToAssignMapFileTo.addAll(findOverlappingTablets(instance.getConfiguration(), fs, locator, entry.getKey(), ke));\n                        timer.stop(Timers.QUERY_METADATA);\n                        keListIter.remove();\n                    } catch (Exception ex) {\n                        log.warn(\"Exception finding overlapping tablets, will retry tablet \" + ke);\n                    }\n                }\n                if (tabletsToAssignMapFileTo.size() > 0)\n                    assignments.put(entry.getKey(), tabletsToAssignMapFileTo);\n            }\n            assignmentStats.attemptingAssignments(assignments);\n            Map<Path, List<KeyExtent>> assignmentFailures2 = assignMapFiles(acuConf, instance, conf, credentials, fs, tableId, assignments, paths, numAssignThreads, numThreads);\n            assignmentStats.assignmentsFailed(assignmentFailures2);\n                        for (Entry<Path, List<KeyExtent>> entry : assignmentFailures2.entrySet()) {\n                assignmentFailures.get(entry.getKey()).addAll(entry.getValue());\n                Integer fc = failureCount.get(entry.getKey());\n                if (fc == null)\n                    fc = 0;\n                failureCount.put(entry.getKey(), fc + 1);\n            }\n                        Iterator<Entry<Path, List<KeyExtent>>> afIter = assignmentFailures.entrySet().iterator();\n            while (afIter.hasNext()) {\n                Entry<Path, List<KeyExtent>> entry = afIter.next();\n                if (entry.getValue().size() == 0)\n                    afIter.remove();\n            }\n            Set<Entry<Path, Integer>> failureIter = failureCount.entrySet();\n            for (Entry<Path, Integer> entry : failureIter) {\n                if (entry.getValue() > acuConf.getCount(Property.TSERV_BULK_RETRY) && assignmentFailures.get(entry.getKey()) != null) {\n                    log.error(\"Map file \" + entry.getKey() + \" failed more than three times, giving up.\");\n                    completeFailures.put(entry.getKey(), assignmentFailures.get(entry.getKey()));\n                    assignmentFailures.remove(entry.getKey());\n                }\n            }\n        }\n        assignmentStats.assignmentsAbandoned(completeFailures);\n        Set<Path> failedFailures = processFailures(conf, fs, failureDir, completeFailures);\n        assignmentStats.unrecoveredMapFiles(failedFailures);\n        timer.stop(Timers.TOTAL);\n        printReport();\n        return assignmentStats;\n    } finally {\n        if (client != null)\n            ServerClient.close(client);\n        locator.invalidateCache();\n    }\n}", "lc": 4.681818181818182, "pi": 1.5693779904306218, "ma": 3.8, "nbd": 1.5, "ml": 1.75, "d": 1.4960317460317463, "mi": -1.5443269908386184, "fo": 7.583333333333333, "r": -0.02631578947368421, "e": 15.166337603660605}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1199_813109d7", "label": 3, "code": "public void removeConstraint(ByteBuffer login, String tableName, int constraint) throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException;", "code_comment": NaN, "code_no_comment": "public void removeConstraint(ByteBuffer login, String tableName, int constraint) throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException;", "lc": -0.5909090909090909, "pi": -1.4306220095693782, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.4033826638477798, "fo": -0.5, "r": -0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-172_99e22ce4", "label": 1, "code": "/**\n *  Ensure that there is space in childForId map for a new entry before\n *  adding it.\n *\n *  @param child\n *             The child to put into the map\n *  @return Any component that was replaced\n */\nprivate final Component put(final Component<?> child) {\n    int index = children_indexOf(child);\n    if (index == -1) {\n        children_add(child);\n        return null;\n    } else {\n        return children_set(index, child);\n    }\n}", "code_comment": "/**\n *  Ensure that there is space in childForId map for a new entry before\n *  adding it.\n *\n *  @param child\n *             The child to put into the map\n *  @return Any component that was replaced\n */\n", "code_no_comment": "private final Component put(final Component<?> child) {\n    int index = children_indexOf(child);\n    if (index == -1) {\n        children_add(child);\n        return null;\n    } else {\n        return children_set(index, child);\n    }\n}", "lc": -0.22727272727272727, "pi": -0.01913875598086126, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": -0.047619047619047616, "mi": 0.33784355179704006, "fo": -0.25, "r": 2.236842105263158, "e": -0.1109316920523504}
{"project_name": "Closure", "project_version": 125, "label": 2, "code": "/**\n * Visits a NEW node.\n */\nprivate void visitNew(NodeTraversal t, Node n) {\n    Node constructor = n.getFirstChild();\n    JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n    if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n        FunctionType fnType = type.toMaybeFunctionType();\n        if (fnType != null) {\n            visitParameterList(t, n, fnType);\n            ensureTyped(t, n, fnType.getInstanceType());\n        } else {\n            ensureTyped(t, n);\n        }\n    } else {\n        report(t, n, NOT_A_CONSTRUCTOR);\n        ensureTyped(t, n);\n    }\n}", "code_comment": "/**\n * Visits a NEW node.\n */\n", "code_no_comment": "private void visitNew(NodeTraversal t, Node n) {\n    Node constructor = n.getFirstChild();\n    JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n    if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n        FunctionType fnType = type.toMaybeFunctionType();\n        if (fnType != null) {\n            visitParameterList(t, n, fnType);\n            ensureTyped(t, n, fnType.getInstanceType());\n        } else {\n            ensureTyped(t, n);\n        }\n    } else {\n        report(t, n, NOT_A_CONSTRUCTOR);\n        ensureTyped(t, n);\n    }\n}", "lc": 0.09090909090909091, "pi": 0.3444976076555023, "ma": -0.2, "nbd": 0.0, "ml": 0.25, "d": 0.015873015873015844, "mi": -0.11289640591966157, "fo": 0.5833333333333334, "r": 0.05263157894736841, "e": 0.05149058049941506}
{"project_name": "Math", "project_version": 96, "label": 3, "code": "/**\n * Test for the equality of two Complex objects.\n * <p>\n * If both the real and imaginary parts of two Complex numbers\n * are exactly the same, and neither is <code>Double.NaN</code>, the two\n * Complex objects are considered to be equal.</p>\n * <p>\n * All <code>NaN</code> values are considered to be equal - i.e, if either\n * (or both) real and imaginary parts of the complex number are equal\n * to <code>Double.NaN</code>, the complex number is equal to\n * <code>Complex.NaN</code>.</p>\n *\n * @param other Object to test for equality to this\n * @return true if two Complex objects are equal, false if\n *         object is null, not an instance of Complex, or\n *         not equal to this Complex instance\n */\npublic boolean equals(Object other) {\n    boolean ret;\n    if (this == other) {\n        ret = true;\n    } else if (other == null) {\n        ret = false;\n    } else {\n        try {\n            Complex rhs = (Complex) other;\n            if (rhs.isNaN()) {\n                ret = this.isNaN();\n            } else {\n                ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));\n            }\n        } catch (ClassCastException ex) {\n            // ignore exception\n            ret = false;\n        }\n    }\n    return ret;\n}", "code_comment": "/**\n * Test for the equality of two Complex objects.\n * <p>\n * If both the real and imaginary parts of two Complex numbers\n * are exactly the same, and neither is <code>Double.NaN</code>, the two\n * Complex objects are considered to be equal.</p>\n * <p>\n * All <code>NaN</code> values are considered to be equal - i.e, if either\n * (or both) real and imaginary parts of the complex number are equal\n * to <code>Double.NaN</code>, the complex number is equal to\n * <code>Complex.NaN</code>.</p>\n *\n * @param other Object to test for equality to this\n * @return true if two Complex objects are equal, false if\n *         object is null, not an instance of Complex, or\n *         not equal to this Complex instance\n */\n", "code_no_comment": "public boolean equals(Object other) {\n    boolean ret;\n    if (this == other) {\n        ret = true;\n    } else if (other == null) {\n        ret = false;\n    } else {\n        try {\n            Complex rhs = (Complex) other;\n            if (rhs.isNaN()) {\n                ret = this.isNaN();\n            } else {\n                ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));\n            }\n        } catch (ClassCastException ex) {\n                        ret = false;\n        }\n    }\n    return ret;\n}", "lc": 0.2727272727272727, "pi": 0.7894736842105261, "ma": 0.2, "nbd": 1.0, "ml": 0.0, "d": 0.053571428571428534, "mi": -0.2183227625088091, "fo": 0.16666666666666666, "r": -0.02631578947368421, "e": 0.05794966661480033}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3310_4416a9f8", "label": 1, "code": "private void internalSetValue(@Nonnull final Value[] values) throws RepositoryException {\n    if (values.length > MV_PROPERTY_WARN_THRESHOLD) {\n        LOG.warn(\"Large multi valued property [{}] detected ({} values).\", dlg.getPath(), values.length);\n    }\n    sessionDelegate.performVoid(new ItemWriteOperation(\"internalSetValue\") {\n\n        @Override\n        public void performVoid() throws RepositoryException {\n            Type<?> type = dlg.getPropertyState().getType();\n            if (!type.isArray()) {\n                throw new ValueFormatException(\"This is a single-valued property\");\n            }\n            List<Value> converted = newArrayListWithCapacity(values.length);\n            ValueFactory factory = getValueFactory();\n            for (Value value : values) {\n                if (value != null) {\n                    converted.add(ValueHelper.convert(value, type.tag(), factory));\n                }\n            }\n            dlg.setState(createMultiState(dlg.getName(), converted, type));\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"Setting property [%s/%s]\", dlg.getPath(), dlg.getName());\n        }\n    });\n}", "code_comment": NaN, "code_no_comment": "private void internalSetValue(@Nonnull final Value[] values) throws RepositoryException {\n    if (values.length > MV_PROPERTY_WARN_THRESHOLD) {\n        LOG.warn(\"Large multi valued property [{}] detected ({} values).\", dlg.getPath(), values.length);\n    }\n    sessionDelegate.performVoid(new ItemWriteOperation(\"internalSetValue\") {\n\n        @Override\n        public void performVoid() throws RepositoryException {\n            Type<?> type = dlg.getPropertyState().getType();\n            if (!type.isArray()) {\n                throw new ValueFormatException(\"This is a single-valued property\");\n            }\n            List<Value> converted = newArrayListWithCapacity(values.length);\n            ValueFactory factory = getValueFactory();\n            for (Value value : values) {\n                if (value != null) {\n                    converted.add(ValueHelper.convert(value, type.tag(), factory));\n                }\n            }\n            dlg.setState(createMultiState(dlg.getName(), converted, type));\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"Setting property [%s/%s]\", dlg.getPath(), dlg.getName());\n        }\n    });\n}", "lc": 0.5454545454545454, "pi": 0.8899521531100476, "ma": 0.4, "nbd": 0.5, "ml": 0.08333333333333333, "d": 0.28968253968253965, "mi": -0.43735024665257216, "fo": 0.9166666666666666, "r": -0.02631578947368421, "e": 0.488380214726578}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1697_1552be04", "label": 3, "code": "/**\n * Create a separate token node underneath a dedicated token store within\n * the user home node. That token node contains the hashed token, the\n * expiration time and additional mandatory attributes that will be verified\n * during login.\n *\n * @param userId     The identifier of the user for which a new token should\n *                   be created.\n * @param attributes The attributes associated with the new token.\n * @return A new {@code TokenInfo} or {@code null} if the token could not\n *         be created.\n */\n@Override\npublic TokenInfo createToken(String userId, Map<String, ?> attributes) {\n    String error = \"Failed to create login token. \";\n    NodeUtil tokenParent = getTokenParent(userId);\n    if (tokenParent != null) {\n        try {\n            long creationTime = new Date().getTime();\n            Calendar creation = GregorianCalendar.getInstance();\n            creation.setTimeInMillis(creationTime);\n            String tokenName = Text.replace(ISO8601.format(creation), \":\", \".\");\n            NodeUtil tokenNode = tokenParent.addChild(tokenName, TOKEN_NT_NAME);\n            tokenNode.setString(JcrConstants.JCR_UUID, IdentifierManager.generateUUID());\n            String key = generateKey(options.getConfigValue(PARAM_TOKEN_LENGTH, DEFAULT_KEY_SIZE));\n            String nodeId = getIdentifier(tokenNode.getTree());\n            String token = new StringBuilder(nodeId).append(DELIM).append(key).toString();\n            String keyHash = PasswordUtil.buildPasswordHash(getKeyValue(key, userId));\n            tokenNode.setString(TOKEN_ATTRIBUTE_KEY, keyHash);\n            long exp;\n            if (attributes.containsKey(PARAM_TOKEN_EXPIRATION)) {\n                exp = Long.parseLong(attributes.get(PARAM_TOKEN_EXPIRATION).toString());\n            } else {\n                exp = tokenExpiration;\n            }\n            long expTime = createExpirationTime(creationTime, exp);\n            tokenNode.setDate(TOKEN_ATTRIBUTE_EXPIRY, expTime);\n            for (String name : attributes.keySet()) {\n                if (!RESERVED_ATTRIBUTES.contains(name)) {\n                    String attr = attributes.get(name).toString();\n                    tokenNode.setString(name, attr);\n                }\n            }\n            root.commit();\n            return new TokenInfoImpl(tokenNode, token, userId);\n        } catch (NoSuchAlgorithmException e) {\n            // error while generating login token\n            log.error(error, e.getMessage());\n        } catch (UnsupportedEncodingException e) {\n            // error while generating login token\n            log.error(error, e.getMessage());\n        } catch (CommitFailedException e) {\n            // conflict while committing changes\n            log.warn(error, e.getMessage());\n        } catch (AccessDeniedException e) {\n            log.warn(error, e.getMessage());\n        }\n    } else {\n        log.warn(\"Unable to get/create token store for user \" + userId);\n    }\n    return null;\n}", "code_comment": "/**\n * Create a separate token node underneath a dedicated token store within\n * the user home node. That token node contains the hashed token, the\n * expiration time and additional mandatory attributes that will be verified\n * during login.\n *\n * @param userId     The identifier of the user for which a new token should\n *                   be created.\n * @param attributes The attributes associated with the new token.\n * @return A new {@code TokenInfo} or {@code null} if the token could not\n *         be created.\n */\n", "code_no_comment": "@Override\npublic TokenInfo createToken(String userId, Map<String, ?> attributes) {\n    String error = \"Failed to create login token. \";\n    NodeUtil tokenParent = getTokenParent(userId);\n    if (tokenParent != null) {\n        try {\n            long creationTime = new Date().getTime();\n            Calendar creation = GregorianCalendar.getInstance();\n            creation.setTimeInMillis(creationTime);\n            String tokenName = Text.replace(ISO8601.format(creation), \":\", \".\");\n            NodeUtil tokenNode = tokenParent.addChild(tokenName, TOKEN_NT_NAME);\n            tokenNode.setString(JcrConstants.JCR_UUID, IdentifierManager.generateUUID());\n            String key = generateKey(options.getConfigValue(PARAM_TOKEN_LENGTH, DEFAULT_KEY_SIZE));\n            String nodeId = getIdentifier(tokenNode.getTree());\n            String token = new StringBuilder(nodeId).append(DELIM).append(key).toString();\n            String keyHash = PasswordUtil.buildPasswordHash(getKeyValue(key, userId));\n            tokenNode.setString(TOKEN_ATTRIBUTE_KEY, keyHash);\n            long exp;\n            if (attributes.containsKey(PARAM_TOKEN_EXPIRATION)) {\n                exp = Long.parseLong(attributes.get(PARAM_TOKEN_EXPIRATION).toString());\n            } else {\n                exp = tokenExpiration;\n            }\n            long expTime = createExpirationTime(creationTime, exp);\n            tokenNode.setDate(TOKEN_ATTRIBUTE_EXPIRY, expTime);\n            for (String name : attributes.keySet()) {\n                if (!RESERVED_ATTRIBUTES.contains(name)) {\n                    String attr = attributes.get(name).toString();\n                    tokenNode.setString(name, attr);\n                }\n            }\n            root.commit();\n            return new TokenInfoImpl(tokenNode, token, userId);\n        } catch (NoSuchAlgorithmException e) {\n                        log.error(error, e.getMessage());\n        } catch (UnsupportedEncodingException e) {\n                        log.error(error, e.getMessage());\n        } catch (CommitFailedException e) {\n                        log.warn(error, e.getMessage());\n        } catch (AccessDeniedException e) {\n            log.warn(error, e.getMessage());\n        }\n    } else {\n        log.warn(\"Unable to get/create token store for user \" + userId);\n    }\n    return null;\n}", "lc": 1.5, "pi": 0.7607655502392344, "ma": 1.0, "nbd": 1.0, "ml": 0.16666666666666666, "d": 0.3809523809523809, "mi": -0.8694855532064832, "fo": 2.8333333333333335, "r": -0.02631578947368421, "e": 1.7977351705537592}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5853_b80f6640", "label": 3, "code": "/**\n *  Parses a value as a String and returns a Number.\n *\n *  @param value\n *             The object to parse (after converting with toString())\n *  @param min\n *             The minimum allowed value\n *  @param max\n *             The maximum allowed value\n *  @param locale\n *  @return The number\n *  @throws ConversionException\n *              if value is unparsable or out of range\n */\nprotected N parse(Object value, final double min, final double max, Locale locale) {\n    if (locale == null) {\n        locale = Locale.getDefault();\n    }\n    if (value == null) {\n        return null;\n    } else if (value instanceof String) {\n        // Convert spaces to no-break space (U+00A0) as required by Java formats:\n        // http://bugs.sun.com/view_bug.do?bug_id=4510618\n        value = ((String) value).replaceAll(\"(\\\\d+)\\\\s(?=\\\\d)\", \"$1\\u00A0\");\n    }\n    final NumberFormat numberFormat = getNumberFormat(locale);\n    final N number = parse(numberFormat, value, locale);\n    if (number == null) {\n        return null;\n    }\n    if (number.doubleValue() < min) {\n        throw newConversionException(\"Value cannot be less than \" + min, value, locale).setFormat(numberFormat);\n    }\n    if (number.doubleValue() > max) {\n        throw newConversionException(\"Value cannot be greater than \" + max, value, locale).setFormat(numberFormat);\n    }\n    return number;\n}", "code_comment": "/**\n *  Parses a value as a String and returns a Number.\n *\n *  @param value\n *             The object to parse (after converting with toString())\n *  @param min\n *             The minimum allowed value\n *  @param max\n *             The maximum allowed value\n *  @param locale\n *  @return The number\n *  @throws ConversionException\n *              if value is unparsable or out of range\n */\n", "code_no_comment": "protected N parse(Object value, final double min, final double max, Locale locale) {\n    if (locale == null) {\n        locale = Locale.getDefault();\n    }\n    if (value == null) {\n        return null;\n    } else if (value instanceof String) {\n                        value = ((String) value).replaceAll(\"(\\\\d+)\\\\s(?=\\\\d)\", \"$1\\u00A0\");\n    }\n    final NumberFormat numberFormat = getNumberFormat(locale);\n    final N number = parse(numberFormat, value, locale);\n    if (number == null) {\n        return null;\n    }\n    if (number.doubleValue() < min) {\n        throw newConversionException(\"Value cannot be less than \" + min, value, locale).setFormat(numberFormat);\n    }\n    if (number.doubleValue() > max) {\n        throw newConversionException(\"Value cannot be greater than \" + max, value, locale).setFormat(numberFormat);\n    }\n    return number;\n}", "lc": 0.36363636363636365, "pi": -0.3301435406698567, "ma": 1.0, "nbd": 0.0, "ml": 0.5833333333333334, "d": 0.6111111111111112, "mi": -0.34686398872445356, "fo": 0.3333333333333333, "r": -0.02631578947368421, "e": 0.6080369749255141}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-793_73400bfb", "label": 3, "code": "/**\n * Return a Log4j Marker that is compatible with SLF4J.\n * @param name The name of the Marker.\n * @return A Marker.\n */\n@Override\npublic Marker getMarker(final String name) {\n    if (name == null) {\n        throw new IllegalArgumentException(\"Marker name must not be null\");\n    }\n    Marker marker = markerMap.get(name);\n    if (marker != null) {\n        return marker;\n    }\n    final org.apache.logging.log4j.Marker log4jMarker = MarkerManager.getMarker(name);\n    marker = new Log4jMarker(log4jMarker);\n    final Marker existing = markerMap.putIfAbsent(name, marker);\n    return existing == null ? marker : existing;\n}", "code_comment": "/**\n * Return a Log4j Marker that is compatible with SLF4J.\n * @param name The name of the Marker.\n * @return A Marker.\n */\n", "code_no_comment": "@Override\npublic Marker getMarker(final String name) {\n    if (name == null) {\n        throw new IllegalArgumentException(\"Marker name must not be null\");\n    }\n    Marker marker = markerMap.get(name);\n    if (marker != null) {\n        return marker;\n    }\n    final org.apache.logging.log4j.Marker log4jMarker = MarkerManager.getMarker(name);\n    marker = new Log4jMarker(log4jMarker);\n    final Marker existing = markerMap.putIfAbsent(name, marker);\n    return existing == null ? marker : existing;\n}", "lc": 0.0, "pi": -0.29665071770334933, "ma": 0.2, "nbd": -0.5, "ml": 0.08333333333333333, "d": 0.011904761904761871, "mi": -0.047498238195912666, "fo": -0.25, "r": 0.15789473684210528, "e": 0.026442604150458418}
{"project_name": "Closure", "project_version": 146, "label": 2, "code": "/**\n * Computes the subset of {@code this} and {@code that} types if inequality\n * is observed. If a value {@code v1} of type {@code number} is not equal to a\n * value {@code v2} of type {@code (undefined,number)}, we can infer that the\n * type of {@code v1} is {@code number} and the type of {@code v2} is\n * {@code number} as well.\n *\n * @return a pair containing the restricted type of {@code this} as the first\n *         component and the restricted type of {@code that} as the second\n *         element. The returned pair is never {@code null} even though its\n *         components may be {@code null}\n */\npublic TypePair getTypesUnderInequality(JSType that) {\n    // unions types\n    if (that instanceof UnionType) {\n        TypePair p = that.getTypesUnderInequality(this);\n        return new TypePair(p.typeB, p.typeA);\n    }\n    // other types\n    switch(this.testForEquality(that)) {\n        case TRUE:\n            return new TypePair(null, null);\n        case FALSE:\n        case UNKNOWN:\n            return new TypePair(this, that);\n    }\n    // switch case is exhaustive\n    throw new IllegalStateException();\n}", "code_comment": "/**\n * Computes the subset of {@code this} and {@code that} types if inequality\n * is observed. If a value {@code v1} of type {@code number} is not equal to a\n * value {@code v2} of type {@code (undefined,number)}, we can infer that the\n * type of {@code v1} is {@code number} and the type of {@code v2} is\n * {@code number} as well.\n *\n * @return a pair containing the restricted type of {@code this} as the first\n *         component and the restricted type of {@code that} as the second\n *         element. The returned pair is never {@code null} even though its\n *         components may be {@code null}\n */\n", "code_no_comment": "public TypePair getTypesUnderInequality(JSType that) {\n        if (that instanceof UnionType) {\n        TypePair p = that.getTypesUnderInequality(this);\n        return new TypePair(p.typeB, p.typeA);\n    }\n        switch(this.testForEquality(that)) {\n        case TRUE:\n            return new TypePair(null, null);\n        case FALSE:\n        case UNKNOWN:\n            return new TypePair(this, that);\n    }\n        throw new IllegalStateException();\n}", "lc": 0.0, "pi": 0.3062200956937798, "ma": 0.4, "nbd": 0.0, "ml": 0.08333333333333333, "d": -0.3650793650793651, "mi": 0.04186046511627904, "fo": -0.3333333333333333, "r": -0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-2172_ea4a3f8a", "label": 3, "code": "/**\n *  @see IValueMap#getAsDuration(String, Duration)\n */\npublic Duration getAsDuration(String key, Duration defaultValue) {\n    if (!containsKey(key))\n        return defaultValue;\n    try {\n        return getDuration(key);\n    } catch (StringValueConversionException ignored) {\n        return defaultValue;\n    }\n}", "code_comment": "/**\n *  @see IValueMap#getAsDuration(String, Duration)\n */\n", "code_no_comment": "public Duration getAsDuration(String key, Duration defaultValue) {\n    if (!containsKey(key))\n        return defaultValue;\n    try {\n        return getDuration(key);\n    } catch (StringValueConversionException ignored) {\n        return defaultValue;\n    }\n}", "lc": -0.22727272727272727, "pi": -0.01913875598086126, "ma": -0.2, "nbd": -0.5, "ml": -0.16666666666666666, "d": -0.3650793650793651, "mi": 0.3663143058491896, "fo": -0.3333333333333333, "r": 2.263157894736842, "e": -0.16279340490885932}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2435_7e250001", "label": 3, "code": "@Override\npublic boolean equals(Object obj) {\n    if (obj instanceof Key) {\n        Key other = (Key) obj;\n        return name.equals(other.name) && revision != null ? revision.equals(other.revision) : other.revision == null;\n    }\n    return false;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean equals(Object obj) {\n    if (obj instanceof Key) {\n        Key other = (Key) obj;\n        return name.equals(other.name) && revision != null ? revision.equals(other.revision) : other.revision == null;\n    }\n    return false;\n}", "lc": -0.2727272727272727, "pi": 0.06220095693779899, "ma": -0.2, "nbd": -0.5, "ml": 0.16666666666666666, "d": 0.5376984126984127, "mi": 0.315292459478506, "fo": -0.3333333333333333, "r": 0.6578947368421053, "e": 0.07463909683442539}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-4513_9e05f77f", "label": 3, "code": "public void process(Exchange exchange) throws Exception {\n    // copy the original exchange to avoid side effects on it\n    Exchange resultExchange = exchange.copy();\n    // force to use InOut to retrieve the result on the OUT message\n    resultExchange.setPattern(ExchangePattern.InOut);\n    // do not propagate any method name when using OGNL, as with OGNL we\n    // compute and provide the method name to explicit to invoke\n    resultExchange.getIn().removeHeader(Exchange.BEAN_METHOD_NAME);\n    // current ognl path as we go along\n    String ognlPath = \"\";\n    // loop and invoke each method\n    Object beanToCall = beanHolder.getBean();\n    // there must be a bean to call with, we currently does not support OGNL expressions on using purely static methods\n    if (beanToCall == null) {\n        throw new IllegalArgumentException(\"Bean instance is null. OGNL bean expressions requires bean instances.\");\n    }\n    // Split ognl except when this is not a Map, Array\n    // and we would like to keep the dots within the key name\n    List<String> methods = OgnlHelper.splitOgnl(ognl);\n    for (String methodName : methods) {\n        BeanHolder holder = new ConstantBeanHolder(beanToCall, exchange.getContext());\n        // support the null safe operator\n        boolean nullSafe = OgnlHelper.isNullSafeOperator(methodName);\n        // keep up with how far are we doing\n        ognlPath += methodName;\n        // get rid of leading ?. or . as we only needed that to determine if null safe was enabled or not\n        methodName = OgnlHelper.removeLeadingOperators(methodName);\n        // are we doing an index lookup (eg in Map/List/array etc)?\n        String key = null;\n        KeyValueHolder<String, String> index = OgnlHelper.isOgnlIndex(methodName);\n        if (index != null) {\n            methodName = index.getKey();\n            key = index.getValue();\n        }\n        // only invoke if we have a method name to use to invoke\n        if (methodName != null) {\n            InvokeProcessor invoke = new InvokeProcessor(holder, methodName);\n            invoke.process(resultExchange);\n            // check for exception and rethrow if we failed\n            if (resultExchange.getException() != null) {\n                throw new RuntimeBeanExpressionException(exchange, beanName, methodName, resultExchange.getException());\n            }\n            result = invoke.getResult();\n        }\n        // if there was a key then we need to lookup using the key\n        if (key != null) {\n            result = lookupResult(resultExchange, key, result, nullSafe, ognlPath, holder.getBean());\n        }\n        // check null safe for null results\n        if (result == null && nullSafe) {\n            return;\n        }\n        // prepare for next bean to invoke\n        beanToCall = result;\n    }\n}", "code_comment": NaN, "code_no_comment": "public void process(Exchange exchange) throws Exception {\n        Exchange resultExchange = exchange.copy();\n        resultExchange.setPattern(ExchangePattern.InOut);\n            resultExchange.getIn().removeHeader(Exchange.BEAN_METHOD_NAME);\n        String ognlPath = \"\";\n        Object beanToCall = beanHolder.getBean();\n        if (beanToCall == null) {\n        throw new IllegalArgumentException(\"Bean instance is null. OGNL bean expressions requires bean instances.\");\n    }\n            List<String> methods = OgnlHelper.splitOgnl(ognl);\n    for (String methodName : methods) {\n        BeanHolder holder = new ConstantBeanHolder(beanToCall, exchange.getContext());\n                boolean nullSafe = OgnlHelper.isNullSafeOperator(methodName);\n                ognlPath += methodName;\n                methodName = OgnlHelper.removeLeadingOperators(methodName);\n                String key = null;\n        KeyValueHolder<String, String> index = OgnlHelper.isOgnlIndex(methodName);\n        if (index != null) {\n            methodName = index.getKey();\n            key = index.getValue();\n        }\n                if (methodName != null) {\n            InvokeProcessor invoke = new InvokeProcessor(holder, methodName);\n            invoke.process(resultExchange);\n                        if (resultExchange.getException() != null) {\n                throw new RuntimeBeanExpressionException(exchange, beanName, methodName, resultExchange.getException());\n            }\n            result = invoke.getResult();\n        }\n                if (key != null) {\n            result = lookupResult(resultExchange, key, result, nullSafe, ognlPath, holder.getBean());\n        }\n                if (result == null && nullSafe) {\n            return;\n        }\n                beanToCall = result;\n    }\n}", "lc": 1.0909090909090908, "pi": 0.29186602870813394, "ma": 1.2, "nbd": 0.5, "ml": 0.75, "d": 0.507936507936508, "mi": -0.7223396758280477, "fo": 1.0, "r": -0.02631578947368421, "e": 1.3969998213493309}
{"project_name": "Math", "project_version": 93, "label": 3, "code": "/**\n * Returns n!. Shorthand for <code>n</code> <a\n * href=\"http://mathworld.wolfram.com/Factorial.html\"> Factorial</a>, the\n * product of the numbers <code>1,...,n</code> as a <code>double</code>.\n * <p>\n * <Strong>Preconditions</strong>:\n * <ul>\n * <li> <code>n >= 0</code> (otherwise\n * <code>IllegalArgumentException</code> is thrown)</li>\n * <li> The result is small enough to fit into a <code>double</code>. The\n * largest value of <code>n</code> for which <code>n!</code> <\n * Double.MAX_VALUE</code> is 170. If the computed value exceeds\n * Double.MAX_VALUE, Double.POSITIVE_INFINITY is returned</li>\n * </ul>\n * </p>\n *\n * @param n argument\n * @return <code>n!</code>\n * @throws IllegalArgumentException if n < 0\n */\npublic static double factorialDouble(final int n) {\n    if (n < 0) {\n        throw new IllegalArgumentException(\"must have n >= 0 for n!\");\n    }\n    return Math.floor(Math.exp(factorialLog(n)) + 0.5);\n}", "code_comment": "/**\n * Returns n!. Shorthand for <code>n</code> <a\n * href=\"http://mathworld.wolfram.com/Factorial.html\"> Factorial</a>, the\n * product of the numbers <code>1,...,n</code> as a <code>double</code>.\n * <p>\n * <Strong>Preconditions</strong>:\n * <ul>\n * <li> <code>n >= 0</code> (otherwise\n * <code>IllegalArgumentException</code> is thrown)</li>\n * <li> The result is small enough to fit into a <code>double</code>. The\n * largest value of <code>n</code> for which <code>n!</code> <\n * Double.MAX_VALUE</code> is 170. If the computed value exceeds\n * Double.MAX_VALUE, Double.POSITIVE_INFINITY is returned</li>\n * </ul>\n * </p>\n *\n * @param n argument\n * @return <code>n!</code>\n * @throws IllegalArgumentException if n < 0\n */\n", "code_no_comment": "public static double factorialDouble(final int n) {\n    if (n < 0) {\n        throw new IllegalArgumentException(\"must have n >= 0 for n!\");\n    }\n    return Math.floor(Math.exp(factorialLog(n)) + 0.5);\n}", "lc": -0.36363636363636365, "pi": -0.11483253588516758, "ma": -0.2, "nbd": -0.5, "ml": -0.25, "d": -0.11309523809523811, "mi": 0.5416490486257928, "fo": -0.25, "r": -0.02631578947368421, "e": -0.12805449421690493}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-2437_a41bc8cc", "label": 3, "code": "/**\n *  recursively determine all declared fields\n *  This is required because class.getFields() is not returning fields defined\n *  in parent classes.\n */\npublic static List<Field> getAllDeclaredFields(Class<?> clazz) {\n    List<Field> result = new ArrayList<Field>();\n    while (clazz != null) {\n        Field[] fields = clazz.getDeclaredFields();\n        for (Field field : fields) {\n            if (Modifier.isTransient(field.getModifiers()) || Modifier.isStatic(field.getModifiers())) {\n                // we have no use for transient or static fields\n                continue;\n            }\n            if (hasFieldWithSameName(field.getName(), result)) {\n                throw new RuntimeException(\"The field \" + field + \" is already contained in the hierarchy of the class \" + clazz + \".\" + \"Please use unique field names through your classes hierarchy\");\n            }\n            result.add(field);\n        }\n        clazz = clazz.getSuperclass();\n    }\n    return result;\n}", "code_comment": "/**\n *  recursively determine all declared fields\n *  This is required because class.getFields() is not returning fields defined\n *  in parent classes.\n */\n", "code_no_comment": "public static List<Field> getAllDeclaredFields(Class<?> clazz) {\n    List<Field> result = new ArrayList<Field>();\n    while (clazz != null) {\n        Field[] fields = clazz.getDeclaredFields();\n        for (Field field : fields) {\n            if (Modifier.isTransient(field.getModifiers()) || Modifier.isStatic(field.getModifiers())) {\n                                continue;\n            }\n            if (hasFieldWithSameName(field.getName(), result)) {\n                throw new RuntimeException(\"The field \" + field + \" is already contained in the hierarchy of the class \" + clazz + \".\" + \"Please use unique field names through your classes hierarchy\");\n            }\n            result.add(field);\n        }\n        clazz = clazz.getSuperclass();\n    }\n    return result;\n}", "lc": 0.13636363636363635, "pi": 0.8899521531100476, "ma": 0.6, "nbd": 0.5, "ml": 0.5, "d": 0.3650793650793651, "mi": -0.17237491190979545, "fo": 0.25, "r": -0.02631578947368421, "e": 0.26579300726704813}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-43_668f08f2", "label": 1, "code": "void apply() throws Exception {\n    moveNode(srcPath, destPath);\n}", "code_comment": NaN, "code_no_comment": "void apply() throws Exception {\n    moveNode(srcPath, destPath);\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.0676532769556022, "fo": -0.4166666666666667, "r": 1.6578947368421053, "e": -0.16279340490885932}
{"project_name": "Closure", "project_version": 67, "label": 2, "code": "private boolean isPrototypePropertyAssign(Node assign) {\n    Node n = assign.getFirstChild();\n    if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.getType() == Token.GETPROP) {\n        // We want to exclude the assignment itself from the usage list\n        boolean isChainedProperty = n.getFirstChild().getType() == Token.GETPROP;\n        if (isChainedProperty) {\n            Node child = n.getFirstChild().getFirstChild().getNext();\n            if (child.getType() == Token.STRING && child.getString().equals(\"prototype\")) {\n                return true;\n            }\n        }\n    }\n    return false;\n}", "code_comment": NaN, "code_no_comment": "private boolean isPrototypePropertyAssign(Node assign) {\n    Node n = assign.getFirstChild();\n    if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.getType() == Token.GETPROP) {\n                boolean isChainedProperty = n.getFirstChild().getType() == Token.GETPROP;\n        if (isChainedProperty) {\n            Node child = n.getFirstChild().getFirstChild().getNext();\n            if (child.getType() == Token.STRING && child.getString().equals(\"prototype\")) {\n                return true;\n            }\n        }\n    }\n    return false;\n}", "lc": -0.045454545454545456, "pi": 0.8421052631578947, "ma": 0.0, "nbd": 0.5, "ml": 0.6666666666666666, "d": 0.40873015873015867, "mi": -0.021000704721635077, "fo": 0.4166666666666667, "r": 0.21052631578947367, "e": 0.26356621312448486}
{"project_name": "Lang", "project_version": 57, "label": 1, "code": "// -----------------------------------------------------------------------\n/**\n * <p>Checks if the locale specified is in the list of available locales.</p>\n *\n * @param locale the Locale object to check if it is available\n * @return true if the locale is a known locale\n */\npublic static boolean isAvailableLocale(Locale locale) {\n    return cAvailableLocaleSet.contains(locale);\n}", "code_comment": "/**\n * <p>Checks if the locale specified is in the list of available locales.</p>\n *\n * @param locale the Locale object to check if it is available\n * @return true if the locale is a known locale\n */\n", "code_no_comment": "public static boolean isAvailableLocale(Locale locale) {\n    return cAvailableLocaleSet.contains(locale);\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.0451021846370678, "fo": -0.4166666666666667, "r": 2.6052631578947367, "e": -0.16279340490885932}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-4351_59a83d23", "label": 3, "code": "@Override\npublic IndexRow next() {\n    final IndexRow pathRow = pathCursor.next();\n    return new IndexRow() {\n\n        @Override\n        public boolean isVirtualRow() {\n            return currentRow.isVirutal;\n        }\n\n        @Override\n        public String getPath() {\n            String sub = pathRow.getPath();\n            if (isVirtualRow()) {\n                return sub;\n            } else if (PathUtils.isAbsolute(sub)) {\n                return pathPrefix + sub;\n            } else {\n                return PathUtils.concat(pathPrefix, sub);\n            }\n        }\n\n        @Override\n        public PropertyValue getValue(String columnName) {\n            // overlay the score\n            if (QueryImpl.JCR_SCORE.equals(columnName)) {\n                return PropertyValues.newDouble(currentRow.score);\n            }\n            if (QueryImpl.REP_SPELLCHECK.equals(columnName) || QueryImpl.REP_SUGGEST.equals(columnName)) {\n                return PropertyValues.newString(currentRow.suggestion);\n            }\n            if (QueryImpl.OAK_SCORE_EXPLANATION.equals(columnName)) {\n                return PropertyValues.newString(currentRow.explanation);\n            }\n            if (QueryImpl.REP_EXCERPT.equals(columnName)) {\n                return PropertyValues.newString(currentRow.excerpt);\n            }\n            if (columnName.startsWith(QueryImpl.REP_FACET)) {\n                String facetFieldName = FacetHelper.parseFacetField(columnName);\n                Facets facets = currentRow.facets;\n                try {\n                    if (facets != null) {\n                        FacetResult topChildren = facets.getTopChildren(10, facetFieldName);\n                        if (topChildren != null) {\n                            JsopWriter writer = new JsopBuilder();\n                            writer.object();\n                            for (LabelAndValue lav : topChildren.labelValues) {\n                                writer.key(lav.label).value(lav.value.intValue());\n                            }\n                            writer.endObject();\n                            return PropertyValues.newString(writer.toString());\n                        } else {\n                            return null;\n                        }\n                    }\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return pathRow.getValue(columnName);\n        }\n    };\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic IndexRow next() {\n    final IndexRow pathRow = pathCursor.next();\n    return new IndexRow() {\n\n        @Override\n        public boolean isVirtualRow() {\n            return currentRow.isVirutal;\n        }\n\n        @Override\n        public String getPath() {\n            String sub = pathRow.getPath();\n            if (isVirtualRow()) {\n                return sub;\n            } else if (PathUtils.isAbsolute(sub)) {\n                return pathPrefix + sub;\n            } else {\n                return PathUtils.concat(pathPrefix, sub);\n            }\n        }\n\n        @Override\n        public PropertyValue getValue(String columnName) {\n                        if (QueryImpl.JCR_SCORE.equals(columnName)) {\n                return PropertyValues.newDouble(currentRow.score);\n            }\n            if (QueryImpl.REP_SPELLCHECK.equals(columnName) || QueryImpl.REP_SUGGEST.equals(columnName)) {\n                return PropertyValues.newString(currentRow.suggestion);\n            }\n            if (QueryImpl.OAK_SCORE_EXPLANATION.equals(columnName)) {\n                return PropertyValues.newString(currentRow.explanation);\n            }\n            if (QueryImpl.REP_EXCERPT.equals(columnName)) {\n                return PropertyValues.newString(currentRow.excerpt);\n            }\n            if (columnName.startsWith(QueryImpl.REP_FACET)) {\n                String facetFieldName = FacetHelper.parseFacetField(columnName);\n                Facets facets = currentRow.facets;\n                try {\n                    if (facets != null) {\n                        FacetResult topChildren = facets.getTopChildren(10, facetFieldName);\n                        if (topChildren != null) {\n                            JsopWriter writer = new JsopBuilder();\n                            writer.object();\n                            for (LabelAndValue lav : topChildren.labelValues) {\n                                writer.key(lav.label).value(lav.value.intValue());\n                            }\n                            writer.endObject();\n                            return PropertyValues.newString(writer.toString());\n                        } else {\n                            return null;\n                        }\n                    }\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return pathRow.getValue(columnName);\n        }\n    };\n}", "lc": 2.0454545454545454, "pi": 2.258373205741627, "ma": 1.8, "nbd": 2.0, "ml": 1.4166666666666667, "d": 0.45436507936507936, "mi": -0.9520789288231148, "fo": 1.5833333333333333, "r": -0.02631578947368421, "e": 1.3971519625640403}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-293_25cb587a", "label": 1, "code": "/**\n * Load the configuration from a URI.\n * @param configLocation A URI representing the location of the configuration.\n * @return The ConfigurationSource for the configuration.\n */\nprotected ConfigurationSource getInputFromURI(final URI configLocation) {\n    final File configFile = FileUtils.fileFromURI(configLocation);\n    if (configFile != null && configFile.exists() && configFile.canRead()) {\n        try {\n            return new ConfigurationSource(new FileInputStream(configFile), configFile);\n        } catch (final FileNotFoundException ex) {\n            LOGGER.error(\"Cannot locate file \" + configLocation.getPath(), ex);\n        }\n    }\n    final String scheme = configLocation.getScheme();\n    if (scheme == null || scheme.equals(\"classloader\")) {\n        final ClassLoader loader = this.getClass().getClassLoader();\n        final ConfigurationSource source = getInputFromResource(configLocation.getPath(), loader);\n        if (source != null) {\n            return source;\n        }\n    }\n    try {\n        return new ConfigurationSource(configLocation.toURL().openStream(), configLocation.getPath());\n    } catch (final MalformedURLException ex) {\n        LOGGER.error(\"Invalid URL \" + configLocation.toString(), ex);\n    } catch (final IOException ex) {\n        LOGGER.error(\"Unable to access \" + configLocation.toString(), ex);\n    } catch (final Exception ex) {\n        LOGGER.error(\"Unable to access \" + configLocation.toString(), ex);\n    }\n    return null;\n}", "code_comment": "/**\n * Load the configuration from a URI.\n * @param configLocation A URI representing the location of the configuration.\n * @return The ConfigurationSource for the configuration.\n */\n", "code_no_comment": "protected ConfigurationSource getInputFromURI(final URI configLocation) {\n    final File configFile = FileUtils.fileFromURI(configLocation);\n    if (configFile != null && configFile.exists() && configFile.canRead()) {\n        try {\n            return new ConfigurationSource(new FileInputStream(configFile), configFile);\n        } catch (final FileNotFoundException ex) {\n            LOGGER.error(\"Cannot locate file \" + configLocation.getPath(), ex);\n        }\n    }\n    final String scheme = configLocation.getScheme();\n    if (scheme == null || scheme.equals(\"classloader\")) {\n        final ClassLoader loader = this.getClass().getClassLoader();\n        final ConfigurationSource source = getInputFromResource(configLocation.getPath(), loader);\n        if (source != null) {\n            return source;\n        }\n    }\n    try {\n        return new ConfigurationSource(configLocation.toURL().openStream(), configLocation.getPath());\n    } catch (final MalformedURLException ex) {\n        LOGGER.error(\"Invalid URL \" + configLocation.toString(), ex);\n    } catch (final IOException ex) {\n        LOGGER.error(\"Unable to access \" + configLocation.toString(), ex);\n    } catch (final Exception ex) {\n        LOGGER.error(\"Unable to access \" + configLocation.toString(), ex);\n    }\n    return null;\n}", "lc": 0.6363636363636364, "pi": 0.057416267942583574, "ma": 0.8, "nbd": 0.0, "ml": 0.5833333333333334, "d": 0.9027777777777778, "mi": -0.5123326286116981, "fo": 1.1666666666666667, "r": -0.02631578947368421, "e": 1.366271906317894}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-209_76d727f0", "label": 1, "code": "@Override\npublic boolean validateOptions(Map<String, String> options) {\n    super.validateOptions(options);\n    if (options.containsKey(ROW_REGEX))\n        Pattern.compile(options.get(ROW_REGEX)).matcher(\"\");\n    if (options.containsKey(COLF_REGEX))\n        Pattern.compile(options.get(COLF_REGEX)).matcher(\"\");\n    if (options.containsKey(COLQ_REGEX))\n        Pattern.compile(options.get(COLQ_REGEX)).matcher(\"\");\n    if (options.containsKey(VALUE_REGEX))\n        Pattern.compile(options.get(VALUE_REGEX)).matcher(\"\");\n    return true;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean validateOptions(Map<String, String> options) {\n    super.validateOptions(options);\n    if (options.containsKey(ROW_REGEX))\n        Pattern.compile(options.get(ROW_REGEX)).matcher(\"\");\n    if (options.containsKey(COLF_REGEX))\n        Pattern.compile(options.get(COLF_REGEX)).matcher(\"\");\n    if (options.containsKey(COLQ_REGEX))\n        Pattern.compile(options.get(COLQ_REGEX)).matcher(\"\");\n    if (options.containsKey(VALUE_REGEX))\n        Pattern.compile(options.get(VALUE_REGEX)).matcher(\"\");\n    return true;\n}", "lc": -0.045454545454545456, "pi": -0.03349282296650732, "ma": 0.2, "nbd": -1.0, "ml": 0.25, "d": -0.3650793650793651, "mi": -0.006060606060606155, "fo": 0.9166666666666666, "r": -0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5147_184e51e9", "label": 1, "code": "/**\n *  Servlets and Filters are treated essentially the same with Wicket. This is the entry point\n *  for both of them.\n *\n *  @see #init(FilterConfig)\n *\n *  @param isServlet\n *             True if Servlet, false if Filter\n *  @param filterConfig\n *  @throws ServletException\n */\npublic void init(final boolean isServlet, final FilterConfig filterConfig) throws ServletException {\n    this.filterConfig = filterConfig;\n    this.isServlet = isServlet;\n    initIgnorePaths(filterConfig);\n    final ClassLoader previousClassLoader = Thread.currentThread().getContextClassLoader();\n    final ClassLoader newClassLoader = getClassLoader();\n    try {\n        if (previousClassLoader != newClassLoader) {\n            Thread.currentThread().setContextClassLoader(newClassLoader);\n        }\n        // locate application instance unless it was already specified during construction\n        if (application == null) {\n            applicationFactory = getApplicationFactory();\n            application = applicationFactory.createApplication(this);\n        }\n        application.setName(filterConfig.getFilterName());\n        application.setWicketFilter(this);\n        // Allow the filterPath to be preset via setFilterPath()\n        String configureFilterPath = getFilterPath();\n        if (configureFilterPath == null) {\n            configureFilterPath = getFilterPathFromConfig(filterConfig);\n            if (configureFilterPath == null) {\n                configureFilterPath = getFilterPathFromWebXml(isServlet, filterConfig);\n                if (configureFilterPath == null) {\n                    configureFilterPath = getFilterPathFromAnnotation(isServlet);\n                }\n            }\n            if (configureFilterPath != null) {\n                setFilterPath(configureFilterPath);\n            }\n        }\n        if (getFilterPath() == null) {\n            log.warn(\"Unable to determine filter path from filter init-param, web.xml, \" + \"or servlet 3.0 annotations. Assuming user will set filter path \" + \"manually by calling setFilterPath(String)\");\n        }\n        ThreadContext.setApplication(application);\n        try {\n            application.initApplication();\n            // Give the application the option to log that it is started\n            application.logStarted();\n        } finally {\n            ThreadContext.detach();\n        }\n    } finally {\n        if (newClassLoader != previousClassLoader) {\n            Thread.currentThread().setContextClassLoader(previousClassLoader);\n        }\n    }\n}", "code_comment": "/**\n *  Servlets and Filters are treated essentially the same with Wicket. This is the entry point\n *  for both of them.\n *\n *  @see #init(FilterConfig)\n *\n *  @param isServlet\n *             True if Servlet, false if Filter\n *  @param filterConfig\n *  @throws ServletException\n */\n", "code_no_comment": "public void init(final boolean isServlet, final FilterConfig filterConfig) throws ServletException {\n    this.filterConfig = filterConfig;\n    this.isServlet = isServlet;\n    initIgnorePaths(filterConfig);\n    final ClassLoader previousClassLoader = Thread.currentThread().getContextClassLoader();\n    final ClassLoader newClassLoader = getClassLoader();\n    try {\n        if (previousClassLoader != newClassLoader) {\n            Thread.currentThread().setContextClassLoader(newClassLoader);\n        }\n                if (application == null) {\n            applicationFactory = getApplicationFactory();\n            application = applicationFactory.createApplication(this);\n        }\n        application.setName(filterConfig.getFilterName());\n        application.setWicketFilter(this);\n                String configureFilterPath = getFilterPath();\n        if (configureFilterPath == null) {\n            configureFilterPath = getFilterPathFromConfig(filterConfig);\n            if (configureFilterPath == null) {\n                configureFilterPath = getFilterPathFromWebXml(isServlet, filterConfig);\n                if (configureFilterPath == null) {\n                    configureFilterPath = getFilterPathFromAnnotation(isServlet);\n                }\n            }\n            if (configureFilterPath != null) {\n                setFilterPath(configureFilterPath);\n            }\n        }\n        if (getFilterPath() == null) {\n            log.warn(\"Unable to determine filter path from filter init-param, web.xml, \" + \"or servlet 3.0 annotations. Assuming user will set filter path \" + \"manually by calling setFilterPath(String)\");\n        }\n        ThreadContext.setApplication(application);\n        try {\n            application.initApplication();\n                        application.logStarted();\n        } finally {\n            ThreadContext.detach();\n        }\n    } finally {\n        if (newClassLoader != previousClassLoader) {\n            Thread.currentThread().setContextClassLoader(previousClassLoader);\n        }\n    }\n}", "lc": 1.4090909090909092, "pi": 0.6028708133971291, "ma": 1.0, "nbd": 1.0, "ml": 0.6666666666666666, "d": 0.4682539682539683, "mi": -0.7471458773784352, "fo": 1.5, "r": -0.02631578947368421, "e": 0.9260536067264856}
{"project_name": "Closure", "project_version": 128, "label": 2, "code": "static boolean isSimpleNumber(String s) {\n    int len = s.length();\n    for (int index = 0; index < len; index++) {\n        char c = s.charAt(index);\n        if (c < '0' || c > '9') {\n            return false;\n        }\n    }\n    return len > 0 && s.charAt(0) != '0';\n}", "code_comment": NaN, "code_no_comment": "static boolean isSimpleNumber(String s) {\n    int len = s.length();\n    for (int index = 0; index < len; index++) {\n        char c = s.charAt(index);\n        if (c < '0' || c > '9') {\n            return false;\n        }\n    }\n    return len > 0 && s.charAt(0) != '0';\n}", "lc": -0.18181818181818182, "pi": 0.29186602870813394, "ma": -0.2, "nbd": 0.0, "ml": 0.08333333333333333, "d": 0.9742063492063492, "mi": 0.16138125440451, "fo": -0.25, "r": 0.47368421052631576, "e": 0.33954461368233596}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4016_f1c9cef2", "label": 1, "code": "/**\n *  @param detailed\n *             True if a detailed string is desired\n *  @return String representation of this container\n */\n@Override\npublic String toString(final boolean detailed) {\n    final StringBuilder buffer = new StringBuilder();\n    buffer.append(\"[\").append(this.getClass().getSimpleName()).append(\" \");\n    buffer.append(super.toString(detailed));\n    if (detailed) {\n        if (getMarkup() != null) {\n            buffer.append(\", markup = \").append(new MarkupStream(getMarkup()).toString());\n        }\n        if (children_size() != 0) {\n            buffer.append(\", children = \");\n            // Loop through child components\n            final int size = children_size();\n            for (int i = 0; i < size; i++) {\n                // Get next child\n                final Component child = children_get(i);\n                if (i != 0) {\n                    buffer.append(' ');\n                }\n                buffer.append(child.toString());\n            }\n        }\n    }\n    buffer.append(']');\n    return buffer.toString();\n}", "code_comment": "/**\n *  @param detailed\n *             True if a detailed string is desired\n *  @return String representation of this container\n */\n", "code_no_comment": "@Override\npublic String toString(final boolean detailed) {\n    final StringBuilder buffer = new StringBuilder();\n    buffer.append(\"[\").append(this.getClass().getSimpleName()).append(\" \");\n    buffer.append(super.toString(detailed));\n    if (detailed) {\n        if (getMarkup() != null) {\n            buffer.append(\", markup = \").append(new MarkupStream(getMarkup()).toString());\n        }\n        if (children_size() != 0) {\n            buffer.append(\", children = \");\n                        final int size = children_size();\n            for (int i = 0; i < size; i++) {\n                                final Component child = children_get(i);\n                if (i != 0) {\n                    buffer.append(' ');\n                }\n                buffer.append(child.toString());\n            }\n        }\n    }\n    buffer.append(']');\n    return buffer.toString();\n}", "lc": 0.45454545454545453, "pi": 1.291866028708134, "ma": 0.4, "nbd": 1.0, "ml": 0.4166666666666667, "d": 0.5873015873015873, "mi": -0.3649048625792809, "fo": 1.25, "r": 0.0, "e": 0.5789918339355589}
{"project_name": "Lang", "project_version": 30, "label": 3, "code": "/**\n * <p>\n * Checks if the CharSequence contains any character in the given set of characters.\n * </p>\n *\n * <p>\n * A <code>null</code> CharSequence will return <code>false</code>. A <code>null</code> search CharSequence will return\n * <code>false</code>.\n * </p>\n *\n * <pre>\n * StringUtils.containsAny(null, *)            = false\n * StringUtils.containsAny(\"\", *)              = false\n * StringUtils.containsAny(*, null)            = false\n * StringUtils.containsAny(*, \"\")              = false\n * StringUtils.containsAny(\"zzabyycdxx\", \"za\") = true\n * StringUtils.containsAny(\"zzabyycdxx\", \"by\") = true\n * StringUtils.containsAny(\"aba\",\"z\")          = false\n * </pre>\n *\n * @param cs\n *            the CharSequence to check, may be null\n * @param searchChars\n *            the chars to search for, may be null\n * @return the <code>true</code> if any of the chars are found, <code>false</code> if no match or null input\n * @since 2.4\n */\npublic static boolean containsAny(CharSequence cs, String searchChars) {\n    if (searchChars == null) {\n        return false;\n    }\n    return containsAny(cs, searchChars.toCharArray());\n}", "code_comment": "/**\n * <p>\n * Checks if the CharSequence contains any character in the given set of characters.\n * </p>\n *\n * <p>\n * A <code>null</code> CharSequence will return <code>false</code>. A <code>null</code> search CharSequence will return\n * <code>false</code>.\n * </p>\n *\n * <pre>\n * StringUtils.containsAny(null, *)            = false\n * StringUtils.containsAny(\"\", *)              = false\n * StringUtils.containsAny(*, null)            = false\n * StringUtils.containsAny(*, \"\")              = false\n * StringUtils.containsAny(\"zzabyycdxx\", \"za\") = true\n * StringUtils.containsAny(\"zzabyycdxx\", \"by\") = true\n * StringUtils.containsAny(\"aba\",\"z\")          = false\n * </pre>\n *\n * @param cs\n *            the CharSequence to check, may be null\n * @param searchChars\n *            the chars to search for, may be null\n * @return the <code>true</code> if any of the chars are found, <code>false</code> if no match or null input\n * @since 2.4\n */\n", "code_no_comment": "public static boolean containsAny(CharSequence cs, String searchChars) {\n    if (searchChars == null) {\n        return false;\n    }\n    return containsAny(cs, searchChars.toCharArray());\n}", "lc": -0.36363636363636365, "pi": -0.11483253588516758, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": -0.3650793650793651, "mi": 0.5836504580690626, "fo": -0.3333333333333333, "r": 0.05263157894736841, "e": -0.16279340490885932}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3510_292a2582", "label": 1, "code": "/**\n *  create a new {@link DateTextField} instance to be added to this panel.\n *\n *  @param id\n *             the component id\n *  @param dateFieldModel\n *             model that should be used by the {@link DateTextField}\n *  @return a new date text field instance\n */\nprotected DateTextField newDateTextField(String id, PropertyModel<Date> dateFieldModel) {\n    return DateTextField.forShortStyle(id, dateFieldModel);\n}", "code_comment": "/**\n *  create a new {@link DateTextField} instance to be added to this panel.\n *\n *  @param id\n *             the component id\n *  @param dateFieldModel\n *             model that should be used by the {@link DateTextField}\n *  @return a new date text field instance\n */\n", "code_no_comment": "protected DateTextField newDateTextField(String id, PropertyModel<Date> dateFieldModel) {\n    return DateTextField.forShortStyle(id, dateFieldModel);\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.9360112755461594, "fo": -0.4166666666666667, "r": 2.552631578947368, "e": -0.16279340490885932}
{"project_name": "maven", "project_version": "remotes/origin/bugs-dot-jar_MNG-5742_6ab41ee8", "label": 1, "code": "public ExtensionRealmCache.CacheRecord setupExtensionsRealm(MavenProject project, Plugin plugin, RepositorySystemSession session) throws PluginManagerException {\n    @SuppressWarnings(\"unchecked\")\n    Map<String, ExtensionRealmCache.CacheRecord> pluginRealms = (Map<String, ExtensionRealmCache.CacheRecord>) project.getContextValue(KEY_EXTENSIONS_REALMS);\n    if (pluginRealms == null) {\n        pluginRealms = new HashMap<String, ExtensionRealmCache.CacheRecord>();\n        project.setContextValue(KEY_EXTENSIONS_REALMS, pluginRealms);\n    }\n    final String pluginKey = plugin.getId();\n    ExtensionRealmCache.CacheRecord extensionRecord = pluginRealms.get(pluginKey);\n    if (extensionRecord != null) {\n        return extensionRecord;\n    }\n    final List<RemoteRepository> repositories = project.getRemotePluginRepositories();\n    // resolve plugin version as necessary\n    if (plugin.getVersion() == null) {\n        PluginVersionRequest versionRequest = new DefaultPluginVersionRequest(plugin, session, repositories);\n        try {\n            plugin.setVersion(pluginVersionResolver.resolve(versionRequest).getVersion());\n        } catch (PluginVersionResolutionException e) {\n            throw new PluginManagerException(plugin, e.getMessage(), e);\n        }\n    }\n    // resolve plugin artifacts\n    List<Artifact> artifacts;\n    PluginArtifactsCache.Key cacheKey = pluginArtifactsCache.createKey(plugin, null, repositories, session);\n    PluginArtifactsCache.CacheRecord recordArtifacts;\n    try {\n        recordArtifacts = pluginArtifactsCache.get(cacheKey);\n    } catch (PluginResolutionException e) {\n        throw new PluginManagerException(plugin, e.getMessage(), e);\n    }\n    if (recordArtifacts != null) {\n        artifacts = recordArtifacts.artifacts;\n    } else {\n        try {\n            artifacts = resolveExtensionArtifacts(plugin, repositories, session);\n            recordArtifacts = pluginArtifactsCache.put(cacheKey, artifacts);\n        } catch (PluginResolutionException e) {\n            pluginArtifactsCache.put(cacheKey, e);\n            pluginArtifactsCache.register(project, cacheKey, recordArtifacts);\n            throw new PluginManagerException(plugin, e.getMessage(), e);\n        }\n    }\n    pluginArtifactsCache.register(project, cacheKey, recordArtifacts);\n    // create and cache extensions realms\n    final ExtensionRealmCache.Key extensionKey = extensionRealmCache.createKey(artifacts);\n    extensionRecord = extensionRealmCache.get(extensionKey);\n    if (extensionRecord == null) {\n        ClassRealm extensionRealm = classRealmManager.createExtensionRealm(plugin, toAetherArtifacts(artifacts));\n        PluginDescriptor pluginDescriptor = null;\n        if (plugin.isExtensions() && !artifacts.isEmpty()) {\n            // these errors will reported during calculation of project build execution plan\n            try {\n                pluginDescriptor = extractPluginDescriptor(artifacts.get(0), plugin);\n            } catch (PluginDescriptorParsingException e) {\n            // ignore, see above\n            } catch (InvalidPluginDescriptorException e) {\n            // ignore, see above\n            }\n        }\n        discoverPluginComponents(extensionRealm, plugin, pluginDescriptor);\n        ExtensionDescriptor extensionDescriptor = null;\n        Artifact extensionArtifact = artifacts.get(0);\n        try {\n            extensionDescriptor = extensionDescriptorBuilder.build(extensionArtifact.getFile());\n        } catch (IOException e) {\n            String message = \"Invalid extension descriptor for \" + plugin.getId() + \": \" + e.getMessage();\n            if (logger.isDebugEnabled()) {\n                logger.error(message, e);\n            } else {\n                logger.error(message);\n            }\n        }\n        extensionRecord = extensionRealmCache.put(extensionKey, extensionRealm, extensionDescriptor, artifacts);\n    }\n    extensionRealmCache.register(project, extensionKey, extensionRecord);\n    pluginRealms.put(pluginKey, extensionRecord);\n    return extensionRecord;\n}", "code_comment": NaN, "code_no_comment": "public ExtensionRealmCache.CacheRecord setupExtensionsRealm(MavenProject project, Plugin plugin, RepositorySystemSession session) throws PluginManagerException {\n    @SuppressWarnings(\"unchecked\")\n    Map<String, ExtensionRealmCache.CacheRecord> pluginRealms = (Map<String, ExtensionRealmCache.CacheRecord>) project.getContextValue(KEY_EXTENSIONS_REALMS);\n    if (pluginRealms == null) {\n        pluginRealms = new HashMap<String, ExtensionRealmCache.CacheRecord>();\n        project.setContextValue(KEY_EXTENSIONS_REALMS, pluginRealms);\n    }\n    final String pluginKey = plugin.getId();\n    ExtensionRealmCache.CacheRecord extensionRecord = pluginRealms.get(pluginKey);\n    if (extensionRecord != null) {\n        return extensionRecord;\n    }\n    final List<RemoteRepository> repositories = project.getRemotePluginRepositories();\n        if (plugin.getVersion() == null) {\n        PluginVersionRequest versionRequest = new DefaultPluginVersionRequest(plugin, session, repositories);\n        try {\n            plugin.setVersion(pluginVersionResolver.resolve(versionRequest).getVersion());\n        } catch (PluginVersionResolutionException e) {\n            throw new PluginManagerException(plugin, e.getMessage(), e);\n        }\n    }\n        List<Artifact> artifacts;\n    PluginArtifactsCache.Key cacheKey = pluginArtifactsCache.createKey(plugin, null, repositories, session);\n    PluginArtifactsCache.CacheRecord recordArtifacts;\n    try {\n        recordArtifacts = pluginArtifactsCache.get(cacheKey);\n    } catch (PluginResolutionException e) {\n        throw new PluginManagerException(plugin, e.getMessage(), e);\n    }\n    if (recordArtifacts != null) {\n        artifacts = recordArtifacts.artifacts;\n    } else {\n        try {\n            artifacts = resolveExtensionArtifacts(plugin, repositories, session);\n            recordArtifacts = pluginArtifactsCache.put(cacheKey, artifacts);\n        } catch (PluginResolutionException e) {\n            pluginArtifactsCache.put(cacheKey, e);\n            pluginArtifactsCache.register(project, cacheKey, recordArtifacts);\n            throw new PluginManagerException(plugin, e.getMessage(), e);\n        }\n    }\n    pluginArtifactsCache.register(project, cacheKey, recordArtifacts);\n        final ExtensionRealmCache.Key extensionKey = extensionRealmCache.createKey(artifacts);\n    extensionRecord = extensionRealmCache.get(extensionKey);\n    if (extensionRecord == null) {\n        ClassRealm extensionRealm = classRealmManager.createExtensionRealm(plugin, toAetherArtifacts(artifacts));\n        PluginDescriptor pluginDescriptor = null;\n        if (plugin.isExtensions() && !artifacts.isEmpty()) {\n                        try {\n                pluginDescriptor = extractPluginDescriptor(artifacts.get(0), plugin);\n            } catch (PluginDescriptorParsingException e) {\n                        } catch (InvalidPluginDescriptorException e) {\n                        }\n        }\n        discoverPluginComponents(extensionRealm, plugin, pluginDescriptor);\n        ExtensionDescriptor extensionDescriptor = null;\n        Artifact extensionArtifact = artifacts.get(0);\n        try {\n            extensionDescriptor = extensionDescriptorBuilder.build(extensionArtifact.getFile());\n        } catch (IOException e) {\n            String message = \"Invalid extension descriptor for \" + plugin.getId() + \": \" + e.getMessage();\n            if (logger.isDebugEnabled()) {\n                logger.error(message, e);\n            } else {\n                logger.error(message);\n            }\n        }\n        extensionRecord = extensionRealmCache.put(extensionKey, extensionRealm, extensionDescriptor, artifacts);\n    }\n    extensionRealmCache.register(project, extensionKey, extensionRecord);\n    pluginRealms.put(pluginKey, extensionRecord);\n    return extensionRecord;\n}", "lc": 2.6818181818181817, "pi": 0.3444976076555023, "ma": 2.6, "nbd": 0.5, "ml": 0.8333333333333334, "d": 1.3234126984126984, "mi": -1.1773079633544747, "fo": 2.75, "r": -0.02631578947368421, "e": 6.293581830650691}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4755_87ae870f", "label": 1, "code": "/**\n *  @see org.apache.wicket.util.convert.IConverter#convertToObject(java.lang.String,\n *       java.util.Locale)\n */\n@Override\npublic C convertToObject(String value, Locale locale) {\n    if (value == null) {\n        return null;\n    }\n    Class<C> theType = type.get();\n    if (\"\".equals(value)) {\n        if (String.class.equals(theType)) {\n            return theType.cast(\"\");\n        }\n        return null;\n    }\n    try {\n        C converted = Objects.convertValue(value, theType);\n        if (converted != null) {\n            return converted;\n        } else {\n            throw new ConversionException(\"Could not convert value: \" + value + \" to type: \" + theType.getName() + \". Could not find compatible converter.\").setSourceValue(value);\n        }\n    } catch (Exception e) {\n        throw new ConversionException(e.getMessage(), e).setSourceValue(value);\n    }\n}", "code_comment": "/**\n *  @see org.apache.wicket.util.convert.IConverter#convertToObject(java.lang.String,\n *       java.util.Locale)\n */\n", "code_no_comment": "@Override\npublic C convertToObject(String value, Locale locale) {\n    if (value == null) {\n        return null;\n    }\n    Class<C> theType = type.get();\n    if (\"\".equals(value)) {\n        if (String.class.equals(theType)) {\n            return theType.cast(\"\");\n        }\n        return null;\n    }\n    try {\n        C converted = Objects.convertValue(value, theType);\n        if (converted != null) {\n            return converted;\n        } else {\n            throw new ConversionException(\"Could not convert value: \" + value + \" to type: \" + theType.getName() + \". Could not find compatible converter.\").setSourceValue(value);\n        }\n    } catch (Exception e) {\n        throw new ConversionException(e.getMessage(), e).setSourceValue(value);\n    }\n}", "lc": 0.4090909090909091, "pi": 0.24880382775119597, "ma": 0.8, "nbd": 0.0, "ml": 0.3333333333333333, "d": 0.371031746031746, "mi": -0.33474277660324164, "fo": 0.25, "r": -0.02631578947368421, "e": 0.3252433394996628}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-843_65390f8c", "label": 3, "code": "@Override\npublic void offline(String tableName) throws AccumuloSecurityException, AccumuloException {\n    throw new NotImplementedException();\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void offline(String tableName) throws AccumuloSecurityException, AccumuloException {\n    throw new NotImplementedException();\n}", "lc": -0.45454545454545453, "pi": -0.6028708133971293, "ma": -0.4, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.8658210007047216, "fo": -0.5, "r": 1.4736842105263157, "e": -0.16279340490885932}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-1886_5226978a", "label": 1, "code": "/**\n *  Reset the request and the response back to a starting state and recreate the necessary wicket\n *  request, response and session objects. The request and response objects can be accessed and\n *  Initialized at this point.\n *\n *  @param isAjax\n *             indicates whether the request should be initialized as an ajax request (ajax\n *             header \"Wicket-Ajax\" is set)\n *  @return the constructed {@link WebRequestCycle}\n */\npublic WebRequestCycle setupRequestAndResponse(boolean isAjax) {\n    servletRequest.initialize();\n    servletResponse.initialize();\n    servletRequest.setParameters(parametersForNextRequest);\n    if (isAjax) {\n        servletRequest.addHeader(\"Wicket-Ajax\", \"Yes\");\n    }\n    parametersForNextRequest.clear();\n    wicketRequest = application.newWebRequest(servletRequest);\n    wicketResponse = application.newWebResponse(servletResponse);\n    WebRequestCycle requestCycle = createRequestCycle();\n    if (!initializeHttpSessionAsTemporary())\n        application.getSessionStore().bind(wicketRequest, wicketSession);\n    wicketResponse.setAjax(wicketRequest.isAjax());\n    return requestCycle;\n}", "code_comment": "/**\n *  Reset the request and the response back to a starting state and recreate the necessary wicket\n *  request, response and session objects. The request and response objects can be accessed and\n *  Initialized at this point.\n *\n *  @param isAjax\n *             indicates whether the request should be initialized as an ajax request (ajax\n *             header \"Wicket-Ajax\" is set)\n *  @return the constructed {@link WebRequestCycle}\n */\n", "code_no_comment": "public WebRequestCycle setupRequestAndResponse(boolean isAjax) {\n    servletRequest.initialize();\n    servletResponse.initialize();\n    servletRequest.setParameters(parametersForNextRequest);\n    if (isAjax) {\n        servletRequest.addHeader(\"Wicket-Ajax\", \"Yes\");\n    }\n    parametersForNextRequest.clear();\n    wicketRequest = application.newWebRequest(servletRequest);\n    wicketResponse = application.newWebResponse(servletResponse);\n    WebRequestCycle requestCycle = createRequestCycle();\n    if (!initializeHttpSessionAsTemporary())\n        application.getSessionStore().bind(wicketRequest, wicketSession);\n    wicketResponse.setAjax(wicketRequest.isAjax());\n    return requestCycle;\n}", "lc": 0.09090909090909091, "pi": -0.47368421052631593, "ma": -0.2, "nbd": -0.5, "ml": -0.08333333333333333, "d": -0.047619047619047616, "mi": -0.09119097956307255, "fo": 0.5833333333333334, "r": -0.02631578947368421, "e": -0.008466889115563933}
{"project_name": "Closure", "project_version": 115, "label": 2, "code": "/**\n * Determines whether a function can be inlined at a particular call site.\n * There are several criteria that the function and reference must hold in\n * order for the functions to be inlined:\n * 1) If a call's arguments have side effects,\n * the corresponding argument in the function must only be referenced once.\n * For instance, this will not be inlined:\n * <pre>\n *     function foo(a) { return a + a }\n *     x = foo(i++);\n * </pre>\n */\nprivate CanInlineResult canInlineReferenceDirectly(Node callNode, Node fnNode) {\n    if (!isDirectCallNodeReplacementPossible(fnNode)) {\n        return CanInlineResult.NO;\n    }\n    Node block = fnNode.getLastChild();\n    boolean hasSideEffects = false;\n    if (block.hasChildren()) {\n        Preconditions.checkState(block.hasOneChild());\n        Node stmt = block.getFirstChild();\n        if (stmt.isReturn()) {\n            hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler);\n        }\n    }\n    // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n    Node cArg = callNode.getFirstChild().getNext();\n    // parameter list.\n    if (!callNode.getFirstChild().isName()) {\n        if (NodeUtil.isFunctionObjectCall(callNode)) {\n            // TODO(johnlenz): Support replace this with a value.\n            if (cArg == null || !cArg.isThis()) {\n                return CanInlineResult.NO;\n            }\n            cArg = cArg.getNext();\n        } else {\n            // \".apply\" call should be filtered before this.\n            Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n        }\n    }\n    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]\n    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n    while (cArg != null || fnParam != null) {\n        // For each named parameter check if a mutable argument use more than one.\n        if (fnParam != null) {\n            if (cArg != null) {\n                if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n                    return CanInlineResult.NO;\n                }\n                // parameter reference will be in a loop.\n                if (NodeUtil.mayEffectMutableState(cArg, compiler) && NodeUtil.getNameReferenceCount(block, fnParam.getString()) > 1) {\n                    return CanInlineResult.NO;\n                }\n            }\n            // Move to the next name.\n            fnParam = fnParam.getNext();\n        }\n        // isn't a named parameter to match.\n        if (cArg != null) {\n            if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n                return CanInlineResult.NO;\n            }\n            cArg = cArg.getNext();\n        }\n    }\n    return CanInlineResult.YES;\n}", "code_comment": "/**\n * Determines whether a function can be inlined at a particular call site.\n * There are several criteria that the function and reference must hold in\n * order for the functions to be inlined:\n * 1) If a call's arguments have side effects,\n * the corresponding argument in the function must only be referenced once.\n * For instance, this will not be inlined:\n * <pre>\n *     function foo(a) { return a + a }\n *     x = foo(i++);\n * </pre>\n */\n", "code_no_comment": "private CanInlineResult canInlineReferenceDirectly(Node callNode, Node fnNode) {\n    if (!isDirectCallNodeReplacementPossible(fnNode)) {\n        return CanInlineResult.NO;\n    }\n    Node block = fnNode.getLastChild();\n    boolean hasSideEffects = false;\n    if (block.hasChildren()) {\n        Preconditions.checkState(block.hasOneChild());\n        Node stmt = block.getFirstChild();\n        if (stmt.isReturn()) {\n            hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler);\n        }\n    }\n        Node cArg = callNode.getFirstChild().getNext();\n        if (!callNode.getFirstChild().isName()) {\n        if (NodeUtil.isFunctionObjectCall(callNode)) {\n                        if (cArg == null || !cArg.isThis()) {\n                return CanInlineResult.NO;\n            }\n            cArg = cArg.getNext();\n        } else {\n                        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n        }\n    }\n        Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n    while (cArg != null || fnParam != null) {\n                if (fnParam != null) {\n            if (cArg != null) {\n                if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n                    return CanInlineResult.NO;\n                }\n                                if (NodeUtil.mayEffectMutableState(cArg, compiler) && NodeUtil.getNameReferenceCount(block, fnParam.getString()) > 1) {\n                    return CanInlineResult.NO;\n                }\n            }\n                        fnParam = fnParam.getNext();\n        }\n                if (cArg != null) {\n            if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n                return CanInlineResult.NO;\n            }\n            cArg = cArg.getNext();\n        }\n    }\n    return CanInlineResult.YES;\n}", "lc": 1.4545454545454546, "pi": 0.9425837320574162, "ma": 2.0, "nbd": 1.0, "ml": 2.5, "d": 1.373015873015873, "mi": -0.8260747004933048, "fo": 1.75, "r": -0.02631578947368421, "e": 2.7465661612581616}
{"project_name": "Lang", "project_version": 46, "label": 0, "code": "// Java and JavaScript\n// --------------------------------------------------------------------------\n/**\n * <p>Escapes the characters in a <code>String</code> using Java String rules.</p>\n *\n * <p>Deals correctly with quotes and control-chars (tab, backslash, cr, ff, etc.) </p>\n *\n * <p>So a tab becomes the characters <code>'\\\\'</code> and\n * <code>'t'</code>.</p>\n *\n * <p>The only difference between Java strings and JavaScript strings\n * is that in JavaScript, a single quote must be escaped.</p>\n *\n * <p>Example:\n * <pre>\n * input string: He didn't say, \"Stop!\"\n * output string: He didn't say, \\\"Stop!\\\"\n * </pre>\n * </p>\n *\n * @param str  String to escape values in, may be null\n * @return String with escaped values, <code>null</code> if null string input\n */\npublic static String escapeJava(String str) {\n    return escapeJavaStyleString(str, false);\n}", "code_comment": "/**\n * <p>Escapes the characters in a <code>String</code> using Java String rules.</p>\n *\n * <p>Deals correctly with quotes and control-chars (tab, backslash, cr, ff, etc.) </p>\n *\n * <p>So a tab becomes the characters <code>'\\\\'</code> and\n * <code>'t'</code>.</p>\n *\n * <p>The only difference between Java strings and JavaScript strings\n * is that in JavaScript, a single quote must be escaped.</p>\n *\n * <p>Example:\n * <pre>\n * input string: He didn't say, \"Stop!\"\n * output string: He didn't say, \\\"Stop!\\\"\n * </pre>\n * </p>\n *\n * @param str  String to escape values in, may be null\n * @return String with escaped values, <code>null</code> if null string input\n */\n", "code_no_comment": "public static String escapeJava(String str) {\n    return escapeJavaStyleString(str, false);\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.0253699788583508, "fo": -0.4166666666666667, "r": 1.0789473684210527, "e": -0.16279340490885932}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4686_89184b79", "label": 1, "code": "/**\n *  Creates a {@code IRequestHandler} that processes a listener request.\n *\n *  @param pageComponentInfo\n *  @param pageClass\n *  @param pageParameters\n *  @return a {@code IRequestHandler} that invokes the listener interface\n */\nprotected IRequestHandler processListener(PageComponentInfo pageComponentInfo, Class<? extends IRequestablePage> pageClass, PageParameters pageParameters) {\n    PageInfo pageInfo = pageComponentInfo.getPageInfo();\n    ComponentInfo componentInfo = pageComponentInfo.getComponentInfo();\n    Integer renderCount = null;\n    RequestListenerInterface listenerInterface = null;\n    if (componentInfo != null) {\n        renderCount = componentInfo.getRenderCount();\n        listenerInterface = requestListenerInterfaceFromString(componentInfo.getListenerInterface());\n    }\n    if (listenerInterface != null) {\n        // if (pageInfo.getPageId() != null)\n        // {\n        // // WICKET-4594 - ignore the parsed parameters for stateful pages\n        // pageParameters = null;\n        // }\n        PageAndComponentProvider provider = new PageAndComponentProvider(pageInfo.getPageId(), pageClass, pageParameters, renderCount, componentInfo.getComponentPath());\n        provider.setPageSource(getContext());\n        return new ListenerInterfaceRequestHandler(provider, listenerInterface, componentInfo.getBehaviorId());\n    } else {\n        if (logger.isWarnEnabled()) {\n            if (componentInfo != null) {\n                logger.warn(\"Unknown listener interface '{}'\", componentInfo.getListenerInterface());\n            } else {\n                logger.warn(\"Cannot extract the listener interface for PageComponentInfo: '{}'\" + pageComponentInfo);\n            }\n        }\n        return null;\n    }\n}", "code_comment": "/**\n *  Creates a {@code IRequestHandler} that processes a listener request.\n *\n *  @param pageComponentInfo\n *  @param pageClass\n *  @param pageParameters\n *  @return a {@code IRequestHandler} that invokes the listener interface\n */\n", "code_no_comment": "protected IRequestHandler processListener(PageComponentInfo pageComponentInfo, Class<? extends IRequestablePage> pageClass, PageParameters pageParameters) {\n    PageInfo pageInfo = pageComponentInfo.getPageInfo();\n    ComponentInfo componentInfo = pageComponentInfo.getComponentInfo();\n    Integer renderCount = null;\n    RequestListenerInterface listenerInterface = null;\n    if (componentInfo != null) {\n        renderCount = componentInfo.getRenderCount();\n        listenerInterface = requestListenerInterfaceFromString(componentInfo.getListenerInterface());\n    }\n    if (listenerInterface != null) {\n                                                PageAndComponentProvider provider = new PageAndComponentProvider(pageInfo.getPageId(), pageClass, pageParameters, renderCount, componentInfo.getComponentPath());\n        provider.setPageSource(getContext());\n        return new ListenerInterfaceRequestHandler(provider, listenerInterface, componentInfo.getBehaviorId());\n    } else {\n        if (logger.isWarnEnabled()) {\n            if (componentInfo != null) {\n                logger.warn(\"Unknown listener interface '{}'\", componentInfo.getListenerInterface());\n            } else {\n                logger.warn(\"Cannot extract the listener interface for PageComponentInfo: '{}'\" + pageComponentInfo);\n            }\n        }\n        return null;\n    }\n}", "lc": 0.45454545454545453, "pi": 0.5789473684210527, "ma": 0.2, "nbd": 0.5, "ml": 0.16666666666666666, "d": -0.005952380952380957, "mi": -0.38971106412966877, "fo": 0.6666666666666666, "r": -0.02631578947368421, "e": 0.1837612304997032}
{"project_name": "Codec", "project_version": 8, "label": 1, "code": "/**\n * Attempts to read <code>len</code> bytes into the specified <code>b</code> array starting at <code>offset</code>\n * from this InputStream.\n *\n * @param b\n *            destination byte array\n * @param offset\n *            where to start writing the bytes\n * @param len\n *            maximum number of bytes to read\n *\n * @return number of bytes read\n * @throws IOException\n *             if an I/O error occurs.\n * @throws NullPointerException\n *             if the byte array parameter is null\n * @throws IndexOutOfBoundsException\n *             if offset, len or buffer size are invalid\n */\npublic int read(byte[] b, int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0) {\n        throw new IndexOutOfBoundsException();\n    } else if (offset > b.length || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        int readLen = 0;\n        /*\n             Rationale for while-loop on (readLen == 0):\n             -----\n             Base64.readResults() usually returns > 0 or EOF (-1).  In the\n             rare case where it returns 0, we just keep trying.\n\n             This is essentially an undocumented contract for InputStream\n             implementors that want their code to work properly with\n             java.io.InputStreamReader, since the latter hates it when\n             InputStream.read(byte[]) returns a zero.  Unfortunately our\n             readResults() call must return 0 if a large amount of the data\n             being decoded was non-base64, so this while-loop enables proper\n             interop with InputStreamReader for that scenario.\n             -----\n             This is a fix for CODEC-101\n            */\n        while (readLen == 0) {\n            if (!base64.hasData()) {\n                byte[] buf = new byte[doEncode ? 4096 : 8192];\n                int c = in.read(buf);\n                if (c > 0 && b.length == len) {\n                    base64.setInitialBuffer(b, offset, len);\n                }\n                if (doEncode) {\n                    base64.encode(buf, 0, c);\n                } else {\n                    base64.decode(buf, 0, c);\n                }\n            }\n            readLen = base64.readResults(b, offset, len);\n        }\n        return readLen;\n    }\n}", "code_comment": "/**\n * Attempts to read <code>len</code> bytes into the specified <code>b</code> array starting at <code>offset</code>\n * from this InputStream.\n *\n * @param b\n *            destination byte array\n * @param offset\n *            where to start writing the bytes\n * @param len\n *            maximum number of bytes to read\n *\n * @return number of bytes read\n * @throws IOException\n *             if an I/O error occurs.\n * @throws NullPointerException\n *             if the byte array parameter is null\n * @throws IndexOutOfBoundsException\n *             if offset, len or buffer size are invalid\n */\n", "code_no_comment": "public int read(byte[] b, int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0) {\n        throw new IndexOutOfBoundsException();\n    } else if (offset > b.length || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        int readLen = 0;\n                while (readLen == 0) {\n            if (!base64.hasData()) {\n                byte[] buf = new byte[doEncode ? 4096 : 8192];\n                int c = in.read(buf);\n                if (c > 0 && b.length == len) {\n                    base64.setInitialBuffer(b, offset, len);\n                }\n                if (doEncode) {\n                    base64.encode(buf, 0, c);\n                } else {\n                    base64.decode(buf, 0, c);\n                }\n            }\n            readLen = base64.readResults(b, offset, len);\n        }\n        return readLen;\n    }\n}", "lc": 0.6818181818181818, "pi": 1.3923444976076558, "ma": 1.8, "nbd": 2.5, "ml": 1.25, "d": 1.8511904761904763, "mi": -0.5315010570824524, "fo": 0.0, "r": -0.02631578947368421, "e": 2.025195507223826}
{"project_name": "Closure", "project_version": 172, "label": 2, "code": "/**\n * Determines whether a qualified name is inferred.\n * NOTE(nicksantos): Determining whether a property is declared or not\n * is really really obnoxious.\n *\n * The problem is that there are two (equally valid) coding styles:\n *\n * (function() {\n *   /* The authoritative definition of goog.bar. /\n *   goog.bar = function() {};\n * })();\n *\n * function f() {\n *   goog.bar();\n *   /* Reset goog.bar to a no-op. /\n *   goog.bar = function() {};\n * }\n *\n * In a dynamic language with first-class functions, it's very difficult\n * to know which one the user intended without looking at lots of\n * contextual information (the second example demonstrates a small case\n * of this, but there are some really pathological cases as well).\n *\n * The current algorithm checks if either the declaration has\n * JsDoc type information, or @const with a known type,\n * or a function literal with a name we haven't seen before.\n */\nprivate boolean isQualifiedNameInferred(String qName, Node n, JSDocInfo info, Node rhsValue, JSType valueType) {\n    if (valueType == null) {\n        return true;\n    }\n    // Prototypes of constructors and interfaces are always declared.\n    if (qName != null && qName.endsWith(\".prototype\")) {\n        return false;\n    }\n    boolean inferred = true;\n    if (info != null) {\n        inferred = !(info.hasType() || info.hasEnumParameterType() || (isConstantSymbol(info, n) && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (inferred && rhsValue != null && rhsValue.isFunction()) {\n        if (info != null) {\n            return false;\n        } else if (!scope.isDeclared(qName, false) && n.isUnscopedQualifiedName()) {\n            // Functions assigned in conditional blocks are inferred.\n            for (Node current = n.getParent(); !(current.isScript() || current.isFunction()); current = current.getParent()) {\n                if (NodeUtil.isControlStructure(current)) {\n                    return true;\n                }\n            }\n            // Check if this is assigned in an inner scope.\n            // Functions assigned in inner scopes are inferred.\n            AstFunctionContents contents = getFunctionAnalysisResults(scope.getRootNode());\n            if (contents == null || !contents.getEscapedQualifiedNames().contains(qName)) {\n                return false;\n            }\n        }\n    }\n    return inferred;\n}", "code_comment": "/**\n * Determines whether a qualified name is inferred.\n * NOTE(nicksantos): Determining whether a property is declared or not\n * is really really obnoxious.\n *\n * The problem is that there are two (equally valid) coding styles:\n *\n * (function() {\n *   /* The authoritative definition of goog.bar. /\n *   goog.bar = function() {};\n * })();\n *\n * function f() {\n *   goog.bar();\n *   /* Reset goog.bar to a no-op. /\n *   goog.bar = function() {};\n * }\n *\n * In a dynamic language with first-class functions, it's very difficult\n * to know which one the user intended without looking at lots of\n * contextual information (the second example demonstrates a small case\n * of this, but there are some really pathological cases as well).\n *\n * The current algorithm checks if either the declaration has\n * JsDoc type information, or @const with a known type,\n * or a function literal with a name we haven't seen before.\n */\n", "code_no_comment": "private boolean isQualifiedNameInferred(String qName, Node n, JSDocInfo info, Node rhsValue, JSType valueType) {\n    if (valueType == null) {\n        return true;\n    }\n        if (qName != null && qName.endsWith(\".prototype\")) {\n        return false;\n    }\n    boolean inferred = true;\n    if (info != null) {\n        inferred = !(info.hasType() || info.hasEnumParameterType() || (isConstantSymbol(info, n) && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (inferred && rhsValue != null && rhsValue.isFunction()) {\n        if (info != null) {\n            return false;\n        } else if (!scope.isDeclared(qName, false) && n.isUnscopedQualifiedName()) {\n                        for (Node current = n.getParent(); !(current.isScript() || current.isFunction()); current = current.getParent()) {\n                if (NodeUtil.isControlStructure(current)) {\n                    return true;\n                }\n            }\n                                    AstFunctionContents contents = getFunctionAnalysisResults(scope.getRootNode());\n            if (contents == null || !contents.getEscapedQualifiedNames().contains(qName)) {\n                return false;\n            }\n        }\n    }\n    return inferred;\n}", "lc": 0.6363636363636364, "pi": 0.9952153110047848, "ma": 1.2, "nbd": 1.5, "ml": 2.0833333333333335, "d": 0.9186507936507936, "mi": -0.5439041578576461, "fo": 1.0, "r": -0.02631578947368421, "e": 1.5969733118952527}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5398_19e7c1cd", "label": 3, "code": "@Override\npublic final String getEncoding() {\n    return xmlReader.getEncoding();\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic final String getEncoding() {\n    return xmlReader.getEncoding();\n}", "lc": -0.45454545454545453, "pi": -0.6028708133971293, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.9517970401691334, "fo": -0.4166666666666667, "r": 1.6578947368421053, "e": -0.16279340490885932}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3903_690fb9f4", "label": 1, "code": "/**\n * Apply the changes to the document store.\n *\n * @param baseBranchRevision the base revision of this commit. Currently only\n *                     used for branch commits.\n */\nprivate void applyToDocumentStore(RevisionVector baseBranchRevision) {\n    // the value in _revisions.<revision> property of the commit root node\n    // regular commits use \"c\", which makes the commit visible to\n    // other readers. branch commits use the base revision to indicate\n    // the visibility of the commit\n    String commitValue = baseBranchRevision != null ? baseBranchRevision.toString() : \"c\";\n    DocumentStore store = nodeStore.getDocumentStore();\n    String commitRootPath = null;\n    if (baseBranchRevision != null) {\n        // branch commits always use root node as commit root\n        commitRootPath = \"/\";\n    }\n    ArrayList<UpdateOp> newNodes = new ArrayList<UpdateOp>();\n    ArrayList<UpdateOp> changedNodes = new ArrayList<UpdateOp>();\n    // operations are added to this list before they are executed,\n    // so that all operations can be rolled back if there is a conflict\n    ArrayList<UpdateOp> opLog = new ArrayList<UpdateOp>();\n    // Compute the commit root\n    for (String p : operations.keySet()) {\n        markChanged(p);\n        if (commitRootPath == null) {\n            commitRootPath = p;\n        } else {\n            while (!PathUtils.isAncestor(commitRootPath, p)) {\n                commitRootPath = PathUtils.getParentPath(commitRootPath);\n                if (denotesRoot(commitRootPath)) {\n                    break;\n                }\n            }\n        }\n    }\n    // push branch changes to journal\n    if (baseBranchRevision != null) {\n        // store as external change\n        JournalEntry doc = JOURNAL.newDocument(store);\n        doc.modified(modifiedNodes);\n        Revision r = revision.asBranchRevision();\n        store.create(JOURNAL, singletonList(doc.asUpdateOp(r)));\n    }\n    int commitRootDepth = PathUtils.getDepth(commitRootPath);\n    // check if there are real changes on the commit root\n    boolean commitRootHasChanges = operations.containsKey(commitRootPath);\n    // create a \"root of the commit\" if there is none\n    UpdateOp commitRoot = getUpdateOperationForNode(commitRootPath);\n    for (String p : operations.keySet()) {\n        UpdateOp op = operations.get(p);\n        if (op.isNew()) {\n            NodeDocument.setDeleted(op, revision, false);\n        }\n        if (op == commitRoot) {\n            if (!op.isNew() && commitRootHasChanges) {\n                // commit root already exists and this is an update\n                changedNodes.add(op);\n            }\n        } else {\n            NodeDocument.setCommitRoot(op, revision, commitRootDepth);\n            if (op.isNew()) {\n                newNodes.add(op);\n            } else {\n                changedNodes.add(op);\n            }\n        }\n    }\n    if (changedNodes.size() == 0 && commitRoot.isNew()) {\n        // no updates and root of commit is also new. that is,\n        // it is the root of a subtree added in a commit.\n        // so we try to add the root like all other nodes\n        NodeDocument.setRevision(commitRoot, revision, commitValue);\n        newNodes.add(commitRoot);\n    }\n    boolean success = false;\n    try {\n        if (newNodes.size() > 0) {\n            // set commit root on new nodes\n            if (!store.create(NODES, newNodes)) {\n                // try to apply all changes one by one\n                for (UpdateOp op : newNodes) {\n                    if (op == commitRoot) {\n                        // don't write the commit root just yet\n                        // (because there might be a conflict)\n                        NodeDocument.unsetRevision(commitRoot, revision);\n                    }\n                    changedNodes.add(op);\n                }\n                newNodes.clear();\n            }\n        }\n        for (UpdateOp op : changedNodes) {\n            // set commit root on changed nodes. this may even apply\n            // to the commit root. the _commitRoot entry is removed\n            // again when the _revisions entry is set at the end\n            NodeDocument.setCommitRoot(op, revision, commitRootDepth);\n            opLog.add(op);\n            createOrUpdateNode(store, op);\n        }\n        // the revision, with the revision property set)\n        if (changedNodes.size() > 0 || !commitRoot.isNew()) {\n            // set revision to committed\n            NodeDocument.setRevision(commitRoot, revision, commitValue);\n            if (commitRootHasChanges) {\n                // remove previously added commit root\n                NodeDocument.removeCommitRoot(commitRoot, revision);\n            }\n            opLog.add(commitRoot);\n            if (baseBranchRevision == null) {\n                // create a clone of the commitRoot in order\n                // to set isNew to false. If we get here the\n                // commitRoot document already exists and\n                // only needs an update\n                UpdateOp commit = commitRoot.copy();\n                commit.setNew(false);\n                // only set revision on commit root when there is\n                // no collision for this commit revision\n                commit.containsMapEntry(COLLISIONS, revision, false);\n                NodeDocument before = nodeStore.updateCommitRoot(commit);\n                if (before == null) {\n                    String msg = \"Conflicting concurrent change. \" + \"Update operation failed: \" + commitRoot;\n                    NodeDocument commitRootDoc = store.find(NODES, commitRoot.getId());\n                    DocumentStoreException dse;\n                    if (commitRootDoc == null) {\n                        dse = new DocumentStoreException(msg);\n                    } else {\n                        dse = new ConflictException(msg, commitRootDoc.getConflictsFor(Collections.singleton(revision)));\n                    }\n                    throw dse;\n                } else {\n                    success = true;\n                    // if we get here the commit was successful and\n                    // the commit revision is set on the commitRoot\n                    // document for this commit.\n                    // now check for conflicts/collisions by other commits.\n                    // use original commitRoot operation with\n                    // correct isNew flag.\n                    checkConflicts(commitRoot, before);\n                    checkSplitCandidate(before);\n                }\n            } else {\n                // this is a branch commit, do not fail on collisions now\n                // trying to merge the branch will fail later\n                createOrUpdateNode(store, commitRoot);\n            }\n            operations.put(commitRootPath, commitRoot);\n        }\n    } catch (DocumentStoreException e) {\n        // OAK-3084 do not roll back if already committed\n        if (success) {\n            LOG.error(\"Exception occurred after commit. Rollback will be suppressed.\", e);\n        } else {\n            rollback(newNodes, opLog, commitRoot);\n            throw e;\n        }\n    }\n}", "code_comment": "/**\n * Apply the changes to the document store.\n *\n * @param baseBranchRevision the base revision of this commit. Currently only\n *                     used for branch commits.\n */\n", "code_no_comment": "private void applyToDocumentStore(RevisionVector baseBranchRevision) {\n                    String commitValue = baseBranchRevision != null ? baseBranchRevision.toString() : \"c\";\n    DocumentStore store = nodeStore.getDocumentStore();\n    String commitRootPath = null;\n    if (baseBranchRevision != null) {\n                commitRootPath = \"/\";\n    }\n    ArrayList<UpdateOp> newNodes = new ArrayList<UpdateOp>();\n    ArrayList<UpdateOp> changedNodes = new ArrayList<UpdateOp>();\n            ArrayList<UpdateOp> opLog = new ArrayList<UpdateOp>();\n        for (String p : operations.keySet()) {\n        markChanged(p);\n        if (commitRootPath == null) {\n            commitRootPath = p;\n        } else {\n            while (!PathUtils.isAncestor(commitRootPath, p)) {\n                commitRootPath = PathUtils.getParentPath(commitRootPath);\n                if (denotesRoot(commitRootPath)) {\n                    break;\n                }\n            }\n        }\n    }\n        if (baseBranchRevision != null) {\n                JournalEntry doc = JOURNAL.newDocument(store);\n        doc.modified(modifiedNodes);\n        Revision r = revision.asBranchRevision();\n        store.create(JOURNAL, singletonList(doc.asUpdateOp(r)));\n    }\n    int commitRootDepth = PathUtils.getDepth(commitRootPath);\n        boolean commitRootHasChanges = operations.containsKey(commitRootPath);\n        UpdateOp commitRoot = getUpdateOperationForNode(commitRootPath);\n    for (String p : operations.keySet()) {\n        UpdateOp op = operations.get(p);\n        if (op.isNew()) {\n            NodeDocument.setDeleted(op, revision, false);\n        }\n        if (op == commitRoot) {\n            if (!op.isNew() && commitRootHasChanges) {\n                                changedNodes.add(op);\n            }\n        } else {\n            NodeDocument.setCommitRoot(op, revision, commitRootDepth);\n            if (op.isNew()) {\n                newNodes.add(op);\n            } else {\n                changedNodes.add(op);\n            }\n        }\n    }\n    if (changedNodes.size() == 0 && commitRoot.isNew()) {\n                                NodeDocument.setRevision(commitRoot, revision, commitValue);\n        newNodes.add(commitRoot);\n    }\n    boolean success = false;\n    try {\n        if (newNodes.size() > 0) {\n                        if (!store.create(NODES, newNodes)) {\n                                for (UpdateOp op : newNodes) {\n                    if (op == commitRoot) {\n                                                                        NodeDocument.unsetRevision(commitRoot, revision);\n                    }\n                    changedNodes.add(op);\n                }\n                newNodes.clear();\n            }\n        }\n        for (UpdateOp op : changedNodes) {\n                                                NodeDocument.setCommitRoot(op, revision, commitRootDepth);\n            opLog.add(op);\n            createOrUpdateNode(store, op);\n        }\n                if (changedNodes.size() > 0 || !commitRoot.isNew()) {\n                        NodeDocument.setRevision(commitRoot, revision, commitValue);\n            if (commitRootHasChanges) {\n                                NodeDocument.removeCommitRoot(commitRoot, revision);\n            }\n            opLog.add(commitRoot);\n            if (baseBranchRevision == null) {\n                                                                                UpdateOp commit = commitRoot.copy();\n                commit.setNew(false);\n                                                commit.containsMapEntry(COLLISIONS, revision, false);\n                NodeDocument before = nodeStore.updateCommitRoot(commit);\n                if (before == null) {\n                    String msg = \"Conflicting concurrent change. \" + \"Update operation failed: \" + commitRoot;\n                    NodeDocument commitRootDoc = store.find(NODES, commitRoot.getId());\n                    DocumentStoreException dse;\n                    if (commitRootDoc == null) {\n                        dse = new DocumentStoreException(msg);\n                    } else {\n                        dse = new ConflictException(msg, commitRootDoc.getConflictsFor(Collections.singleton(revision)));\n                    }\n                    throw dse;\n                } else {\n                    success = true;\n                                                                                                                                            checkConflicts(commitRoot, before);\n                    checkSplitCandidate(before);\n                }\n            } else {\n                                                createOrUpdateNode(store, commitRoot);\n            }\n            operations.put(commitRootPath, commitRoot);\n        }\n    } catch (DocumentStoreException e) {\n                if (success) {\n            LOG.error(\"Exception occurred after commit. Rollback will be suppressed.\", e);\n        } else {\n            rollback(newNodes, opLog, commitRoot);\n            throw e;\n        }\n    }\n}", "lc": 4.454545454545454, "pi": 1.325358851674641, "ma": 5.0, "nbd": 1.5, "ml": 2.9166666666666665, "d": 1.9642857142857144, "mi": -1.4851303735024661, "fo": 4.25, "r": -0.02631578947368421, "e": 11.09189444626937}
{"project_name": "Closure", "project_version": 154, "label": 2, "code": "/**\n * Expect that the peroperty in an interface that this type implements is\n * implemented and correctly typed.\n */\nprivate void expectInterfaceProperty(NodeTraversal t, Node n, ObjectType instance, ObjectType implementedInterface, String prop) {\n    if (!instance.hasProperty(prop)) {\n        // Not implemented\n        String sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n        sourceName = sourceName == null ? \"\" : sourceName;\n        if (shouldReport) {\n            compiler.report(JSError.make(sourceName, n, INTERFACE_METHOD_NOT_IMPLEMENTED, prop, implementedInterface.toString(), instance.toString()));\n        }\n        registerMismatch(instance, implementedInterface);\n    // Implemented, but not correctly typed\n    }\n}", "code_comment": "/**\n * Expect that the peroperty in an interface that this type implements is\n * implemented and correctly typed.\n */\n", "code_no_comment": "private void expectInterfaceProperty(NodeTraversal t, Node n, ObjectType instance, ObjectType implementedInterface, String prop) {\n    if (!instance.hasProperty(prop)) {\n                String sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n        sourceName = sourceName == null ? \"\" : sourceName;\n        if (shouldReport) {\n            compiler.report(JSError.make(sourceName, n, INTERFACE_METHOD_NOT_IMPLEMENTED, prop, implementedInterface.toString(), instance.toString()));\n        }\n        registerMismatch(instance, implementedInterface);\n        }\n}", "lc": -0.18181818181818182, "pi": 0.3349282296650717, "ma": 0.0, "nbd": 0.0, "ml": 0.16666666666666666, "d": -0.02380952380952383, "mi": 0.10556730091613822, "fo": 0.08333333333333333, "r": 0.02631578947368421, "e": 0.01637823228044696}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-766_6fc5ea9d", "label": 1, "code": "@Override\npublic TreeImpl getChild(@Nonnull String name) {\n    checkNotNull(name);\n    enter();\n    TreeImpl child = internalGetChild(name);\n    if (child != null && canRead(child)) {\n        return child;\n    } else {\n        return null;\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic TreeImpl getChild(@Nonnull String name) {\n    checkNotNull(name);\n    enter();\n    TreeImpl child = internalGetChild(name);\n    if (child != null && canRead(child)) {\n        return child;\n    } else {\n        return null;\n    }\n}", "lc": -0.13636363636363635, "pi": -0.15311004784689008, "ma": -0.4, "nbd": -0.5, "ml": -0.08333333333333333, "d": -0.059523809523809534, "mi": 0.20676532769556044, "fo": -0.16666666666666666, "r": 1.6052631578947367, "e": -0.09753865481809328}
{"project_name": "Cli", "project_version": 1, "label": 1, "code": "/**\n * Returns an array of the processed {@link Option}s.\n *\n * @return an array of the processed {@link Option}s.\n */\npublic Option[] getOptions() {\n    Collection processed = options.values();\n    // reinitialise array\n    Option[] optionsArray = new Option[processed.size()];\n    // return the array\n    return (Option[]) processed.toArray(optionsArray);\n}", "code_comment": "/**\n * Returns an array of the processed {@link Option}s.\n *\n * @return an array of the processed {@link Option}s.\n */\n", "code_no_comment": "public Option[] getOptions() {\n    Collection processed = options.values();\n        Option[] optionsArray = new Option[processed.size()];\n        return (Option[]) processed.toArray(optionsArray);\n}", "lc": -0.4090909090909091, "pi": -0.49282296650717716, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.6304439746300209, "fo": -0.25, "r": 2.526315789473684, "e": -0.16279340490885932}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4777_eccb3b11", "label": 3, "code": "/**\n *  @param response\n *  @param id\n */\npublic static void writeOpenTag(final Response response, String id) {\n    response.write(\"<script type=\\\"text/javascript\\\" \");\n    if (id != null) {\n        response.write(\"id=\\\"\" + id + \"\\\"\");\n    }\n    response.write(\">\");\n    response.write(SCRIPT_CONTENT_PREFIX);\n}", "code_comment": "/**\n *  @param response\n *  @param id\n */\n", "code_no_comment": "public static void writeOpenTag(final Response response, String id) {\n    response.write(\"<script type=\\\"text/javascript\\\" \");\n    if (id != null) {\n        response.write(\"id=\\\"\" + id + \"\\\"\");\n    }\n    response.write(\">\");\n    response.write(SCRIPT_CONTENT_PREFIX);\n}", "lc": -0.2727272727272727, "pi": -0.2822966507177035, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": -0.029761904761904788, "mi": 0.34940098661028873, "fo": -0.16666666666666666, "r": 2.0, "e": -0.08963653233288958}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2389_7c320b1e", "label": 1, "code": "/**\n * Escape a string into the target buffer.\n *\n * @param s      the string to escape\n * @param length the number of characters.\n * @param buff   the target buffer\n */\npublic static void escape(String s, int length, StringBuilder buff) {\n    // needs more time, memory, and storage space\n    for (int i = 0; i < length; i++) {\n        char c = s.charAt(i);\n        switch(c) {\n            case '\"':\n                // quotation mark\n                buff.append(\"\\\\\\\"\");\n                break;\n            case '\\\\':\n                // backslash\n                buff.append(\"\\\\\\\\\");\n                break;\n            case '\\b':\n                // backspace\n                buff.append(\"\\\\b\");\n                break;\n            case '\\f':\n                // formfeed\n                buff.append(\"\\\\f\");\n                break;\n            case '\\n':\n                // newline\n                buff.append(\"\\\\n\");\n                break;\n            case '\\r':\n                // carriage return\n                buff.append(\"\\\\r\");\n                break;\n            case '\\t':\n                // horizontal tab\n                buff.append(\"\\\\t\");\n                break;\n            default:\n                if (c < ' ') {\n                    // guaranteed to be 1 or 2 hex digits only\n                    buff.append(\"\\\\u00\");\n                    String hex = Integer.toHexString(c);\n                    if (hex.length() == 1) {\n                        buff.append('0');\n                    }\n                    buff.append(hex);\n                } else if (c >= 127) {\n                    // ascii only mode\n                    buff.append(\"\\\\u\");\n                    String hex = Integer.toHexString(c);\n                    for (int len = hex.length(); len < 4; len++) {\n                        buff.append('0');\n                    }\n                    buff.append(hex);\n                } else {\n                    buff.append(c);\n                }\n        }\n    }\n}", "code_comment": "/**\n * Escape a string into the target buffer.\n *\n * @param s      the string to escape\n * @param length the number of characters.\n * @param buff   the target buffer\n */\n", "code_no_comment": "public static void escape(String s, int length, StringBuilder buff) {\n        for (int i = 0; i < length; i++) {\n        char c = s.charAt(i);\n        switch(c) {\n            case '\"':\n                                buff.append(\"\\\\\\\"\");\n                break;\n            case '\\\\':\n                                buff.append(\"\\\\\\\\\");\n                break;\n            case '\\b':\n                                buff.append(\"\\\\b\");\n                break;\n            case '\\f':\n                                buff.append(\"\\\\f\");\n                break;\n            case '\\n':\n                                buff.append(\"\\\\n\");\n                break;\n            case '\\r':\n                                buff.append(\"\\\\r\");\n                break;\n            case '\\t':\n                                buff.append(\"\\\\t\");\n                break;\n            default:\n                if (c < ' ') {\n                                        buff.append(\"\\\\u00\");\n                    String hex = Integer.toHexString(c);\n                    if (hex.length() == 1) {\n                        buff.append('0');\n                    }\n                    buff.append(hex);\n                } else if (c >= 127) {\n                                        buff.append(\"\\\\u\");\n                    String hex = Integer.toHexString(c);\n                    for (int len = hex.length(); len < 4; len++) {\n                        buff.append('0');\n                    }\n                    buff.append(hex);\n                } else {\n                    buff.append(c);\n                }\n        }\n    }\n}", "lc": 1.4545454545454546, "pi": 1.1770334928229667, "ma": 3.4, "nbd": 2.0, "ml": 1.0, "d": 0.6150793650793652, "mi": -0.829457364341085, "fo": 1.0833333333333333, "r": -0.02631578947368421, "e": 1.0707030191963023}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-821_a450ac2f", "label": 1, "code": "@SuppressWarnings(\"unchecked\")\n@Override\npublic Iterator<Entry<Key, Value>> iterator() {\n    if (ranges == null) {\n        throw new IllegalStateException(\"ranges not set\");\n    }\n    IteratorChain chain = new IteratorChain();\n    for (Range range : ranges) {\n        SortedKeyValueIterator<Key, Value> i = new SortedMapIterator(table.table);\n        try {\n            i = new RangesFilter(createFilter(i), ranges);\n            i.seek(range, createColumnBSS(fetchedColumns), !fetchedColumns.isEmpty());\n            chain.addIterator(new IteratorAdapter(i));\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n    return chain;\n}", "code_comment": NaN, "code_no_comment": "@SuppressWarnings(\"unchecked\")\n@Override\npublic Iterator<Entry<Key, Value>> iterator() {\n    if (ranges == null) {\n        throw new IllegalStateException(\"ranges not set\");\n    }\n    IteratorChain chain = new IteratorChain();\n    for (Range range : ranges) {\n        SortedKeyValueIterator<Key, Value> i = new SortedMapIterator(table.table);\n        try {\n            i = new RangesFilter(createFilter(i), ranges);\n            i.seek(range, createColumnBSS(fetchedColumns), !fetchedColumns.isEmpty());\n            chain.addIterator(new IteratorAdapter(i));\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n    return chain;\n}", "lc": 0.22727272727272727, "pi": 0.5693779904306218, "ma": 0.4, "nbd": 0.0, "ml": -0.25, "d": -0.07341269841269843, "mi": -0.22480620155038739, "fo": -0.08333333333333333, "r": -0.02631578947368421, "e": 0.017816658310425695}
{"project_name": "Closure", "project_version": 44, "label": 2, "code": "void add(String newcode) {\n    maybeEndStatement();\n    if (newcode.length() == 0) {\n        return;\n    }\n    char c = newcode.charAt(0);\n    if ((isWordChar(c) || c == '\\\\') && isWordChar(getLastChar())) {\n        // need space to separate. This is not pretty printing.\n        // For example: \"return foo;\"\n        append(\" \");\n    // Do not allow a forward slash to appear after a DIV.\n    // For example,\n    // REGEXP DIV REGEXP\n    // is valid and should print like\n    // / // / /\n    }\n    append(newcode);\n}", "code_comment": NaN, "code_no_comment": "void add(String newcode) {\n    maybeEndStatement();\n    if (newcode.length() == 0) {\n        return;\n    }\n    char c = newcode.charAt(0);\n    if ((isWordChar(c) || c == '\\\\') && isWordChar(getLastChar())) {\n                        append(\" \");\n                        }\n    append(newcode);\n}", "lc": -0.13636363636363635, "pi": -0.2775119617224881, "ma": -0.2, "nbd": -0.5, "ml": 0.3333333333333333, "d": 0.25793650793650796, "mi": 0.17068357998590572, "fo": 0.16666666666666666, "r": 2.3947368421052633, "e": 0.0003434703180558217}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4616_dd1df04b", "label": 1, "code": "/**\n *  Calls onError on this {@link Form} and any enabled and visible nested form, if the respective\n *  {@link Form} actually has errors.\n *\n *  @param submitter\n */\nprotected void callOnError(IFormSubmitter submitter) {\n    if (submitter != null) {\n        submitter.onError();\n    }\n    onError();\n    // call onError on nested forms\n    visitChildren(Form.class, new IVisitor<Component, Void>() {\n\n        @Override\n        public void component(final Component component, final IVisit<Void> visit) {\n            final Form<?> form = (Form<?>) component;\n            if (!form.isEnabledInHierarchy() || !form.isVisibleInHierarchy()) {\n                visit.dontGoDeeper();\n                return;\n            }\n            if (form.hasError()) {\n                form.onError();\n            }\n        }\n    });\n}", "code_comment": "/**\n *  Calls onError on this {@link Form} and any enabled and visible nested form, if the respective\n *  {@link Form} actually has errors.\n *\n *  @param submitter\n */\n", "code_no_comment": "protected void callOnError(IFormSubmitter submitter) {\n    if (submitter != null) {\n        submitter.onError();\n    }\n    onError();\n        visitChildren(Form.class, new IVisitor<Component, Void>() {\n\n        @Override\n        public void component(final Component component, final IVisit<Void> visit) {\n            final Form<?> form = (Form<?>) component;\n            if (!form.isEnabledInHierarchy() || !form.isVisibleInHierarchy()) {\n                visit.dontGoDeeper();\n                return;\n            }\n            if (form.hasError()) {\n                form.onError();\n            }\n        }\n    });\n}", "lc": 0.22727272727272727, "pi": 0.9665071770334926, "ma": 0.0, "nbd": 0.0, "ml": 0.25, "d": 0.32936507936507936, "mi": -0.1568710359408033, "fo": 0.16666666666666666, "r": 0.05263157894736841, "e": 0.13313969906006692}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-492_61ccbb95", "label": 3, "code": "/**\n * Unregisters all MBeans associated with the specified logger context\n * (including MBeans for {@code LoggerConfig}s and {@code Appender}s from\n * the platform MBean server.\n *\n * @param loggerContextName name of the logger context to unregister\n * @param mbs the MBean Server to unregister the instrumented objects from\n */\npublic static void unregisterContext(String contextName, MBeanServer mbs) {\n    final String pattern = LoggerContextAdminMBean.PATTERN;\n    final String search = String.format(pattern, contextName, \"*\");\n    // unregister context mbean\n    unregisterAllMatching(search, mbs);\n    unregisterLoggerConfigs(contextName, mbs);\n    unregisterAppenders(contextName, mbs);\n    unregisterAsyncAppenders(contextName, mbs);\n    unregisterAsyncLoggerRingBufferAdmins(contextName, mbs);\n    unregisterAsyncLoggerConfigRingBufferAdmins(contextName, mbs);\n}", "code_comment": "/**\n * Unregisters all MBeans associated with the specified logger context\n * (including MBeans for {@code LoggerConfig}s and {@code Appender}s from\n * the platform MBean server.\n *\n * @param loggerContextName name of the logger context to unregister\n * @param mbs the MBean Server to unregister the instrumented objects from\n */\n", "code_no_comment": "public static void unregisterContext(String contextName, MBeanServer mbs) {\n    final String pattern = LoggerContextAdminMBean.PATTERN;\n    final String search = String.format(pattern, contextName, \"*\");\n        unregisterAllMatching(search, mbs);\n    unregisterLoggerConfigs(contextName, mbs);\n    unregisterAppenders(contextName, mbs);\n    unregisterAsyncAppenders(contextName, mbs);\n    unregisterAsyncLoggerRingBufferAdmins(contextName, mbs);\n    unregisterAsyncLoggerConfigRingBufferAdmins(contextName, mbs);\n}", "lc": -0.18181818181818182, "pi": -0.6650717703349284, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.1782945736434109, "fo": 0.08333333333333333, "r": 0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-2281_6e0b40bc", "label": 1, "code": "/**\n *  Initialize the request parameters to point to the given component.\n *\n *  @param component\n *             The component\n */\npublic void setRequestToComponent(final Component component) {\n    final IPageMap pageMap = component.getPage().getPageMap();\n    final String pageMapName = pageMap.isDefault() ? \"\" : pageMap.getName();\n    if (component instanceof BookmarkablePageLink) {\n        final Class<? extends Page> clazz = ((BookmarkablePageLink<?>) component).getPageClass();\n        parameters.put(WebRequestCodingStrategy.BOOKMARKABLE_PAGE_PARAMETER_NAME, pageMapName + ':' + clazz.getName());\n    } else {\n        int version = component.getPage().getCurrentVersionNumber();\n        Class<?> clazz = null;\n        if (component instanceof IRedirectListener) {\n            clazz = IRedirectListener.class;\n        } else if (component instanceof IResourceListener) {\n            clazz = IResourceListener.class;\n        } else if (component instanceof IFormSubmitListener) {\n            clazz = IFormSubmitListener.class;\n        } else if (component instanceof ILinkListener) {\n            clazz = ILinkListener.class;\n        } else if (component instanceof IOnChangeListener) {\n            clazz = IOnChangeListener.class;\n        } else {\n            throw new IllegalArgumentException(\"The component class doesn't seem to implement any of the known *Listener interfaces: \" + component.getClass());\n        }\n        // manually create the url using default strategy and format\n        parameters.put(WebRequestCodingStrategy.INTERFACE_PARAMETER_NAME, pageMapName + ':' + component.getPath() + ':' + (version == 0 ? \"\" : \"\" + version) + ':' + Classes.simpleName(clazz) + \"::\");\n        try {\n            RequestListenerInterface rli = (RequestListenerInterface) clazz.getField(\"INTERFACE\").get(clazz);\n            String auto = component.getRequestCycle().urlFor(component, rli).toString();\n            int idx = auto.indexOf(WebRequestCodingStrategy.INTERFACE_PARAMETER_NAME);\n            if (idx >= 0) {\n                auto = auto.substring(idx + WebRequestCodingStrategy.INTERFACE_PARAMETER_NAME.length() + 1);\n            } else {\n                // additional check for crypted strategy\n                idx = auto.indexOf(\"x=6*\");\n                if (idx >= 0) {\n                    auto = auto.substring(idx + 4);\n                }\n            }\n            idx = auto.indexOf(\"&\");\n            if (idx >= 0) {\n                auto = auto.substring(0, idx);\n            }\n            parameters.put(WebRequestCodingStrategy.INTERFACE_PARAMETER_NAME, auto);\n        } catch (Exception e) {\n        // noop\n        }\n        if (component.isStateless() && component.getPage().isBookmarkable()) {\n            parameters.put(WebRequestCodingStrategy.BOOKMARKABLE_PAGE_PARAMETER_NAME, pageMapName + ':' + component.getPage().getClass().getName());\n        }\n    }\n}", "code_comment": "/**\n *  Initialize the request parameters to point to the given component.\n *\n *  @param component\n *             The component\n */\n", "code_no_comment": "public void setRequestToComponent(final Component component) {\n    final IPageMap pageMap = component.getPage().getPageMap();\n    final String pageMapName = pageMap.isDefault() ? \"\" : pageMap.getName();\n    if (component instanceof BookmarkablePageLink) {\n        final Class<? extends Page> clazz = ((BookmarkablePageLink<?>) component).getPageClass();\n        parameters.put(WebRequestCodingStrategy.BOOKMARKABLE_PAGE_PARAMETER_NAME, pageMapName + ':' + clazz.getName());\n    } else {\n        int version = component.getPage().getCurrentVersionNumber();\n        Class<?> clazz = null;\n        if (component instanceof IRedirectListener) {\n            clazz = IRedirectListener.class;\n        } else if (component instanceof IResourceListener) {\n            clazz = IResourceListener.class;\n        } else if (component instanceof IFormSubmitListener) {\n            clazz = IFormSubmitListener.class;\n        } else if (component instanceof ILinkListener) {\n            clazz = ILinkListener.class;\n        } else if (component instanceof IOnChangeListener) {\n            clazz = IOnChangeListener.class;\n        } else {\n            throw new IllegalArgumentException(\"The component class doesn't seem to implement any of the known *Listener interfaces: \" + component.getClass());\n        }\n                parameters.put(WebRequestCodingStrategy.INTERFACE_PARAMETER_NAME, pageMapName + ':' + component.getPath() + ':' + (version == 0 ? \"\" : \"\" + version) + ':' + Classes.simpleName(clazz) + \"::\");\n        try {\n            RequestListenerInterface rli = (RequestListenerInterface) clazz.getField(\"INTERFACE\").get(clazz);\n            String auto = component.getRequestCycle().urlFor(component, rli).toString();\n            int idx = auto.indexOf(WebRequestCodingStrategy.INTERFACE_PARAMETER_NAME);\n            if (idx >= 0) {\n                auto = auto.substring(idx + WebRequestCodingStrategy.INTERFACE_PARAMETER_NAME.length() + 1);\n            } else {\n                                idx = auto.indexOf(\"x=6*\");\n                if (idx >= 0) {\n                    auto = auto.substring(idx + 4);\n                }\n            }\n            idx = auto.indexOf(\"&\");\n            if (idx >= 0) {\n                auto = auto.substring(0, idx);\n            }\n            parameters.put(WebRequestCodingStrategy.INTERFACE_PARAMETER_NAME, auto);\n        } catch (Exception e) {\n                }\n        if (component.isStateless() && component.getPage().isBookmarkable()) {\n            parameters.put(WebRequestCodingStrategy.BOOKMARKABLE_PAGE_PARAMETER_NAME, pageMapName + ':' + component.getPage().getClass().getName());\n        }\n    }\n}", "lc": 1.5, "pi": 0.535885167464115, "ma": 2.2, "nbd": 2.0, "ml": 1.1666666666666667, "d": 0.6567460317460319, "mi": -0.9083861874559546, "fo": 2.25, "r": -0.02631578947368421, "e": 2.5196267929899783}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-2337_36a41358", "label": 1, "code": "/**\n *  @see org.apache.wicket.util.lang.PropertyResolver.IGetAndSet#getValue(java.lang.Object)\n */\npublic Object getValue(Object object) {\n    return ((List<?>) object).get(index);\n}", "code_comment": "/**\n *  @see org.apache.wicket.util.lang.PropertyResolver.IGetAndSet#getValue(java.lang.Object)\n */\n", "code_no_comment": "public Object getValue(Object object) {\n    return ((List<?>) object).get(index);\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.9960535588442565, "fo": -0.4166666666666667, "r": 1.4210526315789473, "e": -0.16279340490885932}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-143_1461f1f6", "label": 1, "code": "/**\n * {@inheritDoc}\n */\n@Override\npublic void format(final LogEvent event, final StringBuilder toAppendTo) {\n    final Message msg = event.getMessage();\n    if (msg != null) {\n        String result;\n        if (msg instanceof MultiformatMessage) {\n            result = ((MultiformatMessage) msg).getFormattedMessage(formats);\n        } else {\n            result = msg.getFormattedMessage();\n        }\n        toAppendTo.append(config != null && result.contains(\"${\") ? config.getSubst().replace(event, result) : result);\n    }\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "@Override\npublic void format(final LogEvent event, final StringBuilder toAppendTo) {\n    final Message msg = event.getMessage();\n    if (msg != null) {\n        String result;\n        if (msg instanceof MultiformatMessage) {\n            result = ((MultiformatMessage) msg).getFormattedMessage(formats);\n        } else {\n            result = msg.getFormattedMessage();\n        }\n        toAppendTo.append(config != null && result.contains(\"${\") ? config.getSubst().replace(event, result) : result);\n    }\n}", "lc": -0.045454545454545456, "pi": 0.5023923444976076, "ma": 0.0, "nbd": 0.0, "ml": 0.16666666666666666, "d": -0.021825396825396845, "mi": 0.0007047216349543532, "fo": 0.08333333333333333, "r": 0.07894736842105263, "e": -8.068094719432529e-05}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3998_b76f9c44", "label": 3, "code": "/**\n *  Check if the credit card is a Visa. A Visa number has to start with a 4 and has to have a\n *  length of 13 or 16 digits. The number has to be validated with the Luhn algorithm.\n *\n *  @param creditCardNumber\n *             the credit card number as a string\n *  @return The credit card id of the issuer\n */\nprivate CreditCard isVisa(String creditCardNumber) {\n    if (creditCardNumber.length() == 13 || creditCardNumber.length() == 16) {\n        if (creditCardNumber.startsWith(\"4\")) {\n            return CreditCard.SWITCH;\n        }\n    }\n    return CreditCard.INVALID;\n}", "code_comment": "/**\n *  Check if the credit card is a Visa. A Visa number has to start with a 4 and has to have a\n *  length of 13 or 16 digits. The number has to be validated with the Luhn algorithm.\n *\n *  @param creditCardNumber\n *             the credit card number as a string\n *  @return The credit card id of the issuer\n */\n", "code_no_comment": "private CreditCard isVisa(String creditCardNumber) {\n    if (creditCardNumber.length() == 13 || creditCardNumber.length() == 16) {\n        if (creditCardNumber.startsWith(\"4\")) {\n            return CreditCard.SWITCH;\n        }\n    }\n    return CreditCard.INVALID;\n}", "lc": -0.2727272727272727, "pi": 0.42105263157894735, "ma": -0.2, "nbd": 0.0, "ml": 0.0, "d": -0.06746031746031747, "mi": 0.3663143058491896, "fo": -0.25, "r": 1.894736842105263, "e": -0.10750159921163187}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1250_0c3b3306", "label": 1, "code": "@Override\n@Nonnull\npublic synchronized String checkpoint(long lifetime) {\n    checkArgument(lifetime > 0);\n    // TODO: Guard the checkpoint from garbage collection\n    return head.getRecordId().toString();\n}", "code_comment": NaN, "code_no_comment": "@Override\n@Nonnull\npublic synchronized String checkpoint(long lifetime) {\n    checkArgument(lifetime > 0);\n        return head.getRecordId().toString();\n}", "lc": -0.36363636363636365, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.5898520084566594, "fo": -0.25, "r": 2.1052631578947367, "e": -0.16279340490885932}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2336_d0f6715d", "label": 1, "code": "/**\n * Returns a {@link DocumentNodeState} as seen at the given\n * <code>readRevision</code>.\n *\n * @param nodeStore    the node store.\n * @param readRevision the read revision.\n * @param lastModified the revision when this node was last modified, but\n *                     the value is potentially not yet reflected in this\n *                     document.\n *                     See {@link RevisionContext#getPendingModifications()}.\n * @return the node or <code>null</code> if the node doesn't exist at the\n *         given read revision.\n */\n@CheckForNull\npublic DocumentNodeState getNodeAtRevision(@Nonnull DocumentNodeStore nodeStore, @Nonnull Revision readRevision, @Nullable Revision lastModified) {\n    Map<Revision, String> validRevisions = Maps.newHashMap();\n    Branch branch = nodeStore.getBranches().getBranch(readRevision);\n    LastRevs lastRevs = new LastRevs(getLastRev(), readRevision, branch);\n    // overlay with unsaved last modified from this instance\n    lastRevs.update(lastModified);\n    Revision min = getLiveRevision(nodeStore, readRevision, validRevisions, lastRevs);\n    if (min == null) {\n        // deleted\n        return null;\n    }\n    String path = getPath();\n    DocumentNodeState n = new DocumentNodeState(nodeStore, path, readRevision, hasChildren());\n    Revision lastRevision = min;\n    for (String key : keySet()) {\n        if (!Utils.isPropertyName(key)) {\n            continue;\n        }\n        // first check local map, which contains most recent values\n        Value value = getLatestValue(nodeStore, getLocalMap(key), min, readRevision, validRevisions, lastRevs);\n        // check if there may be more recent values in a previous document\n        if (value != null && !getPreviousRanges().isEmpty()) {\n            Revision newest = getLocalMap(key).firstKey();\n            if (!value.revision.equals(newest)) {\n                // not reading the most recent value, we may need to\n                // consider previous documents as well\n                Revision newestPrev = getPreviousRanges().firstKey();\n                if (isRevisionNewer(nodeStore, newestPrev, value.revision)) {\n                    // a previous document has more recent changes\n                    // than value.revision\n                    value = null;\n                }\n            }\n        }\n        if (value == null && !getPreviousRanges().isEmpty()) {\n            // check complete revision history\n            value = getLatestValue(nodeStore, getValueMap(key), min, readRevision, validRevisions, lastRevs);\n        }\n        String propertyName = Utils.unescapePropertyName(key);\n        String v = value != null ? value.value : null;\n        n.setProperty(propertyName, v);\n        // keep track of when this node was last modified\n        if (value != null && isRevisionNewer(nodeStore, value.revision, lastRevision)) {\n            lastRevision = value.revision;\n        }\n    }\n    // lastRevision now points to the revision when this node was\n    // last modified directly. but it may also have been 'modified'\n    // by an operation on a descendant node, which is tracked in\n    // _lastRev.\n    // when was this node last modified?\n    Revision branchBase = null;\n    if (branch != null) {\n        branchBase = branch.getBase(readRevision);\n    }\n    for (Revision r : lastRevs.get().values()) {\n        // ignore if newer than readRevision\n        if (isRevisionNewer(nodeStore, r, readRevision)) {\n            // the node has a _lastRev which is newer than readRevision\n            // this means we don't know when this node was\n            // modified by an operation on a descendant node between\n            // current lastRevision and readRevision. therefore we have\n            // to stay on the safe side and use readRevision\n            lastRevision = readRevision;\n            continue;\n        } else if (branchBase != null && isRevisionNewer(nodeStore, r, branchBase)) {\n            // readRevision is on a branch and the node has a\n            // _lastRev which is newer than the base of the branch\n            // we cannot use this _lastRev because it is not visible\n            // from this branch. highest possible revision of visible\n            // changes is the base of the branch\n            r = branchBase;\n        }\n        if (revisionAreAmbiguous(nodeStore, r, lastRevision)) {\n            // _lastRev entries from multiple cluster nodes are ambiguous\n            // use readRevision to make sure read is consistent\n            lastRevision = readRevision;\n        } else if (isRevisionNewer(nodeStore, r, lastRevision)) {\n            lastRevision = r;\n        }\n    }\n    if (branch != null) {\n        // read from a branch\n        // -> possibly overlay with unsaved last revs from branch\n        lastRevs.updateBranch(branch.getUnsavedLastRevision(path, readRevision));\n        Revision r = lastRevs.getBranchRevision();\n        if (r != null) {\n            lastRevision = r;\n        }\n    }\n    n.setLastRevision(lastRevision);\n    return n;\n}", "code_comment": "/**\n * Returns a {@link DocumentNodeState} as seen at the given\n * <code>readRevision</code>.\n *\n * @param nodeStore    the node store.\n * @param readRevision the read revision.\n * @param lastModified the revision when this node was last modified, but\n *                     the value is potentially not yet reflected in this\n *                     document.\n *                     See {@link RevisionContext#getPendingModifications()}.\n * @return the node or <code>null</code> if the node doesn't exist at the\n *         given read revision.\n */\n", "code_no_comment": "@CheckForNull\npublic DocumentNodeState getNodeAtRevision(@Nonnull DocumentNodeStore nodeStore, @Nonnull Revision readRevision, @Nullable Revision lastModified) {\n    Map<Revision, String> validRevisions = Maps.newHashMap();\n    Branch branch = nodeStore.getBranches().getBranch(readRevision);\n    LastRevs lastRevs = new LastRevs(getLastRev(), readRevision, branch);\n        lastRevs.update(lastModified);\n    Revision min = getLiveRevision(nodeStore, readRevision, validRevisions, lastRevs);\n    if (min == null) {\n                return null;\n    }\n    String path = getPath();\n    DocumentNodeState n = new DocumentNodeState(nodeStore, path, readRevision, hasChildren());\n    Revision lastRevision = min;\n    for (String key : keySet()) {\n        if (!Utils.isPropertyName(key)) {\n            continue;\n        }\n                Value value = getLatestValue(nodeStore, getLocalMap(key), min, readRevision, validRevisions, lastRevs);\n                if (value != null && !getPreviousRanges().isEmpty()) {\n            Revision newest = getLocalMap(key).firstKey();\n            if (!value.revision.equals(newest)) {\n                                                Revision newestPrev = getPreviousRanges().firstKey();\n                if (isRevisionNewer(nodeStore, newestPrev, value.revision)) {\n                                                            value = null;\n                }\n            }\n        }\n        if (value == null && !getPreviousRanges().isEmpty()) {\n                        value = getLatestValue(nodeStore, getValueMap(key), min, readRevision, validRevisions, lastRevs);\n        }\n        String propertyName = Utils.unescapePropertyName(key);\n        String v = value != null ? value.value : null;\n        n.setProperty(propertyName, v);\n                if (value != null && isRevisionNewer(nodeStore, value.revision, lastRevision)) {\n            lastRevision = value.revision;\n        }\n    }\n                        Revision branchBase = null;\n    if (branch != null) {\n        branchBase = branch.getBase(readRevision);\n    }\n    for (Revision r : lastRevs.get().values()) {\n                if (isRevisionNewer(nodeStore, r, readRevision)) {\n                                                                        lastRevision = readRevision;\n            continue;\n        } else if (branchBase != null && isRevisionNewer(nodeStore, r, branchBase)) {\n                                                                        r = branchBase;\n        }\n        if (revisionAreAmbiguous(nodeStore, r, lastRevision)) {\n                                    lastRevision = readRevision;\n        } else if (isRevisionNewer(nodeStore, r, lastRevision)) {\n            lastRevision = r;\n        }\n    }\n    if (branch != null) {\n                        lastRevs.updateBranch(branch.getUnsavedLastRevision(path, readRevision));\n        Revision r = lastRevs.getBranchRevision();\n        if (r != null) {\n            lastRevision = r;\n        }\n    }\n    n.setLastRevision(lastRevision);\n    return n;\n}", "lc": 2.272727272727273, "pi": 0.5023923444976076, "ma": 3.2, "nbd": 1.0, "ml": 2.9166666666666665, "d": 0.8690476190476191, "mi": -1.1169837914023957, "fo": 2.6666666666666665, "r": -0.02631578947368421, "e": 3.958435481175406}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2049_4af0d4ee", "label": 0, "code": "/**\n * Before writing a record (which are written backwards, from the end of the\n * file to the beginning), this method is called, to ensure there is enough\n * space. A new segment is also created if there is not enough space in the\n * segment lookup table or elsewhere.\n * <p>\n * This method does not actually write into the segment, just allocates the\n * space (flushing the segment if needed and starting a new one), and sets\n * the write position (records are written from the end to the beginning,\n * but within a record from left to right).\n *\n * @param type the record type (only used for root records)\n * @param size the size of the record, excluding the size used for the\n *            record ids\n * @param ids the record ids\n * @return a new record id\n */\nprivate RecordId prepare(RecordType type, int size, Collection<RecordId> ids) {\n    checkArgument(size >= 0);\n    checkNotNull(ids);\n    int idcount = ids.size();\n    int recordSize = align(size + idcount * RECORD_ID_BYTES);\n    // First compute the header and segment sizes based on the assumption\n    // that *all* identifiers stored in this record point to previously\n    // unreferenced segments.\n    int refcount = segment.getRefCount() + idcount;\n    int blobrefcount = blobrefs.size() + 1;\n    int rootcount = roots.size() + 1;\n    int headerSize = refcount * 16 + rootcount * 3 + blobrefcount * 2;\n    int segmentSize = align(headerSize + recordSize + length, 16);\n    // avoid the somewhat expensive list and set traversals.\n    if (segmentSize > buffer.length - 1 || refcount > Segment.SEGMENT_REFERENCE_LIMIT) {\n        refcount -= idcount;\n        Set<SegmentId> segmentIds = newIdentityHashSet();\n        for (RecordId recordId : ids) {\n            SegmentId segmentId = recordId.getSegmentId();\n            if (segmentId != segment.getSegmentId()) {\n                segmentIds.add(segmentId);\n            } else if (roots.containsKey(recordId)) {\n                rootcount--;\n            }\n        }\n        if (!segmentIds.isEmpty()) {\n            for (int refid = 1; refid < refcount; refid++) {\n                segmentIds.remove(segment.getRefId(refid));\n            }\n            refcount += segmentIds.size();\n        }\n        headerSize = refcount * 16 + rootcount * 3 + blobrefcount * 2;\n        segmentSize = align(headerSize + recordSize + length, 16);\n    }\n    if (segmentSize > buffer.length - 1 || blobrefcount > 0xffff || rootcount > 0xffff || refcount > Segment.SEGMENT_REFERENCE_LIMIT) {\n        flush();\n    }\n    length += recordSize;\n    position = buffer.length - length;\n    checkState(position >= 0);\n    RecordId id = new RecordId(segment.getSegmentId(), position);\n    roots.put(id, type);\n    return id;\n}", "code_comment": "/**\n * Before writing a record (which are written backwards, from the end of the\n * file to the beginning), this method is called, to ensure there is enough\n * space. A new segment is also created if there is not enough space in the\n * segment lookup table or elsewhere.\n * <p>\n * This method does not actually write into the segment, just allocates the\n * space (flushing the segment if needed and starting a new one), and sets\n * the write position (records are written from the end to the beginning,\n * but within a record from left to right).\n *\n * @param type the record type (only used for root records)\n * @param size the size of the record, excluding the size used for the\n *            record ids\n * @param ids the record ids\n * @return a new record id\n */\n", "code_no_comment": "private RecordId prepare(RecordType type, int size, Collection<RecordId> ids) {\n    checkArgument(size >= 0);\n    checkNotNull(ids);\n    int idcount = ids.size();\n    int recordSize = align(size + idcount * RECORD_ID_BYTES);\n                int refcount = segment.getRefCount() + idcount;\n    int blobrefcount = blobrefs.size() + 1;\n    int rootcount = roots.size() + 1;\n    int headerSize = refcount * 16 + rootcount * 3 + blobrefcount * 2;\n    int segmentSize = align(headerSize + recordSize + length, 16);\n        if (segmentSize > buffer.length - 1 || refcount > Segment.SEGMENT_REFERENCE_LIMIT) {\n        refcount -= idcount;\n        Set<SegmentId> segmentIds = newIdentityHashSet();\n        for (RecordId recordId : ids) {\n            SegmentId segmentId = recordId.getSegmentId();\n            if (segmentId != segment.getSegmentId()) {\n                segmentIds.add(segmentId);\n            } else if (roots.containsKey(recordId)) {\n                rootcount--;\n            }\n        }\n        if (!segmentIds.isEmpty()) {\n            for (int refid = 1; refid < refcount; refid++) {\n                segmentIds.remove(segment.getRefId(refid));\n            }\n            refcount += segmentIds.size();\n        }\n        headerSize = refcount * 16 + rootcount * 3 + blobrefcount * 2;\n        segmentSize = align(headerSize + recordSize + length, 16);\n    }\n    if (segmentSize > buffer.length - 1 || blobrefcount > 0xffff || rootcount > 0xffff || refcount > Segment.SEGMENT_REFERENCE_LIMIT) {\n        flush();\n    }\n    length += recordSize;\n    position = buffer.length - length;\n    checkState(position >= 0);\n    RecordId id = new RecordId(segment.getSegmentId(), position);\n    roots.put(id, type);\n    return id;\n}", "lc": 1.1818181818181819, "pi": 0.5645933014354066, "ma": 0.8, "nbd": 1.0, "ml": 1.3333333333333333, "d": 3.365079365079365, "mi": -0.791966173361522, "fo": 1.3333333333333333, "r": -0.02631578947368421, "e": 9.809201085735031}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-4420_d645112f", "label": 1, "code": "@Override\npublic NodeStore create(BlobStore blobStore, Closer closer) throws IOException {\n    FileStoreBuilder builder = fileStoreBuilder(new File(dir, \"segmentstore\"));\n    if (blobStore != null) {\n        builder.withBlobStore(blobStore);\n    }\n    builder.withMaxFileSize(256).withMemoryMapping(mmap);\n    FileStore fs = builder.build();\n    closer.register(asCloseable(fs));\n    return SegmentNodeStoreBuilders.builder(fs).build();\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic NodeStore create(BlobStore blobStore, Closer closer) throws IOException {\n    FileStoreBuilder builder = fileStoreBuilder(new File(dir, \"segmentstore\"));\n    if (blobStore != null) {\n        builder.withBlobStore(blobStore);\n    }\n    builder.withMaxFileSize(256).withMemoryMapping(mmap);\n    FileStore fs = builder.build();\n    closer.register(asCloseable(fs));\n    return SegmentNodeStoreBuilders.builder(fs).build();\n}", "lc": -0.13636363636363635, "pi": -0.3301435406698567, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": -0.09325396825396824, "mi": 0.09711064129668799, "fo": 0.25, "r": 0.02631578947368421, "e": -0.04002466531814226}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-8954_7b1253db", "label": 3, "code": "@Override\npublic boolean acquireExclusiveReadLock(GenericFileOperations<File> operations, GenericFile<File> file, Exchange exchange) throws Exception {\n    // must call super\n    if (!super.acquireExclusiveReadLock(operations, file, exchange)) {\n        return false;\n    }\n    File target = new File(file.getAbsoluteFilePath());\n    LOG.trace(\"Waiting for exclusive read lock to file: {}\", target);\n    FileChannel channel = null;\n    RandomAccessFile randomAccessFile = null;\n    boolean exclusive = false;\n    FileLock lock = null;\n    try {\n        randomAccessFile = new RandomAccessFile(target, \"rw\");\n        // try to acquire rw lock on the file before we can consume it\n        channel = randomAccessFile.getChannel();\n        StopWatch watch = new StopWatch();\n        while (!exclusive) {\n            // timeout check\n            if (timeout > 0) {\n                long delta = watch.taken();\n                if (delta > timeout) {\n                    CamelLogger.log(LOG, readLockLoggingLevel, \"Cannot acquire read lock within \" + timeout + \" millis. Will skip the file: \" + target);\n                    // we could not get the lock within the timeout period, so return false\n                    return false;\n                }\n            }\n            // get the lock using either try lock or not depending on if we are using timeout or not\n            try {\n                lock = timeout > 0 ? channel.tryLock() : channel.lock();\n            } catch (IllegalStateException ex) {\n            // Also catch the OverlappingFileLockException here. Do nothing here\n            }\n            if (lock != null) {\n                LOG.trace(\"Acquired exclusive read lock: {} to file: {}\", lock, target);\n                exclusive = true;\n            } else {\n                boolean interrupted = sleep();\n                if (interrupted) {\n                    // we were interrupted while sleeping, we are likely being shutdown so return false\n                    return false;\n                }\n            }\n        }\n    } catch (IOException e) {\n        // such as AntiVirus or MS Office that has special locks for it's supported files\n        if (timeout == 0) {\n            // if not using timeout, then we cant retry, so return false\n            return false;\n        }\n        LOG.debug(\"Cannot acquire read lock. Will try again.\", e);\n        boolean interrupted = sleep();\n        if (interrupted) {\n            // we were interrupted while sleeping, we are likely being shutdown so return false\n            return false;\n        }\n    } finally {\n        // close channels if we did not grab the lock\n        if (!exclusive) {\n            IOHelper.close(channel, \"while acquiring exclusive read lock for file: \" + target, LOG);\n            IOHelper.close(randomAccessFile, \"while acquiring exclusive read lock for file: \" + target, LOG);\n            // and also must release super lock\n            super.releaseExclusiveReadLockOnAbort(operations, file, exchange);\n        }\n    }\n    // we grabbed the lock\n    exchange.setProperty(Exchange.FILE_LOCK_EXCLUSIVE_LOCK, lock);\n    exchange.setProperty(Exchange.FILE_LOCK_RANDOM_ACCESS_FILE, randomAccessFile);\n    return true;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean acquireExclusiveReadLock(GenericFileOperations<File> operations, GenericFile<File> file, Exchange exchange) throws Exception {\n        if (!super.acquireExclusiveReadLock(operations, file, exchange)) {\n        return false;\n    }\n    File target = new File(file.getAbsoluteFilePath());\n    LOG.trace(\"Waiting for exclusive read lock to file: {}\", target);\n    FileChannel channel = null;\n    RandomAccessFile randomAccessFile = null;\n    boolean exclusive = false;\n    FileLock lock = null;\n    try {\n        randomAccessFile = new RandomAccessFile(target, \"rw\");\n                channel = randomAccessFile.getChannel();\n        StopWatch watch = new StopWatch();\n        while (!exclusive) {\n                        if (timeout > 0) {\n                long delta = watch.taken();\n                if (delta > timeout) {\n                    CamelLogger.log(LOG, readLockLoggingLevel, \"Cannot acquire read lock within \" + timeout + \" millis. Will skip the file: \" + target);\n                                        return false;\n                }\n            }\n                        try {\n                lock = timeout > 0 ? channel.tryLock() : channel.lock();\n            } catch (IllegalStateException ex) {\n                        }\n            if (lock != null) {\n                LOG.trace(\"Acquired exclusive read lock: {} to file: {}\", lock, target);\n                exclusive = true;\n            } else {\n                boolean interrupted = sleep();\n                if (interrupted) {\n                                        return false;\n                }\n            }\n        }\n    } catch (IOException e) {\n                if (timeout == 0) {\n                        return false;\n        }\n        LOG.debug(\"Cannot acquire read lock. Will try again.\", e);\n        boolean interrupted = sleep();\n        if (interrupted) {\n                        return false;\n        }\n    } finally {\n                if (!exclusive) {\n            IOHelper.close(channel, \"while acquiring exclusive read lock for file: \" + target, LOG);\n            IOHelper.close(randomAccessFile, \"while acquiring exclusive read lock for file: \" + target, LOG);\n                        super.releaseExclusiveReadLockOnAbort(operations, file, exchange);\n        }\n    }\n        exchange.setProperty(Exchange.FILE_LOCK_EXCLUSIVE_LOCK, lock);\n    exchange.setProperty(Exchange.FILE_LOCK_RANDOM_ACCESS_FILE, randomAccessFile);\n    return true;\n}", "lc": 1.9545454545454546, "pi": 1.062200956937799, "ma": 1.8, "nbd": 1.0, "ml": 1.1666666666666667, "d": 0.9841269841269841, "mi": -0.949823819591261, "fo": 0.9166666666666666, "r": -0.02631578947368421, "e": 2.657342254340923}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-8146_17475d80", "label": 3, "code": "@Override\nprotected void doStop() throws Exception {\n    ServiceHelper.stopService(scheduler);\n    // clear counters\n    backoffCounter = 0;\n    idleCounter = 0;\n    errorCounter = 0;\n    super.doStop();\n}", "code_comment": NaN, "code_no_comment": "@Override\nprotected void doStop() throws Exception {\n    ServiceHelper.stopService(scheduler);\n        backoffCounter = 0;\n    idleCounter = 0;\n    errorCounter = 0;\n    super.doStop();\n}", "lc": -0.2727272727272727, "pi": -0.5023923444976078, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.41902748414376295, "fo": -0.3333333333333333, "r": 1.8421052631578947, "e": -0.16279340490885932}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-7478_69b00a31", "label": 1, "code": "private MethodInvocation createInvocation(Object pojo, Exchange exchange, Method explicitMethod) throws AmbiguousMethodCallException, MethodNotFoundException {\n    MethodInfo methodInfo = null;\n    // find the explicit method to invoke\n    if (explicitMethod != null) {\n        Iterator<List<MethodInfo>> it = operations.values().iterator();\n        while (it.hasNext()) {\n            List<MethodInfo> infos = it.next();\n            for (MethodInfo info : infos) {\n                if (explicitMethod.equals(info.getMethod())) {\n                    return info.createMethodInvocation(pojo, exchange);\n                }\n            }\n        }\n        throw new MethodNotFoundException(exchange, pojo, explicitMethod.getName());\n    }\n    String methodName = exchange.getIn().getHeader(Exchange.BEAN_METHOD_NAME, String.class);\n    if (methodName != null) {\n        // do not use qualifier for name\n        String name = methodName;\n        if (methodName.contains(\"(\")) {\n            name = ObjectHelper.before(methodName, \"(\");\n        }\n        boolean emptyParameters = methodName.endsWith(\"()\");\n        // for example to log the class type or the likes\n        if (\"class\".equals(name) || \"getClass\".equals(name)) {\n            try {\n                Method method = pojo.getClass().getMethod(\"getClass\");\n                methodInfo = new MethodInfo(exchange.getContext(), pojo.getClass(), method, Collections.<ParameterInfo>emptyList(), Collections.<ParameterInfo>emptyList(), false, false);\n            } catch (NoSuchMethodException e) {\n                throw new MethodNotFoundException(exchange, pojo, \"getClass\");\n            }\n        // special for length on an array type\n        } else if (\"length\".equals(name) && pojo.getClass().isArray()) {\n            try {\n                // need to use arrayLength method from ObjectHelper as Camel's bean OGNL support is method invocation based\n                // and not for accessing fields. And hence we need to create a MethodInfo instance with a method to call\n                // and therefore use arrayLength from ObjectHelper to return the array length field.\n                Method method = ObjectHelper.class.getMethod(\"arrayLength\", Object[].class);\n                ParameterInfo pi = new ParameterInfo(0, Object[].class, null, ExpressionBuilder.mandatoryBodyExpression(Object[].class, true));\n                List<ParameterInfo> lpi = new ArrayList<ParameterInfo>(1);\n                lpi.add(pi);\n                methodInfo = new MethodInfo(exchange.getContext(), pojo.getClass(), method, lpi, lpi, false, false);\n            } catch (NoSuchMethodException e) {\n                throw new MethodNotFoundException(exchange, pojo, \"getClass\");\n            }\n        } else {\n            List<MethodInfo> methods = getOperations(name);\n            if (methods != null && methods.size() == 1) {\n                // only one method then choose it\n                methodInfo = methods.get(0);\n                // validate that if we want an explict no-arg method, then that's what we get\n                if (emptyParameters && methodInfo.hasParameters()) {\n                    throw new MethodNotFoundException(exchange, pojo, methodName, \"(with no parameters)\");\n                }\n            } else if (methods != null) {\n                // there are more methods with that name so we cannot decide which to use\n                // but first let's try to choose a method and see if that complies with the name\n                // must use the method name which may have qualifiers\n                methodInfo = chooseMethod(pojo, exchange, methodName);\n                // validate that if we want an explicit no-arg method, then that's what we get\n                if (emptyParameters) {\n                    if (methodInfo == null || methodInfo.hasParameters()) {\n                        // we could not find a no-arg method with that name\n                        throw new MethodNotFoundException(exchange, pojo, methodName, \"(with no parameters)\");\n                    }\n                }\n                if (methodInfo == null || !name.equals(methodInfo.getMethod().getName())) {\n                    throw new AmbiguousMethodCallException(exchange, methods);\n                }\n            } else {\n                // a specific method was given to invoke but not found\n                throw new MethodNotFoundException(exchange, pojo, methodName);\n            }\n        }\n    }\n    if (methodInfo == null) {\n        // no name or type\n        methodInfo = chooseMethod(pojo, exchange, null);\n    }\n    if (methodInfo == null) {\n        methodInfo = defaultMethod;\n    }\n    if (methodInfo != null) {\n        LOG.trace(\"Chosen method to invoke: {} on bean: {}\", methodInfo, pojo);\n        return methodInfo.createMethodInvocation(pojo, exchange);\n    }\n    LOG.debug(\"Cannot find suitable method to invoke on bean: {}\", pojo);\n    return null;\n}", "code_comment": NaN, "code_no_comment": "private MethodInvocation createInvocation(Object pojo, Exchange exchange, Method explicitMethod) throws AmbiguousMethodCallException, MethodNotFoundException {\n    MethodInfo methodInfo = null;\n        if (explicitMethod != null) {\n        Iterator<List<MethodInfo>> it = operations.values().iterator();\n        while (it.hasNext()) {\n            List<MethodInfo> infos = it.next();\n            for (MethodInfo info : infos) {\n                if (explicitMethod.equals(info.getMethod())) {\n                    return info.createMethodInvocation(pojo, exchange);\n                }\n            }\n        }\n        throw new MethodNotFoundException(exchange, pojo, explicitMethod.getName());\n    }\n    String methodName = exchange.getIn().getHeader(Exchange.BEAN_METHOD_NAME, String.class);\n    if (methodName != null) {\n                String name = methodName;\n        if (methodName.contains(\"(\")) {\n            name = ObjectHelper.before(methodName, \"(\");\n        }\n        boolean emptyParameters = methodName.endsWith(\"()\");\n                if (\"class\".equals(name) || \"getClass\".equals(name)) {\n            try {\n                Method method = pojo.getClass().getMethod(\"getClass\");\n                methodInfo = new MethodInfo(exchange.getContext(), pojo.getClass(), method, Collections.<ParameterInfo>emptyList(), Collections.<ParameterInfo>emptyList(), false, false);\n            } catch (NoSuchMethodException e) {\n                throw new MethodNotFoundException(exchange, pojo, \"getClass\");\n            }\n                } else if (\"length\".equals(name) && pojo.getClass().isArray()) {\n            try {\n                                                                Method method = ObjectHelper.class.getMethod(\"arrayLength\", Object[].class);\n                ParameterInfo pi = new ParameterInfo(0, Object[].class, null, ExpressionBuilder.mandatoryBodyExpression(Object[].class, true));\n                List<ParameterInfo> lpi = new ArrayList<ParameterInfo>(1);\n                lpi.add(pi);\n                methodInfo = new MethodInfo(exchange.getContext(), pojo.getClass(), method, lpi, lpi, false, false);\n            } catch (NoSuchMethodException e) {\n                throw new MethodNotFoundException(exchange, pojo, \"getClass\");\n            }\n        } else {\n            List<MethodInfo> methods = getOperations(name);\n            if (methods != null && methods.size() == 1) {\n                                methodInfo = methods.get(0);\n                                if (emptyParameters && methodInfo.hasParameters()) {\n                    throw new MethodNotFoundException(exchange, pojo, methodName, \"(with no parameters)\");\n                }\n            } else if (methods != null) {\n                                                                methodInfo = chooseMethod(pojo, exchange, methodName);\n                                if (emptyParameters) {\n                    if (methodInfo == null || methodInfo.hasParameters()) {\n                                                throw new MethodNotFoundException(exchange, pojo, methodName, \"(with no parameters)\");\n                    }\n                }\n                if (methodInfo == null || !name.equals(methodInfo.getMethod().getName())) {\n                    throw new AmbiguousMethodCallException(exchange, methods);\n                }\n            } else {\n                                throw new MethodNotFoundException(exchange, pojo, methodName);\n            }\n        }\n    }\n    if (methodInfo == null) {\n                methodInfo = chooseMethod(pojo, exchange, null);\n    }\n    if (methodInfo == null) {\n        methodInfo = defaultMethod;\n    }\n    if (methodInfo != null) {\n        LOG.trace(\"Chosen method to invoke: {} on bean: {}\", methodInfo, pojo);\n        return methodInfo.createMethodInvocation(pojo, exchange);\n    }\n    LOG.debug(\"Cannot find suitable method to invoke on bean: {}\", pojo);\n    return null;\n}", "lc": 2.6818181818181817, "pi": 1.1722488038277514, "ma": 4.6, "nbd": 2.5, "ml": 2.9166666666666665, "d": 1.4523809523809523, "mi": -1.246934460887949, "fo": 3.0, "r": -0.02631578947368421, "e": 7.004081303343072}
{"project_name": "Lang", "project_version": 45, "label": 3, "code": "// -----------------------------------------------------------------------\n/**\n * Abbreviates a string nicely.\n *\n * This method searches for the first space after the lower limit and abbreviates\n * the String there. It will also append any String passed as a parameter\n * to the end of the String. The upper limit can be specified to forcibly\n * abbreviate a String.\n *\n * @param str         the string to be abbreviated. If null is passed, null is returned.\n *                    If the empty String is passed, the empty string is returned.\n * @param lower       the lower limit.\n * @param upper       the upper limit; specify -1 if no limit is desired.\n *                    If the upper limit is lower than the lower limit, it will be\n *                    adjusted to be the same as the lower limit.\n * @param appendToEnd String to be appended to the end of the abbreviated string.\n *                    This is appended ONLY if the string was indeed abbreviated.\n *                    The append does not count towards the lower or upper limits.\n * @return the abbreviated String.\n * @since 2.4\n */\npublic static String abbreviate(String str, int lower, int upper, String appendToEnd) {\n    // initial parameter checks\n    if (str == null) {\n        return null;\n    }\n    if (str.length() == 0) {\n        return StringUtils.EMPTY;\n    }\n    // than the length of the string, set to the length of the string\n    if (upper == -1 || upper > str.length()) {\n        upper = str.length();\n    }\n    // if upper is less than lower, raise it to lower\n    if (upper < lower) {\n        upper = lower;\n    }\n    StringBuffer result = new StringBuffer();\n    int index = StringUtils.indexOf(str, \" \", lower);\n    if (index == -1) {\n        result.append(str.substring(0, upper));\n        // only if abbreviation has occured do we append the appendToEnd value\n        if (upper != str.length()) {\n            result.append(StringUtils.defaultString(appendToEnd));\n        }\n    } else if (index > upper) {\n        result.append(str.substring(0, upper));\n        result.append(StringUtils.defaultString(appendToEnd));\n    } else {\n        result.append(str.substring(0, index));\n        result.append(StringUtils.defaultString(appendToEnd));\n    }\n    return result.toString();\n}", "code_comment": "/**\n * Abbreviates a string nicely.\n *\n * This method searches for the first space after the lower limit and abbreviates\n * the String there. It will also append any String passed as a parameter\n * to the end of the String. The upper limit can be specified to forcibly\n * abbreviate a String.\n *\n * @param str         the string to be abbreviated. If null is passed, null is returned.\n *                    If the empty String is passed, the empty string is returned.\n * @param lower       the lower limit.\n * @param upper       the upper limit; specify -1 if no limit is desired.\n *                    If the upper limit is lower than the lower limit, it will be\n *                    adjusted to be the same as the lower limit.\n * @param appendToEnd String to be appended to the end of the abbreviated string.\n *                    This is appended ONLY if the string was indeed abbreviated.\n *                    The append does not count towards the lower or upper limits.\n * @return the abbreviated String.\n * @since 2.4\n */\n", "code_no_comment": "public static String abbreviate(String str, int lower, int upper, String appendToEnd) {\n        if (str == null) {\n        return null;\n    }\n    if (str.length() == 0) {\n        return StringUtils.EMPTY;\n    }\n        if (upper == -1 || upper > str.length()) {\n        upper = str.length();\n    }\n        if (upper < lower) {\n        upper = lower;\n    }\n    StringBuffer result = new StringBuffer();\n    int index = StringUtils.indexOf(str, \" \", lower);\n    if (index == -1) {\n        result.append(str.substring(0, upper));\n                if (upper != str.length()) {\n            result.append(StringUtils.defaultString(appendToEnd));\n        }\n    } else if (index > upper) {\n        result.append(str.substring(0, upper));\n        result.append(StringUtils.defaultString(appendToEnd));\n    } else {\n        result.append(str.substring(0, index));\n        result.append(StringUtils.defaultString(appendToEnd));\n    }\n    return result.toString();\n}", "lc": 0.6818181818181818, "pi": -0.1578947368421053, "ma": 0.8, "nbd": 0.0, "ml": 0.6666666666666666, "d": 1.7996031746031746, "mi": -0.5112050739957716, "fo": 1.0, "r": -0.02631578947368421, "e": 2.1583421217936523}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-7239_ae419224", "label": 1, "code": "protected Schema createSchema() throws SAXException, IOException {\n    SchemaFactory factory = getSchemaFactory();\n    URL url = getSchemaUrl();\n    if (url != null) {\n        return factory.newSchema(url);\n    }\n    File file = getSchemaFile();\n    if (file != null) {\n        return factory.newSchema(file);\n    }\n    byte[] bytes = getSchemaAsByteArray();\n    if (bytes != null) {\n        return factory.newSchema(new StreamSource(new ByteArrayInputStream(schemaAsByteArray)));\n    }\n    Source source = getSchemaSource();\n    return factory.newSchema(source);\n}", "code_comment": NaN, "code_no_comment": "protected Schema createSchema() throws SAXException, IOException {\n    SchemaFactory factory = getSchemaFactory();\n    URL url = getSchemaUrl();\n    if (url != null) {\n        return factory.newSchema(url);\n    }\n    File file = getSchemaFile();\n    if (file != null) {\n        return factory.newSchema(file);\n    }\n    byte[] bytes = getSchemaAsByteArray();\n    if (bytes != null) {\n        return factory.newSchema(new StreamSource(new ByteArrayInputStream(schemaAsByteArray)));\n    }\n    Source source = getSchemaSource();\n    return factory.newSchema(source);\n}", "lc": 0.13636363636363635, "pi": -0.3971291866028709, "ma": 0.0, "nbd": -0.5, "ml": 0.08333333333333333, "d": -0.04365079365079365, "mi": -0.13347427766032413, "fo": 0.25, "r": 0.21052631578947367, "e": 0.0027177953354886584}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3411_978c77ff", "label": 0, "code": "/**\n * Get the revision of the latest change made to this node.\n *\n * @param context the revision context\n * @param changeRev the revision of the current change\n * @param handler the conflict handler, which is called for concurrent changes\n *                preceding <code>changeRev</code>.\n * @return the revision, or null if deleted\n */\n@CheckForNull\npublic Revision getNewestRevision(final RevisionContext context, final Revision changeRev, final CollisionHandler handler) {\n    final Map<Revision, String> validRevisions = Maps.newHashMap();\n    Predicate<Revision> predicate = new Predicate<Revision>() {\n\n        @Override\n        public boolean apply(Revision input) {\n            if (input.equals(changeRev)) {\n                return false;\n            }\n            if (isValidRevision(context, input, null, changeRev, validRevisions)) {\n                return true;\n            }\n            handler.concurrentModification(input);\n            return false;\n        }\n    };\n    Revision newestRev = null;\n    // check local commits first\n    Comparator<Revision> comp = reverseOrder(context.getRevisionComparator());\n    SortedSet<Revision> revisions = Sets.newTreeSet(comp);\n    revisions.addAll(getLocalRevisions().keySet());\n    revisions.addAll(getLocalCommitRoot().keySet());\n    Iterator<Revision> it = filter(revisions, predicate).iterator();\n    if (it.hasNext()) {\n        newestRev = it.next();\n    } else {\n        // check full history (only needed in rare cases)\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"getNewestRevision() with changeRev {} on {}, \" + \"_revisions {}, _commitRoot {}\", changeRev, getId(), getLocalRevisions(), getLocalCommitRoot());\n        }\n        it = filter(getAllChanges(), predicate).iterator();\n        if (it.hasNext()) {\n            newestRev = it.next();\n        }\n    }\n    if (newestRev == null) {\n        return null;\n    }\n    // the local deleted map contains the most recent revisions\n    SortedMap<Revision, String> deleted = getLocalDeleted();\n    String value = deleted.get(newestRev);\n    if (value == null && deleted.headMap(newestRev).isEmpty()) {\n        // no need to check previous docs\n        return newestRev;\n    }\n    if (value == null) {\n        // get from complete map\n        value = getDeleted().get(newestRev);\n    }\n    if (\"true\".equals(value)) {\n        // deleted in the newest revision\n        return null;\n    }\n    return newestRev;\n}", "code_comment": "/**\n * Get the revision of the latest change made to this node.\n *\n * @param context the revision context\n * @param changeRev the revision of the current change\n * @param handler the conflict handler, which is called for concurrent changes\n *                preceding <code>changeRev</code>.\n * @return the revision, or null if deleted\n */\n", "code_no_comment": "@CheckForNull\npublic Revision getNewestRevision(final RevisionContext context, final Revision changeRev, final CollisionHandler handler) {\n    final Map<Revision, String> validRevisions = Maps.newHashMap();\n    Predicate<Revision> predicate = new Predicate<Revision>() {\n\n        @Override\n        public boolean apply(Revision input) {\n            if (input.equals(changeRev)) {\n                return false;\n            }\n            if (isValidRevision(context, input, null, changeRev, validRevisions)) {\n                return true;\n            }\n            handler.concurrentModification(input);\n            return false;\n        }\n    };\n    Revision newestRev = null;\n        Comparator<Revision> comp = reverseOrder(context.getRevisionComparator());\n    SortedSet<Revision> revisions = Sets.newTreeSet(comp);\n    revisions.addAll(getLocalRevisions().keySet());\n    revisions.addAll(getLocalCommitRoot().keySet());\n    Iterator<Revision> it = filter(revisions, predicate).iterator();\n    if (it.hasNext()) {\n        newestRev = it.next();\n    } else {\n                if (LOG.isDebugEnabled()) {\n            LOG.debug(\"getNewestRevision() with changeRev {} on {}, \" + \"_revisions {}, _commitRoot {}\", changeRev, getId(), getLocalRevisions(), getLocalCommitRoot());\n        }\n        it = filter(getAllChanges(), predicate).iterator();\n        if (it.hasNext()) {\n            newestRev = it.next();\n        }\n    }\n    if (newestRev == null) {\n        return null;\n    }\n        SortedMap<Revision, String> deleted = getLocalDeleted();\n    String value = deleted.get(newestRev);\n    if (value == null && deleted.headMap(newestRev).isEmpty()) {\n                return newestRev;\n    }\n    if (value == null) {\n                value = getDeleted().get(newestRev);\n    }\n    if (\"true\".equals(value)) {\n                return null;\n    }\n    return newestRev;\n}", "lc": 1.5909090909090908, "pi": 0.4066985645933013, "ma": 1.2, "nbd": 0.0, "ml": 1.4166666666666667, "d": 0.4821428571428571, "mi": -0.8539816772374911, "fo": 2.3333333333333335, "r": -0.02631578947368421, "e": 1.5203494637598471}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5853_b80f6640", "label": 3, "code": "/**\n *  @see org.apache.wicket.util.convert.IConverter#convertToObject(java.lang.String,Locale)\n */\n@Override\npublic Short convertToObject(final String value, final Locale locale) {\n    final Number number = parse(value, Short.MIN_VALUE, Short.MAX_VALUE, locale);\n    if (number == null) {\n        return null;\n    }\n    return number.shortValue();\n}", "code_comment": "/**\n *  @see org.apache.wicket.util.convert.IConverter#convertToObject(java.lang.String,Locale)\n */\n", "code_no_comment": "@Override\npublic Short convertToObject(final String value, final Locale locale) {\n    final Number number = parse(value, Short.MIN_VALUE, Short.MAX_VALUE, locale);\n    if (number == null) {\n        return null;\n    }\n    return number.shortValue();\n}", "lc": -0.2727272727272727, "pi": -0.16267942583732073, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": -0.07341269841269843, "mi": 0.34291754756871046, "fo": -0.3333333333333333, "r": 0.2631578947368421, "e": -0.09645983529560923}
{"project_name": "maven", "project_version": "remotes/origin/bugs-dot-jar_MNG-4648_83389c34", "label": 1, "code": "private void validateEffectiveDependencies(ModelProblemCollector problems, List<Dependency> dependencies, boolean managed, ModelBuildingRequest request) {\n    Severity errOn30 = getSeverity(request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0);\n    String prefix = managed ? \"dependencyManagement.dependencies.dependency.\" : \"dependencies.dependency.\";\n    for (Dependency d : dependencies) {\n        validateId(prefix + \"artifactId\", problems, d.getArtifactId(), d.getManagementKey());\n        validateId(prefix + \"groupId\", problems, d.getGroupId(), d.getManagementKey());\n        if (!managed) {\n            validateStringNotEmpty(prefix + \"type\", problems, Severity.ERROR, d.getType(), d.getManagementKey());\n            validateStringNotEmpty(prefix + \"version\", problems, Severity.ERROR, d.getVersion(), d.getManagementKey());\n        }\n        if (\"system\".equals(d.getScope())) {\n            String systemPath = d.getSystemPath();\n            if (StringUtils.isEmpty(systemPath)) {\n                addViolation(problems, Severity.ERROR, prefix + \"systemPath\", d.getManagementKey(), \"is missing.\");\n            } else {\n                File sysFile = new File(systemPath);\n                if (!sysFile.isAbsolute()) {\n                    addViolation(problems, Severity.ERROR, prefix + \"systemPath\", d.getManagementKey(), \"must specify an absolute path but is \" + systemPath);\n                } else if (!sysFile.isFile()) {\n                    String msg = \"refers to a non-existing file \" + sysFile.getAbsolutePath();\n                    systemPath = systemPath.replace('/', File.separatorChar).replace('\\\\', File.separatorChar);\n                    String jdkHome = request.getSystemProperties().getProperty(\"java.home\", \"\") + File.separator + \"..\";\n                    if (systemPath.startsWith(jdkHome)) {\n                        msg += \". Please verify that you run Maven using a JDK and not just a JRE.\";\n                    }\n                    addViolation(problems, Severity.WARNING, prefix + \"systemPath\", d.getManagementKey(), msg);\n                }\n            }\n        } else if (StringUtils.isNotEmpty(d.getSystemPath())) {\n            addViolation(problems, Severity.ERROR, prefix + \"systemPath\", d.getManagementKey(), \"must be omitted.\" + \" This field may only be specified for a dependency with system scope.\");\n        }\n        if (request.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0) {\n            validateBoolean(prefix + \"optional\", problems, errOn30, d.getOptional(), d.getManagementKey());\n            if (!managed) {\n                validateVersion(prefix + \"version\", problems, errOn30, d.getVersion(), d.getManagementKey());\n                /*\n                     * TODO: Extensions like Flex Mojos use custom scopes like \"merged\", \"internal\", \"external\", etc. In\n                     * order to don't break backward-compat with those, only warn but don't error out.\n                     */\n                validateEnum(prefix + \"scope\", problems, Severity.WARNING, d.getScope(), d.getManagementKey(), \"provided\", \"compile\", \"runtime\", \"test\", \"system\");\n            }\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "private void validateEffectiveDependencies(ModelProblemCollector problems, List<Dependency> dependencies, boolean managed, ModelBuildingRequest request) {\n    Severity errOn30 = getSeverity(request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0);\n    String prefix = managed ? \"dependencyManagement.dependencies.dependency.\" : \"dependencies.dependency.\";\n    for (Dependency d : dependencies) {\n        validateId(prefix + \"artifactId\", problems, d.getArtifactId(), d.getManagementKey());\n        validateId(prefix + \"groupId\", problems, d.getGroupId(), d.getManagementKey());\n        if (!managed) {\n            validateStringNotEmpty(prefix + \"type\", problems, Severity.ERROR, d.getType(), d.getManagementKey());\n            validateStringNotEmpty(prefix + \"version\", problems, Severity.ERROR, d.getVersion(), d.getManagementKey());\n        }\n        if (\"system\".equals(d.getScope())) {\n            String systemPath = d.getSystemPath();\n            if (StringUtils.isEmpty(systemPath)) {\n                addViolation(problems, Severity.ERROR, prefix + \"systemPath\", d.getManagementKey(), \"is missing.\");\n            } else {\n                File sysFile = new File(systemPath);\n                if (!sysFile.isAbsolute()) {\n                    addViolation(problems, Severity.ERROR, prefix + \"systemPath\", d.getManagementKey(), \"must specify an absolute path but is \" + systemPath);\n                } else if (!sysFile.isFile()) {\n                    String msg = \"refers to a non-existing file \" + sysFile.getAbsolutePath();\n                    systemPath = systemPath.replace('/', File.separatorChar).replace('\\\\', File.separatorChar);\n                    String jdkHome = request.getSystemProperties().getProperty(\"java.home\", \"\") + File.separator + \"..\";\n                    if (systemPath.startsWith(jdkHome)) {\n                        msg += \". Please verify that you run Maven using a JDK and not just a JRE.\";\n                    }\n                    addViolation(problems, Severity.WARNING, prefix + \"systemPath\", d.getManagementKey(), msg);\n                }\n            }\n        } else if (StringUtils.isNotEmpty(d.getSystemPath())) {\n            addViolation(problems, Severity.ERROR, prefix + \"systemPath\", d.getManagementKey(), \"must be omitted.\" + \" This field may only be specified for a dependency with system scope.\");\n        }\n        if (request.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0) {\n            validateBoolean(prefix + \"optional\", problems, errOn30, d.getOptional(), d.getManagementKey());\n            if (!managed) {\n                validateVersion(prefix + \"version\", problems, errOn30, d.getVersion(), d.getManagementKey());\n                                validateEnum(prefix + \"scope\", problems, Severity.WARNING, d.getScope(), d.getManagementKey(), \"provided\", \"compile\", \"runtime\", \"test\", \"system\");\n            }\n        }\n    }\n}", "lc": 1.1818181818181819, "pi": 1.3923444976076558, "ma": 1.6, "nbd": 2.0, "ml": 1.4166666666666667, "d": 0.6150793650793652, "mi": -0.845243128964059, "fo": 3.25, "r": -0.02631578947368421, "e": 2.990559176593304}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3433_b76b31f7", "label": 0, "code": "/**\n * Recover the correct _lastRev updates for the given candidate nodes.\n *\n * @param suspects the potential suspects\n * @param clusterId the cluster id for which _lastRev recovery needed\n * @param dryRun if {@code true}, this method will only perform a check\n *               but not apply the changes to the _lastRev fields.\n * @return the number of documents that required recovery. This method\n *          returns the number of the affected documents even if\n *          {@code dryRun} is set true and no document was changed.\n */\npublic int recover(Iterator<NodeDocument> suspects, int clusterId, boolean dryRun) {\n    UnsavedModifications unsaved = new UnsavedModifications();\n    UnsavedModifications unsavedParents = new UnsavedModifications();\n    // Map of known last rev of checked paths\n    Map<String, Revision> knownLastRevOrModification = MapFactory.getInstance().create();\n    final DocumentStore docStore = nodeStore.getDocumentStore();\n    final JournalEntry changes = JOURNAL.newDocument(docStore);\n    long count = 0;\n    while (suspects.hasNext()) {\n        NodeDocument doc = suspects.next();\n        count++;\n        if (count % 100000 == 0) {\n            log.info(\"Scanned {} suspects so far...\", count);\n        }\n        Revision currentLastRev = doc.getLastRev().get(clusterId);\n        // 1. determine last committed modification on document\n        Revision lastModifiedRev = determineLastModification(doc, clusterId);\n        Revision lastRevForParents = Utils.max(lastModifiedRev, currentLastRev);\n        // _lastRev entry or an explicit modification on the document\n        if (lastRevForParents != null) {\n            knownLastRevOrModification.put(doc.getPath(), lastRevForParents);\n        }\n        // 2. Update lastRev for parent paths aka rollup\n        if (lastRevForParents != null) {\n            String path = doc.getPath();\n            // track all changes\n            changes.modified(path);\n            while (true) {\n                if (PathUtils.denotesRoot(path)) {\n                    break;\n                }\n                path = PathUtils.getParentPath(path);\n                unsavedParents.put(path, lastRevForParents);\n            }\n        }\n    }\n    for (String parentPath : unsavedParents.getPaths()) {\n        Revision calcLastRev = unsavedParents.get(parentPath);\n        Revision knownLastRev = knownLastRevOrModification.get(parentPath);\n        if (knownLastRev == null) {\n            // we don't know when the document was last modified with\n            // the given clusterId. need to read from store\n            String id = Utils.getIdFromPath(parentPath);\n            NodeDocument doc = docStore.find(NODES, id);\n            if (doc != null) {\n                Revision lastRev = doc.getLastRev().get(clusterId);\n                Revision lastMod = determineLastModification(doc, clusterId);\n                knownLastRev = Utils.max(lastRev, lastMod);\n            } else {\n                log.warn(\"Unable to find document: {}\", id);\n                continue;\n            }\n        }\n        // This check ensures that unnecessary updates are not made\n        if (knownLastRev == null || calcLastRev.compareRevisionTime(knownLastRev) > 0) {\n            unsaved.put(parentPath, calcLastRev);\n        }\n    }\n    // take the root's lastRev\n    final Revision lastRootRev = unsaved.get(\"/\");\n    // Note the size before persist as persist operation\n    // would empty the internal state\n    int size = unsaved.getPaths().size();\n    String updates = unsaved.toString();\n    if (dryRun) {\n        log.info(\"Dry run of lastRev recovery identified [{}] documents for \" + \"cluster node [{}]: {}\", size, clusterId, updates);\n    } else {\n        // UnsavedModifications is designed to be used in concurrent\n        // access mode. For recovery case there is no concurrent access\n        // involve so just pass a new lock instance\n        // the lock uses to do the persisting is a plain reentrant lock\n        // thus it doesn't matter, where exactly the check is done\n        // as to whether the recovered lastRev has already been\n        // written to the journal.\n        unsaved.persist(nodeStore, new UnsavedModifications.Snapshot() {\n\n            @Override\n            public void acquiring() {\n                if (lastRootRev == null) {\n                    // then we cannot and probably don't have to persist anything\n                    return;\n                }\n                // lastRootRev never null at this point\n                final String id = JournalEntry.asId(lastRootRev);\n                final JournalEntry existingEntry = docStore.find(Collection.JOURNAL, id);\n                if (existingEntry != null) {\n                    // hence: nothing to be done here. return.\n                    return;\n                }\n                // otherwise store a new journal entry now\n                docStore.create(JOURNAL, singletonList(changes.asUpdateOp(lastRootRev)));\n            }\n        }, new ReentrantLock());\n        log.info(\"Updated lastRev of [{}] documents while performing lastRev recovery for \" + \"cluster node [{}]: {}\", size, clusterId, updates);\n    }\n    return size;\n}", "code_comment": "/**\n * Recover the correct _lastRev updates for the given candidate nodes.\n *\n * @param suspects the potential suspects\n * @param clusterId the cluster id for which _lastRev recovery needed\n * @param dryRun if {@code true}, this method will only perform a check\n *               but not apply the changes to the _lastRev fields.\n * @return the number of documents that required recovery. This method\n *          returns the number of the affected documents even if\n *          {@code dryRun} is set true and no document was changed.\n */\n", "code_no_comment": "public int recover(Iterator<NodeDocument> suspects, int clusterId, boolean dryRun) {\n    UnsavedModifications unsaved = new UnsavedModifications();\n    UnsavedModifications unsavedParents = new UnsavedModifications();\n        Map<String, Revision> knownLastRevOrModification = MapFactory.getInstance().create();\n    final DocumentStore docStore = nodeStore.getDocumentStore();\n    final JournalEntry changes = JOURNAL.newDocument(docStore);\n    long count = 0;\n    while (suspects.hasNext()) {\n        NodeDocument doc = suspects.next();\n        count++;\n        if (count % 100000 == 0) {\n            log.info(\"Scanned {} suspects so far...\", count);\n        }\n        Revision currentLastRev = doc.getLastRev().get(clusterId);\n                Revision lastModifiedRev = determineLastModification(doc, clusterId);\n        Revision lastRevForParents = Utils.max(lastModifiedRev, currentLastRev);\n                if (lastRevForParents != null) {\n            knownLastRevOrModification.put(doc.getPath(), lastRevForParents);\n        }\n                if (lastRevForParents != null) {\n            String path = doc.getPath();\n                        changes.modified(path);\n            while (true) {\n                if (PathUtils.denotesRoot(path)) {\n                    break;\n                }\n                path = PathUtils.getParentPath(path);\n                unsavedParents.put(path, lastRevForParents);\n            }\n        }\n    }\n    for (String parentPath : unsavedParents.getPaths()) {\n        Revision calcLastRev = unsavedParents.get(parentPath);\n        Revision knownLastRev = knownLastRevOrModification.get(parentPath);\n        if (knownLastRev == null) {\n                                    String id = Utils.getIdFromPath(parentPath);\n            NodeDocument doc = docStore.find(NODES, id);\n            if (doc != null) {\n                Revision lastRev = doc.getLastRev().get(clusterId);\n                Revision lastMod = determineLastModification(doc, clusterId);\n                knownLastRev = Utils.max(lastRev, lastMod);\n            } else {\n                log.warn(\"Unable to find document: {}\", id);\n                continue;\n            }\n        }\n                if (knownLastRev == null || calcLastRev.compareRevisionTime(knownLastRev) > 0) {\n            unsaved.put(parentPath, calcLastRev);\n        }\n    }\n        final Revision lastRootRev = unsaved.get(\"/\");\n            int size = unsaved.getPaths().size();\n    String updates = unsaved.toString();\n    if (dryRun) {\n        log.info(\"Dry run of lastRev recovery identified [{}] documents for \" + \"cluster node [{}]: {}\", size, clusterId, updates);\n    } else {\n                                                                unsaved.persist(nodeStore, new UnsavedModifications.Snapshot() {\n\n            @Override\n            public void acquiring() {\n                if (lastRootRev == null) {\n                                        return;\n                }\n                                final String id = JournalEntry.asId(lastRootRev);\n                final JournalEntry existingEntry = docStore.find(Collection.JOURNAL, id);\n                if (existingEntry != null) {\n                                        return;\n                }\n                                docStore.create(JOURNAL, singletonList(changes.asUpdateOp(lastRootRev)));\n            }\n        }, new ReentrantLock());\n        log.info(\"Updated lastRev of [{}] documents while performing lastRev recovery for \" + \"cluster node [{}]: {}\", size, clusterId, updates);\n    }\n    return size;\n}", "lc": 2.727272727272727, "pi": 0.9473684210526314, "ma": 2.4, "nbd": 1.0, "ml": 1.5833333333333333, "d": 1.6587301587301586, "mi": -1.1733615221987312, "fo": 3.0, "r": -0.02631578947368421, "e": 7.374074906496544}
{"project_name": "Closure", "project_version": 174, "label": 2, "code": "/**\n * Creates a node representing a qualified name.\n *\n * @param name A qualified name (e.g. \"foo\" or \"foo.bar.baz\")\n * @return A NAME or GETPROP node\n */\npublic static Node newQualifiedNameNodeDeclaration(CodingConvention convention, String name, Node value, JSDocInfo info) {\n    Node result;\n    Node nameNode = newQualifiedNameNode(convention, name);\n    if (nameNode.isName()) {\n        result = IR.var(nameNode, value);\n        result.setJSDocInfo(info);\n    } else {\n        result = IR.exprResult(IR.assign(nameNode, value));\n        result.getFirstChild().setJSDocInfo(info);\n    }\n    return result;\n}", "code_comment": "/**\n * Creates a node representing a qualified name.\n *\n * @param name A qualified name (e.g. \"foo\" or \"foo.bar.baz\")\n * @return A NAME or GETPROP node\n */\n", "code_no_comment": "public static Node newQualifiedNameNodeDeclaration(CodingConvention convention, String name, Node value, JSDocInfo info) {\n    Node result;\n    Node nameNode = newQualifiedNameNode(convention, name);\n    if (nameNode.isName()) {\n        result = IR.var(nameNode, value);\n        result.setJSDocInfo(info);\n    } else {\n        result = IR.exprResult(IR.assign(nameNode, value));\n        result.getFirstChild().setJSDocInfo(info);\n    }\n    return result;\n}", "lc": -0.09090909090909091, "pi": -0.11483253588516758, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": -0.3650793650793651, "mi": 0.061592670894996523, "fo": 0.16666666666666666, "r": 0.07894736842105263, "e": -0.16279340490885932}
{"project_name": "Closure", "project_version": 153, "label": 2, "code": "/**\n * Declares a variable.\n *\n * @param n The node corresponding to the variable name.\n * @param declaredType The variable's type, according to JSDoc\n */\nprivate void declareVar(String name, Node n, Node parent, Node gramps, JSType declaredType, Node nodeWithLineNumber) {\n    if (scope.isDeclared(name, false) || (scope.isLocal() && name.equals(ARGUMENTS))) {\n        redeclarationHandler.onRedeclaration(scope, name, n, parent, gramps, nodeWithLineNumber);\n    } else {\n        scope.declare(name, n, declaredType, compiler.getInput(sourceName));\n    }\n}", "code_comment": "/**\n * Declares a variable.\n *\n * @param n The node corresponding to the variable name.\n * @param declaredType The variable's type, according to JSDoc\n */\n", "code_no_comment": "private void declareVar(String name, Node n, Node parent, Node gramps, JSType declaredType, Node nodeWithLineNumber) {\n    if (scope.isDeclared(name, false) || (scope.isLocal() && name.equals(ARGUMENTS))) {\n        redeclarationHandler.onRedeclaration(scope, name, n, parent, gramps, nodeWithLineNumber);\n    } else {\n        scope.declare(name, n, declaredType, compiler.getInput(sourceName));\n    }\n}", "lc": -0.3181818181818182, "pi": 0.01435406698564584, "ma": -0.4, "nbd": -0.5, "ml": 0.16666666666666666, "d": -0.0277777777777778, "mi": 0.3065539112050739, "fo": 0.0, "r": -0.02631578947368421, "e": -0.013948583184938015}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3304_7e7ab76c", "label": 3, "code": "/**\n *  @see org.apache.wicket.markup.html.form.FormComponent#convertValue(String[])\n */\n@Override\nprotected T convertValue(String[] value) throws ConversionException {\n    String tmp = value != null && value.length > 0 ? value[0] : null;\n    if (getConvertEmptyInputStringToNull() && Strings.isEmpty(tmp)) {\n        return null;\n    }\n    return super.convertValue(value);\n}", "code_comment": "/**\n *  @see org.apache.wicket.markup.html.form.FormComponent#convertValue(String[])\n */\n", "code_no_comment": "@Override\nprotected T convertValue(String[] value) throws ConversionException {\n    String tmp = value != null && value.length > 0 ? value[0] : null;\n    if (getConvertEmptyInputStringToNull() && Strings.isEmpty(tmp)) {\n        return null;\n    }\n    return super.convertValue(value);\n}", "lc": -0.2727272727272727, "pi": -0.16267942583732073, "ma": -0.2, "nbd": -0.5, "ml": 0.3333333333333333, "d": 0.31547619047619047, "mi": 0.30570824524312884, "fo": -0.25, "r": 0.763157894736842, "e": 0.02835589518392374}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-2494_0dc92ca1", "label": 1, "code": "public String toString() {\n    return String.format(\"%,d %,d %,.2f %,d\", getMin(), getMax(), getAverage(), count);\n}", "code_comment": NaN, "code_no_comment": "public String toString() {\n    return String.format(\"%,d %,d %,.2f %,d\", getMin(), getMax(), getAverage(), count);\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.9627906976744184, "fo": -0.16666666666666666, "r": -0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "Cli", "project_version": 28, "label": 3, "code": "/**\n * Sets the values of Options using the values in <code>properties</code>.\n *\n * @param properties The value properties to be processed.\n */\nprotected void processProperties(Properties properties) {\n    if (properties == null) {\n        return;\n    }\n    for (Enumeration e = properties.propertyNames(); e.hasMoreElements(); ) {\n        String option = e.nextElement().toString();\n        if (!cmd.hasOption(option)) {\n            Option opt = getOptions().getOption(option);\n            // get the value from the properties instance\n            String value = properties.getProperty(option);\n            if (opt.hasArg()) {\n                if (opt.getValues() == null || opt.getValues().length == 0) {\n                    try {\n                        opt.addValueForProcessing(value);\n                    } catch (RuntimeException exp) {\n                    // if we cannot add the value don't worry about it\n                    }\n                }\n            } else if (!(\"yes\".equalsIgnoreCase(value) || \"true\".equalsIgnoreCase(value) || \"1\".equalsIgnoreCase(value))) {\n                // option to the CommandLine\n                break;\n            }\n            cmd.addOption(opt);\n        }\n    }\n}", "code_comment": "/**\n * Sets the values of Options using the values in <code>properties</code>.\n *\n * @param properties The value properties to be processed.\n */\n", "code_no_comment": "protected void processProperties(Properties properties) {\n    if (properties == null) {\n        return;\n    }\n    for (Enumeration e = properties.propertyNames(); e.hasMoreElements(); ) {\n        String option = e.nextElement().toString();\n        if (!cmd.hasOption(option)) {\n            Option opt = getOptions().getOption(option);\n                        String value = properties.getProperty(option);\n            if (opt.hasArg()) {\n                if (opt.getValues() == null || opt.getValues().length == 0) {\n                    try {\n                        opt.addValueForProcessing(value);\n                    } catch (RuntimeException exp) {\n                                        }\n                }\n            } else if (!(\"yes\".equalsIgnoreCase(value) || \"true\".equalsIgnoreCase(value) || \"1\".equalsIgnoreCase(value))) {\n                                break;\n            }\n            cmd.addOption(opt);\n        }\n    }\n}", "lc": 0.4090909090909091, "pi": 1.6698564593301437, "ma": 1.0, "nbd": 1.5, "ml": 1.25, "d": 0.30753968253968256, "mi": -0.37082452431289636, "fo": 0.8333333333333334, "r": 0.0, "e": 0.38334745249909224}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5853_b80f6640", "label": 3, "code": "/**\n *  @param locale\n *             The locale\n *  @return Returns the numberFormat.\n */\n@Override\npublic NumberFormat getNumberFormat(final Locale locale) {\n    NumberFormat numberFormat = numberFormats.get(locale);\n    if (numberFormat == null) {\n        numberFormat = NumberFormat.getIntegerInstance(locale);\n        numberFormat.setParseIntegerOnly(true);\n        numberFormat.setGroupingUsed(false);\n        NumberFormat tmpNumberFormat = numberFormats.putIfAbsent(locale, numberFormat);\n        if (tmpNumberFormat != null) {\n            numberFormat = tmpNumberFormat;\n        }\n    }\n    return (NumberFormat) numberFormat.clone();\n}", "code_comment": "/**\n *  @param locale\n *             The locale\n *  @return Returns the numberFormat.\n */\n", "code_no_comment": "@Override\npublic NumberFormat getNumberFormat(final Locale locale) {\n    NumberFormat numberFormat = numberFormats.get(locale);\n    if (numberFormat == null) {\n        numberFormat = NumberFormat.getIntegerInstance(locale);\n        numberFormat.setParseIntegerOnly(true);\n        numberFormat.setGroupingUsed(false);\n        NumberFormat tmpNumberFormat = numberFormats.putIfAbsent(locale, numberFormat);\n        if (tmpNumberFormat != null) {\n            numberFormat = tmpNumberFormat;\n        }\n    }\n    return (NumberFormat) numberFormat.clone();\n}", "lc": 0.0, "pi": 0.2822966507177033, "ma": -0.2, "nbd": 0.0, "ml": -0.08333333333333333, "d": 0.03174603174603173, "mi": -0.011698379140239377, "fo": 0.0, "r": 0.10526315789473684, "e": 0.007305083475965707}
{"project_name": "Closure", "project_version": 30, "label": 2, "code": "boolean dependsOnOuterScopeVars(String name, Node useNode) {\n    Preconditions.checkArgument(getCfg().hasNode(useNode));\n    GraphNode<Node, Branch> n = getCfg().getNode(useNode);\n    FlowState<MustDef> state = n.getAnnotation();\n    Definition def = state.getIn().reachingDef.get(jsScope.getVar(name));\n    for (Var s : def.depends) {\n        if (s.scope != jsScope) {\n            return true;\n        }\n    }\n    return false;\n}", "code_comment": NaN, "code_no_comment": "boolean dependsOnOuterScopeVars(String name, Node useNode) {\n    Preconditions.checkArgument(getCfg().hasNode(useNode));\n    GraphNode<Node, Branch> n = getCfg().getNode(useNode);\n    FlowState<MustDef> state = n.getAnnotation();\n    Definition def = state.getIn().reachingDef.get(jsScope.getVar(name));\n    for (Var s : def.depends) {\n        if (s.scope != jsScope) {\n            return true;\n        }\n    }\n    return false;\n}", "lc": -0.09090909090909091, "pi": 0.10047846889952151, "ma": -0.2, "nbd": 0.0, "ml": -0.16666666666666666, "d": -0.10317460317460318, "mi": 0.028047921071177005, "fo": 0.25, "r": 0.0, "e": -0.024381782242123513}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2442_ea7a6199", "label": 1, "code": "/**\n * Returns a {@link DocumentNodeState} as seen at the given\n * <code>readRevision</code>.\n *\n * @param nodeStore    the node store.\n * @param readRevision the read revision.\n * @param lastModified the revision when this node was last modified, but\n *                     the value is potentially not yet reflected in this\n *                     document.\n *                     See {@link RevisionContext#getPendingModifications()}.\n * @return the node or <code>null</code> if the node doesn't exist at the\n *         given read revision.\n */\n@CheckForNull\npublic DocumentNodeState getNodeAtRevision(@Nonnull DocumentNodeStore nodeStore, @Nonnull Revision readRevision, @Nullable Revision lastModified) {\n    Map<Revision, String> validRevisions = Maps.newHashMap();\n    Branch branch = nodeStore.getBranches().getBranch(readRevision);\n    LastRevs lastRevs = new LastRevs(getLastRev(), readRevision, branch);\n    // overlay with unsaved last modified from this instance\n    lastRevs.update(lastModified);\n    Revision min = getLiveRevision(nodeStore, readRevision, validRevisions, lastRevs);\n    if (min == null) {\n        // deleted\n        return null;\n    }\n    String path = getPath();\n    DocumentNodeState n = new DocumentNodeState(nodeStore, path, readRevision, hasChildren());\n    Revision lastRevision = min;\n    for (String key : keySet()) {\n        if (!Utils.isPropertyName(key)) {\n            continue;\n        }\n        // first check local map, which contains most recent values\n        Value value = getLatestValue(nodeStore, getLocalMap(key), min, readRevision, validRevisions, lastRevs);\n        // check if there may be more recent values in a previous document\n        if (!getPreviousRanges().isEmpty()) {\n            Revision newest = getLocalMap(key).firstKey();\n            if (isRevisionNewer(nodeStore, newest, value.revision)) {\n                // not reading the most recent value, we may need to\n                // consider previous documents as well\n                Revision newestPrev = getPreviousRanges().firstKey();\n                if (isRevisionNewer(nodeStore, newestPrev, value.revision)) {\n                    // a previous document has more recent changes\n                    // than value.revision\n                    value = null;\n                }\n            }\n        }\n        if (value == null && !getPreviousRanges().isEmpty()) {\n            // check complete revision history\n            value = getLatestValue(nodeStore, getValueMap(key), min, readRevision, validRevisions, lastRevs);\n        }\n        String propertyName = Utils.unescapePropertyName(key);\n        String v = value != null ? value.value : null;\n        n.setProperty(propertyName, v);\n        // keep track of when this node was last modified\n        if (value != null && isRevisionNewer(nodeStore, value.revision, lastRevision)) {\n            lastRevision = value.revision;\n        }\n    }\n    // lastRevision now points to the revision when this node was\n    // last modified directly. but it may also have been 'modified'\n    // by an operation on a descendant node, which is tracked in\n    // _lastRev.\n    // when was this node last modified?\n    Revision branchBase = null;\n    if (branch != null) {\n        branchBase = branch.getBase(readRevision);\n    }\n    for (Revision r : lastRevs.get().values()) {\n        // ignore if newer than readRevision\n        if (isRevisionNewer(nodeStore, r, readRevision)) {\n            // the node has a _lastRev which is newer than readRevision\n            // this means we don't know when this node was\n            // modified by an operation on a descendant node between\n            // current lastRevision and readRevision. therefore we have\n            // to stay on the safe side and use readRevision\n            lastRevision = readRevision;\n            continue;\n        } else if (branchBase != null && isRevisionNewer(nodeStore, r, branchBase)) {\n            // readRevision is on a branch and the node has a\n            // _lastRev which is newer than the base of the branch\n            // we cannot use this _lastRev because it is not visible\n            // from this branch. highest possible revision of visible\n            // changes is the base of the branch\n            r = branchBase;\n        }\n        if (revisionAreAmbiguous(nodeStore, r, lastRevision)) {\n            // _lastRev entries from multiple cluster nodes are ambiguous\n            // use readRevision to make sure read is consistent\n            lastRevision = readRevision;\n        } else if (isRevisionNewer(nodeStore, r, lastRevision)) {\n            lastRevision = r;\n        }\n    }\n    if (branch != null) {\n        // read from a branch\n        // -> possibly overlay with unsaved last revs from branch\n        lastRevs.updateBranch(branch.getUnsavedLastRevision(path, readRevision));\n        Revision r = lastRevs.getBranchRevision();\n        if (r != null) {\n            lastRevision = r;\n        }\n    }\n    n.setLastRevision(lastRevision);\n    return n;\n}", "code_comment": "/**\n * Returns a {@link DocumentNodeState} as seen at the given\n * <code>readRevision</code>.\n *\n * @param nodeStore    the node store.\n * @param readRevision the read revision.\n * @param lastModified the revision when this node was last modified, but\n *                     the value is potentially not yet reflected in this\n *                     document.\n *                     See {@link RevisionContext#getPendingModifications()}.\n * @return the node or <code>null</code> if the node doesn't exist at the\n *         given read revision.\n */\n", "code_no_comment": "@CheckForNull\npublic DocumentNodeState getNodeAtRevision(@Nonnull DocumentNodeStore nodeStore, @Nonnull Revision readRevision, @Nullable Revision lastModified) {\n    Map<Revision, String> validRevisions = Maps.newHashMap();\n    Branch branch = nodeStore.getBranches().getBranch(readRevision);\n    LastRevs lastRevs = new LastRevs(getLastRev(), readRevision, branch);\n        lastRevs.update(lastModified);\n    Revision min = getLiveRevision(nodeStore, readRevision, validRevisions, lastRevs);\n    if (min == null) {\n                return null;\n    }\n    String path = getPath();\n    DocumentNodeState n = new DocumentNodeState(nodeStore, path, readRevision, hasChildren());\n    Revision lastRevision = min;\n    for (String key : keySet()) {\n        if (!Utils.isPropertyName(key)) {\n            continue;\n        }\n                Value value = getLatestValue(nodeStore, getLocalMap(key), min, readRevision, validRevisions, lastRevs);\n                if (!getPreviousRanges().isEmpty()) {\n            Revision newest = getLocalMap(key).firstKey();\n            if (isRevisionNewer(nodeStore, newest, value.revision)) {\n                                                Revision newestPrev = getPreviousRanges().firstKey();\n                if (isRevisionNewer(nodeStore, newestPrev, value.revision)) {\n                                                            value = null;\n                }\n            }\n        }\n        if (value == null && !getPreviousRanges().isEmpty()) {\n                        value = getLatestValue(nodeStore, getValueMap(key), min, readRevision, validRevisions, lastRevs);\n        }\n        String propertyName = Utils.unescapePropertyName(key);\n        String v = value != null ? value.value : null;\n        n.setProperty(propertyName, v);\n                if (value != null && isRevisionNewer(nodeStore, value.revision, lastRevision)) {\n            lastRevision = value.revision;\n        }\n    }\n                        Revision branchBase = null;\n    if (branch != null) {\n        branchBase = branch.getBase(readRevision);\n    }\n    for (Revision r : lastRevs.get().values()) {\n                if (isRevisionNewer(nodeStore, r, readRevision)) {\n                                                                        lastRevision = readRevision;\n            continue;\n        } else if (branchBase != null && isRevisionNewer(nodeStore, r, branchBase)) {\n                                                                        r = branchBase;\n        }\n        if (revisionAreAmbiguous(nodeStore, r, lastRevision)) {\n                                    lastRevision = readRevision;\n        } else if (isRevisionNewer(nodeStore, r, lastRevision)) {\n            lastRevision = r;\n        }\n    }\n    if (branch != null) {\n                        lastRevs.updateBranch(branch.getUnsavedLastRevision(path, readRevision));\n        Revision r = lastRevs.getBranchRevision();\n        if (r != null) {\n            lastRevision = r;\n        }\n    }\n    n.setLastRevision(lastRevision);\n    return n;\n}", "lc": 2.272727272727273, "pi": 0.5023923444976076, "ma": 3.2, "nbd": 1.0, "ml": 2.8333333333333335, "d": 0.882936507936508, "mi": -1.1138830162085973, "fo": 2.6666666666666665, "r": -0.02631578947368421, "e": 3.918546820882534}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1614_86edbffb", "label": 1, "code": "@Override\nprotected TokenStreamComponents createComponents(final String fieldName, final Reader reader) {\n    WhitespaceTokenizer src = new WhitespaceTokenizer(matchVersion, reader);\n    TokenStream tok = new LowerCaseFilter(matchVersion, src);\n    tok = new WordDelimiterFilter(tok, WordDelimiterFilter.GENERATE_WORD_PARTS | WordDelimiterFilter.STEM_ENGLISH_POSSESSIVE | WordDelimiterFilter.GENERATE_NUMBER_PARTS, null);\n    return new TokenStreamComponents(src, tok);\n}", "code_comment": NaN, "code_no_comment": "@Override\nprotected TokenStreamComponents createComponents(final String fieldName, final Reader reader) {\n    WhitespaceTokenizer src = new WhitespaceTokenizer(matchVersion, reader);\n    TokenStream tok = new LowerCaseFilter(matchVersion, src);\n    tok = new WordDelimiterFilter(tok, WordDelimiterFilter.GENERATE_WORD_PARTS | WordDelimiterFilter.STEM_ENGLISH_POSSESSIVE | WordDelimiterFilter.GENERATE_NUMBER_PARTS, null);\n    return new TokenStreamComponents(src, tok);\n}", "lc": -0.3181818181818182, "pi": -0.48325358851674655, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.041666666666666706, "mi": 0.3443269908386188, "fo": -0.5, "r": 0.0, "e": -0.04715686105012016}
{"project_name": "Closure", "project_version": 64, "label": 2, "code": "public Void call() throws Exception {\n    if (options.printInputDelimiter) {\n        if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n            // Make sure that the label starts on a new line\n            cb.append(\"\\n\");\n        }\n        Preconditions.checkState(root.getType() == Token.SCRIPT);\n        String delimiter = options.inputDelimiter;\n        String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n        Preconditions.checkState(sourceName != null);\n        Preconditions.checkState(!sourceName.isEmpty());\n        delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n        cb.append(delimiter).append(\"\\n\");\n    }\n    if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n        cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n    }\n    // root node's mappings are offset by the given string builder buffer.\n    if (options.sourceMapOutputPath != null) {\n        sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n    }\n    // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n    // for the first input file\n    String code = toSource(root, sourceMap);\n    if (!code.isEmpty()) {\n        cb.append(code);\n        // In order to avoid parse ambiguity when files are concatenated\n        // together, all files should end in a semi-colon. Do a quick\n        // heuristic check if there's an obvious semi-colon already there.\n        int length = code.length();\n        char lastChar = code.charAt(length - 1);\n        char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n        boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n        if (!hasSemiColon) {\n            cb.append(\";\");\n        }\n    }\n    return null;\n}", "code_comment": NaN, "code_no_comment": "public Void call() throws Exception {\n    if (options.printInputDelimiter) {\n        if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n                        cb.append(\"\\n\");\n        }\n        Preconditions.checkState(root.getType() == Token.SCRIPT);\n        String delimiter = options.inputDelimiter;\n        String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n        Preconditions.checkState(sourceName != null);\n        Preconditions.checkState(!sourceName.isEmpty());\n        delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n        cb.append(delimiter).append(\"\\n\");\n    }\n    if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n        cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n    }\n        if (options.sourceMapOutputPath != null) {\n        sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n    }\n            String code = toSource(root, sourceMap);\n    if (!code.isEmpty()) {\n        cb.append(code);\n                                int length = code.length();\n        char lastChar = code.charAt(length - 1);\n        char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n        boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n        if (!hasSemiColon) {\n            cb.append(\";\");\n        }\n    }\n    return null;\n}", "lc": 0.8181818181818182, "pi": -0.10047846889952174, "ma": 0.8, "nbd": 0.0, "ml": 1.0833333333333333, "d": 1.4365079365079365, "mi": -0.6484848484848482, "fo": 2.1666666666666665, "r": -0.02631578947368421, "e": 3.4607492954824433}
{"project_name": "maven", "project_version": "remotes/origin/bugs-dot-jar_MNG-4518_f5ebc72d", "label": 1, "code": "private static int getRelationOrder(String value, RangeValue rangeValue, boolean isLeft) {\n    if (rangeValue.value.length() <= 0) {\n        return isLeft ? 1 : -1;\n    }\n    value = value.replaceAll(\"[^0-9\\\\.\\\\-\\\\_]\", \"\");\n    List<String> valueTokens = new ArrayList<String>(Arrays.asList(value.split(\"[\\\\.\\\\-\\\\_]\")));\n    List<String> rangeValueTokens = new ArrayList<String>(Arrays.asList(rangeValue.value.split(\"\\\\.\")));\n    int max = Math.max(valueTokens.size(), rangeValueTokens.size());\n    addZeroTokens(valueTokens, max);\n    addZeroTokens(rangeValueTokens, max);\n    if (value.equals(rangeValue.getValue())) {\n        if (!rangeValue.isClosed()) {\n            return isLeft ? -1 : 1;\n        }\n        return 0;\n    }\n    for (int i = 0; i < valueTokens.size() && i < rangeValueTokens.size(); i++) {\n        int x = Integer.parseInt(valueTokens.get(i));\n        int y = Integer.parseInt(rangeValueTokens.get(i));\n        if (x < y) {\n            return -1;\n        } else if (x > y) {\n            return 1;\n        }\n    }\n    if (!rangeValue.isClosed()) {\n        return isLeft ? -1 : 1;\n    }\n    return 0;\n}", "code_comment": NaN, "code_no_comment": "private static int getRelationOrder(String value, RangeValue rangeValue, boolean isLeft) {\n    if (rangeValue.value.length() <= 0) {\n        return isLeft ? 1 : -1;\n    }\n    value = value.replaceAll(\"[^0-9\\\\.\\\\-\\\\_]\", \"\");\n    List<String> valueTokens = new ArrayList<String>(Arrays.asList(value.split(\"[\\\\.\\\\-\\\\_]\")));\n    List<String> rangeValueTokens = new ArrayList<String>(Arrays.asList(rangeValue.value.split(\"\\\\.\")));\n    int max = Math.max(valueTokens.size(), rangeValueTokens.size());\n    addZeroTokens(valueTokens, max);\n    addZeroTokens(rangeValueTokens, max);\n    if (value.equals(rangeValue.getValue())) {\n        if (!rangeValue.isClosed()) {\n            return isLeft ? -1 : 1;\n        }\n        return 0;\n    }\n    for (int i = 0; i < valueTokens.size() && i < rangeValueTokens.size(); i++) {\n        int x = Integer.parseInt(valueTokens.get(i));\n        int y = Integer.parseInt(rangeValueTokens.get(i));\n        if (x < y) {\n            return -1;\n        } else if (x > y) {\n            return 1;\n        }\n    }\n    if (!rangeValue.isClosed()) {\n        return isLeft ? -1 : 1;\n    }\n    return 0;\n}", "lc": 0.7272727272727273, "pi": 0.02870813397129168, "ma": 1.4, "nbd": 0.5, "ml": 1.3333333333333333, "d": 1.8115079365079367, "mi": -0.5915433403805496, "fo": 1.25, "r": -0.02631578947368421, "e": 3.0210750159921163}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-2567_948b6e05", "label": 3, "code": "protected int skipFields(byte[] bytes, int startPos, int limit, byte[] delim) {\n    int i = startPos;\n    final int delimLimit = limit - delim.length + 1;\n    if (quotedStringParsing == true && bytes[i] == quoteCharacter) {\n        // quoted string parsing enabled and field is quoted\n        // search for ending quote character\n        i++;\n        while (i < limit && bytes[i] != quoteCharacter) {\n            i++;\n        }\n        i++;\n        if (i == limit) {\n            // we are at the end of the record\n            return limit;\n        } else if (i < delimLimit && FieldParser.delimiterNext(bytes, i, delim)) {\n            // we are not at the end, check if delimiter comes next\n            return i + delim.length;\n        } else {\n            // delimiter did not follow end quote. Error...\n            return -1;\n        }\n    } else {\n        // field is not quoted\n        while (i < delimLimit && !FieldParser.delimiterNext(bytes, i, delim)) {\n            i++;\n        }\n        if (i >= delimLimit) {\n            // no delimiter found. We are at the end of the record\n            return limit;\n        } else {\n            // delimiter found.\n            return i + delim.length;\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "protected int skipFields(byte[] bytes, int startPos, int limit, byte[] delim) {\n    int i = startPos;\n    final int delimLimit = limit - delim.length + 1;\n    if (quotedStringParsing == true && bytes[i] == quoteCharacter) {\n                        i++;\n        while (i < limit && bytes[i] != quoteCharacter) {\n            i++;\n        }\n        i++;\n        if (i == limit) {\n                        return limit;\n        } else if (i < delimLimit && FieldParser.delimiterNext(bytes, i, delim)) {\n                        return i + delim.length;\n        } else {\n                        return -1;\n        }\n    } else {\n                while (i < delimLimit && !FieldParser.delimiterNext(bytes, i, delim)) {\n            i++;\n        }\n        if (i >= delimLimit) {\n                        return limit;\n        } else {\n                        return i + delim.length;\n        }\n    }\n}", "lc": 0.5909090909090909, "pi": 0.21052631578947367, "ma": 0.6, "nbd": 0.5, "ml": 1.0833333333333333, "d": 3.2063492063492065, "mi": -0.4365045806906271, "fo": -0.3333333333333333, "r": 0.0, "e": 2.843134339540003}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-413_51aa6e6c", "label": 1, "code": "/**\n * {@inheritDoc}\n */\npublic UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal, final double min, final double max) throws FunctionEvaluationException {\n    optima = new UnivariateRealPointValuePair[starts];\n    totalEvaluations = 0;\n    // Multi-start loop.\n    for (int i = 0; i < starts; ++i) {\n        try {\n            final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);\n            final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min);\n            optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2));\n        } catch (FunctionEvaluationException fee) {\n            optima[i] = null;\n        } catch (ConvergenceException ce) {\n            optima[i] = null;\n        }\n        final int usedEvaluations = optimizer.getEvaluations();\n        optimizer.setMaxEvaluations(optimizer.getMaxEvaluations() - usedEvaluations);\n        totalEvaluations += usedEvaluations;\n    }\n    sortPairs(goal);\n    if (optima[0] == null) {\n        throw new ConvergenceException(LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT, starts);\n    }\n    // Return the point with the best objective function value.\n    return optima[0];\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal, final double min, final double max) throws FunctionEvaluationException {\n    optima = new UnivariateRealPointValuePair[starts];\n    totalEvaluations = 0;\n        for (int i = 0; i < starts; ++i) {\n        try {\n            final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);\n            final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min);\n            optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2));\n        } catch (FunctionEvaluationException fee) {\n            optima[i] = null;\n        } catch (ConvergenceException ce) {\n            optima[i] = null;\n        }\n        final int usedEvaluations = optimizer.getEvaluations();\n        optimizer.setMaxEvaluations(optimizer.getMaxEvaluations() - usedEvaluations);\n        totalEvaluations += usedEvaluations;\n    }\n    sortPairs(goal);\n    if (optima[0] == null) {\n        throw new ConvergenceException(LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT, starts);\n    }\n        return optima[0];\n}", "lc": 0.4090909090909091, "pi": 0.30143540669856456, "ma": 0.8, "nbd": 0.0, "ml": 0.08333333333333333, "d": 1.6944444444444446, "mi": -0.43340380549682866, "fo": 0.25, "r": 0.0, "e": 2.5100879998616894}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-288_38983e82", "label": 1, "code": "/**\n * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).\n * @param tableau simple tableau for the problem\n * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}\n * @return row with the minimum ratio\n */\nprivate Integer getPivotRow(final int col, final SimplexTableau tableau) {\n    double minRatio = Double.MAX_VALUE;\n    Integer minRatioPos = null;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n        if (MathUtils.compareTo(tableau.getEntry(i, col), 0, epsilon) >= 0) {\n            double ratio = rhs / tableau.getEntry(i, col);\n            if (ratio < minRatio) {\n                minRatio = ratio;\n                minRatioPos = i;\n            }\n        }\n    }\n    return minRatioPos;\n}", "code_comment": "/**\n * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).\n * @param tableau simple tableau for the problem\n * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}\n * @return row with the minimum ratio\n */\n", "code_no_comment": "private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n    double minRatio = Double.MAX_VALUE;\n    Integer minRatioPos = null;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n        if (MathUtils.compareTo(tableau.getEntry(i, col), 0, epsilon) >= 0) {\n            double ratio = rhs / tableau.getEntry(i, col);\n            if (ratio < minRatio) {\n                minRatio = ratio;\n                minRatioPos = i;\n            }\n        }\n    }\n    return minRatioPos;\n}", "lc": 0.045454545454545456, "pi": 0.9760765550239235, "ma": 0.0, "nbd": 0.5, "ml": 0.5, "d": 0.876984126984127, "mi": -0.11937984496124027, "fo": 0.08333333333333333, "r": 0.0, "e": 0.6925767765656424}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3433_b76b31f7", "label": 0, "code": "/**\n * Persist the pending changes to _lastRev to the given store. This method\n * will persist a snapshot of the pending revisions by acquiring the passed\n * lock for a short period of time.\n *\n * @param store the document node store.\n * @param snapshot callback when the snapshot of the pending changes is\n *                 acquired.\n * @param lock the lock to acquire to get a consistent snapshot of the\n *             revisions to write back.\n * @return stats about the write operation.\n */\npublic BackgroundWriteStats persist(@Nonnull DocumentNodeStore store, @Nonnull Snapshot snapshot, @Nonnull Lock lock) {\n    BackgroundWriteStats stats = new BackgroundWriteStats();\n    if (map.size() == 0) {\n        return stats;\n    }\n    checkNotNull(store);\n    checkNotNull(lock);\n    Clock clock = store.getClock();\n    long time = clock.getTime();\n    // get a copy of the map while holding the lock\n    lock.lock();\n    stats.lock = clock.getTime() - time;\n    time = clock.getTime();\n    Map<String, Revision> pending;\n    try {\n        snapshot.acquiring();\n        pending = Maps.newTreeMap(PathComparator.INSTANCE);\n        pending.putAll(map);\n    } finally {\n        lock.unlock();\n    }\n    stats.num = pending.size();\n    UpdateOp updateOp = null;\n    Revision lastRev = null;\n    PeekingIterator<String> paths = Iterators.peekingIterator(pending.keySet().iterator());\n    int i = 0;\n    ArrayList<String> pathList = new ArrayList<String>();\n    while (paths.hasNext()) {\n        String p = paths.peek();\n        Revision r = pending.get(p);\n        int size = pathList.size();\n        if (updateOp == null) {\n            // create UpdateOp\n            Commit commit = new Commit(store, r, null, null);\n            updateOp = commit.getUpdateOperationForNode(p);\n            NodeDocument.setLastRev(updateOp, r);\n            lastRev = r;\n            pathList.add(p);\n            paths.next();\n            i++;\n        } else if (r.equals(lastRev)) {\n            // use multi update when possible\n            pathList.add(p);\n            paths.next();\n            i++;\n        }\n        // - the update limit is reached\n        if (i + 2 > pending.size() || size == pathList.size() || pathList.size() >= BACKGROUND_MULTI_UPDATE_LIMIT) {\n            List<String> ids = new ArrayList<String>();\n            for (String path : pathList) {\n                ids.add(Utils.getIdFromPath(path));\n            }\n            store.getDocumentStore().update(NODES, ids, updateOp);\n            LOG.debug(\"Updated _lastRev to {} on {}\", lastRev, ids);\n            for (String path : pathList) {\n                map.remove(path, lastRev);\n            }\n            pathList.clear();\n            updateOp = null;\n            lastRev = null;\n        }\n    }\n    Revision writtenRootRev = pending.get(\"/\");\n    if (writtenRootRev != null) {\n        int cid = writtenRootRev.getClusterId();\n        if (store.getDocumentStore().find(org.apache.jackrabbit.oak.plugins.document.Collection.CLUSTER_NODES, String.valueOf(cid)) != null) {\n            UpdateOp update = new UpdateOp(String.valueOf(cid), false);\n            update.equals(Document.ID, null, String.valueOf(cid));\n            update.set(ClusterNodeInfo.LAST_WRITTEN_ROOT_REV_KEY, writtenRootRev.toString());\n            store.getDocumentStore().findAndUpdate(org.apache.jackrabbit.oak.plugins.document.Collection.CLUSTER_NODES, update);\n        }\n    }\n    stats.write = clock.getTime() - time;\n    return stats;\n}", "code_comment": "/**\n * Persist the pending changes to _lastRev to the given store. This method\n * will persist a snapshot of the pending revisions by acquiring the passed\n * lock for a short period of time.\n *\n * @param store the document node store.\n * @param snapshot callback when the snapshot of the pending changes is\n *                 acquired.\n * @param lock the lock to acquire to get a consistent snapshot of the\n *             revisions to write back.\n * @return stats about the write operation.\n */\n", "code_no_comment": "public BackgroundWriteStats persist(@Nonnull DocumentNodeStore store, @Nonnull Snapshot snapshot, @Nonnull Lock lock) {\n    BackgroundWriteStats stats = new BackgroundWriteStats();\n    if (map.size() == 0) {\n        return stats;\n    }\n    checkNotNull(store);\n    checkNotNull(lock);\n    Clock clock = store.getClock();\n    long time = clock.getTime();\n        lock.lock();\n    stats.lock = clock.getTime() - time;\n    time = clock.getTime();\n    Map<String, Revision> pending;\n    try {\n        snapshot.acquiring();\n        pending = Maps.newTreeMap(PathComparator.INSTANCE);\n        pending.putAll(map);\n    } finally {\n        lock.unlock();\n    }\n    stats.num = pending.size();\n    UpdateOp updateOp = null;\n    Revision lastRev = null;\n    PeekingIterator<String> paths = Iterators.peekingIterator(pending.keySet().iterator());\n    int i = 0;\n    ArrayList<String> pathList = new ArrayList<String>();\n    while (paths.hasNext()) {\n        String p = paths.peek();\n        Revision r = pending.get(p);\n        int size = pathList.size();\n        if (updateOp == null) {\n                        Commit commit = new Commit(store, r, null, null);\n            updateOp = commit.getUpdateOperationForNode(p);\n            NodeDocument.setLastRev(updateOp, r);\n            lastRev = r;\n            pathList.add(p);\n            paths.next();\n            i++;\n        } else if (r.equals(lastRev)) {\n                        pathList.add(p);\n            paths.next();\n            i++;\n        }\n                if (i + 2 > pending.size() || size == pathList.size() || pathList.size() >= BACKGROUND_MULTI_UPDATE_LIMIT) {\n            List<String> ids = new ArrayList<String>();\n            for (String path : pathList) {\n                ids.add(Utils.getIdFromPath(path));\n            }\n            store.getDocumentStore().update(NODES, ids, updateOp);\n            LOG.debug(\"Updated _lastRev to {} on {}\", lastRev, ids);\n            for (String path : pathList) {\n                map.remove(path, lastRev);\n            }\n            pathList.clear();\n            updateOp = null;\n            lastRev = null;\n        }\n    }\n    Revision writtenRootRev = pending.get(\"/\");\n    if (writtenRootRev != null) {\n        int cid = writtenRootRev.getClusterId();\n        if (store.getDocumentStore().find(org.apache.jackrabbit.oak.plugins.document.Collection.CLUSTER_NODES, String.valueOf(cid)) != null) {\n            UpdateOp update = new UpdateOp(String.valueOf(cid), false);\n            update.equals(Document.ID, null, String.valueOf(cid));\n            update.set(ClusterNodeInfo.LAST_WRITTEN_ROOT_REV_KEY, writtenRootRev.toString());\n            store.getDocumentStore().findAndUpdate(org.apache.jackrabbit.oak.plugins.document.Collection.CLUSTER_NODES, update);\n        }\n    }\n    stats.write = clock.getTime() - time;\n    return stats;\n}", "lc": 2.590909090909091, "pi": 0.42583732057416257, "ma": 1.2, "nbd": 0.5, "ml": 1.4166666666666667, "d": 1.619047619047619, "mi": -1.1384073291050032, "fo": 3.6666666666666665, "r": -0.02631578947368421, "e": 8.473636347919296}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1848_093b9128", "label": 1, "code": "/**\n * Syncs the properties specified in the {@code mapping} from the external identity to the given authorizable.\n * Note that this method does not check for value equality and just blindly copies or deletes the properties.\n *\n * @param ext external identity\n * @param auth the authorizable\n * @param mapping the property mapping\n * @throws RepositoryException if an error occurs\n */\nprivate void syncProperties(ExternalIdentity ext, Authorizable auth, Map<String, String> mapping) throws RepositoryException {\n    Map<String, ?> properties = ext.getProperties();\n    for (Map.Entry<String, String> entry : mapping.entrySet()) {\n        String relPath = entry.getKey();\n        String name = entry.getValue();\n        Object obj = properties.get(name);\n        if (obj == null) {\n            auth.removeProperty(relPath);\n        } else {\n            if (obj instanceof Collection) {\n                auth.setProperty(relPath, createValues((Collection) obj));\n            } else if (obj instanceof byte[] || obj instanceof char[]) {\n                auth.setProperty(relPath, createValue(obj));\n            } else if (obj instanceof Object[]) {\n                auth.setProperty(relPath, createValues(Arrays.asList((Object[]) obj)));\n            } else {\n                auth.setProperty(relPath, createValue(obj));\n            }\n        }\n    }\n}", "code_comment": "/**\n * Syncs the properties specified in the {@code mapping} from the external identity to the given authorizable.\n * Note that this method does not check for value equality and just blindly copies or deletes the properties.\n *\n * @param ext external identity\n * @param auth the authorizable\n * @param mapping the property mapping\n * @throws RepositoryException if an error occurs\n */\n", "code_no_comment": "private void syncProperties(ExternalIdentity ext, Authorizable auth, Map<String, String> mapping) throws RepositoryException {\n    Map<String, ?> properties = ext.getProperties();\n    for (Map.Entry<String, String> entry : mapping.entrySet()) {\n        String relPath = entry.getKey();\n        String name = entry.getValue();\n        Object obj = properties.get(name);\n        if (obj == null) {\n            auth.removeProperty(relPath);\n        } else {\n            if (obj instanceof Collection) {\n                auth.setProperty(relPath, createValues((Collection) obj));\n            } else if (obj instanceof byte[] || obj instanceof char[]) {\n                auth.setProperty(relPath, createValue(obj));\n            } else if (obj instanceof Object[]) {\n                auth.setProperty(relPath, createValues(Arrays.asList((Object[]) obj)));\n            } else {\n                auth.setProperty(relPath, createValue(obj));\n            }\n        }\n    }\n}", "lc": 0.3181818181818182, "pi": 0.8803827751196173, "ma": 0.4, "nbd": 1.5, "ml": 0.08333333333333333, "d": 0.10515873015873016, "mi": -0.3254404510218463, "fo": 0.75, "r": -0.02631578947368421, "e": 0.26101669519314435}
{"project_name": "Math", "project_version": 103, "label": 3, "code": "/**\n * For this disbution, X, this method returns P(X &lt; <code>x</code>).\n * @param x the value at which the CDF is evaluated.\n * @return CDF evaluted at <code>x</code>.\n * @throws MathException if the algorithm fails to converge; unless\n * x is more than 20 standard deviations from the mean, in which case the\n * convergence exception is caught and 0 or 1 is returned.\n */\npublic double cumulativeProbability(double x) throws MathException {\n    return 0.5 * (1.0 + Erf.erf((x - mean) / (standardDeviation * Math.sqrt(2.0))));\n}", "code_comment": "/**\n * For this disbution, X, this method returns P(X &lt; <code>x</code>).\n * @param x the value at which the CDF is evaluated.\n * @return CDF evaluted at <code>x</code>.\n * @throws MathException if the algorithm fails to converge; unless\n * x is more than 20 standard deviations from the mean, in which case the\n * convergence exception is caught and 0 or 1 is returned.\n */\n", "code_no_comment": "public double cumulativeProbability(double x) throws MathException {\n    return 0.5 * (1.0 + Erf.erf((x - mean) / (standardDeviation * Math.sqrt(2.0))));\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": 0.06150793650793648, "mi": 0.8314305849189569, "fo": -0.3333333333333333, "r": 0.5526315789473684, "e": -0.08567625041060838}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-781_3c4cb189", "label": 1, "code": "/**\n * Removes the phase 1 objective function, positive cost non-artificial variables,\n * and the non-basic artificial variables from this tableau.\n */\nprotected void dropPhase1Objective() {\n    if (getNumObjectiveFunctions() == 1) {\n        return;\n    }\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\n    columnsToDrop.add(0);\n    // positive cost non-artificial variables\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(0, i);\n        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n            columnsToDrop.add(i);\n        }\n    }\n    // non-basic artificial variables\n    for (int i = 0; i < getNumArtificialVariables(); i++) {\n        int col = i + getArtificialVariableOffset();\n        if (getBasicRow(col) == null) {\n            columnsToDrop.add(col);\n        }\n    }\n    double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];\n    for (int i = 1; i < getHeight(); i++) {\n        int col = 0;\n        for (int j = 0; j < getWidth(); j++) {\n            if (!columnsToDrop.contains(j)) {\n                matrix[i - 1][col++] = tableau.getEntry(i, j);\n            }\n        }\n    }\n    for (int i = columnsToDrop.size() - 1; i >= 0; i--) {\n        columnLabels.remove((int) columnsToDrop.get(i));\n    }\n    this.tableau = new Array2DRowRealMatrix(matrix);\n    this.numArtificialVariables = 0;\n}", "code_comment": "/**\n * Removes the phase 1 objective function, positive cost non-artificial variables,\n * and the non-basic artificial variables from this tableau.\n */\n", "code_no_comment": "protected void dropPhase1Objective() {\n    if (getNumObjectiveFunctions() == 1) {\n        return;\n    }\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\n    columnsToDrop.add(0);\n        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(0, i);\n        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n            columnsToDrop.add(i);\n        }\n    }\n        for (int i = 0; i < getNumArtificialVariables(); i++) {\n        int col = i + getArtificialVariableOffset();\n        if (getBasicRow(col) == null) {\n            columnsToDrop.add(col);\n        }\n    }\n    double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];\n    for (int i = 1; i < getHeight(); i++) {\n        int col = 0;\n        for (int j = 0; j < getWidth(); j++) {\n            if (!columnsToDrop.contains(j)) {\n                matrix[i - 1][col++] = tableau.getEntry(i, j);\n            }\n        }\n    }\n    for (int i = columnsToDrop.size() - 1; i >= 0; i--) {\n        columnLabels.remove((int) columnsToDrop.get(i));\n    }\n    this.tableau = new Array2DRowRealMatrix(matrix);\n    this.numArtificialVariables = 0;\n}", "lc": 0.8636363636363636, "pi": 0.26315789473684204, "ma": 1.2, "nbd": 0.5, "ml": 1.4166666666666667, "d": 2.28968253968254, "mi": -0.6394644115574347, "fo": 1.25, "r": -0.02631578947368421, "e": 4.0139209211459}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1348_6ff92b12", "label": 1, "code": "public int start() throws IOException {\n    if (configError)\n        return 1;\n    String input;\n    if (isVerbose())\n        printInfo();\n    String home = System.getProperty(\"HOME\");\n    if (home == null)\n        home = System.getenv(\"HOME\");\n    String configDir = home + \"/\" + HISTORY_DIR_NAME;\n    String historyPath = configDir + \"/\" + HISTORY_FILE_NAME;\n    File accumuloDir = new File(configDir);\n    if (!accumuloDir.exists() && !accumuloDir.mkdirs())\n        log.warn(\"Unable to make directory for history at \" + accumuloDir);\n    try {\n        History history = new History();\n        history.setHistoryFile(new File(historyPath));\n        reader.setHistory(history);\n    } catch (IOException e) {\n        log.warn(\"Unable to load history file at \" + historyPath);\n    }\n    ShellCompletor userCompletor = null;\n    if (execFile != null) {\n        java.util.Scanner scanner = new java.util.Scanner(new File(execFile));\n        try {\n            while (scanner.hasNextLine()) execCommand(scanner.nextLine(), true, isVerbose());\n        } finally {\n            scanner.close();\n        }\n    } else if (execCommand != null) {\n        for (String command : execCommand.split(\"\\n\")) {\n            execCommand(command, true, isVerbose());\n        }\n        return exitCode;\n    }\n    while (true) {\n        if (hasExited())\n            return exitCode;\n        // If tab completion is true we need to reset\n        if (tabCompletion) {\n            if (userCompletor != null)\n                reader.removeCompletor(userCompletor);\n            userCompletor = setupCompletion();\n            reader.addCompletor(userCompletor);\n        }\n        reader.setDefaultPrompt(getDefaultPrompt());\n        input = reader.readLine();\n        if (input == null) {\n            reader.printNewline();\n            return exitCode;\n        }\n        // user canceled\n        execCommand(input, disableAuthTimeout, false);\n    }\n}", "code_comment": NaN, "code_no_comment": "public int start() throws IOException {\n    if (configError)\n        return 1;\n    String input;\n    if (isVerbose())\n        printInfo();\n    String home = System.getProperty(\"HOME\");\n    if (home == null)\n        home = System.getenv(\"HOME\");\n    String configDir = home + \"/\" + HISTORY_DIR_NAME;\n    String historyPath = configDir + \"/\" + HISTORY_FILE_NAME;\n    File accumuloDir = new File(configDir);\n    if (!accumuloDir.exists() && !accumuloDir.mkdirs())\n        log.warn(\"Unable to make directory for history at \" + accumuloDir);\n    try {\n        History history = new History();\n        history.setHistoryFile(new File(historyPath));\n        reader.setHistory(history);\n    } catch (IOException e) {\n        log.warn(\"Unable to load history file at \" + historyPath);\n    }\n    ShellCompletor userCompletor = null;\n    if (execFile != null) {\n        java.util.Scanner scanner = new java.util.Scanner(new File(execFile));\n        try {\n            while (scanner.hasNextLine()) execCommand(scanner.nextLine(), true, isVerbose());\n        } finally {\n            scanner.close();\n        }\n    } else if (execCommand != null) {\n        for (String command : execCommand.split(\"\\n\")) {\n            execCommand(command, true, isVerbose());\n        }\n        return exitCode;\n    }\n    while (true) {\n        if (hasExited())\n            return exitCode;\n                if (tabCompletion) {\n            if (userCompletor != null)\n                reader.removeCompletor(userCompletor);\n            userCompletor = setupCompletion();\n            reader.addCompletor(userCompletor);\n        }\n        reader.setDefaultPrompt(getDefaultPrompt());\n        input = reader.readLine();\n        if (input == null) {\n            reader.printNewline();\n            return exitCode;\n        }\n                execCommand(input, disableAuthTimeout, false);\n    }\n}", "lc": 1.7727272727272727, "pi": 0.1626794258373205, "ma": 2.2, "nbd": 0.5, "ml": 1.6666666666666667, "d": 0.8253968253968255, "mi": -0.9255813953488368, "fo": 1.75, "r": -0.02631578947368421, "e": 2.2535318084634315}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-9032_108d94f7", "label": 1, "code": "/**\n * Choose one of the available methods to invoke if we can match\n * the message body to the body parameter\n *\n * @param pojo the bean to invoke a method on\n * @param exchange the message exchange\n * @param name an optional name of the method that must match, use <tt>null</tt> to indicate all methods\n * @return the method to invoke or null if no definitive method could be matched\n * @throws AmbiguousMethodCallException is thrown if cannot choose method due to ambiguity\n */\nprotected MethodInfo chooseMethod(Object pojo, Exchange exchange, String name) throws AmbiguousMethodCallException {\n    // @Handler should be select first\n    // then any single method that has a custom @annotation\n    // or any single method that has a match parameter type that matches the Exchange payload\n    // and last then try to select the best among the rest\n    // must use defensive copy, to avoid altering the shared lists\n    // and we want to remove unwanted operations from these local lists\n    final List<MethodInfo> localOperationsWithBody = new ArrayList<MethodInfo>(operationsWithBody);\n    final List<MethodInfo> localOperationsWithNoBody = new ArrayList<MethodInfo>(operationsWithNoBody);\n    final List<MethodInfo> localOperationsWithCustomAnnotation = new ArrayList<MethodInfo>(operationsWithCustomAnnotation);\n    final List<MethodInfo> localOperationsWithHandlerAnnotation = new ArrayList<MethodInfo>(operationsWithHandlerAnnotation);\n    if (name != null) {\n        // filter all lists to only include methods with this name\n        removeNonMatchingMethods(localOperationsWithHandlerAnnotation, name);\n        removeNonMatchingMethods(localOperationsWithCustomAnnotation, name);\n        removeNonMatchingMethods(localOperationsWithBody, name);\n        removeNonMatchingMethods(localOperationsWithNoBody, name);\n    } else {\n        // remove all getter/setter as we do not want to consider these methods\n        removeAllSetterOrGetterMethods(localOperationsWithHandlerAnnotation);\n        removeAllSetterOrGetterMethods(localOperationsWithCustomAnnotation);\n        removeAllSetterOrGetterMethods(localOperationsWithBody);\n        removeAllSetterOrGetterMethods(localOperationsWithNoBody);\n    }\n    if (localOperationsWithHandlerAnnotation.size() > 1) {\n        // if we have more than 1 @Handler then its ambiguous\n        throw new AmbiguousMethodCallException(exchange, localOperationsWithHandlerAnnotation);\n    }\n    if (localOperationsWithHandlerAnnotation.size() == 1) {\n        // methods with handler should be preferred\n        return localOperationsWithHandlerAnnotation.get(0);\n    } else if (localOperationsWithCustomAnnotation.size() == 1) {\n        // if there is one method with an annotation then use that one\n        return localOperationsWithCustomAnnotation.get(0);\n    }\n    // named method and with no parameters\n    boolean noParameters = name != null && name.endsWith(\"()\");\n    if (noParameters && localOperationsWithNoBody.size() == 1) {\n        // if there was a method name configured and it has no parameters, then use the method with no body (eg no parameters)\n        return localOperationsWithNoBody.get(0);\n    } else if (!noParameters && localOperationsWithBody.size() == 1 && localOperationsWithCustomAnnotation.isEmpty()) {\n        // if there is one method with body then use that one\n        return localOperationsWithBody.get(0);\n    }\n    Collection<MethodInfo> possibleOperations = new ArrayList<MethodInfo>();\n    possibleOperations.addAll(localOperationsWithBody);\n    possibleOperations.addAll(localOperationsWithCustomAnnotation);\n    if (!possibleOperations.isEmpty()) {\n        // multiple possible operations so find the best suited if possible\n        MethodInfo answer = chooseMethodWithMatchingBody(exchange, possibleOperations, localOperationsWithCustomAnnotation);\n        if (answer == null && name != null) {\n            // do we have hardcoded parameters values provided from the method name then fallback and try that\n            String parameters = ObjectHelper.between(name, \"(\", \")\");\n            if (parameters != null) {\n                // special as we have hardcoded parameters, so we need to choose method that matches those parameters the best\n                answer = chooseMethodWithMatchingParameters(exchange, parameters, possibleOperations);\n            }\n        }\n        if (answer == null && possibleOperations.size() > 1) {\n            answer = getSingleCovariantMethod(possibleOperations);\n        }\n        if (answer == null) {\n            throw new AmbiguousMethodCallException(exchange, possibleOperations);\n        } else {\n            return answer;\n        }\n    }\n    // not possible to determine\n    return null;\n}", "code_comment": "/**\n * Choose one of the available methods to invoke if we can match\n * the message body to the body parameter\n *\n * @param pojo the bean to invoke a method on\n * @param exchange the message exchange\n * @param name an optional name of the method that must match, use <tt>null</tt> to indicate all methods\n * @return the method to invoke or null if no definitive method could be matched\n * @throws AmbiguousMethodCallException is thrown if cannot choose method due to ambiguity\n */\n", "code_no_comment": "protected MethodInfo chooseMethod(Object pojo, Exchange exchange, String name) throws AmbiguousMethodCallException {\n                            final List<MethodInfo> localOperationsWithBody = new ArrayList<MethodInfo>(operationsWithBody);\n    final List<MethodInfo> localOperationsWithNoBody = new ArrayList<MethodInfo>(operationsWithNoBody);\n    final List<MethodInfo> localOperationsWithCustomAnnotation = new ArrayList<MethodInfo>(operationsWithCustomAnnotation);\n    final List<MethodInfo> localOperationsWithHandlerAnnotation = new ArrayList<MethodInfo>(operationsWithHandlerAnnotation);\n    if (name != null) {\n                removeNonMatchingMethods(localOperationsWithHandlerAnnotation, name);\n        removeNonMatchingMethods(localOperationsWithCustomAnnotation, name);\n        removeNonMatchingMethods(localOperationsWithBody, name);\n        removeNonMatchingMethods(localOperationsWithNoBody, name);\n    } else {\n                removeAllSetterOrGetterMethods(localOperationsWithHandlerAnnotation);\n        removeAllSetterOrGetterMethods(localOperationsWithCustomAnnotation);\n        removeAllSetterOrGetterMethods(localOperationsWithBody);\n        removeAllSetterOrGetterMethods(localOperationsWithNoBody);\n    }\n    if (localOperationsWithHandlerAnnotation.size() > 1) {\n                throw new AmbiguousMethodCallException(exchange, localOperationsWithHandlerAnnotation);\n    }\n    if (localOperationsWithHandlerAnnotation.size() == 1) {\n                return localOperationsWithHandlerAnnotation.get(0);\n    } else if (localOperationsWithCustomAnnotation.size() == 1) {\n                return localOperationsWithCustomAnnotation.get(0);\n    }\n        boolean noParameters = name != null && name.endsWith(\"()\");\n    if (noParameters && localOperationsWithNoBody.size() == 1) {\n                return localOperationsWithNoBody.get(0);\n    } else if (!noParameters && localOperationsWithBody.size() == 1 && localOperationsWithCustomAnnotation.isEmpty()) {\n                return localOperationsWithBody.get(0);\n    }\n    Collection<MethodInfo> possibleOperations = new ArrayList<MethodInfo>();\n    possibleOperations.addAll(localOperationsWithBody);\n    possibleOperations.addAll(localOperationsWithCustomAnnotation);\n    if (!possibleOperations.isEmpty()) {\n                MethodInfo answer = chooseMethodWithMatchingBody(exchange, possibleOperations, localOperationsWithCustomAnnotation);\n        if (answer == null && name != null) {\n                        String parameters = ObjectHelper.between(name, \"(\", \")\");\n            if (parameters != null) {\n                                answer = chooseMethodWithMatchingParameters(exchange, parameters, possibleOperations);\n            }\n        }\n        if (answer == null && possibleOperations.size() > 1) {\n            answer = getSingleCovariantMethod(possibleOperations);\n        }\n        if (answer == null) {\n            throw new AmbiguousMethodCallException(exchange, possibleOperations);\n        } else {\n            return answer;\n        }\n    }\n        return null;\n}", "lc": 1.7272727272727273, "pi": 0.11004784688995216, "ma": 2.0, "nbd": 0.5, "ml": 1.8333333333333333, "d": 1.6845238095238095, "mi": -0.930937279774489, "fo": 1.75, "r": -0.02631578947368421, "e": 4.6216098154135175}
{"project_name": "JxPath", "project_version": 19, "label": 1, "code": "/**\n * Get relative position of this among like-named siblings.\n * @return 1..n\n */\nprivate int getRelativePositionByQName() {\n    if (node instanceof Element) {\n        Object parent = ((Element) node).getParent();\n        if (!(parent instanceof Element)) {\n            return 1;\n        }\n        List children = ((Element) parent).getContent();\n        int count = 0;\n        String name = ((Element) node).getQualifiedName();\n        for (int i = 0; i < children.size(); i++) {\n            Object child = children.get(i);\n            if ((child instanceof Element) && ((Element) child).getQualifiedName().equals(name)) {\n                count++;\n            }\n            if (child == node) {\n                break;\n            }\n        }\n        return count;\n    }\n    return 1;\n}", "code_comment": "/**\n * Get relative position of this among like-named siblings.\n * @return 1..n\n */\n", "code_no_comment": "private int getRelativePositionByQName() {\n    if (node instanceof Element) {\n        Object parent = ((Element) node).getParent();\n        if (!(parent instanceof Element)) {\n            return 1;\n        }\n        List children = ((Element) parent).getContent();\n        int count = 0;\n        String name = ((Element) node).getQualifiedName();\n        for (int i = 0; i < children.size(); i++) {\n            Object child = children.get(i);\n            if ((child instanceof Element) && ((Element) child).getQualifiedName().equals(name)) {\n                count++;\n            }\n            if (child == node) {\n                break;\n            }\n        }\n        return count;\n    }\n    return 1;\n}", "lc": 0.36363636363636365, "pi": 0.5933014354066987, "ma": 0.6, "nbd": 0.5, "ml": 0.6666666666666666, "d": 0.9662698412698413, "mi": -0.30570824524312884, "fo": 0.08333333333333333, "r": 0.07894736842105263, "e": 0.7056148176322445}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-2621_c849f986", "label": 1, "code": "@Override\npublic void onFormComponent(FormComponent<?> formComponent) {\n    if (formComponent.isVisible() && formComponent.isMultiPart()) {\n        setMultiPart(true);\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void onFormComponent(FormComponent<?> formComponent) {\n    if (formComponent.isVisible() && formComponent.isMultiPart()) {\n        setMultiPart(true);\n    }\n}", "lc": -0.36363636363636365, "pi": -0.004784688995215422, "ma": -0.4, "nbd": -0.5, "ml": -0.08333333333333333, "d": -0.3650793650793651, "mi": 0.6062015503875966, "fo": -0.25, "r": 0.0, "e": -0.16279340490885932}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-8106_39ccf5d6", "label": 1, "code": "@Override\npublic Object next() {\n    Object o = nextToken;\n    try {\n        nextToken = getNextToken();\n    } catch (XMLStreamException e) {\n    // \n    }\n    return o;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic Object next() {\n    Object o = nextToken;\n    try {\n        nextToken = getNextToken();\n    } catch (XMLStreamException e) {\n        }\n    return o;\n}", "lc": -0.22727272727272727, "pi": -0.22966507177033516, "ma": -0.4, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.39844961240310084, "fo": -0.4166666666666667, "r": 2.4473684210526314, "e": -0.16279340490885932}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-442_246d53c5", "label": 1, "code": "/**\n *  Registers an error feedback message for this component\n *\n *  @param message\n *             The feedback message\n */\npublic final void error(final Serializable message) {\n    getPage().getFeedbackMessages().error(this, message);\n}", "code_comment": "/**\n *  Registers an error feedback message for this component\n *\n *  @param message\n *             The feedback message\n */\n", "code_no_comment": "public final void error(final Serializable message) {\n    getPage().getFeedbackMessages().error(this, message);\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.0253699788583508, "fo": -0.25, "r": 2.526315789473684, "e": -0.16279340490885932}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-757_76b7413d", "label": 1, "code": "/**\n * Sets the {@link ExpansionMode expansion mode}.\n *\n * @param expansionMode Expansion mode to use for resizing the array.\n * @deprecated As of 3.1 (to be removed in 4.0 as field will become \"final\").\n */\n@Deprecated\npublic void setExpansionMode(ExpansionMode expansionMode) {\n    this.expansionMode = expansionMode;\n}", "code_comment": "/**\n * Sets the {@link ExpansionMode expansion mode}.\n *\n * @param expansionMode Expansion mode to use for resizing the array.\n * @deprecated As of 3.1 (to be removed in 4.0 as field will become \"final\").\n */\n", "code_no_comment": "@Deprecated\npublic void setExpansionMode(ExpansionMode expansionMode) {\n    this.expansionMode = expansionMode;\n}", "lc": -0.45454545454545453, "pi": -0.6028708133971293, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.8940098661028892, "fo": -0.5, "r": 2.3421052631578947, "e": -0.16279340490885932}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1190_e29dc4f5", "label": 3, "code": "private void addCellsToWriter(Map<ByteBuffer, List<ColumnUpdate>> cells, BatchWriter writer) throws MutationsRejectedException {\n    HashMap<Text, ColumnVisibility> vizMap = new HashMap<Text, ColumnVisibility>();\n    for (Entry<ByteBuffer, List<ColumnUpdate>> entry : cells.entrySet()) {\n        Mutation m = new Mutation(ByteBufferUtil.toBytes(entry.getKey()));\n        for (ColumnUpdate update : entry.getValue()) {\n            ColumnVisibility viz = EMPTY_VIS;\n            if (update.isSetColVisibility()) {\n                Text vizText = new Text(update.getColVisibility());\n                viz = vizMap.get(vizText);\n                if (viz == null) {\n                    vizMap.put(vizText, viz = new ColumnVisibility(vizText));\n                }\n            }\n            byte[] value = new byte[0];\n            if (update.isSetValue())\n                value = update.getValue();\n            if (update.isSetTimestamp()) {\n                if (update.isSetDeleteCell()) {\n                    m.putDelete(update.getColFamily(), update.getColQualifier(), viz, update.getTimestamp());\n                } else {\n                    if (update.isSetDeleteCell()) {\n                        m.putDelete(update.getColFamily(), update.getColQualifier(), viz, update.getTimestamp());\n                    } else {\n                        m.put(update.getColFamily(), update.getColQualifier(), viz, update.getTimestamp(), value);\n                    }\n                }\n            } else {\n                m.put(update.getColFamily(), update.getColQualifier(), viz, value);\n            }\n        }\n        writer.addMutation(m);\n    }\n}", "code_comment": NaN, "code_no_comment": "private void addCellsToWriter(Map<ByteBuffer, List<ColumnUpdate>> cells, BatchWriter writer) throws MutationsRejectedException {\n    HashMap<Text, ColumnVisibility> vizMap = new HashMap<Text, ColumnVisibility>();\n    for (Entry<ByteBuffer, List<ColumnUpdate>> entry : cells.entrySet()) {\n        Mutation m = new Mutation(ByteBufferUtil.toBytes(entry.getKey()));\n        for (ColumnUpdate update : entry.getValue()) {\n            ColumnVisibility viz = EMPTY_VIS;\n            if (update.isSetColVisibility()) {\n                Text vizText = new Text(update.getColVisibility());\n                viz = vizMap.get(vizText);\n                if (viz == null) {\n                    vizMap.put(vizText, viz = new ColumnVisibility(vizText));\n                }\n            }\n            byte[] value = new byte[0];\n            if (update.isSetValue())\n                value = update.getValue();\n            if (update.isSetTimestamp()) {\n                if (update.isSetDeleteCell()) {\n                    m.putDelete(update.getColFamily(), update.getColQualifier(), viz, update.getTimestamp());\n                } else {\n                    if (update.isSetDeleteCell()) {\n                        m.putDelete(update.getColFamily(), update.getColQualifier(), viz, update.getTimestamp());\n                    } else {\n                        m.put(update.getColFamily(), update.getColQualifier(), viz, update.getTimestamp(), value);\n                    }\n                }\n            } else {\n                m.put(update.getColFamily(), update.getColQualifier(), viz, value);\n            }\n        }\n        writer.addMutation(m);\n    }\n}", "lc": 0.8636363636363636, "pi": 1.5215311004784688, "ma": 1.0, "nbd": 1.5, "ml": 0.5, "d": 0.15079365079365079, "mi": -0.6256518675123323, "fo": 1.9166666666666667, "r": -0.02631578947368421, "e": 0.6080047025466364}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3834_747bccb5", "label": 1, "code": "/**\n *  Parses the given URL string.\n *\n *  @param url\n *            full absolute or relative url with query string\n *  @param charset\n *  @return Url object\n */\npublic static Url parse(String url, Charset charset) {\n    Args.notNull(url, \"url\");\n    Url result = new Url(charset);\n    // the url object resolved the charset, use that\n    charset = result.getCharset();\n    // extract query string part\n    final String queryString;\n    final String absoluteUrl;\n    int queryAt = url.indexOf('?');\n    if (queryAt == -1) {\n        queryString = \"\";\n        absoluteUrl = url;\n    } else {\n        absoluteUrl = url.substring(0, queryAt);\n        queryString = url.substring(queryAt + 1);\n    }\n    // get absolute / relative part of url\n    String relativeUrl;\n    // absolute urls contain a scheme://\n    final int protocolAt = absoluteUrl.indexOf(\"://\");\n    if (protocolAt != -1) {\n        result.protocol = absoluteUrl.substring(0, protocolAt);\n        final String afterProto = absoluteUrl.substring(protocolAt + 3);\n        final String hostAndPort;\n        int relativeAt = afterProto.indexOf('/');\n        if (relativeAt == -1) {\n            relativeUrl = \"\";\n            hostAndPort = afterProto;\n        } else {\n            relativeUrl = afterProto.substring(relativeAt);\n            hostAndPort = afterProto.substring(0, relativeAt);\n        }\n        int portAt = hostAndPort.indexOf(':');\n        if (portAt == -1) {\n            result.host = hostAndPort;\n            result.port = null;\n        } else {\n            result.host = hostAndPort.substring(0, portAt);\n            result.port = Integer.parseInt(hostAndPort.substring(portAt + 1));\n        }\n    } else {\n        relativeUrl = absoluteUrl;\n    }\n    if (relativeUrl.length() > 0) {\n        boolean removeLast = false;\n        if (relativeUrl.endsWith(\"/\")) {\n            // we need to append something and remove it after splitting\n            // because otherwise the\n            // trailing slashes will be lost\n            relativeUrl += \"/x\";\n            removeLast = true;\n        }\n        String[] segmentArray = Strings.split(relativeUrl, '/');\n        if (removeLast) {\n            segmentArray[segmentArray.length - 1] = null;\n        }\n        for (String s : segmentArray) {\n            if (s != null) {\n                result.segments.add(decodeSegment(s, charset));\n            }\n        }\n    }\n    if (queryString.length() > 0) {\n        String[] queryArray = Strings.split(queryString, '&');\n        for (String s : queryArray) {\n            result.parameters.add(parseQueryParameter(s, charset));\n        }\n    }\n    return result;\n}", "code_comment": "/**\n *  Parses the given URL string.\n *\n *  @param url\n *            full absolute or relative url with query string\n *  @param charset\n *  @return Url object\n */\n", "code_no_comment": "public static Url parse(String url, Charset charset) {\n    Args.notNull(url, \"url\");\n    Url result = new Url(charset);\n        charset = result.getCharset();\n        final String queryString;\n    final String absoluteUrl;\n    int queryAt = url.indexOf('?');\n    if (queryAt == -1) {\n        queryString = \"\";\n        absoluteUrl = url;\n    } else {\n        absoluteUrl = url.substring(0, queryAt);\n        queryString = url.substring(queryAt + 1);\n    }\n        String relativeUrl;\n        final int protocolAt = absoluteUrl.indexOf(\"://\");\n    if (protocolAt != -1) {\n        result.protocol = absoluteUrl.substring(0, protocolAt);\n        final String afterProto = absoluteUrl.substring(protocolAt + 3);\n        final String hostAndPort;\n        int relativeAt = afterProto.indexOf('/');\n        if (relativeAt == -1) {\n            relativeUrl = \"\";\n            hostAndPort = afterProto;\n        } else {\n            relativeUrl = afterProto.substring(relativeAt);\n            hostAndPort = afterProto.substring(0, relativeAt);\n        }\n        int portAt = hostAndPort.indexOf(':');\n        if (portAt == -1) {\n            result.host = hostAndPort;\n            result.port = null;\n        } else {\n            result.host = hostAndPort.substring(0, portAt);\n            result.port = Integer.parseInt(hostAndPort.substring(portAt + 1));\n        }\n    } else {\n        relativeUrl = absoluteUrl;\n    }\n    if (relativeUrl.length() > 0) {\n        boolean removeLast = false;\n        if (relativeUrl.endsWith(\"/\")) {\n                                                relativeUrl += \"/x\";\n            removeLast = true;\n        }\n        String[] segmentArray = Strings.split(relativeUrl, '/');\n        if (removeLast) {\n            segmentArray[segmentArray.length - 1] = null;\n        }\n        for (String s : segmentArray) {\n            if (s != null) {\n                result.segments.add(decodeSegment(s, charset));\n            }\n        }\n    }\n    if (queryString.length() > 0) {\n        String[] queryArray = Strings.split(queryString, '&');\n        for (String s : queryArray) {\n            result.parameters.add(parseQueryParameter(s, charset));\n        }\n    }\n    return result;\n}", "lc": 2.227272727272727, "pi": 0.17224880382775115, "ma": 1.6, "nbd": 0.5, "ml": 1.0833333333333333, "d": 1.4880952380952381, "mi": -1.0341085271317827, "fo": 1.5, "r": -0.02631578947368421, "e": 5.102122485203689}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1829_ca36450e", "label": 1, "code": "@Override\npublic PropertyValue currentProperty() {\n    PropertyValue p = operand.currentProperty();\n    if (p == null) {\n        return null;\n    }\n    // TODO what is the expected result of LOWER(x) for an array property?\n    // currently throws an exception\n    String value = p.getValue(STRING);\n    // TODO toLowerCase(): document the Turkish locale problem\n    return PropertyValues.newString(value.toLowerCase());\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic PropertyValue currentProperty() {\n    PropertyValue p = operand.currentProperty();\n    if (p == null) {\n        return null;\n    }\n            String value = p.getValue(STRING);\n        return PropertyValues.newString(value.toLowerCase());\n}", "lc": -0.22727272727272727, "pi": -0.22966507177033516, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": -0.08134920634920638, "mi": 0.2983791402396055, "fo": -0.16666666666666666, "r": 2.263157894736842, "e": -0.10219970839600513}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-1705_5308ac83", "label": 1, "code": "public String getHostname() {\n    if (hostName == null) {\n        String fqdn = getFQDNHostname();\n        if (this.fqdnHostNameIsIP) {\n            // fqdn to hostname translation is pointless if FQDN is an ip address.\n            hostName = fqdn;\n        } else {\n            hostName = NetUtils.getHostnameFromFQDN(fqdn);\n        }\n    }\n    return hostName;\n}", "code_comment": NaN, "code_no_comment": "public String getHostname() {\n    if (hostName == null) {\n        String fqdn = getFQDNHostname();\n        if (this.fqdnHostNameIsIP) {\n                        hostName = fqdn;\n        } else {\n            hostName = NetUtils.getHostnameFromFQDN(fqdn);\n        }\n    }\n    return hostName;\n}", "lc": -0.13636363636363635, "pi": 0.45933014354066987, "ma": -0.2, "nbd": 0.0, "ml": -0.08333333333333333, "d": -0.047619047619047616, "mi": 0.2369274136715997, "fo": -0.3333333333333333, "r": 1.736842105263158, "e": -0.10990358626810277}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-3448_b345dd82", "label": 0, "code": "@Override\npublic String toString() {\n    return \"ExceptionPolicyKey[\" + exceptionClass + (when != null ? \" \" + when : \"\") + \"]\";\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic String toString() {\n    return \"ExceptionPolicyKey[\" + exceptionClass + (when != null ? \" \" + when : \"\") + \"]\";\n}", "lc": -0.45454545454545453, "pi": -0.6028708133971293, "ma": -0.4, "nbd": -1.0, "ml": -0.25, "d": -0.1488095238095238, "mi": 0.7429175475687103, "fo": -0.5, "r": 2.552631578947368, "e": -0.1348777971796246}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-127_029e79da", "label": 1, "code": "/**\n * Logs a message with the specific Marker at the {@link Level#ERROR ERROR} level.\n *\n * @param marker the marker data specific to this log statement\n * @param msg    the message string to be logged\n */\npublic void error(Marker marker, Message msg) {\n    if (isEnabled(Level.ERROR, marker, msg, null)) {\n        log(null, FQCN, Level.ERROR, msg, null);\n    }\n}", "code_comment": "/**\n * Logs a message with the specific Marker at the {@link Level#ERROR ERROR} level.\n *\n * @param marker the marker data specific to this log statement\n * @param msg    the message string to be logged\n */\n", "code_no_comment": "public void error(Marker marker, Message msg) {\n    if (isEnabled(Level.ERROR, marker, msg, null)) {\n        log(null, FQCN, Level.ERROR, msg, null);\n    }\n}", "lc": -0.4090909090909091, "pi": 0.0, "ma": -0.4, "nbd": -0.5, "ml": -0.08333333333333333, "d": -0.3650793650793651, "mi": 0.6109936575052852, "fo": -0.3333333333333333, "r": 0.894736842105263, "e": -0.16279340490885932}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-2442_30761572", "label": 0, "code": "private static int countNestedElementsBefore(CompositeType<?> compositeType, int pos) {\n    if (pos == 0) {\n        return 0;\n    }\n    int ret = 0;\n    for (int i = 0; i < pos; i++) {\n        TypeInformation<?> fieldType = compositeType.getTypeAt(i);\n        ret += fieldType.getTotalFields() - 1;\n    }\n    return ret;\n}", "code_comment": NaN, "code_no_comment": "private static int countNestedElementsBefore(CompositeType<?> compositeType, int pos) {\n    if (pos == 0) {\n        return 0;\n    }\n    int ret = 0;\n    for (int i = 0; i < pos; i++) {\n        TypeInformation<?> fieldType = compositeType.getTypeAt(i);\n        ret += fieldType.getTotalFields() - 1;\n    }\n    return ret;\n}", "lc": -0.13636363636363635, "pi": -0.15311004784689008, "ma": -0.2, "nbd": -0.5, "ml": -0.08333333333333333, "d": 0.7797619047619047, "mi": 0.1385482734319945, "fo": -0.3333333333333333, "r": 0.05263157894736841, "e": 0.2100632192850515}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-867_bfbb156d", "label": 1, "code": "/**\n * @param point Normalized objective variables.\n * @return the objective value + penalty for violated bounds.\n */\npublic double value(final double[] point) {\n    double value;\n    if (boundaries != null && isRepairMode) {\n        double[] repaired = repair(point);\n        value = CMAESOptimizer.this.computeObjectiveValue(decode(repaired)) + penalty(point, repaired);\n    } else {\n        value = CMAESOptimizer.this.computeObjectiveValue(decode(point));\n    }\n    return isMinimize ? value : -value;\n}", "code_comment": "/**\n * @param point Normalized objective variables.\n * @return the objective value + penalty for violated bounds.\n */\n", "code_no_comment": "public double value(final double[] point) {\n    double value;\n    if (boundaries != null && isRepairMode) {\n        double[] repaired = repair(point);\n        value = CMAESOptimizer.this.computeObjectiveValue(decode(repaired)) + penalty(point, repaired);\n    } else {\n        value = CMAESOptimizer.this.computeObjectiveValue(decode(point));\n    }\n    return isMinimize ? value : -value;\n}", "lc": -0.18181818181818182, "pi": -0.0909090909090911, "ma": -0.2, "nbd": -0.5, "ml": 0.08333333333333333, "d": 0.4285714285714286, "mi": 0.18477801268498958, "fo": 0.0, "r": 0.47368421052631576, "e": 0.09097353088639541}
{"project_name": "Compress", "project_version": 2, "label": 1, "code": "public void close() throws IOException {\n    if (!closed) {\n        closed = true;\n        input.close();\n    }\n}", "code_comment": NaN, "code_no_comment": "public void close() throws IOException {\n    if (!closed) {\n        closed = true;\n        input.close();\n    }\n}", "lc": -0.36363636363636365, "pi": 0.13397129186602863, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": -0.10119047619047619, "mi": 0.6479210711768849, "fo": -0.4166666666666667, "r": 2.1578947368421053, "e": -0.1443520455501576}
{"project_name": "Lang", "project_version": 32, "label": 1, "code": "/**\n * <p>\n * Returns <code>true</code> if the registry contains the given object. Used by the reflection methods to avoid\n * infinite loops.\n * </p>\n *\n * @param value\n *            The object to lookup in the registry.\n * @return boolean <code>true</code> if the registry contains the given object.\n * @since 2.3\n */\nstatic boolean isRegistered(Object value) {\n    return getRegistry().contains(new IDKey(value));\n}", "code_comment": "/**\n * <p>\n * Returns <code>true</code> if the registry contains the given object. Used by the reflection methods to avoid\n * infinite loops.\n * </p>\n *\n * @param value\n *            The object to lookup in the registry.\n * @return boolean <code>true</code> if the registry contains the given object.\n * @since 2.3\n */\n", "code_no_comment": "static boolean isRegistered(Object value) {\n    return getRegistry().contains(new IDKey(value));\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.0132487667371384, "fo": -0.3333333333333333, "r": 2.3421052631578947, "e": -0.16279340490885932}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-865_b55e0206", "label": 1, "code": "/**\n * Checks dimensions and values of boundaries and inputSigma if defined.\n */\nprivate void checkParameters() {\n    final double[] init = getStartPoint();\n    final double[] lB = getLowerBound();\n    final double[] uB = getUpperBound();\n    // Checks whether there is at least one finite bound value.\n    boolean hasFiniteBounds = false;\n    for (int i = 0; i < lB.length; i++) {\n        if (!Double.isInfinite(lB[i]) || !Double.isInfinite(uB[i])) {\n            hasFiniteBounds = true;\n            break;\n        }\n    }\n    // Checks whether there is at least one infinite bound value.\n    boolean hasInfiniteBounds = false;\n    if (hasFiniteBounds) {\n        for (int i = 0; i < lB.length; i++) {\n            if (Double.isInfinite(lB[i]) || Double.isInfinite(uB[i])) {\n                hasInfiniteBounds = true;\n                break;\n            }\n        }\n        if (hasInfiniteBounds) {\n            // because mixed cases are not supported by the current code.\n            throw new MathUnsupportedOperationException();\n        } else {\n            // Convert API to internal handling of boundaries.\n            boundaries = new double[2][];\n            boundaries[0] = lB;\n            boundaries[1] = uB;\n        }\n    } else {\n        // Convert API to internal handling of boundaries.\n        boundaries = null;\n    }\n    if (inputSigma != null) {\n        if (inputSigma.length != init.length) {\n            throw new DimensionMismatchException(inputSigma.length, init.length);\n        }\n        for (int i = 0; i < init.length; i++) {\n            if (inputSigma[i] < 0) {\n                throw new NotPositiveException(inputSigma[i]);\n            }\n            if (boundaries != null) {\n                if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {\n                    throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);\n                }\n            }\n        }\n    }\n}", "code_comment": "/**\n * Checks dimensions and values of boundaries and inputSigma if defined.\n */\n", "code_no_comment": "private void checkParameters() {\n    final double[] init = getStartPoint();\n    final double[] lB = getLowerBound();\n    final double[] uB = getUpperBound();\n        boolean hasFiniteBounds = false;\n    for (int i = 0; i < lB.length; i++) {\n        if (!Double.isInfinite(lB[i]) || !Double.isInfinite(uB[i])) {\n            hasFiniteBounds = true;\n            break;\n        }\n    }\n        boolean hasInfiniteBounds = false;\n    if (hasFiniteBounds) {\n        for (int i = 0; i < lB.length; i++) {\n            if (Double.isInfinite(lB[i]) || Double.isInfinite(uB[i])) {\n                hasInfiniteBounds = true;\n                break;\n            }\n        }\n        if (hasInfiniteBounds) {\n                        throw new MathUnsupportedOperationException();\n        } else {\n                        boundaries = new double[2][];\n            boundaries[0] = lB;\n            boundaries[1] = uB;\n        }\n    } else {\n                boundaries = null;\n    }\n    if (inputSigma != null) {\n        if (inputSigma.length != init.length) {\n            throw new DimensionMismatchException(inputSigma.length, init.length);\n        }\n        for (int i = 0; i < init.length; i++) {\n            if (inputSigma[i] < 0) {\n                throw new NotPositiveException(inputSigma[i]);\n            }\n            if (boundaries != null) {\n                if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {\n                    throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);\n                }\n            }\n        }\n    }\n}", "lc": 1.4090909090909092, "pi": 0.7751196172248805, "ma": 3.0, "nbd": 1.0, "ml": 1.5833333333333333, "d": 2.6865079365079367, "mi": -0.8370683579985901, "fo": 0.08333333333333333, "r": -0.02631578947368421, "e": 4.564275629167315}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-5224_2db5570f", "label": 1, "code": "/**\n * Strategy when the file was processed and a commit should be executed.\n *\n * @param processStrategy the strategy to perform the commit\n * @param exchange        the exchange\n * @param file            the file processed\n */\nprotected void processStrategyCommit(GenericFileProcessStrategy<T> processStrategy, Exchange exchange, GenericFile<T> file) {\n    if (endpoint.isIdempotent()) {\n        // only add to idempotent repository if we could process the file\n        endpoint.getIdempotentRepository().add(absoluteFileName);\n    }\n    // delete done file if used\n    if (endpoint.getDoneFileName() != null) {\n        // done file must be in same path as the original input file\n        String doneFileName = endpoint.createDoneFileName(absoluteFileName);\n        ObjectHelper.notEmpty(doneFileName, \"doneFileName\", endpoint);\n        try {\n            // delete done file\n            boolean deleted = operations.deleteFile(doneFileName);\n            log.trace(\"Done file: {} was deleted: {}\", doneFileName, deleted);\n            if (!deleted) {\n                log.warn(\"Done file: \" + doneFileName + \" could not be deleted\");\n            }\n        } catch (Exception e) {\n            handleException(e);\n        }\n    }\n    try {\n        log.trace(\"Commit file strategy: {} for file: {}\", processStrategy, file);\n        processStrategy.commit(operations, endpoint, exchange, file);\n    } catch (Exception e) {\n        handleException(e);\n    }\n}", "code_comment": "/**\n * Strategy when the file was processed and a commit should be executed.\n *\n * @param processStrategy the strategy to perform the commit\n * @param exchange        the exchange\n * @param file            the file processed\n */\n", "code_no_comment": "protected void processStrategyCommit(GenericFileProcessStrategy<T> processStrategy, Exchange exchange, GenericFile<T> file) {\n    if (endpoint.isIdempotent()) {\n                endpoint.getIdempotentRepository().add(absoluteFileName);\n    }\n        if (endpoint.getDoneFileName() != null) {\n                String doneFileName = endpoint.createDoneFileName(absoluteFileName);\n        ObjectHelper.notEmpty(doneFileName, \"doneFileName\", endpoint);\n        try {\n                        boolean deleted = operations.deleteFile(doneFileName);\n            log.trace(\"Done file: {} was deleted: {}\", doneFileName, deleted);\n            if (!deleted) {\n                log.warn(\"Done file: \" + doneFileName + \" could not be deleted\");\n            }\n        } catch (Exception e) {\n            handleException(e);\n        }\n    }\n    try {\n        log.trace(\"Commit file strategy: {} for file: {}\", processStrategy, file);\n        processStrategy.commit(operations, endpoint, exchange, file);\n    } catch (Exception e) {\n        handleException(e);\n    }\n}", "lc": 0.45454545454545453, "pi": 0.4545454545454545, "ma": 0.4, "nbd": 0.5, "ml": 0.08333333333333333, "d": 0.3492063492063492, "mi": -0.3750528541226213, "fo": 0.5833333333333334, "r": -0.02631578947368421, "e": 0.43372463592722565}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-135_438e31a7", "label": 1, "code": "@Override\n@Nonnull\npublic PropertyIterator getProperties() throws RepositoryException {\n    checkStatus();\n    Iterator<PropertyDelegate> properties = dlg.getProperties();\n    return new PropertyIteratorAdapter(propertyIterator(properties));\n}", "code_comment": NaN, "code_no_comment": "@Override\n@Nonnull\npublic PropertyIterator getProperties() throws RepositoryException {\n    checkStatus();\n    Iterator<PropertyDelegate> properties = dlg.getProperties();\n    return new PropertyIteratorAdapter(propertyIterator(properties));\n}", "lc": -0.3181818181818182, "pi": -0.48325358851674655, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.480197322057787, "fo": -0.25, "r": 1.131578947368421, "e": -0.16279340490885932}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-539_ffa818f3", "label": 1, "code": "@Override\npublic int compareTo(Id o) {\n    byte[] other = o.getBytes();\n    int len = Math.min(raw.length, other.length);\n    for (int i = 0; i < len; i++) {\n        if (raw[i] != other[i]) {\n            return raw[i] - other[i];\n        }\n    }\n    return raw.length - other.length;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic int compareTo(Id o) {\n    byte[] other = o.getBytes();\n    int len = Math.min(raw.length, other.length);\n    for (int i = 0; i < len; i++) {\n        if (raw[i] != other[i]) {\n            return raw[i] - other[i];\n        }\n    }\n    return raw.length - other.length;\n}", "lc": -0.13636363636363635, "pi": 0.29186602870813394, "ma": -0.2, "nbd": 0.0, "ml": -0.08333333333333333, "d": 0.5416666666666667, "mi": 0.1103594080338268, "fo": -0.3333333333333333, "r": 0.15789473684210528, "e": 0.19531935247776946}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-8125_36e7b668", "label": 3, "code": "protected Component lookupPropertiesComponent() {\n    // no existing properties component so lookup and add as component if possible\n    PropertiesComponent answer = (PropertiesComponent) hasComponent(\"properties\");\n    if (answer == null) {\n        answer = getRegistry().lookupByNameAndType(\"properties\", PropertiesComponent.class);\n        if (answer != null) {\n            addComponent(\"properties\", answer);\n        }\n    }\n    return answer;\n}", "code_comment": NaN, "code_no_comment": "protected Component lookupPropertiesComponent() {\n        PropertiesComponent answer = (PropertiesComponent) hasComponent(\"properties\");\n    if (answer == null) {\n        answer = getRegistry().lookupByNameAndType(\"properties\", PropertiesComponent.class);\n        if (answer != null) {\n            addComponent(\"properties\", answer);\n        }\n    }\n    return answer;\n}", "lc": -0.18181818181818182, "pi": 0.29186602870813394, "ma": -0.2, "nbd": 0.0, "ml": -0.16666666666666666, "d": 0.013888888888888857, "mi": 0.23890063424947125, "fo": -0.16666666666666666, "r": 0.4473684210526315, "e": -0.07901891968211706}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-1025_a96b455c", "label": 1, "code": "@Override\npublic Level toLevel(final java.util.logging.Level javaLevel) {\n    return julToLog4j.get(javaLevel);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic Level toLevel(final java.util.logging.Level javaLevel) {\n    return julToLog4j.get(javaLevel);\n}", "lc": -0.45454545454545453, "pi": -0.6028708133971293, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.7978858350951374, "fo": -0.4166666666666667, "r": 0.3684210526315789, "e": -0.16279340490885932}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-43_668f08f2", "label": 1, "code": "void apply() throws Exception {\n    removeNode(nodePath);\n}", "code_comment": NaN, "code_no_comment": "void apply() throws Exception {\n    removeNode(nodePath);\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.1099365750528538, "fo": -0.4166666666666667, "r": 2.3157894736842106, "e": -0.16279340490885932}
{"project_name": "Math", "project_version": 49, "label": 1, "code": "/**\n * {@inheritDoc}\n */\n@Override\npublic OpenMapRealVector ebeMultiply(double[] v) {\n    checkVectorDimensions(v.length);\n    OpenMapRealVector res = new OpenMapRealVector(this);\n    Iterator iter = res.entries.iterator();\n    while (iter.hasNext()) {\n        iter.advance();\n        res.setEntry(iter.key(), iter.value() * v[iter.key()]);\n    }\n    return res;\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "@Override\npublic OpenMapRealVector ebeMultiply(double[] v) {\n    checkVectorDimensions(v.length);\n    OpenMapRealVector res = new OpenMapRealVector(this);\n    Iterator iter = res.entries.iterator();\n    while (iter.hasNext()) {\n        iter.advance();\n        res.setEntry(iter.key(), iter.value() * v[iter.key()]);\n    }\n    return res;\n}", "lc": -0.13636363636363635, "pi": -0.15311004784689008, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": -0.015873015873015886, "mi": 0.1450317124735728, "fo": 0.16666666666666666, "r": 0.1842105263157895, "e": -0.04874281795496851}
{"project_name": "Closure", "project_version": 148, "label": 2, "code": "private int findLastLine() {\n    int maxLine = 0;\n    for (Mapping mapping : mappings) {\n        int endPositionLine = mapping.endPosition.getLineNumber();\n        maxLine = Math.max(maxLine, endPositionLine);\n    }\n    return maxLine + prefixPosition.getLineNumber();\n}", "code_comment": NaN, "code_no_comment": "private int findLastLine() {\n    int maxLine = 0;\n    for (Mapping mapping : mappings) {\n        int endPositionLine = mapping.endPosition.getLineNumber();\n        maxLine = Math.max(maxLine, endPositionLine);\n    }\n    return maxLine + prefixPosition.getLineNumber();\n}", "lc": -0.2727272727272727, "pi": -0.07655502392344504, "ma": -0.4, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.07539682539682542, "mi": 0.35560253699788563, "fo": -0.25, "r": 0.13157894736842105, "e": -0.10224581179440188}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-1686_1f726e48", "label": 0, "code": "@Override\npublic void setInputsOutputs() {\n    try {\n        inputHandler = new InputHandler<IN>(this);\n        iterationId = configuration.getIterationId();\n        iterationWaitTime = configuration.getIterationWaitTime();\n        shouldWait = iterationWaitTime > 0;\n        BlockingQueueBroker.instance().get(iterationId.toString() + \"-\" + getEnvironment().getIndexInSubtaskGroup());\n    } catch (Exception e) {\n        throw new StreamVertexException(String.format(\"Cannot register inputs of StreamIterationSink %s\", iterationId), e);\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void setInputsOutputs() {\n    try {\n        inputHandler = new InputHandler<IN>(this);\n        iterationId = configuration.getIterationId();\n        iterationWaitTime = configuration.getIterationWaitTime();\n        shouldWait = iterationWaitTime > 0;\n        BlockingQueueBroker.instance().get(iterationId.toString() + \"-\" + getEnvironment().getIndexInSubtaskGroup());\n    } catch (Exception e) {\n        throw new StreamVertexException(String.format(\"Cannot register inputs of StreamIterationSink %s\", iterationId), e);\n    }\n}", "lc": -0.09090909090909091, "pi": 0.1578947368421051, "ma": -0.2, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.12896825396825398, "mi": 0.06243833685694159, "fo": 0.16666666666666666, "r": 0.05263157894736841, "e": -0.06398921180477515}
