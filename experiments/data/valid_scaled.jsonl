{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-369_f4a4464b", "label": 3, "code": "/**\n * {@inheritDoc}\n */\npublic double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException {\n    return solve(min, max);\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "public double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException {\n    return solve(min, max);\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.9360112755461594, "fo": -0.4166666666666667, "r": 1.9736842105263157, "e": -0.16279340490885932}
{"project_name": "Closure", "project_version": 56, "label": 2, "code": "/**\n * Gets the source line for the indicated line number.\n *\n * @param lineNumber the line number, 1 being the first line of the file.\n * @return The line indicated. Does not include the newline at the end\n *     of the file. Returns {@code null} if it does not exist,\n *     or if there was an IO exception.\n */\npublic String getLine(int lineNumber) {\n    String js = \"\";\n    try {\n        // NOTE(nicksantos): Right now, this is optimized for few warnings.\n        // This is probably the right trade-off, but will be slow if there\n        // are lots of warnings in one file.\n        js = getCode();\n    } catch (IOException e) {\n        return null;\n    }\n    int pos = 0;\n    int startLine = 1;\n    // one we're searching for, then start at that point.\n    if (lineNumber >= lastLine) {\n        pos = lastOffset;\n        startLine = lastLine;\n    }\n    for (int n = startLine; n < lineNumber; n++) {\n        int nextpos = js.indexOf('\\n', pos);\n        if (nextpos == -1) {\n            return null;\n        }\n        pos = nextpos + 1;\n    }\n    // Remember this offset for the next search we do.\n    lastOffset = pos;\n    lastLine = lineNumber;\n    if (js.indexOf('\\n', pos) == -1) {\n        // 2. otherwise, return the contents between pos and the end of file.\n        return null;\n    } else {\n        return js.substring(pos, js.indexOf('\\n', pos));\n    }\n}", "code_comment": "/**\n * Gets the source line for the indicated line number.\n *\n * @param lineNumber the line number, 1 being the first line of the file.\n * @return The line indicated. Does not include the newline at the end\n *     of the file. Returns {@code null} if it does not exist,\n *     or if there was an IO exception.\n */\n", "code_no_comment": "public String getLine(int lineNumber) {\n    String js = \"\";\n    try {\n                                js = getCode();\n    } catch (IOException e) {\n        return null;\n    }\n    int pos = 0;\n    int startLine = 1;\n        if (lineNumber >= lastLine) {\n        pos = lastOffset;\n        startLine = lastLine;\n    }\n    for (int n = startLine; n < lineNumber; n++) {\n        int nextpos = js.indexOf('\\n', pos);\n        if (nextpos == -1) {\n            return null;\n        }\n        pos = nextpos + 1;\n    }\n        lastOffset = pos;\n    lastLine = lineNumber;\n    if (js.indexOf('\\n', pos) == -1) {\n                return null;\n    } else {\n        return js.substring(pos, js.indexOf('\\n', pos));\n    }\n}", "lc": 0.6363636363636364, "pi": -0.1578947368421053, "ma": 0.4, "nbd": 0.0, "ml": 0.4166666666666667, "d": 1.1944444444444444, "mi": -0.44411557434813226, "fo": -0.08333333333333333, "r": -0.02631578947368421, "e": 1.1258565146983395}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4138_7c89598a", "label": 1, "code": "@Override\npublic boolean shouldPreserveClientUrl() {\n    return errorAttributes != null && !Strings.isEmpty(errorAttributes.getRequestUri());\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean shouldPreserveClientUrl() {\n    return errorAttributes != null && !Strings.isEmpty(errorAttributes.getRequestUri());\n}", "lc": -0.45454545454545453, "pi": -0.6028708133971293, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.14285714285714285, "mi": 0.791966173361522, "fo": -0.3333333333333333, "r": 1.4210526315789473, "e": -0.14126311785757506}
{"project_name": "Closure", "project_version": 39, "label": 2, "code": "@Override\nString toStringHelper(boolean forAnnotations) {\n    if (hasReferenceName()) {\n        return getReferenceName();\n    } else if (prettyPrint) {\n        // Don't pretty print recursively.\n        prettyPrint = false;\n        // Use a tree set so that the properties are sorted.\n        Set<String> propertyNames = Sets.newTreeSet();\n        for (ObjectType current = this; current != null && !current.isNativeObjectType() && propertyNames.size() <= MAX_PRETTY_PRINTED_PROPERTIES; current = current.getImplicitPrototype()) {\n            propertyNames.addAll(current.getOwnPropertyNames());\n        }\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"{\");\n        int i = 0;\n        for (String property : propertyNames) {\n            if (i > 0) {\n                sb.append(\", \");\n            }\n            sb.append(property);\n            sb.append(\": \");\n            sb.append(getPropertyType(property).toString());\n            ++i;\n            if (i == MAX_PRETTY_PRINTED_PROPERTIES) {\n                sb.append(\", ...\");\n                break;\n            }\n        }\n        sb.append(\"}\");\n        prettyPrint = true;\n        return sb.toString();\n    } else {\n        return \"{...}\";\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\nString toStringHelper(boolean forAnnotations) {\n    if (hasReferenceName()) {\n        return getReferenceName();\n    } else if (prettyPrint) {\n                prettyPrint = false;\n                Set<String> propertyNames = Sets.newTreeSet();\n        for (ObjectType current = this; current != null && !current.isNativeObjectType() && propertyNames.size() <= MAX_PRETTY_PRINTED_PROPERTIES; current = current.getImplicitPrototype()) {\n            propertyNames.addAll(current.getOwnPropertyNames());\n        }\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"{\");\n        int i = 0;\n        for (String property : propertyNames) {\n            if (i > 0) {\n                sb.append(\", \");\n            }\n            sb.append(property);\n            sb.append(\": \");\n            sb.append(getPropertyType(property).toString());\n            ++i;\n            if (i == MAX_PRETTY_PRINTED_PROPERTIES) {\n                sb.append(\", ...\");\n                break;\n            }\n        }\n        sb.append(\"}\");\n        prettyPrint = true;\n        return sb.toString();\n    } else {\n        return \"{...}\";\n    }\n}", "lc": 0.8636363636363636, "pi": 0.5741626794258374, "ma": 0.8, "nbd": 1.0, "ml": 0.6666666666666666, "d": 1.1785714285714286, "mi": -0.5751937984496123, "fo": 1.0, "r": -0.02631578947368421, "e": 1.551801202146113}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-621_00b4b8a0", "label": 1, "code": "@Override\npublic Iterable<Tree> getChildren() {\n    root.checkLive();\n    Iterable<String> childNames;\n    if (hasOrderableChildren()) {\n        childNames = getOrderedChildNames();\n    } else {\n        childNames = getNodeBuilder().getChildNodeNames();\n    }\n    return Iterables.filter(Iterables.transform(childNames, new Function<String, Tree>() {\n\n        @Override\n        public Tree apply(String input) {\n            return new TreeImpl(root, TreeImpl.this, input);\n        }\n    }), new Predicate<Tree>() {\n\n        @Override\n        public boolean apply(Tree tree) {\n            return tree != null && canRead(tree);\n        }\n    });\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic Iterable<Tree> getChildren() {\n    root.checkLive();\n    Iterable<String> childNames;\n    if (hasOrderableChildren()) {\n        childNames = getOrderedChildNames();\n    } else {\n        childNames = getNodeBuilder().getChildNodeNames();\n    }\n    return Iterables.filter(Iterables.transform(childNames, new Function<String, Tree>() {\n\n        @Override\n        public Tree apply(String input) {\n            return new TreeImpl(root, TreeImpl.this, input);\n        }\n    }), new Predicate<Tree>() {\n\n        @Override\n        public boolean apply(Tree tree) {\n            return tree != null && canRead(tree);\n        }\n    });\n}", "lc": 0.3181818181818182, "pi": 0.1961722488038276, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": -0.009920634920634929, "mi": -0.21860465116279051, "fo": 0.16666666666666666, "r": 0.0, "e": 0.021804602271744935}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-3498_b4606700", "label": 1, "code": "@SuppressWarnings(\"unchecked\")\nprivate Iterable<ProcessorExchangePair> createProcessorExchangePairsIterable(final Exchange exchange, final Object value) {\n    final Iterator iterator = ObjectHelper.createIterator(value);\n    return new Iterable() {\n\n        public Iterator iterator() {\n            return new Iterator() {\n\n                private int index;\n\n                private boolean closed;\n\n                public boolean hasNext() {\n                    if (closed) {\n                        return false;\n                    }\n                    boolean answer = iterator.hasNext();\n                    if (!answer) {\n                        // we are now closed\n                        closed = true;\n                        // nothing more so we need to close the expression value in case it needs to be\n                        if (value instanceof Closeable) {\n                            IOHelper.close((Closeable) value, value.getClass().getName(), LOG);\n                        } else if (value instanceof Scanner) {\n                            // special for Scanner as it does not implement Closeable\n                            ((Scanner) value).close();\n                        }\n                    }\n                    return answer;\n                }\n\n                public Object next() {\n                    Object part = iterator.next();\n                    Exchange newExchange = ExchangeHelper.createCopy(exchange, true);\n                    if (part instanceof Message) {\n                        newExchange.setIn((Message) part);\n                    } else {\n                        Message in = newExchange.getIn();\n                        in.setBody(part);\n                    }\n                    return createProcessorExchangePair(index++, getProcessors().iterator().next(), newExchange);\n                }\n\n                public void remove() {\n                    throw new UnsupportedOperationException(\"Remove is not supported by this iterator\");\n                }\n            };\n        }\n    };\n}", "code_comment": NaN, "code_no_comment": "@SuppressWarnings(\"unchecked\")\nprivate Iterable<ProcessorExchangePair> createProcessorExchangePairsIterable(final Exchange exchange, final Object value) {\n    final Iterator iterator = ObjectHelper.createIterator(value);\n    return new Iterable() {\n\n        public Iterator iterator() {\n            return new Iterator() {\n\n                private int index;\n\n                private boolean closed;\n\n                public boolean hasNext() {\n                    if (closed) {\n                        return false;\n                    }\n                    boolean answer = iterator.hasNext();\n                    if (!answer) {\n                                                closed = true;\n                                                if (value instanceof Closeable) {\n                            IOHelper.close((Closeable) value, value.getClass().getName(), LOG);\n                        } else if (value instanceof Scanner) {\n                                                        ((Scanner) value).close();\n                        }\n                    }\n                    return answer;\n                }\n\n                public Object next() {\n                    Object part = iterator.next();\n                    Exchange newExchange = ExchangeHelper.createCopy(exchange, true);\n                    if (part instanceof Message) {\n                        newExchange.setIn((Message) part);\n                    } else {\n                        Message in = newExchange.getIn();\n                        in.setBody(part);\n                    }\n                    return createProcessorExchangePair(index++, getProcessors().iterator().next(), newExchange);\n                }\n\n                public void remove() {\n                    throw new UnsupportedOperationException(\"Remove is not supported by this iterator\");\n                }\n            };\n        }\n    };\n}", "lc": 1.2272727272727273, "pi": 2.186602870813397, "ma": 0.6, "nbd": 1.5, "ml": 0.3333333333333333, "d": 0.011904761904761871, "mi": -0.669626497533474, "fo": 0.75, "r": -0.02631578947368421, "e": 0.2616068186926228}
{"project_name": "Closure", "project_version": 46, "label": 2, "code": "@Override\npublic JSType getLeastSupertype(JSType that) {\n    if (!that.isRecordType()) {\n        return super.getLeastSupertype(that);\n    }\n    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n    for (String property : properties.keySet()) {\n        if (that.toMaybeRecordType().hasProperty(property) && that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(getPropertyType(property))) {\n            builder.addProperty(property, getPropertyType(property), getPropertyNode(property));\n        }\n    }\n    return builder.build();\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic JSType getLeastSupertype(JSType that) {\n    if (!that.isRecordType()) {\n        return super.getLeastSupertype(that);\n    }\n    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n    for (String property : properties.keySet()) {\n        if (that.toMaybeRecordType().hasProperty(property) && that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(getPropertyType(property))) {\n            builder.addProperty(property, getPropertyType(property), getPropertyNode(property));\n        }\n    }\n    return builder.build();\n}", "lc": -0.045454545454545456, "pi": 0.22009569377990432, "ma": 0.0, "nbd": 0.0, "ml": 0.25, "d": 0.011904761904761871, "mi": 0.014799154334038212, "fo": 0.5833333333333334, "r": -0.02631578947368421, "e": -0.000329639298536808}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1822_016df669", "label": 1, "code": "/**\n * Creates a MongoDB update object from the given UpdateOp.\n *\n * @param updateOp the update op.\n * @return the DBObject.\n */\n@Nonnull\nprivate static DBObject createUpdate(UpdateOp updateOp) {\n    BasicDBObject setUpdates = new BasicDBObject();\n    BasicDBObject incUpdates = new BasicDBObject();\n    BasicDBObject unsetUpdates = new BasicDBObject();\n    // always increment modCount\n    updateOp.increment(Document.MOD_COUNT, 1);\n    // other updates\n    for (Entry<Key, Operation> entry : updateOp.getChanges().entrySet()) {\n        Key k = entry.getKey();\n        if (k.getName().equals(Document.ID)) {\n            // avoid exception \"Mod on _id not allowed\"\n            continue;\n        }\n        Operation op = entry.getValue();\n        switch(op.type) {\n            case SET:\n                {\n                    setUpdates.append(k.toString(), op.value);\n                    break;\n                }\n            case INCREMENT:\n                {\n                    incUpdates.append(k.toString(), op.value);\n                    break;\n                }\n            case SET_MAP_ENTRY:\n                {\n                    setUpdates.append(k.toString(), op.value);\n                    break;\n                }\n            case REMOVE_MAP_ENTRY:\n                {\n                    unsetUpdates.append(k.toString(), \"1\");\n                    break;\n                }\n        }\n    }\n    BasicDBObject update = new BasicDBObject();\n    if (!setUpdates.isEmpty()) {\n        update.append(\"$set\", setUpdates);\n    }\n    if (!incUpdates.isEmpty()) {\n        update.append(\"$inc\", incUpdates);\n    }\n    if (!unsetUpdates.isEmpty()) {\n        update.append(\"$unset\", unsetUpdates);\n    }\n    return update;\n}", "code_comment": "/**\n * Creates a MongoDB update object from the given UpdateOp.\n *\n * @param updateOp the update op.\n * @return the DBObject.\n */\n", "code_no_comment": "@Nonnull\nprivate static DBObject createUpdate(UpdateOp updateOp) {\n    BasicDBObject setUpdates = new BasicDBObject();\n    BasicDBObject incUpdates = new BasicDBObject();\n    BasicDBObject unsetUpdates = new BasicDBObject();\n        updateOp.increment(Document.MOD_COUNT, 1);\n        for (Entry<Key, Operation> entry : updateOp.getChanges().entrySet()) {\n        Key k = entry.getKey();\n        if (k.getName().equals(Document.ID)) {\n                        continue;\n        }\n        Operation op = entry.getValue();\n        switch(op.type) {\n            case SET:\n                {\n                    setUpdates.append(k.toString(), op.value);\n                    break;\n                }\n            case INCREMENT:\n                {\n                    incUpdates.append(k.toString(), op.value);\n                    break;\n                }\n            case SET_MAP_ENTRY:\n                {\n                    setUpdates.append(k.toString(), op.value);\n                    break;\n                }\n            case REMOVE_MAP_ENTRY:\n                {\n                    unsetUpdates.append(k.toString(), \"1\");\n                    break;\n                }\n        }\n    }\n    BasicDBObject update = new BasicDBObject();\n    if (!setUpdates.isEmpty()) {\n        update.append(\"$set\", setUpdates);\n    }\n    if (!incUpdates.isEmpty()) {\n        update.append(\"$inc\", incUpdates);\n    }\n    if (!unsetUpdates.isEmpty()) {\n        update.append(\"$unset\", unsetUpdates);\n    }\n    return update;\n}", "lc": 1.5, "pi": 1.6507177033492826, "ma": 2.2, "nbd": 0.5, "ml": 0.6666666666666666, "d": 0.0853174603174603, "mi": -0.799859055673009, "fo": 1.25, "r": -0.02631578947368421, "e": 0.4027800349233242}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1731_024e5d37", "label": 1, "code": "private void copyPropertyDefinition(QPropertyDefinition def, NodeBuilder builder) throws NamespaceException {\n    builder.setProperty(JCR_PRIMARYTYPE, NT_PROPERTYDEFINITION, NAME);\n    copyItemDefinition(def, builder);\n    // - jcr:requiredType (STRING) protected mandatory\n    // < 'STRING', 'URI', 'BINARY', 'LONG', 'DOUBLE',\n    // 'DECIMAL', 'BOOLEAN', 'DATE', 'NAME', 'PATH',\n    // 'REFERENCE', 'WEAKREFERENCE', 'UNDEFINED'\n    builder.setProperty(JCR_REQUIREDTYPE, Type.fromTag(def.getRequiredType(), false).toString());\n    // - jcr:valueConstraints (STRING) protected multiple\n    QValueConstraint[] constraints = def.getValueConstraints();\n    if (constraints != null && constraints.length > 0) {\n        List<String> strings = newArrayListWithCapacity(constraints.length);\n        for (QValueConstraint constraint : constraints) {\n            strings.add(constraint.getString());\n        }\n        builder.setProperty(JCR_VALUECONSTRAINTS, strings, STRINGS);\n    }\n    // - jcr:defaultValues (UNDEFINED) protected multiple\n    QValue[] values = def.getDefaultValues();\n    if (values != null) {\n    // TODO\n    }\n    // - jcr:multiple (BOOLEAN) protected mandatory\n    builder.setProperty(JCR_MULTIPLE, def.isMultiple());\n    // - jcr:availableQueryOperators (NAME) protected mandatory multiple\n    List<String> operators = asList(def.getAvailableQueryOperators());\n    builder.setProperty(JCR_AVAILABLE_QUERY_OPERATORS, operators, NAMES);\n    // - jcr:isFullTextSearchable (BOOLEAN) protected mandatory\n    builder.setProperty(JCR_IS_FULLTEXT_SEARCHABLE, def.isFullTextSearchable());\n    // - jcr:isQueryOrderable (BOOLEAN) protected mandatory\n    builder.setProperty(JCR_IS_QUERY_ORDERABLE, def.isQueryOrderable());\n}", "code_comment": NaN, "code_no_comment": "private void copyPropertyDefinition(QPropertyDefinition def, NodeBuilder builder) throws NamespaceException {\n    builder.setProperty(JCR_PRIMARYTYPE, NT_PROPERTYDEFINITION, NAME);\n    copyItemDefinition(def, builder);\n                    builder.setProperty(JCR_REQUIREDTYPE, Type.fromTag(def.getRequiredType(), false).toString());\n        QValueConstraint[] constraints = def.getValueConstraints();\n    if (constraints != null && constraints.length > 0) {\n        List<String> strings = newArrayListWithCapacity(constraints.length);\n        for (QValueConstraint constraint : constraints) {\n            strings.add(constraint.getString());\n        }\n        builder.setProperty(JCR_VALUECONSTRAINTS, strings, STRINGS);\n    }\n        QValue[] values = def.getDefaultValues();\n    if (values != null) {\n        }\n        builder.setProperty(JCR_MULTIPLE, def.isMultiple());\n        List<String> operators = asList(def.getAvailableQueryOperators());\n    builder.setProperty(JCR_AVAILABLE_QUERY_OPERATORS, operators, NAMES);\n        builder.setProperty(JCR_IS_FULLTEXT_SEARCHABLE, def.isFullTextSearchable());\n        builder.setProperty(JCR_IS_QUERY_ORDERABLE, def.isQueryOrderable());\n}", "lc": 0.3181818181818182, "pi": -0.16267942583732073, "ma": 0.0, "nbd": 0.0, "ml": 0.08333333333333333, "d": 0.33531746031746024, "mi": -0.3541930937279773, "fo": 1.25, "r": -0.02631578947368421, "e": 0.6777360926217273}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3517_24f7f60a", "label": 1, "code": "@Nonnull\n@Override\npublic Node perform() throws RepositoryException {\n    String oakName = PathUtils.getName(oakPath);\n    String parentPath = PathUtils.getParentPath(oakPath);\n    NodeDelegate parent = dlg.getChild(parentPath);\n    if (parent == null) {\n        // is it a property?\n        String grandParentPath = PathUtils.getParentPath(parentPath);\n        NodeDelegate grandParent = dlg.getChild(grandParentPath);\n        if (grandParent != null) {\n            String propName = PathUtils.getName(parentPath);\n            if (grandParent.getPropertyOrNull(propName) != null) {\n                throw new ConstraintViolationException(\"Can't add new node to property.\");\n            }\n        }\n        throw new PathNotFoundException(relPath);\n    }\n    if (parent.getChild(oakName) != null) {\n        throw new ItemExistsException(relPath);\n    }\n    // modification of that property in the PermissionValidator\n    if (oakTypeName != null) {\n        PropertyState prop = PropertyStates.createProperty(JCR_PRIMARYTYPE, oakTypeName, NAME);\n        sessionContext.getAccessManager().checkPermissions(dlg.getTree(), prop, Permissions.NODE_TYPE_MANAGEMENT);\n    }\n    NodeDelegate added = parent.addChild(oakName, oakTypeName);\n    if (added == null) {\n        throw new ItemExistsException();\n    }\n    return createNode(added, sessionContext);\n}", "code_comment": NaN, "code_no_comment": "@Nonnull\n@Override\npublic Node perform() throws RepositoryException {\n    String oakName = PathUtils.getName(oakPath);\n    String parentPath = PathUtils.getParentPath(oakPath);\n    NodeDelegate parent = dlg.getChild(parentPath);\n    if (parent == null) {\n                String grandParentPath = PathUtils.getParentPath(parentPath);\n        NodeDelegate grandParent = dlg.getChild(grandParentPath);\n        if (grandParent != null) {\n            String propName = PathUtils.getName(parentPath);\n            if (grandParent.getPropertyOrNull(propName) != null) {\n                throw new ConstraintViolationException(\"Can't add new node to property.\");\n            }\n        }\n        throw new PathNotFoundException(relPath);\n    }\n    if (parent.getChild(oakName) != null) {\n        throw new ItemExistsException(relPath);\n    }\n        if (oakTypeName != null) {\n        PropertyState prop = PropertyStates.createProperty(JCR_PRIMARYTYPE, oakTypeName, NAME);\n        sessionContext.getAccessManager().checkPermissions(dlg.getTree(), prop, Permissions.NODE_TYPE_MANAGEMENT);\n    }\n    NodeDelegate added = parent.addChild(oakName, oakTypeName);\n    if (added == null) {\n        throw new ItemExistsException();\n    }\n    return createNode(added, sessionContext);\n}", "lc": 0.7272727272727273, "pi": 0.40191387559808606, "ma": 1.4, "nbd": 0.5, "ml": 0.75, "d": 0.01785714285714283, "mi": -0.5678646934460886, "fo": 0.6666666666666666, "r": -0.02631578947368421, "e": 0.3140033309705341}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1732_941e3cb1", "label": 3, "code": "/**\n * Gets the splits of the tables that have been set on the job.\n *\n * @param context\n *          the configuration of the job\n * @return the splits from the tables based on the ranges.\n * @throws java.io.IOException\n *           if a table set on the job doesn't exist or an error occurs initializing the tablet locator\n */\npublic List<InputSplit> getSplits(JobContext context) throws IOException {\n    log.setLevel(getLogLevel(context));\n    validateOptions(context);\n    LinkedList<InputSplit> splits = new LinkedList<InputSplit>();\n    Map<String, BatchScanConfig> tableConfigs = getBatchScanConfigs(context);\n    for (Map.Entry<String, BatchScanConfig> tableConfigEntry : tableConfigs.entrySet()) {\n        String tableName = tableConfigEntry.getKey();\n        BatchScanConfig tableConfig = tableConfigEntry.getValue();\n        boolean autoAdjust = tableConfig.shouldAutoAdjustRanges();\n        String tableId = null;\n        List<Range> ranges = autoAdjust ? Range.mergeOverlapping(tableConfig.getRanges()) : tableConfig.getRanges();\n        if (ranges.isEmpty()) {\n            ranges = new ArrayList<Range>(1);\n            ranges.add(new Range());\n        }\n        // get the metadata information for these ranges\n        Map<String, Map<KeyExtent, List<Range>>> binnedRanges = new HashMap<String, Map<KeyExtent, List<Range>>>();\n        TabletLocator tl;\n        try {\n            // resolve table name to id once, and use id from this point forward\n            tableId = Tables.getTableId(getInstance(context), tableName);\n            if (tableConfig.isOfflineScan()) {\n                binnedRanges = binOfflineTable(context, tableId, ranges);\n                while (binnedRanges == null) {\n                    // Some tablets were still online, try again\n                    // sleep randomly between 100 and 200 ms\n                    UtilWaitThread.sleep(100 + (int) (Math.random() * 100));\n                    binnedRanges = binOfflineTable(context, tableId, ranges);\n                }\n            } else {\n                Instance instance = getInstance(context);\n                tl = getTabletLocator(context, tableId);\n                // its possible that the cache could contain complete, but old information about a tables tablets... so clear it\n                tl.invalidateCache();\n                Credentials creds = new Credentials(getPrincipal(context), getAuthenticationToken(context));\n                while (!tl.binRanges(creds, ranges, binnedRanges).isEmpty()) {\n                    if (!(instance instanceof MockInstance)) {\n                        if (!Tables.exists(instance, tableId))\n                            throw new TableDeletedException(tableId);\n                        if (Tables.getTableState(instance, tableId) == TableState.OFFLINE)\n                            throw new TableOfflineException(instance, tableId);\n                    }\n                    binnedRanges.clear();\n                    log.warn(\"Unable to locate bins for specified ranges. Retrying.\");\n                    // sleep randomly between 100 and 200 ms\n                    UtilWaitThread.sleep(100 + (int) (Math.random() * 100));\n                    tl.invalidateCache();\n                }\n            }\n        } catch (Exception e) {\n            throw new IOException(e);\n        }\n        HashMap<Range, ArrayList<String>> splitsToAdd = null;\n        if (!autoAdjust)\n            splitsToAdd = new HashMap<Range, ArrayList<String>>();\n        HashMap<String, String> hostNameCache = new HashMap<String, String>();\n        for (Map.Entry<String, Map<KeyExtent, List<Range>>> tserverBin : binnedRanges.entrySet()) {\n            String ip = tserverBin.getKey().split(\":\", 2)[0];\n            String location = hostNameCache.get(ip);\n            if (location == null) {\n                InetAddress inetAddress = InetAddress.getByName(ip);\n                location = inetAddress.getHostName();\n                hostNameCache.put(ip, location);\n            }\n            for (Map.Entry<KeyExtent, List<Range>> extentRanges : tserverBin.getValue().entrySet()) {\n                Range ke = extentRanges.getKey().toDataRange();\n                for (Range r : extentRanges.getValue()) {\n                    if (autoAdjust) {\n                        // divide ranges into smaller ranges, based on the tablets\n                        splits.add(new RangeInputSplit(tableName, tableId, ke.clip(r), new String[] { location }));\n                    } else {\n                        // don't divide ranges\n                        ArrayList<String> locations = splitsToAdd.get(r);\n                        if (locations == null)\n                            locations = new ArrayList<String>(1);\n                        locations.add(location);\n                        splitsToAdd.put(r, locations);\n                    }\n                }\n            }\n        }\n        if (!autoAdjust)\n            for (Map.Entry<Range, ArrayList<String>> entry : splitsToAdd.entrySet()) splits.add(new RangeInputSplit(tableName, tableId, entry.getKey(), entry.getValue().toArray(new String[0])));\n    }\n    return splits;\n}", "code_comment": "/**\n * Gets the splits of the tables that have been set on the job.\n *\n * @param context\n *          the configuration of the job\n * @return the splits from the tables based on the ranges.\n * @throws java.io.IOException\n *           if a table set on the job doesn't exist or an error occurs initializing the tablet locator\n */\n", "code_no_comment": "public List<InputSplit> getSplits(JobContext context) throws IOException {\n    log.setLevel(getLogLevel(context));\n    validateOptions(context);\n    LinkedList<InputSplit> splits = new LinkedList<InputSplit>();\n    Map<String, BatchScanConfig> tableConfigs = getBatchScanConfigs(context);\n    for (Map.Entry<String, BatchScanConfig> tableConfigEntry : tableConfigs.entrySet()) {\n        String tableName = tableConfigEntry.getKey();\n        BatchScanConfig tableConfig = tableConfigEntry.getValue();\n        boolean autoAdjust = tableConfig.shouldAutoAdjustRanges();\n        String tableId = null;\n        List<Range> ranges = autoAdjust ? Range.mergeOverlapping(tableConfig.getRanges()) : tableConfig.getRanges();\n        if (ranges.isEmpty()) {\n            ranges = new ArrayList<Range>(1);\n            ranges.add(new Range());\n        }\n                Map<String, Map<KeyExtent, List<Range>>> binnedRanges = new HashMap<String, Map<KeyExtent, List<Range>>>();\n        TabletLocator tl;\n        try {\n                        tableId = Tables.getTableId(getInstance(context), tableName);\n            if (tableConfig.isOfflineScan()) {\n                binnedRanges = binOfflineTable(context, tableId, ranges);\n                while (binnedRanges == null) {\n                                                            UtilWaitThread.sleep(100 + (int) (Math.random() * 100));\n                    binnedRanges = binOfflineTable(context, tableId, ranges);\n                }\n            } else {\n                Instance instance = getInstance(context);\n                tl = getTabletLocator(context, tableId);\n                                tl.invalidateCache();\n                Credentials creds = new Credentials(getPrincipal(context), getAuthenticationToken(context));\n                while (!tl.binRanges(creds, ranges, binnedRanges).isEmpty()) {\n                    if (!(instance instanceof MockInstance)) {\n                        if (!Tables.exists(instance, tableId))\n                            throw new TableDeletedException(tableId);\n                        if (Tables.getTableState(instance, tableId) == TableState.OFFLINE)\n                            throw new TableOfflineException(instance, tableId);\n                    }\n                    binnedRanges.clear();\n                    log.warn(\"Unable to locate bins for specified ranges. Retrying.\");\n                                        UtilWaitThread.sleep(100 + (int) (Math.random() * 100));\n                    tl.invalidateCache();\n                }\n            }\n        } catch (Exception e) {\n            throw new IOException(e);\n        }\n        HashMap<Range, ArrayList<String>> splitsToAdd = null;\n        if (!autoAdjust)\n            splitsToAdd = new HashMap<Range, ArrayList<String>>();\n        HashMap<String, String> hostNameCache = new HashMap<String, String>();\n        for (Map.Entry<String, Map<KeyExtent, List<Range>>> tserverBin : binnedRanges.entrySet()) {\n            String ip = tserverBin.getKey().split(\":\", 2)[0];\n            String location = hostNameCache.get(ip);\n            if (location == null) {\n                InetAddress inetAddress = InetAddress.getByName(ip);\n                location = inetAddress.getHostName();\n                hostNameCache.put(ip, location);\n            }\n            for (Map.Entry<KeyExtent, List<Range>> extentRanges : tserverBin.getValue().entrySet()) {\n                Range ke = extentRanges.getKey().toDataRange();\n                for (Range r : extentRanges.getValue()) {\n                    if (autoAdjust) {\n                                                splits.add(new RangeInputSplit(tableName, tableId, ke.clip(r), new String[] { location }));\n                    } else {\n                                                ArrayList<String> locations = splitsToAdd.get(r);\n                        if (locations == null)\n                            locations = new ArrayList<String>(1);\n                        locations.add(location);\n                        splitsToAdd.put(r, locations);\n                    }\n                }\n            }\n        }\n        if (!autoAdjust)\n            for (Map.Entry<Range, ArrayList<String>> entry : splitsToAdd.entrySet()) splits.add(new RangeInputSplit(tableName, tableId, entry.getKey(), entry.getValue().toArray(new String[0])));\n    }\n    return splits;\n}", "lc": 2.909090909090909, "pi": 1.7894736842105265, "ma": 3.8, "nbd": 1.5, "ml": 1.5833333333333333, "d": 0.8134920634920636, "mi": -1.2875264270613105, "fo": 4.166666666666667, "r": -0.02631578947368421, "e": 5.792248866144544}
{"project_name": "Closure", "project_version": 169, "label": 2, "code": "/**\n * Determines if typeA is a subtype of typeB\n */\nstatic boolean isSubtype(ObjectType typeA, RecordType typeB) {\n    // to the property of z would not violate any restrictions on it.\n    for (String property : typeB.properties.keySet()) {\n        if (!typeA.hasProperty(property)) {\n            return false;\n        }\n        JSType propA = typeA.getPropertyType(property);\n        JSType propB = typeB.getPropertyType(property);\n        if (!propA.isUnknownType() && !propB.isUnknownType()) {\n            if (typeA.isPropertyTypeDeclared(property)) {\n                // then the whole record isn't covariant.\n                if (!propA.isInvariant(propB)) {\n                    return false;\n                }\n            } else {\n                // then the whole record isn't covariant.\n                if (!propA.isSubtype(propB)) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}", "code_comment": "/**\n * Determines if typeA is a subtype of typeB\n */\n", "code_no_comment": "static boolean isSubtype(ObjectType typeA, RecordType typeB) {\n        for (String property : typeB.properties.keySet()) {\n        if (!typeA.hasProperty(property)) {\n            return false;\n        }\n        JSType propA = typeA.getPropertyType(property);\n        JSType propB = typeB.getPropertyType(property);\n        if (!propA.isUnknownType() && !propB.isUnknownType()) {\n            if (typeA.isPropertyTypeDeclared(property)) {\n                                if (!propA.isInvariant(propB)) {\n                    return false;\n                }\n            } else {\n                                if (!propA.isSubtype(propB)) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}", "lc": 0.3181818181818182, "pi": 1.3157894736842106, "ma": 0.6, "nbd": 1.0, "ml": 0.75, "d": 0.041666666666666616, "mi": -0.24989429175475666, "fo": 0.25, "r": 0.10526315789473684, "e": 0.04669582706615259}
{"project_name": "Closure", "project_version": 84, "label": 2, "code": "@Override\nNode processAssignment(Assignment assignmentNode) {\n    Node assign = processInfixExpression(assignmentNode);\n    return assign;\n}", "code_comment": NaN, "code_no_comment": "@Override\nNode processAssignment(Assignment assignmentNode) {\n    Node assign = processInfixExpression(assignmentNode);\n    return assign;\n}", "lc": -0.4090909090909091, "pi": -0.49282296650717716, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.702889358703312, "fo": -0.4166666666666667, "r": 2.131578947368421, "e": -0.16279340490885932}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1051_25cf3ccd", "label": 3, "code": "@Override\npublic int hashCode() {\n    int result = 0;\n    for (ByteSequence b : auths) result += b.hashCode();\n    return result;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic int hashCode() {\n    int result = 0;\n    for (ByteSequence b : auths) result += b.hashCode();\n    return result;\n}", "lc": -0.36363636363636365, "pi": -0.47368421052631593, "ma": -0.4, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.06746031746031747, "mi": 0.5836504580690626, "fo": -0.4166666666666667, "r": 1.2894736842105263, "e": -0.13063167418728353}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-1089_e91d0f05", "label": 1, "code": "/**\n * Rounds the given value to the specified number of decimal places.\n * The value is rounded using the given method which is any method defined\n * in {@link BigDecimal}.\n * If {@code x} is infinite or {@code NaN}, then the value of {@code x} is\n * returned unchanged, regardless of the other parameters.\n *\n * @param x Value to round.\n * @param scale Number of digits to the right of the decimal point.\n * @param roundingMethod Rounding method as defined in {@link BigDecimal}.\n * @return the rounded value.\n * @throws ArithmeticException if {@code roundingMethod == ROUND_UNNECESSARY}\n * and the specified scaling operation would require rounding.\n * @throws IllegalArgumentException if {@code roundingMethod} does not\n * represent a valid rounding mode.\n * @since 1.1 (previously in {@code MathUtils}, moved as of version 3.0)\n */\npublic static double round(double x, int scale, int roundingMethod) {\n    try {\n        return (new BigDecimal(Double.toString(x)).setScale(scale, roundingMethod)).doubleValue();\n    } catch (NumberFormatException ex) {\n        if (Double.isInfinite(x)) {\n            return x;\n        } else {\n            return Double.NaN;\n        }\n    }\n}", "code_comment": "/**\n * Rounds the given value to the specified number of decimal places.\n * The value is rounded using the given method which is any method defined\n * in {@link BigDecimal}.\n * If {@code x} is infinite or {@code NaN}, then the value of {@code x} is\n * returned unchanged, regardless of the other parameters.\n *\n * @param x Value to round.\n * @param scale Number of digits to the right of the decimal point.\n * @param roundingMethod Rounding method as defined in {@link BigDecimal}.\n * @return the rounded value.\n * @throws ArithmeticException if {@code roundingMethod == ROUND_UNNECESSARY}\n * and the specified scaling operation would require rounding.\n * @throws IllegalArgumentException if {@code roundingMethod} does not\n * represent a valid rounding mode.\n * @since 1.1 (previously in {@code MathUtils}, moved as of version 3.0)\n */\n", "code_no_comment": "public static double round(double x, int scale, int roundingMethod) {\n    try {\n        return (new BigDecimal(Double.toString(x)).setScale(scale, roundingMethod)).doubleValue();\n    } catch (NumberFormatException ex) {\n        if (Double.isInfinite(x)) {\n            return x;\n        } else {\n            return Double.NaN;\n        }\n    }\n}", "lc": -0.13636363636363635, "pi": 0.45933014354066987, "ma": -0.2, "nbd": 0.0, "ml": -0.16666666666666666, "d": -0.3650793650793651, "mi": 0.22085976039464428, "fo": -0.16666666666666666, "r": 0.0, "e": -0.16279340490885932}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1655_01a8b283", "label": 1, "code": "@Nullable\n@Override\npublic String apply(@Nullable DataIdentifier input) {\n    return input.toString();\n}", "code_comment": NaN, "code_no_comment": "@Nullable\n@Override\npublic String apply(@Nullable DataIdentifier input) {\n    return input.toString();\n}", "lc": -0.4090909090909091, "pi": -0.6650717703349284, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.7375616631430585, "fo": -0.4166666666666667, "r": 1.894736842105263, "e": -0.16279340490885932}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3630_fcd64766", "label": 3, "code": "@Override\npublic Aggregate getAggregate(NodeState matchedNodeState) {\n    return aggMapper.getAggregate(ConfigUtil.getPrimaryTypeName(matchedNodeState));\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic Aggregate getAggregate(NodeState matchedNodeState) {\n    return aggMapper.getAggregate(ConfigUtil.getPrimaryTypeName(matchedNodeState));\n}", "lc": -0.45454545454545453, "pi": -0.6028708133971293, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.8173361522198731, "fo": -0.3333333333333333, "r": 1.0526315789473684, "e": -0.16279340490885932}
{"project_name": "Compress", "project_version": 4, "label": 1, "code": "/**\n * Closes this output stream and releases any system resources\n * associated with the stream.\n *\n * @exception  IOException  if an I/O error occurs.\n */\npublic void close() throws IOException {\n    finish();\n    if (raf != null) {\n        raf.close();\n    }\n    if (out != null) {\n        out.close();\n    }\n}", "code_comment": "/**\n * Closes this output stream and releases any system resources\n * associated with the stream.\n *\n * @exception  IOException  if an I/O error occurs.\n */\n", "code_no_comment": "public void close() throws IOException {\n    finish();\n    if (raf != null) {\n        raf.close();\n    }\n    if (out != null) {\n        out.close();\n    }\n}", "lc": -0.22727272727272727, "pi": -0.15311004784689008, "ma": -0.2, "nbd": -0.5, "ml": -0.08333333333333333, "d": -0.3650793650793651, "mi": 0.4069062720225511, "fo": -0.25, "r": 2.552631578947368, "e": -0.16279340490885932}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-2487_f2920c26", "label": 0, "code": "/**\n * @return the current size of the buffer.\n */\npublic int getSize() {\n    if (this.value == null) {\n        throw new IllegalStateException(\"Uninitialized. Null constructor \" + \"called w/o accompanying readFields invocation\");\n    }\n    return this.value.length;\n}", "code_comment": "/**\n * @return the current size of the buffer.\n */\n", "code_no_comment": "public int getSize() {\n    if (this.value == null) {\n        throw new IllegalStateException(\"Uninitialized. Null constructor \" + \"called w/o accompanying readFields invocation\");\n    }\n    return this.value.length;\n}", "lc": -0.36363636363636365, "pi": -0.11483253588516758, "ma": -0.2, "nbd": -0.5, "ml": -0.25, "d": -0.14285714285714285, "mi": 0.6124031007751934, "fo": -0.5, "r": 2.5, "e": -0.14384029782795363}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1429_c2f5ca6c", "label": 1, "code": "private void diffFewChildren(JsopWriter w, DocumentNodeState.Children fromChildren, Revision fromRev, DocumentNodeState.Children toChildren, Revision toRev) {\n    Set<String> childrenSet = Sets.newHashSet(toChildren.children);\n    for (String n : fromChildren.children) {\n        if (!childrenSet.contains(n)) {\n            w.tag('-').value(n).newline();\n        } else {\n            DocumentNodeState n1 = getNode(n, fromRev);\n            DocumentNodeState n2 = getNode(n, toRev);\n            // this is not fully correct:\n            // a change is detected if the node changed recently,\n            // even if the revisions are well in the past\n            // if this is a problem it would need to be changed\n            checkNotNull(n1, \"Node at [%s] not found for fromRev [%s]\", n, fromRev);\n            checkNotNull(n2, \"Node at [%s] not found for toRev [%s]\", n, toRev);\n            if (!n1.getId().equals(n2.getId())) {\n                w.tag('^').key(n).object().endObject().newline();\n            }\n        }\n    }\n    childrenSet = Sets.newHashSet(fromChildren.children);\n    for (String n : toChildren.children) {\n        if (!childrenSet.contains(n)) {\n            w.tag('+').key(n).object().endObject().newline();\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "private void diffFewChildren(JsopWriter w, DocumentNodeState.Children fromChildren, Revision fromRev, DocumentNodeState.Children toChildren, Revision toRev) {\n    Set<String> childrenSet = Sets.newHashSet(toChildren.children);\n    for (String n : fromChildren.children) {\n        if (!childrenSet.contains(n)) {\n            w.tag('-').value(n).newline();\n        } else {\n            DocumentNodeState n1 = getNode(n, fromRev);\n            DocumentNodeState n2 = getNode(n, toRev);\n                                                            checkNotNull(n1, \"Node at [%s] not found for fromRev [%s]\", n, fromRev);\n            checkNotNull(n2, \"Node at [%s] not found for toRev [%s]\", n, toRev);\n            if (!n1.getId().equals(n2.getId())) {\n                w.tag('^').key(n).object().endObject().newline();\n            }\n        }\n    }\n    childrenSet = Sets.newHashSet(fromChildren.children);\n    for (String n : toChildren.children) {\n        if (!childrenSet.contains(n)) {\n            w.tag('+').key(n).object().endObject().newline();\n        }\n    }\n}", "lc": 0.36363636363636365, "pi": 0.650717703349282, "ma": 0.4, "nbd": 0.5, "ml": 0.16666666666666666, "d": 0.11507936507936505, "mi": -0.3818181818181818, "fo": 1.5, "r": -0.02631578947368421, "e": 0.38682825907804724}
{"project_name": "Lang", "project_version": 10, "label": 1, "code": "// Support for strategies\n// -----------------------------------------------------------------------\n/**\n * Escape constant fields into regular expression\n * @param regex The destination regex\n * @param value The source field\n * @param unquote If true, replace two success quotes ('') with single quote (')\n * @return The <code>StringBuilder</code>\n */\nprivate static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n    boolean wasWhite = false;\n    for (int i = 0; i < value.length(); ++i) {\n        char c = value.charAt(i);\n        if (Character.isWhitespace(c)) {\n            if (!wasWhite) {\n                wasWhite = true;\n                regex.append(\"\\\\s*+\");\n            }\n            continue;\n        }\n        wasWhite = false;\n        switch(c) {\n            case '\\'':\n                if (unquote) {\n                    if (++i == value.length()) {\n                        return regex;\n                    }\n                    c = value.charAt(i);\n                }\n                break;\n            case '?':\n            case '[':\n            case ']':\n            case '(':\n            case ')':\n            case '{':\n            case '}':\n            case '\\\\':\n            case '|':\n            case '*':\n            case '+':\n            case '^':\n            case '$':\n            case '.':\n                regex.append('\\\\');\n        }\n        regex.append(c);\n    }\n    return regex;\n}", "code_comment": "/**\n * Escape constant fields into regular expression\n * @param regex The destination regex\n * @param value The source field\n * @param unquote If true, replace two success quotes ('') with single quote (')\n * @return The <code>StringBuilder</code>\n */\n", "code_no_comment": "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n    boolean wasWhite = false;\n    for (int i = 0; i < value.length(); ++i) {\n        char c = value.charAt(i);\n        if (Character.isWhitespace(c)) {\n            if (!wasWhite) {\n                wasWhite = true;\n                regex.append(\"\\\\s*+\");\n            }\n            continue;\n        }\n        wasWhite = false;\n        switch(c) {\n            case '\\'':\n                if (unquote) {\n                    if (++i == value.length()) {\n                        return regex;\n                    }\n                    c = value.charAt(i);\n                }\n                break;\n            case '?':\n            case '[':\n            case ']':\n            case '(':\n            case ')':\n            case '{':\n            case '}':\n            case '\\\\':\n            case '|':\n            case '*':\n            case '+':\n            case '^':\n            case '$':\n            case '.':\n                regex.append('\\\\');\n        }\n        regex.append(c);\n    }\n    return regex;\n}", "lc": 1.2272727272727273, "pi": 1.0191387559808613, "ma": 3.8, "nbd": 1.5, "ml": 1.75, "d": 0.371031746031746, "mi": -0.7423537702607467, "fo": 0.16666666666666666, "r": -0.02631578947368421, "e": 0.5054476928130565}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-3740_f2f5bd5b", "label": 1, "code": "@Override\npublic void merge(W mergeResult, Collection<W> mergedWindows, W stateWindowResult, Collection<W> mergedStateWindows) throws Exception {\n    context.window = mergeResult;\n    // store for later use\n    mergeTriggerResult.f0 = context.onMerge(mergedWindows);\n    for (W m : mergedWindows) {\n        context.window = m;\n        context.clear();\n    }\n    // merge the merged state windows into the newly resulting state window\n    getStateBackend().mergePartitionedStates(stateWindowResult, mergedStateWindows, windowSerializer, (StateDescriptor<? extends MergingState<?, ?>, ?>) windowStateDescriptor);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void merge(W mergeResult, Collection<W> mergedWindows, W stateWindowResult, Collection<W> mergedStateWindows) throws Exception {\n    context.window = mergeResult;\n        mergeTriggerResult.f0 = context.onMerge(mergedWindows);\n    for (W m : mergedWindows) {\n        context.window = m;\n        context.clear();\n    }\n        getStateBackend().mergePartitionedStates(stateWindowResult, mergedStateWindows, windowSerializer, (StateDescriptor<? extends MergingState<?, ?>, ?>) windowStateDescriptor);\n}", "lc": -0.18181818181818182, "pi": -0.0909090909090911, "ma": -0.4, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.14559548978153644, "fo": -0.16666666666666666, "r": -0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-2802_88a97768", "label": 0, "code": "// ------------------------------------------------------------------------\n@Override\nprotected void run() throws Exception {\n    final String iterationId = configuration.getIterationId();\n    if (iterationId == null || iterationId.length() == 0) {\n        throw new Exception(\"Missing iteration ID in the task configuration\");\n    }\n    final String brokerID = createBrokerIdString(getEnvironment().getJobID(), iterationId, getEnvironment().getIndexInSubtaskGroup());\n    final long iterationWaitTime = configuration.getIterationWaitTime();\n    final boolean shouldWait = iterationWaitTime > 0;\n    final BlockingQueue<StreamRecord<OUT>> dataChannel = new ArrayBlockingQueue<StreamRecord<OUT>>(1);\n    // offer the queue for the tail\n    BlockingQueueBroker.INSTANCE.handIn(brokerID, dataChannel);\n    LOG.info(\"Iteration head {} added feedback queue under {}\", getName(), brokerID);\n    // do the work\n    try {\n        @SuppressWarnings(\"unchecked\")\n        Collection<RecordWriterOutput<OUT>> outputs = (Collection<RecordWriterOutput<OUT>>) (Collection<?>) outputHandler.getOutputs();\n        while (running) {\n            StreamRecord<OUT> nextRecord = shouldWait ? dataChannel.poll(iterationWaitTime, TimeUnit.MILLISECONDS) : dataChannel.take();\n            if (nextRecord != null) {\n                for (RecordWriterOutput<OUT> output : outputs) {\n                    output.collect(nextRecord);\n                }\n            } else {\n                // done\n                break;\n            }\n        }\n    } finally {\n        // make sure that we remove the queue from the broker, to prevent a resource leak\n        BlockingQueueBroker.INSTANCE.remove(brokerID);\n        LOG.info(\"Iteration head {} removed feedback queue under {}\", getName(), brokerID);\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\nprotected void run() throws Exception {\n    final String iterationId = configuration.getIterationId();\n    if (iterationId == null || iterationId.length() == 0) {\n        throw new Exception(\"Missing iteration ID in the task configuration\");\n    }\n    final String brokerID = createBrokerIdString(getEnvironment().getJobID(), iterationId, getEnvironment().getIndexInSubtaskGroup());\n    final long iterationWaitTime = configuration.getIterationWaitTime();\n    final boolean shouldWait = iterationWaitTime > 0;\n    final BlockingQueue<StreamRecord<OUT>> dataChannel = new ArrayBlockingQueue<StreamRecord<OUT>>(1);\n        BlockingQueueBroker.INSTANCE.handIn(brokerID, dataChannel);\n    LOG.info(\"Iteration head {} added feedback queue under {}\", getName(), brokerID);\n        try {\n        @SuppressWarnings(\"unchecked\")\n        Collection<RecordWriterOutput<OUT>> outputs = (Collection<RecordWriterOutput<OUT>>) (Collection<?>) outputHandler.getOutputs();\n        while (running) {\n            StreamRecord<OUT> nextRecord = shouldWait ? dataChannel.poll(iterationWaitTime, TimeUnit.MILLISECONDS) : dataChannel.take();\n            if (nextRecord != null) {\n                for (RecordWriterOutput<OUT> output : outputs) {\n                    output.collect(nextRecord);\n                }\n            } else {\n                                break;\n            }\n        }\n    } finally {\n                BlockingQueueBroker.INSTANCE.remove(brokerID);\n        LOG.info(\"Iteration head {} removed feedback queue under {}\", getName(), brokerID);\n    }\n}", "lc": 0.7272727272727273, "pi": 0.9952153110047848, "ma": 0.8, "nbd": 1.0, "ml": 0.4166666666666667, "d": 0.3412698412698413, "mi": -0.5610993657505284, "fo": 1.0, "r": -0.02631578947368421, "e": 0.7955809892636709}
{"project_name": "Closure", "project_version": 91, "label": 2, "code": "/**\n * Since this pass reports errors only when a global {@code this} keyword\n * is encountered, there is no reason to traverse non global contexts.\n */\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() == Token.FUNCTION) {\n        // Don't traverse functions that are constructors or have the @this\n        // or @override annotation.\n        JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.isInterface() || jsDoc.hasThisType() || jsDoc.isOverride())) {\n            return false;\n        }\n        // Don't traverse functions unless they would normally\n        // be able to have a @this annotation associated with them. e.g.,\n        // var a = function() { }; // or\n        // function a() {} // or\n        // a.x = function() {}; // or\n        // var a = {x: function() {}};\n        int pType = parent.getType();\n        if (!(pType == Token.BLOCK || pType == Token.SCRIPT || pType == Token.NAME || pType == Token.ASSIGN || // object literal keys\n        pType == Token.STRING || pType == Token.NUMBER)) {\n            return false;\n        }\n    // Don't traverse functions that are getting lent to a prototype.\n    }\n    if (parent != null && parent.getType() == Token.ASSIGN) {\n        Node lhs = parent.getFirstChild();\n        Node rhs = lhs.getNext();\n        if (n == lhs) {\n            // assignLhsChild should not be overridden.\n            if (assignLhsChild == null) {\n                assignLhsChild = lhs;\n            }\n        } else {\n            // property or subproperty.\n            if (NodeUtil.isGet(lhs)) {\n                if (lhs.getType() == Token.GETPROP && lhs.getLastChild().getString().equals(\"prototype\")) {\n                    return false;\n                }\n                Node llhs = lhs.getFirstChild();\n                if (llhs.getType() == Token.GETPROP && llhs.getLastChild().getString().equals(\"prototype\")) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}", "code_comment": "/**\n * Since this pass reports errors only when a global {@code this} keyword\n * is encountered, there is no reason to traverse non global contexts.\n */\n", "code_no_comment": "public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() == Token.FUNCTION) {\n                        JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.isInterface() || jsDoc.hasThisType() || jsDoc.isOverride())) {\n            return false;\n        }\n                                                        int pType = parent.getType();\n        if (!(pType == Token.BLOCK || pType == Token.SCRIPT || pType == Token.NAME || pType == Token.ASSIGN ||         pType == Token.STRING || pType == Token.NUMBER)) {\n            return false;\n        }\n        }\n    if (parent != null && parent.getType() == Token.ASSIGN) {\n        Node lhs = parent.getFirstChild();\n        Node rhs = lhs.getNext();\n        if (n == lhs) {\n                        if (assignLhsChild == null) {\n                assignLhsChild = lhs;\n            }\n        } else {\n                        if (NodeUtil.isGet(lhs)) {\n                if (lhs.getType() == Token.GETPROP && lhs.getLastChild().getString().equals(\"prototype\")) {\n                    return false;\n                }\n                Node llhs = lhs.getFirstChild();\n                if (llhs.getType() == Token.GETPROP && llhs.getLastChild().getString().equals(\"prototype\")) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}", "lc": 0.8636363636363636, "pi": 1.0239234449760766, "ma": 1.2, "nbd": 1.0, "ml": 2.75, "d": 1.0773809523809523, "mi": -0.6456659619450316, "fo": 1.1666666666666667, "r": -0.02631578947368421, "e": 2.2085533329875573}
{"project_name": "Lang", "project_version": 14, "label": 1, "code": "// Equals\n// -----------------------------------------------------------------------\n/**\n * <p>Compares two CharSequences, returning {@code true} if they represent\n * equal sequences of characters.</p>\n *\n * <p>{@code null}s are handled without exceptions. Two {@code null}\n * references are considered to be equal. The comparison is case sensitive.</p>\n *\n * <pre>\n * StringUtils.equals(null, null)   = true\n * StringUtils.equals(null, \"abc\")  = false\n * StringUtils.equals(\"abc\", null)  = false\n * StringUtils.equals(\"abc\", \"abc\") = true\n * StringUtils.equals(\"abc\", \"ABC\") = false\n * </pre>\n *\n * @see java.lang.CharSequence#equals(Object)\n * @param cs1  the first CharSequence, may be {@code null}\n * @param cs2  the second CharSequence, may be {@code null}\n * @return {@code true} if the CharSequences are equal (case-sensitive), or both {@code null}\n * @since 3.0 Changed signature from equals(String, String) to equals(CharSequence, CharSequence)\n */\npublic static boolean equals(CharSequence cs1, CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    return cs1.equals(cs2);\n}", "code_comment": "/**\n * <p>Compares two CharSequences, returning {@code true} if they represent\n * equal sequences of characters.</p>\n *\n * <p>{@code null}s are handled without exceptions. Two {@code null}\n * references are considered to be equal. The comparison is case sensitive.</p>\n *\n * <pre>\n * StringUtils.equals(null, null)   = true\n * StringUtils.equals(null, \"abc\")  = false\n * StringUtils.equals(\"abc\", null)  = false\n * StringUtils.equals(\"abc\", \"abc\") = true\n * StringUtils.equals(\"abc\", \"ABC\") = false\n * </pre>\n *\n * @see java.lang.CharSequence#equals(Object)\n * @param cs1  the first CharSequence, may be {@code null}\n * @param cs2  the second CharSequence, may be {@code null}\n * @return {@code true} if the CharSequences are equal (case-sensitive), or both {@code null}\n * @since 3.0 Changed signature from equals(String, String) to equals(CharSequence, CharSequence)\n */\n", "code_no_comment": "public static boolean equals(CharSequence cs1, CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    return cs1.equals(cs2);\n}", "lc": -0.22727272727272727, "pi": -0.15311004784689008, "ma": -0.2, "nbd": -0.5, "ml": 0.0, "d": 0.05555555555555556, "mi": 0.3324876673713883, "fo": -0.4166666666666667, "r": 0.02631578947368421, "e": -0.09444972712551072}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4066_4d3d1f85", "label": 1, "code": "public IRequestHandler mapRequest(Request request) {\n    InterceptData data = InterceptData.get();\n    if (data != null) {\n        if (data.originalUrl.equals(request.getOriginalUrl())) {\n            if (data.postParameters.isEmpty() == false && request.getPostParameters() instanceof IWritableRequestParameters) {\n                IWritableRequestParameters parameters = (IWritableRequestParameters) request.getPostParameters();\n                parameters.reset();\n                for (String s : data.postParameters.keySet()) {\n                    parameters.setParameterValues(s, data.postParameters.get(s));\n                }\n            }\n            InterceptData.clear();\n        }\n    }\n    return null;\n}", "code_comment": NaN, "code_no_comment": "public IRequestHandler mapRequest(Request request) {\n    InterceptData data = InterceptData.get();\n    if (data != null) {\n        if (data.originalUrl.equals(request.getOriginalUrl())) {\n            if (data.postParameters.isEmpty() == false && request.getPostParameters() instanceof IWritableRequestParameters) {\n                IWritableRequestParameters parameters = (IWritableRequestParameters) request.getPostParameters();\n                parameters.reset();\n                for (String s : data.postParameters.keySet()) {\n                    parameters.setParameterValues(s, data.postParameters.get(s));\n                }\n            }\n            InterceptData.clear();\n        }\n    }\n    return null;\n}", "lc": 0.09090909090909091, "pi": 1.5071770334928227, "ma": 0.2, "nbd": 1.0, "ml": 0.3333333333333333, "d": 0.37896825396825395, "mi": -0.12445384073291024, "fo": 0.4166666666666667, "r": -0.02631578947368421, "e": 0.2527734075598047}
{"project_name": "Closure", "project_version": 5, "label": 1, "code": "/**\n * Counts the number of direct (full) references to an object.\n * Specifically, we check for references of the following type:\n * <pre>\n *   x;\n *   x.fn();\n * </pre>\n */\nprivate boolean isInlinableObject(List<Reference> refs) {\n    boolean ret = false;\n    Set<String> validProperties = Sets.newHashSet();\n    for (Reference ref : refs) {\n        Node name = ref.getNode();\n        Node parent = ref.getParent();\n        Node gramps = ref.getGrandparent();\n        // \n        if (parent.isGetProp()) {\n            Preconditions.checkState(parent.getFirstChild() == name);\n            // A call target may be using the object as a 'this' value.\n            if (gramps.isCall() && gramps.getFirstChild() == parent) {\n                return false;\n            }\n            // Deleting a property has different semantics from deleting\n            // a variable, so deleted properties should not be inlined.\n            // NOTE(nicksantos): This pass's object-splitting algorithm has\n            // a blind spot. It assumes that if a property isn't defined on an\n            // object, then the value is undefined. This is not true, because\n            // Object.prototype can have arbitrary properties on it.\n            // \n            // We short-circuit this problem by bailing out if we see a reference\n            // to a property that isn't defined on the object literal. This\n            // isn't a perfect algorithm, but it should catch most cases.\n            String propName = parent.getLastChild().getString();\n            if (!validProperties.contains(propName)) {\n                if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {\n                    validProperties.add(propName);\n                } else {\n                    return false;\n                }\n            }\n            continue;\n        }\n        // Only rewrite VAR declarations or simple assignment statements\n        if (!isVarOrAssignExprLhs(name)) {\n            return false;\n        }\n        Node val = ref.getAssignedValue();\n        if (val == null) {\n            // A var with no assignment.\n            continue;\n        }\n        // We're looking for object literal assignments only.\n        if (!val.isObjectLit()) {\n            return false;\n        }\n        // Also, ES5 getters/setters aren't handled by this pass.\n        for (Node child = val.getFirstChild(); child != null; child = child.getNext()) {\n            if (child.isGetterDef() || child.isSetterDef()) {\n                // ES5 get/set not supported.\n                return false;\n            }\n            validProperties.add(child.getString());\n            Node childVal = child.getFirstChild();\n            // will happen.\n            for (Reference t : refs) {\n                Node refNode = t.getParent();\n                while (!NodeUtil.isStatementBlock(refNode)) {\n                    if (refNode == childVal) {\n                        // There's a self-referential assignment\n                        return false;\n                    }\n                    refNode = refNode.getParent();\n                }\n            }\n        }\n        // We have found an acceptable object literal assignment. As\n        // long as there are no other assignments that mess things up,\n        // we can inline.\n        ret = true;\n    }\n    return ret;\n}", "code_comment": "/**\n * Counts the number of direct (full) references to an object.\n * Specifically, we check for references of the following type:\n * <pre>\n *   x;\n *   x.fn();\n * </pre>\n */\n", "code_no_comment": "private boolean isInlinableObject(List<Reference> refs) {\n    boolean ret = false;\n    Set<String> validProperties = Sets.newHashSet();\n    for (Reference ref : refs) {\n        Node name = ref.getNode();\n        Node parent = ref.getParent();\n        Node gramps = ref.getGrandparent();\n                if (parent.isGetProp()) {\n            Preconditions.checkState(parent.getFirstChild() == name);\n                        if (gramps.isCall() && gramps.getFirstChild() == parent) {\n                return false;\n            }\n                                                                                                                                    String propName = parent.getLastChild().getString();\n            if (!validProperties.contains(propName)) {\n                if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {\n                    validProperties.add(propName);\n                } else {\n                    return false;\n                }\n            }\n            continue;\n        }\n                if (!isVarOrAssignExprLhs(name)) {\n            return false;\n        }\n        Node val = ref.getAssignedValue();\n        if (val == null) {\n                        continue;\n        }\n                if (!val.isObjectLit()) {\n            return false;\n        }\n                for (Node child = val.getFirstChild(); child != null; child = child.getNext()) {\n            if (child.isGetterDef() || child.isSetterDef()) {\n                                return false;\n            }\n            validProperties.add(child.getString());\n            Node childVal = child.getFirstChild();\n                        for (Reference t : refs) {\n                Node refNode = t.getParent();\n                while (!NodeUtil.isStatementBlock(refNode)) {\n                    if (refNode == childVal) {\n                                                return false;\n                    }\n                    refNode = refNode.getParent();\n                }\n            }\n        }\n                                ret = true;\n    }\n    return ret;\n}", "lc": 1.7272727272727273, "pi": 1.062200956937799, "ma": 2.4, "nbd": 1.5, "ml": 2.1666666666666665, "d": 1.0456349206349207, "mi": -0.9024665257223394, "fo": 1.75, "r": -0.02631578947368421, "e": 2.321958472363894}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3089_ba38c380", "label": 3, "code": "/**\n * Set the maximum memory this cache should use. This will not\n * immediately cause entries to get removed however; it will only change\n * the limit. To resize the internal array, call the clear method.\n *\n * @param maxMemory the maximum size (1 or larger)\n */\npublic void setMaxMemory(long maxMemory) {\n    if (maxMemory <= 0) {\n        throw new IllegalArgumentException(\"Max memory must be larger than 0\");\n    }\n    this.maxMemory = maxMemory;\n    if (segments != null) {\n        long max = 1 + maxMemory / segments.length;\n        for (Segment<K, V> s : segments) {\n            s.setMaxMemory(max);\n        }\n    }\n}", "code_comment": "/**\n * Set the maximum memory this cache should use. This will not\n * immediately cause entries to get removed however; it will only change\n * the limit. To resize the internal array, call the clear method.\n *\n * @param maxMemory the maximum size (1 or larger)\n */\n", "code_no_comment": "public void setMaxMemory(long maxMemory) {\n    if (maxMemory <= 0) {\n        throw new IllegalArgumentException(\"Max memory must be larger than 0\");\n    }\n    this.maxMemory = maxMemory;\n    if (segments != null) {\n        long max = 1 + maxMemory / segments.length;\n        for (Segment<K, V> s : segments) {\n            s.setMaxMemory(max);\n        }\n    }\n}", "lc": -0.09090909090909091, "pi": 0.1961722488038276, "ma": 0.2, "nbd": 0.0, "ml": -0.08333333333333333, "d": 0.2698412698412699, "mi": 0.09739252995066941, "fo": -0.4166666666666667, "r": 0.5526315789473684, "e": 0.028494205379114006}
{"project_name": "maven", "project_version": "remotes/origin/bugs-dot-jar_MNG-5212_c53d95ce", "label": 1, "code": "protected static PluginDescriptor clone(PluginDescriptor original) {\n    PluginDescriptor clone = null;\n    if (original != null) {\n        clone = new PluginDescriptor();\n        clone.setGroupId(original.getGroupId());\n        clone.setArtifactId(original.getArtifactId());\n        clone.setVersion(original.getVersion());\n        clone.setGoalPrefix(original.getGoalPrefix());\n        clone.setInheritedByDefault(original.isInheritedByDefault());\n        clone.setName(original.getName());\n        clone.setDescription(original.getDescription());\n        clone.setRequiredMavenVersion(original.getRequiredMavenVersion());\n        clone.setPluginArtifact(ArtifactUtils.copyArtifactSafe(original.getPluginArtifact()));\n        clone.setComponents(clone(original.getMojos(), clone));\n        clone.setId(original.getId());\n        clone.setIsolatedRealm(original.isIsolatedRealm());\n        clone.setSource(original.getSource());\n    }\n    return clone;\n}", "code_comment": NaN, "code_no_comment": "protected static PluginDescriptor clone(PluginDescriptor original) {\n    PluginDescriptor clone = null;\n    if (original != null) {\n        clone = new PluginDescriptor();\n        clone.setGroupId(original.getGroupId());\n        clone.setArtifactId(original.getArtifactId());\n        clone.setVersion(original.getVersion());\n        clone.setGoalPrefix(original.getGoalPrefix());\n        clone.setInheritedByDefault(original.isInheritedByDefault());\n        clone.setName(original.getName());\n        clone.setDescription(original.getDescription());\n        clone.setRequiredMavenVersion(original.getRequiredMavenVersion());\n        clone.setPluginArtifact(ArtifactUtils.copyArtifactSafe(original.getPluginArtifact()));\n        clone.setComponents(clone(original.getMojos(), clone));\n        clone.setId(original.getId());\n        clone.setIsolatedRealm(original.isIsolatedRealm());\n        clone.setSource(original.getSource());\n    }\n    return clone;\n}", "lc": 0.2727272727272727, "pi": -0.16267942583732073, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": 0.04960317460317456, "mi": -0.269908386187456, "fo": 1.8333333333333333, "r": -0.02631578947368421, "e": 0.19321242717103784}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-757_76b7413d", "label": 1, "code": "/**\n * Returns a hash code consistent with equals.\n *\n * @return the hash code representing this {@code ResizableDoubleArray}.\n * @since 2.0\n */\n@Override\npublic synchronized int hashCode() {\n    final int[] hashData = new int[6];\n    hashData[0] = Double.valueOf(expansionFactor).hashCode();\n    hashData[1] = Double.valueOf(contractionCriterion).hashCode();\n    hashData[2] = expansionMode.hashCode();\n    hashData[3] = Arrays.hashCode(internalArray);\n    hashData[4] = numElements;\n    hashData[5] = startIndex;\n    return Arrays.hashCode(hashData);\n}", "code_comment": "/**\n * Returns a hash code consistent with equals.\n *\n * @return the hash code representing this {@code ResizableDoubleArray}.\n * @since 2.0\n */\n", "code_no_comment": "@Override\npublic synchronized int hashCode() {\n    final int[] hashData = new int[6];\n    hashData[0] = Double.valueOf(expansionFactor).hashCode();\n    hashData[1] = Double.valueOf(contractionCriterion).hashCode();\n    hashData[2] = expansionMode.hashCode();\n    hashData[3] = Arrays.hashCode(internalArray);\n    hashData[4] = numElements;\n    hashData[5] = startIndex;\n    return Arrays.hashCode(hashData);\n}", "lc": -0.13636363636363635, "pi": -0.5789473684210528, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.11120507399577186, "fo": 0.08333333333333333, "r": 0.2631578947368421, "e": -0.16279340490885932}
{"project_name": "Closure", "project_version": 45, "label": 1, "code": "/**\n * Look at all the property assigns to all variables.\n * These may or may not count as references. For example,\n *\n * <code>\n * var x = {};\n * x.foo = 3; // not a reference.\n * var y = foo();\n * y.foo = 3; // is a reference.\n * </code>\n *\n * Interpreting assignments could mark a variable as referenced that\n * wasn't referenced before, in order to keep it alive. Because we find\n * references by lazily traversing subtrees, marking a variable as\n * referenced could trigger new traversals of new subtrees, which could\n * find new references.\n *\n * Therefore, this interpretation needs to be run to a fixed point.\n */\nprivate void interpretAssigns() {\n    boolean changes = false;\n    do {\n        changes = false;\n        // we traverse it.\n        for (int current = 0; current < maybeUnreferenced.size(); current++) {\n            Var var = maybeUnreferenced.get(current);\n            if (referenced.contains(var)) {\n                maybeUnreferenced.remove(current);\n                current--;\n            } else {\n                boolean assignedToUnknownValue = false;\n                boolean hasPropertyAssign = false;\n                if (var.getParentNode().isVar() && !NodeUtil.isForIn(var.getParentNode().getParent())) {\n                    Node value = var.getInitialValue();\n                    assignedToUnknownValue = value != null && !NodeUtil.isLiteralValue(value, true);\n                } else {\n                    // This was initialized to a function arg or a catch param\n                    // or a for...in variable.\n                    assignedToUnknownValue = true;\n                }\n                for (Assign assign : assignsByVar.get(var)) {\n                    if (assign.isPropertyAssign) {\n                        hasPropertyAssign = true;\n                    } else if (!NodeUtil.isLiteralValue(assign.assignNode.getLastChild(), true)) {\n                        assignedToUnknownValue = true;\n                    }\n                }\n                if (assignedToUnknownValue && hasPropertyAssign) {\n                    changes = markReferencedVar(var) || changes;\n                    maybeUnreferenced.remove(current);\n                    current--;\n                }\n            }\n        }\n    } while (changes);\n}", "code_comment": "/**\n * Look at all the property assigns to all variables.\n * These may or may not count as references. For example,\n *\n * <code>\n * var x = {};\n * x.foo = 3; // not a reference.\n * var y = foo();\n * y.foo = 3; // is a reference.\n * </code>\n *\n * Interpreting assignments could mark a variable as referenced that\n * wasn't referenced before, in order to keep it alive. Because we find\n * references by lazily traversing subtrees, marking a variable as\n * referenced could trigger new traversals of new subtrees, which could\n * find new references.\n *\n * Therefore, this interpretation needs to be run to a fixed point.\n */\n", "code_no_comment": "private void interpretAssigns() {\n    boolean changes = false;\n    do {\n        changes = false;\n                for (int current = 0; current < maybeUnreferenced.size(); current++) {\n            Var var = maybeUnreferenced.get(current);\n            if (referenced.contains(var)) {\n                maybeUnreferenced.remove(current);\n                current--;\n            } else {\n                boolean assignedToUnknownValue = false;\n                boolean hasPropertyAssign = false;\n                if (var.getParentNode().isVar() && !NodeUtil.isForIn(var.getParentNode().getParent())) {\n                    Node value = var.getInitialValue();\n                    assignedToUnknownValue = value != null && !NodeUtil.isLiteralValue(value, true);\n                } else {\n                                                            assignedToUnknownValue = true;\n                }\n                for (Assign assign : assignsByVar.get(var)) {\n                    if (assign.isPropertyAssign) {\n                        hasPropertyAssign = true;\n                    } else if (!NodeUtil.isLiteralValue(assign.assignNode.getLastChild(), true)) {\n                        assignedToUnknownValue = true;\n                    }\n                }\n                if (assignedToUnknownValue && hasPropertyAssign) {\n                    changes = markReferencedVar(var) || changes;\n                    maybeUnreferenced.remove(current);\n                    current--;\n                }\n            }\n        }\n    } while (changes);\n}", "lc": 0.9090909090909091, "pi": 1.6172248803827751, "ma": 1.0, "nbd": 2.0, "ml": 1.4166666666666667, "d": 1.4325396825396826, "mi": -0.6146582100070469, "fo": 0.8333333333333334, "r": -0.02631578947368421, "e": 2.1117869100926097}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1270_70564c7c", "label": 1, "code": "@Override\npublic boolean visit(FullTextOr or) {\n    BooleanQuery q = new BooleanQuery();\n    for (FullTextExpression e : or.list) {\n        Query x = getFullTextQuery(e, analyzer);\n        q.add(x, SHOULD);\n    }\n    result.set(q);\n    return true;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean visit(FullTextOr or) {\n    BooleanQuery q = new BooleanQuery();\n    for (FullTextExpression e : or.list) {\n        Query x = getFullTextQuery(e, analyzer);\n        q.add(x, SHOULD);\n    }\n    result.set(q);\n    return true;\n}", "lc": -0.18181818181818182, "pi": -0.0909090909090911, "ma": -0.4, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.2155038759689921, "fo": -0.25, "r": 0.6842105263157895, "e": -0.16279340490885932}
{"project_name": "Lang", "project_version": 49, "label": 1, "code": "// Calculations\n// -------------------------------------------------------------------\n/**\n * <p>Reduce the fraction to the smallest values for the numerator and\n * denominator, returning the result.</p>\n *\n * <p>For example, if this fraction represents 2/4, then the result\n * will be 1/2.</p>\n *\n * @return a new reduced fraction instance, or this if no simplification possible\n */\npublic Fraction reduce() {\n    int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);\n    if (gcd == 1) {\n        return this;\n    }\n    return Fraction.getFraction(numerator / gcd, denominator / gcd);\n}", "code_comment": "/**\n * <p>Reduce the fraction to the smallest values for the numerator and\n * denominator, returning the result.</p>\n *\n * <p>For example, if this fraction represents 2/4, then the result\n * will be 1/2.</p>\n *\n * @return a new reduced fraction instance, or this if no simplification possible\n */\n", "code_no_comment": "public Fraction reduce() {\n    int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);\n    if (gcd == 1) {\n        return this;\n    }\n    return Fraction.getFraction(numerator / gcd, denominator / gcd);\n}", "lc": -0.3181818181818182, "pi": -0.20574162679425848, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": -0.05753968253968254, "mi": 0.4336856941508105, "fo": -0.25, "r": 1.9473684210526316, "e": -0.10582343550999003}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-6667_1fc7bd7a", "label": 1, "code": "protected boolean process(final Exchange exchange, final AsyncCallback callback, final AtomicInteger index, final AtomicInteger count) {\n    // set current index as property\n    LOG.debug(\"LoopProcessor: iteration #{}\", index.get());\n    exchange.setProperty(Exchange.LOOP_INDEX, index.get());\n    boolean sync = processor.process(exchange, new AsyncCallback() {\n\n        public void done(boolean doneSync) {\n            // we only have to handle async completion of the routing slip\n            if (doneSync) {\n                return;\n            }\n            Exchange target = exchange;\n            // increment index as we have just processed once\n            index.getAndIncrement();\n            // continue looping asynchronously\n            while (index.get() < count.get()) {\n                // and prepare for next iteration\n                target = prepareExchange(exchange, index.get());\n                // process again\n                boolean sync = process(target, callback, index, count);\n                if (!sync) {\n                    LOG.trace(\"Processing exchangeId: {} is continued being processed asynchronously\", target.getExchangeId());\n                    // so we break out now, then the callback will be invoked which then continue routing from where we left here\n                    return;\n                }\n                // increment counter before next loop\n                index.getAndIncrement();\n            }\n            // we are done so prepare the result\n            ExchangeHelper.copyResults(exchange, target);\n            LOG.trace(\"Processing complete for exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\n            callback.done(false);\n        }\n    });\n    return sync;\n}", "code_comment": NaN, "code_no_comment": "protected boolean process(final Exchange exchange, final AsyncCallback callback, final AtomicInteger index, final AtomicInteger count) {\n        LOG.debug(\"LoopProcessor: iteration #{}\", index.get());\n    exchange.setProperty(Exchange.LOOP_INDEX, index.get());\n    boolean sync = processor.process(exchange, new AsyncCallback() {\n\n        public void done(boolean doneSync) {\n                        if (doneSync) {\n                return;\n            }\n            Exchange target = exchange;\n                        index.getAndIncrement();\n                        while (index.get() < count.get()) {\n                                target = prepareExchange(exchange, index.get());\n                                boolean sync = process(target, callback, index, count);\n                if (!sync) {\n                    LOG.trace(\"Processing exchangeId: {} is continued being processed asynchronously\", target.getExchangeId());\n                                        return;\n                }\n                                index.getAndIncrement();\n            }\n                        ExchangeHelper.copyResults(exchange, target);\n            LOG.trace(\"Processing complete for exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\n            callback.done(false);\n        }\n    });\n    return sync;\n}", "lc": 0.5454545454545454, "pi": 1.263157894736842, "ma": 0.0, "nbd": 0.5, "ml": 0.16666666666666666, "d": 0.12103174603174605, "mi": -0.4088794926004226, "fo": 1.0, "r": -0.02631578947368421, "e": 0.2717726180391072}
{"project_name": "maven", "project_version": "remotes/origin/bugs-dot-jar_MNG-2221_cc859f5c", "label": 0, "code": "public static void mergePluginLists(PluginContainer childContainer, PluginContainer parentContainer, boolean handleAsInheritance) {\n    if (childContainer == null || parentContainer == null) {\n        // nothing to do.\n        return;\n    }\n    List mergedPlugins = new ArrayList();\n    List parentPlugins = parentContainer.getPlugins();\n    if (parentPlugins != null && !parentPlugins.isEmpty()) {\n        Map assembledPlugins = new TreeMap();\n        Map childPlugins = childContainer.getPluginsAsMap();\n        for (Iterator it = parentPlugins.iterator(); it.hasNext(); ) {\n            Plugin parentPlugin = (Plugin) it.next();\n            String parentInherited = parentPlugin.getInherited();\n            if (!handleAsInheritance || parentInherited == null || Boolean.valueOf(parentInherited).booleanValue()) {\n                Plugin assembledPlugin = parentPlugin;\n                Plugin childPlugin = (Plugin) childPlugins.get(parentPlugin.getKey());\n                if (childPlugin != null) {\n                    assembledPlugin = childPlugin;\n                    mergePluginDefinitions(childPlugin, parentPlugin, handleAsInheritance);\n                }\n                if (handleAsInheritance && parentInherited == null) {\n                    assembledPlugin.unsetInheritanceApplied();\n                }\n                mergedPlugins.add(assembledPlugin);\n            }\n        }\n        // since assembledPlugins is never updated and remains empty.\n        for (Iterator it = childPlugins.values().iterator(); it.hasNext(); ) {\n            Plugin childPlugin = (Plugin) it.next();\n            if (!assembledPlugins.containsKey(childPlugin.getKey())) {\n                mergedPlugins.add(childPlugin);\n            }\n        }\n        childContainer.setPlugins(mergedPlugins);\n        childContainer.flushPluginMap();\n    }\n}", "code_comment": NaN, "code_no_comment": "public static void mergePluginLists(PluginContainer childContainer, PluginContainer parentContainer, boolean handleAsInheritance) {\n    if (childContainer == null || parentContainer == null) {\n                return;\n    }\n    List mergedPlugins = new ArrayList();\n    List parentPlugins = parentContainer.getPlugins();\n    if (parentPlugins != null && !parentPlugins.isEmpty()) {\n        Map assembledPlugins = new TreeMap();\n        Map childPlugins = childContainer.getPluginsAsMap();\n        for (Iterator it = parentPlugins.iterator(); it.hasNext(); ) {\n            Plugin parentPlugin = (Plugin) it.next();\n            String parentInherited = parentPlugin.getInherited();\n            if (!handleAsInheritance || parentInherited == null || Boolean.valueOf(parentInherited).booleanValue()) {\n                Plugin assembledPlugin = parentPlugin;\n                Plugin childPlugin = (Plugin) childPlugins.get(parentPlugin.getKey());\n                if (childPlugin != null) {\n                    assembledPlugin = childPlugin;\n                    mergePluginDefinitions(childPlugin, parentPlugin, handleAsInheritance);\n                }\n                if (handleAsInheritance && parentInherited == null) {\n                    assembledPlugin.unsetInheritanceApplied();\n                }\n                mergedPlugins.add(assembledPlugin);\n            }\n        }\n                for (Iterator it = childPlugins.values().iterator(); it.hasNext(); ) {\n            Plugin childPlugin = (Plugin) it.next();\n            if (!assembledPlugins.containsKey(childPlugin.getKey())) {\n                mergedPlugins.add(childPlugin);\n            }\n        }\n        childContainer.setPlugins(mergedPlugins);\n        childContainer.flushPluginMap();\n    }\n}", "lc": 0.9545454545454546, "pi": 1.200956937799043, "ma": 1.0, "nbd": 1.0, "ml": 1.5833333333333333, "d": 1.0654761904761905, "mi": -0.6665257223396756, "fo": 1.4166666666666667, "r": -0.02631578947368421, "e": 2.1963267117327385}
{"project_name": "Closure", "project_version": 132, "label": 2, "code": "/**\n * Try turning IF nodes into smaller HOOKs\n *\n * Returns the replacement for n or the original if no replacement was\n * necessary.\n */\nprivate Node tryMinimizeIf(Node n) {\n    Node parent = n.getParent();\n    Node cond = n.getFirstChild();\n    /* If the condition is a literal, we'll let other\n     * optimizations try to remove useless code.\n     */\n    if (NodeUtil.isLiteralValue(cond, true)) {\n        return n;\n    }\n    Node thenBranch = cond.getNext();\n    Node elseBranch = thenBranch.getNext();\n    if (elseBranch == null) {\n        if (isFoldableExpressBlock(thenBranch)) {\n            Node expr = getBlockExpression(thenBranch);\n            if (!late && isPropertyAssignmentInExpression(expr)) {\n                // until CollapseProperties has been run.\n                return n;\n            }\n            if (cond.isNot()) {\n                // if(!x)bar(); -> x||bar();\n                if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), OR_PRECEDENCE)) {\n                    // It's not okay to add two sets of parentheses.\n                    return n;\n                }\n                Node or = IR.or(cond.removeFirstChild(), expr.removeFirstChild()).srcref(n);\n                Node newExpr = NodeUtil.newExpr(or);\n                parent.replaceChild(n, newExpr);\n                reportCodeChange();\n                return newExpr;\n            }\n            // if(x)foo(); -> x&&foo();\n            if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), AND_PRECEDENCE)) {\n                // we can further optimize its parent.\n                return n;\n            }\n            n.removeChild(cond);\n            Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n            Node newExpr = NodeUtil.newExpr(and);\n            parent.replaceChild(n, newExpr);\n            reportCodeChange();\n            return newExpr;\n        } else {\n            // Try to combine two IF-ELSE\n            if (NodeUtil.isStatementBlock(thenBranch) && thenBranch.hasOneChild()) {\n                Node innerIf = thenBranch.getFirstChild();\n                if (innerIf.isIf()) {\n                    Node innerCond = innerIf.getFirstChild();\n                    Node innerThenBranch = innerCond.getNext();\n                    Node innerElseBranch = innerThenBranch.getNext();\n                    if (innerElseBranch == null && !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n                        n.detachChildren();\n                        n.addChildToBack(IR.and(cond, innerCond.detachFromParent()).srcref(cond));\n                        n.addChildrenToBack(innerThenBranch.detachFromParent());\n                        reportCodeChange();\n                        // the inner IF-ELSE wasn't able to be folded into && anyways.\n                        return n;\n                    }\n                }\n            }\n        }\n        return n;\n    }\n    /* TODO(dcc) This modifies the siblings of n, which is undesirable for a\n     * peephole optimization. This should probably get moved to another pass.\n     */\n    tryRemoveRepeatedStatements(n);\n    // An additional set of curly braces isn't worth it.\n    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n        n.replaceChild(cond, cond.removeFirstChild());\n        n.removeChild(thenBranch);\n        n.addChildToBack(thenBranch);\n        reportCodeChange();\n        return n;\n    }\n    // if(x)return 1;else return 2; -> return x?1:2;\n    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n        Node thenExpr = getBlockReturnExpression(thenBranch);\n        Node elseExpr = getBlockReturnExpression(elseBranch);\n        n.removeChild(cond);\n        thenExpr.detachFromParent();\n        elseExpr.detachFromParent();\n        // note - we ignore any cases with \"return;\", technically this\n        // can be converted to \"return undefined;\" or some variant, but\n        // that does not help code size.\n        Node returnNode = IR.returnNode(IR.hook(cond, thenExpr, elseExpr).srcref(n));\n        parent.replaceChild(n, returnNode);\n        reportCodeChange();\n        return returnNode;\n    }\n    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n        Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n        Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n        if (thenOp.getType() == elseOp.getType()) {\n            // if(x)a=1;else a=2; -> a=x?1:2;\n            if (NodeUtil.isAssignmentOp(thenOp)) {\n                Node lhs = thenOp.getFirstChild();\n                if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && // proceed even if there are side effects...\n                !mayEffectMutableState(lhs)) {\n                    n.removeChild(cond);\n                    Node assignName = thenOp.removeFirstChild();\n                    Node thenExpr = thenOp.removeFirstChild();\n                    Node elseExpr = elseOp.getLastChild();\n                    elseOp.removeChild(elseExpr);\n                    Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n                    Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp);\n                    Node expr = NodeUtil.newExpr(assign);\n                    parent.replaceChild(n, expr);\n                    reportCodeChange();\n                    return expr;\n                }\n            }\n        }\n        // if(x)foo();else bar(); -> x?foo():bar()\n        n.removeChild(cond);\n        thenOp.detachFromParent();\n        elseOp.detachFromParent();\n        Node expr = IR.exprResult(IR.hook(cond, thenOp, elseOp).srcref(n));\n        parent.replaceChild(n, expr);\n        reportCodeChange();\n        return expr;\n    }\n    boolean thenBranchIsVar = isVarBlock(thenBranch);\n    boolean elseBranchIsVar = isVarBlock(elseBranch);\n    // if(x)var y=1;else y=2  ->  var y=x?1:2\n    if (thenBranchIsVar && elseBranchIsExpressionBlock && getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n        Node var = getBlockVar(thenBranch);\n        Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n        Node name1 = var.getFirstChild();\n        Node maybeName2 = elseAssign.getFirstChild();\n        if (name1.hasChildren() && maybeName2.isName() && name1.getString().equals(maybeName2.getString())) {\n            Node thenExpr = name1.removeChildren();\n            Node elseExpr = elseAssign.getLastChild().detachFromParent();\n            cond.detachFromParent();\n            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n            var.detachFromParent();\n            name1.addChildrenToBack(hookNode);\n            parent.replaceChild(n, var);\n            reportCodeChange();\n            return var;\n        }\n    // if(x)y=1;else var y=2  ->  var y=x?1:2\n    } else if (elseBranchIsVar && thenBranchIsExpressionBlock && getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n        Node var = getBlockVar(elseBranch);\n        Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n        Node maybeName1 = thenAssign.getFirstChild();\n        Node name2 = var.getFirstChild();\n        if (name2.hasChildren() && maybeName1.isName() && maybeName1.getString().equals(name2.getString())) {\n            Node thenExpr = thenAssign.getLastChild().detachFromParent();\n            Node elseExpr = name2.removeChildren();\n            cond.detachFromParent();\n            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n            var.detachFromParent();\n            name2.addChildrenToBack(hookNode);\n            parent.replaceChild(n, var);\n            reportCodeChange();\n            return var;\n        }\n    }\n    return n;\n}", "code_comment": "/**\n * Try turning IF nodes into smaller HOOKs\n *\n * Returns the replacement for n or the original if no replacement was\n * necessary.\n */\n", "code_no_comment": "private Node tryMinimizeIf(Node n) {\n    Node parent = n.getParent();\n    Node cond = n.getFirstChild();\n        if (NodeUtil.isLiteralValue(cond, true)) {\n        return n;\n    }\n    Node thenBranch = cond.getNext();\n    Node elseBranch = thenBranch.getNext();\n    if (elseBranch == null) {\n        if (isFoldableExpressBlock(thenBranch)) {\n            Node expr = getBlockExpression(thenBranch);\n            if (!late && isPropertyAssignmentInExpression(expr)) {\n                                return n;\n            }\n            if (cond.isNot()) {\n                                if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), OR_PRECEDENCE)) {\n                                        return n;\n                }\n                Node or = IR.or(cond.removeFirstChild(), expr.removeFirstChild()).srcref(n);\n                Node newExpr = NodeUtil.newExpr(or);\n                parent.replaceChild(n, newExpr);\n                reportCodeChange();\n                return newExpr;\n            }\n                        if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), AND_PRECEDENCE)) {\n                                return n;\n            }\n            n.removeChild(cond);\n            Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n            Node newExpr = NodeUtil.newExpr(and);\n            parent.replaceChild(n, newExpr);\n            reportCodeChange();\n            return newExpr;\n        } else {\n                        if (NodeUtil.isStatementBlock(thenBranch) && thenBranch.hasOneChild()) {\n                Node innerIf = thenBranch.getFirstChild();\n                if (innerIf.isIf()) {\n                    Node innerCond = innerIf.getFirstChild();\n                    Node innerThenBranch = innerCond.getNext();\n                    Node innerElseBranch = innerThenBranch.getNext();\n                    if (innerElseBranch == null && !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n                        n.detachChildren();\n                        n.addChildToBack(IR.and(cond, innerCond.detachFromParent()).srcref(cond));\n                        n.addChildrenToBack(innerThenBranch.detachFromParent());\n                        reportCodeChange();\n                                                return n;\n                    }\n                }\n            }\n        }\n        return n;\n    }\n        tryRemoveRepeatedStatements(n);\n        if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n        n.replaceChild(cond, cond.removeFirstChild());\n        n.removeChild(thenBranch);\n        n.addChildToBack(thenBranch);\n        reportCodeChange();\n        return n;\n    }\n        if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n        Node thenExpr = getBlockReturnExpression(thenBranch);\n        Node elseExpr = getBlockReturnExpression(elseBranch);\n        n.removeChild(cond);\n        thenExpr.detachFromParent();\n        elseExpr.detachFromParent();\n                                Node returnNode = IR.returnNode(IR.hook(cond, thenExpr, elseExpr).srcref(n));\n        parent.replaceChild(n, returnNode);\n        reportCodeChange();\n        return returnNode;\n    }\n    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n        Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n        Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n        if (thenOp.getType() == elseOp.getType()) {\n                        if (NodeUtil.isAssignmentOp(thenOp)) {\n                Node lhs = thenOp.getFirstChild();\n                if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&                 !mayEffectMutableState(lhs)) {\n                    n.removeChild(cond);\n                    Node assignName = thenOp.removeFirstChild();\n                    Node thenExpr = thenOp.removeFirstChild();\n                    Node elseExpr = elseOp.getLastChild();\n                    elseOp.removeChild(elseExpr);\n                    Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n                    Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp);\n                    Node expr = NodeUtil.newExpr(assign);\n                    parent.replaceChild(n, expr);\n                    reportCodeChange();\n                    return expr;\n                }\n            }\n        }\n                n.removeChild(cond);\n        thenOp.detachFromParent();\n        elseOp.detachFromParent();\n        Node expr = IR.exprResult(IR.hook(cond, thenOp, elseOp).srcref(n));\n        parent.replaceChild(n, expr);\n        reportCodeChange();\n        return expr;\n    }\n    boolean thenBranchIsVar = isVarBlock(thenBranch);\n    boolean elseBranchIsVar = isVarBlock(elseBranch);\n        if (thenBranchIsVar && elseBranchIsExpressionBlock && getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n        Node var = getBlockVar(thenBranch);\n        Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n        Node name1 = var.getFirstChild();\n        Node maybeName2 = elseAssign.getFirstChild();\n        if (name1.hasChildren() && maybeName2.isName() && name1.getString().equals(maybeName2.getString())) {\n            Node thenExpr = name1.removeChildren();\n            Node elseExpr = elseAssign.getLastChild().detachFromParent();\n            cond.detachFromParent();\n            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n            var.detachFromParent();\n            name1.addChildrenToBack(hookNode);\n            parent.replaceChild(n, var);\n            reportCodeChange();\n            return var;\n        }\n        } else if (elseBranchIsVar && thenBranchIsExpressionBlock && getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n        Node var = getBlockVar(elseBranch);\n        Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n        Node maybeName1 = thenAssign.getFirstChild();\n        Node name2 = var.getFirstChild();\n        if (name2.hasChildren() && maybeName1.isName() && maybeName1.getString().equals(name2.getString())) {\n            Node thenExpr = thenAssign.getLastChild().detachFromParent();\n            Node elseExpr = name2.removeChildren();\n            cond.detachFromParent();\n            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n            var.detachFromParent();\n            name2.addChildrenToBack(hookNode);\n            parent.replaceChild(n, var);\n            reportCodeChange();\n            return var;\n        }\n    }\n    return n;\n}", "lc": 5.7272727272727275, "pi": 1.2535885167464116, "ma": 3.4, "nbd": 1.5, "ml": 6.5, "d": 1.751984126984127, "mi": -1.6015503875968988, "fo": 11.75, "r": -0.02631578947368421, "e": 15.945019392241946}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3563_c62b66c1", "label": 1, "code": "/**\n *  Processes components added to the target. This involves attaching components, rendering\n *  markup into a client side xml envelope, and detaching them\n *\n *  @param response\n */\nprivate void respondComponents(Response response) {\n    // process component markup\n    for (Map.Entry<String, Component> stringComponentEntry : markupIdToComponent.entrySet()) {\n        final Component component = stringComponentEntry.getValue();\n        if (!containsAncestorFor(component)) {\n            respondComponent(response, getAjaxRegionMarkupId(component), component);\n        }\n    }\n    if (header != null) {\n        // some header responses buffer all calls to render*** until close is called.\n        // when they are closed, they do something (i.e. aggregate all JS resource urls to a\n        // single url), and then \"flush\" (by writing to the real response) before closing.\n        // to support this, we need to allow header contributions to be written in the close\n        // tag, which we do here:\n        headerRendering = true;\n        // save old response, set new\n        Response oldResponse = RequestCycle.get().setResponse(encodingHeaderResponse);\n        encodingHeaderResponse.reset();\n        // now, close the response (which may render things)\n        header.getHeaderResponse().close();\n        // revert to old response\n        RequestCycle.get().setResponse(oldResponse);\n        // write the XML tags and we're done\n        writeHeaderContribution(response);\n        headerRendering = false;\n    }\n}", "code_comment": "/**\n *  Processes components added to the target. This involves attaching components, rendering\n *  markup into a client side xml envelope, and detaching them\n *\n *  @param response\n */\n", "code_no_comment": "private void respondComponents(Response response) {\n        for (Map.Entry<String, Component> stringComponentEntry : markupIdToComponent.entrySet()) {\n        final Component component = stringComponentEntry.getValue();\n        if (!containsAncestorFor(component)) {\n            respondComponent(response, getAjaxRegionMarkupId(component), component);\n        }\n    }\n    if (header != null) {\n                                                headerRendering = true;\n                Response oldResponse = RequestCycle.get().setResponse(encodingHeaderResponse);\n        encodingHeaderResponse.reset();\n                header.getHeaderResponse().close();\n                RequestCycle.get().setResponse(oldResponse);\n                writeHeaderContribution(response);\n        headerRendering = false;\n    }\n}", "lc": 0.13636363636363635, "pi": 0.04784688995215294, "ma": 0.0, "nbd": 0.0, "ml": 0.0, "d": -0.06746031746031747, "mi": -0.1557434813248768, "fo": 0.5833333333333334, "r": -0.02631578947368421, "e": 0.015119609504215557}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-2874_17e7b423", "label": 3, "code": "/**\n *  Checks if the given field is a valid pojo field:\n *  - it is public\n *  OR\n *   - there are getter and setter methods for the field.\n *\n *  @param f field to check\n *  @param clazz class of field\n *  @param typeHierarchy type hierarchy for materializing generic types\n */\nprivate boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy) {\n    if (Modifier.isPublic(f.getModifiers())) {\n        return true;\n    } else {\n        boolean hasGetter = false, hasSetter = false;\n        final String fieldNameLow = f.getName().toLowerCase();\n        Type fieldType = f.getGenericType();\n        TypeVariable<?> fieldTypeGeneric = null;\n        if (fieldType instanceof TypeVariable) {\n            fieldTypeGeneric = (TypeVariable<?>) fieldType;\n            fieldType = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) fieldType);\n        }\n        for (Method m : clazz.getMethods()) {\n            // check for getter\n            if (// The name should be \"get<FieldName>\" or \"<fieldName>\" (for scala) or \"is<fieldName>\" for boolean fields.\n            (m.getName().toLowerCase().equals(\"get\" + fieldNameLow) || m.getName().toLowerCase().equals(\"is\" + fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow)) && // no arguments for the getter\n            m.getParameterTypes().length == 0 && // return type is same as field type (or the generic variant of it)\n            (m.getGenericReturnType().equals(fieldType) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)))) {\n                if (hasGetter) {\n                    throw new IllegalStateException(\"Detected more than one getter\");\n                }\n                hasGetter = true;\n            }\n            // check for setters (<FieldName>_$eq for scala)\n            if ((m.getName().toLowerCase().equals(\"set\" + fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow + \"_$eq\")) && // one parameter of the field's type\n            m.getParameterTypes().length == 1 && (m.getGenericParameterTypes()[0].equals(fieldType) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric))) && // return type is void.\n            m.getReturnType().equals(Void.TYPE)) {\n                if (hasSetter) {\n                    throw new IllegalStateException(\"Detected more than one setter\");\n                }\n                hasSetter = true;\n            }\n        }\n        if (hasGetter && hasSetter) {\n            return true;\n        } else {\n            if (!hasGetter) {\n                LOG.debug(clazz + \" does not contain a getter for field \" + f.getName());\n            }\n            if (!hasSetter) {\n                LOG.debug(clazz + \" does not contain a setter for field \" + f.getName());\n            }\n            return false;\n        }\n    }\n}", "code_comment": "/**\n *  Checks if the given field is a valid pojo field:\n *  - it is public\n *  OR\n *   - there are getter and setter methods for the field.\n *\n *  @param f field to check\n *  @param clazz class of field\n *  @param typeHierarchy type hierarchy for materializing generic types\n */\n", "code_no_comment": "private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy) {\n    if (Modifier.isPublic(f.getModifiers())) {\n        return true;\n    } else {\n        boolean hasGetter = false, hasSetter = false;\n        final String fieldNameLow = f.getName().toLowerCase();\n        Type fieldType = f.getGenericType();\n        TypeVariable<?> fieldTypeGeneric = null;\n        if (fieldType instanceof TypeVariable) {\n            fieldTypeGeneric = (TypeVariable<?>) fieldType;\n            fieldType = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) fieldType);\n        }\n        for (Method m : clazz.getMethods()) {\n                        if (            (m.getName().toLowerCase().equals(\"get\" + fieldNameLow) || m.getName().toLowerCase().equals(\"is\" + fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow)) &&             m.getParameterTypes().length == 0 &&             (m.getGenericReturnType().equals(fieldType) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)))) {\n                if (hasGetter) {\n                    throw new IllegalStateException(\"Detected more than one getter\");\n                }\n                hasGetter = true;\n            }\n                        if ((m.getName().toLowerCase().equals(\"set\" + fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow + \"_$eq\")) &&             m.getParameterTypes().length == 1 && (m.getGenericParameterTypes()[0].equals(fieldType) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric))) &&             m.getReturnType().equals(Void.TYPE)) {\n                if (hasSetter) {\n                    throw new IllegalStateException(\"Detected more than one setter\");\n                }\n                hasSetter = true;\n            }\n        }\n        if (hasGetter && hasSetter) {\n            return true;\n        } else {\n            if (!hasGetter) {\n                LOG.debug(clazz + \" does not contain a getter for field \" + f.getName());\n            }\n            if (!hasSetter) {\n                LOG.debug(clazz + \" does not contain a setter for field \" + f.getName());\n            }\n            return false;\n        }\n    }\n}", "lc": 1.3636363636363635, "pi": 0.7033492822966506, "ma": 1.8, "nbd": 1.0, "ml": 2.9166666666666665, "d": 1.253968253968254, "mi": -0.845243128964059, "fo": 2.6666666666666665, "r": -0.02631578947368421, "e": 3.5456671449894244}
{"project_name": "Collections", "project_version": 25, "label": 1, "code": "/**\n * Gets an iterator that provides an ordered iteration over the elements\n * contained in a collection of {@link Iterator}s.\n * <p>\n * Given two ordered {@link Iterator}s <code>A</code> and <code>B</code>,\n * the {@link Iterator#next()} method will return the lesser of\n * <code>A.next()</code> and <code>B.next()</code> and so on.\n * <p>\n * The comparator is optional. If null is specified then natural order is used.\n *\n * @param <E>  the element type\n * @param comparator  the comparator to use, may be null for natural order\n * @param iterators  the iterators to use, not null or empty or contain nulls\n * @return a combination iterator over the iterators\n * @throws NullPointerException if iterators collection is null or contains a null\n * @throws ClassCastException if the iterators collection contains the wrong object type\n */\npublic static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator, final Collection<Iterator<? extends E>> iterators) {\n    return new CollatingIterator<E>(comparator, iterators);\n}", "code_comment": "/**\n * Gets an iterator that provides an ordered iteration over the elements\n * contained in a collection of {@link Iterator}s.\n * <p>\n * Given two ordered {@link Iterator}s <code>A</code> and <code>B</code>,\n * the {@link Iterator#next()} method will return the lesser of\n * <code>A.next()</code> and <code>B.next()</code> and so on.\n * <p>\n * The comparator is optional. If null is specified then natural order is used.\n *\n * @param <E>  the element type\n * @param comparator  the comparator to use, may be null for natural order\n * @param iterators  the iterators to use, not null or empty or contain nulls\n * @return a combination iterator over the iterators\n * @throws NullPointerException if iterators collection is null or contains a null\n * @throws ClassCastException if the iterators collection contains the wrong object type\n */\n", "code_no_comment": "public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator, final Collection<Iterator<? extends E>> iterators) {\n    return new CollatingIterator<E>(comparator, iterators);\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.8940098661028892, "fo": -0.5, "r": 0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "Closure", "project_version": 116, "label": 2, "code": "/**\n * Determines whether a function can be inlined at a particular call site.\n * There are several criteria that the function and reference must hold in\n * order for the functions to be inlined:\n * 1) If a call's arguments have side effects,\n * the corresponding argument in the function must only be referenced once.\n * For instance, this will not be inlined:\n * <pre>\n *     function foo(a) { return a + a }\n *     x = foo(i++);\n * </pre>\n */\nprivate CanInlineResult canInlineReferenceDirectly(Node callNode, Node fnNode) {\n    if (!isDirectCallNodeReplacementPossible(fnNode)) {\n        return CanInlineResult.NO;\n    }\n    Node block = fnNode.getLastChild();\n    // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n    Node cArg = callNode.getFirstChild().getNext();\n    // parameter list.\n    if (!callNode.getFirstChild().isName()) {\n        if (NodeUtil.isFunctionObjectCall(callNode)) {\n            // TODO(johnlenz): Support replace this with a value.\n            if (cArg == null || !cArg.isThis()) {\n                return CanInlineResult.NO;\n            }\n            cArg = cArg.getNext();\n        } else {\n            // \".apply\" call should be filtered before this.\n            Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n        }\n    }\n    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]\n    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n    while (cArg != null || fnParam != null) {\n        // For each named parameter check if a mutable argument use more than one.\n        if (fnParam != null) {\n            if (cArg != null) {\n                // parameter reference will be in a loop.\n                if (NodeUtil.mayEffectMutableState(cArg, compiler) && NodeUtil.getNameReferenceCount(block, fnParam.getString()) > 1) {\n                    return CanInlineResult.NO;\n                }\n            }\n            // Move to the next name.\n            fnParam = fnParam.getNext();\n        }\n        // isn't a named parameter to match.\n        if (cArg != null) {\n            if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n                return CanInlineResult.NO;\n            }\n            cArg = cArg.getNext();\n        }\n    }\n    return CanInlineResult.YES;\n}", "code_comment": "/**\n * Determines whether a function can be inlined at a particular call site.\n * There are several criteria that the function and reference must hold in\n * order for the functions to be inlined:\n * 1) If a call's arguments have side effects,\n * the corresponding argument in the function must only be referenced once.\n * For instance, this will not be inlined:\n * <pre>\n *     function foo(a) { return a + a }\n *     x = foo(i++);\n * </pre>\n */\n", "code_no_comment": "private CanInlineResult canInlineReferenceDirectly(Node callNode, Node fnNode) {\n    if (!isDirectCallNodeReplacementPossible(fnNode)) {\n        return CanInlineResult.NO;\n    }\n    Node block = fnNode.getLastChild();\n        Node cArg = callNode.getFirstChild().getNext();\n        if (!callNode.getFirstChild().isName()) {\n        if (NodeUtil.isFunctionObjectCall(callNode)) {\n                        if (cArg == null || !cArg.isThis()) {\n                return CanInlineResult.NO;\n            }\n            cArg = cArg.getNext();\n        } else {\n                        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n        }\n    }\n        Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n    while (cArg != null || fnParam != null) {\n                if (fnParam != null) {\n            if (cArg != null) {\n                                if (NodeUtil.mayEffectMutableState(cArg, compiler) && NodeUtil.getNameReferenceCount(block, fnParam.getString()) > 1) {\n                    return CanInlineResult.NO;\n                }\n            }\n                        fnParam = fnParam.getNext();\n        }\n                if (cArg != null) {\n            if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n                return CanInlineResult.NO;\n            }\n            cArg = cArg.getNext();\n        }\n    }\n    return CanInlineResult.YES;\n}", "lc": 0.9545454545454546, "pi": 0.8947368421052633, "ma": 1.4, "nbd": 1.0, "ml": 1.8333333333333333, "d": 1.2619047619047619, "mi": -0.6372093023255814, "fo": 1.0833333333333333, "r": -0.02631578947368421, "e": 1.8460192596946798}
{"project_name": "Compress", "project_version": 43, "label": 3, "code": "private void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {\n    final boolean encodable = zipEncoding.canEncode(ze.getName());\n    final ByteBuffer name = getName(ze);\n    if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n        addUnicodeExtraFields(ze, encodable, name);\n    }\n    final long localHeaderStart = streamCompressor.getTotalBytesWritten();\n    final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n    metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\n    // At crc offset\n    entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET;\n    writeCounted(localHeader);\n    entry.dataStart = streamCompressor.getTotalBytesWritten();\n}", "code_comment": NaN, "code_no_comment": "private void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {\n    final boolean encodable = zipEncoding.canEncode(ze.getName());\n    final ByteBuffer name = getName(ze);\n    if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n        addUnicodeExtraFields(ze, encodable, name);\n    }\n    final long localHeaderStart = streamCompressor.getTotalBytesWritten();\n    final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n    metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\n        entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET;\n    writeCounted(localHeader);\n    entry.dataStart = streamCompressor.getTotalBytesWritten();\n}", "lc": -0.045454545454545456, "pi": -0.5215311004784691, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": -0.04563492063492063, "mi": -0.04045102184637074, "fo": 0.4166666666666667, "r": -0.02631578947368421, "e": 0.056621888740973805}
{"project_name": "Closure", "project_version": 153, "label": 2, "code": "private void scanRoot(Node n, Scope parent) {\n    if (n.getType() == Token.FUNCTION) {\n        sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n        final Node fnNameNode = n.getFirstChild();\n        final Node args = fnNameNode.getNext();\n        final Node body = args.getNext();\n        // Bleed the function name into the scope, if it hasn't\n        // been declared in the outer scope.\n        String fnName = fnNameNode.getString();\n        if (!fnName.isEmpty() && NodeUtil.isFunctionExpression(n)) {\n            declareVar(fnName, fnNameNode, n, null, null, n);\n        }\n        // Args: Declare function variables\n        Preconditions.checkState(args.getType() == Token.LP);\n        for (Node a = args.getFirstChild(); a != null; a = a.getNext()) {\n            Preconditions.checkState(a.getType() == Token.NAME);\n            declareVar(a.getString(), a, args, n, null, n);\n        }\n        // Body\n        scanVars(body, n);\n    } else {\n        // It's the global block\n        Preconditions.checkState(scope.getParent() == null);\n        scanVars(n, null);\n    }\n}", "code_comment": NaN, "code_no_comment": "private void scanRoot(Node n, Scope parent) {\n    if (n.getType() == Token.FUNCTION) {\n        sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n        final Node fnNameNode = n.getFirstChild();\n        final Node args = fnNameNode.getNext();\n        final Node body = args.getNext();\n                        String fnName = fnNameNode.getString();\n        if (!fnName.isEmpty() && NodeUtil.isFunctionExpression(n)) {\n            declareVar(fnName, fnNameNode, n, null, null, n);\n        }\n                Preconditions.checkState(args.getType() == Token.LP);\n        for (Node a = args.getFirstChild(); a != null; a = a.getNext()) {\n            Preconditions.checkState(a.getType() == Token.NAME);\n            declareVar(a.getString(), a, args, n, null, n);\n        }\n                scanVars(body, n);\n    } else {\n                Preconditions.checkState(scope.getParent() == null);\n        scanVars(n, null);\n    }\n}", "lc": 0.3181818181818182, "pi": 0.09090909090909088, "ma": 0.0, "nbd": 0.0, "ml": 0.3333333333333333, "d": 0.6448412698412699, "mi": -0.35362931642001405, "fo": 1.25, "r": -0.02631578947368421, "e": 1.0443042132743208}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5476_813d8bee", "label": 3, "code": "/**\n *  @see Component#onComponentTag(ComponentTag)\n *  @param tag\n *             the abstraction representing html tag of this component\n */\n@Override\nprotected void onComponentTag(final ComponentTag tag) {\n    // Default handling for component tag\n    super.onComponentTag(tag);\n    // must be attached to <input type=\"checkbox\" .../> tag\n    checkComponentTag(tag, \"input\");\n    checkComponentTagAttribute(tag, \"type\", \"checkbox\");\n    CheckGroup<?> group = getGroup();\n    final String uuid = getValue();\n    // assign name and value\n    tag.put(\"name\", group.getInputName());\n    tag.put(\"value\", uuid);\n    // check if the model collection of the group contains the model object.\n    // if it does check the check box.\n    Collection<?> collection = (Collection<?>) group.getDefaultModelObject();\n    // check for npe in group's model object\n    if (collection == null) {\n        throw new WicketRuntimeException(\"CheckGroup [\" + group.getPath() + \"] contains a null model object, must be an object of type java.util.Collection\");\n    }\n    if (group.hasRawInput()) {\n        final String raw = group.getRawInput();\n        if (!Strings.isEmpty(raw)) {\n            final String[] values = raw.split(FormComponent.VALUE_SEPARATOR);\n            for (String value : values) {\n                if (uuid.equals(value)) {\n                    tag.put(\"checked\", \"checked\");\n                }\n            }\n        }\n    } else if (collection.contains(getDefaultModelObject())) {\n        tag.put(\"checked\", \"checked\");\n    }\n    if (group.wantOnSelectionChangedNotifications()) {\n        // url that points to this components IOnChangeListener method\n        CharSequence url = group.urlFor(IOnChangeListener.INTERFACE, new PageParameters());\n        Form<?> form = group.findParent(Form.class);\n        if (form != null) {\n            tag.put(\"onclick\", form.getJsForInterfaceUrl(url));\n        } else {\n            // NOTE: do not encode the url as that would give invalid JavaScript\n            tag.put(\"onclick\", \"window.location.href='\" + url + (url.toString().indexOf('?') > -1 ? \"&\" : \"?\") + group.getInputName() + \"=' + this.value;\");\n        }\n    }\n    if (!isActionAuthorized(ENABLE) || !isEnabledInHierarchy() || !group.isEnabledInHierarchy()) {\n        tag.put(ATTR_DISABLED, ATTR_DISABLED);\n    }\n    // put group id into the class so we can easily identify all radios belonging to the group\n    final String marker = \"wicket-\" + getGroup().getMarkupId();\n    String clazz = tag.getAttribute(\"class\");\n    if (Strings.isEmpty(clazz)) {\n        clazz = marker;\n    } else {\n        clazz = clazz + \" \" + marker;\n    }\n    tag.put(\"class\", clazz);\n}", "code_comment": "/**\n *  @see Component#onComponentTag(ComponentTag)\n *  @param tag\n *             the abstraction representing html tag of this component\n */\n", "code_no_comment": "@Override\nprotected void onComponentTag(final ComponentTag tag) {\n        super.onComponentTag(tag);\n        checkComponentTag(tag, \"input\");\n    checkComponentTagAttribute(tag, \"type\", \"checkbox\");\n    CheckGroup<?> group = getGroup();\n    final String uuid = getValue();\n        tag.put(\"name\", group.getInputName());\n    tag.put(\"value\", uuid);\n            Collection<?> collection = (Collection<?>) group.getDefaultModelObject();\n        if (collection == null) {\n        throw new WicketRuntimeException(\"CheckGroup [\" + group.getPath() + \"] contains a null model object, must be an object of type java.util.Collection\");\n    }\n    if (group.hasRawInput()) {\n        final String raw = group.getRawInput();\n        if (!Strings.isEmpty(raw)) {\n            final String[] values = raw.split(FormComponent.VALUE_SEPARATOR);\n            for (String value : values) {\n                if (uuid.equals(value)) {\n                    tag.put(\"checked\", \"checked\");\n                }\n            }\n        }\n    } else if (collection.contains(getDefaultModelObject())) {\n        tag.put(\"checked\", \"checked\");\n    }\n    if (group.wantOnSelectionChangedNotifications()) {\n                CharSequence url = group.urlFor(IOnChangeListener.INTERFACE, new PageParameters());\n        Form<?> form = group.findParent(Form.class);\n        if (form != null) {\n            tag.put(\"onclick\", form.getJsForInterfaceUrl(url));\n        } else {\n                        tag.put(\"onclick\", \"window.location.href='\" + url + (url.toString().indexOf('?') > -1 ? \"&\" : \"?\") + group.getInputName() + \"=' + this.value;\");\n        }\n    }\n    if (!isActionAuthorized(ENABLE) || !isEnabledInHierarchy() || !group.isEnabledInHierarchy()) {\n        tag.put(ATTR_DISABLED, ATTR_DISABLED);\n    }\n        final String marker = \"wicket-\" + getGroup().getMarkupId();\n    String clazz = tag.getAttribute(\"class\");\n    if (Strings.isEmpty(clazz)) {\n        clazz = marker;\n    } else {\n        clazz = clazz + \" \" + marker;\n    }\n    tag.put(\"class\", clazz);\n}", "lc": 1.5, "pi": 0.5598086124401914, "ma": 1.8, "nbd": 1.0, "ml": 1.9166666666666667, "d": 1.2440476190476188, "mi": -0.8835799859055671, "fo": 2.5833333333333335, "r": -0.02631578947368421, "e": 3.740440172196193}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4658_ef3adb12", "label": 3, "code": "@Override\npublic boolean isVisible() {\n    return getTabs().get(tabIndex).isVisible();\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean isVisible() {\n    return getTabs().get(tabIndex).isVisible();\n}", "lc": -0.45454545454545453, "pi": -0.6028708133971293, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.9134601832276249, "fo": -0.25, "r": 1.3947368421052633, "e": -0.16279340490885932}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-428_4a6a573b", "label": 3, "code": "/**\n *  @see java.util.Map#keySet()\n */\npublic Set keySet() {\n    return new AbstractSet() {\n\n        public Iterator iterator() {\n            return new Iterator() {\n\n                public boolean hasNext() {\n                    return i < size;\n                }\n\n                public Object next() {\n                    // Find next key\n                    i = nextKey(nextIndex(i));\n                    // Just in case... (WICKET-428)\n                    if (!hasNext()) {\n                        throw new NoSuchElementException();\n                    }\n                    // Get key\n                    return keys[i];\n                }\n\n                public void remove() {\n                    keys[i] = null;\n                    values[i] = null;\n                    size--;\n                }\n\n                int i = -1;\n            };\n        }\n\n        public int size() {\n            return size;\n        }\n    };\n}", "code_comment": "/**\n *  @see java.util.Map#keySet()\n */\n", "code_no_comment": "public Set keySet() {\n    return new AbstractSet() {\n\n        public Iterator iterator() {\n            return new Iterator() {\n\n                public boolean hasNext() {\n                    return i < size;\n                }\n\n                public Object next() {\n                                        i = nextKey(nextIndex(i));\n                                        if (!hasNext()) {\n                        throw new NoSuchElementException();\n                    }\n                                        return keys[i];\n                }\n\n                public void remove() {\n                    keys[i] = null;\n                    values[i] = null;\n                    size--;\n                }\n\n                int i = -1;\n            };\n        }\n\n        public int size() {\n            return size;\n        }\n    };\n}", "lc": 0.5909090909090909, "pi": 1.708133971291866, "ma": -0.2, "nbd": 0.5, "ml": -0.25, "d": 0.30357142857142855, "mi": -0.31078224101479923, "fo": -0.25, "r": 1.9210526315789473, "e": 0.12201494902693011}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2359_b3071839", "label": 0, "code": "/**\n * Get the earliest (oldest) revision where the node was alive at or before\n * the provided revision, if the node was alive at the given revision.\n *\n * @param context the revision context\n * @param maxRev the maximum revision to return\n * @param validRevisions the map of revisions to commit value already\n *                       checked against maxRev and considered valid.\n * @param lastRevs to keep track of the last modification.\n * @return the earliest revision, or null if the node is deleted at the\n *         given revision\n */\n@CheckForNull\npublic Revision getLiveRevision(RevisionContext context, Revision maxRev, Map<Revision, String> validRevisions, LastRevs lastRevs) {\n    // check local deleted map first\n    Value value = getLatestValue(context, getLocalDeleted(), null, maxRev, validRevisions, lastRevs);\n    if (value == null && !getPreviousRanges().isEmpty()) {\n        // need to check complete map\n        value = getLatestValue(context, getDeleted(), null, maxRev, validRevisions, lastRevs);\n    }\n    return value != null && \"false\".equals(value.value) ? value.revision : null;\n}", "code_comment": "/**\n * Get the earliest (oldest) revision where the node was alive at or before\n * the provided revision, if the node was alive at the given revision.\n *\n * @param context the revision context\n * @param maxRev the maximum revision to return\n * @param validRevisions the map of revisions to commit value already\n *                       checked against maxRev and considered valid.\n * @param lastRevs to keep track of the last modification.\n * @return the earliest revision, or null if the node is deleted at the\n *         given revision\n */\n", "code_no_comment": "@CheckForNull\npublic Revision getLiveRevision(RevisionContext context, Revision maxRev, Map<Revision, String> validRevisions, LastRevs lastRevs) {\n        Value value = getLatestValue(context, getLocalDeleted(), null, maxRev, validRevisions, lastRevs);\n    if (value == null && !getPreviousRanges().isEmpty()) {\n                value = getLatestValue(context, getDeleted(), null, maxRev, validRevisions, lastRevs);\n    }\n    return value != null && \"false\".equals(value.value) ? value.revision : null;\n}", "lc": -0.2727272727272727, "pi": -0.16267942583732073, "ma": -0.2, "nbd": -0.5, "ml": 0.25, "d": 0.3948412698412698, "mi": 0.20197322057787187, "fo": 0.08333333333333333, "r": -0.02631578947368421, "e": 0.26968413409173414}
{"project_name": "Lang", "project_version": 3, "label": 3, "code": "// -----------------------------------------------------------------------\n// must handle Long, Float, Integer, Float, Short,\n// BigDecimal, BigInteger and Byte\n// useful methods:\n// Byte.decode(String)\n// Byte.valueOf(String,int radix)\n// Byte.valueOf(String)\n// Double.valueOf(String)\n// Float.valueOf(String)\n// Float.valueOf(String)\n// Integer.valueOf(String,int radix)\n// Integer.valueOf(String)\n// Integer.decode(String)\n// Integer.getInteger(String)\n// Integer.getInteger(String,int val)\n// Integer.getInteger(String,Integer val)\n// Integer.valueOf(String)\n// Double.valueOf(String)\n// new Byte(String)\n// Long.valueOf(String)\n// Long.getLong(String)\n// Long.getLong(String,int)\n// Long.getLong(String,Integer)\n// Long.valueOf(String,int)\n// Long.valueOf(String)\n// Short.valueOf(String)\n// Short.decode(String)\n// Short.valueOf(String,int)\n// Short.valueOf(String)\n// new BigDecimal(String)\n// new BigInteger(String)\n// new BigInteger(String,int radix)\n// Possible inputs:\n// 45 45.5 45E7 4.5E7 Hex Oct Binary xxxF xxxD xxxf xxxd\n// plus minus everything. Prolly more. A lot are not separable.\n/**\n * <p>Turns a string value into a java.lang.Number.</p>\n *\n * <p>If the string starts with {@code 0x} or {@code -0x} (lower or upper case) or {@code #} or {@code -#}, it\n * will be interpreted as a hexadecimal Integer - or Long, if the number of digits after the\n * prefix is more than 8 - or BigInteger if there are more than 16 digits.\n * </p>\n * <p>Then, the value is examined for a type qualifier on the end, i.e. one of\n * <code>'f','F','d','D','l','L'</code>.  If it is found, it starts\n * trying to create successively larger types from the type specified\n * until one is found that can represent the value.</p>\n *\n * <p>If a type specifier is not found, it will check for a decimal point\n * and then try successively larger types from <code>Integer</code> to\n * <code>BigInteger</code> and from <code>Float</code> to\n * <code>BigDecimal</code>.</p>\n *\n * <p>\n * Integral values with a leading {@code 0} will be interpreted as octal; the returned number will\n * be Integer, Long or BigDecimal as appropriate.\n * </p>\n *\n * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n *\n * <p>This method does not trim the input string, i.e., strings with leading\n * or trailing spaces will generate NumberFormatExceptions.</p>\n *\n * @param str  String containing a number, may be null\n * @return Number created from the string (or null if the input is null)\n * @throws NumberFormatException if the value cannot be converted\n */\npublic static Number createNumber(final String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    // Need to deal with all possible hex prefixes here\n    final String[] hex_prefixes = { \"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\" };\n    int pfxLen = 0;\n    for (final String pfx : hex_prefixes) {\n        if (str.startsWith(pfx)) {\n            pfxLen += pfx.length();\n            break;\n        }\n    }\n    if (pfxLen > 0) {\n        // we have a hex number\n        final int hexDigits = str.length() - pfxLen;\n        if (hexDigits > 16) {\n            // too many for Long\n            return createBigInteger(str);\n        }\n        if (hexDigits > 8) {\n            // too many for an int\n            return createLong(str);\n        }\n        return createInteger(str);\n    }\n    final char lastChar = str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    final int decPos = str.indexOf('.');\n    // assumes both not present\n    final int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n    // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n    // and the parsing which will detect if e or E appear in a number due to using the wrong offset\n    // Check required precision (LANG-693)\n    int numDecimals = 0;\n    if (decPos > -1) {\n        if (expPos > -1) {\n            // there is an exponent\n            if (expPos < decPos || expPos > str.length()) {\n                // prevents double exponent causing IOOBE\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec = str.substring(decPos + 1, expPos);\n        } else {\n            dec = str.substring(decPos + 1);\n        }\n        mant = str.substring(0, decPos);\n        // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.\n        numDecimals = dec.length();\n    } else {\n        if (expPos > -1) {\n            if (expPos > str.length()) {\n                // prevents double exponent causing IOOBE\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            mant = str.substring(0, expPos);\n        } else {\n            mant = str;\n        }\n        dec = null;\n    }\n    if (!Character.isDigit(lastChar) && lastChar != '.') {\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp = null;\n        }\n        // Requesting a specific type..\n        final String numeric = str.substring(0, str.length() - 1);\n        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        switch(lastChar) {\n            case 'l':\n            case 'L':\n                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (final NumberFormatException nfe) {\n                    // NOPMD\n                    // Too big for a long\n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case 'f':\n            case 'F':\n                try {\n                    final Float f = NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        // has non-zeros in it, then float does not have the precision we want\n                        return f;\n                    }\n                } catch (final NumberFormatException nfe) {\n                // NOPMD\n                // ignore the bad number\n                }\n            // $FALL-THROUGH$\n            case 'd':\n            case 'D':\n                try {\n                    final Double d = NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (final NumberFormatException nfe) {\n                // NOPMD\n                // ignore the bad number\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (final NumberFormatException e) {\n                // NOPMD\n                // ignore the bad number\n                }\n            // $FALL-THROUGH$\n            default:\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    }\n    // small and go from there...\n    if (expPos > -1 && expPos < str.length() - 1) {\n        exp = str.substring(expPos + 1, str.length());\n    } else {\n        exp = null;\n    }\n    if (dec == null && exp == null) {\n        // Must be an Integer, Long, Biginteger\n        try {\n            return createInteger(str);\n        } catch (final NumberFormatException nfe) {\n        // NOPMD\n        // ignore the bad number\n        }\n        try {\n            return createLong(str);\n        } catch (final NumberFormatException nfe) {\n        // NOPMD\n        // ignore the bad number\n        }\n        return createBigInteger(str);\n    }\n    // Must be a Float, Double, BigDecimal\n    final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n    try {\n        final Float f = createFloat(str);\n        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n            return f;\n        }\n    } catch (final NumberFormatException nfe) {\n    // NOPMD\n    // ignore the bad number\n    }\n    try {\n        final Double d = createDouble(str);\n        if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n            return d;\n        }\n    } catch (final NumberFormatException nfe) {\n    // NOPMD\n    // ignore the bad number\n    }\n    return createBigDecimal(str);\n}", "code_comment": "/**\n * <p>Turns a string value into a java.lang.Number.</p>\n *\n * <p>If the string starts with {@code 0x} or {@code -0x} (lower or upper case) or {@code #} or {@code -#}, it\n * will be interpreted as a hexadecimal Integer - or Long, if the number of digits after the\n * prefix is more than 8 - or BigInteger if there are more than 16 digits.\n * </p>\n * <p>Then, the value is examined for a type qualifier on the end, i.e. one of\n * <code>'f','F','d','D','l','L'</code>.  If it is found, it starts\n * trying to create successively larger types from the type specified\n * until one is found that can represent the value.</p>\n *\n * <p>If a type specifier is not found, it will check for a decimal point\n * and then try successively larger types from <code>Integer</code> to\n * <code>BigInteger</code> and from <code>Float</code> to\n * <code>BigDecimal</code>.</p>\n *\n * <p>\n * Integral values with a leading {@code 0} will be interpreted as octal; the returned number will\n * be Integer, Long or BigDecimal as appropriate.\n * </p>\n *\n * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n *\n * <p>This method does not trim the input string, i.e., strings with leading\n * or trailing spaces will generate NumberFormatExceptions.</p>\n *\n * @param str  String containing a number, may be null\n * @return Number created from the string (or null if the input is null)\n * @throws NumberFormatException if the value cannot be converted\n */\n", "code_no_comment": "public static Number createNumber(final String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n        final String[] hex_prefixes = { \"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\" };\n    int pfxLen = 0;\n    for (final String pfx : hex_prefixes) {\n        if (str.startsWith(pfx)) {\n            pfxLen += pfx.length();\n            break;\n        }\n    }\n    if (pfxLen > 0) {\n                final int hexDigits = str.length() - pfxLen;\n        if (hexDigits > 16) {\n                        return createBigInteger(str);\n        }\n        if (hexDigits > 8) {\n                        return createLong(str);\n        }\n        return createInteger(str);\n    }\n    final char lastChar = str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    final int decPos = str.indexOf('.');\n        final int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n                int numDecimals = 0;\n    if (decPos > -1) {\n        if (expPos > -1) {\n                        if (expPos < decPos || expPos > str.length()) {\n                                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec = str.substring(decPos + 1, expPos);\n        } else {\n            dec = str.substring(decPos + 1);\n        }\n        mant = str.substring(0, decPos);\n                numDecimals = dec.length();\n    } else {\n        if (expPos > -1) {\n            if (expPos > str.length()) {\n                                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            mant = str.substring(0, expPos);\n        } else {\n            mant = str;\n        }\n        dec = null;\n    }\n    if (!Character.isDigit(lastChar) && lastChar != '.') {\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp = null;\n        }\n                final String numeric = str.substring(0, str.length() - 1);\n        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        switch(lastChar) {\n            case 'l':\n            case 'L':\n                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (final NumberFormatException nfe) {\n                                                            }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case 'f':\n            case 'F':\n                try {\n                    final Float f = NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                                                return f;\n                    }\n                } catch (final NumberFormatException nfe) {\n                                                }\n                        case 'd':\n            case 'D':\n                try {\n                    final Double d = NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (final NumberFormatException nfe) {\n                                                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (final NumberFormatException e) {\n                                                }\n                        default:\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    }\n        if (expPos > -1 && expPos < str.length() - 1) {\n        exp = str.substring(expPos + 1, str.length());\n    } else {\n        exp = null;\n    }\n    if (dec == null && exp == null) {\n                try {\n            return createInteger(str);\n        } catch (final NumberFormatException nfe) {\n                        }\n        try {\n            return createLong(str);\n        } catch (final NumberFormatException nfe) {\n                        }\n        return createBigInteger(str);\n    }\n        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n    try {\n        final Float f = createFloat(str);\n        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n            return f;\n        }\n    } catch (final NumberFormatException nfe) {\n            }\n    try {\n        final Double d = createDouble(str);\n        if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n            return d;\n        }\n    } catch (final NumberFormatException nfe) {\n            }\n    return createBigDecimal(str);\n}", "lc": 5.363636363636363, "pi": 1.1866028708133969, "ma": 7.8, "nbd": 1.5, "ml": 5.166666666666667, "d": 3.7777777777777777, "mi": -1.6723044397462996, "fo": 4.083333333333333, "r": -0.02631578947368421, "e": 23.020590930308945}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1225_3535afe2", "label": 1, "code": "/**\n * Returns the property at the specified absolute path in the workspace or\n * {@code null} if no such node exists.\n *\n * @param absPath An absolute path.\n * @return the specified {@code Property} or {@code null}.\n * @throws RepositoryException if another error occurs.\n */\n@CheckForNull\npublic Property getPropertyOrNull(final String absPath) throws RepositoryException {\n    if (absPath.equals(\"/\")) {\n        return null;\n    } else {\n        final String oakPath = getOakPathOrThrow(absPath);\n        return perform(new ReadOperation<Property>() {\n\n            @Override\n            public Property perform() throws RepositoryException {\n                PropertyDelegate pd = sd.getProperty(oakPath);\n                if (pd != null) {\n                    return new PropertyImpl(pd, sessionContext);\n                } else {\n                    return null;\n                }\n            }\n        });\n    }\n}", "code_comment": "/**\n * Returns the property at the specified absolute path in the workspace or\n * {@code null} if no such node exists.\n *\n * @param absPath An absolute path.\n * @return the specified {@code Property} or {@code null}.\n * @throws RepositoryException if another error occurs.\n */\n", "code_no_comment": "@CheckForNull\npublic Property getPropertyOrNull(final String absPath) throws RepositoryException {\n    if (absPath.equals(\"/\")) {\n        return null;\n    } else {\n        final String oakPath = getOakPathOrThrow(absPath);\n        return perform(new ReadOperation<Property>() {\n\n            @Override\n            public Property perform() throws RepositoryException {\n                PropertyDelegate pd = sd.getProperty(oakPath);\n                if (pd != null) {\n                    return new PropertyImpl(pd, sessionContext);\n                } else {\n                    return null;\n                }\n            }\n        });\n    }\n}", "lc": 0.22727272727272727, "pi": 1.6315789473684212, "ma": -0.2, "nbd": 0.5, "ml": -0.08333333333333333, "d": -0.053571428571428575, "mi": -0.13291050035236088, "fo": -0.16666666666666666, "r": 0.8421052631578947, "e": -0.04481480841156504}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-1978_0078c44e", "label": 1, "code": "@Override\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\npublic T copy(T from, T reuse) {\n    if (from == null) {\n        return null;\n    }\n    Class<?> actualType = from.getClass();\n    if (reuse == null || actualType != reuse.getClass()) {\n        // cannot reuse, do a non-reuse copy\n        return copy(from);\n    }\n    if (actualType == clazz) {\n        try {\n            for (int i = 0; i < numFields; i++) {\n                Object value = fields[i].get(from);\n                if (value != null) {\n                    Object copy = fieldSerializers[i].copy(fields[i].get(from), fields[i].get(reuse));\n                    fields[i].set(reuse, copy);\n                } else {\n                    fields[i].set(reuse, null);\n                }\n            }\n        } catch (IllegalAccessException e) {\n            throw new RuntimeException(\"Error during POJO copy, this should not happen since we check the fields\" + \"before.\");\n        }\n    } else {\n        TypeSerializer subclassSerializer = getSubclassSerializer(actualType);\n        reuse = (T) subclassSerializer.copy(from, reuse);\n    }\n    return reuse;\n}", "code_comment": NaN, "code_no_comment": "@Override\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\npublic T copy(T from, T reuse) {\n    if (from == null) {\n        return null;\n    }\n    Class<?> actualType = from.getClass();\n    if (reuse == null || actualType != reuse.getClass()) {\n                return copy(from);\n    }\n    if (actualType == clazz) {\n        try {\n            for (int i = 0; i < numFields; i++) {\n                Object value = fields[i].get(from);\n                if (value != null) {\n                    Object copy = fieldSerializers[i].copy(fields[i].get(from), fields[i].get(reuse));\n                    fields[i].set(reuse, copy);\n                } else {\n                    fields[i].set(reuse, null);\n                }\n            }\n        } catch (IllegalAccessException e) {\n            throw new RuntimeException(\"Error during POJO copy, this should not happen since we check the fields\" + \"before.\");\n        }\n    } else {\n        TypeSerializer subclassSerializer = getSubclassSerializer(actualType);\n        reuse = (T) subclassSerializer.copy(from, reuse);\n    }\n    return reuse;\n}", "lc": 0.7272727272727273, "pi": 1.5071770334928227, "ma": 0.8, "nbd": 1.0, "ml": 0.75, "d": 1.152777777777778, "mi": -0.5365750528541224, "fo": 0.4166666666666667, "r": -0.02631578947368421, "e": 1.5759501622263328}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5071_faaae8d3", "label": 1, "code": "/**\n *  Matches when the request url starts with\n *  {@link org.apache.wicket.core.request.mapper.IMapperContext#getNamespace()}/{@link org.apache.wicket.core.request.mapper.IMapperContext#getPageIdentifier()}\n *  or when the base url starts with\n *  {@link org.apache.wicket.core.request.mapper.IMapperContext#getNamespace()}/{@link org.apache.wicket.core.request.mapper.IMapperContext#getPageIdentifier()}\n *  and the request url with {@link org.apache.wicket.core.request.mapper.IMapperContext#getPageIdentifier()}\n *\n *  @param request\n *       the request to check\n *  @return {@code true} if the conditions match\n */\nprivate boolean matches(final Request request) {\n    boolean matches = false;\n    Url url = request.getUrl();\n    String namespace = getContext().getNamespace();\n    String pageIdentifier = getContext().getPageIdentifier();\n    if (urlStartsWith(url, namespace, pageIdentifier)) {\n        matches = true;\n    } else if (urlStartsWith(request.getClientUrl(), namespace, pageIdentifier) && urlStartsWith(url, pageIdentifier)) {\n        matches = true;\n    } else if (urlStartsWith(request.getClientUrl(), pageIdentifier) && urlStartsWith(url, pageIdentifier)) {\n        matches = true;\n    }\n    return matches;\n}", "code_comment": "/**\n *  Matches when the request url starts with\n *  {@link org.apache.wicket.core.request.mapper.IMapperContext#getNamespace()}/{@link org.apache.wicket.core.request.mapper.IMapperContext#getPageIdentifier()}\n *  or when the base url starts with\n *  {@link org.apache.wicket.core.request.mapper.IMapperContext#getNamespace()}/{@link org.apache.wicket.core.request.mapper.IMapperContext#getPageIdentifier()}\n *  and the request url with {@link org.apache.wicket.core.request.mapper.IMapperContext#getPageIdentifier()}\n *\n *  @param request\n *       the request to check\n *  @return {@code true} if the conditions match\n */\n", "code_no_comment": "private boolean matches(final Request request) {\n    boolean matches = false;\n    Url url = request.getUrl();\n    String namespace = getContext().getNamespace();\n    String pageIdentifier = getContext().getPageIdentifier();\n    if (urlStartsWith(url, namespace, pageIdentifier)) {\n        matches = true;\n    } else if (urlStartsWith(request.getClientUrl(), namespace, pageIdentifier) && urlStartsWith(url, pageIdentifier)) {\n        matches = true;\n    } else if (urlStartsWith(request.getClientUrl(), pageIdentifier) && urlStartsWith(url, pageIdentifier)) {\n        matches = true;\n    }\n    return matches;\n}", "lc": 0.0, "pi": -0.29665071770334933, "ma": 0.0, "nbd": 0.5, "ml": 0.6666666666666666, "d": 0.14880952380952375, "mi": -0.047498238195912666, "fo": 0.5, "r": -0.02631578947368421, "e": 0.10586031822870742}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5071_faaae8d3", "label": 1, "code": "private boolean matches(final Request request) {\n    boolean matches = false;\n    Url url = request.getUrl();\n    Url baseUrl = request.getClientUrl();\n    String namespace = getContext().getNamespace();\n    String bookmarkableIdentifier = getContext().getBookmarkableIdentifier();\n    String pageIdentifier = getContext().getPageIdentifier();\n    if (url.getSegments().size() >= 3 && urlStartsWith(url, namespace, bookmarkableIdentifier)) {\n        matches = true;\n    } else // baseUrl = 'wicket/bookmarkable/com.example.SomePage[?...]', requestUrl = 'bookmarkable/com.example.SomePage'\n    if (baseUrl.getSegments().size() == 3 && urlStartsWith(baseUrl, namespace, bookmarkableIdentifier) && url.getSegments().size() >= 2 && urlStartsWith(url, bookmarkableIdentifier)) {\n        matches = true;\n    } else // baseUrl = 'wicket/page[?...]', requestUrl = 'bookmarkable/com.example.SomePage'\n    if (baseUrl.getSegments().size() == 2 && urlStartsWith(baseUrl, namespace, pageIdentifier) && url.getSegments().size() >= 2 && urlStartsWith(url, bookmarkableIdentifier)) {\n        matches = true;\n    }\n    return matches;\n}", "code_comment": NaN, "code_no_comment": "private boolean matches(final Request request) {\n    boolean matches = false;\n    Url url = request.getUrl();\n    Url baseUrl = request.getClientUrl();\n    String namespace = getContext().getNamespace();\n    String bookmarkableIdentifier = getContext().getBookmarkableIdentifier();\n    String pageIdentifier = getContext().getPageIdentifier();\n    if (url.getSegments().size() >= 3 && urlStartsWith(url, namespace, bookmarkableIdentifier)) {\n        matches = true;\n    } else     if (baseUrl.getSegments().size() == 3 && urlStartsWith(baseUrl, namespace, bookmarkableIdentifier) && url.getSegments().size() >= 2 && urlStartsWith(url, bookmarkableIdentifier)) {\n        matches = true;\n    } else     if (baseUrl.getSegments().size() == 2 && urlStartsWith(baseUrl, namespace, pageIdentifier) && url.getSegments().size() >= 2 && urlStartsWith(url, bookmarkableIdentifier)) {\n        matches = true;\n    }\n    return matches;\n}", "lc": 0.18181818181818182, "pi": -0.4258373205741628, "ma": 0.0, "nbd": 0.5, "ml": 1.3333333333333333, "d": 0.8095238095238095, "mi": -0.26116983791402393, "fo": 1.4166666666666667, "r": -0.02631578947368421, "e": 1.0436403243374077}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1505_b082fc1e", "label": 1, "code": "synchronized void addMutation(Mutation m) {\n    long now = System.currentTimeMillis();\n    mutationCount++;\n    for (ColumnUpdate u : m.getUpdates()) {\n        Key key = new Key(m.getRow(), 0, m.getRow().length, u.getColumnFamily(), 0, u.getColumnFamily().length, u.getColumnQualifier(), 0, u.getColumnQualifier().length, u.getColumnVisibility(), 0, u.getColumnVisibility().length, u.getTimestamp());\n        if (u.isDeleted())\n            key.setDeleted(true);\n        if (!u.hasTimestamp())\n            if (timeType.equals(TimeType.LOGICAL))\n                key.setTimestamp(mutationCount);\n            else\n                key.setTimestamp(now);\n        table.put(new MockMemKey(key, mutationCount), new Value(u.getValue()));\n    }\n}", "code_comment": NaN, "code_no_comment": "synchronized void addMutation(Mutation m) {\n    long now = System.currentTimeMillis();\n    mutationCount++;\n    for (ColumnUpdate u : m.getUpdates()) {\n        Key key = new Key(m.getRow(), 0, m.getRow().length, u.getColumnFamily(), 0, u.getColumnFamily().length, u.getColumnQualifier(), 0, u.getColumnQualifier().length, u.getColumnVisibility(), 0, u.getColumnVisibility().length, u.getTimestamp());\n        if (u.isDeleted())\n            key.setDeleted(true);\n        if (!u.hasTimestamp())\n            if (timeType.equals(TimeType.LOGICAL))\n                key.setTimestamp(mutationCount);\n            else\n                key.setTimestamp(now);\n        table.put(new MockMemKey(key, mutationCount), new Value(u.getValue()));\n    }\n}", "lc": 0.045454545454545456, "pi": 0.937799043062201, "ma": 0.2, "nbd": -0.5, "ml": 0.08333333333333333, "d": 0.019841269841269816, "mi": -0.15630725863284003, "fo": 1.0833333333333333, "r": -0.02631578947368421, "e": 0.16355872132224544}
{"project_name": "Closure", "project_version": 2, "label": 2, "code": "/**\n * Check whether there's any property conflict for for a particular super\n * interface\n * @param t The node traversal object that supplies context\n * @param n The node being visited\n * @param functionName The function name being checked\n * @param properties The property names in the super interfaces that have\n * been visited\n * @param currentProperties The property names in the super interface\n * that have been visited\n * @param interfaceType The super interface that is being visited\n */\nprivate void checkInterfaceConflictProperties(NodeTraversal t, Node n, String functionName, HashMap<String, ObjectType> properties, HashMap<String, ObjectType> currentProperties, ObjectType interfaceType) {\n    ObjectType implicitProto = interfaceType.getImplicitPrototype();\n    Set<String> currentPropertyNames;\n    // This can be the case if interfaceType is proxy to a non-existent\n    // object (which is a bad type annotation, but shouldn't crash).\n    currentPropertyNames = implicitProto.getOwnPropertyNames();\n    for (String name : currentPropertyNames) {\n        ObjectType oType = properties.get(name);\n        if (oType != null) {\n            if (!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))) {\n                compiler.report(t.makeError(n, INCOMPATIBLE_EXTENDED_PROPERTY_TYPE, functionName, name, oType.toString(), interfaceType.toString()));\n            }\n        }\n        currentProperties.put(name, interfaceType);\n    }\n    for (ObjectType iType : interfaceType.getCtorExtendedInterfaces()) {\n        checkInterfaceConflictProperties(t, n, functionName, properties, currentProperties, iType);\n    }\n}", "code_comment": "/**\n * Check whether there's any property conflict for for a particular super\n * interface\n * @param t The node traversal object that supplies context\n * @param n The node being visited\n * @param functionName The function name being checked\n * @param properties The property names in the super interfaces that have\n * been visited\n * @param currentProperties The property names in the super interface\n * that have been visited\n * @param interfaceType The super interface that is being visited\n */\n", "code_no_comment": "private void checkInterfaceConflictProperties(NodeTraversal t, Node n, String functionName, HashMap<String, ObjectType> properties, HashMap<String, ObjectType> currentProperties, ObjectType interfaceType) {\n    ObjectType implicitProto = interfaceType.getImplicitPrototype();\n    Set<String> currentPropertyNames;\n            currentPropertyNames = implicitProto.getOwnPropertyNames();\n    for (String name : currentPropertyNames) {\n        ObjectType oType = properties.get(name);\n        if (oType != null) {\n            if (!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))) {\n                compiler.report(t.makeError(n, INCOMPATIBLE_EXTENDED_PROPERTY_TYPE, functionName, name, oType.toString(), interfaceType.toString()));\n            }\n        }\n        currentProperties.put(name, interfaceType);\n    }\n    for (ObjectType iType : interfaceType.getCtorExtendedInterfaces()) {\n        checkInterfaceConflictProperties(t, n, functionName, properties, currentProperties, iType);\n    }\n}", "lc": 0.13636363636363635, "pi": 0.5454545454545453, "ma": 0.2, "nbd": 0.5, "ml": 0.08333333333333333, "d": 0.08134920634920634, "mi": -0.2250880902043692, "fo": 0.5833333333333334, "r": -0.02631578947368421, "e": 0.24690444494389788}
{"project_name": "Math", "project_version": 65, "label": 1, "code": "/**\n * Get a Chi-Square-like value assuming the N residuals follow N\n * distinct normal distributions centered on 0 and whose variances are\n * the reciprocal of the weights.\n * @return chi-square value\n */\npublic double getChiSquare() {\n    double chiSquare = 0;\n    for (int i = 0; i < rows; ++i) {\n        final double residual = residuals[i];\n        chiSquare += residual * residual / residualsWeights[i];\n    }\n    return chiSquare;\n}", "code_comment": "/**\n * Get a Chi-Square-like value assuming the N residuals follow N\n * distinct normal distributions centered on 0 and whose variances are\n * the reciprocal of the weights.\n * @return chi-square value\n */\n", "code_no_comment": "public double getChiSquare() {\n    double chiSquare = 0;\n    for (int i = 0; i < rows; ++i) {\n        final double residual = residuals[i];\n        chiSquare += residual * residual / residualsWeights[i];\n    }\n    return chiSquare;\n}", "lc": -0.2727272727272727, "pi": -0.07655502392344504, "ma": -0.4, "nbd": -0.5, "ml": -0.16666666666666666, "d": 0.8253968253968255, "mi": 0.33756166314305824, "fo": -0.5, "r": 2.552631578947368, "e": 0.1181929772998392}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-93_0be7e8f0", "label": 1, "code": "public static NodeStateBuilder create(NodeStateBuilderContext context) {\n    return new KernelNodeStateBuilder(context, \"\");\n}", "code_comment": NaN, "code_no_comment": "public static NodeStateBuilder create(NodeStateBuilderContext context) {\n    return new KernelNodeStateBuilder(context, \"\");\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.0132487667371384, "fo": -0.5, "r": 1.0263157894736843, "e": -0.16279340490885932}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-2172_ea4a3f8a", "label": 3, "code": "/**\n *  @see IValueMap#getAsLong(String)\n */\npublic Long getAsLong(String key) {\n    if (!containsKey(key))\n        return null;\n    try {\n        return getLong(key);\n    } catch (StringValueConversionException ignored) {\n        return null;\n    }\n}", "code_comment": "/**\n *  @see IValueMap#getAsLong(String)\n */\n", "code_no_comment": "public Long getAsLong(String key) {\n    if (!containsKey(key))\n        return null;\n    try {\n        return getLong(key);\n    } catch (StringValueConversionException ignored) {\n        return null;\n    }\n}", "lc": -0.22727272727272727, "pi": -0.01913875598086126, "ma": -0.2, "nbd": -0.5, "ml": -0.16666666666666666, "d": -0.3650793650793651, "mi": 0.3860465116279071, "fo": -0.3333333333333333, "r": 2.5, "e": -0.16279340490885932}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4116_4624ab3d", "label": 1, "code": "/**\n *  The page instance is new only if there is no cached instance or the data stores doesn't have\n *  a page with that id with the same {@linkplain #pageClass}.\n *\n *  @see org.apache.wicket.request.handler.IPageProvider#isNewPageInstance()\n */\npublic boolean isNewPageInstance() {\n    boolean isNew = pageInstance == null;\n    if (isNew && pageId != null) {\n        IRequestablePage storedPageInstance = getStoredPage(pageId);\n        if (storedPageInstance != null) {\n            pageInstance = storedPageInstance;\n            isNew = false;\n        }\n    }\n    return isNew;\n}", "code_comment": "/**\n *  The page instance is new only if there is no cached instance or the data stores doesn't have\n *  a page with that id with the same {@linkplain #pageClass}.\n *\n *  @see org.apache.wicket.request.handler.IPageProvider#isNewPageInstance()\n */\n", "code_no_comment": "public boolean isNewPageInstance() {\n    boolean isNew = pageInstance == null;\n    if (isNew && pageId != null) {\n        IRequestablePage storedPageInstance = getStoredPage(pageId);\n        if (storedPageInstance != null) {\n            pageInstance = storedPageInstance;\n            isNew = false;\n        }\n    }\n    return isNew;\n}", "lc": -0.13636363636363635, "pi": 0.45933014354066987, "ma": -0.2, "nbd": 0.0, "ml": 0.08333333333333333, "d": 0.38888888888888884, "mi": 0.1839323467230445, "fo": -0.4166666666666667, "r": 1.9736842105263157, "e": 0.017300300248382045}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-3189_a5b05566", "label": 3, "code": "public static InfoOptions parseInfoCommand(String[] args) throws CliArgsException {\n    try {\n        PosixParser parser = new PosixParser();\n        CommandLine line = parser.parse(INFO_OPTIONS, args, false);\n        return new InfoOptions(line);\n    } catch (ParseException e) {\n        throw new CliArgsException(e.getMessage());\n    }\n}", "code_comment": NaN, "code_no_comment": "public static InfoOptions parseInfoCommand(String[] args) throws CliArgsException {\n    try {\n        PosixParser parser = new PosixParser();\n        CommandLine line = parser.parse(INFO_OPTIONS, args, false);\n        return new InfoOptions(line);\n    } catch (ParseException e) {\n        throw new CliArgsException(e.getMessage());\n    }\n}", "lc": -0.22727272727272727, "pi": 0.07177033492822962, "ma": -0.2, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.2766737138830161, "fo": -0.3333333333333333, "r": 0.894736842105263, "e": -0.16279340490885932}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-1820_39d526e6", "label": 0, "code": "/**\n *  Static utility to parse a field of type short from a byte sequence that represents text characters\n *  (such as when read from a file stream).\n *\n *  @param bytes The bytes containing the text data that should be parsed.\n *  @param startPos The offset to start the parsing.\n *  @param length The length of the byte sequence (counting from the offset).\n *\n *  @return The parsed value.\n *\n *  @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\n */\npublic static final short parseField(byte[] bytes, int startPos, int length) {\n    return parseField(bytes, startPos, length, (char) 0xffff);\n}", "code_comment": "/**\n *  Static utility to parse a field of type short from a byte sequence that represents text characters\n *  (such as when read from a file stream).\n *\n *  @param bytes The bytes containing the text data that should be parsed.\n *  @param startPos The offset to start the parsing.\n *  @param length The length of the byte sequence (counting from the offset).\n *\n *  @return The parsed value.\n *\n *  @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\n */\n", "code_no_comment": "public static final short parseField(byte[] bytes, int startPos, int length) {\n    return parseField(bytes, startPos, length, (char) 0xffff);\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.9926708949964762, "fo": -0.4166666666666667, "r": 1.9210526315789473, "e": -0.16279340490885932}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-6948_f744afd9", "label": 3, "code": "/**\n * Releases an acquired producer back after usage.\n *\n * @param endpoint the endpoint\n * @param producer the producer to release\n * @throws Exception can be thrown if error stopping producer if that was needed.\n */\npublic void releaseProducer(Endpoint endpoint, Producer producer) throws Exception {\n    if (producer instanceof ServicePoolAware) {\n        // release back to the pool\n        pool.release(endpoint, producer);\n    } else if (!producer.isSingleton()) {\n        // stop non singleton producers as we should not leak resources\n        producer.stop();\n    }\n}", "code_comment": "/**\n * Releases an acquired producer back after usage.\n *\n * @param endpoint the endpoint\n * @param producer the producer to release\n * @throws Exception can be thrown if error stopping producer if that was needed.\n */\n", "code_no_comment": "public void releaseProducer(Endpoint endpoint, Producer producer) throws Exception {\n    if (producer instanceof ServicePoolAware) {\n                pool.release(endpoint, producer);\n    } else if (!producer.isSingleton()) {\n                producer.stop();\n    }\n}", "lc": -0.3181818181818182, "pi": 0.01435406698564584, "ma": -0.2, "nbd": 0.0, "ml": -0.08333333333333333, "d": -0.3650793650793651, "mi": 0.4539816772374912, "fo": -0.25, "r": 0.7894736842105263, "e": -0.16279340490885932}
{"project_name": "JxPath", "project_version": 3, "label": 1, "code": "public NodePointer createPath(JXPathContext context, Object value) {\n    NodePointer newParent = parent.createPath(context);\n    if (isAttribute()) {\n        NodePointer pointer = newParent.createAttribute(context, getName());\n        pointer.setValue(value);\n        return pointer;\n    } else {\n        if (newParent instanceof PropertyOwnerPointer) {\n            PropertyOwnerPointer pop = (PropertyOwnerPointer) newParent;\n            newParent = pop.getPropertyPointer();\n        }\n        return newParent.createChild(context, getName(), index, value);\n    }\n}", "code_comment": NaN, "code_no_comment": "public NodePointer createPath(JXPathContext context, Object value) {\n    NodePointer newParent = parent.createPath(context);\n    if (isAttribute()) {\n        NodePointer pointer = newParent.createAttribute(context, getName());\n        pointer.setValue(value);\n        return pointer;\n    } else {\n        if (newParent instanceof PropertyOwnerPointer) {\n            PropertyOwnerPointer pop = (PropertyOwnerPointer) newParent;\n            newParent = pop.getPropertyPointer();\n        }\n        return newParent.createChild(context, getName(), index, value);\n    }\n}", "lc": 0.0, "pi": 0.29665071770334916, "ma": -0.2, "nbd": 0.0, "ml": -0.08333333333333333, "d": -0.3650793650793651, "mi": -0.00944326990838601, "fo": 0.16666666666666666, "r": -0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-2172_ea4a3f8a", "label": 3, "code": "/**\n *  THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT USE IT!\n *\n *  @param parameters\n *             Map of query parameters that parameterize this resource\n */\npublic final void setParameters(final Map<?, ?> parameters) {\n    if (parameters == null) {\n        Resource.parameters.set(null);\n    } else {\n        Resource.parameters.set(new ValueMap(parameters));\n    }\n}", "code_comment": "/**\n *  THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT USE IT!\n *\n *  @param parameters\n *             Map of query parameters that parameterize this resource\n */\n", "code_no_comment": "public final void setParameters(final Map<?, ?> parameters) {\n    if (parameters == null) {\n        Resource.parameters.set(null);\n    } else {\n        Resource.parameters.set(new ValueMap(parameters));\n    }\n}", "lc": -0.3181818181818182, "pi": 0.01435406698564584, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": -0.3650793650793651, "mi": 0.5004933051444677, "fo": -0.3333333333333333, "r": 1.6842105263157894, "e": -0.16279340490885932}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-9444_baece126", "label": 1, "code": "private Processor makeProcessorImpl(RouteContext routeContext) throws Exception {\n    Processor processor = null;\n    // allow any custom logic before we create the processor\n    preCreateProcessor();\n    // resolve properties before we create the processor\n    ProcessorDefinitionHelper.resolvePropertyPlaceholders(routeContext.getCamelContext(), this);\n    // resolve constant fields (eg Exchange.FILE_NAME)\n    ProcessorDefinitionHelper.resolveKnownConstantFields(this);\n    // also resolve properties and constant fields on embedded expressions\n    ProcessorDefinition<?> me = (ProcessorDefinition<?>) this;\n    if (me instanceof ExpressionNode) {\n        ExpressionNode exp = (ExpressionNode) me;\n        ExpressionDefinition expressionDefinition = exp.getExpression();\n        if (expressionDefinition != null) {\n            // resolve properties before we create the processor\n            ProcessorDefinitionHelper.resolvePropertyPlaceholders(routeContext.getCamelContext(), expressionDefinition);\n            // resolve constant fields (eg Exchange.FILE_NAME)\n            ProcessorDefinitionHelper.resolveKnownConstantFields(expressionDefinition);\n        }\n    }\n    // at first use custom factory\n    if (routeContext.getCamelContext().getProcessorFactory() != null) {\n        processor = routeContext.getCamelContext().getProcessorFactory().createProcessor(routeContext, this);\n    }\n    // fallback to default implementation if factory did not create the processor\n    if (processor == null) {\n        processor = createProcessor(routeContext);\n    }\n    // unwrap internal processor so we can set id on the actual processor\n    Processor idProcessor = processor;\n    if (processor instanceof CamelInternalProcessor) {\n        idProcessor = ((CamelInternalProcessor) processor).getProcessor();\n    }\n    // inject id\n    if (idProcessor instanceof IdAware) {\n        String id = this.idOrCreate(routeContext.getCamelContext().getNodeIdFactory());\n        ((IdAware) idProcessor).setId(id);\n    }\n    if (processor == null) {\n        // no processor to make\n        return null;\n    }\n    return wrapProcessor(routeContext, processor);\n}", "code_comment": NaN, "code_no_comment": "private Processor makeProcessorImpl(RouteContext routeContext) throws Exception {\n    Processor processor = null;\n        preCreateProcessor();\n        ProcessorDefinitionHelper.resolvePropertyPlaceholders(routeContext.getCamelContext(), this);\n        ProcessorDefinitionHelper.resolveKnownConstantFields(this);\n        ProcessorDefinition<?> me = (ProcessorDefinition<?>) this;\n    if (me instanceof ExpressionNode) {\n        ExpressionNode exp = (ExpressionNode) me;\n        ExpressionDefinition expressionDefinition = exp.getExpression();\n        if (expressionDefinition != null) {\n                        ProcessorDefinitionHelper.resolvePropertyPlaceholders(routeContext.getCamelContext(), expressionDefinition);\n                        ProcessorDefinitionHelper.resolveKnownConstantFields(expressionDefinition);\n        }\n    }\n        if (routeContext.getCamelContext().getProcessorFactory() != null) {\n        processor = routeContext.getCamelContext().getProcessorFactory().createProcessor(routeContext, this);\n    }\n        if (processor == null) {\n        processor = createProcessor(routeContext);\n    }\n        Processor idProcessor = processor;\n    if (processor instanceof CamelInternalProcessor) {\n        idProcessor = ((CamelInternalProcessor) processor).getProcessor();\n    }\n        if (idProcessor instanceof IdAware) {\n        String id = this.idOrCreate(routeContext.getCamelContext().getNodeIdFactory());\n        ((IdAware) idProcessor).setId(id);\n    }\n    if (processor == null) {\n                return null;\n    }\n    return wrapProcessor(routeContext, processor);\n}", "lc": 0.8636363636363636, "pi": -0.11483253588516758, "ma": 0.8, "nbd": 0.0, "ml": 0.5833333333333334, "d": 0.13690476190476186, "mi": -0.5766032417195206, "fo": 1.1666666666666667, "r": -0.02631578947368421, "e": 0.3998755208243287}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3767_84c3baac", "label": 1, "code": "/**\n *  Validates this component using the component's validators.\n */\n@SuppressWarnings(\"unchecked\")\nprotected final void validateValidators() {\n    final IValidatable<T> validatable = newValidatable();\n    boolean isNull = getConvertedInput() == null;\n    IValidator<T> validator = null;\n    try {\n        for (Behavior behavior : getBehaviors()) {\n            if (behavior instanceof IValidator) {\n                validator = (IValidator<T>) behavior;\n                if (isNull == false || validator instanceof INullAcceptingValidator<?>) {\n                    validator.validate(validatable);\n                }\n                if (!isValid()) {\n                    break;\n                }\n            }\n        }\n    } catch (Exception e) {\n        throw new WicketRuntimeException(\"Exception '\" + e + \"' occurred during validation \" + validator.getClass().getName() + \" on component \" + getPath(), e);\n    }\n}", "code_comment": "/**\n *  Validates this component using the component's validators.\n */\n", "code_no_comment": "@SuppressWarnings(\"unchecked\")\nprotected final void validateValidators() {\n    final IValidatable<T> validatable = newValidatable();\n    boolean isNull = getConvertedInput() == null;\n    IValidator<T> validator = null;\n    try {\n        for (Behavior behavior : getBehaviors()) {\n            if (behavior instanceof IValidator) {\n                validator = (IValidator<T>) behavior;\n                if (isNull == false || validator instanceof INullAcceptingValidator<?>) {\n                    validator.validate(validatable);\n                }\n                if (!isValid()) {\n                    break;\n                }\n            }\n        }\n    } catch (Exception e) {\n        throw new WicketRuntimeException(\"Exception '\" + e + \"' occurred during validation \" + validator.getClass().getName() + \" on component \" + getPath(), e);\n    }\n}", "lc": 0.3181818181818182, "pi": 1.7033492822966507, "ma": 0.8, "nbd": 1.0, "ml": 0.25, "d": 0.23611111111111105, "mi": -0.28513037350246634, "fo": 0.16666666666666666, "r": 0.31578947368421056, "e": 0.2144246007733845}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1308_69ba2a54", "label": 1, "code": "private Expression parsePropertyOrFunction() throws ParseException {\n    StringBuilder buff = new StringBuilder();\n    boolean isPath = false;\n    while (true) {\n        if (currentTokenType == IDENTIFIER) {\n            String name = readIdentifier();\n            buff.append(name);\n        } else if (readIf(\"*\")) {\n            // any node\n            buff.append('*');\n            isPath = true;\n        } else if (readIf(\".\")) {\n            buff.append('.');\n            if (readIf(\".\")) {\n                buff.append('.');\n            }\n            isPath = true;\n        } else if (readIf(\"@\")) {\n            if (readIf(\"*\")) {\n                // xpath supports @*, even thought jackrabbit may not\n                buff.append('*');\n            } else {\n                buff.append(readIdentifier());\n            }\n            return new Expression.Property(currentSelector, buff.toString());\n        } else {\n            break;\n        }\n        if (readIf(\"/\")) {\n            isPath = true;\n            buff.append('/');\n        } else {\n            break;\n        }\n    }\n    if (!isPath && readIf(\"(\")) {\n        return parseFunction(buff.toString());\n    } else if (buff.length() > 0) {\n        // jcr:contains(jcr:content, 'x')\n        if (buff.toString().equals(\".\")) {\n            buff = new StringBuilder(\"*\");\n        } else {\n            buff.append(\"/*\");\n        }\n        return new Expression.Property(currentSelector, buff.toString());\n    }\n    throw getSyntaxError();\n}", "code_comment": NaN, "code_no_comment": "private Expression parsePropertyOrFunction() throws ParseException {\n    StringBuilder buff = new StringBuilder();\n    boolean isPath = false;\n    while (true) {\n        if (currentTokenType == IDENTIFIER) {\n            String name = readIdentifier();\n            buff.append(name);\n        } else if (readIf(\"*\")) {\n                        buff.append('*');\n            isPath = true;\n        } else if (readIf(\".\")) {\n            buff.append('.');\n            if (readIf(\".\")) {\n                buff.append('.');\n            }\n            isPath = true;\n        } else if (readIf(\"@\")) {\n            if (readIf(\"*\")) {\n                                buff.append('*');\n            } else {\n                buff.append(readIdentifier());\n            }\n            return new Expression.Property(currentSelector, buff.toString());\n        } else {\n            break;\n        }\n        if (readIf(\"/\")) {\n            isPath = true;\n            buff.append('/');\n        } else {\n            break;\n        }\n    }\n    if (!isPath && readIf(\"(\")) {\n        return parseFunction(buff.toString());\n    } else if (buff.length() > 0) {\n                if (buff.toString().equals(\".\")) {\n            buff = new StringBuilder(\"*\");\n        } else {\n            buff.append(\"/*\");\n        }\n        return new Expression.Property(currentSelector, buff.toString());\n    }\n    throw getSyntaxError();\n}", "lc": 1.4090909090909092, "pi": 0.4354066985645932, "ma": 2.2, "nbd": 2.0, "ml": 1.3333333333333333, "d": 0.7460317460317459, "mi": -0.7651867512332625, "fo": 1.5833333333333333, "r": -0.02631578947368421, "e": 1.095266909862093}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1104_7ae92779", "label": 1, "code": "private static int compare(MapEntry before, MapEntry after) {\n    if (before == null) {\n        // sentinel value appear greater than any normal value.\n        return 1;\n    } else if (after == null) {\n        // see above\n        return -1;\n    } else {\n        return ComparisonChain.start().compare(before.getHash(), after.getHash()).compare(before.getName(), after.getName()).result();\n    }\n}", "code_comment": NaN, "code_no_comment": "private static int compare(MapEntry before, MapEntry after) {\n    if (before == null) {\n                return 1;\n    } else if (after == null) {\n                return -1;\n    } else {\n        return ComparisonChain.start().compare(before.getHash(), after.getHash()).compare(before.getName(), after.getName()).result();\n    }\n}", "lc": -0.22727272727272727, "pi": -0.01913875598086126, "ma": -0.2, "nbd": 0.0, "ml": -0.08333333333333333, "d": 0.047619047619047616, "mi": 0.2704721634954192, "fo": 0.16666666666666666, "r": 0.0, "e": -0.060397757069668}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3861_d1e0e411", "label": 3, "code": "@Override\nprotected void onAfterRenderChildren() {\n    // Loop through child components\n    final Iterator<? extends Component> iter = iterator();\n    while (iter.hasNext()) {\n        // Get next child\n        final Component child = iter.next();\n        // Call end request on the child\n        child.afterRender();\n    }\n    super.onAfterRenderChildren();\n}", "code_comment": NaN, "code_no_comment": "@Override\nprotected void onAfterRenderChildren() {\n        final Iterator<? extends Component> iter = iterator();\n    while (iter.hasNext()) {\n                final Component child = iter.next();\n                child.afterRender();\n    }\n    super.onAfterRenderChildren();\n}", "lc": -0.22727272727272727, "pi": -0.01913875598086126, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": -0.3650793650793651, "mi": 0.35052854122621563, "fo": -0.08333333333333333, "r": 1.3157894736842106, "e": -0.16279340490885932}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1225_3535afe2", "label": 1, "code": "@Override\npublic Node perform() throws RepositoryException {\n    return NodeImpl.createNodeOrNull(sd.getNode(getOakPathOrThrow(absPath)), sessionContext);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic Node perform() throws RepositoryException {\n    return NodeImpl.createNodeOrNull(sd.getNode(getOakPathOrThrow(absPath)), sessionContext);\n}", "lc": -0.45454545454545453, "pi": -0.6028708133971293, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.7866102889358701, "fo": -0.25, "r": 0.2894736842105263, "e": -0.16279340490885932}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5359_61122bab", "label": 3, "code": "/**\n *  Convert this text to an enum.\n *\n *  @param defaultValue\n *             This will be returned if there is an error converting the value\n *  @return The value as an enum\n */\npublic final <T extends Enum<T>> T toEnum(final T defaultValue) {\n    Args.notNull(defaultValue, \"defaultValue\");\n    return toEnum((Class<T>) defaultValue.getClass(), defaultValue);\n}", "code_comment": "/**\n *  Convert this text to an enum.\n *\n *  @param defaultValue\n *             This will be returned if there is an error converting the value\n *  @return The value as an enum\n */\n", "code_no_comment": "public final <T extends Enum<T>> T toEnum(final T defaultValue) {\n    Args.notNull(defaultValue, \"defaultValue\");\n    return toEnum((Class<T>) defaultValue.getClass(), defaultValue);\n}", "lc": -0.45454545454545453, "pi": -0.47368421052631593, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.7451726568005637, "fo": -0.25, "r": 2.263157894736842, "e": -0.16279340490885932}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-470_50340d0c", "label": 3, "code": "@Override\n@SuppressWarnings(\"unchecked\")\npublic Map<String, String> getProperties() {\n    return (Map<String, String>) componentMap.get(CONTEXT_PROPERTIES);\n}", "code_comment": NaN, "code_no_comment": "@Override\n@SuppressWarnings(\"unchecked\")\npublic Map<String, String> getProperties() {\n    return (Map<String, String>) componentMap.get(CONTEXT_PROPERTIES);\n}", "lc": -0.4090909090909091, "pi": -0.6650717703349284, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.673291050035236, "fo": -0.4166666666666667, "r": 0.07894736842105263, "e": -0.16279340490885932}
{"project_name": "Math", "project_version": 54, "label": 3, "code": "/**\n * Convert the instance into a double.\n * @return a double approximating the instance\n * @see #toSplitDouble()\n */\npublic double toDouble() {\n    if (isInfinite()) {\n        if (lessThan(getZero())) {\n            return Double.NEGATIVE_INFINITY;\n        } else {\n            return Double.POSITIVE_INFINITY;\n        }\n    }\n    if (isNaN()) {\n        return Double.NaN;\n    }\n    Dfp y = this;\n    boolean negate = false;\n    if (lessThan(getZero())) {\n        y = negate();\n        negate = true;\n    }\n    /* Find the exponent, first estimate by integer log10, then adjust.\n         Should be faster than doing a natural logarithm.  */\n    int exponent = (int) (y.log10() * 3.32);\n    if (exponent < 0) {\n        exponent--;\n    }\n    Dfp tempDfp = DfpMath.pow(getTwo(), exponent);\n    while (tempDfp.lessThan(y) || tempDfp.equals(y)) {\n        tempDfp = tempDfp.multiply(2);\n        exponent++;\n    }\n    exponent--;\n    /* We have the exponent, now work on the mantissa */\n    y = y.divide(DfpMath.pow(getTwo(), exponent));\n    if (exponent > -1023) {\n        y = y.subtract(getOne());\n    }\n    if (exponent < -1074) {\n        return 0;\n    }\n    if (exponent > 1023) {\n        return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n    }\n    y = y.multiply(newInstance(4503599627370496l)).rint();\n    String str = y.toString();\n    str = str.substring(0, str.length() - 1);\n    long mantissa = Long.parseLong(str);\n    if (mantissa == 4503599627370496L) {\n        // Handle special case where we round up to next power of two\n        mantissa = 0;\n        exponent++;\n    }\n    /* Its going to be subnormal, so make adjustments */\n    if (exponent <= -1023) {\n        exponent--;\n    }\n    while (exponent < -1023) {\n        exponent++;\n        mantissa >>>= 1;\n    }\n    long bits = mantissa | ((exponent + 1023L) << 52);\n    double x = Double.longBitsToDouble(bits);\n    if (negate) {\n        x = -x;\n    }\n    return x;\n}", "code_comment": "/**\n * Convert the instance into a double.\n * @return a double approximating the instance\n * @see #toSplitDouble()\n */\n", "code_no_comment": "public double toDouble() {\n    if (isInfinite()) {\n        if (lessThan(getZero())) {\n            return Double.NEGATIVE_INFINITY;\n        } else {\n            return Double.POSITIVE_INFINITY;\n        }\n    }\n    if (isNaN()) {\n        return Double.NaN;\n    }\n    Dfp y = this;\n    boolean negate = false;\n    if (lessThan(getZero())) {\n        y = negate();\n        negate = true;\n    }\n        int exponent = (int) (y.log10() * 3.32);\n    if (exponent < 0) {\n        exponent--;\n    }\n    Dfp tempDfp = DfpMath.pow(getTwo(), exponent);\n    while (tempDfp.lessThan(y) || tempDfp.equals(y)) {\n        tempDfp = tempDfp.multiply(2);\n        exponent++;\n    }\n    exponent--;\n        y = y.divide(DfpMath.pow(getTwo(), exponent));\n    if (exponent > -1023) {\n        y = y.subtract(getOne());\n    }\n    if (exponent < -1074) {\n        return 0;\n    }\n    if (exponent > 1023) {\n        return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n    }\n    y = y.multiply(newInstance(4503599627370496l)).rint();\n    String str = y.toString();\n    str = str.substring(0, str.length() - 1);\n    long mantissa = Long.parseLong(str);\n    if (mantissa == 4503599627370496L) {\n                mantissa = 0;\n        exponent++;\n    }\n        if (exponent <= -1023) {\n        exponent--;\n    }\n    while (exponent < -1023) {\n        exponent++;\n        mantissa >>>= 1;\n    }\n    long bits = mantissa | ((exponent + 1023L) << 52);\n    double x = Double.longBitsToDouble(bits);\n    if (negate) {\n        x = -x;\n    }\n    return x;\n}", "lc": 2.0454545454545454, "pi": -0.2822966507177035, "ma": 2.2, "nbd": 0.0, "ml": 1.6666666666666667, "d": 2.9503968253968256, "mi": -0.9867512332628608, "fo": 1.6666666666666667, "r": -0.02631578947368421, "e": 7.160754482114761}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-442_246d53c5", "label": 1, "code": "/**\n *  Common functionality to be called by processEvents()\n *\n *  @param requestCycle\n *             The request cycle\n */\nprotected void onProcessEvents(final RequestCycle requestCycle) {\n    // Assume cluster needs to be updated now, unless listener\n    // invocation changes this\n    requestCycle.setUpdateSession(true);\n    // Clear all feedback messages if it isn't a redirect\n    getPage().getFeedbackMessages().clear();\n    getPage().startComponentRender(getTarget());\n    final Application application = requestCycle.getApplication();\n    // and see if we have to redirect the render part by default\n    IRequestCycleSettings.RenderStrategy strategy = application.getRequestCycleSettings().getRenderStrategy();\n    boolean issueRedirect = (strategy == IRequestCycleSettings.REDIRECT_TO_RENDER || strategy == IRequestCycleSettings.REDIRECT_TO_BUFFER);\n    requestCycle.setRedirect(issueRedirect);\n}", "code_comment": "/**\n *  Common functionality to be called by processEvents()\n *\n *  @param requestCycle\n *             The request cycle\n */\n", "code_no_comment": "protected void onProcessEvents(final RequestCycle requestCycle) {\n            requestCycle.setUpdateSession(true);\n        getPage().getFeedbackMessages().clear();\n    getPage().startComponentRender(getTarget());\n    final Application application = requestCycle.getApplication();\n        IRequestCycleSettings.RenderStrategy strategy = application.getRequestCycleSettings().getRenderStrategy();\n    boolean issueRedirect = (strategy == IRequestCycleSettings.REDIRECT_TO_RENDER || strategy == IRequestCycleSettings.REDIRECT_TO_BUFFER);\n    requestCycle.setRedirect(issueRedirect);\n}", "lc": -0.22727272727272727, "pi": -0.6363636363636366, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.08134920634920638, "mi": 0.20394644115574342, "fo": 0.4166666666666667, "r": 0.5789473684210527, "e": -0.04153224644571614}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1215_a9efe3c4", "label": 0, "code": "/**\n * Get the property value. The property name may be relative. The special\n * property names \"jcr:path\", \"jcr:score\" and \"rep:excerpt\" are supported.\n *\n * @param oakPropertyName (must already be normalized)\n * @return the property value or null if not found\n */\npublic PropertyValue currentOakProperty(String oakPropertyName) {\n    boolean relative = oakPropertyName.indexOf('/') >= 0;\n    Tree t = currentTree();\n    if (relative) {\n        for (String p : PathUtils.elements(PathUtils.getParentPath(oakPropertyName))) {\n            if (t == null) {\n                return null;\n            }\n            if (p.equals(\"..\")) {\n                t = t.isRoot() ? null : t.getParent();\n            } else if (p.equals(\".\")) {\n            // same node\n            } else {\n                t = t.getChild(p);\n            }\n        }\n        oakPropertyName = PathUtils.getName(oakPropertyName);\n    }\n    if (t == null || !t.exists()) {\n        return null;\n    }\n    if (oakPropertyName.equals(QueryImpl.JCR_PATH)) {\n        String path = currentPath();\n        String local = getLocalPath(path);\n        if (local == null) {\n            // not a local path\n            return null;\n        }\n        return PropertyValues.newString(local);\n    } else if (oakPropertyName.equals(QueryImpl.JCR_SCORE)) {\n        return currentRow.getValue(QueryImpl.JCR_SCORE);\n    } else if (oakPropertyName.equals(QueryImpl.REP_EXCERPT)) {\n        return currentRow.getValue(QueryImpl.REP_EXCERPT);\n    }\n    return PropertyValues.create(t.getProperty(oakPropertyName));\n}", "code_comment": "/**\n * Get the property value. The property name may be relative. The special\n * property names \"jcr:path\", \"jcr:score\" and \"rep:excerpt\" are supported.\n *\n * @param oakPropertyName (must already be normalized)\n * @return the property value or null if not found\n */\n", "code_no_comment": "public PropertyValue currentOakProperty(String oakPropertyName) {\n    boolean relative = oakPropertyName.indexOf('/') >= 0;\n    Tree t = currentTree();\n    if (relative) {\n        for (String p : PathUtils.elements(PathUtils.getParentPath(oakPropertyName))) {\n            if (t == null) {\n                return null;\n            }\n            if (p.equals(\"..\")) {\n                t = t.isRoot() ? null : t.getParent();\n            } else if (p.equals(\".\")) {\n                        } else {\n                t = t.getChild(p);\n            }\n        }\n        oakPropertyName = PathUtils.getName(oakPropertyName);\n    }\n    if (t == null || !t.exists()) {\n        return null;\n    }\n    if (oakPropertyName.equals(QueryImpl.JCR_PATH)) {\n        String path = currentPath();\n        String local = getLocalPath(path);\n        if (local == null) {\n                        return null;\n        }\n        return PropertyValues.newString(local);\n    } else if (oakPropertyName.equals(QueryImpl.JCR_SCORE)) {\n        return currentRow.getValue(QueryImpl.JCR_SCORE);\n    } else if (oakPropertyName.equals(QueryImpl.REP_EXCERPT)) {\n        return currentRow.getValue(QueryImpl.REP_EXCERPT);\n    }\n    return PropertyValues.create(t.getProperty(oakPropertyName));\n}", "lc": 0.9090909090909091, "pi": 0.5885167464114831, "ma": 1.6, "nbd": 1.0, "ml": 1.3333333333333333, "d": 0.5198412698412699, "mi": -0.6343904157857644, "fo": 1.25, "r": -0.02631578947368421, "e": 0.9601701215400839}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-209_76d727f0", "label": 1, "code": "@Override\npublic void init(SortedKeyValueIterator<Key, Value> source, Map<String, String> options, IteratorEnvironment env) throws IOException {\n    super.init(source, options, env);\n    if (options.containsKey(ROW_REGEX)) {\n        rowMatcher = Pattern.compile(options.get(ROW_REGEX)).matcher(\"\");\n    } else {\n        rowMatcher = null;\n    }\n    if (options.containsKey(COLF_REGEX)) {\n        colfMatcher = Pattern.compile(options.get(COLF_REGEX)).matcher(\"\");\n    } else {\n        colfMatcher = null;\n    }\n    if (options.containsKey(COLQ_REGEX)) {\n        colqMatcher = Pattern.compile(options.get(COLQ_REGEX)).matcher(\"\");\n    } else {\n        colqMatcher = null;\n    }\n    if (options.containsKey(VALUE_REGEX)) {\n        valueMatcher = Pattern.compile(options.get(VALUE_REGEX)).matcher(\"\");\n    } else {\n        valueMatcher = null;\n    }\n    if (options.containsKey(OR_FIELDS)) {\n        orFields = Boolean.parseBoolean(options.get(OR_FIELDS));\n    } else {\n        orFields = false;\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void init(SortedKeyValueIterator<Key, Value> source, Map<String, String> options, IteratorEnvironment env) throws IOException {\n    super.init(source, options, env);\n    if (options.containsKey(ROW_REGEX)) {\n        rowMatcher = Pattern.compile(options.get(ROW_REGEX)).matcher(\"\");\n    } else {\n        rowMatcher = null;\n    }\n    if (options.containsKey(COLF_REGEX)) {\n        colfMatcher = Pattern.compile(options.get(COLF_REGEX)).matcher(\"\");\n    } else {\n        colfMatcher = null;\n    }\n    if (options.containsKey(COLQ_REGEX)) {\n        colqMatcher = Pattern.compile(options.get(COLQ_REGEX)).matcher(\"\");\n    } else {\n        colqMatcher = null;\n    }\n    if (options.containsKey(VALUE_REGEX)) {\n        valueMatcher = Pattern.compile(options.get(VALUE_REGEX)).matcher(\"\");\n    } else {\n        valueMatcher = null;\n    }\n    if (options.containsKey(OR_FIELDS)) {\n        orFields = Boolean.parseBoolean(options.get(OR_FIELDS));\n    } else {\n        orFields = false;\n    }\n}", "lc": 0.6818181818181818, "pi": -0.23444976076555035, "ma": 0.4, "nbd": -0.5, "ml": 0.4166666666666667, "d": -0.3650793650793651, "mi": -0.49880197322057757, "fo": 1.1666666666666667, "r": -0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-107_88641f49", "label": 1, "code": "/**\n * Extract options.\n *\n * @param pattern conversion pattern.\n * @param i       start of options.\n * @param options array to receive extracted options\n * @return position in pattern after options.\n */\nprivate static int extractOptions(String pattern, int i, List<String> options) {\n    while ((i < pattern.length()) && (pattern.charAt(i) == '{')) {\n        int begin = i;\n        int end;\n        int depth = 0;\n        do {\n            end = pattern.indexOf('}', i);\n            if (end != -1) {\n                int next = pattern.indexOf(\"{\", i + 1);\n                if (next != -1 && next < end) {\n                    i = end + 1;\n                    ++depth;\n                } else if (depth > 0) {\n                    --depth;\n                }\n            }\n        } while (depth > 0);\n        if (end == -1) {\n            break;\n        }\n        String r = pattern.substring(begin + 1, end);\n        options.add(r);\n        i = end + 1;\n    }\n    return i;\n}", "code_comment": "/**\n * Extract options.\n *\n * @param pattern conversion pattern.\n * @param i       start of options.\n * @param options array to receive extracted options\n * @return position in pattern after options.\n */\n", "code_no_comment": "private static int extractOptions(String pattern, int i, List<String> options) {\n    while ((i < pattern.length()) && (pattern.charAt(i) == '{')) {\n        int begin = i;\n        int end;\n        int depth = 0;\n        do {\n            end = pattern.indexOf('}', i);\n            if (end != -1) {\n                int next = pattern.indexOf(\"{\", i + 1);\n                if (next != -1 && next < end) {\n                    i = end + 1;\n                    ++depth;\n                } else if (depth > 0) {\n                    --depth;\n                }\n            }\n        } while (depth > 0);\n        if (end == -1) {\n            break;\n        }\n        String r = pattern.substring(begin + 1, end);\n        options.add(r);\n        i = end + 1;\n    }\n    return i;\n}", "lc": 0.5454545454545454, "pi": 1.2344497607655505, "ma": 0.8, "nbd": 1.5, "ml": 0.75, "d": 2.5634920634920633, "mi": -0.4528541226215643, "fo": 0.0, "r": 0.0, "e": 2.804301447070417}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-1096_19c1c3bb", "label": 0, "code": "/**\n * Compute a dimension 4 minor, when 4<sup>th</sup> column is known to be filled with 1.0.\n * <p>\n * The computation is performed using {@link MathArrays#linearCombination(double[], double[])\n * high accuracy sum of products}, trying to avoid cancellations effect. This should reduce\n * risks in case of near co-planar points.\n * </p>\n * @param c1 first column\n * @param c2 second column\n * @param c3 third column\n * @return value of the minor computed to high accuracy\n */\nprivate double minor(final double[] c1, final double[] c2, final double[] c3) {\n    final double m01 = c2[0] * c3[1];\n    final double m02 = c2[0] * c3[2];\n    final double m03 = c2[0] * c3[3];\n    final double m10 = c2[1] * c3[0];\n    final double m12 = c2[1] * c3[2];\n    final double m13 = c2[1] * c3[3];\n    final double m20 = c2[2] * c3[0];\n    final double m21 = c2[2] * c3[1];\n    final double m23 = c2[2] * c3[3];\n    final double m30 = c2[3] * c3[0];\n    final double m31 = c2[3] * c3[1];\n    final double m32 = c2[3] * c3[2];\n    return MathArrays.linearCombination(new double[] { c1[2], c1[1], c1[3], -c1[1], -c1[3], -c1[2], c1[0], c1[3], c1[2], -c1[3], -c1[0], -c1[2], c1[1], c1[0], c1[3], -c1[0], -c1[3], -c1[1], c1[0], c1[2], c1[1], -c1[2], -c1[0], -c1[1] }, new double[] { m13, m32, m21, m23, m12, m31, m23, m02, m30, m20, m32, m03, m03, m31, m10, m13, m01, m30, m12, m01, m20, m10, m21, m02 });\n}", "code_comment": "/**\n * Compute a dimension 4 minor, when 4<sup>th</sup> column is known to be filled with 1.0.\n * <p>\n * The computation is performed using {@link MathArrays#linearCombination(double[], double[])\n * high accuracy sum of products}, trying to avoid cancellations effect. This should reduce\n * risks in case of near co-planar points.\n * </p>\n * @param c1 first column\n * @param c2 second column\n * @param c3 third column\n * @return value of the minor computed to high accuracy\n */\n", "code_no_comment": "private double minor(final double[] c1, final double[] c2, final double[] c3) {\n    final double m01 = c2[0] * c3[1];\n    final double m02 = c2[0] * c3[2];\n    final double m03 = c2[0] * c3[3];\n    final double m10 = c2[1] * c3[0];\n    final double m12 = c2[1] * c3[2];\n    final double m13 = c2[1] * c3[3];\n    final double m20 = c2[2] * c3[0];\n    final double m21 = c2[2] * c3[1];\n    final double m23 = c2[2] * c3[3];\n    final double m30 = c2[3] * c3[0];\n    final double m31 = c2[3] * c3[1];\n    final double m32 = c2[3] * c3[2];\n    return MathArrays.linearCombination(new double[] { c1[2], c1[1], c1[3], -c1[1], -c1[3], -c1[2], c1[0], c1[3], c1[2], -c1[3], -c1[0], -c1[2], c1[1], c1[0], c1[3], -c1[0], -c1[3], -c1[1], c1[0], c1[2], c1[1], -c1[2], -c1[0], -c1[1] }, new double[] { m13, m32, m21, m23, m12, m31, m23, m02, m30, m20, m32, m03, m03, m31, m10, m13, m01, m30, m12, m01, m20, m10, m21, m02 });\n}", "lc": 0.045454545454545456, "pi": -0.7799043062200958, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": 0.8333333333333334, "mi": -0.24961240310077526, "fo": -0.4166666666666667, "r": -0.02631578947368421, "e": 2.12911256721011}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4072_7d5b8645", "label": 1, "code": "/**\n *  return path for current url in original encoding\n *\n *  @return path string\n */\npublic String getPath() {\n    return getPath(getCharset());\n}", "code_comment": "/**\n *  return path for current url in original encoding\n *\n *  @return path string\n */\n", "code_no_comment": "public String getPath() {\n    return getPath(getCharset());\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.1319238900634248, "fo": -0.3333333333333333, "r": 2.6052631578947367, "e": -0.16279340490885932}
{"project_name": "Csv", "project_version": 5, "label": 1, "code": "/**\n * Outputs the record separator.\n *\n * @throws IOException\n *             If an I/O error occurs\n */\npublic void println() throws IOException {\n    final String recordSeparator = format.getRecordSeparator();\n    out.append(recordSeparator);\n    newRecord = true;\n}", "code_comment": "/**\n * Outputs the record separator.\n *\n * @throws IOException\n *             If an I/O error occurs\n */\n", "code_no_comment": "public void println() throws IOException {\n    final String recordSeparator = format.getRecordSeparator();\n    out.append(recordSeparator);\n    newRecord = true;\n}", "lc": -0.4090909090909091, "pi": -0.49282296650717716, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.6620155038759689, "fo": -0.3333333333333333, "r": 2.5789473684210527, "e": -0.16279340490885932}
{"project_name": "Math", "project_version": 20, "label": 1, "code": "/**\n * @param x Normalized objective variables.\n * @return the original objective variables, possibly repaired.\n */\npublic double[] repairAndDecode(final double[] x) {\n    return decode(x);\n}", "code_comment": "/**\n * @param x Normalized objective variables.\n * @return the original objective variables, possibly repaired.\n */\n", "code_no_comment": "public double[] repairAndDecode(final double[] x) {\n    return decode(x);\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.1319238900634248, "fo": -0.4166666666666667, "r": 2.6052631578947367, "e": -0.16279340490885932}
{"project_name": "Math", "project_version": 63, "label": 3, "code": "/**\n * Returns true iff they are equal as defined by\n * {@link #equals(double,double,int) equals(x, y, 1)}.\n *\n * @param x first value\n * @param y second value\n * @return {@code true} if the values are equal.\n */\npublic static boolean equals(double x, double y) {\n    return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n}", "code_comment": "/**\n * Returns true iff they are equal as defined by\n * {@link #equals(double,double,int) equals(x, y, 1)}.\n *\n * @param x first value\n * @param y second value\n * @return {@code true} if the values are equal.\n */\n", "code_no_comment": "public static boolean equals(double x, double y) {\n    return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": 0.03174603174603173, "mi": 0.9033121916842841, "fo": -0.3333333333333333, "r": 2.4473684210526314, "e": -0.11894907303354596}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4309_b4274415", "label": 1, "code": "/**\n *  Convert to object types, returning null if text is null.\n *\n *  @return converted\n *  @throws StringValueConversionException\n */\npublic final Boolean toOptionalBoolean() throws StringValueConversionException {\n    return (text == null) ? null : toBooleanObject();\n}", "code_comment": "/**\n *  Convert to object types, returning null if text is null.\n *\n *  @return converted\n *  @throws StringValueConversionException\n */\n", "code_no_comment": "public final Boolean toOptionalBoolean() throws StringValueConversionException {\n    return (text == null) ? null : toBooleanObject();\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.4, "nbd": -1.0, "ml": -0.25, "d": -0.3650793650793651, "mi": 0.9797040169133189, "fo": -0.4166666666666667, "r": 2.6052631578947367, "e": -0.16279340490885932}
{"project_name": "Closure", "project_version": 108, "label": 2, "code": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, n.getParent());\n    }\n    if (t.getScopeDepth() < 2) {\n        return;\n    }\n    int type = n.getType();\n    Var aliasVar = null;\n    if (type == Token.NAME) {\n        String name = n.getString();\n        Var lexicalVar = t.getScope().getVar(n.getString());\n        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n            aliasVar = lexicalVar;\n        }\n    }\n    // Validate the top-level of the goog.scope block.\n    if (t.getScopeDepth() == 2) {\n        if (aliasVar != null && NodeUtil.isLValue(n)) {\n            if (aliasVar.getNode() == n) {\n                aliasDefinitionsInOrder.add(n);\n                // twice.\n                return;\n            } else {\n                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n            }\n        }\n        if (type == Token.RETURN) {\n            report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n            report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n    }\n    // Validate all descendent scopes of the goog.scope block.\n    if (t.getScopeDepth() >= 2) {\n        // Check if this name points to an alias.\n        if (aliasVar != null) {\n            // Note, to support the transitive case, it's important we don't\n            // clone aliasedNode here.  For example,\n            // var g = goog; var d = g.dom; d.createElement('DIV');\n            // The node in aliasedNode (which is \"g\") will be replaced in the\n            // changes pass above with \"goog\".  If we cloned here, we'd end up\n            // with <code>g.dom.createElement('DIV')</code>.\n            aliasUsages.add(new AliasedNode(aliasVar, n));\n        }\n        // When we inject declarations, we duplicate jsdoc. Make sure\n        // we only process that jsdoc once.\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n            for (Node node : info.getTypeNodes()) {\n                fixTypeNode(node);\n            }\n        }\n    // TODO(robbyw): Error for goog.scope not at root.\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, n.getParent());\n    }\n    if (t.getScopeDepth() < 2) {\n        return;\n    }\n    int type = n.getType();\n    Var aliasVar = null;\n    if (type == Token.NAME) {\n        String name = n.getString();\n        Var lexicalVar = t.getScope().getVar(n.getString());\n        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n            aliasVar = lexicalVar;\n        }\n    }\n        if (t.getScopeDepth() == 2) {\n        if (aliasVar != null && NodeUtil.isLValue(n)) {\n            if (aliasVar.getNode() == n) {\n                aliasDefinitionsInOrder.add(n);\n                                return;\n            } else {\n                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n            }\n        }\n        if (type == Token.RETURN) {\n            report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n            report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n    }\n        if (t.getScopeDepth() >= 2) {\n                if (aliasVar != null) {\n                                                                                    aliasUsages.add(new AliasedNode(aliasVar, n));\n        }\n                        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n            for (Node node : info.getTypeNodes()) {\n                fixTypeNode(node);\n            }\n        }\n        }\n}", "lc": 1.4545454545454546, "pi": 0.5645933014354066, "ma": 2.2, "nbd": 1.0, "ml": 1.75, "d": 0.9702380952380953, "mi": -0.8398872445384071, "fo": 1.5, "r": -0.02631578947368421, "e": 2.188747313036312}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3510_292a2582", "label": 1, "code": "/**\n *  Creates a new DateTextField defaulting to using a short date pattern\n *\n *  @param id\n *             The id of the text field\n *  @param model\n *             The model\n *  @return DateTextField\n */\npublic static DateTextField forShortStyle(String id, IModel<Date> model) {\n    return new DateTextField(id, model, new StyleDateConverter(true));\n}", "code_comment": "/**\n *  Creates a new DateTextField defaulting to using a short date pattern\n *\n *  @param id\n *             The id of the text field\n *  @param model\n *             The model\n *  @return DateTextField\n */\n", "code_no_comment": "public static DateTextField forShortStyle(String id, IModel<Date> model) {\n    return new DateTextField(id, model, new StyleDateConverter(true));\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.917406624383368, "fo": -0.5, "r": 2.5789473684210527, "e": -0.16279340490885932}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-479_3270e761", "label": 1, "code": "void checkProtected() throws RepositoryException {\n    ItemDefinition definition = (isNode()) ? ((Node) this).getDefinition() : ((Property) this).getDefinition();\n    checkProtected(definition);\n}", "code_comment": NaN, "code_no_comment": "void checkProtected() throws RepositoryException {\n    ItemDefinition definition = (isNode()) ? ((Node) this).getDefinition() : ((Property) this).getDefinition();\n    checkProtected(definition);\n}", "lc": -0.45454545454545453, "pi": -0.47368421052631593, "ma": -0.4, "nbd": -1.0, "ml": -0.25, "d": -0.3650793650793651, "mi": 0.7795630725863283, "fo": -0.16666666666666666, "r": 2.026315789473684, "e": -0.16279340490885932}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5500_825da305", "label": 1, "code": "/**\n *  Loads page class with given name.\n *\n *  @param name\n *  @return class\n */\nprotected Class<? extends IRequestablePage> getPageClass(String name) {\n    Args.notEmpty(name, \"name\");\n    return WicketObjects.resolveClass(name);\n}", "code_comment": "/**\n *  Loads page class with given name.\n *\n *  @param name\n *  @return class\n */\n", "code_no_comment": "protected Class<? extends IRequestablePage> getPageClass(String name) {\n    Args.notEmpty(name, \"name\");\n    return WicketObjects.resolveClass(name);\n}", "lc": -0.45454545454545453, "pi": -0.47368421052631593, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.7860465116279065, "fo": -0.3333333333333333, "r": 2.4736842105263155, "e": -0.16279340490885932}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2420_24cb1908", "label": 0, "code": "@Override\npublic NodeDocument apply(String name) {\n    String p = concat(path, name);\n    NodeDocument doc = store.find(Collection.NODES, Utils.getIdFromPath(p));\n    if (doc == null) {\n        docChildrenCache.invalidateAll();\n        throw new NullPointerException(\"Document \" + p + \" not found\");\n    }\n    return doc;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic NodeDocument apply(String name) {\n    String p = concat(path, name);\n    NodeDocument doc = store.find(Collection.NODES, Utils.getIdFromPath(p));\n    if (doc == null) {\n        docChildrenCache.invalidateAll();\n        throw new NullPointerException(\"Document \" + p + \" not found\");\n    }\n    return doc;\n}", "lc": -0.18181818181818182, "pi": -0.0909090909090911, "ma": -0.2, "nbd": -0.5, "ml": -0.25, "d": -0.10317460317460318, "mi": 0.1689922480620156, "fo": -0.16666666666666666, "r": 0.894736842105263, "e": -0.06965992980757595}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-2754_68912126", "label": 1, "code": "/**\n *  Writes a subset of the records in this buffer in their logical order to the given output.\n *\n *  @param output The output view to write the records to.\n *  @param start The logical start position of the subset.\n *  @param num The number of elements to write.\n *  @throws IOException Thrown, if an I/O exception occurred writing to the output view.\n */\n@Override\npublic void writeToOutput(final ChannelWriterOutputView output, final int start, int num) throws IOException {\n    final TypeComparator<T> comparator = this.comparator;\n    final TypeSerializer<T> serializer = this.serializer;\n    T record = this.recordInstance;\n    final SingleSegmentInputView inView = this.inView;\n    final int recordsPerSegment = this.recordsPerSegment;\n    int currentMemSeg = start / recordsPerSegment;\n    int offset = (start % recordsPerSegment) * this.recordSize;\n    while (num > 0) {\n        final MemorySegment currentIndexSegment = this.sortBuffer.get(currentMemSeg++);\n        inView.set(currentIndexSegment, offset);\n        // check whether we have a full or partially full segment\n        if (num >= recordsPerSegment && offset == 0) {\n            // full segment\n            for (int numInMemSeg = 0; numInMemSeg < recordsPerSegment; numInMemSeg++) {\n                record = comparator.readWithKeyDenormalization(record, inView);\n                serializer.serialize(record, output);\n            }\n            num -= recordsPerSegment;\n        } else {\n            // partially filled segment\n            for (; num > 0; num--) {\n                record = comparator.readWithKeyDenormalization(record, inView);\n                serializer.serialize(record, output);\n            }\n        }\n    }\n}", "code_comment": "/**\n *  Writes a subset of the records in this buffer in their logical order to the given output.\n *\n *  @param output The output view to write the records to.\n *  @param start The logical start position of the subset.\n *  @param num The number of elements to write.\n *  @throws IOException Thrown, if an I/O exception occurred writing to the output view.\n */\n", "code_no_comment": "@Override\npublic void writeToOutput(final ChannelWriterOutputView output, final int start, int num) throws IOException {\n    final TypeComparator<T> comparator = this.comparator;\n    final TypeSerializer<T> serializer = this.serializer;\n    T record = this.recordInstance;\n    final SingleSegmentInputView inView = this.inView;\n    final int recordsPerSegment = this.recordsPerSegment;\n    int currentMemSeg = start / recordsPerSegment;\n    int offset = (start % recordsPerSegment) * this.recordSize;\n    while (num > 0) {\n        final MemorySegment currentIndexSegment = this.sortBuffer.get(currentMemSeg++);\n        inView.set(currentIndexSegment, offset);\n                if (num >= recordsPerSegment && offset == 0) {\n                        for (int numInMemSeg = 0; numInMemSeg < recordsPerSegment; numInMemSeg++) {\n                record = comparator.readWithKeyDenormalization(record, inView);\n                serializer.serialize(record, output);\n            }\n            num -= recordsPerSegment;\n        } else {\n                        for (; num > 0; num--) {\n                record = comparator.readWithKeyDenormalization(record, inView);\n                serializer.serialize(record, output);\n            }\n        }\n    }\n}", "lc": 0.5454545454545454, "pi": 0.9952153110047848, "ma": 0.2, "nbd": 0.5, "ml": 0.3333333333333333, "d": 2.5714285714285716, "mi": -0.4615926708949964, "fo": 0.0, "r": -0.02631578947368421, "e": 3.442962604380975}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-3251_117ba95f", "label": 1, "code": "@Override\npublic Option<OperatorCheckpointStats> getOperatorStats(JobVertexID operatorId) {\n    synchronized (statsLock) {\n        OperatorCheckpointStats stats = operatorStatsCache.get(operatorId);\n        if (stats != null) {\n            return Option.apply(stats);\n        } else if (latestCompletedCheckpoint != null && subTaskStats != null) {\n            long[][] subTaskStats = this.subTaskStats.get(operatorId);\n            if (subTaskStats == null) {\n                throw new IllegalArgumentException(\"Unknown operator ID.\");\n            }\n            long maxDuration = Long.MIN_VALUE;\n            long stateSize = 0;\n            for (long[] subTaskStat : subTaskStats) {\n                if (subTaskStat[0] > maxDuration) {\n                    maxDuration = subTaskStat[0];\n                }\n                stateSize += subTaskStat[1];\n            }\n            stats = new OperatorCheckpointStats(latestCompletedCheckpoint.getCheckpointID(), latestCompletedCheckpoint.getTimestamp(), maxDuration, stateSize, subTaskStats);\n            // Remember this and don't recompute if requested again\n            operatorStatsCache.put(operatorId, stats);\n            return Option.apply(stats);\n        } else {\n            return Option.empty();\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic Option<OperatorCheckpointStats> getOperatorStats(JobVertexID operatorId) {\n    synchronized (statsLock) {\n        OperatorCheckpointStats stats = operatorStatsCache.get(operatorId);\n        if (stats != null) {\n            return Option.apply(stats);\n        } else if (latestCompletedCheckpoint != null && subTaskStats != null) {\n            long[][] subTaskStats = this.subTaskStats.get(operatorId);\n            if (subTaskStats == null) {\n                throw new IllegalArgumentException(\"Unknown operator ID.\");\n            }\n            long maxDuration = Long.MIN_VALUE;\n            long stateSize = 0;\n            for (long[] subTaskStat : subTaskStats) {\n                if (subTaskStat[0] > maxDuration) {\n                    maxDuration = subTaskStat[0];\n                }\n                stateSize += subTaskStat[1];\n            }\n            stats = new OperatorCheckpointStats(latestCompletedCheckpoint.getCheckpointID(), latestCompletedCheckpoint.getTimestamp(), maxDuration, stateSize, subTaskStats);\n                        operatorStatsCache.put(operatorId, stats);\n            return Option.apply(stats);\n        } else {\n            return Option.empty();\n        }\n    }\n}", "lc": 0.5909090909090909, "pi": 0.9760765550239235, "ma": 0.6, "nbd": 1.5, "ml": 0.3333333333333333, "d": 0.9960317460317462, "mi": -0.44806201550387575, "fo": 0.16666666666666666, "r": -0.02631578947368421, "e": 1.0756268621450755}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-8146_17475d80", "label": 3, "code": "@Override\nprotected void doStop() throws Exception {\n    if (future != null) {\n        LOG.debug(\"This consumer is stopping, so cancelling scheduled task: \" + future);\n        future.cancel(false);\n        future = null;\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\nprotected void doStop() throws Exception {\n    if (future != null) {\n        LOG.debug(\"This consumer is stopping, so cancelling scheduled task: \" + future);\n        future.cancel(false);\n        future = null;\n    }\n}", "lc": -0.2727272727272727, "pi": 0.22488038277511951, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": -0.09523809523809523, "mi": 0.3953488372093024, "fo": -0.3333333333333333, "r": 1.0263157894736843, "e": -0.11970977910709242}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-1129_d4f978dd", "label": 1, "code": "/**\n * Sort in place a (small) array slice using insertion sort\n * @param work array to sort\n * @param begin index of the first element of the slice to sort\n * @param end index after the last element of the slice to sort\n */\nprivate void insertionSort(final double[] work, final int begin, final int end) {\n    for (int j = begin + 1; j < end; j++) {\n        final double saved = work[j];\n        int i = j - 1;\n        while ((i >= begin) && (saved < work[i])) {\n            work[i + 1] = work[i];\n            i--;\n        }\n        work[i + 1] = saved;\n    }\n}", "code_comment": "/**\n * Sort in place a (small) array slice using insertion sort\n * @param work array to sort\n * @param begin index of the first element of the slice to sort\n * @param end index after the last element of the slice to sort\n */\n", "code_no_comment": "private void insertionSort(final double[] work, final int begin, final int end) {\n    for (int j = begin + 1; j < end; j++) {\n        final double saved = work[j];\n        int i = j - 1;\n        while ((i >= begin) && (saved < work[i])) {\n            work[i + 1] = work[i];\n            i--;\n        }\n        work[i + 1] = saved;\n    }\n}", "lc": -0.13636363636363635, "pi": 0.4449760765550238, "ma": -0.2, "nbd": 0.0, "ml": 0.25, "d": 2.4563492063492065, "mi": 0.09231853417899943, "fo": -0.5, "r": 1.1842105263157894, "e": 1.0968620874466206}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-2447_5546a1ef", "label": 1, "code": "@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\nprivate <OUT, IN1, IN2> TypeInformation<OUT> privateGetForClass(Class<OUT> clazz, ArrayList<Type> typeHierarchy, ParameterizedType parameterizedType, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {\n    Preconditions.checkNotNull(clazz);\n    if (clazz.equals(Object.class)) {\n        return new GenericTypeInfo<OUT>(clazz);\n    }\n    // check for arrays\n    if (clazz.isArray()) {\n        // primitive arrays: int[], byte[], ...\n        PrimitiveArrayTypeInfo<OUT> primitiveArrayInfo = PrimitiveArrayTypeInfo.getInfoFor(clazz);\n        if (primitiveArrayInfo != null) {\n            return primitiveArrayInfo;\n        }\n        // basic type arrays: String[], Integer[], Double[]\n        BasicArrayTypeInfo<OUT, ?> basicArrayInfo = BasicArrayTypeInfo.getInfoFor(clazz);\n        if (basicArrayInfo != null) {\n            return basicArrayInfo;\n        } else // object arrays\n        {\n            return ObjectArrayTypeInfo.getInfoFor(clazz);\n        }\n    }\n    // check for writable types\n    if (Writable.class.isAssignableFrom(clazz) && !Writable.class.equals(clazz)) {\n        return (TypeInformation<OUT>) WritableTypeInfo.getWritableTypeInfo((Class<? extends Writable>) clazz);\n    }\n    // check for basic types\n    TypeInformation<OUT> basicTypeInfo = BasicTypeInfo.getInfoFor(clazz);\n    if (basicTypeInfo != null) {\n        return basicTypeInfo;\n    }\n    // check for subclasses of Value\n    if (Value.class.isAssignableFrom(clazz)) {\n        Class<? extends Value> valueClass = clazz.asSubclass(Value.class);\n        return (TypeInformation<OUT>) ValueTypeInfo.getValueTypeInfo(valueClass);\n    }\n    // check for subclasses of Tuple\n    if (Tuple.class.isAssignableFrom(clazz)) {\n        throw new InvalidTypesException(\"Type information extraction for tuples cannot be done based on the class.\");\n    }\n    // check for Enums\n    if (Enum.class.isAssignableFrom(clazz)) {\n        return (TypeInformation<OUT>) new EnumTypeInfo(clazz);\n    }\n    // special case for POJOs generated by Avro.\n    if (SpecificRecordBase.class.isAssignableFrom(clazz)) {\n        return (TypeInformation<OUT>) new AvroTypeInfo(clazz);\n    }\n    if (alreadySeen.contains(clazz)) {\n        return new GenericTypeInfo<OUT>(clazz);\n    }\n    alreadySeen.add(clazz);\n    if (Modifier.isInterface(clazz.getModifiers())) {\n        // Interface has no members and is therefore not handled as POJO\n        return new GenericTypeInfo<OUT>(clazz);\n    }\n    if (clazz.equals(Class.class)) {\n        // special case handling for Class, this should not be handled by the POJO logic\n        return new GenericTypeInfo<OUT>(clazz);\n    }\n    try {\n        TypeInformation<OUT> pojoType = analyzePojo(clazz, new ArrayList<Type>(typeHierarchy), parameterizedType, in1Type, in2Type);\n        if (pojoType != null) {\n            return pojoType;\n        }\n    } catch (InvalidTypesException e) {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Unable to handle type \" + clazz + \" as POJO. Message: \" + e.getMessage(), e);\n        }\n    // ignore and create generic type info\n    }\n    // return a generic type\n    return new GenericTypeInfo<OUT>(clazz);\n}", "code_comment": NaN, "code_no_comment": "@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\nprivate <OUT, IN1, IN2> TypeInformation<OUT> privateGetForClass(Class<OUT> clazz, ArrayList<Type> typeHierarchy, ParameterizedType parameterizedType, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {\n    Preconditions.checkNotNull(clazz);\n    if (clazz.equals(Object.class)) {\n        return new GenericTypeInfo<OUT>(clazz);\n    }\n        if (clazz.isArray()) {\n                PrimitiveArrayTypeInfo<OUT> primitiveArrayInfo = PrimitiveArrayTypeInfo.getInfoFor(clazz);\n        if (primitiveArrayInfo != null) {\n            return primitiveArrayInfo;\n        }\n                BasicArrayTypeInfo<OUT, ?> basicArrayInfo = BasicArrayTypeInfo.getInfoFor(clazz);\n        if (basicArrayInfo != null) {\n            return basicArrayInfo;\n        } else         {\n            return ObjectArrayTypeInfo.getInfoFor(clazz);\n        }\n    }\n        if (Writable.class.isAssignableFrom(clazz) && !Writable.class.equals(clazz)) {\n        return (TypeInformation<OUT>) WritableTypeInfo.getWritableTypeInfo((Class<? extends Writable>) clazz);\n    }\n        TypeInformation<OUT> basicTypeInfo = BasicTypeInfo.getInfoFor(clazz);\n    if (basicTypeInfo != null) {\n        return basicTypeInfo;\n    }\n        if (Value.class.isAssignableFrom(clazz)) {\n        Class<? extends Value> valueClass = clazz.asSubclass(Value.class);\n        return (TypeInformation<OUT>) ValueTypeInfo.getValueTypeInfo(valueClass);\n    }\n        if (Tuple.class.isAssignableFrom(clazz)) {\n        throw new InvalidTypesException(\"Type information extraction for tuples cannot be done based on the class.\");\n    }\n        if (Enum.class.isAssignableFrom(clazz)) {\n        return (TypeInformation<OUT>) new EnumTypeInfo(clazz);\n    }\n        if (SpecificRecordBase.class.isAssignableFrom(clazz)) {\n        return (TypeInformation<OUT>) new AvroTypeInfo(clazz);\n    }\n    if (alreadySeen.contains(clazz)) {\n        return new GenericTypeInfo<OUT>(clazz);\n    }\n    alreadySeen.add(clazz);\n    if (Modifier.isInterface(clazz.getModifiers())) {\n                return new GenericTypeInfo<OUT>(clazz);\n    }\n    if (clazz.equals(Class.class)) {\n                return new GenericTypeInfo<OUT>(clazz);\n    }\n    try {\n        TypeInformation<OUT> pojoType = analyzePojo(clazz, new ArrayList<Type>(typeHierarchy), parameterizedType, in1Type, in2Type);\n        if (pojoType != null) {\n            return pojoType;\n        }\n    } catch (InvalidTypesException e) {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Unable to handle type \" + clazz + \" as POJO. Message: \" + e.getMessage(), e);\n        }\n        }\n        return new GenericTypeInfo<OUT>(clazz);\n}", "lc": 2.1363636363636362, "pi": -0.06220095693779921, "ma": 2.8, "nbd": 0.0, "ml": 2.4166666666666665, "d": 0.6388888888888888, "mi": -1.0377730796335445, "fo": 1.5833333333333333, "r": -0.02631578947368421, "e": 2.3179613077228955}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-1103_a6f96306", "label": 1, "code": "/**\n * {@inheritDoc}\n */\npublic Evaluation evaluate(final RealVector point) {\n    // evaluate value and jacobian in one function call\n    final Pair<RealVector, RealMatrix> value = this.model.value(point);\n    return new UnweightedEvaluation(value.getFirst(), value.getSecond(), this.target, point);\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "public Evaluation evaluate(final RealVector point) {\n        final Pair<RealVector, RealMatrix> value = this.model.value(point);\n    return new UnweightedEvaluation(value.getFirst(), value.getSecond(), this.target, point);\n}", "lc": -0.45454545454545453, "pi": -0.47368421052631593, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.702889358703312, "fo": -0.25, "r": 1.131578947368421, "e": -0.16279340490885932}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-2172_ea4a3f8a", "label": 3, "code": "/**\n *  @see IValueMap#getAsEnum(String, Class<T>)\n */\npublic <T extends Enum<T>> T getAsEnum(String key, Class<T> eClass) {\n    return getEnumImpl(key, eClass, null);\n}", "code_comment": "/**\n *  @see IValueMap#getAsEnum(String, Class<T>)\n */\n", "code_no_comment": "public <T extends Enum<T>> T getAsEnum(String key, Class<T> eClass) {\n    return getEnumImpl(key, eClass, null);\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.8965468639887244, "fo": -0.4166666666666667, "r": 1.7631578947368423, "e": -0.16279340490885932}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-8125_36e7b668", "label": 3, "code": "/**\n * Inspects the given definition and resolves any property placeholders from its properties.\n * <p/>\n * This implementation will check all the getter/setter pairs on this instance and for all the values\n * (which is a String type) will be property placeholder resolved.\n *\n * @param routeContext the route context\n * @param definition   the definition\n * @throws Exception is thrown if property placeholders was used and there was an error resolving them\n * @see org.apache.camel.CamelContext#resolvePropertyPlaceholders(String)\n * @see org.apache.camel.component.properties.PropertiesComponent\n */\npublic static void resolvePropertyPlaceholders(RouteContext routeContext, Object definition) throws Exception {\n    LOG.trace(\"Resolving property placeholders for: {}\", definition);\n    // find all getter/setter which we can use for property placeholders\n    Map<String, Object> properties = new HashMap<String, Object>();\n    IntrospectionSupport.getProperties(definition, properties, null);\n    ProcessorDefinition<?> processorDefinition = null;\n    if (definition instanceof ProcessorDefinition) {\n        processorDefinition = (ProcessorDefinition<?>) definition;\n    }\n    // and when the definition parameter is this (otherAttributes belong to this)\n    if (processorDefinition != null && processorDefinition.getOtherAttributes() != null) {\n        for (QName key : processorDefinition.getOtherAttributes().keySet()) {\n            if (Constants.PLACEHOLDER_QNAME.equals(key.getNamespaceURI())) {\n                String local = key.getLocalPart();\n                Object value = processorDefinition.getOtherAttributes().get(key);\n                if (value != null && value instanceof String) {\n                    // value must be enclosed with placeholder tokens\n                    String s = (String) value;\n                    String prefixToken = routeContext.getCamelContext().getPropertyPrefixToken();\n                    String suffixToken = routeContext.getCamelContext().getPropertySuffixToken();\n                    if (prefixToken == null) {\n                        throw new IllegalArgumentException(\"Property with name [\" + local + \"] uses property placeholders; however, no properties component is configured.\");\n                    }\n                    if (!s.startsWith(prefixToken)) {\n                        s = prefixToken + s;\n                    }\n                    if (!s.endsWith(suffixToken)) {\n                        s = s + suffixToken;\n                    }\n                    value = s;\n                }\n                properties.put(local, value);\n            }\n        }\n    }\n    if (!properties.isEmpty()) {\n        LOG.trace(\"There are {} properties on: {}\", properties.size(), definition);\n        // lookup and resolve properties for String based properties\n        for (Map.Entry<String, Object> entry : properties.entrySet()) {\n            // the name is always a String\n            String name = entry.getKey();\n            Object value = entry.getValue();\n            if (value instanceof String) {\n                // value must be a String, as a String is the key for a property placeholder\n                String text = (String) value;\n                text = routeContext.getCamelContext().resolvePropertyPlaceholders(text);\n                if (text != value) {\n                    // invoke setter as the text has changed\n                    boolean changed = IntrospectionSupport.setProperty(routeContext.getCamelContext().getTypeConverter(), definition, name, text);\n                    if (!changed) {\n                        throw new IllegalArgumentException(\"No setter to set property: \" + name + \" to: \" + text + \" on: \" + definition);\n                    }\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Changed property [{}] from: {} to: {}\", new Object[] { name, value, text });\n                    }\n                }\n            }\n        }\n    }\n}", "code_comment": "/**\n * Inspects the given definition and resolves any property placeholders from its properties.\n * <p/>\n * This implementation will check all the getter/setter pairs on this instance and for all the values\n * (which is a String type) will be property placeholder resolved.\n *\n * @param routeContext the route context\n * @param definition   the definition\n * @throws Exception is thrown if property placeholders was used and there was an error resolving them\n * @see org.apache.camel.CamelContext#resolvePropertyPlaceholders(String)\n * @see org.apache.camel.component.properties.PropertiesComponent\n */\n", "code_no_comment": "public static void resolvePropertyPlaceholders(RouteContext routeContext, Object definition) throws Exception {\n    LOG.trace(\"Resolving property placeholders for: {}\", definition);\n        Map<String, Object> properties = new HashMap<String, Object>();\n    IntrospectionSupport.getProperties(definition, properties, null);\n    ProcessorDefinition<?> processorDefinition = null;\n    if (definition instanceof ProcessorDefinition) {\n        processorDefinition = (ProcessorDefinition<?>) definition;\n    }\n        if (processorDefinition != null && processorDefinition.getOtherAttributes() != null) {\n        for (QName key : processorDefinition.getOtherAttributes().keySet()) {\n            if (Constants.PLACEHOLDER_QNAME.equals(key.getNamespaceURI())) {\n                String local = key.getLocalPart();\n                Object value = processorDefinition.getOtherAttributes().get(key);\n                if (value != null && value instanceof String) {\n                                        String s = (String) value;\n                    String prefixToken = routeContext.getCamelContext().getPropertyPrefixToken();\n                    String suffixToken = routeContext.getCamelContext().getPropertySuffixToken();\n                    if (prefixToken == null) {\n                        throw new IllegalArgumentException(\"Property with name [\" + local + \"] uses property placeholders; however, no properties component is configured.\");\n                    }\n                    if (!s.startsWith(prefixToken)) {\n                        s = prefixToken + s;\n                    }\n                    if (!s.endsWith(suffixToken)) {\n                        s = s + suffixToken;\n                    }\n                    value = s;\n                }\n                properties.put(local, value);\n            }\n        }\n    }\n    if (!properties.isEmpty()) {\n        LOG.trace(\"There are {} properties on: {}\", properties.size(), definition);\n                for (Map.Entry<String, Object> entry : properties.entrySet()) {\n                        String name = entry.getKey();\n            Object value = entry.getValue();\n            if (value instanceof String) {\n                                String text = (String) value;\n                text = routeContext.getCamelContext().resolvePropertyPlaceholders(text);\n                if (text != value) {\n                                        boolean changed = IntrospectionSupport.setProperty(routeContext.getCamelContext().getTypeConverter(), definition, name, text);\n                    if (!changed) {\n                        throw new IllegalArgumentException(\"No setter to set property: \" + name + \" to: \" + text + \" on: \" + definition);\n                    }\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Changed property [{}] from: {} to: {}\", new Object[] { name, value, text });\n                    }\n                }\n            }\n        }\n    }\n}", "lc": 1.7727272727272727, "pi": 1.9856459330143539, "ma": 2.6, "nbd": 1.5, "ml": 1.9166666666666667, "d": 1.1706349206349207, "mi": -0.9802677942212825, "fo": 2.0, "r": -0.02631578947368421, "e": 3.9872454948335374}
{"project_name": "Lang", "project_version": 63, "label": 1, "code": "/**\n * <p>Formats the time gap as a string, using the specified format.\n * Padding the left hand side of numbers with zeroes is optional and\n * the timezone may be specified.\n *\n * @param startMillis  the start of the duration\n * @param endMillis  the end of the duration\n * @param format  the way in which to format the duration\n * @param padWithZeros whether to pad the left hand side of numbers with 0's\n * @param timezone the millis are defined in\n * @return the time as a String\n */\npublic static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n    long millis = endMillis - startMillis;\n    if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n        return formatDuration(millis, format, padWithZeros);\n    }\n    Token[] tokens = lexx(format);\n    // timezones get funky around 0, so normalizing everything to GMT\n    // stops the hours being off\n    Calendar start = Calendar.getInstance(timezone);\n    start.setTime(new Date(startMillis));\n    Calendar end = Calendar.getInstance(timezone);\n    end.setTime(new Date(endMillis));\n    // initial estimates\n    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n    // each initial estimate is adjusted in case it is under 0\n    while (milliseconds < 0) {\n        milliseconds += 1000;\n        seconds -= 1;\n    }\n    while (seconds < 0) {\n        seconds += 60;\n        minutes -= 1;\n    }\n    while (minutes < 0) {\n        minutes += 60;\n        hours -= 1;\n    }\n    while (hours < 0) {\n        hours += 24;\n        days -= 1;\n    }\n    while (days < 0) {\n        days += 31;\n        // days += 31; // TODO: Need tests to show this is bad and the new code is good.\n        // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is\n        // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n        // Also it's contextual - if asked for no M in the format then I should probably\n        // be doing no calculating here.\n        months -= 1;\n    }\n    while (months < 0) {\n        months += 12;\n        years -= 1;\n    }\n    milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n    seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n    minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n    hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n    days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n    months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n    years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n    // number of months and get the real count and not just 0->11.\n    if (!Token.containsTokenWithValue(tokens, y)) {\n        if (Token.containsTokenWithValue(tokens, M)) {\n            months += 12 * years;\n            years = 0;\n        } else {\n            // TODO: this is a bit weak, needs work to know about leap years\n            days += 365 * years;\n            years = 0;\n        }\n    }\n    if (!Token.containsTokenWithValue(tokens, M)) {\n        days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n        months = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, d)) {\n        hours += 24 * days;\n        days = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, H)) {\n        minutes += 60 * hours;\n        hours = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, m)) {\n        seconds += 60 * minutes;\n        minutes = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, s)) {\n        milliseconds += 1000 * seconds;\n        seconds = 0;\n    }\n    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n}", "code_comment": "/**\n * <p>Formats the time gap as a string, using the specified format.\n * Padding the left hand side of numbers with zeroes is optional and\n * the timezone may be specified.\n *\n * @param startMillis  the start of the duration\n * @param endMillis  the end of the duration\n * @param format  the way in which to format the duration\n * @param padWithZeros whether to pad the left hand side of numbers with 0's\n * @param timezone the millis are defined in\n * @return the time as a String\n */\n", "code_no_comment": "public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n    long millis = endMillis - startMillis;\n    if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n        return formatDuration(millis, format, padWithZeros);\n    }\n    Token[] tokens = lexx(format);\n            Calendar start = Calendar.getInstance(timezone);\n    start.setTime(new Date(startMillis));\n    Calendar end = Calendar.getInstance(timezone);\n    end.setTime(new Date(endMillis));\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n        while (milliseconds < 0) {\n        milliseconds += 1000;\n        seconds -= 1;\n    }\n    while (seconds < 0) {\n        seconds += 60;\n        minutes -= 1;\n    }\n    while (minutes < 0) {\n        minutes += 60;\n        hours -= 1;\n    }\n    while (hours < 0) {\n        hours += 24;\n        days -= 1;\n    }\n    while (days < 0) {\n        days += 31;\n                                                months -= 1;\n    }\n    while (months < 0) {\n        months += 12;\n        years -= 1;\n    }\n    milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n    seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n    minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n    hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n    days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n    months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n    years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n        if (!Token.containsTokenWithValue(tokens, y)) {\n        if (Token.containsTokenWithValue(tokens, M)) {\n            months += 12 * years;\n            years = 0;\n        } else {\n                        days += 365 * years;\n            years = 0;\n        }\n    }\n    if (!Token.containsTokenWithValue(tokens, M)) {\n        days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n        months = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, d)) {\n        hours += 24 * days;\n        days = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, H)) {\n        minutes += 60 * hours;\n        hours = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, m)) {\n        seconds += 60 * minutes;\n        minutes = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, s)) {\n        milliseconds += 1000 * seconds;\n        seconds = 0;\n    }\n    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n}", "lc": 2.9545454545454546, "pi": -0.22966507177033516, "ma": 2.2, "nbd": 0.0, "ml": 2.25, "d": 2.557539682539683, "mi": -1.2322762508809015, "fo": 2.5833333333333335, "r": -0.02631578947368421, "e": 13.703887092777324}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3297_71499e17", "label": 1, "code": "protected static String encodeResourceReferenceAttributes(ResourceReference.UrlAttributes attributes) {\n    if (attributes == null || (attributes.getLocale() == null && attributes.getStyle() == null && attributes.getVariation() == null)) {\n        return null;\n    } else {\n        StringBuilder res = new StringBuilder();\n        if (attributes.getLocale() != null) {\n            res.append(attributes.getLocale().toString());\n        }\n        if (!Strings.isEmpty(attributes.getStyle())) {\n            res.append(\"-\");\n            res.append(attributes.getStyle());\n        }\n        if (!Strings.isEmpty(attributes.getVariation())) {\n            res.append(\"-\");\n            res.append(attributes.getVariation());\n        }\n        return res.toString();\n    }\n}", "code_comment": NaN, "code_no_comment": "protected static String encodeResourceReferenceAttributes(ResourceReference.UrlAttributes attributes) {\n    if (attributes == null || (attributes.getLocale() == null && attributes.getStyle() == null && attributes.getVariation() == null)) {\n        return null;\n    } else {\n        StringBuilder res = new StringBuilder();\n        if (attributes.getLocale() != null) {\n            res.append(attributes.getLocale().toString());\n        }\n        if (!Strings.isEmpty(attributes.getStyle())) {\n            res.append(\"-\");\n            res.append(attributes.getStyle());\n        }\n        if (!Strings.isEmpty(attributes.getVariation())) {\n            res.append(\"-\");\n            res.append(attributes.getVariation());\n        }\n        return res.toString();\n    }\n}", "lc": 0.22727272727272727, "pi": 0.3157894736842104, "ma": 0.2, "nbd": 0.0, "ml": 0.6666666666666666, "d": 1.4900793650793651, "mi": -0.23016208597603918, "fo": 1.0, "r": -0.02631578947368421, "e": 1.0855713651792556}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-8964_ea8ee025", "label": 1, "code": "public synchronized void suspendRoute(String routeId, long timeout, TimeUnit timeUnit) throws Exception {\n    if (!routeSupportsSuspension(routeId)) {\n        stopRoute(routeId, timeout, timeUnit);\n        return;\n    }\n    RouteService routeService = routeServices.get(routeId);\n    if (routeService != null) {\n        List<RouteStartupOrder> routes = new ArrayList<RouteStartupOrder>(1);\n        RouteStartupOrder order = new DefaultRouteStartupOrder(1, routeService.getRoutes().iterator().next(), routeService);\n        routes.add(order);\n        getShutdownStrategy().suspend(this, routes, timeout, timeUnit);\n        // must suspend route service as well\n        suspendRouteService(routeService);\n    }\n}", "code_comment": NaN, "code_no_comment": "public synchronized void suspendRoute(String routeId, long timeout, TimeUnit timeUnit) throws Exception {\n    if (!routeSupportsSuspension(routeId)) {\n        stopRoute(routeId, timeout, timeUnit);\n        return;\n    }\n    RouteService routeService = routeServices.get(routeId);\n    if (routeService != null) {\n        List<RouteStartupOrder> routes = new ArrayList<RouteStartupOrder>(1);\n        RouteStartupOrder order = new DefaultRouteStartupOrder(1, routeService.getRoutes().iterator().next(), routeService);\n        routes.add(order);\n        getShutdownStrategy().suspend(this, routes, timeout, timeUnit);\n                suspendRouteService(routeService);\n    }\n}", "lc": 0.0, "pi": -0.05741626794258379, "ma": -0.2, "nbd": -0.5, "ml": 0.0, "d": -0.0496031746031746, "mi": -0.059337561663143155, "fo": 0.3333333333333333, "r": -0.02631578947368421, "e": 0.02368562092633253}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5582_1fb66533", "label": 1, "code": "@Override\npublic String encodeURL(CharSequence url) {\n    Args.notNull(url, \"url\");\n    /*\n\t\t  WICKET-4645 - always pass absolute url to the web container for encoding\n\t\t  because when REDIRECT_TO_BUFFER is in use Wicket may render PageB when\n\t\t  PageA is actually the requested one and the web container cannot resolve\n\t\t  the base url properly\n\t\t */\n    UrlRenderer urlRenderer = RequestCycle.get().getUrlRenderer();\n    Url relativeUrl = Url.parse(url);\n    String fullUrl = urlRenderer.renderFullUrl(relativeUrl);\n    String encodedFullUrl = httpServletResponse.encodeURL(fullUrl);\n    final String encodedRelativeUrl;\n    if (fullUrl.equals(encodedFullUrl)) {\n        // no encoding happened so just reuse the relative url\n        encodedRelativeUrl = url.toString();\n    } else {\n        // get the relative url with the jsessionid encoded in it\n        Url _encoded = Url.parse(encodedFullUrl);\n        encodedRelativeUrl = urlRenderer.renderRelativeUrl(_encoded);\n    }\n    return encodedRelativeUrl;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic String encodeURL(CharSequence url) {\n    Args.notNull(url, \"url\");\n        UrlRenderer urlRenderer = RequestCycle.get().getUrlRenderer();\n    Url relativeUrl = Url.parse(url);\n    String fullUrl = urlRenderer.renderFullUrl(relativeUrl);\n    String encodedFullUrl = httpServletResponse.encodeURL(fullUrl);\n    final String encodedRelativeUrl;\n    if (fullUrl.equals(encodedFullUrl)) {\n                encodedRelativeUrl = url.toString();\n    } else {\n                Url _encoded = Url.parse(encodedFullUrl);\n        encodedRelativeUrl = urlRenderer.renderRelativeUrl(_encoded);\n    }\n    return encodedRelativeUrl;\n}", "lc": 0.09090909090909091, "pi": -0.2583732057416268, "ma": -0.4, "nbd": -0.5, "ml": -0.16666666666666666, "d": -0.3650793650793651, "mi": -0.11571529245947859, "fo": 0.3333333333333333, "r": -0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4658_ef3adb12", "label": 3, "code": "@Override\nprotected void onComponentTag(final ComponentTag tag) {\n    super.onComponentTag(tag);\n    String cssClass = tag.getAttribute(\"class\");\n    if (cssClass == null) {\n        cssClass = \" \";\n    }\n    cssClass += \" tab\" + getIndex();\n    if (getIndex() == getSelectedTab()) {\n        cssClass += ' ' + getSelectedTabCssClass();\n    }\n    if (getIndex() == getTabs().size() - 1) {\n        cssClass += ' ' + getLastTabCssClass();\n    }\n    tag.put(\"class\", cssClass.trim());\n}", "code_comment": NaN, "code_no_comment": "@Override\nprotected void onComponentTag(final ComponentTag tag) {\n    super.onComponentTag(tag);\n    String cssClass = tag.getAttribute(\"class\");\n    if (cssClass == null) {\n        cssClass = \" \";\n    }\n    cssClass += \" tab\" + getIndex();\n    if (getIndex() == getSelectedTab()) {\n        cssClass += ' ' + getSelectedTabCssClass();\n    }\n    if (getIndex() == getTabs().size() - 1) {\n        cssClass += ' ' + getLastTabCssClass();\n    }\n    tag.put(\"class\", cssClass.trim());\n}", "lc": 0.09090909090909091, "pi": -0.2583732057416268, "ma": 0.0, "nbd": -0.5, "ml": 0.16666666666666666, "d": 0.31547619047619047, "mi": -0.10866807610993666, "fo": 0.5, "r": 0.10526315789473684, "e": 0.19384404372907332}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-2460_a17d4e82", "label": 1, "code": "@Override\npublic Buffer getNextBuffer() throws IOException, InterruptedException {\n    if (isReleased.get()) {\n        return null;\n    }\n    // 1) In-memory\n    synchronized (parent.buffers) {\n        if (parent.isReleased) {\n            return null;\n        }\n        if (parent.spillWriter == null) {\n            if (currentQueuePosition < numberOfBuffers) {\n                Buffer buffer = parent.buffers.get(currentQueuePosition);\n                buffer.retain();\n                // TODO Fix hard coding of 8 bytes for the header\n                currentBytesRead += buffer.getSize() + 8;\n                currentQueuePosition++;\n                return buffer;\n            }\n            return null;\n        }\n    }\n    // 2) Spilled\n    if (spilledView != null) {\n        return spilledView.getNextBuffer();\n    }\n    // because this might be called from an network I/O thread.\n    if (parent.spillWriter.getNumberOfOutstandingRequests() > 0) {\n        return null;\n    }\n    if (ioMode.isSynchronous()) {\n        spilledView = new SpilledSubpartitionViewSyncIO(parent, bufferProvider.getMemorySegmentSize(), parent.spillWriter.getChannelID(), currentBytesRead);\n    } else {\n        spilledView = new SpilledSubpartitionViewAsyncIO(parent, bufferProvider, parent.ioManager, parent.spillWriter.getChannelID(), currentBytesRead);\n    }\n    return spilledView.getNextBuffer();\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic Buffer getNextBuffer() throws IOException, InterruptedException {\n    if (isReleased.get()) {\n        return null;\n    }\n        synchronized (parent.buffers) {\n        if (parent.isReleased) {\n            return null;\n        }\n        if (parent.spillWriter == null) {\n            if (currentQueuePosition < numberOfBuffers) {\n                Buffer buffer = parent.buffers.get(currentQueuePosition);\n                buffer.retain();\n                                currentBytesRead += buffer.getSize() + 8;\n                currentQueuePosition++;\n                return buffer;\n            }\n            return null;\n        }\n    }\n        if (spilledView != null) {\n        return spilledView.getNextBuffer();\n    }\n        if (parent.spillWriter.getNumberOfOutstandingRequests() > 0) {\n        return null;\n    }\n    if (ioMode.isSynchronous()) {\n        spilledView = new SpilledSubpartitionViewSyncIO(parent, bufferProvider.getMemorySegmentSize(), parent.spillWriter.getChannelID(), currentBytesRead);\n    } else {\n        spilledView = new SpilledSubpartitionViewAsyncIO(parent, bufferProvider, parent.ioManager, parent.spillWriter.getChannelID(), currentBytesRead);\n    }\n    return spilledView.getNextBuffer();\n}", "lc": 0.8636363636363636, "pi": 0.8660287081339711, "ma": 0.8, "nbd": 0.5, "ml": 0.8333333333333334, "d": 1.3809523809523812, "mi": -0.5486962649753347, "fo": 0.4166666666666667, "r": -0.02631578947368421, "e": 1.4553482823602633}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4594_556a2236", "label": 1, "code": "private void resolvePageInstance(Integer pageId, Class<? extends IRequestablePage> pageClass, PageParameters pageParameters, Integer renderCount) {\n    IRequestablePage page = null;\n    boolean freshCreated = false;\n    if (pageId != null) {\n        page = getStoredPage(pageId);\n    }\n    if (page == null) {\n        if (pageClass != null) {\n            page = getPageSource().newPageInstance(pageClass, pageParameters);\n            freshCreated = true;\n        }\n    }\n    if (page != null && !freshCreated) {\n        if (renderCount != null && page.getRenderCount() != renderCount) {\n            throw new StalePageException(page);\n        }\n    }\n    pageInstanceIsFresh = freshCreated;\n    pageInstance = page;\n}", "code_comment": NaN, "code_no_comment": "private void resolvePageInstance(Integer pageId, Class<? extends IRequestablePage> pageClass, PageParameters pageParameters, Integer renderCount) {\n    IRequestablePage page = null;\n    boolean freshCreated = false;\n    if (pageId != null) {\n        page = getStoredPage(pageId);\n    }\n    if (page == null) {\n        if (pageClass != null) {\n            page = getPageSource().newPageInstance(pageClass, pageParameters);\n            freshCreated = true;\n        }\n    }\n    if (page != null && !freshCreated) {\n        if (renderCount != null && page.getRenderCount() != renderCount) {\n            throw new StalePageException(page);\n        }\n    }\n    pageInstanceIsFresh = freshCreated;\n    pageInstance = page;\n}", "lc": 0.2727272727272727, "pi": 0.22488038277511951, "ma": 0.6, "nbd": 0.0, "ml": 0.6666666666666666, "d": 0.46428571428571425, "mi": -0.26934460887949235, "fo": -0.16666666666666666, "r": -0.02631578947368421, "e": 0.4055739008661675}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1199_813109d7", "label": 3, "code": "@Override\npublic void read(org.apache.thrift.protocol.TProtocol prot, removeConstraint_result struct) throws org.apache.thrift.TException {\n    TTupleProtocol iprot = (TTupleProtocol) prot;\n    BitSet incoming = iprot.readBitSet(2);\n    if (incoming.get(0)) {\n        struct.ouch1 = new AccumuloException();\n        struct.ouch1.read(iprot);\n        struct.setOuch1IsSet(true);\n    }\n    if (incoming.get(1)) {\n        struct.ouch2 = new AccumuloSecurityException();\n        struct.ouch2.read(iprot);\n        struct.setOuch2IsSet(true);\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void read(org.apache.thrift.protocol.TProtocol prot, removeConstraint_result struct) throws org.apache.thrift.TException {\n    TTupleProtocol iprot = (TTupleProtocol) prot;\n    BitSet incoming = iprot.readBitSet(2);\n    if (incoming.get(0)) {\n        struct.ouch1 = new AccumuloException();\n        struct.ouch1.read(iprot);\n        struct.setOuch1IsSet(true);\n    }\n    if (incoming.get(1)) {\n        struct.ouch2 = new AccumuloSecurityException();\n        struct.ouch2.read(iprot);\n        struct.setOuch2IsSet(true);\n    }\n}", "lc": 0.045454545454545456, "pi": 0.0, "ma": -0.2, "nbd": -0.5, "ml": -0.08333333333333333, "d": -0.3650793650793651, "mi": -0.09485553206483423, "fo": 0.08333333333333333, "r": -0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-843_65390f8c", "label": 3, "code": "@Override\npublic void compact(String tableName, Text start, Text end, boolean flush, boolean wait) throws AccumuloSecurityException, TableNotFoundException, AccumuloException {\n    throw new NotImplementedException();\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void compact(String tableName, Text start, Text end, boolean flush, boolean wait) throws AccumuloSecurityException, TableNotFoundException, AccumuloException {\n    throw new NotImplementedException();\n}", "lc": -0.45454545454545453, "pi": -0.6028708133971293, "ma": -0.4, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.738689217758985, "fo": -0.5, "r": -0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-320_c06cc933", "label": 1, "code": "/**\n * Solve the linear equation A &times; X = B in least square sense.\n * <p>The m&times;n matrix A may not be square, the solution X is\n * such that ||A &times; X - B|| is minimal.</p>\n * @param b right-hand side of the equation A &times; X = B\n * @return a matrix X that minimizes the two norm of A &times; X - B\n * @exception IllegalArgumentException if matrices dimensions don't match\n * @exception InvalidMatrixException if decomposed matrix is singular\n */\npublic RealMatrix solve(final RealMatrix b) throws IllegalArgumentException, InvalidMatrixException {\n    if (b.getRowDimension() != singularValues.length) {\n        throw MathRuntimeException.createIllegalArgumentException(\"dimensions mismatch: got {0}x{1} but expected {2}x{3}\", b.getRowDimension(), b.getColumnDimension(), singularValues.length, \"n\");\n    }\n    final RealMatrix w = uT.multiply(b);\n    for (int i = 0; i < singularValues.length; ++i) {\n        final double si = singularValues[i];\n        if (si == 0) {\n            throw new SingularMatrixException();\n        }\n        final double inv = 1.0 / si;\n        for (int j = 0; j < b.getColumnDimension(); ++j) {\n            w.multiplyEntry(i, j, inv);\n        }\n    }\n    return v.multiply(w);\n}", "code_comment": "/**\n * Solve the linear equation A &times; X = B in least square sense.\n * <p>The m&times;n matrix A may not be square, the solution X is\n * such that ||A &times; X - B|| is minimal.</p>\n * @param b right-hand side of the equation A &times; X = B\n * @return a matrix X that minimizes the two norm of A &times; X - B\n * @exception IllegalArgumentException if matrices dimensions don't match\n * @exception InvalidMatrixException if decomposed matrix is singular\n */\n", "code_no_comment": "public RealMatrix solve(final RealMatrix b) throws IllegalArgumentException, InvalidMatrixException {\n    if (b.getRowDimension() != singularValues.length) {\n        throw MathRuntimeException.createIllegalArgumentException(\"dimensions mismatch: got {0}x{1} but expected {2}x{3}\", b.getRowDimension(), b.getColumnDimension(), singularValues.length, \"n\");\n    }\n    final RealMatrix w = uT.multiply(b);\n    for (int i = 0; i < singularValues.length; ++i) {\n        final double si = singularValues[i];\n        if (si == 0) {\n            throw new SingularMatrixException();\n        }\n        final double inv = 1.0 / si;\n        for (int j = 0; j < b.getColumnDimension(); ++j) {\n            w.multiplyEntry(i, j, inv);\n        }\n    }\n    return v.multiply(w);\n}", "lc": 0.13636363636363635, "pi": 0.1913875598086124, "ma": 0.6, "nbd": 0.0, "ml": 0.4166666666666667, "d": 0.8948412698412698, "mi": -0.21381254404510194, "fo": 0.16666666666666666, "r": 0.0, "e": 0.8173464036467787}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-2899_31aea2ad", "label": 0, "code": "private int removeMetadataEntries(Map<String, Path> nameToFileMap, Map<String, Path> sortedWALogs, GCStatus status) throws IOException, KeeperException, InterruptedException {\n    int count = 0;\n    Iterator<LogEntry> iterator = MetadataTableUtil.getLogEntries(SystemCredentials.get());\n    while (iterator.hasNext()) {\n        for (String entry : iterator.next().logSet) {\n            String uuid = new Path(entry).getName();\n            if (!isUUID(uuid)) {\n                // fully expect this to be a uuid, if its not then something is wrong and walog GC should not proceed!\n                throw new IllegalArgumentException(\"Expected uuid, but got \" + uuid + \" from \" + entry);\n            }\n            Path pathFromNN = nameToFileMap.remove(uuid);\n            if (pathFromNN != null) {\n                status.currentLog.inUse++;\n                sortedWALogs.remove(uuid);\n            }\n            count++;\n        }\n    }\n    return count;\n}", "code_comment": NaN, "code_no_comment": "private int removeMetadataEntries(Map<String, Path> nameToFileMap, Map<String, Path> sortedWALogs, GCStatus status) throws IOException, KeeperException, InterruptedException {\n    int count = 0;\n    Iterator<LogEntry> iterator = MetadataTableUtil.getLogEntries(SystemCredentials.get());\n    while (iterator.hasNext()) {\n        for (String entry : iterator.next().logSet) {\n            String uuid = new Path(entry).getName();\n            if (!isUUID(uuid)) {\n                                throw new IllegalArgumentException(\"Expected uuid, but got \" + uuid + \" from \" + entry);\n            }\n            Path pathFromNN = nameToFileMap.remove(uuid);\n            if (pathFromNN != null) {\n                status.currentLog.inUse++;\n                sortedWALogs.remove(uuid);\n            }\n            count++;\n        }\n    }\n    return count;\n}", "lc": 0.22727272727272727, "pi": 1.0191387559808613, "ma": 0.4, "nbd": 0.5, "ml": 0.16666666666666666, "d": 0.27380952380952384, "mi": -0.26821705426356585, "fo": 0.16666666666666666, "r": -0.02631578947368421, "e": 0.3704569423073598}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-6889_cd40b712", "label": 1, "code": "public boolean process(final Exchange exchange, final AsyncCallback callback) {\n    Iterator<Processor> processors = next().iterator();\n    // callback to restore existing FILTER_MATCHED property on the Exchange\n    final Object existing = exchange.getProperty(Exchange.FILTER_MATCHED);\n    final AsyncCallback choiceCallback = new AsyncCallback() {\n\n        @Override\n        public void done(boolean doneSync) {\n            if (existing != null) {\n                exchange.setProperty(Exchange.FILTER_MATCHED, existing);\n            } else {\n                exchange.removeProperty(Exchange.FILTER_MATCHED);\n            }\n            callback.done(doneSync);\n        }\n    };\n    // and if not, we just continue without using any processor\n    while (processors.hasNext()) {\n        // get the next processor\n        Processor processor = processors.next();\n        // evaluate the predicate on filter predicate early to be faster\n        // and avoid issues when having nested choices\n        // as we should only pick one processor\n        boolean matches = true;\n        if (processor instanceof FilterProcessor) {\n            FilterProcessor filter = (FilterProcessor) processor;\n            try {\n                matches = filter.getPredicate().matches(exchange);\n                exchange.setProperty(Exchange.FILTER_MATCHED, matches);\n            } catch (Throwable e) {\n                exchange.setException(e);\n                choiceCallback.done(true);\n                return true;\n            }\n            // as we have pre evaluated the predicate then use its processor directly when routing\n            processor = filter.getProcessor();\n        }\n        // if we did not match then continue to next filter\n        if (!matches) {\n            continue;\n        }\n        // okay we found a filter or its the otherwise we are processing\n        AsyncProcessor async = AsyncProcessorConverterHelper.convert(processor);\n        return async.process(exchange, choiceCallback);\n    }\n    // when no filter matches and there is no otherwise, then just continue\n    choiceCallback.done(true);\n    return true;\n}", "code_comment": NaN, "code_no_comment": "public boolean process(final Exchange exchange, final AsyncCallback callback) {\n    Iterator<Processor> processors = next().iterator();\n        final Object existing = exchange.getProperty(Exchange.FILTER_MATCHED);\n    final AsyncCallback choiceCallback = new AsyncCallback() {\n\n        @Override\n        public void done(boolean doneSync) {\n            if (existing != null) {\n                exchange.setProperty(Exchange.FILTER_MATCHED, existing);\n            } else {\n                exchange.removeProperty(Exchange.FILTER_MATCHED);\n            }\n            callback.done(doneSync);\n        }\n    };\n        while (processors.hasNext()) {\n                Processor processor = processors.next();\n                                boolean matches = true;\n        if (processor instanceof FilterProcessor) {\n            FilterProcessor filter = (FilterProcessor) processor;\n            try {\n                matches = filter.getPredicate().matches(exchange);\n                exchange.setProperty(Exchange.FILTER_MATCHED, matches);\n            } catch (Throwable e) {\n                exchange.setException(e);\n                choiceCallback.done(true);\n                return true;\n            }\n                        processor = filter.getProcessor();\n        }\n                if (!matches) {\n            continue;\n        }\n                AsyncProcessor async = AsyncProcessorConverterHelper.convert(processor);\n        return async.process(exchange, choiceCallback);\n    }\n        choiceCallback.done(true);\n    return true;\n}", "lc": 1.0909090909090908, "pi": 0.7703349282296649, "ma": 0.6, "nbd": 0.5, "ml": 0.25, "d": 0.10119047619047619, "mi": -0.645947850599013, "fo": 0.9166666666666666, "r": -0.02631578947368421, "e": 0.40259101098989747}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-7611_e30f1c53", "label": 1, "code": "@SuppressWarnings(\"unchecked\")\n@Override\npublic boolean equals(Object o) {\n    if (this == o) {\n        return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n        return false;\n    }\n    KeyValueHolder<K, V> that = (KeyValueHolder<K, V>) o;\n    if (key != null ? !key.equals(that.key) : that.key != null) {\n        return false;\n    }\n    return true;\n}", "code_comment": NaN, "code_no_comment": "@SuppressWarnings(\"unchecked\")\n@Override\npublic boolean equals(Object o) {\n    if (this == o) {\n        return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n        return false;\n    }\n    KeyValueHolder<K, V> that = (KeyValueHolder<K, V>) o;\n    if (key != null ? !key.equals(that.key) : that.key != null) {\n        return false;\n    }\n    return true;\n}", "lc": 0.045454545454545456, "pi": -0.1291866028708134, "ma": 0.2, "nbd": -0.5, "ml": 0.3333333333333333, "d": 0.4781746031746032, "mi": -0.05623678646934473, "fo": -0.25, "r": 0.5789473684210527, "e": 0.1986710695412135}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-3006_d6472040", "label": 0, "code": "@Override\npublic boolean isReady() throws IOException {\n    for (Volume volume : getFileSystems().values()) {\n        FileSystem fs = volume.getFileSystem();\n        if (ViewFSUtils.isViewFS(fs)) {\n            try {\n                FileSystem resolvedFs = ViewFSUtils.resolvePath(fs, new Path(\"/\")).getFileSystem(fs.getConf());\n                log.debug(\"resolved \" + fs.getUri() + \" to \" + resolvedFs.getUri() + \" for ready check\");\n                fs = resolvedFs;\n            } catch (IOException e) {\n                log.warn(\"Failed to resolve \" + fs.getUri(), e);\n            }\n        }\n        if (!(fs instanceof DistributedFileSystem))\n            continue;\n        DistributedFileSystem dfs = (DistributedFileSystem) fs;\n        // So this: if (!dfs.setSafeMode(SafeModeAction.SAFEMODE_GET))\n        // Becomes this:\n        Class<?> safeModeAction;\n        try {\n            // hadoop 2.0\n            safeModeAction = Class.forName(\"org.apache.hadoop.hdfs.protocol.HdfsConstants$SafeModeAction\");\n        } catch (ClassNotFoundException ex) {\n            // hadoop 1.0\n            try {\n                safeModeAction = Class.forName(\"org.apache.hadoop.hdfs.protocol.FSConstants$SafeModeAction\");\n            } catch (ClassNotFoundException e) {\n                throw new RuntimeException(\"Cannot figure out the right class for Constants\");\n            }\n        }\n        Object get = null;\n        for (Object obj : safeModeAction.getEnumConstants()) {\n            if (obj.toString().equals(\"SAFEMODE_GET\"))\n                get = obj;\n        }\n        if (get == null) {\n            throw new RuntimeException(\"cannot find SAFEMODE_GET\");\n        }\n        try {\n            Method setSafeMode = dfs.getClass().getMethod(\"setSafeMode\", safeModeAction);\n            boolean inSafeMode = (Boolean) setSafeMode.invoke(dfs, get);\n            if (inSafeMode) {\n                return false;\n            }\n        } catch (IllegalArgumentException exception) {\n            /* Send IAEs back as-is, so that those that wrap UnknownHostException can be handled in the same place as similar sources of failure. */\n            throw exception;\n        } catch (Exception ex) {\n            throw new RuntimeException(\"cannot find method setSafeMode\");\n        }\n    }\n    return true;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean isReady() throws IOException {\n    for (Volume volume : getFileSystems().values()) {\n        FileSystem fs = volume.getFileSystem();\n        if (ViewFSUtils.isViewFS(fs)) {\n            try {\n                FileSystem resolvedFs = ViewFSUtils.resolvePath(fs, new Path(\"/\")).getFileSystem(fs.getConf());\n                log.debug(\"resolved \" + fs.getUri() + \" to \" + resolvedFs.getUri() + \" for ready check\");\n                fs = resolvedFs;\n            } catch (IOException e) {\n                log.warn(\"Failed to resolve \" + fs.getUri(), e);\n            }\n        }\n        if (!(fs instanceof DistributedFileSystem))\n            continue;\n        DistributedFileSystem dfs = (DistributedFileSystem) fs;\n                        Class<?> safeModeAction;\n        try {\n                        safeModeAction = Class.forName(\"org.apache.hadoop.hdfs.protocol.HdfsConstants$SafeModeAction\");\n        } catch (ClassNotFoundException ex) {\n                        try {\n                safeModeAction = Class.forName(\"org.apache.hadoop.hdfs.protocol.FSConstants$SafeModeAction\");\n            } catch (ClassNotFoundException e) {\n                throw new RuntimeException(\"Cannot figure out the right class for Constants\");\n            }\n        }\n        Object get = null;\n        for (Object obj : safeModeAction.getEnumConstants()) {\n            if (obj.toString().equals(\"SAFEMODE_GET\"))\n                get = obj;\n        }\n        if (get == null) {\n            throw new RuntimeException(\"cannot find SAFEMODE_GET\");\n        }\n        try {\n            Method setSafeMode = dfs.getClass().getMethod(\"setSafeMode\", safeModeAction);\n            boolean inSafeMode = (Boolean) setSafeMode.invoke(dfs, get);\n            if (inSafeMode) {\n                return false;\n            }\n        } catch (IllegalArgumentException exception) {\n                        throw exception;\n        } catch (Exception ex) {\n            throw new RuntimeException(\"cannot find method setSafeMode\");\n        }\n    }\n    return true;\n}", "lc": 1.5454545454545454, "pi": 0.5598086124401914, "ma": 2.8, "nbd": 0.5, "ml": 0.4166666666666667, "d": 0.33531746031746024, "mi": -0.8714587737843548, "fo": 1.1666666666666667, "r": -0.02631578947368421, "e": 1.0100770503045704}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5209_55eb5212", "label": 1, "code": "/**\n *  Collects the html generated by the rendering of a component.\n *\n *  @param component\n *             the component to render.\n *  @return the html rendered by the component\n */\npublic static CharSequence renderComponent(final Component component) {\n    RequestCycle requestCycle = RequestCycle.get();\n    final Response originalResponse = requestCycle.getResponse();\n    BufferedWebResponse tempResponse = new BufferedWebResponse(null);\n    try {\n        requestCycle.setResponse(tempResponse);\n        RenderPage page = new RenderPage();\n        page.add(component);\n        component.render();\n    } finally {\n        requestCycle.setResponse(originalResponse);\n    }\n    return tempResponse.getText();\n}", "code_comment": "/**\n *  Collects the html generated by the rendering of a component.\n *\n *  @param component\n *             the component to render.\n *  @return the html rendered by the component\n */\n", "code_no_comment": "public static CharSequence renderComponent(final Component component) {\n    RequestCycle requestCycle = RequestCycle.get();\n    final Response originalResponse = requestCycle.getResponse();\n    BufferedWebResponse tempResponse = new BufferedWebResponse(null);\n    try {\n        requestCycle.setResponse(tempResponse);\n        RenderPage page = new RenderPage();\n        page.add(component);\n        component.render();\n    } finally {\n        requestCycle.setResponse(originalResponse);\n    }\n    return tempResponse.getText();\n}", "lc": 0.0, "pi": -0.13875598086124405, "ma": -0.6, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.01987315010570819, "fo": 0.08333333333333333, "r": 0.05263157894736841, "e": -0.16279340490885932}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3433_b76b31f7", "label": 0, "code": "BackgroundWriteStats backgroundWrite() {\n    return unsavedLastRevisions.persist(this, new UnsavedModifications.Snapshot() {\n\n        @Override\n        public void acquiring() {\n            if (store.create(JOURNAL, singletonList(changes.asUpdateOp(getHeadRevision())))) {\n                changes = JOURNAL.newDocument(getDocumentStore());\n            }\n        }\n    }, backgroundOperationLock.writeLock());\n}", "code_comment": NaN, "code_no_comment": "BackgroundWriteStats backgroundWrite() {\n    return unsavedLastRevisions.persist(this, new UnsavedModifications.Snapshot() {\n\n        @Override\n        public void acquiring() {\n            if (store.create(JOURNAL, singletonList(changes.asUpdateOp(getHeadRevision())))) {\n                changes = JOURNAL.newDocument(getDocumentStore());\n            }\n        }\n    }, backgroundOperationLock.writeLock());\n}", "lc": -0.18181818181818182, "pi": 0.9617224880382774, "ma": -0.4, "nbd": 0.0, "ml": 0.0, "d": -0.3650793650793651, "mi": 0.23664552501761787, "fo": 0.16666666666666666, "r": 0.42105263157894735, "e": -0.16279340490885932}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-177_f91ce934", "label": 1, "code": "@Override\npublic synchronized void flush() throws IOException {\n    if (this.ds != null && this.address != null) {\n        final DatagramPacket packet = new DatagramPacket(data, data.length, address, port);\n        ds.send(packet);\n    }\n    data = null;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic synchronized void flush() throws IOException {\n    if (this.ds != null && this.address != null) {\n        final DatagramPacket packet = new DatagramPacket(data, data.length, address, port);\n        ds.send(packet);\n    }\n    data = null;\n}", "lc": -0.2727272727272727, "pi": 0.06220095693779899, "ma": -0.4, "nbd": -0.5, "ml": -0.08333333333333333, "d": -0.04365079365079365, "mi": 0.3341789992952784, "fo": -0.4166666666666667, "r": 0.39473684210526316, "e": -0.08533969560231208}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3792_94110f21", "label": 3, "code": "private boolean changePassword(User user, SimpleCredentials credentials) {\n    try {\n        Object newPasswordObject = credentials.getAttribute(CREDENTIALS_ATTRIBUTE_NEWPASSWORD);\n        if (newPasswordObject != null) {\n            if (newPasswordObject instanceof String) {\n                user.changePassword((String) newPasswordObject);\n                root.commit();\n                log.debug(\"User \" + userId + \": changed user password\");\n                return true;\n            } else {\n                log.warn(\"Aborted password change for user \" + userId + \": provided new password is of incompatible type \" + newPasswordObject.getClass().getName());\n            }\n        }\n    } catch (PasswordHistoryException e) {\n        credentials.setAttribute(e.getClass().getName(), e.getMessage());\n        log.error(\"Failed to change password for user \" + userId, e.getMessage());\n    } catch (RepositoryException e) {\n        log.error(\"Failed to change password for user \" + userId, e.getMessage());\n    } catch (CommitFailedException e) {\n        root.refresh();\n        log.error(\"Failed to change password for user \" + userId, e.getMessage());\n    }\n    return false;\n}", "code_comment": NaN, "code_no_comment": "private boolean changePassword(User user, SimpleCredentials credentials) {\n    try {\n        Object newPasswordObject = credentials.getAttribute(CREDENTIALS_ATTRIBUTE_NEWPASSWORD);\n        if (newPasswordObject != null) {\n            if (newPasswordObject instanceof String) {\n                user.changePassword((String) newPasswordObject);\n                root.commit();\n                log.debug(\"User \" + userId + \": changed user password\");\n                return true;\n            } else {\n                log.warn(\"Aborted password change for user \" + userId + \": provided new password is of incompatible type \" + newPasswordObject.getClass().getName());\n            }\n        }\n    } catch (PasswordHistoryException e) {\n        credentials.setAttribute(e.getClass().getName(), e.getMessage());\n        log.error(\"Failed to change password for user \" + userId, e.getMessage());\n    } catch (RepositoryException e) {\n        log.error(\"Failed to change password for user \" + userId, e.getMessage());\n    } catch (CommitFailedException e) {\n        root.refresh();\n        log.error(\"Failed to change password for user \" + userId, e.getMessage());\n    }\n    return false;\n}", "lc": 0.45454545454545453, "pi": 0.9330143540669857, "ma": 0.4, "nbd": 0.5, "ml": -0.16666666666666666, "d": 0.02579365079365077, "mi": -0.39055673009161385, "fo": 1.0, "r": -0.02631578947368421, "e": 0.19971300634498015}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1894_35562cce", "label": 1, "code": "@Override\npublic double getCost(Filter filter, NodeState root) {\n    if (filter.getFullTextConstraint() != null) {\n        // not an appropriate index for full-text search\n        return Double.POSITIVE_INFINITY;\n    }\n    if (filter.containsNativeConstraint()) {\n        // not an appropriate index for native search\n        return Double.POSITIVE_INFINITY;\n    }\n    PropertyIndexLookup lookup = getLookup(root);\n    for (PropertyRestriction pr : filter.getPropertyRestrictions()) {\n        String propertyName = PathUtils.getName(pr.propertyName);\n        // currently, only indexes on the root node are supported\n        if (lookup.isIndexed(propertyName, \"/\", filter)) {\n            if (pr.firstIncluding && pr.lastIncluding && pr.first != null && pr.first.equals(pr.last)) {\n                // \"[property] = $value\"\n                return lookup.getCost(filter, propertyName, pr.first);\n            } else if (pr.list != null) {\n                double cost = 0;\n                for (PropertyValue p : pr.list) {\n                    cost += lookup.getCost(filter, propertyName, p);\n                }\n                return cost;\n            } else {\n                // processed as \"[property] is not null\"\n                return lookup.getCost(filter, propertyName, null);\n            }\n        }\n    }\n    // not an appropriate index\n    return Double.POSITIVE_INFINITY;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic double getCost(Filter filter, NodeState root) {\n    if (filter.getFullTextConstraint() != null) {\n                return Double.POSITIVE_INFINITY;\n    }\n    if (filter.containsNativeConstraint()) {\n                return Double.POSITIVE_INFINITY;\n    }\n    PropertyIndexLookup lookup = getLookup(root);\n    for (PropertyRestriction pr : filter.getPropertyRestrictions()) {\n        String propertyName = PathUtils.getName(pr.propertyName);\n                if (lookup.isIndexed(propertyName, \"/\", filter)) {\n            if (pr.firstIncluding && pr.lastIncluding && pr.first != null && pr.first.equals(pr.last)) {\n                                return lookup.getCost(filter, propertyName, pr.first);\n            } else if (pr.list != null) {\n                double cost = 0;\n                for (PropertyValue p : pr.list) {\n                    cost += lookup.getCost(filter, propertyName, p);\n                }\n                return cost;\n            } else {\n                                return lookup.getCost(filter, propertyName, null);\n            }\n        }\n    }\n        return Double.POSITIVE_INFINITY;\n}", "lc": 0.5909090909090909, "pi": 1.325358851674641, "ma": 0.8, "nbd": 1.5, "ml": 1.1666666666666667, "d": 0.5218253968253967, "mi": -0.47371388301620826, "fo": 0.3333333333333333, "r": -0.02631578947368421, "e": 0.7566051762590549}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-1458_91f9bfc7", "label": 1, "code": "// --------------------------------------------------------------------------------------------\n// Utility methods\n// --------------------------------------------------------------------------------------------\n/**\n *  @param curT : start type\n *  @return Type The immediate child of the top class\n */\nprivate static Type getTypeHierarchy(ArrayList<Type> typeHierarchy, Type curT, Class<?> stopAtClass) {\n    // skip first one\n    if (typeHierarchy.size() > 0 && typeHierarchy.get(0) == curT && isClassType(curT)) {\n        curT = typeToClass(curT).getGenericSuperclass();\n    }\n    while (!(isClassType(curT) && typeToClass(curT).equals(stopAtClass))) {\n        typeHierarchy.add(curT);\n        curT = typeToClass(curT).getGenericSuperclass();\n    }\n    return curT;\n}", "code_comment": "/**\n *  @param curT : start type\n *  @return Type The immediate child of the top class\n */\n", "code_no_comment": "private static Type getTypeHierarchy(ArrayList<Type> typeHierarchy, Type curT, Class<?> stopAtClass) {\n        if (typeHierarchy.size() > 0 && typeHierarchy.get(0) == curT && isClassType(curT)) {\n        curT = typeToClass(curT).getGenericSuperclass();\n    }\n    while (!(isClassType(curT) && typeToClass(curT).equals(stopAtClass))) {\n        typeHierarchy.add(curT);\n        curT = typeToClass(curT).getGenericSuperclass();\n    }\n    return curT;\n}", "lc": -0.18181818181818182, "pi": -0.0909090909090911, "ma": -0.2, "nbd": -0.5, "ml": 0.5, "d": 0.5515873015873016, "mi": 0.131782945736434, "fo": 0.4166666666666667, "r": -0.02631578947368421, "e": 0.2586608115350702}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-757_76b7413d", "label": 1, "code": "/**\n * Returns the \"start index\" of the internal array.\n * This index is the position of the first addressable element in the\n * internal storage array.\n * The addressable elements in the array are at indices contained in\n * the interval [{@link #getStartIndex()},\n *               {@link #getStartIndex()} + {@link #getNumElements()} - 1].\n *\n * @return the start index.\n * @since 3.1\n */\nprotected int getStartIndex() {\n    return startIndex;\n}", "code_comment": "/**\n * Returns the \"start index\" of the internal array.\n * This index is the position of the first addressable element in the\n * internal storage array.\n * The addressable elements in the array are at indices contained in\n * the interval [{@link #getStartIndex()},\n *               {@link #getStartIndex()} + {@link #getNumElements()} - 1].\n *\n * @return the start index.\n * @since 3.1\n */\n", "code_no_comment": "protected int getStartIndex() {\n    return startIndex;\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.2407329105003524, "fo": -0.5, "r": 2.3947368421052633, "e": -0.16279340490885932}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4494_35843c19", "label": 1, "code": "@Override\npublic void postProcess(final Markup markup) {\n    // If there's still a non-simple tag left, it's an error\n    while (stack.size() > 0) {\n        final ComponentTag top = stack.peek();\n        if (!requiresCloseTag(top.getName())) {\n            stack.pop();\n        } else {\n            throw new MarkupException(markup, \"Tag does not have a close tag\", null);\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void postProcess(final Markup markup) {\n        while (stack.size() > 0) {\n        final ComponentTag top = stack.peek();\n        if (!requiresCloseTag(top.getName())) {\n            stack.pop();\n        } else {\n            throw new MarkupException(markup, \"Tag does not have a close tag\", null);\n        }\n    }\n}", "lc": -0.13636363636363635, "pi": 0.6267942583732056, "ma": 0.0, "nbd": 0.0, "ml": 0.0, "d": -0.11904761904761907, "mi": 0.17632135306553895, "fo": -0.08333333333333333, "r": 0.39473684210526316, "e": -0.10372112054309802}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-633_8dad5e0f", "label": 3, "code": "// this is only ever called immediately after getting \"next\" entry\n@Override\nprotected void consume() throws IOException {\n    int count = 0;\n    while (getSource().hasTop() && lastRowFound.equals(getSource().getTopKey().getRow())) {\n        // try to efficiently jump to the next matching key\n        if (count < numscans) {\n            ++count;\n            // scan\n            getSource().next();\n        } else {\n            // too many scans, just seek\n            count = 0;\n            // determine where to seek to, but don't go beyond the user-specified range\n            Key nextKey = getSource().getTopKey().followingKey(PartialKey.ROW);\n            if (!latestRange.afterEndKey(nextKey))\n                getSource().seek(new Range(nextKey, true, latestRange.getEndKey(), latestRange.isEndKeyInclusive()), latestColumnFamilies, latestInclusive);\n        }\n    }\n    lastRowFound = getSource().hasTop() ? getSource().getTopKey().getRow(lastRowFound) : null;\n}", "code_comment": NaN, "code_no_comment": "@Override\nprotected void consume() throws IOException {\n    int count = 0;\n    while (getSource().hasTop() && lastRowFound.equals(getSource().getTopKey().getRow())) {\n                if (count < numscans) {\n            ++count;\n                        getSource().next();\n        } else {\n                        count = 0;\n                        Key nextKey = getSource().getTopKey().followingKey(PartialKey.ROW);\n            if (!latestRange.afterEndKey(nextKey))\n                getSource().seek(new Range(nextKey, true, latestRange.getEndKey(), latestRange.isEndKeyInclusive()), latestColumnFamilies, latestInclusive);\n        }\n    }\n    lastRowFound = getSource().hasTop() ? getSource().getTopKey().getRow(lastRowFound) : null;\n}", "lc": 0.09090909090909091, "pi": 0.9330143540669857, "ma": 0.2, "nbd": 0.0, "ml": 0.5833333333333334, "d": 0.3055555555555555, "mi": -0.15207892882311472, "fo": 1.25, "r": -0.02631578947368421, "e": 0.28899684768013456}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3511_4a875f46", "label": 1, "code": "public String getReference() {\n    return null;\n}", "code_comment": NaN, "code_no_comment": "public String getReference() {\n    return null;\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.1646229739252991, "fo": -0.5, "r": 2.1842105263157894, "e": -0.16279340490885932}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-554_fbbb96eb", "label": 1, "code": "/**\n * Compute the cross-product of two vectors.\n * @param v1 first vector\n * @param v2 second vector\n * @return the cross product v1 ^ v2 as a new Vector\n */\npublic static Vector3D crossProduct(Vector3D v1, Vector3D v2) {\n    return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);\n}", "code_comment": "/**\n * Compute the cross-product of two vectors.\n * @param v1 first vector\n * @param v2 second vector\n * @return the cross product v1 ^ v2 as a new Vector\n */\n", "code_no_comment": "public static Vector3D crossProduct(Vector3D v1, Vector3D v2) {\n    return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": 0.4285714285714286, "mi": 0.7491190979563072, "fo": -0.5, "r": 0.05263157894736841, "e": 0.08837790955665815}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5968_8b7946d8", "label": 1, "code": "@Override\npublic boolean equals(Object o) {\n    if (this == o)\n        return true;\n    if (o == null || getClass() != o.getClass())\n        return false;\n    if (!super.equals(o))\n        return false;\n    CacheKey cacheKey = (CacheKey) o;\n    return !(extension != null ? !extension.equals(cacheKey.extension) : cacheKey.extension != null);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean equals(Object o) {\n    if (this == o)\n        return true;\n    if (o == null || getClass() != o.getClass())\n        return false;\n    if (!super.equals(o))\n        return false;\n    CacheKey cacheKey = (CacheKey) o;\n    return !(extension != null ? !extension.equals(cacheKey.extension) : cacheKey.extension != null);\n}", "lc": -0.13636363636363635, "pi": -0.01913875598086126, "ma": 0.2, "nbd": -1.0, "ml": 0.4166666666666667, "d": 0.5932539682539683, "mi": 0.10669485553206472, "fo": -0.16666666666666666, "r": 0.763157894736842, "e": 0.19242866939829298}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-1761_380ef878", "label": 1, "code": "private boolean decodeBufferOrEvent(RemoteInputChannel inputChannel, NettyMessage.BufferResponse bufferOrEvent) throws Throwable {\n    boolean releaseNettyBuffer = true;\n    try {\n        if (bufferOrEvent.isBuffer()) {\n            // ---- Buffer ------------------------------------------------\n            BufferProvider bufferProvider = inputChannel.getBufferProvider();\n            if (bufferProvider == null) {\n                // receiver has been cancelled/failed\n                return false;\n            }\n            while (true) {\n                Buffer buffer = bufferProvider.requestBuffer();\n                if (buffer != null) {\n                    buffer.setSize(bufferOrEvent.getSize());\n                    bufferOrEvent.getNettyBuffer().readBytes(buffer.getNioBuffer());\n                    inputChannel.onBuffer(buffer, bufferOrEvent.sequenceNumber);\n                    return true;\n                } else if (bufferListener.waitForBuffer(bufferProvider, bufferOrEvent)) {\n                    releaseNettyBuffer = false;\n                    return false;\n                } else if (bufferProvider.isDestroyed()) {\n                    return false;\n                }\n            }\n        } else {\n            // ---- Event -------------------------------------------------\n            // TODO We can just keep the serialized data in the Netty buffer and release it later at the reader\n            byte[] byteArray = new byte[bufferOrEvent.getSize()];\n            bufferOrEvent.getNettyBuffer().readBytes(byteArray);\n            Buffer buffer = new Buffer(new MemorySegment(byteArray), EventSerializer.RECYCLER, false);\n            inputChannel.onBuffer(buffer, bufferOrEvent.sequenceNumber);\n            return true;\n        }\n    } finally {\n        if (releaseNettyBuffer) {\n            bufferOrEvent.releaseBuffer();\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "private boolean decodeBufferOrEvent(RemoteInputChannel inputChannel, NettyMessage.BufferResponse bufferOrEvent) throws Throwable {\n    boolean releaseNettyBuffer = true;\n    try {\n        if (bufferOrEvent.isBuffer()) {\n                        BufferProvider bufferProvider = inputChannel.getBufferProvider();\n            if (bufferProvider == null) {\n                                return false;\n            }\n            while (true) {\n                Buffer buffer = bufferProvider.requestBuffer();\n                if (buffer != null) {\n                    buffer.setSize(bufferOrEvent.getSize());\n                    bufferOrEvent.getNettyBuffer().readBytes(buffer.getNioBuffer());\n                    inputChannel.onBuffer(buffer, bufferOrEvent.sequenceNumber);\n                    return true;\n                } else if (bufferListener.waitForBuffer(bufferProvider, bufferOrEvent)) {\n                    releaseNettyBuffer = false;\n                    return false;\n                } else if (bufferProvider.isDestroyed()) {\n                    return false;\n                }\n            }\n        } else {\n                                    byte[] byteArray = new byte[bufferOrEvent.getSize()];\n            bufferOrEvent.getNettyBuffer().readBytes(byteArray);\n            Buffer buffer = new Buffer(new MemorySegment(byteArray), EventSerializer.RECYCLER, false);\n            inputChannel.onBuffer(buffer, bufferOrEvent.sequenceNumber);\n            return true;\n        }\n    } finally {\n        if (releaseNettyBuffer) {\n            bufferOrEvent.releaseBuffer();\n        }\n    }\n}", "lc": 0.9545454545454546, "pi": 1.334928229665072, "ma": 0.8, "nbd": 2.0, "ml": 0.75, "d": 0.07341269841269839, "mi": -0.5875968992248061, "fo": 0.8333333333333334, "r": -0.02631578947368421, "e": 0.2769361986595436}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-3395_8433e6db", "label": 3, "code": "public Object next() {\n    Object part = iterator.next();\n    Exchange newExchange = exchange.copy();\n    if (part instanceof Message) {\n        newExchange.setIn((Message) part);\n    } else {\n        Message in = newExchange.getIn();\n        in.setBody(part);\n    }\n    return createProcessorExchangePair(index++, getProcessors().iterator().next(), newExchange);\n}", "code_comment": NaN, "code_no_comment": "public Object next() {\n    Object part = iterator.next();\n    Exchange newExchange = exchange.copy();\n    if (part instanceof Message) {\n        newExchange.setIn((Message) part);\n    } else {\n        Message in = newExchange.getIn();\n        in.setBody(part);\n    }\n    return createProcessorExchangePair(index++, getProcessors().iterator().next(), newExchange);\n}", "lc": -0.13636363636363635, "pi": -0.15311004784689008, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": -0.015873015873015886, "mi": 0.14080338266384787, "fo": 0.25, "r": 0.13157894736842105, "e": -0.045285063075211934}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1977_4bfbfcdd", "label": 1, "code": "/**\n * queries through the index as other query() but provides the PropertyRestriction to be applied\n * for advanced cases like range queries\n *\n * @param filter\n * @param indexName\n * @param indexMeta\n * @param indexStorageNodeName\n * @param pr\n * @return the iterable\n */\npublic Iterable<String> query(final Filter filter, final String indexName, final NodeState indexMeta, final String indexStorageNodeName, final PropertyRestriction pr) {\n    if (LOG.isDebugEnabled()) {\n        LOG.debug(\"query() - filter: {}\", filter);\n        LOG.debug(\"query() - indexName: {}\", indexName);\n        LOG.debug(\"query() - indexMeta: {}\", indexMeta);\n        LOG.debug(\"query() - indexStorageNodeName: {}\", indexStorageNodeName);\n        LOG.debug(\"query() - pr: {}\", pr);\n    }\n    final NodeState indexState = indexMeta.getChildNode(indexStorageNodeName);\n    final NodeBuilder index = new ReadOnlyBuilder(indexState);\n    final String firstEncoded = (pr.first == null) ? null : encode(pr.first.getValue(Type.STRING));\n    final String lastEncoded = (pr.last == null) ? null : encode(pr.last.getValue(Type.STRING));\n    if (firstEncoded != null && !firstEncoded.equals(lastEncoded)) {\n        // '>' & '>=' and between use case\n        LOG.debug(\"'>' & '>=' and between use case\");\n        ChildNodeEntry firstValueableItem;\n        String firstValuableItemKey;\n        Iterable<String> it = Collections.emptyList();\n        Iterable<ChildNodeEntry> childrenIterable;\n        if (lastEncoded == null) {\n            LOG.debug(\"> & >= case.\");\n            firstValuableItemKey = seek(index, new PredicateGreaterThan(firstEncoded, pr.firstIncluding));\n            if (firstValuableItemKey != null) {\n                firstValueableItem = new OrderedChildNodeEntry(firstValuableItemKey, indexState.getChildNode(firstValuableItemKey));\n                if (direction.isAscending()) {\n                    childrenIterable = new SeekedIterable(indexState, firstValueableItem);\n                    it = new QueryResultsWrapper(filter, indexName, childrenIterable);\n                } else {\n                    it = new QueryResultsWrapper(filter, indexName, new BetweenIterable(indexState, firstValueableItem, firstEncoded, pr.firstIncluding, direction));\n                }\n            }\n        } else {\n            String first, last;\n            boolean includeFirst, includeLast;\n            first = firstEncoded;\n            last = lastEncoded;\n            includeFirst = pr.firstIncluding;\n            includeLast = pr.lastIncluding;\n            if (LOG.isDebugEnabled()) {\n                final String op1 = includeFirst ? \">=\" : \">\";\n                final String op2 = includeLast ? \"<=\" : \"<\";\n                LOG.debug(\"in between case. direction: {} - Condition: (x {} {} AND x {} {})\", new Object[] { direction, op1, first, op2, last });\n            }\n            if (direction.equals(OrderDirection.ASC)) {\n                firstValuableItemKey = seek(index, new PredicateGreaterThan(first, includeFirst));\n            } else {\n                firstValuableItemKey = seek(index, new PredicateLessThan(last, includeLast));\n            }\n            LOG.debug(\"firstValueableItem: {}\", firstValuableItemKey);\n            if (firstValuableItemKey != null) {\n                firstValueableItem = new OrderedChildNodeEntry(firstValuableItemKey, indexState.getChildNode(firstValuableItemKey));\n                childrenIterable = new BetweenIterable(indexState, firstValueableItem, last, includeLast, direction);\n                it = new QueryResultsWrapper(filter, indexName, childrenIterable);\n            }\n        }\n        return it;\n    } else if (lastEncoded != null && !lastEncoded.equals(firstEncoded)) {\n        // '<' & '<=' use case\n        LOG.debug(\"'<' & '<=' use case\");\n        final String searchfor = lastEncoded;\n        final boolean include = pr.lastIncluding;\n        Predicate<String> predicate = new PredicateLessThan(searchfor, include);\n        LOG.debug(\"< & <= case. - searchfor: {} - include: {} - predicate: {}\", new Object[] { searchfor, include, predicate });\n        ChildNodeEntry firstValueableItem;\n        String firstValueableItemKey = seek(index, predicate);\n        LOG.debug(\"firstValuableItem: {}\", firstValueableItemKey);\n        Iterable<String> it = Collections.emptyList();\n        if (firstValueableItemKey != null) {\n            firstValueableItem = new OrderedChildNodeEntry(firstValueableItemKey, indexState.getChildNode(firstValueableItemKey));\n            if (direction.isAscending()) {\n                it = new QueryResultsWrapper(filter, indexName, new BetweenIterable(indexState, firstValueableItem, searchfor, include, direction));\n            } else {\n                it = new QueryResultsWrapper(filter, indexName, new SeekedIterable(indexState, firstValueableItem));\n            }\n        }\n        return it;\n    } else {\n        // property is not null. AKA \"open query\"\n        LOG.debug(\"property is not null. AKA 'open query'. FullIterable\");\n        return new QueryResultsWrapper(filter, indexName, new FullIterable(indexState, false));\n    }\n}", "code_comment": "/**\n * queries through the index as other query() but provides the PropertyRestriction to be applied\n * for advanced cases like range queries\n *\n * @param filter\n * @param indexName\n * @param indexMeta\n * @param indexStorageNodeName\n * @param pr\n * @return the iterable\n */\n", "code_no_comment": "public Iterable<String> query(final Filter filter, final String indexName, final NodeState indexMeta, final String indexStorageNodeName, final PropertyRestriction pr) {\n    if (LOG.isDebugEnabled()) {\n        LOG.debug(\"query() - filter: {}\", filter);\n        LOG.debug(\"query() - indexName: {}\", indexName);\n        LOG.debug(\"query() - indexMeta: {}\", indexMeta);\n        LOG.debug(\"query() - indexStorageNodeName: {}\", indexStorageNodeName);\n        LOG.debug(\"query() - pr: {}\", pr);\n    }\n    final NodeState indexState = indexMeta.getChildNode(indexStorageNodeName);\n    final NodeBuilder index = new ReadOnlyBuilder(indexState);\n    final String firstEncoded = (pr.first == null) ? null : encode(pr.first.getValue(Type.STRING));\n    final String lastEncoded = (pr.last == null) ? null : encode(pr.last.getValue(Type.STRING));\n    if (firstEncoded != null && !firstEncoded.equals(lastEncoded)) {\n                LOG.debug(\"'>' & '>=' and between use case\");\n        ChildNodeEntry firstValueableItem;\n        String firstValuableItemKey;\n        Iterable<String> it = Collections.emptyList();\n        Iterable<ChildNodeEntry> childrenIterable;\n        if (lastEncoded == null) {\n            LOG.debug(\"> & >= case.\");\n            firstValuableItemKey = seek(index, new PredicateGreaterThan(firstEncoded, pr.firstIncluding));\n            if (firstValuableItemKey != null) {\n                firstValueableItem = new OrderedChildNodeEntry(firstValuableItemKey, indexState.getChildNode(firstValuableItemKey));\n                if (direction.isAscending()) {\n                    childrenIterable = new SeekedIterable(indexState, firstValueableItem);\n                    it = new QueryResultsWrapper(filter, indexName, childrenIterable);\n                } else {\n                    it = new QueryResultsWrapper(filter, indexName, new BetweenIterable(indexState, firstValueableItem, firstEncoded, pr.firstIncluding, direction));\n                }\n            }\n        } else {\n            String first, last;\n            boolean includeFirst, includeLast;\n            first = firstEncoded;\n            last = lastEncoded;\n            includeFirst = pr.firstIncluding;\n            includeLast = pr.lastIncluding;\n            if (LOG.isDebugEnabled()) {\n                final String op1 = includeFirst ? \">=\" : \">\";\n                final String op2 = includeLast ? \"<=\" : \"<\";\n                LOG.debug(\"in between case. direction: {} - Condition: (x {} {} AND x {} {})\", new Object[] { direction, op1, first, op2, last });\n            }\n            if (direction.equals(OrderDirection.ASC)) {\n                firstValuableItemKey = seek(index, new PredicateGreaterThan(first, includeFirst));\n            } else {\n                firstValuableItemKey = seek(index, new PredicateLessThan(last, includeLast));\n            }\n            LOG.debug(\"firstValueableItem: {}\", firstValuableItemKey);\n            if (firstValuableItemKey != null) {\n                firstValueableItem = new OrderedChildNodeEntry(firstValuableItemKey, indexState.getChildNode(firstValuableItemKey));\n                childrenIterable = new BetweenIterable(indexState, firstValueableItem, last, includeLast, direction);\n                it = new QueryResultsWrapper(filter, indexName, childrenIterable);\n            }\n        }\n        return it;\n    } else if (lastEncoded != null && !lastEncoded.equals(firstEncoded)) {\n                LOG.debug(\"'<' & '<=' use case\");\n        final String searchfor = lastEncoded;\n        final boolean include = pr.lastIncluding;\n        Predicate<String> predicate = new PredicateLessThan(searchfor, include);\n        LOG.debug(\"< & <= case. - searchfor: {} - include: {} - predicate: {}\", new Object[] { searchfor, include, predicate });\n        ChildNodeEntry firstValueableItem;\n        String firstValueableItemKey = seek(index, predicate);\n        LOG.debug(\"firstValuableItem: {}\", firstValueableItemKey);\n        Iterable<String> it = Collections.emptyList();\n        if (firstValueableItemKey != null) {\n            firstValueableItem = new OrderedChildNodeEntry(firstValueableItemKey, indexState.getChildNode(firstValueableItemKey));\n            if (direction.isAscending()) {\n                it = new QueryResultsWrapper(filter, indexName, new BetweenIterable(indexState, firstValueableItem, searchfor, include, direction));\n            } else {\n                it = new QueryResultsWrapper(filter, indexName, new SeekedIterable(indexState, firstValueableItem));\n            }\n        }\n        return it;\n    } else {\n                LOG.debug(\"property is not null. AKA 'open query'. FullIterable\");\n        return new QueryResultsWrapper(filter, indexName, new FullIterable(indexState, false));\n    }\n}", "lc": 2.9545454545454546, "pi": 0.6937799043062203, "ma": 2.4, "nbd": 1.0, "ml": 2.0833333333333335, "d": 1.0813492063492063, "mi": -1.2429880197322054, "fo": 2.3333333333333335, "r": -0.02631578947368421, "e": 6.906604888112814}
{"project_name": "Math", "project_version": 71, "label": 0, "code": "/**\n * {@inheritDoc}\n */\npublic double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException {\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > t0;\n    // create some internal working arrays\n    final int stages = c.length + 1;\n    if (y != y0) {\n        System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n        yDotK[i] = new double[y0.length];\n    }\n    final double[] yTmp = new double[y0.length];\n    // set up an interpolator sharing the integrator arrays\n    AbstractStepInterpolator interpolator;\n    if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {\n        final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n        rki.reinitialize(this, yTmp, yDotK, forward);\n        interpolator = rki;\n    } else {\n        interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n    }\n    interpolator.storeTime(t0);\n    // set up integration control objects\n    stepStart = t0;\n    stepSize = forward ? step : -step;\n    for (StepHandler handler : stepHandlers) {\n        handler.reset();\n    }\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n    boolean lastStep = false;\n    // main integration loop\n    while (!lastStep) {\n        interpolator.shift();\n        for (boolean loop = true; loop; ) {\n            // first stage\n            computeDerivatives(stepStart, y, yDotK[0]);\n            // next stages\n            for (int k = 1; k < stages; ++k) {\n                for (int j = 0; j < y0.length; ++j) {\n                    double sum = a[k - 1][0] * yDotK[0][j];\n                    for (int l = 1; l < k; ++l) {\n                        sum += a[k - 1][l] * yDotK[l][j];\n                    }\n                    yTmp[j] = y[j] + stepSize * sum;\n                }\n                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);\n            }\n            // estimate the state at the end of the step\n            for (int j = 0; j < y0.length; ++j) {\n                double sum = b[0] * yDotK[0][j];\n                for (int l = 1; l < stages; ++l) {\n                    sum += b[l] * yDotK[l][j];\n                }\n                yTmp[j] = y[j] + stepSize * sum;\n            }\n            // discrete events handling\n            interpolator.storeTime(stepStart + stepSize);\n            if (manager.evaluateStep(interpolator)) {\n                final double dt = manager.getEventTime() - stepStart;\n                if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                    // we cannot simply truncate the step, reject the current computation\n                    // and let the loop compute another state with the truncated step.\n                    // it is so small (much probably exactly 0 due to limited accuracy)\n                    // that the code above would fail handling it.\n                    // So we set up an artificial 0 size step by copying states\n                    loop = false;\n                } else {\n                    // reject the step to match exactly the next switch time\n                    stepSize = dt;\n                }\n            } else {\n                loop = false;\n            }\n        }\n        // the step has been accepted\n        final double nextStep = stepStart + stepSize;\n        System.arraycopy(yTmp, 0, y, 0, y0.length);\n        manager.stepAccepted(nextStep, y);\n        lastStep = manager.stop();\n        // provide the step data to the step handler\n        interpolator.storeTime(nextStep);\n        for (StepHandler handler : stepHandlers) {\n            handler.handleStep(interpolator, lastStep);\n        }\n        stepStart = nextStep;\n        if (manager.reset(stepStart, y) && !lastStep) {\n            // some events handler has triggered changes that\n            // invalidate the derivatives, we need to recompute them\n            computeDerivatives(stepStart, y, yDotK[0]);\n        }\n        // make sure step size is set to default before next step\n        stepSize = forward ? step : -step;\n    }\n    final double stopTime = stepStart;\n    stepStart = Double.NaN;\n    stepSize = Double.NaN;\n    return stopTime;\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException {\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > t0;\n        final int stages = c.length + 1;\n    if (y != y0) {\n        System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n        yDotK[i] = new double[y0.length];\n    }\n    final double[] yTmp = new double[y0.length];\n        AbstractStepInterpolator interpolator;\n    if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {\n        final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n        rki.reinitialize(this, yTmp, yDotK, forward);\n        interpolator = rki;\n    } else {\n        interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n    }\n    interpolator.storeTime(t0);\n        stepStart = t0;\n    stepSize = forward ? step : -step;\n    for (StepHandler handler : stepHandlers) {\n        handler.reset();\n    }\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n    boolean lastStep = false;\n        while (!lastStep) {\n        interpolator.shift();\n        for (boolean loop = true; loop; ) {\n                        computeDerivatives(stepStart, y, yDotK[0]);\n                        for (int k = 1; k < stages; ++k) {\n                for (int j = 0; j < y0.length; ++j) {\n                    double sum = a[k - 1][0] * yDotK[0][j];\n                    for (int l = 1; l < k; ++l) {\n                        sum += a[k - 1][l] * yDotK[l][j];\n                    }\n                    yTmp[j] = y[j] + stepSize * sum;\n                }\n                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);\n            }\n                        for (int j = 0; j < y0.length; ++j) {\n                double sum = b[0] * yDotK[0][j];\n                for (int l = 1; l < stages; ++l) {\n                    sum += b[l] * yDotK[l][j];\n                }\n                yTmp[j] = y[j] + stepSize * sum;\n            }\n                        interpolator.storeTime(stepStart + stepSize);\n            if (manager.evaluateStep(interpolator)) {\n                final double dt = manager.getEventTime() - stepStart;\n                if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                                                                                                                        loop = false;\n                } else {\n                                        stepSize = dt;\n                }\n            } else {\n                loop = false;\n            }\n        }\n                final double nextStep = stepStart + stepSize;\n        System.arraycopy(yTmp, 0, y, 0, y0.length);\n        manager.stepAccepted(nextStep, y);\n        lastStep = manager.stop();\n                interpolator.storeTime(nextStep);\n        for (StepHandler handler : stepHandlers) {\n            handler.handleStep(interpolator, lastStep);\n        }\n        stepStart = nextStep;\n        if (manager.reset(stepStart, y) && !lastStep) {\n                                    computeDerivatives(stepStart, y, yDotK[0]);\n        }\n                stepSize = forward ? step : -step;\n    }\n    final double stopTime = stepStart;\n    stepStart = Double.NaN;\n    stepSize = Double.NaN;\n    return stopTime;\n}", "lc": 3.090909090909091, "pi": 1.2775119617224882, "ma": 2.8, "nbd": 1.5, "ml": 2.6666666666666665, "d": 3.9781746031746033, "mi": -1.27568710359408, "fo": 1.6666666666666667, "r": -0.02631578947368421, "e": 21.445910916708442}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1364_b481a14c", "label": 1, "code": "synchronized void refresh(K key, int hash, CacheLoader<K, V> loader) throws ExecutionException {\n    V value;\n    V old = get(key, hash);\n    long start = System.nanoTime();\n    try {\n        if (old == null) {\n            value = loader.load(key);\n        } else {\n            ListenableFuture<V> future = loader.reload(key, old);\n            value = future.get();\n        }\n        loadSuccessCount++;\n    } catch (Exception e) {\n        loadExceptionCount++;\n        throw new ExecutionException(e);\n    } finally {\n        long time = System.nanoTime() - start;\n        totalLoadTime += time;\n    }\n    put(key, hash, value, cache.sizeOf(key, value));\n}", "code_comment": NaN, "code_no_comment": "synchronized void refresh(K key, int hash, CacheLoader<K, V> loader) throws ExecutionException {\n    V value;\n    V old = get(key, hash);\n    long start = System.nanoTime();\n    try {\n        if (old == null) {\n            value = loader.load(key);\n        } else {\n            ListenableFuture<V> future = loader.reload(key, old);\n            value = future.get();\n        }\n        loadSuccessCount++;\n    } catch (Exception e) {\n        loadExceptionCount++;\n        throw new ExecutionException(e);\n    } finally {\n        long time = System.nanoTime() - start;\n        totalLoadTime += time;\n    }\n    put(key, hash, value, cache.sizeOf(key, value));\n}", "lc": 0.3181818181818182, "pi": 0.1961722488038276, "ma": 0.0, "nbd": 0.0, "ml": -0.25, "d": 0.4007936507936507, "mi": -0.29330514446793515, "fo": 0.16666666666666666, "r": 0.0, "e": 0.4441209522656938}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-43_668f08f2", "label": 1, "code": "public void moveNode(String srcPath, String destPath) throws NotFoundException, Exception {\n    if (PathUtils.isAncestor(srcPath, destPath)) {\n        throw new Exception(\"target path cannot be descendant of source path: \" + destPath);\n    }\n    String srcParentPath = PathUtils.getParentPath(srcPath);\n    String srcNodeName = PathUtils.getName(srcPath);\n    String destParentPath = PathUtils.getParentPath(destPath);\n    String destNodeName = PathUtils.getName(destPath);\n    MutableNode srcParent = getOrCreateStagedNode(srcParentPath);\n    if (srcParentPath.equals(destParentPath)) {\n        if (srcParent.getChildNodeEntry(destNodeName) != null) {\n            throw new Exception(\"node already exists at move destination path: \" + destPath);\n        }\n        if (srcParent.rename(srcNodeName, destNodeName) == null) {\n            throw new NotFoundException(srcPath);\n        }\n    } else {\n        ChildNode srcCNE = srcParent.remove(srcNodeName);\n        if (srcCNE == null) {\n            throw new NotFoundException(srcPath);\n        }\n        MutableNode destParent = getOrCreateStagedNode(destParentPath);\n        if (destParent.getChildNodeEntry(destNodeName) != null) {\n            throw new Exception(\"node already exists at move destination path: \" + destPath);\n        }\n        destParent.add(new ChildNode(destNodeName, srcCNE.getId()));\n    }\n    // update staging area\n    moveStagedNodes(srcPath, destPath);\n    // update change log\n    changeLog.add(new MoveNode(srcPath, destPath));\n}", "code_comment": NaN, "code_no_comment": "public void moveNode(String srcPath, String destPath) throws NotFoundException, Exception {\n    if (PathUtils.isAncestor(srcPath, destPath)) {\n        throw new Exception(\"target path cannot be descendant of source path: \" + destPath);\n    }\n    String srcParentPath = PathUtils.getParentPath(srcPath);\n    String srcNodeName = PathUtils.getName(srcPath);\n    String destParentPath = PathUtils.getParentPath(destPath);\n    String destNodeName = PathUtils.getName(destPath);\n    MutableNode srcParent = getOrCreateStagedNode(srcParentPath);\n    if (srcParentPath.equals(destParentPath)) {\n        if (srcParent.getChildNodeEntry(destNodeName) != null) {\n            throw new Exception(\"node already exists at move destination path: \" + destPath);\n        }\n        if (srcParent.rename(srcNodeName, destNodeName) == null) {\n            throw new NotFoundException(srcPath);\n        }\n    } else {\n        ChildNode srcCNE = srcParent.remove(srcNodeName);\n        if (srcCNE == null) {\n            throw new NotFoundException(srcPath);\n        }\n        MutableNode destParent = getOrCreateStagedNode(destParentPath);\n        if (destParent.getChildNodeEntry(destNodeName) != null) {\n            throw new Exception(\"node already exists at move destination path: \" + destPath);\n        }\n        destParent.add(new ChildNode(destNodeName, srcCNE.getId()));\n    }\n        moveStagedNodes(srcPath, destPath);\n        changeLog.add(new MoveNode(srcPath, destPath));\n}", "lc": 0.7272727272727273, "pi": 0.10047846889952151, "ma": 1.6, "nbd": 0.0, "ml": 1.0, "d": 0.7162698412698413, "mi": -0.5760394644115574, "fo": 0.8333333333333334, "r": -0.02631578947368421, "e": 1.1996450038323447}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-7586_1f92fa42", "label": 3, "code": "public boolean isMessageHistory() {\n    return context.isMessageHistory();\n}", "code_comment": NaN, "code_no_comment": "public boolean isMessageHistory() {\n    return context.isMessageHistory();\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.1987315010570823, "fo": -0.4166666666666667, "r": 0.9473684210526315, "e": -0.16279340490885932}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-7990_d581c4a4", "label": 1, "code": "public boolean process(Exchange exchange, AsyncCallback callback) {\n    final String messageId = messageIdExpression.evaluate(exchange, String.class);\n    if (messageId == null) {\n        throw new NoMessageIdException(exchange, messageIdExpression);\n    }\n    boolean newKey;\n    if (eager) {\n        // add the key to the repository\n        if (idempotentRepository instanceof ExchangeIdempotentRepository) {\n            newKey = ((ExchangeIdempotentRepository<String>) idempotentRepository).add(exchange, messageId);\n        } else {\n            newKey = idempotentRepository.add(messageId);\n        }\n    } else {\n        // check if we already have the key\n        if (idempotentRepository instanceof ExchangeIdempotentRepository) {\n            newKey = ((ExchangeIdempotentRepository<String>) idempotentRepository).contains(exchange, messageId);\n        } else {\n            newKey = !idempotentRepository.contains(messageId);\n        }\n    }\n    if (!newKey) {\n        // mark the exchange as duplicate\n        exchange.setProperty(Exchange.DUPLICATE_MESSAGE, Boolean.TRUE);\n        // we already have this key so its a duplicate message\n        onDuplicate(exchange, messageId);\n        if (skipDuplicate) {\n            // if we should skip duplicate then we are done\n            LOG.debug(\"Ignoring duplicate message with id: {} for exchange: {}\", messageId, exchange);\n            callback.done(true);\n            return true;\n        }\n    }\n    // register our on completion callback\n    exchange.addOnCompletion(new IdempotentOnCompletion(idempotentRepository, messageId, eager, removeOnFailure));\n    // process the exchange\n    return processor.process(exchange, callback);\n}", "code_comment": NaN, "code_no_comment": "public boolean process(Exchange exchange, AsyncCallback callback) {\n    final String messageId = messageIdExpression.evaluate(exchange, String.class);\n    if (messageId == null) {\n        throw new NoMessageIdException(exchange, messageIdExpression);\n    }\n    boolean newKey;\n    if (eager) {\n                if (idempotentRepository instanceof ExchangeIdempotentRepository) {\n            newKey = ((ExchangeIdempotentRepository<String>) idempotentRepository).add(exchange, messageId);\n        } else {\n            newKey = idempotentRepository.add(messageId);\n        }\n    } else {\n                if (idempotentRepository instanceof ExchangeIdempotentRepository) {\n            newKey = ((ExchangeIdempotentRepository<String>) idempotentRepository).contains(exchange, messageId);\n        } else {\n            newKey = !idempotentRepository.contains(messageId);\n        }\n    }\n    if (!newKey) {\n                exchange.setProperty(Exchange.DUPLICATE_MESSAGE, Boolean.TRUE);\n                onDuplicate(exchange, messageId);\n        if (skipDuplicate) {\n                        LOG.debug(\"Ignoring duplicate message with id: {} for exchange: {}\", messageId, exchange);\n            callback.done(true);\n            return true;\n        }\n    }\n        exchange.addOnCompletion(new IdempotentOnCompletion(idempotentRepository, messageId, eager, removeOnFailure));\n        return processor.process(exchange, callback);\n}", "lc": 0.7727272727272727, "pi": 0.24880382775119597, "ma": 0.8, "nbd": 0.0, "ml": 0.5, "d": 0.09126984126984122, "mi": -0.5326286116983789, "fo": 0.4166666666666667, "r": -0.02631578947368421, "e": 0.2983097341562789}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-217_add180fb", "label": 1, "code": "@Override\npublic Set<String> listIterators(String tableName) throws AccumuloSecurityException, AccumuloException, TableNotFoundException {\n    Set<String> result = new HashSet<String>();\n    Set<String> lifecycles = new HashSet<String>();\n    for (IteratorScope scope : IteratorScope.values()) lifecycles.add(scope.name().toLowerCase());\n    for (Entry<String, String> property : this.getProperties(tableName)) {\n        String name = property.getKey();\n        String[] parts = name.split(\"\\\\.\");\n        if (parts.length == 4) {\n            if (parts[0].equals(\"table\") && parts[1].equals(\"iterator\") && lifecycles.contains(parts[2]))\n                result.add(parts[3]);\n        }\n    }\n    return result;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic Set<String> listIterators(String tableName) throws AccumuloSecurityException, AccumuloException, TableNotFoundException {\n    Set<String> result = new HashSet<String>();\n    Set<String> lifecycles = new HashSet<String>();\n    for (IteratorScope scope : IteratorScope.values()) lifecycles.add(scope.name().toLowerCase());\n    for (Entry<String, String> property : this.getProperties(tableName)) {\n        String name = property.getKey();\n        String[] parts = name.split(\"\\\\.\");\n        if (parts.length == 4) {\n            if (parts[0].equals(\"table\") && parts[1].equals(\"iterator\") && lifecycles.contains(parts[2]))\n                result.add(parts[3]);\n        }\n    }\n    return result;\n}", "lc": 0.045454545454545456, "pi": 0.6411483253588517, "ma": 0.2, "nbd": 0.0, "ml": 0.25, "d": -0.0019841269841269858, "mi": -0.1571529245947851, "fo": 0.4166666666666667, "r": -0.02631578947368421, "e": 0.14689695314165843}
{"project_name": "Closure", "project_version": 70, "label": 2, "code": "/**\n * Declares all of a function's arguments.\n */\nprivate void declareArguments(Node functionNode) {\n    Node astParameters = functionNode.getFirstChild().getNext();\n    Node body = astParameters.getNext();\n    FunctionType functionType = (FunctionType) functionNode.getJSType();\n    if (functionType != null) {\n        Node jsDocParameters = functionType.getParametersNode();\n        if (jsDocParameters != null) {\n            Node jsDocParameter = jsDocParameters.getFirstChild();\n            for (Node astParameter : astParameters.children()) {\n                if (jsDocParameter != null) {\n                    defineSlot(astParameter, functionNode, jsDocParameter.getJSType(), true);\n                    jsDocParameter = jsDocParameter.getNext();\n                } else {\n                    defineSlot(astParameter, functionNode, null, true);\n                }\n            }\n        }\n    }\n}", "code_comment": "/**\n * Declares all of a function's arguments.\n */\n", "code_no_comment": "private void declareArguments(Node functionNode) {\n    Node astParameters = functionNode.getFirstChild().getNext();\n    Node body = astParameters.getNext();\n    FunctionType functionType = (FunctionType) functionNode.getJSType();\n    if (functionType != null) {\n        Node jsDocParameters = functionType.getParametersNode();\n        if (jsDocParameters != null) {\n            Node jsDocParameter = jsDocParameters.getFirstChild();\n            for (Node astParameter : astParameters.children()) {\n                if (jsDocParameter != null) {\n                    defineSlot(astParameter, functionNode, jsDocParameter.getJSType(), true);\n                    jsDocParameter = jsDocParameter.getNext();\n                } else {\n                    defineSlot(astParameter, functionNode, null, true);\n                }\n            }\n        }\n    }\n}", "lc": 0.22727272727272727, "pi": 1.6985645933014355, "ma": 0.2, "nbd": 1.0, "ml": 0.08333333333333333, "d": 0.15674603174603172, "mi": -0.2140944326990838, "fo": 0.4166666666666667, "r": 0.0, "e": 0.15161794113748608}
{"project_name": "Math", "project_version": 93, "label": 3, "code": "/**\n * Returns n!. Shorthand for <code>n</code> <a\n * href=\"http://mathworld.wolfram.com/Factorial.html\"> Factorial</a>, the\n * product of the numbers <code>1,...,n</code>.\n * <p>\n * <Strong>Preconditions</strong>:\n * <ul>\n * <li> <code>n >= 0</code> (otherwise\n * <code>IllegalArgumentException</code> is thrown)</li>\n * <li> The result is small enough to fit into a <code>long</code>. The\n * largest value of <code>n</code> for which <code>n!</code> <\n * Long.MAX_VALUE</code> is 20. If the computed value exceeds <code>Long.MAX_VALUE</code>\n * an <code>ArithMeticException </code> is thrown.</li>\n * </ul>\n * </p>\n *\n * @param n argument\n * @return <code>n!</code>\n * @throws ArithmeticException if the result is too large to be represented\n *         by a long integer.\n * @throws IllegalArgumentException if n < 0\n */\npublic static long factorial(final int n) {\n    long result = Math.round(factorialDouble(n));\n    if (result == Long.MAX_VALUE) {\n        throw new ArithmeticException(\"factorial value is too large to fit in a long\");\n    }\n    return factorials[n];\n}", "code_comment": "/**\n * Returns n!. Shorthand for <code>n</code> <a\n * href=\"http://mathworld.wolfram.com/Factorial.html\"> Factorial</a>, the\n * product of the numbers <code>1,...,n</code>.\n * <p>\n * <Strong>Preconditions</strong>:\n * <ul>\n * <li> <code>n >= 0</code> (otherwise\n * <code>IllegalArgumentException</code> is thrown)</li>\n * <li> The result is small enough to fit into a <code>long</code>. The\n * largest value of <code>n</code> for which <code>n!</code> <\n * Long.MAX_VALUE</code> is 20. If the computed value exceeds <code>Long.MAX_VALUE</code>\n * an <code>ArithMeticException </code> is thrown.</li>\n * </ul>\n * </p>\n *\n * @param n argument\n * @return <code>n!</code>\n * @throws ArithmeticException if the result is too large to be represented\n *         by a long integer.\n * @throws IllegalArgumentException if n < 0\n */\n", "code_no_comment": "public static long factorial(final int n) {\n    long result = Math.round(factorialDouble(n));\n    if (result == Long.MAX_VALUE) {\n        throw new ArithmeticException(\"factorial value is too large to fit in a long\");\n    }\n    return factorials[n];\n}", "lc": -0.3181818181818182, "pi": -0.20574162679425848, "ma": -0.2, "nbd": -0.5, "ml": -0.25, "d": -0.11706349206349208, "mi": 0.4582100070472161, "fo": -0.3333333333333333, "r": -0.02631578947368421, "e": -0.12549114526604543}
{"project_name": "Closure", "project_version": 120, "label": 2, "code": "/**\n * @return Whether the variable is only assigned a value once for its\n *     lifetime.\n */\nboolean isAssignedOnceInLifetime() {\n    Reference ref = getOneAndOnlyAssignment();\n    if (ref == null) {\n        return false;\n    }\n    // Make sure this assignment is not in a loop.\n    for (BasicBlock block = ref.getBasicBlock(); block != null; block = block.getParent()) {\n        if (block.isFunction) {\n            break;\n        } else if (block.isLoop) {\n            return false;\n        }\n    }\n    return true;\n}", "code_comment": "/**\n * @return Whether the variable is only assigned a value once for its\n *     lifetime.\n */\n", "code_no_comment": "boolean isAssignedOnceInLifetime() {\n    Reference ref = getOneAndOnlyAssignment();\n    if (ref == null) {\n        return false;\n    }\n        for (BasicBlock block = ref.getBasicBlock(); block != null; block = block.getParent()) {\n        if (block.isFunction) {\n            break;\n        } else if (block.isLoop) {\n            return false;\n        }\n    }\n    return true;\n}", "lc": 0.0, "pi": 0.29665071770334916, "ma": 0.4, "nbd": 0.5, "ml": 0.25, "d": -0.039682539682539715, "mi": 0.03875968992248061, "fo": -0.25, "r": 1.0, "e": -0.07610979524328186}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-1251_424068f7", "label": 1, "code": "@Override\npublic void log(final LogRecord record) {\n    if (isFiltered(record)) {\n        return;\n    }\n    final org.apache.logging.log4j.Level level = LevelTranslator.toLevel(record.getLevel());\n    final Message message = logger.getMessageFactory().newMessage(record.getMessage(), record.getParameters());\n    final Throwable thrown = record.getThrown();\n    logger.logIfEnabled(FQCN, level, null, message, thrown);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void log(final LogRecord record) {\n    if (isFiltered(record)) {\n        return;\n    }\n    final org.apache.logging.log4j.Level level = LevelTranslator.toLevel(record.getLevel());\n    final Message message = logger.getMessageFactory().newMessage(record.getMessage(), record.getParameters());\n    final Throwable thrown = record.getThrown();\n    logger.logIfEnabled(FQCN, level, null, message, thrown);\n}", "lc": -0.18181818181818182, "pi": -0.2822966507177035, "ma": -0.4, "nbd": -0.5, "ml": -0.16666666666666666, "d": -0.3650793650793651, "mi": 0.14080338266384787, "fo": 0.25, "r": -0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-812_6eb46555", "label": 1, "code": "/**\n * {@inheritDoc}\n */\n@Override\npublic double dotProduct(RealVector v) {\n    if (v instanceof ArrayRealVector) {\n        final double[] vData = ((ArrayRealVector) v).data;\n        checkVectorDimensions(vData.length);\n        double dot = 0;\n        for (int i = 0; i < data.length; i++) {\n            dot += data[i] * vData[i];\n        }\n        return dot;\n    } else {\n        checkVectorDimensions(v);\n        double dot = 0;\n        Iterator<Entry> it = v.sparseIterator();\n        while (it.hasNext()) {\n            final Entry e = it.next();\n            dot += data[e.getIndex()] * e.getValue();\n        }\n        return dot;\n    }\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "@Override\npublic double dotProduct(RealVector v) {\n    if (v instanceof ArrayRealVector) {\n        final double[] vData = ((ArrayRealVector) v).data;\n        checkVectorDimensions(vData.length);\n        double dot = 0;\n        for (int i = 0; i < data.length; i++) {\n            dot += data[i] * vData[i];\n        }\n        return dot;\n    } else {\n        checkVectorDimensions(v);\n        double dot = 0;\n        Iterator<Entry> it = v.sparseIterator();\n        while (it.hasNext()) {\n            final Entry e = it.next();\n            dot += data[e.getIndex()] * e.getValue();\n        }\n        return dot;\n    }\n}", "lc": 0.3181818181818182, "pi": 0.2535885167464114, "ma": 0.0, "nbd": 0.0, "ml": 0.16666666666666666, "d": 0.5376984126984127, "mi": -0.27216349541930934, "fo": 0.08333333333333333, "r": 0.39473684210526316, "e": 0.4549967439474881}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-398_2c966ad9", "label": 1, "code": "@SuppressWarnings(\"unchecked\")\nprotected void doConfigure() {\n    boolean setRoot = false;\n    boolean setLoggers = false;\n    for (final Node child : rootNode.getChildren()) {\n        createConfiguration(child, null);\n        if (child.getObject() == null) {\n            continue;\n        }\n        if (child.getName().equalsIgnoreCase(\"Properties\")) {\n            if (tempLookup == subst.getVariableResolver()) {\n                subst.setVariableResolver((StrLookup) child.getObject());\n            } else {\n                LOGGER.error(\"Properties declaration must be the first element in the configuration\");\n            }\n            continue;\n        } else if (tempLookup == subst.getVariableResolver()) {\n            final Map<String, String> map = (Map<String, String>) componentMap.get(CONTEXT_PROPERTIES);\n            final StrLookup lookup = map == null ? null : new MapLookup(map);\n            subst.setVariableResolver(new Interpolator(lookup));\n        }\n        if (child.getName().equalsIgnoreCase(\"Appenders\")) {\n            appenders = (ConcurrentMap<String, Appender>) child.getObject();\n        } else if (child.getObject() instanceof Filter) {\n            addFilter((Filter) child.getObject());\n        } else if (child.getName().equalsIgnoreCase(\"Loggers\")) {\n            final Loggers l = (Loggers) child.getObject();\n            loggers = l.getMap();\n            setLoggers = true;\n            if (l.getRoot() != null) {\n                root = l.getRoot();\n                setRoot = true;\n            }\n        } else {\n            LOGGER.error(\"Unknown object \\\"\" + child.getName() + \"\\\" of type \" + child.getObject().getClass().getName() + \" is ignored\");\n        }\n    }\n    if (!setLoggers) {\n        LOGGER.warn(\"No Loggers were configured, using default. Is the Loggers element missing?\");\n        setToDefault();\n        return;\n    } else if (!setRoot) {\n        LOGGER.warn(\"No Root logger was configured, creating default ERROR-level Root logger with Console appender\");\n        setToDefault();\n    // return; // LOG4J2-219: creating default root=ok, but don't exclude configured Loggers\n    }\n    for (final Map.Entry<String, LoggerConfig> entry : loggers.entrySet()) {\n        final LoggerConfig l = entry.getValue();\n        for (final AppenderRef ref : l.getAppenderRefs()) {\n            final Appender app = appenders.get(ref.getRef());\n            if (app != null) {\n                l.addAppender(app, ref.getLevel(), ref.getFilter());\n            } else {\n                LOGGER.error(\"Unable to locate appender \" + ref.getRef() + \" for logger \" + l.getName());\n            }\n        }\n    }\n    setParents();\n}", "code_comment": NaN, "code_no_comment": "@SuppressWarnings(\"unchecked\")\nprotected void doConfigure() {\n    boolean setRoot = false;\n    boolean setLoggers = false;\n    for (final Node child : rootNode.getChildren()) {\n        createConfiguration(child, null);\n        if (child.getObject() == null) {\n            continue;\n        }\n        if (child.getName().equalsIgnoreCase(\"Properties\")) {\n            if (tempLookup == subst.getVariableResolver()) {\n                subst.setVariableResolver((StrLookup) child.getObject());\n            } else {\n                LOGGER.error(\"Properties declaration must be the first element in the configuration\");\n            }\n            continue;\n        } else if (tempLookup == subst.getVariableResolver()) {\n            final Map<String, String> map = (Map<String, String>) componentMap.get(CONTEXT_PROPERTIES);\n            final StrLookup lookup = map == null ? null : new MapLookup(map);\n            subst.setVariableResolver(new Interpolator(lookup));\n        }\n        if (child.getName().equalsIgnoreCase(\"Appenders\")) {\n            appenders = (ConcurrentMap<String, Appender>) child.getObject();\n        } else if (child.getObject() instanceof Filter) {\n            addFilter((Filter) child.getObject());\n        } else if (child.getName().equalsIgnoreCase(\"Loggers\")) {\n            final Loggers l = (Loggers) child.getObject();\n            loggers = l.getMap();\n            setLoggers = true;\n            if (l.getRoot() != null) {\n                root = l.getRoot();\n                setRoot = true;\n            }\n        } else {\n            LOGGER.error(\"Unknown object \\\"\" + child.getName() + \"\\\" of type \" + child.getObject().getClass().getName() + \" is ignored\");\n        }\n    }\n    if (!setLoggers) {\n        LOGGER.warn(\"No Loggers were configured, using default. Is the Loggers element missing?\");\n        setToDefault();\n        return;\n    } else if (!setRoot) {\n        LOGGER.warn(\"No Root logger was configured, creating default ERROR-level Root logger with Console appender\");\n        setToDefault();\n        }\n    for (final Map.Entry<String, LoggerConfig> entry : loggers.entrySet()) {\n        final LoggerConfig l = entry.getValue();\n        for (final AppenderRef ref : l.getAppenderRefs()) {\n            final Appender app = appenders.get(ref.getRef());\n            if (app != null) {\n                l.addAppender(app, ref.getLevel(), ref.getFilter());\n            } else {\n                LOGGER.error(\"Unable to locate appender \" + ref.getRef() + \" for logger \" + l.getName());\n            }\n        }\n    }\n    setParents();\n}", "lc": 2.0, "pi": 0.5406698564593301, "ma": 2.8, "nbd": 1.5, "ml": 1.5, "d": 0.5059523809523809, "mi": -1.0214235377026073, "fo": 3.25, "r": -0.02631578947368421, "e": 2.09033038847876}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-466_7b9e48e8", "label": 3, "code": "/**\n * Tries to convert the specified URL to a file object. If this fails,\n * <b>null</b> is returned.\n *\n * @param uri the URI\n * @return the resulting file object\n */\npublic static File fileFromURI(URI uri) {\n    if (uri == null || (uri.getScheme() != null && (!PROTOCOL_FILE.equals(uri.getScheme()) && !JBOSS_FILE.equals(uri.getScheme())))) {\n        return null;\n    }\n    if (uri.getScheme() == null) {\n        try {\n            uri = new File(uri.getPath()).toURI();\n        } catch (final Exception ex) {\n            LOGGER.warn(\"Invalid URI \" + uri);\n            return null;\n        }\n    }\n    try {\n        return new File(URLDecoder.decode(uri.toURL().getFile(), \"UTF8\"));\n    } catch (final MalformedURLException ex) {\n        LOGGER.warn(\"Invalid URL \" + uri, ex);\n    } catch (final UnsupportedEncodingException uee) {\n        LOGGER.warn(\"Invalid encoding: UTF8\", uee);\n    }\n    return null;\n}", "code_comment": "/**\n * Tries to convert the specified URL to a file object. If this fails,\n * <b>null</b> is returned.\n *\n * @param uri the URI\n * @return the resulting file object\n */\n", "code_no_comment": "public static File fileFromURI(URI uri) {\n    if (uri == null || (uri.getScheme() != null && (!PROTOCOL_FILE.equals(uri.getScheme()) && !JBOSS_FILE.equals(uri.getScheme())))) {\n        return null;\n    }\n    if (uri.getScheme() == null) {\n        try {\n            uri = new File(uri.getPath()).toURI();\n        } catch (final Exception ex) {\n            LOGGER.warn(\"Invalid URI \" + uri);\n            return null;\n        }\n    }\n    try {\n        return new File(URLDecoder.decode(uri.toURL().getFile(), \"UTF8\"));\n    } catch (final MalformedURLException ex) {\n        LOGGER.warn(\"Invalid URL \" + uri, ex);\n    } catch (final UnsupportedEncodingException uee) {\n        LOGGER.warn(\"Invalid encoding: UTF8\", uee);\n    }\n    return null;\n}", "lc": 0.3181818181818182, "pi": 0.20095693779904303, "ma": 0.4, "nbd": 0.0, "ml": 0.3333333333333333, "d": 0.8472222222222223, "mi": -0.30429880197322057, "fo": 0.6666666666666666, "r": -0.02631578947368421, "e": 0.7832206681535011}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1199_813109d7", "label": 3, "code": "@Override\npublic String toString() {\n    StringBuilder sb = new StringBuilder(\"removeTableProperty_result(\");\n    boolean first = true;\n    sb.append(\"ouch1:\");\n    if (this.ouch1 == null) {\n        sb.append(\"null\");\n    } else {\n        sb.append(this.ouch1);\n    }\n    first = false;\n    if (!first)\n        sb.append(\", \");\n    sb.append(\"ouch2:\");\n    if (this.ouch2 == null) {\n        sb.append(\"null\");\n    } else {\n        sb.append(this.ouch2);\n    }\n    first = false;\n    sb.append(\")\");\n    return sb.toString();\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic String toString() {\n    StringBuilder sb = new StringBuilder(\"removeTableProperty_result(\");\n    boolean first = true;\n    sb.append(\"ouch1:\");\n    if (this.ouch1 == null) {\n        sb.append(\"null\");\n    } else {\n        sb.append(this.ouch1);\n    }\n    first = false;\n    if (!first)\n        sb.append(\", \");\n    sb.append(\"ouch2:\");\n    if (this.ouch2 == null) {\n        sb.append(\"null\");\n    } else {\n        sb.append(this.ouch2);\n    }\n    first = false;\n    sb.append(\")\");\n    return sb.toString();\n}", "lc": 0.4090909090909091, "pi": -0.3157894736842106, "ma": 0.0, "nbd": -0.5, "ml": 0.08333333333333333, "d": 0.13095238095238093, "mi": -0.27639182522903427, "fo": 0.25, "r": 0.0, "e": 0.1004569999366078}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3630_fcd64766", "label": 3, "code": "@Override\npublic boolean match(String name, NodeState nodeState, int depth) {\n    // last segment -> add to collector if node type matches\n    if (depth == maxDepth() - 1 && primaryType != null && !primaryType.equals(ConfigUtil.getPrimaryTypeName(nodeState))) {\n        return false;\n    }\n    return super.match(name, nodeState, depth);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean match(String name, NodeState nodeState, int depth) {\n        if (depth == maxDepth() - 1 && primaryType != null && !primaryType.equals(ConfigUtil.getPrimaryTypeName(nodeState))) {\n        return false;\n    }\n    return super.match(name, nodeState, depth);\n}", "lc": -0.3181818181818182, "pi": -0.0909090909090911, "ma": -0.4, "nbd": -0.5, "ml": 0.3333333333333333, "d": 0.2063492063492063, "mi": 0.36546863988724454, "fo": -0.16666666666666666, "r": 0.2894736842105263, "e": 0.006041850359894635}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-929_cedf0d27", "label": 0, "code": "/**\n * {@inheritDoc}\n */\npublic double density(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length != dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n    return FastMath.pow(2 * FastMath.PI, -dim / 2) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * getExponentTerm(vals);\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "public double density(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length != dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n    return FastMath.pow(2 * FastMath.PI, -dim / 2) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * getExponentTerm(vals);\n}", "lc": -0.3181818181818182, "pi": -0.20574162679425848, "ma": -0.2, "nbd": -0.5, "ml": -0.16666666666666666, "d": 0.371031746031746, "mi": 0.344890768146582, "fo": -0.16666666666666666, "r": 1.0263157894736843, "e": 0.07725315952352134}
{"project_name": "Closure", "project_version": 149, "label": 2, "code": "/**\n * Generates JavaScript source code for an AST.\n */\nprivate String toSource(Node n, SourceMap sourceMap) {\n    CodePrinter.Builder builder = new CodePrinter.Builder(n);\n    builder.setPrettyPrint(options.prettyPrint);\n    builder.setLineBreak(options.lineBreak);\n    builder.setSourceMap(sourceMap);\n    builder.setSourceMapDetailLevel(options.sourceMapDetailLevel);\n    Charset charset = options.outputCharset;\n    builder.setOutputCharset(charset);\n    return builder.build();\n}", "code_comment": "/**\n * Generates JavaScript source code for an AST.\n */\n", "code_no_comment": "private String toSource(Node n, SourceMap sourceMap) {\n    CodePrinter.Builder builder = new CodePrinter.Builder(n);\n    builder.setPrettyPrint(options.prettyPrint);\n    builder.setLineBreak(options.lineBreak);\n    builder.setSourceMap(sourceMap);\n    builder.setSourceMapDetailLevel(options.sourceMapDetailLevel);\n    Charset charset = options.outputCharset;\n    builder.setOutputCharset(charset);\n    return builder.build();\n}", "lc": -0.18181818181818182, "pi": -0.6650717703349284, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.15940803382663848, "fo": 0.0, "r": 0.0, "e": -0.16279340490885932}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-1005_91d280b7", "label": 1, "code": "/**\n * Compute a linear combination accurately.\n * This method computes the sum of the products\n * <code>a<sub>i</sub> b<sub>i</sub></code> to high accuracy.\n * It does so by using specific multiplication and addition algorithms to\n * preserve accuracy and reduce cancellation effects.\n * <br/>\n * It is based on the 2005 paper\n * <a href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n * Accurate Sum and Dot Product</a> by Takeshi Ogita, Siegfried M. Rump,\n * and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n *\n * @param a Factors.\n * @param b Factors.\n * @return <code>&Sigma;<sub>i</sub> a<sub>i</sub> b<sub>i</sub></code>.\n * @throws DimensionMismatchException if arrays dimensions don't match\n */\npublic static double linearCombination(final double[] a, final double[] b) throws DimensionMismatchException {\n    final int len = a.length;\n    if (len != b.length) {\n        throw new DimensionMismatchException(len, b.length);\n    }\n    final double[] prodHigh = new double[len];\n    double prodLowSum = 0;\n    for (int i = 0; i < len; i++) {\n        final double ai = a[i];\n        final double ca = SPLIT_FACTOR * ai;\n        final double aHigh = ca - (ca - ai);\n        final double aLow = ai - aHigh;\n        final double bi = b[i];\n        final double cb = SPLIT_FACTOR * bi;\n        final double bHigh = cb - (cb - bi);\n        final double bLow = bi - bHigh;\n        prodHigh[i] = ai * bi;\n        final double prodLow = aLow * bLow - (((prodHigh[i] - aHigh * bHigh) - aLow * bHigh) - aHigh * bLow);\n        prodLowSum += prodLow;\n    }\n    final double prodHighCur = prodHigh[0];\n    double prodHighNext = prodHigh[1];\n    double sHighPrev = prodHighCur + prodHighNext;\n    double sPrime = sHighPrev - prodHighNext;\n    double sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime);\n    final int lenMinusOne = len - 1;\n    for (int i = 1; i < lenMinusOne; i++) {\n        prodHighNext = prodHigh[i + 1];\n        final double sHighCur = sHighPrev + prodHighNext;\n        sPrime = sHighCur - prodHighNext;\n        sLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);\n        sHighPrev = sHighCur;\n    }\n    double result = sHighPrev + (prodLowSum + sLowSum);\n    if (Double.isNaN(result)) {\n        // either we have split infinite numbers or some coefficients were NaNs,\n        // just rely on the naive implementation and let IEEE754 handle this\n        result = 0;\n        for (int i = 0; i < len; ++i) {\n            result += a[i] * b[i];\n        }\n    }\n    return result;\n}", "code_comment": "/**\n * Compute a linear combination accurately.\n * This method computes the sum of the products\n * <code>a<sub>i</sub> b<sub>i</sub></code> to high accuracy.\n * It does so by using specific multiplication and addition algorithms to\n * preserve accuracy and reduce cancellation effects.\n * <br/>\n * It is based on the 2005 paper\n * <a href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n * Accurate Sum and Dot Product</a> by Takeshi Ogita, Siegfried M. Rump,\n * and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n *\n * @param a Factors.\n * @param b Factors.\n * @return <code>&Sigma;<sub>i</sub> a<sub>i</sub> b<sub>i</sub></code>.\n * @throws DimensionMismatchException if arrays dimensions don't match\n */\n", "code_no_comment": "public static double linearCombination(final double[] a, final double[] b) throws DimensionMismatchException {\n    final int len = a.length;\n    if (len != b.length) {\n        throw new DimensionMismatchException(len, b.length);\n    }\n    final double[] prodHigh = new double[len];\n    double prodLowSum = 0;\n    for (int i = 0; i < len; i++) {\n        final double ai = a[i];\n        final double ca = SPLIT_FACTOR * ai;\n        final double aHigh = ca - (ca - ai);\n        final double aLow = ai - aHigh;\n        final double bi = b[i];\n        final double cb = SPLIT_FACTOR * bi;\n        final double bHigh = cb - (cb - bi);\n        final double bLow = bi - bHigh;\n        prodHigh[i] = ai * bi;\n        final double prodLow = aLow * bLow - (((prodHigh[i] - aHigh * bHigh) - aLow * bHigh) - aHigh * bLow);\n        prodLowSum += prodLow;\n    }\n    final double prodHighCur = prodHigh[0];\n    double prodHighNext = prodHigh[1];\n    double sHighPrev = prodHighCur + prodHighNext;\n    double sPrime = sHighPrev - prodHighNext;\n    double sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime);\n    final int lenMinusOne = len - 1;\n    for (int i = 1; i < lenMinusOne; i++) {\n        prodHighNext = prodHigh[i + 1];\n        final double sHighCur = sHighPrev + prodHighNext;\n        sPrime = sHighCur - prodHighNext;\n        sLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);\n        sHighPrev = sHighCur;\n    }\n    double result = sHighPrev + (prodLowSum + sLowSum);\n    if (Double.isNaN(result)) {\n                        result = 0;\n        for (int i = 0; i < len; ++i) {\n            result += a[i] * b[i];\n        }\n    }\n    return result;\n}", "lc": 1.2727272727272727, "pi": -0.22966507177033516, "ma": 0.6, "nbd": 0.0, "ml": 0.5, "d": 2.884920634920635, "mi": -0.7984496124031006, "fo": -0.4166666666666667, "r": -0.02631578947368421, "e": 7.993243546964955}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1183_cfbf5999", "label": 3, "code": "@Override\npublic String createBatchScanner(ByteBuffer login, String tableName, BatchScanOptions opts) throws TException {\n    try {\n        Connector connector = getConnector(login);\n        int threads = 10;\n        Authorizations auth;\n        if (opts != null && opts.isSetAuthorizations()) {\n            auth = getAuthorizations(opts.authorizations);\n        } else {\n            auth = connector.securityOperations().getUserAuthorizations(connector.whoami());\n        }\n        if (opts != null && opts.threads > 0)\n            threads = opts.threads;\n        BatchScanner scanner = connector.createBatchScanner(tableName, auth, threads);\n        if (opts != null) {\n            if (opts.iterators != null) {\n                for (org.apache.accumulo.proxy.thrift.IteratorSetting iter : opts.iterators) {\n                    IteratorSetting is = new IteratorSetting(iter.getPriority(), iter.getName(), iter.getIteratorClass(), iter.getProperties());\n                    scanner.addScanIterator(is);\n                }\n            }\n            ArrayList<Range> ranges = new ArrayList<Range>();\n            if (opts.ranges == null) {\n                ranges.add(new Range());\n            } else {\n                for (org.apache.accumulo.proxy.thrift.Range range : opts.ranges) {\n                    Range aRange = new Range(range.getStart() == null ? null : Util.fromThrift(range.getStart()), true, range.getStop() == null ? null : Util.fromThrift(range.getStop()), false);\n                    ranges.add(aRange);\n                }\n            }\n            scanner.setRanges(ranges);\n        }\n        UUID uuid = UUID.randomUUID();\n        ScannerPlusIterator spi = new ScannerPlusIterator();\n        spi.scanner = scanner;\n        spi.iterator = scanner.iterator();\n        scannerCache.put(uuid, spi);\n        return uuid.toString();\n    } catch (Exception e) {\n        throw translateException(e);\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic String createBatchScanner(ByteBuffer login, String tableName, BatchScanOptions opts) throws TException {\n    try {\n        Connector connector = getConnector(login);\n        int threads = 10;\n        Authorizations auth;\n        if (opts != null && opts.isSetAuthorizations()) {\n            auth = getAuthorizations(opts.authorizations);\n        } else {\n            auth = connector.securityOperations().getUserAuthorizations(connector.whoami());\n        }\n        if (opts != null && opts.threads > 0)\n            threads = opts.threads;\n        BatchScanner scanner = connector.createBatchScanner(tableName, auth, threads);\n        if (opts != null) {\n            if (opts.iterators != null) {\n                for (org.apache.accumulo.proxy.thrift.IteratorSetting iter : opts.iterators) {\n                    IteratorSetting is = new IteratorSetting(iter.getPriority(), iter.getName(), iter.getIteratorClass(), iter.getProperties());\n                    scanner.addScanIterator(is);\n                }\n            }\n            ArrayList<Range> ranges = new ArrayList<Range>();\n            if (opts.ranges == null) {\n                ranges.add(new Range());\n            } else {\n                for (org.apache.accumulo.proxy.thrift.Range range : opts.ranges) {\n                    Range aRange = new Range(range.getStart() == null ? null : Util.fromThrift(range.getStart()), true, range.getStop() == null ? null : Util.fromThrift(range.getStop()), false);\n                    ranges.add(aRange);\n                }\n            }\n            scanner.setRanges(ranges);\n        }\n        UUID uuid = UUID.randomUUID();\n        ScannerPlusIterator spi = new ScannerPlusIterator();\n        spi.scanner = scanner;\n        spi.iterator = scanner.iterator();\n        scannerCache.put(uuid, spi);\n        return uuid.toString();\n    } catch (Exception e) {\n        throw translateException(e);\n    }\n}", "lc": 1.2727272727272727, "pi": 1.0095693779904304, "ma": 1.6, "nbd": 1.0, "ml": 0.9166666666666666, "d": 0.5178571428571429, "mi": -0.8260747004933048, "fo": 1.6666666666666667, "r": -0.02631578947368421, "e": 1.9842602997873475}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-8624_597883fa", "label": 1, "code": "private MethodInfo chooseBestPossibleMethodInfo(Exchange exchange, Collection<MethodInfo> operationList, Object body, List<MethodInfo> possibles, List<MethodInfo> possiblesWithException, List<MethodInfo> possibleWithCustomAnnotation) throws AmbiguousMethodCallException {\n    Exception exception = ExpressionBuilder.exchangeExceptionExpression().evaluate(exchange, Exception.class);\n    if (exception != null && possiblesWithException.size() == 1) {\n        LOG.trace(\"Exchange has exception set so we prefer method that also has exception as parameter\");\n        // prefer the method that accepts exception in case we have an exception also\n        return possiblesWithException.get(0);\n    } else if (possibles.size() == 1) {\n        return possibles.get(0);\n    } else if (possibles.isEmpty()) {\n        LOG.trace(\"No possible methods so now trying to convert body to parameter types\");\n        // let's try converting\n        Object newBody = null;\n        MethodInfo matched = null;\n        int matchCounter = 0;\n        for (MethodInfo methodInfo : operationList) {\n            if (methodInfo.getBodyParameterType().isInstance(body)) {\n                return methodInfo;\n            }\n            // we should only try to convert, as we are looking for best match\n            Object value = exchange.getContext().getTypeConverter().tryConvertTo(methodInfo.getBodyParameterType(), exchange, body);\n            if (value != null) {\n                if (LOG.isTraceEnabled()) {\n                    LOG.trace(\"Converted body from: {} to: {}\", body.getClass().getCanonicalName(), methodInfo.getBodyParameterType().getCanonicalName());\n                }\n                matchCounter++;\n                newBody = value;\n                matched = methodInfo;\n            }\n        }\n        if (matchCounter > 1) {\n            throw new AmbiguousMethodCallException(exchange, Arrays.asList(matched, matched));\n        }\n        if (matched != null) {\n            LOG.trace(\"Setting converted body: {}\", body);\n            Message in = exchange.getIn();\n            in.setBody(newBody);\n            return matched;\n        }\n    } else {\n        // if we only have a single method with custom annotations, let's use that one\n        if (possibleWithCustomAnnotation.size() == 1) {\n            MethodInfo answer = possibleWithCustomAnnotation.get(0);\n            LOG.trace(\"There are only one method with annotations so we choose it: {}\", answer);\n            return answer;\n        }\n        // try to choose among multiple methods with annotations\n        MethodInfo chosen = chooseMethodWithCustomAnnotations(exchange, possibles);\n        if (chosen != null) {\n            return chosen;\n        }\n        // just make sure the methods aren't all actually the same\n        chosen = getSingleCovariantMethod(possibles);\n        if (chosen != null) {\n            return chosen;\n        }\n        throw new AmbiguousMethodCallException(exchange, possibles);\n    }\n    // cannot find a good method to use\n    return null;\n}", "code_comment": NaN, "code_no_comment": "private MethodInfo chooseBestPossibleMethodInfo(Exchange exchange, Collection<MethodInfo> operationList, Object body, List<MethodInfo> possibles, List<MethodInfo> possiblesWithException, List<MethodInfo> possibleWithCustomAnnotation) throws AmbiguousMethodCallException {\n    Exception exception = ExpressionBuilder.exchangeExceptionExpression().evaluate(exchange, Exception.class);\n    if (exception != null && possiblesWithException.size() == 1) {\n        LOG.trace(\"Exchange has exception set so we prefer method that also has exception as parameter\");\n                return possiblesWithException.get(0);\n    } else if (possibles.size() == 1) {\n        return possibles.get(0);\n    } else if (possibles.isEmpty()) {\n        LOG.trace(\"No possible methods so now trying to convert body to parameter types\");\n                Object newBody = null;\n        MethodInfo matched = null;\n        int matchCounter = 0;\n        for (MethodInfo methodInfo : operationList) {\n            if (methodInfo.getBodyParameterType().isInstance(body)) {\n                return methodInfo;\n            }\n                        Object value = exchange.getContext().getTypeConverter().tryConvertTo(methodInfo.getBodyParameterType(), exchange, body);\n            if (value != null) {\n                if (LOG.isTraceEnabled()) {\n                    LOG.trace(\"Converted body from: {} to: {}\", body.getClass().getCanonicalName(), methodInfo.getBodyParameterType().getCanonicalName());\n                }\n                matchCounter++;\n                newBody = value;\n                matched = methodInfo;\n            }\n        }\n        if (matchCounter > 1) {\n            throw new AmbiguousMethodCallException(exchange, Arrays.asList(matched, matched));\n        }\n        if (matched != null) {\n            LOG.trace(\"Setting converted body: {}\", body);\n            Message in = exchange.getIn();\n            in.setBody(newBody);\n            return matched;\n        }\n    } else {\n                if (possibleWithCustomAnnotation.size() == 1) {\n            MethodInfo answer = possibleWithCustomAnnotation.get(0);\n            LOG.trace(\"There are only one method with annotations so we choose it: {}\", answer);\n            return answer;\n        }\n                MethodInfo chosen = chooseMethodWithCustomAnnotations(exchange, possibles);\n        if (chosen != null) {\n            return chosen;\n        }\n                chosen = getSingleCovariantMethod(possibles);\n        if (chosen != null) {\n            return chosen;\n        }\n        throw new AmbiguousMethodCallException(exchange, possibles);\n    }\n        return null;\n}", "lc": 1.7727272727272727, "pi": 0.5406698564593301, "ma": 2.2, "nbd": 2.0, "ml": 1.5833333333333333, "d": 1.2142857142857142, "mi": -0.944749823819591, "fo": 2.0, "r": -0.02631578947368421, "e": 3.4953637269987263}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-9700_4d03e9de", "label": 1, "code": "@Override\npublic boolean process(final Exchange exchange, final AsyncCallback callback) {\n    WaitForTaskToComplete wait = waitForTaskToComplete;\n    if (exchange.getProperty(Exchange.ASYNC_WAIT) != null) {\n        wait = exchange.getProperty(Exchange.ASYNC_WAIT, WaitForTaskToComplete.class);\n    }\n    if (wait == WaitForTaskToComplete.Always || (wait == WaitForTaskToComplete.IfReplyExpected && ExchangeHelper.isOutCapable(exchange))) {\n        // do not handover the completion as we wait for the copy to complete, and copy its result back when it done\n        Exchange copy = prepareCopy(exchange, false);\n        // latch that waits until we are complete\n        final CountDownLatch latch = new CountDownLatch(1);\n        // we should wait for the reply so install a on completion so we know when its complete\n        copy.addOnCompletion(new SynchronizationAdapter() {\n\n            @Override\n            public void onDone(Exchange response) {\n                // check for timeout, which then already would have invoked the latch\n                if (latch.getCount() == 0) {\n                    if (log.isTraceEnabled()) {\n                        log.trace(\"{}. Timeout occurred so response will be ignored: {}\", this, response.hasOut() ? response.getOut() : response.getIn());\n                    }\n                    return;\n                } else {\n                    if (log.isTraceEnabled()) {\n                        log.trace(\"{} with response: {}\", this, response.hasOut() ? response.getOut() : response.getIn());\n                    }\n                    try {\n                        ExchangeHelper.copyResults(exchange, response);\n                    } finally {\n                        // always ensure latch is triggered\n                        latch.countDown();\n                    }\n                }\n            }\n\n            @Override\n            public boolean allowHandover() {\n                // at this point in the routing (at this leg), instead of at the very last (this ensure timeout is honored)\n                return false;\n            }\n\n            @Override\n            public String toString() {\n                return \"onDone at endpoint: \" + endpoint;\n            }\n        });\n        log.trace(\"Adding Exchange to queue: {}\", copy);\n        try {\n            addToQueue(copy);\n        } catch (SedaConsumerNotAvailableException e) {\n            exchange.setException(e);\n            callback.done(true);\n            return true;\n        }\n        if (timeout > 0) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Waiting for task to complete using timeout (ms): {} at [{}]\", timeout, endpoint.getEndpointUri());\n            }\n            // lets see if we can get the task done before the timeout\n            boolean done = false;\n            try {\n                done = latch.await(timeout, TimeUnit.MILLISECONDS);\n            } catch (InterruptedException e) {\n            // ignore\n            }\n            if (!done) {\n                exchange.setException(new ExchangeTimedOutException(exchange, timeout));\n                // remove timed out Exchange from queue\n                endpoint.getQueue().remove(copy);\n                // count down to indicate timeout\n                latch.countDown();\n            }\n        } else {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Waiting for task to complete (blocking) at [{}]\", endpoint.getEndpointUri());\n            }\n            // no timeout then wait until its done\n            try {\n                latch.await();\n            } catch (InterruptedException e) {\n            // ignore\n            }\n        }\n    } else {\n        // no wait, eg its a InOnly then just add to queue and return\n        // handover the completion so its the copy which performs that, as we do not wait\n        Exchange copy = prepareCopy(exchange, true);\n        log.trace(\"Adding Exchange to queue: {}\", copy);\n        try {\n            addToQueue(copy);\n        } catch (SedaConsumerNotAvailableException e) {\n            exchange.setException(e);\n            callback.done(true);\n            return true;\n        }\n    }\n    // we use OnCompletion on the Exchange to callback and wait for the Exchange to be done\n    // so we should just signal the callback we are done synchronously\n    callback.done(true);\n    return true;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean process(final Exchange exchange, final AsyncCallback callback) {\n    WaitForTaskToComplete wait = waitForTaskToComplete;\n    if (exchange.getProperty(Exchange.ASYNC_WAIT) != null) {\n        wait = exchange.getProperty(Exchange.ASYNC_WAIT, WaitForTaskToComplete.class);\n    }\n    if (wait == WaitForTaskToComplete.Always || (wait == WaitForTaskToComplete.IfReplyExpected && ExchangeHelper.isOutCapable(exchange))) {\n                Exchange copy = prepareCopy(exchange, false);\n                final CountDownLatch latch = new CountDownLatch(1);\n                copy.addOnCompletion(new SynchronizationAdapter() {\n\n            @Override\n            public void onDone(Exchange response) {\n                                if (latch.getCount() == 0) {\n                    if (log.isTraceEnabled()) {\n                        log.trace(\"{}. Timeout occurred so response will be ignored: {}\", this, response.hasOut() ? response.getOut() : response.getIn());\n                    }\n                    return;\n                } else {\n                    if (log.isTraceEnabled()) {\n                        log.trace(\"{} with response: {}\", this, response.hasOut() ? response.getOut() : response.getIn());\n                    }\n                    try {\n                        ExchangeHelper.copyResults(exchange, response);\n                    } finally {\n                                                latch.countDown();\n                    }\n                }\n            }\n\n            @Override\n            public boolean allowHandover() {\n                                return false;\n            }\n\n            @Override\n            public String toString() {\n                return \"onDone at endpoint: \" + endpoint;\n            }\n        });\n        log.trace(\"Adding Exchange to queue: {}\", copy);\n        try {\n            addToQueue(copy);\n        } catch (SedaConsumerNotAvailableException e) {\n            exchange.setException(e);\n            callback.done(true);\n            return true;\n        }\n        if (timeout > 0) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Waiting for task to complete using timeout (ms): {} at [{}]\", timeout, endpoint.getEndpointUri());\n            }\n                        boolean done = false;\n            try {\n                done = latch.await(timeout, TimeUnit.MILLISECONDS);\n            } catch (InterruptedException e) {\n                        }\n            if (!done) {\n                exchange.setException(new ExchangeTimedOutException(exchange, timeout));\n                                endpoint.getQueue().remove(copy);\n                                latch.countDown();\n            }\n        } else {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Waiting for task to complete (blocking) at [{}]\", endpoint.getEndpointUri());\n            }\n                        try {\n                latch.await();\n            } catch (InterruptedException e) {\n                        }\n        }\n    } else {\n                        Exchange copy = prepareCopy(exchange, true);\n        log.trace(\"Adding Exchange to queue: {}\", copy);\n        try {\n            addToQueue(copy);\n        } catch (SedaConsumerNotAvailableException e) {\n            exchange.setException(e);\n            callback.done(true);\n            return true;\n        }\n    }\n            callback.done(true);\n    return true;\n}", "lc": 3.090909090909091, "pi": 1.2105263157894735, "ma": 2.4, "nbd": 1.0, "ml": 1.5833333333333333, "d": 1.7718253968253967, "mi": -1.1680056377730794, "fo": 2.8333333333333335, "r": -0.02631578947368421, "e": 5.40878846031938}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-373_bfe4623c", "label": 1, "code": "/**\n * {@inheritDoc}\n */\n@Override\npublic void clear() {\n    value = Double.NaN;\n    n = 0;\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "@Override\npublic void clear() {\n    value = Double.NaN;\n    n = 0;\n}", "lc": -0.4090909090909091, "pi": -0.49282296650717716, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.7293868921775897, "fo": -0.5, "r": 2.6052631578947367, "e": -0.16279340490885932}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1429_c2f5ca6c", "label": 1, "code": "/**\n * Returns up to {@code limit} child nodes, starting at the given\n * {@code name} (exclusive).\n *\n * @param parent the parent node.\n * @param name the name of the lower bound child node (exclusive) or\n *             {@code null}, if the method should start with the first known\n *             child node.\n * @param limit the maximum number of child nodes to return.\n * @return the child nodes.\n */\n@Nonnull\nIterable<DocumentNodeState> getChildNodes(@Nonnull final DocumentNodeState parent, @Nullable final String name, final int limit) {\n    // return straight away\n    if (checkNotNull(parent).hasNoChildren()) {\n        return Collections.emptyList();\n    }\n    final Revision readRevision = parent.getLastRevision();\n    return Iterables.transform(getChildren(parent, name, limit).children, new Function<String, DocumentNodeState>() {\n\n        @Override\n        public DocumentNodeState apply(String input) {\n            return getNode(input, readRevision);\n        }\n    });\n}", "code_comment": "/**\n * Returns up to {@code limit} child nodes, starting at the given\n * {@code name} (exclusive).\n *\n * @param parent the parent node.\n * @param name the name of the lower bound child node (exclusive) or\n *             {@code null}, if the method should start with the first known\n *             child node.\n * @param limit the maximum number of child nodes to return.\n * @return the child nodes.\n */\n", "code_no_comment": "@Nonnull\nIterable<DocumentNodeState> getChildNodes(@Nonnull final DocumentNodeState parent, @Nullable final String name, final int limit) {\n        if (checkNotNull(parent).hasNoChildren()) {\n        return Collections.emptyList();\n    }\n    final Revision readRevision = parent.getLastRevision();\n    return Iterables.transform(getChildren(parent, name, limit).children, new Function<String, DocumentNodeState>() {\n\n        @Override\n        public DocumentNodeState apply(String input) {\n            return getNode(input, readRevision);\n        }\n    });\n}", "lc": -0.045454545454545456, "pi": 0.27272727272727265, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": -0.3650793650793651, "mi": 0.02410147991543351, "fo": 0.08333333333333333, "r": 0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3884_b772ff87", "label": 3, "code": "@Override\nprotected String newValue(String currentValue, String appendValue) {\n    // Short circuit when one of the values is empty: return the other value.\n    if (Strings.isEmpty(currentValue))\n        return appendValue != null ? appendValue : \"\";\n    else if (Strings.isEmpty(appendValue))\n        return currentValue != null ? currentValue : \"\";\n    StringBuilder sb = new StringBuilder(currentValue);\n    sb.append((getSeparator() == null ? \"\" : getSeparator()));\n    sb.append(appendValue);\n    return sb.toString();\n}", "code_comment": NaN, "code_no_comment": "@Override\nprotected String newValue(String currentValue, String appendValue) {\n        if (Strings.isEmpty(currentValue))\n        return appendValue != null ? appendValue : \"\";\n    else if (Strings.isEmpty(appendValue))\n        return currentValue != null ? currentValue : \"\";\n    StringBuilder sb = new StringBuilder(currentValue);\n    sb.append((getSeparator() == null ? \"\" : getSeparator()));\n    sb.append(appendValue);\n    return sb.toString();\n}", "lc": -0.13636363636363635, "pi": -0.15311004784689008, "ma": 0.4, "nbd": -1.0, "ml": 0.4166666666666667, "d": 0.12500000000000003, "mi": 0.09006342494714606, "fo": 0.08333333333333333, "r": 0.31578947368421056, "e": 0.031633846809932975}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3713_e1168a57", "label": 3, "code": "/**\n *  @param userAgent\n *             The user agent string\n *  @return Whether the user agent matches this enum or not\n */\npublic boolean matches(String userAgent) {\n    if (notAllowedList != null) {\n        for (String value : notAllowedList) {\n            if (userAgent.contains(value)) {\n                return false;\n            }\n        }\n    }\n    for (List<String> detectionGroup : detectionStrings) {\n        for (String detectionString : detectionGroup) {\n            if (!userAgent.contains(detectionString)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n}", "code_comment": "/**\n *  @param userAgent\n *             The user agent string\n *  @return Whether the user agent matches this enum or not\n */\n", "code_no_comment": "public boolean matches(String userAgent) {\n    if (notAllowedList != null) {\n        for (String value : notAllowedList) {\n            if (userAgent.contains(value)) {\n                return false;\n            }\n        }\n    }\n    for (List<String> detectionGroup : detectionStrings) {\n        for (String detectionString : detectionGroup) {\n            if (!userAgent.contains(detectionString)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n}", "lc": 0.18181818181818182, "pi": 0.8229665071770335, "ma": 0.6, "nbd": 0.5, "ml": 0.25, "d": 0.0039682539682539715, "mi": -0.07935165609584206, "fo": -0.3333333333333333, "r": 0.763157894736842, "e": -0.06689833624361036}
{"project_name": "Lang", "project_version": 30, "label": 3, "code": "// ContainsAny\n// -----------------------------------------------------------------------\n/**\n * <p>Checks if the CharSequence contains any character in the given\n * set of characters.</p>\n *\n * <p>A <code>null</code> CharSequence will return <code>false</code>.\n * A <code>null</code> or zero length search array will return <code>false</code>.</p>\n *\n * <pre>\n * StringUtils.containsAny(null, *)                = false\n * StringUtils.containsAny(\"\", *)                  = false\n * StringUtils.containsAny(*, null)                = false\n * StringUtils.containsAny(*, [])                  = false\n * StringUtils.containsAny(\"zzabyycdxx\",['z','a']) = true\n * StringUtils.containsAny(\"zzabyycdxx\",['b','y']) = true\n * StringUtils.containsAny(\"aba\", ['z'])           = false\n * </pre>\n *\n * @param cs  the CharSequence to check, may be null\n * @param searchChars  the chars to search for, may be null\n * @return the <code>true</code> if any of the chars are found,\n * <code>false</code> if no match or null input\n * @since 2.4\n */\npublic static boolean containsAny(CharSequence cs, char[] searchChars) {\n    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n        return false;\n    }\n    int csLength = cs.length();\n    int searchLength = searchChars.length;\n    int csLast = csLength - 1;\n    int searchLast = searchLength - 1;\n    for (int i = 0; i < csLength; i++) {\n        char ch = cs.charAt(i);\n        for (int j = 0; j < searchLength; j++) {\n            if (searchChars[j] == ch) {\n                if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                    // missing low surrogate, fine, like String.indexOf(String)\n                    if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                        return true;\n                    }\n                } else {\n                    // ch is in the Basic Multilingual Plane\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}", "code_comment": "/**\n * <p>Checks if the CharSequence contains any character in the given\n * set of characters.</p>\n *\n * <p>A <code>null</code> CharSequence will return <code>false</code>.\n * A <code>null</code> or zero length search array will return <code>false</code>.</p>\n *\n * <pre>\n * StringUtils.containsAny(null, *)                = false\n * StringUtils.containsAny(\"\", *)                  = false\n * StringUtils.containsAny(*, null)                = false\n * StringUtils.containsAny(*, [])                  = false\n * StringUtils.containsAny(\"zzabyycdxx\",['z','a']) = true\n * StringUtils.containsAny(\"zzabyycdxx\",['b','y']) = true\n * StringUtils.containsAny(\"aba\", ['z'])           = false\n * </pre>\n *\n * @param cs  the CharSequence to check, may be null\n * @param searchChars  the chars to search for, may be null\n * @return the <code>true</code> if any of the chars are found,\n * <code>false</code> if no match or null input\n * @since 2.4\n */\n", "code_no_comment": "public static boolean containsAny(CharSequence cs, char[] searchChars) {\n    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n        return false;\n    }\n    int csLength = cs.length();\n    int searchLength = searchChars.length;\n    int csLast = csLength - 1;\n    int searchLast = searchLength - 1;\n    for (int i = 0; i < csLength; i++) {\n        char ch = cs.charAt(i);\n        for (int j = 0; j < searchLength; j++) {\n            if (searchChars[j] == ch) {\n                if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                        return true;\n                    }\n                } else {\n                                        return true;\n                }\n            }\n        }\n    }\n    return false;\n}", "lc": 0.45454545454545453, "pi": 1.8708133971291867, "ma": 0.6, "nbd": 1.5, "ml": 1.4166666666666667, "d": 2.222222222222222, "mi": -0.4074700493305143, "fo": -0.08333333333333333, "r": -0.02631578947368421, "e": 2.415631357226419}
{"project_name": "Closure", "project_version": 169, "label": 2, "code": "/**\n * Two function types are equal if their signatures match. Since they don't\n * have signatures, two interfaces are equal if their names match.\n */\nboolean checkFunctionEquivalenceHelper(FunctionType that, boolean tolerateUnknowns) {\n    if (isConstructor()) {\n        if (that.isConstructor()) {\n            return this == that;\n        }\n        return false;\n    }\n    if (isInterface()) {\n        if (that.isInterface()) {\n            return getReferenceName().equals(that.getReferenceName());\n        }\n        return false;\n    }\n    if (that.isInterface()) {\n        return false;\n    }\n    return typeOfThis.checkEquivalenceHelper(that.typeOfThis, tolerateUnknowns) && call.checkArrowEquivalenceHelper(that.call, tolerateUnknowns);\n}", "code_comment": "/**\n * Two function types are equal if their signatures match. Since they don't\n * have signatures, two interfaces are equal if their names match.\n */\n", "code_no_comment": "boolean checkFunctionEquivalenceHelper(FunctionType that, boolean tolerateUnknowns) {\n    if (isConstructor()) {\n        if (that.isConstructor()) {\n            return this == that;\n        }\n        return false;\n    }\n    if (isInterface()) {\n        if (that.isInterface()) {\n            return getReferenceName().equals(that.getReferenceName());\n        }\n        return false;\n    }\n    if (that.isInterface()) {\n        return false;\n    }\n    return typeOfThis.checkEquivalenceHelper(that.typeOfThis, tolerateUnknowns) && call.checkArrowEquivalenceHelper(that.call, tolerateUnknowns);\n}", "lc": 0.18181818181818182, "pi": 0.1626794258373205, "ma": 0.4, "nbd": 0.0, "ml": 0.3333333333333333, "d": 0.07341269841269839, "mi": -0.09682875264270617, "fo": 0.3333333333333333, "r": -0.02631578947368421, "e": -0.028037781734986136}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-5681_78c73502", "label": 1, "code": "public boolean process(Exchange exchange, AsyncCallback callback) {\n    final AtomicExchange result = new AtomicExchange();\n    final Iterable<ProcessorExchangePair> pairs;\n    // multicast uses fine grained error handling on the output processors\n    // so use try .. catch to cater for this\n    boolean exhaust = false;\n    try {\n        boolean sync = true;\n        pairs = createProcessorExchangePairs(exchange);\n        // after we have created the processors we consider the exchange as exhausted if an unhandled\n        // exception was thrown, (used in the catch block)\n        // if the processors is working in Streaming model, the exchange could not be processed at this point.\n        exhaust = !isStreaming();\n        if (isParallelProcessing()) {\n            // ensure an executor is set when running in parallel\n            ObjectHelper.notNull(executorService, \"executorService\", this);\n            doProcessParallel(exchange, result, pairs, isStreaming(), callback);\n        } else {\n            sync = doProcessSequential(exchange, result, pairs, callback);\n        }\n        if (!sync) {\n            // so we break out now, then the callback will be invoked which then continue routing from where we left here\n            return false;\n        }\n    } catch (Throwable e) {\n        exchange.setException(e);\n        // and do the done work\n        doDone(exchange, null, callback, true, exhaust);\n        return true;\n    }\n    // multicasting was processed successfully\n    // and do the done work\n    Exchange subExchange = result.get() != null ? result.get() : null;\n    doDone(exchange, subExchange, callback, true, exhaust);\n    return true;\n}", "code_comment": NaN, "code_no_comment": "public boolean process(Exchange exchange, AsyncCallback callback) {\n    final AtomicExchange result = new AtomicExchange();\n    final Iterable<ProcessorExchangePair> pairs;\n            boolean exhaust = false;\n    try {\n        boolean sync = true;\n        pairs = createProcessorExchangePairs(exchange);\n                                exhaust = !isStreaming();\n        if (isParallelProcessing()) {\n                        ObjectHelper.notNull(executorService, \"executorService\", this);\n            doProcessParallel(exchange, result, pairs, isStreaming(), callback);\n        } else {\n            sync = doProcessSequential(exchange, result, pairs, callback);\n        }\n        if (!sync) {\n                        return false;\n        }\n    } catch (Throwable e) {\n        exchange.setException(e);\n                doDone(exchange, null, callback, true, exhaust);\n        return true;\n    }\n            Exchange subExchange = result.get() != null ? result.get() : null;\n    doDone(exchange, subExchange, callback, true, exhaust);\n    return true;\n}", "lc": 0.5454545454545454, "pi": 0.1578947368421051, "ma": 0.2, "nbd": 0.0, "ml": 0.08333333333333333, "d": 0.07738095238095236, "mi": -0.41649048625792817, "fo": 0.5, "r": -0.02631578947368421, "e": 0.23713974516346534}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4927_8c827e33", "label": 1, "code": "private void checkHeader() {\n    if (bufferedWritten) {\n        throw new IllegalStateException(\"Header was already written to response!\");\n    }\n}", "code_comment": NaN, "code_no_comment": "private void checkHeader() {\n    if (bufferedWritten) {\n        throw new IllegalStateException(\"Header was already written to response!\");\n    }\n}", "lc": -0.4090909090909091, "pi": 0.0, "ma": -0.2, "nbd": -0.5, "ml": -0.25, "d": -0.3650793650793651, "mi": 0.8638477801268499, "fo": -0.5, "r": 2.263157894736842, "e": -0.16279340490885932}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-724_9c8bb934", "label": 1, "code": "/**\n * Generate a random int value uniformly distributed between\n * <code>lower</code> and <code>upper</code>, inclusive.\n *\n * @param lower\n *            the lower bound.\n * @param upper\n *            the upper bound.\n * @return the random integer.\n * @throws NumberIsTooLargeException if {@code lower >= upper}.\n */\npublic int nextInt(int lower, int upper) {\n    if (lower >= upper) {\n        throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND, lower, upper, false);\n    }\n    double r = getRan().nextDouble();\n    return (int) ((r * upper) + ((1.0 - r) * lower) + r);\n}", "code_comment": "/**\n * Generate a random int value uniformly distributed between\n * <code>lower</code> and <code>upper</code>, inclusive.\n *\n * @param lower\n *            the lower bound.\n * @param upper\n *            the upper bound.\n * @return the random integer.\n * @throws NumberIsTooLargeException if {@code lower >= upper}.\n */\n", "code_no_comment": "public int nextInt(int lower, int upper) {\n    if (lower >= upper) {\n        throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND, lower, upper, false);\n    }\n    double r = getRan().nextDouble();\n    return (int) ((r * upper) + ((1.0 - r) * lower) + r);\n}", "lc": -0.3181818181818182, "pi": -0.20574162679425848, "ma": -0.2, "nbd": -0.5, "ml": -0.16666666666666666, "d": 0.32936507936507936, "mi": 0.38012684989429163, "fo": -0.3333333333333333, "r": 0.5, "e": 0.01529019207828355}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5966_d547fcd4", "label": 1, "code": "/**\n *  Extract the locale from the filename\n *\n *  @param path\n *             The file path\n *  @return The updated path, without the locale\n */\npublic static PathLocale getLocaleFromFilename(String path) {\n    String extension = \"\";\n    int pos = path.lastIndexOf('.');\n    if (pos != -1) {\n        extension = path.substring(pos);\n        path = path.substring(0, pos);\n    }\n    String filename = Strings.lastPathComponent(path, '/');\n    Matcher matcher = LOCALE_PATTERN.matcher(filename);\n    if (matcher.find()) {\n        String language = matcher.group(1);\n        String country = matcher.group(3);\n        String variant = matcher.group(5);\n        // did we find a language?\n        if (language != null) {\n            if (isoLanguages.contains(language) == false) {\n                language = null;\n                country = null;\n                variant = null;\n            }\n        }\n        // did we find a country?\n        if ((language != null) && (country != null)) {\n            if (isoCountries.contains(country) == false) {\n                country = null;\n                variant = null;\n            }\n        }\n        if (language != null) {\n            pos = path.length() - filename.length() + matcher.start();\n            String basePath = path.substring(0, pos) + extension;\n            Locale locale = new Locale(language, country != null ? country : \"\", variant != null ? variant : \"\");\n            return new PathLocale(basePath, locale);\n        }\n    }\n    return new PathLocale(path + extension, null);\n}", "code_comment": "/**\n *  Extract the locale from the filename\n *\n *  @param path\n *             The file path\n *  @return The updated path, without the locale\n */\n", "code_no_comment": "public static PathLocale getLocaleFromFilename(String path) {\n    String extension = \"\";\n    int pos = path.lastIndexOf('.');\n    if (pos != -1) {\n        extension = path.substring(pos);\n        path = path.substring(0, pos);\n    }\n    String filename = Strings.lastPathComponent(path, '/');\n    Matcher matcher = LOCALE_PATTERN.matcher(filename);\n    if (matcher.find()) {\n        String language = matcher.group(1);\n        String country = matcher.group(3);\n        String variant = matcher.group(5);\n                if (language != null) {\n            if (isoLanguages.contains(language) == false) {\n                language = null;\n                country = null;\n                variant = null;\n            }\n        }\n                if ((language != null) && (country != null)) {\n            if (isoCountries.contains(country) == false) {\n                country = null;\n                variant = null;\n            }\n        }\n        if (language != null) {\n            pos = path.length() - filename.length() + matcher.start();\n            String basePath = path.substring(0, pos) + extension;\n            Locale locale = new Locale(language, country != null ? country : \"\", variant != null ? variant : \"\");\n            return new PathLocale(basePath, locale);\n        }\n    }\n    return new PathLocale(path + extension, null);\n}", "lc": 0.9545454545454546, "pi": 0.722488038277512, "ma": 1.2, "nbd": 0.5, "ml": 1.0, "d": 1.4047619047619047, "mi": -0.6851303735024662, "fo": 0.75, "r": -0.02631578947368421, "e": 3.0055658327714476}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-4113_27300d81", "label": 0, "code": "public static String toString(ByteBuffer bytes) {\n    return new String(bytes.array(), bytes.position(), bytes.remaining(), UTF_8);\n}", "code_comment": NaN, "code_no_comment": "public static String toString(ByteBuffer bytes) {\n    return new String(bytes.array(), bytes.position(), bytes.remaining(), UTF_8);\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.9244538407329099, "fo": -0.25, "r": -0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-606_f0fbacab", "label": 1, "code": "/**\n * The underlying {@link org.apache.jackrabbit.oak.api.TreeLocation} of this item.\n * @return  tree location of the underlying item\n * @throws InvalidItemStateException if the location points to a stale item\n */\n@Nonnull\npublic TreeLocation getLocation() throws InvalidItemStateException {\n    TreeLocation location = getLocationOrNull();\n    if (!location.exists()) {\n        throw new InvalidItemStateException(\"Item is stale\");\n    }\n    return location;\n}", "code_comment": "/**\n * The underlying {@link org.apache.jackrabbit.oak.api.TreeLocation} of this item.\n * @return  tree location of the underlying item\n * @throws InvalidItemStateException if the location points to a stale item\n */\n", "code_no_comment": "@Nonnull\npublic TreeLocation getLocation() throws InvalidItemStateException {\n    TreeLocation location = getLocationOrNull();\n    if (!location.exists()) {\n        throw new InvalidItemStateException(\"Item is stale\");\n    }\n    return location;\n}", "lc": -0.2727272727272727, "pi": -0.16267942583732073, "ma": -0.2, "nbd": -0.5, "ml": -0.25, "d": -0.07936507936507939, "mi": 0.429739252995067, "fo": -0.3333333333333333, "r": 1.8157894736842104, "e": -0.12823890781049196}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-6918_5761250c", "label": 1, "code": "public boolean process(Exchange exchange, final AsyncCallback callback) {\n    if (!isStarted()) {\n        exchange.setException(new IllegalStateException(\"SendProcessor has not been started: \" + this));\n        callback.done(true);\n        return true;\n    }\n    // we should preserve existing MEP so remember old MEP\n    // if you want to permanently to change the MEP then use .setExchangePattern in the DSL\n    final ExchangePattern existingPattern = exchange.getPattern();\n    // if we have a producer then use that as its optimized\n    if (producer != null) {\n        // record timing for sending the exchange using the producer\n        final StopWatch watch = new StopWatch();\n        final Exchange target = configureExchange(exchange, pattern);\n        EventHelper.notifyExchangeSending(exchange.getContext(), target, destination);\n        LOG.debug(\">>>> {} {}\", destination, exchange);\n        return producer.process(exchange, new AsyncCallback() {\n\n            @Override\n            public void done(boolean doneSync) {\n                try {\n                    // restore previous MEP\n                    target.setPattern(existingPattern);\n                    // emit event that the exchange was sent to the endpoint\n                    long timeTaken = watch.stop();\n                    EventHelper.notifyExchangeSent(target.getContext(), target, destination, timeTaken);\n                } finally {\n                    callback.done(doneSync);\n                }\n            }\n        });\n    }\n    // send the exchange to the destination using the producer cache for the non optimized producers\n    return producerCache.doInAsyncProducer(destination, exchange, pattern, callback, new AsyncProducerCallback() {\n\n        public boolean doInAsyncProducer(Producer producer, AsyncProcessor asyncProducer, final Exchange exchange, ExchangePattern pattern, final AsyncCallback callback) {\n            final Exchange target = configureExchange(exchange, pattern);\n            LOG.debug(\">>>> {} {}\", destination, exchange);\n            return asyncProducer.process(target, new AsyncCallback() {\n\n                public void done(boolean doneSync) {\n                    // restore previous MEP\n                    target.setPattern(existingPattern);\n                    // signal we are done\n                    callback.done(doneSync);\n                }\n            });\n        }\n    });\n}", "code_comment": NaN, "code_no_comment": "public boolean process(Exchange exchange, final AsyncCallback callback) {\n    if (!isStarted()) {\n        exchange.setException(new IllegalStateException(\"SendProcessor has not been started: \" + this));\n        callback.done(true);\n        return true;\n    }\n            final ExchangePattern existingPattern = exchange.getPattern();\n        if (producer != null) {\n                final StopWatch watch = new StopWatch();\n        final Exchange target = configureExchange(exchange, pattern);\n        EventHelper.notifyExchangeSending(exchange.getContext(), target, destination);\n        LOG.debug(\">>>> {} {}\", destination, exchange);\n        return producer.process(exchange, new AsyncCallback() {\n\n            @Override\n            public void done(boolean doneSync) {\n                try {\n                                        target.setPattern(existingPattern);\n                                        long timeTaken = watch.stop();\n                    EventHelper.notifyExchangeSent(target.getContext(), target, destination, timeTaken);\n                } finally {\n                    callback.done(doneSync);\n                }\n            }\n        });\n    }\n        return producerCache.doInAsyncProducer(destination, exchange, pattern, callback, new AsyncProducerCallback() {\n\n        public boolean doInAsyncProducer(Producer producer, AsyncProcessor asyncProducer, final Exchange exchange, ExchangePattern pattern, final AsyncCallback callback) {\n            final Exchange target = configureExchange(exchange, pattern);\n            LOG.debug(\">>>> {} {}\", destination, exchange);\n            return asyncProducer.process(target, new AsyncCallback() {\n\n                public void done(boolean doneSync) {\n                                        target.setPattern(existingPattern);\n                                        callback.done(doneSync);\n                }\n            });\n        }\n    });\n}", "lc": 1.0909090909090908, "pi": 1.3588516746411483, "ma": -0.2, "nbd": 0.5, "ml": -0.08333333333333333, "d": 0.6309523809523809, "mi": -0.6431289640591964, "fo": 1.1666666666666667, "r": -0.02631578947368421, "e": 1.2492845328861302}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1429_c2f5ca6c", "label": 1, "code": "String diff(@Nonnull final String fromRevisionId, @Nonnull final String toRevisionId, @Nonnull final String path) throws MicroKernelException {\n    if (fromRevisionId.equals(toRevisionId)) {\n        return \"\";\n    }\n    Revision fromRev = Revision.fromString(fromRevisionId);\n    Revision toRev = Revision.fromString(toRevisionId);\n    final DocumentNodeState from = getNode(path, fromRev);\n    final DocumentNodeState to = getNode(path, toRev);\n    if (from == null || to == null) {\n        // TODO implement correct behavior if the node does't/didn't exist\n        String msg = String.format(\"Diff is only supported if the node exists in both cases. \" + \"Node [%s], fromRev [%s] -> %s, toRev [%s] -> %s\", path, fromRev, from != null, toRev, to != null);\n        throw new MicroKernelException(msg);\n    }\n    PathRev key = diffCacheKey(path, fromRev, toRev);\n    try {\n        JsopWriter writer = new JsopStream();\n        diffProperties(from, to, writer);\n        return writer.toString() + diffCache.get(key, new Callable<StringValue>() {\n\n            @Override\n            public StringValue call() throws Exception {\n                return new StringValue(diffImpl(from, to));\n            }\n        });\n    } catch (ExecutionException e) {\n        if (e.getCause() instanceof MicroKernelException) {\n            throw (MicroKernelException) e.getCause();\n        } else {\n            throw new MicroKernelException(e.getCause());\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "String diff(@Nonnull final String fromRevisionId, @Nonnull final String toRevisionId, @Nonnull final String path) throws MicroKernelException {\n    if (fromRevisionId.equals(toRevisionId)) {\n        return \"\";\n    }\n    Revision fromRev = Revision.fromString(fromRevisionId);\n    Revision toRev = Revision.fromString(toRevisionId);\n    final DocumentNodeState from = getNode(path, fromRev);\n    final DocumentNodeState to = getNode(path, toRev);\n    if (from == null || to == null) {\n                String msg = String.format(\"Diff is only supported if the node exists in both cases. \" + \"Node [%s], fromRev [%s] -> %s, toRev [%s] -> %s\", path, fromRev, from != null, toRev, to != null);\n        throw new MicroKernelException(msg);\n    }\n    PathRev key = diffCacheKey(path, fromRev, toRev);\n    try {\n        JsopWriter writer = new JsopStream();\n        diffProperties(from, to, writer);\n        return writer.toString() + diffCache.get(key, new Callable<StringValue>() {\n\n            @Override\n            public StringValue call() throws Exception {\n                return new StringValue(diffImpl(from, to));\n            }\n        });\n    } catch (ExecutionException e) {\n        if (e.getCause() instanceof MicroKernelException) {\n            throw (MicroKernelException) e.getCause();\n        } else {\n            throw new MicroKernelException(e.getCause());\n        }\n    }\n}", "lc": 0.7272727272727273, "pi": 0.36363636363636354, "ma": 0.8, "nbd": 0.0, "ml": 0.3333333333333333, "d": 0.5317460317460316, "mi": -0.5664552501761803, "fo": 0.6666666666666666, "r": -0.02631578947368421, "e": 1.0999510151392033}
{"project_name": "Closure", "project_version": 147, "label": 2, "code": "/**\n * Insert checks for the parameters of the function.\n */\nprivate void visitFunction(NodeTraversal t, Node n) {\n    FunctionType funType = (FunctionType) n.getJSType();\n    Node block = n.getLastChild();\n    Node paramName = NodeUtil.getFnParameters(n).getFirstChild();\n    Node insertionPoint = null;\n    for (Node paramType : funType.getParameters()) {\n        // Can this ever happen?\n        if (paramName == null) {\n            return;\n        }\n        Node checkNode = createCheckTypeCallNode(paramType.getJSType(), paramName.cloneTree());\n        if (checkNode == null) {\n            // We don't know how to check this parameter type.\n            paramName = paramName.getNext();\n            continue;\n        }\n        checkNode = new Node(Token.EXPR_RESULT, checkNode);\n        if (insertionPoint == null) {\n            block.addChildToFront(checkNode);\n        } else {\n            block.addChildAfter(checkNode, insertionPoint);\n        }\n        compiler.reportCodeChange();\n        paramName = paramName.getNext();\n        insertionPoint = checkNode;\n    }\n}", "code_comment": "/**\n * Insert checks for the parameters of the function.\n */\n", "code_no_comment": "private void visitFunction(NodeTraversal t, Node n) {\n    FunctionType funType = (FunctionType) n.getJSType();\n    Node block = n.getLastChild();\n    Node paramName = NodeUtil.getFnParameters(n).getFirstChild();\n    Node insertionPoint = null;\n    for (Node paramType : funType.getParameters()) {\n                if (paramName == null) {\n            return;\n        }\n        Node checkNode = createCheckTypeCallNode(paramType.getJSType(), paramName.cloneTree());\n        if (checkNode == null) {\n                        paramName = paramName.getNext();\n            continue;\n        }\n        checkNode = new Node(Token.EXPR_RESULT, checkNode);\n        if (insertionPoint == null) {\n            block.addChildToFront(checkNode);\n        } else {\n            block.addChildAfter(checkNode, insertionPoint);\n        }\n        compiler.reportCodeChange();\n        paramName = paramName.getNext();\n        insertionPoint = checkNode;\n    }\n}", "lc": 0.5, "pi": 0.1913875598086124, "ma": 0.4, "nbd": 0.0, "ml": 0.08333333333333333, "d": 0.06547619047619045, "mi": -0.39873150105708227, "fo": 0.5833333333333334, "r": -0.02631578947368421, "e": 0.20934861660990184}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-2968_59685903", "label": 1, "code": "@Override\npublic final void setOutputType(TypeInformation<OUT> outTypeInfo, ExecutionConfig executionConfig) {\n    if (userFunction instanceof OutputTypeConfigurable) {\n        @SuppressWarnings(\"unchecked\")\n        OutputTypeConfigurable<OUT> typeConfigurable = (OutputTypeConfigurable<OUT>) userFunction;\n        typeConfigurable.setOutputType(outTypeInfo, executionConfig);\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic final void setOutputType(TypeInformation<OUT> outTypeInfo, ExecutionConfig executionConfig) {\n    if (userFunction instanceof OutputTypeConfigurable) {\n        @SuppressWarnings(\"unchecked\")\n        OutputTypeConfigurable<OUT> typeConfigurable = (OutputTypeConfigurable<OUT>) userFunction;\n        typeConfigurable.setOutputType(outTypeInfo, executionConfig);\n    }\n}", "lc": -0.2727272727272727, "pi": 0.22488038277511951, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": -0.3650793650793651, "mi": 0.35954897815362913, "fo": -0.4166666666666667, "r": 0.13157894736842105, "e": -0.16279340490885932}
{"project_name": "Closure", "project_version": 68, "label": 2, "code": "/**\n * Parses a {@link JSDocInfo} object. This parsing method reads all tokens\n * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the\n * {@link JsDocToken#EOC} is returned.\n *\n * @return {@code true} if JSDoc information was correctly parsed,\n *     {@code false} otherwise\n */\nboolean parse() {\n    int lineno;\n    int charno;\n    // JSTypes are represented as Rhino AST nodes, and then resolved later.\n    JSTypeExpression type;\n    state = State.SEARCHING_ANNOTATION;\n    skipEOLs();\n    JsDocToken token = next();\n    List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();\n    // Always record that we have a comment.\n    if (jsdocBuilder.shouldParseDocumentation()) {\n        ExtractionInfo blockInfo = extractBlockComment(token);\n        token = blockInfo.token;\n        if (!blockInfo.string.isEmpty()) {\n            jsdocBuilder.recordBlockDescription(blockInfo.string);\n        }\n    } else {\n        if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) {\n            // Mark that there was a description, but don't bother marking\n            // what it was.\n            jsdocBuilder.recordBlockDescription(\"\");\n        }\n    }\n    // Parse the actual JsDoc.\n    retry: for (; ; ) {\n        switch(token) {\n            case ANNOTATION:\n                if (state == State.SEARCHING_ANNOTATION) {\n                    state = State.SEARCHING_NEWLINE;\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n                    String annotationName = stream.getString();\n                    Annotation annotation = annotationNames.get(annotationName);\n                    if (annotation == null) {\n                        parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n                    } else {\n                        // Mark the beginning of the annotation.\n                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n                        switch(annotation) {\n                            case AUTHOR:\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo authorInfo = extractSingleLineBlock();\n                                    String author = authorInfo.string;\n                                    if (author.length() == 0) {\n                                        parser.addParserWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        jsdocBuilder.addAuthor(author);\n                                    }\n                                    token = authorInfo.token;\n                                } else {\n                                    token = eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case CONSTANT:\n                                if (!jsdocBuilder.recordConstancy()) {\n                                    parser.addParserWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n                                }\n                                token = eatTokensUntilEOL();\n                                continue retry;\n                            case CONSTRUCTOR:\n                                if (!jsdocBuilder.recordConstructor()) {\n                                    if (jsdocBuilder.isInterfaceRecorded()) {\n                                        parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token = eatTokensUntilEOL();\n                                continue retry;\n                            case DEPRECATED:\n                                if (!jsdocBuilder.recordDeprecated()) {\n                                    parser.addParserWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n                                }\n                                // Find the reason/description, if any.\n                                ExtractionInfo reasonInfo = extractMultilineTextualBlock(token);\n                                String reason = reasonInfo.string;\n                                if (reason.length() > 0) {\n                                    jsdocBuilder.recordDeprecationReason(reason);\n                                }\n                                token = reasonInfo.token;\n                                continue retry;\n                            case INTERFACE:\n                                if (!jsdocBuilder.recordInterface()) {\n                                    if (jsdocBuilder.isConstructorRecorded()) {\n                                        parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token = eatTokensUntilEOL();\n                                continue retry;\n                            case DESC:\n                                if (jsdocBuilder.isDescriptionRecorded()) {\n                                    parser.addParserWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n                                    token = eatTokensUntilEOL();\n                                    continue retry;\n                                } else {\n                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);\n                                    String description = descriptionInfo.string;\n                                    jsdocBuilder.recordDescription(description);\n                                    token = descriptionInfo.token;\n                                    continue retry;\n                                }\n                            case FILE_OVERVIEW:\n                                String fileOverview = \"\";\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n                                    fileOverview = fileOverviewInfo.string;\n                                    token = fileOverviewInfo.token;\n                                } else {\n                                    token = eatTokensUntilEOL(token);\n                                }\n                                if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo != null) {\n                                    parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n                                }\n                                continue retry;\n                            case LICENSE:\n                            case PRESERVE:\n                                ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);\n                                String preserve = preserveInfo.string;\n                                if (preserve.length() > 0) {\n                                    if (fileLevelJsDocBuilder != null) {\n                                        fileLevelJsDocBuilder.append(preserve);\n                                    }\n                                }\n                                token = preserveInfo.token;\n                                continue retry;\n                            case ENUM:\n                                token = next();\n                                lineno = stream.getLineno();\n                                charno = stream.getCharno();\n                                type = null;\n                                if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\n                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));\n                                }\n                                if (type == null) {\n                                    type = createJSTypeExpression(newStringNode(\"number\"));\n                                }\n                                if (!jsdocBuilder.recordEnumParameterType(type)) {\n                                    parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                }\n                                token = eatTokensUntilEOL(token);\n                                continue retry;\n                            case EXPORT:\n                                if (!jsdocBuilder.recordExport()) {\n                                    parser.addParserWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n                                }\n                                token = eatTokensUntilEOL();\n                                continue retry;\n                            case EXTERNS:\n                                if (!jsdocBuilder.recordExterns()) {\n                                    parser.addParserWarning(\"msg.jsdoc.externs\", stream.getLineno(), stream.getCharno());\n                                }\n                                token = eatTokensUntilEOL();\n                                continue retry;\n                            case JAVA_DISPATCH:\n                                if (!jsdocBuilder.recordJavaDispatch()) {\n                                    parser.addParserWarning(\"msg.jsdoc.javadispatch\", stream.getLineno(), stream.getCharno());\n                                }\n                                token = eatTokensUntilEOL();\n                                continue retry;\n                            case EXTENDS:\n                            case IMPLEMENTS:\n                                skipEOLs();\n                                token = next();\n                                lineno = stream.getLineno();\n                                charno = stream.getCharno();\n                                boolean matchingRc = false;\n                                if (token == JsDocToken.LC) {\n                                    token = next();\n                                    matchingRc = true;\n                                }\n                                if (token == JsDocToken.STRING) {\n                                    Node typeNode = parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);\n                                    lineno = stream.getLineno();\n                                    charno = stream.getCharno();\n                                    typeNode = wrapNode(Token.BANG, typeNode);\n                                    if (typeNode != null && !matchingRc) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                    type = createJSTypeExpression(typeNode);\n                                    if (annotation == Annotation.EXTENDS) {\n                                        // record the extended type, check later\n                                        extendedTypes.add(new ExtendedTypeInfo(type, stream.getLineno(), stream.getCharno()));\n                                    } else {\n                                        Preconditions.checkState(annotation == Annotation.IMPLEMENTS);\n                                        if (!jsdocBuilder.recordImplementedInterface(type)) {\n                                            parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n                                        }\n                                    }\n                                    token = next();\n                                    if (matchingRc) {\n                                        if (token != JsDocToken.RC) {\n                                            parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                        }\n                                    } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) {\n                                        parser.addTypeWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n                                    }\n                                } else {\n                                    parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n                                }\n                                token = eatTokensUntilEOL(token);\n                                continue retry;\n                            case HIDDEN:\n                                if (!jsdocBuilder.recordHiddenness()) {\n                                    parser.addParserWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n                                }\n                                token = eatTokensUntilEOL();\n                                continue retry;\n                            case LENDS:\n                                skipEOLs();\n                                matchingRc = false;\n                                if (match(JsDocToken.LC)) {\n                                    token = next();\n                                    matchingRc = true;\n                                }\n                                if (match(JsDocToken.STRING)) {\n                                    token = next();\n                                    if (!jsdocBuilder.recordLends(stream.getString())) {\n                                        parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\", stream.getLineno(), stream.getCharno());\n                                    }\n                                } else {\n                                    parser.addTypeWarning(\"msg.jsdoc.lends.missing\", stream.getLineno(), stream.getCharno());\n                                }\n                                if (matchingRc && !match(JsDocToken.RC)) {\n                                    parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                }\n                                token = eatTokensUntilEOL();\n                                continue retry;\n                            case MEANING:\n                                ExtractionInfo meaningInfo = extractMultilineTextualBlock(token);\n                                String meaning = meaningInfo.string;\n                                token = meaningInfo.token;\n                                if (!jsdocBuilder.recordMeaning(meaning)) {\n                                    parser.addParserWarning(\"msg.jsdoc.meaning.extra\", stream.getLineno(), stream.getCharno());\n                                }\n                                continue retry;\n                            case NO_ALIAS:\n                                if (!jsdocBuilder.recordNoAlias()) {\n                                    parser.addParserWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n                                }\n                                token = eatTokensUntilEOL();\n                                continue retry;\n                            case NO_COMPILE:\n                                if (!jsdocBuilder.recordNoCompile()) {\n                                    parser.addParserWarning(\"msg.jsdoc.nocompile\", stream.getLineno(), stream.getCharno());\n                                }\n                                token = eatTokensUntilEOL();\n                                continue retry;\n                            case NO_TYPE_CHECK:\n                                if (!jsdocBuilder.recordNoTypeCheck()) {\n                                    parser.addParserWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n                                }\n                                token = eatTokensUntilEOL();\n                                continue retry;\n                            case NOT_IMPLEMENTED:\n                                token = eatTokensUntilEOL();\n                                continue retry;\n                            case INHERIT_DOC:\n                            case OVERRIDE:\n                                if (!jsdocBuilder.recordOverride()) {\n                                    parser.addTypeWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n                                }\n                                token = eatTokensUntilEOL();\n                                continue retry;\n                            case THROWS:\n                                skipEOLs();\n                                token = next();\n                                lineno = stream.getLineno();\n                                charno = stream.getCharno();\n                                type = null;\n                                if (token == JsDocToken.LC) {\n                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));\n                                    if (type == null) {\n                                        // parsing error reported during recursive descent\n                                        // recovering parsing\n                                        token = eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                }\n                                // *Update* the token to that after the type annotation.\n                                token = current();\n                                // Save the throw type.\n                                jsdocBuilder.recordThrowType(type);\n                                // Find the throw's description (if applicable).\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);\n                                    String description = descriptionInfo.string;\n                                    if (description.length() > 0) {\n                                        jsdocBuilder.recordThrowDescription(type, description);\n                                    }\n                                    token = descriptionInfo.token;\n                                } else {\n                                    token = eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case PARAM:\n                                skipEOLs();\n                                token = next();\n                                lineno = stream.getLineno();\n                                charno = stream.getCharno();\n                                type = null;\n                                if (token == JsDocToken.LC) {\n                                    type = createJSTypeExpression(parseAndRecordParamTypeNode(token));\n                                    if (type == null) {\n                                        // parsing error reported during recursive descent\n                                        // recovering parsing\n                                        token = eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                    skipEOLs();\n                                    token = next();\n                                    lineno = stream.getLineno();\n                                    charno = stream.getCharno();\n                                }\n                                String name = null;\n                                boolean isBracketedParam = JsDocToken.LB == token;\n                                if (isBracketedParam) {\n                                    token = next();\n                                }\n                                if (JsDocToken.STRING != token) {\n                                    parser.addTypeWarning(\"msg.missing.variable.name\", lineno, charno);\n                                } else {\n                                    name = stream.getString();\n                                    if (isBracketedParam) {\n                                        token = next();\n                                        // system.\n                                        if (JsDocToken.EQUALS == token) {\n                                            token = next();\n                                            if (JsDocToken.STRING == token) {\n                                                token = next();\n                                            }\n                                        }\n                                        if (JsDocToken.RB != token) {\n                                            reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                                        } else if (type != null) {\n                                            // Make the type expression optional, if it isn't\n                                            // already.\n                                            type = JSTypeExpression.makeOptionalArg(type);\n                                        }\n                                    }\n                                    // for handling properties of params.\n                                    if (name.indexOf('.') > -1) {\n                                        name = null;\n                                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                                        if (jsdocBuilder.hasParameter(name)) {\n                                            parser.addTypeWarning(\"msg.dup.variable.name\", name, lineno, charno);\n                                        } else {\n                                            parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n                                        }\n                                    }\n                                }\n                                if (name == null) {\n                                    token = eatTokensUntilEOL(token);\n                                    continue retry;\n                                }\n                                jsdocBuilder.markName(name, lineno, charno);\n                                // Find the parameter's description (if applicable).\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token);\n                                    String paramDescription = paramDescriptionInfo.string;\n                                    if (paramDescription.length() > 0) {\n                                        jsdocBuilder.recordParameterDescription(name, paramDescription);\n                                    }\n                                    token = paramDescriptionInfo.token;\n                                } else {\n                                    token = eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case PRESERVE_TRY:\n                                if (!jsdocBuilder.recordPreserveTry()) {\n                                    parser.addParserWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n                                }\n                                token = eatTokensUntilEOL();\n                                continue retry;\n                            case PRIVATE:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                                    parser.addParserWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n                                }\n                                token = eatTokensUntilEOL();\n                                continue retry;\n                            case PROTECTED:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                                    parser.addParserWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n                                }\n                                token = eatTokensUntilEOL();\n                                continue retry;\n                            case PUBLIC:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                                    parser.addParserWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n                                }\n                                token = eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SHADOW:\n                                if (!jsdocBuilder.recordNoShadow()) {\n                                    parser.addParserWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n                                }\n                                token = eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SIDE_EFFECTS:\n                                if (!jsdocBuilder.recordNoSideEffects()) {\n                                    parser.addParserWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n                                }\n                                token = eatTokensUntilEOL();\n                                continue retry;\n                            case MODIFIES:\n                                token = parseModifiesTag(next());\n                                continue retry;\n                            case IMPLICIT_CAST:\n                                if (!jsdocBuilder.recordImplicitCast()) {\n                                    parser.addTypeWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n                                }\n                                token = eatTokensUntilEOL();\n                                continue retry;\n                            case SEE:\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo referenceInfo = extractSingleLineBlock();\n                                    String reference = referenceInfo.string;\n                                    if (reference.length() == 0) {\n                                        parser.addParserWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        jsdocBuilder.addReference(reference);\n                                    }\n                                    token = referenceInfo.token;\n                                } else {\n                                    token = eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case SUPPRESS:\n                                token = parseSuppressTag(next());\n                                continue retry;\n                            case TEMPLATE:\n                                ExtractionInfo templateInfo = extractSingleLineBlock();\n                                String templateTypeName = templateInfo.string;\n                                if (templateTypeName.length() == 0) {\n                                    parser.addTypeWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n                                } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {\n                                    parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n                                }\n                                token = templateInfo.token;\n                                continue retry;\n                            case VERSION:\n                                ExtractionInfo versionInfo = extractSingleLineBlock();\n                                String version = versionInfo.string;\n                                if (version.length() == 0) {\n                                    parser.addParserWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    if (!jsdocBuilder.recordVersion(version)) {\n                                        parser.addParserWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token = versionInfo.token;\n                                continue retry;\n                            case DEFINE:\n                            case RETURN:\n                            case THIS:\n                            case TYPE:\n                            case TYPEDEF:\n                                lineno = stream.getLineno();\n                                charno = stream.getCharno();\n                                Node typeNode = null;\n                                if (!lookAheadForTypeAnnotation() && annotation == Annotation.RETURN) {\n                                    // If RETURN doesn't have a type annotation, record\n                                    // it as the unknown type.\n                                    typeNode = newNode(Token.QMARK);\n                                } else {\n                                    skipEOLs();\n                                    token = next();\n                                    typeNode = parseAndRecordTypeNode(token, lineno, charno);\n                                }\n                                if (annotation == Annotation.THIS) {\n                                    typeNode = wrapNode(Token.BANG, typeNode);\n                                    if (typeNode != null && token != JsDocToken.LC) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                }\n                                type = createJSTypeExpression(typeNode);\n                                if (type == null) {\n                                // error reported during recursive descent\n                                // recovering parsing\n                                } else {\n                                    switch(annotation) {\n                                        case DEFINE:\n                                            if (!jsdocBuilder.recordDefineType(type)) {\n                                                parser.addParserWarning(\"msg.jsdoc.define\", lineno, charno);\n                                            }\n                                            break;\n                                        case RETURN:\n                                            if (!jsdocBuilder.recordReturnType(type)) {\n                                                parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                                break;\n                                            }\n                                            // Find the return's description (if applicable).\n                                            if (jsdocBuilder.shouldParseDocumentation()) {\n                                                ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token);\n                                                String returnDescription = returnDescriptionInfo.string;\n                                                if (returnDescription.length() > 0) {\n                                                    jsdocBuilder.recordReturnDescription(returnDescription);\n                                                }\n                                                token = returnDescriptionInfo.token;\n                                            } else {\n                                                token = eatTokensUntilEOL(token);\n                                            }\n                                            continue retry;\n                                        case THIS:\n                                            if (!jsdocBuilder.recordThisType(type)) {\n                                                parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPE:\n                                            if (!jsdocBuilder.recordType(type)) {\n                                                parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPEDEF:\n                                            if (!jsdocBuilder.recordTypedef(type)) {\n                                                parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                    }\n                                    token = eatTokensUntilEOL();\n                                }\n                                continue retry;\n                        }\n                    }\n                }\n                break;\n            case EOC:\n                if (hasParsedFileOverviewDocInfo()) {\n                    fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();\n                }\n                checkExtendedTypes(extendedTypes);\n                return true;\n            case EOF:\n                // discard any accumulated information\n                jsdocBuilder.build(null);\n                parser.addParserWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n                checkExtendedTypes(extendedTypes);\n                return false;\n            case EOL:\n                if (state == State.SEARCHING_NEWLINE) {\n                    state = State.SEARCHING_ANNOTATION;\n                }\n                token = next();\n                continue retry;\n            default:\n                if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {\n                    token = next();\n                    continue retry;\n                } else {\n                    state = State.SEARCHING_NEWLINE;\n                    token = eatTokensUntilEOL();\n                    continue retry;\n                }\n        }\n        // next token\n        token = next();\n    }\n}", "code_comment": "/**\n * Parses a {@link JSDocInfo} object. This parsing method reads all tokens\n * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the\n * {@link JsDocToken#EOC} is returned.\n *\n * @return {@code true} if JSDoc information was correctly parsed,\n *     {@code false} otherwise\n */\n", "code_no_comment": "boolean parse() {\n    int lineno;\n    int charno;\n        JSTypeExpression type;\n    state = State.SEARCHING_ANNOTATION;\n    skipEOLs();\n    JsDocToken token = next();\n    List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();\n        if (jsdocBuilder.shouldParseDocumentation()) {\n        ExtractionInfo blockInfo = extractBlockComment(token);\n        token = blockInfo.token;\n        if (!blockInfo.string.isEmpty()) {\n            jsdocBuilder.recordBlockDescription(blockInfo.string);\n        }\n    } else {\n        if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) {\n                                    jsdocBuilder.recordBlockDescription(\"\");\n        }\n    }\n        retry: for (; ; ) {\n        switch(token) {\n            case ANNOTATION:\n                if (state == State.SEARCHING_ANNOTATION) {\n                    state = State.SEARCHING_NEWLINE;\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n                    String annotationName = stream.getString();\n                    Annotation annotation = annotationNames.get(annotationName);\n                    if (annotation == null) {\n                        parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n                    } else {\n                                                jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n                        switch(annotation) {\n                            case AUTHOR:\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo authorInfo = extractSingleLineBlock();\n                                    String author = authorInfo.string;\n                                    if (author.length() == 0) {\n                                        parser.addParserWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        jsdocBuilder.addAuthor(author);\n                                    }\n                                    token = authorInfo.token;\n                                } else {\n                                    token = eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case CONSTANT:\n                                if (!jsdocBuilder.recordConstancy()) {\n                                    parser.addParserWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n                                }\n                                token = eatTokensUntilEOL();\n                                continue retry;\n                            case CONSTRUCTOR:\n                                if (!jsdocBuilder.recordConstructor()) {\n                                    if (jsdocBuilder.isInterfaceRecorded()) {\n                                        parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token = eatTokensUntilEOL();\n                                continue retry;\n                            case DEPRECATED:\n                                if (!jsdocBuilder.recordDeprecated()) {\n                                    parser.addParserWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n                                }\n                                                                ExtractionInfo reasonInfo = extractMultilineTextualBlock(token);\n                                String reason = reasonInfo.string;\n                                if (reason.length() > 0) {\n                                    jsdocBuilder.recordDeprecationReason(reason);\n                                }\n                                token = reasonInfo.token;\n                                continue retry;\n                            case INTERFACE:\n                                if (!jsdocBuilder.recordInterface()) {\n                                    if (jsdocBuilder.isConstructorRecorded()) {\n                                        parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token = eatTokensUntilEOL();\n                                continue retry;\n                            case DESC:\n                                if (jsdocBuilder.isDescriptionRecorded()) {\n                                    parser.addParserWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n                                    token = eatTokensUntilEOL();\n                                    continue retry;\n                                } else {\n                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);\n                                    String description = descriptionInfo.string;\n                                    jsdocBuilder.recordDescription(description);\n                                    token = descriptionInfo.token;\n                                    continue retry;\n                                }\n                            case FILE_OVERVIEW:\n                                String fileOverview = \"\";\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n                                    fileOverview = fileOverviewInfo.string;\n                                    token = fileOverviewInfo.token;\n                                } else {\n                                    token = eatTokensUntilEOL(token);\n                                }\n                                if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo != null) {\n                                    parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n                                }\n                                continue retry;\n                            case LICENSE:\n                            case PRESERVE:\n                                ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);\n                                String preserve = preserveInfo.string;\n                                if (preserve.length() > 0) {\n                                    if (fileLevelJsDocBuilder != null) {\n                                        fileLevelJsDocBuilder.append(preserve);\n                                    }\n                                }\n                                token = preserveInfo.token;\n                                continue retry;\n                            case ENUM:\n                                token = next();\n                                lineno = stream.getLineno();\n                                charno = stream.getCharno();\n                                type = null;\n                                if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\n                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));\n                                }\n                                if (type == null) {\n                                    type = createJSTypeExpression(newStringNode(\"number\"));\n                                }\n                                if (!jsdocBuilder.recordEnumParameterType(type)) {\n                                    parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                }\n                                token = eatTokensUntilEOL(token);\n                                continue retry;\n                            case EXPORT:\n                                if (!jsdocBuilder.recordExport()) {\n                                    parser.addParserWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n                                }\n                                token = eatTokensUntilEOL();\n                                continue retry;\n                            case EXTERNS:\n                                if (!jsdocBuilder.recordExterns()) {\n                                    parser.addParserWarning(\"msg.jsdoc.externs\", stream.getLineno(), stream.getCharno());\n                                }\n                                token = eatTokensUntilEOL();\n                                continue retry;\n                            case JAVA_DISPATCH:\n                                if (!jsdocBuilder.recordJavaDispatch()) {\n                                    parser.addParserWarning(\"msg.jsdoc.javadispatch\", stream.getLineno(), stream.getCharno());\n                                }\n                                token = eatTokensUntilEOL();\n                                continue retry;\n                            case EXTENDS:\n                            case IMPLEMENTS:\n                                skipEOLs();\n                                token = next();\n                                lineno = stream.getLineno();\n                                charno = stream.getCharno();\n                                boolean matchingRc = false;\n                                if (token == JsDocToken.LC) {\n                                    token = next();\n                                    matchingRc = true;\n                                }\n                                if (token == JsDocToken.STRING) {\n                                    Node typeNode = parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);\n                                    lineno = stream.getLineno();\n                                    charno = stream.getCharno();\n                                    typeNode = wrapNode(Token.BANG, typeNode);\n                                    if (typeNode != null && !matchingRc) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                    type = createJSTypeExpression(typeNode);\n                                    if (annotation == Annotation.EXTENDS) {\n                                                                                extendedTypes.add(new ExtendedTypeInfo(type, stream.getLineno(), stream.getCharno()));\n                                    } else {\n                                        Preconditions.checkState(annotation == Annotation.IMPLEMENTS);\n                                        if (!jsdocBuilder.recordImplementedInterface(type)) {\n                                            parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n                                        }\n                                    }\n                                    token = next();\n                                    if (matchingRc) {\n                                        if (token != JsDocToken.RC) {\n                                            parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                        }\n                                    } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) {\n                                        parser.addTypeWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n                                    }\n                                } else {\n                                    parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n                                }\n                                token = eatTokensUntilEOL(token);\n                                continue retry;\n                            case HIDDEN:\n                                if (!jsdocBuilder.recordHiddenness()) {\n                                    parser.addParserWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n                                }\n                                token = eatTokensUntilEOL();\n                                continue retry;\n                            case LENDS:\n                                skipEOLs();\n                                matchingRc = false;\n                                if (match(JsDocToken.LC)) {\n                                    token = next();\n                                    matchingRc = true;\n                                }\n                                if (match(JsDocToken.STRING)) {\n                                    token = next();\n                                    if (!jsdocBuilder.recordLends(stream.getString())) {\n                                        parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\", stream.getLineno(), stream.getCharno());\n                                    }\n                                } else {\n                                    parser.addTypeWarning(\"msg.jsdoc.lends.missing\", stream.getLineno(), stream.getCharno());\n                                }\n                                if (matchingRc && !match(JsDocToken.RC)) {\n                                    parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                }\n                                token = eatTokensUntilEOL();\n                                continue retry;\n                            case MEANING:\n                                ExtractionInfo meaningInfo = extractMultilineTextualBlock(token);\n                                String meaning = meaningInfo.string;\n                                token = meaningInfo.token;\n                                if (!jsdocBuilder.recordMeaning(meaning)) {\n                                    parser.addParserWarning(\"msg.jsdoc.meaning.extra\", stream.getLineno(), stream.getCharno());\n                                }\n                                continue retry;\n                            case NO_ALIAS:\n                                if (!jsdocBuilder.recordNoAlias()) {\n                                    parser.addParserWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n                                }\n                                token = eatTokensUntilEOL();\n                                continue retry;\n                            case NO_COMPILE:\n                                if (!jsdocBuilder.recordNoCompile()) {\n                                    parser.addParserWarning(\"msg.jsdoc.nocompile\", stream.getLineno(), stream.getCharno());\n                                }\n                                token = eatTokensUntilEOL();\n                                continue retry;\n                            case NO_TYPE_CHECK:\n                                if (!jsdocBuilder.recordNoTypeCheck()) {\n                                    parser.addParserWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n                                }\n                                token = eatTokensUntilEOL();\n                                continue retry;\n                            case NOT_IMPLEMENTED:\n                                token = eatTokensUntilEOL();\n                                continue retry;\n                            case INHERIT_DOC:\n                            case OVERRIDE:\n                                if (!jsdocBuilder.recordOverride()) {\n                                    parser.addTypeWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n                                }\n                                token = eatTokensUntilEOL();\n                                continue retry;\n                            case THROWS:\n                                skipEOLs();\n                                token = next();\n                                lineno = stream.getLineno();\n                                charno = stream.getCharno();\n                                type = null;\n                                if (token == JsDocToken.LC) {\n                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));\n                                    if (type == null) {\n                                                                                                                        token = eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                }\n                                                                token = current();\n                                                                jsdocBuilder.recordThrowType(type);\n                                                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);\n                                    String description = descriptionInfo.string;\n                                    if (description.length() > 0) {\n                                        jsdocBuilder.recordThrowDescription(type, description);\n                                    }\n                                    token = descriptionInfo.token;\n                                } else {\n                                    token = eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case PARAM:\n                                skipEOLs();\n                                token = next();\n                                lineno = stream.getLineno();\n                                charno = stream.getCharno();\n                                type = null;\n                                if (token == JsDocToken.LC) {\n                                    type = createJSTypeExpression(parseAndRecordParamTypeNode(token));\n                                    if (type == null) {\n                                                                                                                        token = eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                    skipEOLs();\n                                    token = next();\n                                    lineno = stream.getLineno();\n                                    charno = stream.getCharno();\n                                }\n                                String name = null;\n                                boolean isBracketedParam = JsDocToken.LB == token;\n                                if (isBracketedParam) {\n                                    token = next();\n                                }\n                                if (JsDocToken.STRING != token) {\n                                    parser.addTypeWarning(\"msg.missing.variable.name\", lineno, charno);\n                                } else {\n                                    name = stream.getString();\n                                    if (isBracketedParam) {\n                                        token = next();\n                                                                                if (JsDocToken.EQUALS == token) {\n                                            token = next();\n                                            if (JsDocToken.STRING == token) {\n                                                token = next();\n                                            }\n                                        }\n                                        if (JsDocToken.RB != token) {\n                                            reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                                        } else if (type != null) {\n                                                                                                                                    type = JSTypeExpression.makeOptionalArg(type);\n                                        }\n                                    }\n                                                                        if (name.indexOf('.') > -1) {\n                                        name = null;\n                                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                                        if (jsdocBuilder.hasParameter(name)) {\n                                            parser.addTypeWarning(\"msg.dup.variable.name\", name, lineno, charno);\n                                        } else {\n                                            parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n                                        }\n                                    }\n                                }\n                                if (name == null) {\n                                    token = eatTokensUntilEOL(token);\n                                    continue retry;\n                                }\n                                jsdocBuilder.markName(name, lineno, charno);\n                                                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token);\n                                    String paramDescription = paramDescriptionInfo.string;\n                                    if (paramDescription.length() > 0) {\n                                        jsdocBuilder.recordParameterDescription(name, paramDescription);\n                                    }\n                                    token = paramDescriptionInfo.token;\n                                } else {\n                                    token = eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case PRESERVE_TRY:\n                                if (!jsdocBuilder.recordPreserveTry()) {\n                                    parser.addParserWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n                                }\n                                token = eatTokensUntilEOL();\n                                continue retry;\n                            case PRIVATE:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                                    parser.addParserWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n                                }\n                                token = eatTokensUntilEOL();\n                                continue retry;\n                            case PROTECTED:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                                    parser.addParserWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n                                }\n                                token = eatTokensUntilEOL();\n                                continue retry;\n                            case PUBLIC:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                                    parser.addParserWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n                                }\n                                token = eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SHADOW:\n                                if (!jsdocBuilder.recordNoShadow()) {\n                                    parser.addParserWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n                                }\n                                token = eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SIDE_EFFECTS:\n                                if (!jsdocBuilder.recordNoSideEffects()) {\n                                    parser.addParserWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n                                }\n                                token = eatTokensUntilEOL();\n                                continue retry;\n                            case MODIFIES:\n                                token = parseModifiesTag(next());\n                                continue retry;\n                            case IMPLICIT_CAST:\n                                if (!jsdocBuilder.recordImplicitCast()) {\n                                    parser.addTypeWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n                                }\n                                token = eatTokensUntilEOL();\n                                continue retry;\n                            case SEE:\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo referenceInfo = extractSingleLineBlock();\n                                    String reference = referenceInfo.string;\n                                    if (reference.length() == 0) {\n                                        parser.addParserWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        jsdocBuilder.addReference(reference);\n                                    }\n                                    token = referenceInfo.token;\n                                } else {\n                                    token = eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case SUPPRESS:\n                                token = parseSuppressTag(next());\n                                continue retry;\n                            case TEMPLATE:\n                                ExtractionInfo templateInfo = extractSingleLineBlock();\n                                String templateTypeName = templateInfo.string;\n                                if (templateTypeName.length() == 0) {\n                                    parser.addTypeWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n                                } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {\n                                    parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n                                }\n                                token = templateInfo.token;\n                                continue retry;\n                            case VERSION:\n                                ExtractionInfo versionInfo = extractSingleLineBlock();\n                                String version = versionInfo.string;\n                                if (version.length() == 0) {\n                                    parser.addParserWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    if (!jsdocBuilder.recordVersion(version)) {\n                                        parser.addParserWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token = versionInfo.token;\n                                continue retry;\n                            case DEFINE:\n                            case RETURN:\n                            case THIS:\n                            case TYPE:\n                            case TYPEDEF:\n                                lineno = stream.getLineno();\n                                charno = stream.getCharno();\n                                Node typeNode = null;\n                                if (!lookAheadForTypeAnnotation() && annotation == Annotation.RETURN) {\n                                                                                                            typeNode = newNode(Token.QMARK);\n                                } else {\n                                    skipEOLs();\n                                    token = next();\n                                    typeNode = parseAndRecordTypeNode(token, lineno, charno);\n                                }\n                                if (annotation == Annotation.THIS) {\n                                    typeNode = wrapNode(Token.BANG, typeNode);\n                                    if (typeNode != null && token != JsDocToken.LC) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                }\n                                type = createJSTypeExpression(typeNode);\n                                if (type == null) {\n                                                                                                } else {\n                                    switch(annotation) {\n                                        case DEFINE:\n                                            if (!jsdocBuilder.recordDefineType(type)) {\n                                                parser.addParserWarning(\"msg.jsdoc.define\", lineno, charno);\n                                            }\n                                            break;\n                                        case RETURN:\n                                            if (!jsdocBuilder.recordReturnType(type)) {\n                                                parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                                break;\n                                            }\n                                                                                        if (jsdocBuilder.shouldParseDocumentation()) {\n                                                ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token);\n                                                String returnDescription = returnDescriptionInfo.string;\n                                                if (returnDescription.length() > 0) {\n                                                    jsdocBuilder.recordReturnDescription(returnDescription);\n                                                }\n                                                token = returnDescriptionInfo.token;\n                                            } else {\n                                                token = eatTokensUntilEOL(token);\n                                            }\n                                            continue retry;\n                                        case THIS:\n                                            if (!jsdocBuilder.recordThisType(type)) {\n                                                parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPE:\n                                            if (!jsdocBuilder.recordType(type)) {\n                                                parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPEDEF:\n                                            if (!jsdocBuilder.recordTypedef(type)) {\n                                                parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                    }\n                                    token = eatTokensUntilEOL();\n                                }\n                                continue retry;\n                        }\n                    }\n                }\n                break;\n            case EOC:\n                if (hasParsedFileOverviewDocInfo()) {\n                    fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();\n                }\n                checkExtendedTypes(extendedTypes);\n                return true;\n            case EOF:\n                                jsdocBuilder.build(null);\n                parser.addParserWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n                checkExtendedTypes(extendedTypes);\n                return false;\n            case EOL:\n                if (state == State.SEARCHING_NEWLINE) {\n                    state = State.SEARCHING_ANNOTATION;\n                }\n                token = next();\n                continue retry;\n            default:\n                if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {\n                    token = next();\n                    continue retry;\n                } else {\n                    state = State.SEARCHING_NEWLINE;\n                    token = eatTokensUntilEOL();\n                    continue retry;\n                }\n        }\n                token = next();\n    }\n}", "lc": 23.545454545454547, "pi": 2.6889952153110044, "ma": 38.0, "nbd": 5.0, "ml": 17.833333333333332, "d": 3.373015873015873, "mi": -3.515292459478505, "fo": 26.083333333333332, "r": -0.02631578947368421, "e": 98.55931259832988}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5165_0d4d1df7", "label": 1, "code": "/**\n *  @param url\n *  @param requestCycle\n */\nprotected void redirectTo(Url url, RequestCycle requestCycle) {\n    WebResponse response = (WebResponse) requestCycle.getResponse();\n    String relativeUrl = requestCycle.getUrlRenderer().renderUrl(url);\n    response.sendRedirect(relativeUrl);\n}", "code_comment": "/**\n *  @param url\n *  @param requestCycle\n */\n", "code_no_comment": "protected void redirectTo(Url url, RequestCycle requestCycle) {\n    WebResponse response = (WebResponse) requestCycle.getResponse();\n    String relativeUrl = requestCycle.getUrlRenderer().renderUrl(url);\n    response.sendRedirect(relativeUrl);\n}", "lc": -0.4090909090909091, "pi": -0.49282296650717716, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.5833685694150811, "fo": -0.16666666666666666, "r": 2.1578947368421053, "e": -0.16279340490885932}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-43_668f08f2", "label": 1, "code": "void apply() throws Exception {\n    addNode(parentNodePath, nodeName, properties);\n}", "code_comment": NaN, "code_no_comment": "void apply() throws Exception {\n    addNode(parentNodePath, nodeName, properties);\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.0329809725158563, "fo": -0.4166666666666667, "r": 0.5263157894736842, "e": -0.16279340490885932}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-393_d4b02f6a", "label": 3, "code": "/**\n * Get the number of evaluations of the objective function.\n * <p>\n * The number of evaluations corresponds to the last call to the\n * {@link #optimize(UnivariateRealFunction, GoalType, double, double) optimize}\n * method. It is 0 if the method has not been called yet.\n * </p>\n * @return number of evaluations of the objective function\n */\nint getEvaluations();", "code_comment": "/**\n * Get the number of evaluations of the objective function.\n * <p>\n * The number of evaluations corresponds to the last call to the\n * {@link #optimize(UnivariateRealFunction, GoalType, double, double) optimize}\n * method. It is 0 if the method has not been called yet.\n * </p>\n * @return number of evaluations of the objective function\n */\n", "code_no_comment": "int getEvaluations();", "lc": -0.5909090909090909, "pi": -1.4306220095693782, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.8696264975334735, "fo": -0.5, "r": 2.526315789473684, "e": -0.16279340490885932}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-326_ce185345", "label": 1, "code": "/**\n * {@inheritDoc}\n */\npublic double getL1Norm() {\n    double res = 0;\n    Iterator iter = entries.iterator();\n    while (iter.hasNext()) {\n        iter.advance();\n        res += Math.abs(iter.value());\n    }\n    return res;\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "public double getL1Norm() {\n    double res = 0;\n    Iterator iter = entries.iterator();\n    while (iter.hasNext()) {\n        iter.advance();\n        res += Math.abs(iter.value());\n    }\n    return res;\n}", "lc": -0.22727272727272727, "pi": -0.15311004784689008, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": -0.0912698412698413, "mi": 0.315292459478506, "fo": -0.08333333333333333, "r": 2.0, "e": -0.11041994433014643}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-9444_baece126", "label": 1, "code": "private AggregationStrategy createAggregationStrategy(RouteContext routeContext) {\n    AggregationStrategy strategy = getAggregationStrategy();\n    if (strategy == null && strategyRef != null) {\n        Object aggStrategy = routeContext.lookup(strategyRef, Object.class);\n        if (aggStrategy instanceof AggregationStrategy) {\n            strategy = (AggregationStrategy) aggStrategy;\n        } else if (aggStrategy != null) {\n            AggregationStrategyBeanAdapter adapter = new AggregationStrategyBeanAdapter(aggStrategy, getStrategyMethodName());\n            if (getStrategyMethodAllowNull() != null) {\n                adapter.setAllowNullNewExchange(getStrategyMethodAllowNull());\n                adapter.setAllowNullOldExchange(getStrategyMethodAllowNull());\n            }\n            strategy = adapter;\n        } else {\n            throw new IllegalArgumentException(\"Cannot find AggregationStrategy in Registry with name: \" + strategyRef);\n        }\n    }\n    if (strategy == null) {\n        // fallback to use latest\n        strategy = new UseLatestAggregationStrategy();\n    }\n    if (strategy instanceof CamelContextAware) {\n        ((CamelContextAware) strategy).setCamelContext(routeContext.getCamelContext());\n    }\n    return strategy;\n}", "code_comment": NaN, "code_no_comment": "private AggregationStrategy createAggregationStrategy(RouteContext routeContext) {\n    AggregationStrategy strategy = getAggregationStrategy();\n    if (strategy == null && strategyRef != null) {\n        Object aggStrategy = routeContext.lookup(strategyRef, Object.class);\n        if (aggStrategy instanceof AggregationStrategy) {\n            strategy = (AggregationStrategy) aggStrategy;\n        } else if (aggStrategy != null) {\n            AggregationStrategyBeanAdapter adapter = new AggregationStrategyBeanAdapter(aggStrategy, getStrategyMethodName());\n            if (getStrategyMethodAllowNull() != null) {\n                adapter.setAllowNullNewExchange(getStrategyMethodAllowNull());\n                adapter.setAllowNullOldExchange(getStrategyMethodAllowNull());\n            }\n            strategy = adapter;\n        } else {\n            throw new IllegalArgumentException(\"Cannot find AggregationStrategy in Registry with name: \" + strategyRef);\n        }\n    }\n    if (strategy == null) {\n                strategy = new UseLatestAggregationStrategy();\n    }\n    if (strategy instanceof CamelContextAware) {\n        ((CamelContextAware) strategy).setCamelContext(routeContext.getCamelContext());\n    }\n    return strategy;\n}", "lc": 0.5, "pi": 0.6602870813397129, "ma": 0.8, "nbd": 1.0, "ml": 0.5, "d": 0.5436507936507937, "mi": -0.39450317124735734, "fo": 0.3333333333333333, "r": -0.02631578947368421, "e": 0.5352443191968786}
{"project_name": "Closure", "project_version": 27, "label": 2, "code": "public static Node tryFinally(Node tryBody, Node finallyBody) {\n    Preconditions.checkState(tryBody.isLabelName());\n    Preconditions.checkState(finallyBody.isLabelName());\n    Node catchBody = block().copyInformationFrom(tryBody);\n    return new Node(Token.TRY, tryBody, catchBody, finallyBody);\n}", "code_comment": NaN, "code_no_comment": "public static Node tryFinally(Node tryBody, Node finallyBody) {\n    Preconditions.checkState(tryBody.isLabelName());\n    Preconditions.checkState(finallyBody.isLabelName());\n    Node catchBody = block().copyInformationFrom(tryBody);\n    return new Node(Token.TRY, tryBody, catchBody, finallyBody);\n}", "lc": -0.36363636363636365, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.4737138830162087, "fo": 0.0, "r": -0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-2447_5546a1ef", "label": 1, "code": "@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\nprivate <IN1, IN2, OUT> TypeInformation<OUT> createTypeInfoWithTypeHierarchy(ArrayList<Type> typeHierarchy, Type t, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {\n    // check if type is a subclass of tuple\n    if (isClassType(t) && Tuple.class.isAssignableFrom(typeToClass(t))) {\n        Type curT = t;\n        // do not allow usage of Tuple as type\n        if (typeToClass(t).equals(Tuple.class)) {\n            throw new InvalidTypesException(\"Usage of class Tuple as a type is not allowed. Use a concrete subclass (e.g. Tuple1, Tuple2, etc.) instead.\");\n        }\n        // collect the types while moving up for a later top-down\n        while (!(isClassType(curT) && typeToClass(curT).getSuperclass().equals(Tuple.class))) {\n            typeHierarchy.add(curT);\n            curT = typeToClass(curT).getGenericSuperclass();\n        }\n        // check if immediate child of Tuple has generics\n        if (curT instanceof Class<?>) {\n            throw new InvalidTypesException(\"Tuple needs to be parameterized by using generics.\");\n        }\n        typeHierarchy.add(curT);\n        ParameterizedType tupleChild = (ParameterizedType) curT;\n        Type[] subtypes = new Type[tupleChild.getActualTypeArguments().length];\n        // materialize possible type variables\n        for (int i = 0; i < subtypes.length; i++) {\n            // materialize immediate TypeVariables\n            if (tupleChild.getActualTypeArguments()[i] instanceof TypeVariable<?>) {\n                subtypes[i] = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) tupleChild.getActualTypeArguments()[i]);\n            } else // class or parameterized type\n            {\n                subtypes[i] = tupleChild.getActualTypeArguments()[i];\n            }\n        }\n        TypeInformation<?>[] tupleSubTypes = new TypeInformation<?>[subtypes.length];\n        for (int i = 0; i < subtypes.length; i++) {\n            // try to derive the type info of the TypeVariable from the immediate base child input as a last attempt\n            if (subtypes[i] instanceof TypeVariable<?>) {\n                tupleSubTypes[i] = createTypeInfoFromInputs((TypeVariable<?>) subtypes[i], typeHierarchy, in1Type, in2Type);\n                // variable could not be determined\n                if (tupleSubTypes[i] == null) {\n                    throw new InvalidTypesException(\"Type of TypeVariable '\" + ((TypeVariable<?>) subtypes[i]).getName() + \"' in '\" + ((TypeVariable<?>) subtypes[i]).getGenericDeclaration() + \"' could not be determined. This is most likely a type erasure problem. \" + \"The type extraction currently supports types with generic variables only in cases where \" + \"all variables in the return type can be deduced from the input type(s).\");\n                }\n            } else {\n                tupleSubTypes[i] = createTypeInfoWithTypeHierarchy(new ArrayList<Type>(typeHierarchy), subtypes[i], in1Type, in2Type);\n            }\n        }\n        Class<?> tAsClass = null;\n        if (isClassType(t)) {\n            tAsClass = typeToClass(t);\n        }\n        Preconditions.checkNotNull(tAsClass, \"t has a unexpected type\");\n        // check if the class we assumed to be a Tuple so far is actually a pojo because it contains additional fields.\n        // check for additional fields.\n        int fieldCount = countFieldsInClass(tAsClass);\n        if (fieldCount != tupleSubTypes.length) {\n            // the class is not a real tuple because it contains additional fields. treat as a pojo\n            if (t instanceof ParameterizedType) {\n                return (TypeInformation<OUT>) analyzePojo(tAsClass, new ArrayList<Type>(typeHierarchy), (ParameterizedType) t, in1Type, in2Type);\n            } else {\n                return (TypeInformation<OUT>) analyzePojo(tAsClass, new ArrayList<Type>(typeHierarchy), null, in1Type, in2Type);\n            }\n        }\n        return new TupleTypeInfo(tAsClass, tupleSubTypes);\n    } else // e.g. class MyMapper<E> extends MapFunction<String, E>\n    if (t instanceof TypeVariable) {\n        Type typeVar = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) t);\n        if (!(typeVar instanceof TypeVariable)) {\n            return createTypeInfoWithTypeHierarchy(typeHierarchy, typeVar, in1Type, in2Type);\n        } else // try to derive the type info of the TypeVariable from the immediate base child input as a last attempt\n        {\n            TypeInformation<OUT> typeInfo = (TypeInformation<OUT>) createTypeInfoFromInputs((TypeVariable<?>) t, typeHierarchy, in1Type, in2Type);\n            if (typeInfo != null) {\n                return typeInfo;\n            } else {\n                throw new InvalidTypesException(\"Type of TypeVariable '\" + ((TypeVariable<?>) t).getName() + \"' in '\" + ((TypeVariable<?>) t).getGenericDeclaration() + \"' could not be determined. This is most likely a type erasure problem. \" + \"The type extraction currently supports types with generic variables only in cases where \" + \"all variables in the return type can be deduced from the input type(s).\");\n            }\n        }\n    } else // arrays with generics\n    if (t instanceof GenericArrayType) {\n        GenericArrayType genericArray = (GenericArrayType) t;\n        Type componentType = genericArray.getGenericComponentType();\n        // due to a Java 6 bug, it is possible that the JVM classifies e.g. String[] or int[] as GenericArrayType instead of Class\n        if (componentType instanceof Class) {\n            Class<?> componentClass = (Class<?>) componentType;\n            String className;\n            // for int[], double[] etc.\n            if (componentClass.isPrimitive()) {\n                className = encodePrimitiveClass(componentClass);\n            } else // for String[], Integer[] etc.\n            {\n                className = \"L\" + componentClass.getName() + \";\";\n            }\n            Class<OUT> classArray;\n            try {\n                classArray = (Class<OUT>) Class.forName(\"[\" + className);\n            } catch (ClassNotFoundException e) {\n                throw new InvalidTypesException(\"Could not convert GenericArrayType to Class.\");\n            }\n            return getForClass(classArray);\n        }\n        TypeInformation<?> componentInfo = createTypeInfoWithTypeHierarchy(typeHierarchy, genericArray.getGenericComponentType(), in1Type, in2Type);\n        return ObjectArrayTypeInfo.getInfoFor(t, componentInfo);\n    } else // objects with generics are treated as Class first\n    if (t instanceof ParameterizedType) {\n        return (TypeInformation<OUT>) privateGetForClass(typeToClass(t), typeHierarchy, (ParameterizedType) t, in1Type, in2Type);\n    } else // no tuple, no TypeVariable, no generic type\n    if (t instanceof Class) {\n        return privateGetForClass((Class<OUT>) t, typeHierarchy);\n    }\n    throw new InvalidTypesException(\"Type Information could not be created.\");\n}", "code_comment": NaN, "code_no_comment": "@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\nprivate <IN1, IN2, OUT> TypeInformation<OUT> createTypeInfoWithTypeHierarchy(ArrayList<Type> typeHierarchy, Type t, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {\n        if (isClassType(t) && Tuple.class.isAssignableFrom(typeToClass(t))) {\n        Type curT = t;\n                if (typeToClass(t).equals(Tuple.class)) {\n            throw new InvalidTypesException(\"Usage of class Tuple as a type is not allowed. Use a concrete subclass (e.g. Tuple1, Tuple2, etc.) instead.\");\n        }\n                while (!(isClassType(curT) && typeToClass(curT).getSuperclass().equals(Tuple.class))) {\n            typeHierarchy.add(curT);\n            curT = typeToClass(curT).getGenericSuperclass();\n        }\n                if (curT instanceof Class<?>) {\n            throw new InvalidTypesException(\"Tuple needs to be parameterized by using generics.\");\n        }\n        typeHierarchy.add(curT);\n        ParameterizedType tupleChild = (ParameterizedType) curT;\n        Type[] subtypes = new Type[tupleChild.getActualTypeArguments().length];\n                for (int i = 0; i < subtypes.length; i++) {\n                        if (tupleChild.getActualTypeArguments()[i] instanceof TypeVariable<?>) {\n                subtypes[i] = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) tupleChild.getActualTypeArguments()[i]);\n            } else             {\n                subtypes[i] = tupleChild.getActualTypeArguments()[i];\n            }\n        }\n        TypeInformation<?>[] tupleSubTypes = new TypeInformation<?>[subtypes.length];\n        for (int i = 0; i < subtypes.length; i++) {\n                        if (subtypes[i] instanceof TypeVariable<?>) {\n                tupleSubTypes[i] = createTypeInfoFromInputs((TypeVariable<?>) subtypes[i], typeHierarchy, in1Type, in2Type);\n                                if (tupleSubTypes[i] == null) {\n                    throw new InvalidTypesException(\"Type of TypeVariable '\" + ((TypeVariable<?>) subtypes[i]).getName() + \"' in '\" + ((TypeVariable<?>) subtypes[i]).getGenericDeclaration() + \"' could not be determined. This is most likely a type erasure problem. \" + \"The type extraction currently supports types with generic variables only in cases where \" + \"all variables in the return type can be deduced from the input type(s).\");\n                }\n            } else {\n                tupleSubTypes[i] = createTypeInfoWithTypeHierarchy(new ArrayList<Type>(typeHierarchy), subtypes[i], in1Type, in2Type);\n            }\n        }\n        Class<?> tAsClass = null;\n        if (isClassType(t)) {\n            tAsClass = typeToClass(t);\n        }\n        Preconditions.checkNotNull(tAsClass, \"t has a unexpected type\");\n                        int fieldCount = countFieldsInClass(tAsClass);\n        if (fieldCount != tupleSubTypes.length) {\n                        if (t instanceof ParameterizedType) {\n                return (TypeInformation<OUT>) analyzePojo(tAsClass, new ArrayList<Type>(typeHierarchy), (ParameterizedType) t, in1Type, in2Type);\n            } else {\n                return (TypeInformation<OUT>) analyzePojo(tAsClass, new ArrayList<Type>(typeHierarchy), null, in1Type, in2Type);\n            }\n        }\n        return new TupleTypeInfo(tAsClass, tupleSubTypes);\n    } else     if (t instanceof TypeVariable) {\n        Type typeVar = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) t);\n        if (!(typeVar instanceof TypeVariable)) {\n            return createTypeInfoWithTypeHierarchy(typeHierarchy, typeVar, in1Type, in2Type);\n        } else         {\n            TypeInformation<OUT> typeInfo = (TypeInformation<OUT>) createTypeInfoFromInputs((TypeVariable<?>) t, typeHierarchy, in1Type, in2Type);\n            if (typeInfo != null) {\n                return typeInfo;\n            } else {\n                throw new InvalidTypesException(\"Type of TypeVariable '\" + ((TypeVariable<?>) t).getName() + \"' in '\" + ((TypeVariable<?>) t).getGenericDeclaration() + \"' could not be determined. This is most likely a type erasure problem. \" + \"The type extraction currently supports types with generic variables only in cases where \" + \"all variables in the return type can be deduced from the input type(s).\");\n            }\n        }\n    } else     if (t instanceof GenericArrayType) {\n        GenericArrayType genericArray = (GenericArrayType) t;\n        Type componentType = genericArray.getGenericComponentType();\n                if (componentType instanceof Class) {\n            Class<?> componentClass = (Class<?>) componentType;\n            String className;\n                        if (componentClass.isPrimitive()) {\n                className = encodePrimitiveClass(componentClass);\n            } else             {\n                className = \"L\" + componentClass.getName() + \";\";\n            }\n            Class<OUT> classArray;\n            try {\n                classArray = (Class<OUT>) Class.forName(\"[\" + className);\n            } catch (ClassNotFoundException e) {\n                throw new InvalidTypesException(\"Could not convert GenericArrayType to Class.\");\n            }\n            return getForClass(classArray);\n        }\n        TypeInformation<?> componentInfo = createTypeInfoWithTypeHierarchy(typeHierarchy, genericArray.getGenericComponentType(), in1Type, in2Type);\n        return ObjectArrayTypeInfo.getInfoFor(t, componentInfo);\n    } else     if (t instanceof ParameterizedType) {\n        return (TypeInformation<OUT>) privateGetForClass(typeToClass(t), typeHierarchy, (ParameterizedType) t, in1Type, in2Type);\n    } else     if (t instanceof Class) {\n        return privateGetForClass((Class<OUT>) t, typeHierarchy);\n    }\n    throw new InvalidTypesException(\"Type Information could not be created.\");\n}", "lc": 3.727272727272727, "pi": 0.5023923444976076, "ma": 4.8, "nbd": 1.5, "ml": 2.75, "d": 2.630952380952381, "mi": -1.4160676532769552, "fo": 3.25, "r": -0.02631578947368421, "e": 15.126347515891261}
{"project_name": "Csv", "project_version": 7, "label": 1, "code": "/**\n * Initializes the name to index mapping if the format defines a header.\n *\n * @return null if the format has no header.\n */\nprivate Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader != null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n        String[] header = null;\n        if (formatHeader.length == 0) {\n            // read the header from the first line of the file\n            final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord != null) {\n                header = nextRecord.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            header = formatHeader;\n        }\n        // build the name to index mappings\n        if (header != null) {\n            for (int i = 0; i < header.length; i++) {\n                hdrMap.put(header[i], Integer.valueOf(i));\n            }\n        }\n    }\n    return hdrMap;\n}", "code_comment": "/**\n * Initializes the name to index mapping if the format defines a header.\n *\n * @return null if the format has no header.\n */\n", "code_no_comment": "private Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader != null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n        String[] header = null;\n        if (formatHeader.length == 0) {\n                        final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord != null) {\n                header = nextRecord.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            header = formatHeader;\n        }\n                if (header != null) {\n            for (int i = 0; i < header.length; i++) {\n                hdrMap.put(header[i], Integer.valueOf(i));\n            }\n        }\n    }\n    return hdrMap;\n}", "lc": 0.5, "pi": 0.736842105263158, "ma": 0.6, "nbd": 0.5, "ml": 0.6666666666666666, "d": 0.6448412698412699, "mi": -0.38914728682170513, "fo": 0.08333333333333333, "r": -0.02631578947368421, "e": 0.6184148499046235}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1199_813109d7", "label": 3, "code": "public void setTableProperty(ByteBuffer login, String tableName, String property, String value) throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException;", "code_comment": NaN, "code_no_comment": "public void setTableProperty(ByteBuffer login, String tableName, String property, String value) throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException;", "lc": -0.5909090909090909, "pi": -1.4306220095693782, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.3687103594080336, "fo": -0.5, "r": -0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-1103_a6f96306", "label": 1, "code": "/**\n * {@inheritDoc}\n */\npublic Optimum optimize(final LeastSquaresProblem problem) {\n    // pull in relevant data from the problem as locals\n    // Number of observed data.\n    final int nR = problem.getObservationSize();\n    // Number of parameters.\n    final int nC = problem.getParameterSize();\n    final double[] currentPoint = problem.getStart().toArray();\n    // counters\n    final Incrementor iterationCounter = problem.getIterationCounter();\n    final Incrementor evaluationCounter = problem.getEvaluationCounter();\n    // convergence criterion\n    final ConvergenceChecker<Evaluation> checker = problem.getConvergenceChecker();\n    // arrays shared with the other private methods\n    final int solvedCols = FastMath.min(nR, nC);\n    /* Parameters evolution direction associated with lmPar. */\n    double[] lmDir = new double[nC];\n    /* Levenberg-Marquardt parameter. */\n    double lmPar = 0;\n    // local point\n    double delta = 0;\n    double xNorm = 0;\n    double[] diag = new double[nC];\n    double[] oldX = new double[nC];\n    double[] oldRes = new double[nR];\n    double[] qtf = new double[nR];\n    double[] work1 = new double[nC];\n    double[] work2 = new double[nC];\n    double[] work3 = new double[nC];\n    // Evaluate the function at the starting point and calculate its norm.\n    evaluationCounter.incrementCount();\n    // value will be reassigned in the loop\n    Evaluation current = problem.evaluate(new ArrayRealVector(currentPoint, false));\n    double[] currentResiduals = current.getResiduals().toArray();\n    double currentCost = current.getCost();\n    // Outer loop.\n    boolean firstIteration = true;\n    while (true) {\n        iterationCounter.incrementCount();\n        final Evaluation previous = current;\n        // QR decomposition of the jacobian matrix\n        final InternalData internalData = qrDecomposition(current.getJacobian(), solvedCols);\n        final double[][] weightedJacobian = internalData.weightedJacobian;\n        final int[] permutation = internalData.permutation;\n        final double[] diagR = internalData.diagR;\n        final double[] jacNorm = internalData.jacNorm;\n        // residuals already have weights applied\n        double[] weightedResidual = currentResiduals;\n        for (int i = 0; i < nR; i++) {\n            qtf[i] = weightedResidual[i];\n        }\n        // compute Qt.res\n        qTy(qtf, internalData);\n        // so let jacobian contain the R matrix with its diagonal elements\n        for (int k = 0; k < solvedCols; ++k) {\n            int pk = permutation[k];\n            weightedJacobian[k][pk] = diagR[pk];\n        }\n        if (firstIteration) {\n            // scale the point according to the norms of the columns\n            // of the initial jacobian\n            xNorm = 0;\n            for (int k = 0; k < nC; ++k) {\n                double dk = jacNorm[k];\n                if (dk == 0) {\n                    dk = 1.0;\n                }\n                double xk = dk * currentPoint[k];\n                xNorm += xk * xk;\n                diag[k] = dk;\n            }\n            xNorm = FastMath.sqrt(xNorm);\n            // initialize the step bound delta\n            delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n        }\n        // check orthogonality between function vector and jacobian columns\n        double maxCosine = 0;\n        if (currentCost != 0) {\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double s = jacNorm[pj];\n                if (s != 0) {\n                    double sum = 0;\n                    for (int i = 0; i <= j; ++i) {\n                        sum += weightedJacobian[i][pj] * qtf[i];\n                    }\n                    maxCosine = FastMath.max(maxCosine, FastMath.abs(sum) / (s * currentCost));\n                }\n            }\n        }\n        if (maxCosine <= orthoTolerance) {\n            // Convergence has been reached.\n            return new OptimumImpl(current, evaluationCounter.getCount(), iterationCounter.getCount());\n        }\n        // rescale if necessary\n        for (int j = 0; j < nC; ++j) {\n            diag[j] = FastMath.max(diag[j], jacNorm[j]);\n        }\n        // Inner loop.\n        for (double ratio = 0; ratio < 1.0e-4; ) {\n            // save the state\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                oldX[pj] = currentPoint[pj];\n            }\n            final double previousCost = currentCost;\n            double[] tmpVec = weightedResidual;\n            weightedResidual = oldRes;\n            oldRes = tmpVec;\n            // determine the Levenberg-Marquardt parameter\n            lmPar = determineLMParameter(qtf, delta, diag, internalData, solvedCols, work1, work2, work3, lmDir, lmPar);\n            // compute the new point and the norm of the evolution direction\n            double lmNorm = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                lmDir[pj] = -lmDir[pj];\n                currentPoint[pj] = oldX[pj] + lmDir[pj];\n                double s = diag[pj] * lmDir[pj];\n                lmNorm += s * s;\n            }\n            lmNorm = FastMath.sqrt(lmNorm);\n            // on the first iteration, adjust the initial step bound.\n            if (firstIteration) {\n                delta = FastMath.min(delta, lmNorm);\n            }\n            // Evaluate the function at x + p and calculate its norm.\n            evaluationCounter.incrementCount();\n            current = problem.evaluate(new ArrayRealVector(currentPoint, false));\n            currentResiduals = current.getResiduals().toArray();\n            currentCost = current.getCost();\n            // compute the scaled actual reduction\n            double actRed = -1.0;\n            if (0.1 * currentCost < previousCost) {\n                double r = currentCost / previousCost;\n                actRed = 1.0 - r * r;\n            }\n            // and the scaled directional derivative\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double dirJ = lmDir[pj];\n                work1[j] = 0;\n                for (int i = 0; i <= j; ++i) {\n                    work1[i] += weightedJacobian[i][pj] * dirJ;\n                }\n            }\n            double coeff1 = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                coeff1 += work1[j] * work1[j];\n            }\n            double pc2 = previousCost * previousCost;\n            coeff1 /= pc2;\n            double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n            double preRed = coeff1 + 2 * coeff2;\n            double dirDer = -(coeff1 + coeff2);\n            // ratio of the actual to the predicted reduction\n            ratio = (preRed == 0) ? 0 : (actRed / preRed);\n            // update the step bound\n            if (ratio <= 0.25) {\n                double tmp = (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                if ((0.1 * currentCost >= previousCost) || (tmp < 0.1)) {\n                    tmp = 0.1;\n                }\n                delta = tmp * FastMath.min(delta, 10.0 * lmNorm);\n                lmPar /= tmp;\n            } else if ((lmPar == 0) || (ratio >= 0.75)) {\n                delta = 2 * lmNorm;\n                lmPar *= 0.5;\n            }\n            // test for successful iteration.\n            if (ratio >= 1.0e-4) {\n                // successful iteration, update the norm\n                firstIteration = false;\n                xNorm = 0;\n                for (int k = 0; k < nC; ++k) {\n                    double xK = diag[k] * currentPoint[k];\n                    xNorm += xK * xK;\n                }\n                xNorm = FastMath.sqrt(xNorm);\n                // tests for convergence.\n                if (checker != null && checker.converged(iterationCounter.getCount(), previous, current)) {\n                    return new OptimumImpl(current, iterationCounter.getCount(), evaluationCounter.getCount());\n                }\n            } else {\n                // failed iteration, reset the previous values\n                currentCost = previousCost;\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    currentPoint[pj] = oldX[pj];\n                }\n                tmpVec = weightedResidual;\n                weightedResidual = oldRes;\n                oldRes = tmpVec;\n                // Reset \"current\" to previous values.\n                current = previous;\n            }\n            // Default convergence criteria.\n            if ((FastMath.abs(actRed) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0) || delta <= parRelativeTolerance * xNorm) {\n                return new OptimumImpl(current, iterationCounter.getCount(), evaluationCounter.getCount());\n            }\n            // tests for termination and stringent tolerances\n            if (FastMath.abs(actRed) <= TWO_EPS && preRed <= TWO_EPS && ratio <= 2.0) {\n                throw new ConvergenceException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance);\n            } else if (delta <= TWO_EPS * xNorm) {\n                throw new ConvergenceException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance);\n            } else if (maxCosine <= TWO_EPS) {\n                throw new ConvergenceException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance);\n            }\n        }\n    }\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "public Optimum optimize(final LeastSquaresProblem problem) {\n            final int nR = problem.getObservationSize();\n        final int nC = problem.getParameterSize();\n    final double[] currentPoint = problem.getStart().toArray();\n        final Incrementor iterationCounter = problem.getIterationCounter();\n    final Incrementor evaluationCounter = problem.getEvaluationCounter();\n        final ConvergenceChecker<Evaluation> checker = problem.getConvergenceChecker();\n        final int solvedCols = FastMath.min(nR, nC);\n        double[] lmDir = new double[nC];\n        double lmPar = 0;\n        double delta = 0;\n    double xNorm = 0;\n    double[] diag = new double[nC];\n    double[] oldX = new double[nC];\n    double[] oldRes = new double[nR];\n    double[] qtf = new double[nR];\n    double[] work1 = new double[nC];\n    double[] work2 = new double[nC];\n    double[] work3 = new double[nC];\n        evaluationCounter.incrementCount();\n        Evaluation current = problem.evaluate(new ArrayRealVector(currentPoint, false));\n    double[] currentResiduals = current.getResiduals().toArray();\n    double currentCost = current.getCost();\n        boolean firstIteration = true;\n    while (true) {\n        iterationCounter.incrementCount();\n        final Evaluation previous = current;\n                final InternalData internalData = qrDecomposition(current.getJacobian(), solvedCols);\n        final double[][] weightedJacobian = internalData.weightedJacobian;\n        final int[] permutation = internalData.permutation;\n        final double[] diagR = internalData.diagR;\n        final double[] jacNorm = internalData.jacNorm;\n                double[] weightedResidual = currentResiduals;\n        for (int i = 0; i < nR; i++) {\n            qtf[i] = weightedResidual[i];\n        }\n                qTy(qtf, internalData);\n                for (int k = 0; k < solvedCols; ++k) {\n            int pk = permutation[k];\n            weightedJacobian[k][pk] = diagR[pk];\n        }\n        if (firstIteration) {\n                                    xNorm = 0;\n            for (int k = 0; k < nC; ++k) {\n                double dk = jacNorm[k];\n                if (dk == 0) {\n                    dk = 1.0;\n                }\n                double xk = dk * currentPoint[k];\n                xNorm += xk * xk;\n                diag[k] = dk;\n            }\n            xNorm = FastMath.sqrt(xNorm);\n                        delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n        }\n                double maxCosine = 0;\n        if (currentCost != 0) {\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double s = jacNorm[pj];\n                if (s != 0) {\n                    double sum = 0;\n                    for (int i = 0; i <= j; ++i) {\n                        sum += weightedJacobian[i][pj] * qtf[i];\n                    }\n                    maxCosine = FastMath.max(maxCosine, FastMath.abs(sum) / (s * currentCost));\n                }\n            }\n        }\n        if (maxCosine <= orthoTolerance) {\n                        return new OptimumImpl(current, evaluationCounter.getCount(), iterationCounter.getCount());\n        }\n                for (int j = 0; j < nC; ++j) {\n            diag[j] = FastMath.max(diag[j], jacNorm[j]);\n        }\n                for (double ratio = 0; ratio < 1.0e-4; ) {\n                        for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                oldX[pj] = currentPoint[pj];\n            }\n            final double previousCost = currentCost;\n            double[] tmpVec = weightedResidual;\n            weightedResidual = oldRes;\n            oldRes = tmpVec;\n                        lmPar = determineLMParameter(qtf, delta, diag, internalData, solvedCols, work1, work2, work3, lmDir, lmPar);\n                        double lmNorm = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                lmDir[pj] = -lmDir[pj];\n                currentPoint[pj] = oldX[pj] + lmDir[pj];\n                double s = diag[pj] * lmDir[pj];\n                lmNorm += s * s;\n            }\n            lmNorm = FastMath.sqrt(lmNorm);\n                        if (firstIteration) {\n                delta = FastMath.min(delta, lmNorm);\n            }\n                        evaluationCounter.incrementCount();\n            current = problem.evaluate(new ArrayRealVector(currentPoint, false));\n            currentResiduals = current.getResiduals().toArray();\n            currentCost = current.getCost();\n                        double actRed = -1.0;\n            if (0.1 * currentCost < previousCost) {\n                double r = currentCost / previousCost;\n                actRed = 1.0 - r * r;\n            }\n                        for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double dirJ = lmDir[pj];\n                work1[j] = 0;\n                for (int i = 0; i <= j; ++i) {\n                    work1[i] += weightedJacobian[i][pj] * dirJ;\n                }\n            }\n            double coeff1 = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                coeff1 += work1[j] * work1[j];\n            }\n            double pc2 = previousCost * previousCost;\n            coeff1 /= pc2;\n            double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n            double preRed = coeff1 + 2 * coeff2;\n            double dirDer = -(coeff1 + coeff2);\n                        ratio = (preRed == 0) ? 0 : (actRed / preRed);\n                        if (ratio <= 0.25) {\n                double tmp = (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                if ((0.1 * currentCost >= previousCost) || (tmp < 0.1)) {\n                    tmp = 0.1;\n                }\n                delta = tmp * FastMath.min(delta, 10.0 * lmNorm);\n                lmPar /= tmp;\n            } else if ((lmPar == 0) || (ratio >= 0.75)) {\n                delta = 2 * lmNorm;\n                lmPar *= 0.5;\n            }\n                        if (ratio >= 1.0e-4) {\n                                firstIteration = false;\n                xNorm = 0;\n                for (int k = 0; k < nC; ++k) {\n                    double xK = diag[k] * currentPoint[k];\n                    xNorm += xK * xK;\n                }\n                xNorm = FastMath.sqrt(xNorm);\n                                if (checker != null && checker.converged(iterationCounter.getCount(), previous, current)) {\n                    return new OptimumImpl(current, iterationCounter.getCount(), evaluationCounter.getCount());\n                }\n            } else {\n                                currentCost = previousCost;\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    currentPoint[pj] = oldX[pj];\n                }\n                tmpVec = weightedResidual;\n                weightedResidual = oldRes;\n                oldRes = tmpVec;\n                                current = previous;\n            }\n                        if ((FastMath.abs(actRed) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0) || delta <= parRelativeTolerance * xNorm) {\n                return new OptimumImpl(current, iterationCounter.getCount(), evaluationCounter.getCount());\n            }\n                        if (FastMath.abs(actRed) <= TWO_EPS && preRed <= TWO_EPS && ratio <= 2.0) {\n                throw new ConvergenceException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance);\n            } else if (delta <= TWO_EPS * xNorm) {\n                throw new ConvergenceException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance);\n            } else if (maxCosine <= TWO_EPS) {\n                throw new ConvergenceException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance);\n            }\n        }\n    }\n}", "lc": 7.090909090909091, "pi": 0.8899521531100476, "ma": 6.8, "nbd": 1.5, "ml": 5.416666666666667, "d": 7.162698412698411, "mi": -1.8639887244538402, "fo": 2.9166666666666665, "r": -0.02631578947368421, "e": 88.18485388104168}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-93_0be7e8f0", "label": 1, "code": "@Override\npublic TreeImpl getChild(String name) {\n    NodeStateBuilder childBuilder = builder.getChildBuilder(name);\n    if (childBuilder == null) {\n        return null;\n    } else {\n        NodeState childBaseState = baseState == null ? null : baseState.getChildNode(name);\n        return new TreeImpl(store, childBaseState, childBuilder, this, name, listener);\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic TreeImpl getChild(String name) {\n    NodeStateBuilder childBuilder = builder.getChildBuilder(name);\n    if (childBuilder == null) {\n        return null;\n    } else {\n        NodeState childBaseState = baseState == null ? null : baseState.getChildNode(name);\n        return new TreeImpl(store, childBaseState, childBuilder, this, name, listener);\n    }\n}", "lc": -0.18181818181818182, "pi": 0.05263157894736836, "ma": -0.2, "nbd": -0.5, "ml": -0.08333333333333333, "d": -0.03769841269841273, "mi": 0.18646934460887932, "fo": -0.3333333333333333, "r": 0.05263157894736841, "e": -0.0595725062383661}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1199_813109d7", "label": 3, "code": "public int compareTo(removeTableProperty_result other) {\n    if (!getClass().equals(other.getClass())) {\n        return getClass().getName().compareTo(other.getClass().getName());\n    }\n    int lastComparison = 0;\n    removeTableProperty_result typedOther = (removeTableProperty_result) other;\n    lastComparison = Boolean.valueOf(isSetOuch1()).compareTo(typedOther.isSetOuch1());\n    if (lastComparison != 0) {\n        return lastComparison;\n    }\n    if (isSetOuch1()) {\n        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.ouch1, typedOther.ouch1);\n        if (lastComparison != 0) {\n            return lastComparison;\n        }\n    }\n    lastComparison = Boolean.valueOf(isSetOuch2()).compareTo(typedOther.isSetOuch2());\n    if (lastComparison != 0) {\n        return lastComparison;\n    }\n    if (isSetOuch2()) {\n        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.ouch2, typedOther.ouch2);\n        if (lastComparison != 0) {\n            return lastComparison;\n        }\n    }\n    return 0;\n}", "code_comment": NaN, "code_no_comment": "public int compareTo(removeTableProperty_result other) {\n    if (!getClass().equals(other.getClass())) {\n        return getClass().getName().compareTo(other.getClass().getName());\n    }\n    int lastComparison = 0;\n    removeTableProperty_result typedOther = (removeTableProperty_result) other;\n    lastComparison = Boolean.valueOf(isSetOuch1()).compareTo(typedOther.isSetOuch1());\n    if (lastComparison != 0) {\n        return lastComparison;\n    }\n    if (isSetOuch1()) {\n        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.ouch1, typedOther.ouch1);\n        if (lastComparison != 0) {\n            return lastComparison;\n        }\n    }\n    lastComparison = Boolean.valueOf(isSetOuch2()).compareTo(typedOther.isSetOuch2());\n    if (lastComparison != 0) {\n        return lastComparison;\n    }\n    if (isSetOuch2()) {\n        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.ouch2, typedOther.ouch2);\n        if (lastComparison != 0) {\n            return lastComparison;\n        }\n    }\n    return 0;\n}", "lc": 0.6363636363636364, "pi": -0.04306220095693795, "ma": 0.8, "nbd": 0.0, "ml": 0.5833333333333334, "d": 0.2996031746031746, "mi": -0.4556730091613809, "fo": 1.1666666666666667, "r": -0.02631578947368421, "e": 0.3821533744806163}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-2057_e2d88568", "label": 1, "code": "/**\n *  @see org.apache.wicket.ajax.IAjaxCallDecorator#decorateOnSuccessScript(CharSequence)\n */\npublic CharSequence decorateOnSuccessScript(CharSequence script) {\n    CharSequence s = (delegate == null) ? script : delegate.decorateOnSuccessScript(script);\n    return preDecorateOnSuccessScript(s);\n}", "code_comment": "/**\n *  @see org.apache.wicket.ajax.IAjaxCallDecorator#decorateOnSuccessScript(CharSequence)\n */\n", "code_no_comment": "public CharSequence decorateOnSuccessScript(CharSequence script) {\n    CharSequence s = (delegate == null) ? script : delegate.decorateOnSuccessScript(script);\n    return preDecorateOnSuccessScript(s);\n}", "lc": -0.45454545454545453, "pi": -0.47368421052631593, "ma": -0.4, "nbd": -1.0, "ml": -0.25, "d": 0.0079365079365079, "mi": 0.7403805496828751, "fo": -0.3333333333333333, "r": 2.4210526315789473, "e": -0.11397451634653619}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-5681_78c73502", "label": 1, "code": "public Exchange call() throws Exception {\n    // the aggregation task to early and pile up too many threads\n    if (aggregationTaskSubmitted.compareAndSet(false, true)) {\n        // but only submit the task once\n        aggregateExecutorService.submit(aggregateOnTheFlyTask);\n    }\n    if (!running.get()) {\n        // do not start processing the task if we are not running\n        return subExchange;\n    }\n    try {\n        doProcessParallel(pair);\n    } catch (Throwable e) {\n        subExchange.setException(e);\n    }\n    // Decide whether to continue with the multicast or not; similar logic to the Pipeline\n    Integer number = getExchangeIndex(subExchange);\n    boolean continueProcessing = PipelineHelper.continueProcessing(subExchange, \"Parallel processing failed for number \" + number, LOG);\n    if (stopOnException && !continueProcessing) {\n        // signal to stop running\n        running.set(false);\n        // throw caused exception\n        if (subExchange.getException() != null) {\n            // wrap in exception to explain where it failed\n            throw new CamelExchangeException(\"Parallel processing failed for number \" + number, subExchange, subExchange.getException());\n        }\n    }\n    LOG.trace(\"Parallel processing complete for exchange: {}\", subExchange);\n    return subExchange;\n}", "code_comment": NaN, "code_no_comment": "public Exchange call() throws Exception {\n        if (aggregationTaskSubmitted.compareAndSet(false, true)) {\n                aggregateExecutorService.submit(aggregateOnTheFlyTask);\n    }\n    if (!running.get()) {\n                return subExchange;\n    }\n    try {\n        doProcessParallel(pair);\n    } catch (Throwable e) {\n        subExchange.setException(e);\n    }\n        Integer number = getExchangeIndex(subExchange);\n    boolean continueProcessing = PipelineHelper.continueProcessing(subExchange, \"Parallel processing failed for number \" + number, LOG);\n    if (stopOnException && !continueProcessing) {\n                running.set(false);\n                if (subExchange.getException() != null) {\n                        throw new CamelExchangeException(\"Parallel processing failed for number \" + number, subExchange, subExchange.getException());\n        }\n    }\n    LOG.trace(\"Parallel processing complete for exchange: {}\", subExchange);\n    return subExchange;\n}", "lc": 0.4090909090909091, "pi": -0.11483253588516758, "ma": 0.6, "nbd": 0.0, "ml": 0.4166666666666667, "d": 0.24801587301587297, "mi": -0.3403805496828753, "fo": 0.4166666666666667, "r": -0.02631578947368421, "e": 0.27842994876759847}
{"project_name": "Math", "project_version": 91, "label": 1, "code": "/**\n * Compares this object to another based on size.\n * @param object the object to compare to\n * @return -1 if this is less than <tt>object</tt>, +1 if this is greater\n *         than <tt>object</tt>, 0 if they are equal.\n */\npublic int compareTo(Fraction object) {\n    double nOd = doubleValue();\n    double dOn = object.doubleValue();\n    return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n}", "code_comment": "/**\n * Compares this object to another based on size.\n * @param object the object to compare to\n * @return -1 if this is less than <tt>object</tt>, +1 if this is greater\n *         than <tt>object</tt>, 0 if they are equal.\n */\n", "code_no_comment": "public int compareTo(Fraction object) {\n    double nOd = doubleValue();\n    double dOn = object.doubleValue();\n    return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n}", "lc": -0.4090909090909091, "pi": -0.49282296650717716, "ma": -0.2, "nbd": -1.0, "ml": -0.08333333333333333, "d": 0.3412698412698413, "mi": 0.5740662438336854, "fo": -0.3333333333333333, "r": 0.868421052631579, "e": -0.025488263803645633}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-428_4a6a573b", "label": 3, "code": "public boolean hasNext() {\n    return i < size;\n}", "code_comment": NaN, "code_no_comment": "public boolean hasNext() {\n    return i < size;\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.1099365750528538, "fo": -0.5, "r": 2.4473684210526314, "e": -0.16279340490885932}
{"project_name": "Closure", "project_version": 163, "label": 1, "code": "/**\n * Processes a NAME node to see if it's a global function declaration.\n * If it is, record it and return true. Otherwise, return false.\n */\nprivate boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) {\n    Node firstChild = nameNode.getFirstChild();\n    if (// Check for a named FUNCTION.\n    isGlobalFunctionDeclaration(t, parent) || // Check for a VAR declaration.\n    firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) {\n        String name = nameNode.getString();\n        getNameInfoForName(name, VAR).getDeclarations().add(new GlobalFunction(nameNode, parent, gramps, t.getModule()));\n        // so that it's never removed.\n        if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) {\n            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n        }\n        return true;\n    }\n    return false;\n}", "code_comment": "/**\n * Processes a NAME node to see if it's a global function declaration.\n * If it is, record it and return true. Otherwise, return false.\n */\n", "code_no_comment": "private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) {\n    Node firstChild = nameNode.getFirstChild();\n    if (    isGlobalFunctionDeclaration(t, parent) ||     firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) {\n        String name = nameNode.getString();\n        getNameInfoForName(name, VAR).getDeclarations().add(new GlobalFunction(nameNode, parent, gramps, t.getModule()));\n                if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) {\n            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n        }\n        return true;\n    }\n    return false;\n}", "lc": 0.0, "pi": 0.12440191387559799, "ma": -0.2, "nbd": 0.0, "ml": 0.6666666666666666, "d": 0.32936507936507936, "mi": -0.07033121916842858, "fo": 0.5, "r": -0.02631578947368421, "e": 0.28095180465990094}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-7344_91228815", "label": 1, "code": "@Override\npublic String toString() {\n    return String.format(\"Endpoint[%s]\", URISupport.sanitizeUri(getEndpointUri()));\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic String toString() {\n    return String.format(\"Endpoint[%s]\", URISupport.sanitizeUri(getEndpointUri()));\n}", "lc": -0.45454545454545453, "pi": -0.6028708133971293, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.8314305849189569, "fo": -0.25, "r": 0.21052631578947367, "e": -0.16279340490885932}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-217_46f62443", "label": 1, "code": "@Override\npublic Collection<Text> getSplits(String tableName, int maxSplits) {\n    return Collections.emptyList();\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic Collection<Text> getSplits(String tableName, int maxSplits) {\n    return Collections.emptyList();\n}", "lc": -0.45454545454545453, "pi": -0.6028708133971293, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.8246652572233965, "fo": -0.4166666666666667, "r": 0.763157894736842, "e": -0.16279340490885932}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-2624_ef880545", "label": 1, "code": "/**\n *  @param object\n *  @param value\n *  @param converter\n */\npublic final void setValue(final Object object, final Object value, PropertyResolverConverter converter) {\n    Class type = null;\n    if (setMethod != null) {\n        type = getMethod.getReturnType();\n    } else if (field != null) {\n        type = field.getType();\n    }\n    Object converted = null;\n    if (type != null) {\n        converted = converter.convert(value, getMethod.getReturnType());\n        if (converted == null) {\n            if (value != null) {\n                throw new ConversionException(\"Can't convert value: \" + value + \" to class: \" + getMethod.getReturnType() + \" for setting it on \" + object);\n            } else if (getMethod.getReturnType().isPrimitive()) {\n                throw new ConversionException(\"Can't convert null value to a primitive class: \" + getMethod.getReturnType() + \" for setting it on \" + object);\n            }\n        }\n    }\n    if (setMethod != null) {\n        try {\n            setMethod.invoke(object, new Object[] { converted });\n        } catch (InvocationTargetException ex) {\n            throw new WicketRuntimeException(\"Error calling method: \" + setMethod + \" on object: \" + object, ex.getCause());\n        } catch (Exception ex) {\n            throw new WicketRuntimeException(\"Error calling method: \" + setMethod + \" on object: \" + object, ex);\n        }\n    } else if (field != null) {\n        try {\n            field.set(object, converted);\n        } catch (Exception ex) {\n            throw new WicketRuntimeException(\"Error setting field: \" + field + \" on object: \" + object, ex);\n        }\n    } else {\n        throw new WicketRuntimeException(\"no set method defined for value: \" + value + \" on object: \" + object + \" while respective getMethod being \" + getMethod.getName());\n    }\n}", "code_comment": "/**\n *  @param object\n *  @param value\n *  @param converter\n */\n", "code_no_comment": "public final void setValue(final Object object, final Object value, PropertyResolverConverter converter) {\n    Class type = null;\n    if (setMethod != null) {\n        type = getMethod.getReturnType();\n    } else if (field != null) {\n        type = field.getType();\n    }\n    Object converted = null;\n    if (type != null) {\n        converted = converter.convert(value, getMethod.getReturnType());\n        if (converted == null) {\n            if (value != null) {\n                throw new ConversionException(\"Can't convert value: \" + value + \" to class: \" + getMethod.getReturnType() + \" for setting it on \" + object);\n            } else if (getMethod.getReturnType().isPrimitive()) {\n                throw new ConversionException(\"Can't convert null value to a primitive class: \" + getMethod.getReturnType() + \" for setting it on \" + object);\n            }\n        }\n    }\n    if (setMethod != null) {\n        try {\n            setMethod.invoke(object, new Object[] { converted });\n        } catch (InvocationTargetException ex) {\n            throw new WicketRuntimeException(\"Error calling method: \" + setMethod + \" on object: \" + object, ex.getCause());\n        } catch (Exception ex) {\n            throw new WicketRuntimeException(\"Error calling method: \" + setMethod + \" on object: \" + object, ex);\n        }\n    } else if (field != null) {\n        try {\n            field.set(object, converted);\n        } catch (Exception ex) {\n            throw new WicketRuntimeException(\"Error setting field: \" + field + \" on object: \" + object, ex);\n        }\n    } else {\n        throw new WicketRuntimeException(\"no set method defined for value: \" + value + \" on object: \" + object + \" while respective getMethod being \" + getMethod.getName());\n    }\n}", "lc": 1.0, "pi": 0.44976076555023925, "ma": 2.8, "nbd": 1.0, "ml": 0.75, "d": 0.7261904761904762, "mi": -0.718675123326286, "fo": 0.5, "r": -0.02631578947368421, "e": 1.416091238625427}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-848_ad252a8c", "label": 1, "code": "/**\n * Transform original matrix to Schur form.\n * @throws MaxCountExceededException if the transformation does not converge\n */\nprivate void transform() {\n    final int n = matrixT.length;\n    // compute matrix norm\n    final double norm = getNorm();\n    // shift information\n    final ShiftInfo shift = new ShiftInfo();\n    // Outer loop over eigenvalue index\n    int iteration = 0;\n    int idx = n - 1;\n    while (idx >= 0) {\n        // Look for single small sub-diagonal element\n        final int l = findSmallSubDiagonalElement(idx, norm);\n        // Check for convergence\n        if (l == idx) {\n            // One root found\n            matrixT[idx][idx] = matrixT[idx][idx] + shift.exShift;\n            idx--;\n            iteration = 0;\n        } else if (l == idx - 1) {\n            // Two roots found\n            shift.w = matrixT[idx][idx - 1] * matrixT[idx - 1][idx];\n            double p = (matrixT[idx - 1][idx - 1] - matrixT[idx][idx]) / 2.0;\n            double q = p * p + shift.w;\n            double z = FastMath.sqrt(FastMath.abs(q));\n            matrixT[idx][idx] = matrixT[idx][idx] + shift.exShift;\n            matrixT[idx - 1][idx - 1] = matrixT[idx - 1][idx - 1] + shift.exShift;\n            shift.x = matrixT[idx][idx];\n            if (q >= 0) {\n                if (p >= 0) {\n                    z = p + z;\n                } else {\n                    z = p - z;\n                }\n                shift.x = matrixT[idx][idx - 1];\n                double s = FastMath.abs(shift.x) + FastMath.abs(z);\n                p = shift.x / s;\n                q = z / s;\n                double r = FastMath.sqrt(p * p + q * q);\n                p = p / r;\n                q = q / r;\n                // Row modification\n                for (int j = idx - 1; j < n; j++) {\n                    z = matrixT[idx - 1][j];\n                    matrixT[idx - 1][j] = q * z + p * matrixT[idx][j];\n                    matrixT[idx][j] = q * matrixT[idx][j] - p * z;\n                }\n                // Column modification\n                for (int i = 0; i <= idx; i++) {\n                    z = matrixT[i][idx - 1];\n                    matrixT[i][idx - 1] = q * z + p * matrixT[i][idx];\n                    matrixT[i][idx] = q * matrixT[i][idx] - p * z;\n                }\n                // Accumulate transformations\n                for (int i = 0; i <= n - 1; i++) {\n                    z = matrixP[i][idx - 1];\n                    matrixP[i][idx - 1] = q * z + p * matrixP[i][idx];\n                    matrixP[i][idx] = q * matrixP[i][idx] - p * z;\n                }\n            }\n            idx -= 2;\n            iteration = 0;\n        } else {\n            // No convergence yet\n            computeShift(l, idx, iteration, shift);\n            // stop transformation after too many iterations\n            if (++iteration > MAX_ITERATIONS) {\n                throw new MaxCountExceededException(LocalizedFormats.CONVERGENCE_FAILED, MAX_ITERATIONS);\n            }\n            // Look for two consecutive small sub-diagonal elements\n            int m = idx - 2;\n            // the initial houseHolder vector for the QR step\n            final double[] hVec = new double[3];\n            while (m >= l) {\n                double z = matrixT[m][m];\n                hVec[2] = shift.x - z;\n                double s = shift.y - z;\n                hVec[0] = (hVec[2] * s - shift.w) / matrixT[m + 1][m] + matrixT[m][m + 1];\n                hVec[1] = matrixT[m + 1][m + 1] - z - hVec[2] - s;\n                hVec[2] = matrixT[m + 2][m + 1];\n                s = FastMath.abs(hVec[0]) + FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]);\n                if (m == l) {\n                    break;\n                }\n                for (int i = 0; i < hVec.length; i++) {\n                    hVec[i] /= s;\n                }\n                final double lhs = FastMath.abs(matrixT[m][m - 1]) * (FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]));\n                final double rhs = FastMath.abs(hVec[0]) * (FastMath.abs(matrixT[m - 1][m - 1]) + FastMath.abs(z) + FastMath.abs(matrixT[m + 1][m + 1]));\n                if (lhs < epsilon * rhs) {\n                    break;\n                }\n                m--;\n            }\n            performDoubleQRStep(l, m, idx, shift, hVec);\n        }\n    }\n}", "code_comment": "/**\n * Transform original matrix to Schur form.\n * @throws MaxCountExceededException if the transformation does not converge\n */\n", "code_no_comment": "private void transform() {\n    final int n = matrixT.length;\n        final double norm = getNorm();\n        final ShiftInfo shift = new ShiftInfo();\n        int iteration = 0;\n    int idx = n - 1;\n    while (idx >= 0) {\n                final int l = findSmallSubDiagonalElement(idx, norm);\n                if (l == idx) {\n                        matrixT[idx][idx] = matrixT[idx][idx] + shift.exShift;\n            idx--;\n            iteration = 0;\n        } else if (l == idx - 1) {\n                        shift.w = matrixT[idx][idx - 1] * matrixT[idx - 1][idx];\n            double p = (matrixT[idx - 1][idx - 1] - matrixT[idx][idx]) / 2.0;\n            double q = p * p + shift.w;\n            double z = FastMath.sqrt(FastMath.abs(q));\n            matrixT[idx][idx] = matrixT[idx][idx] + shift.exShift;\n            matrixT[idx - 1][idx - 1] = matrixT[idx - 1][idx - 1] + shift.exShift;\n            shift.x = matrixT[idx][idx];\n            if (q >= 0) {\n                if (p >= 0) {\n                    z = p + z;\n                } else {\n                    z = p - z;\n                }\n                shift.x = matrixT[idx][idx - 1];\n                double s = FastMath.abs(shift.x) + FastMath.abs(z);\n                p = shift.x / s;\n                q = z / s;\n                double r = FastMath.sqrt(p * p + q * q);\n                p = p / r;\n                q = q / r;\n                                for (int j = idx - 1; j < n; j++) {\n                    z = matrixT[idx - 1][j];\n                    matrixT[idx - 1][j] = q * z + p * matrixT[idx][j];\n                    matrixT[idx][j] = q * matrixT[idx][j] - p * z;\n                }\n                                for (int i = 0; i <= idx; i++) {\n                    z = matrixT[i][idx - 1];\n                    matrixT[i][idx - 1] = q * z + p * matrixT[i][idx];\n                    matrixT[i][idx] = q * matrixT[i][idx] - p * z;\n                }\n                                for (int i = 0; i <= n - 1; i++) {\n                    z = matrixP[i][idx - 1];\n                    matrixP[i][idx - 1] = q * z + p * matrixP[i][idx];\n                    matrixP[i][idx] = q * matrixP[i][idx] - p * z;\n                }\n            }\n            idx -= 2;\n            iteration = 0;\n        } else {\n                        computeShift(l, idx, iteration, shift);\n                        if (++iteration > MAX_ITERATIONS) {\n                throw new MaxCountExceededException(LocalizedFormats.CONVERGENCE_FAILED, MAX_ITERATIONS);\n            }\n                        int m = idx - 2;\n                        final double[] hVec = new double[3];\n            while (m >= l) {\n                double z = matrixT[m][m];\n                hVec[2] = shift.x - z;\n                double s = shift.y - z;\n                hVec[0] = (hVec[2] * s - shift.w) / matrixT[m + 1][m] + matrixT[m][m + 1];\n                hVec[1] = matrixT[m + 1][m + 1] - z - hVec[2] - s;\n                hVec[2] = matrixT[m + 2][m + 1];\n                s = FastMath.abs(hVec[0]) + FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]);\n                if (m == l) {\n                    break;\n                }\n                for (int i = 0; i < hVec.length; i++) {\n                    hVec[i] /= s;\n                }\n                final double lhs = FastMath.abs(matrixT[m][m - 1]) * (FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]));\n                final double rhs = FastMath.abs(hVec[0]) * (FastMath.abs(matrixT[m - 1][m - 1]) + FastMath.abs(z) + FastMath.abs(matrixT[m + 1][m + 1]));\n                if (lhs < epsilon * rhs) {\n                    break;\n                }\n                m--;\n            }\n            performDoubleQRStep(l, m, idx, shift, hVec);\n        }\n    }\n}", "lc": 3.1363636363636362, "pi": 0.9138755980861245, "ma": 2.6, "nbd": 1.5, "ml": 1.75, "d": 11.156746031746032, "mi": -1.3252995066948552, "fo": 1.0833333333333333, "r": -0.02631578947368421, "e": 80.75962033851418}
{"project_name": "Math", "project_version": 77, "label": 1, "code": "/**\n * {@inheritDoc}\n */\n@Override\npublic double getLInfNorm() {\n    double max = 0;\n    for (double a : data) {\n        max += Math.max(max, Math.abs(a));\n    }\n    return max;\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "@Override\npublic double getLInfNorm() {\n    double max = 0;\n    for (double a : data) {\n        max += Math.max(max, Math.abs(a));\n    }\n    return max;\n}", "lc": -0.2727272727272727, "pi": -0.16267942583732073, "ma": -0.4, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.03373015873015876, "mi": 0.4178999295278365, "fo": -0.3333333333333333, "r": 2.1842105263157894, "e": -0.11760285380036076}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-904_6844aba9", "label": 1, "code": "/**\n * Power function.  Compute x^y.\n *\n * @param x   a double\n * @param y   a double\n * @return double\n */\npublic static double pow(double x, double y) {\n    final double[] lns = new double[2];\n    if (y == 0.0) {\n        return 1.0;\n    }\n    if (x != x) {\n        // X is NaN\n        return x;\n    }\n    if (x == 0) {\n        long bits = Double.doubleToLongBits(x);\n        if ((bits & 0x8000000000000000L) != 0) {\n            // -zero\n            long yi = (long) y;\n            if (y < 0 && y == yi && (yi & 1) == 1) {\n                return Double.NEGATIVE_INFINITY;\n            }\n            if (y > 0 && y == yi && (yi & 1) == 1) {\n                return -0.0;\n            }\n        }\n        if (y < 0) {\n            return Double.POSITIVE_INFINITY;\n        }\n        if (y > 0) {\n            return 0.0;\n        }\n        return Double.NaN;\n    }\n    if (x == Double.POSITIVE_INFINITY) {\n        if (y != y) {\n            // y is NaN\n            return y;\n        }\n        if (y < 0.0) {\n            return 0.0;\n        } else {\n            return Double.POSITIVE_INFINITY;\n        }\n    }\n    if (y == Double.POSITIVE_INFINITY) {\n        if (x * x == 1.0) {\n            return Double.NaN;\n        }\n        if (x * x > 1.0) {\n            return Double.POSITIVE_INFINITY;\n        } else {\n            return 0.0;\n        }\n    }\n    if (x == Double.NEGATIVE_INFINITY) {\n        if (y != y) {\n            // y is NaN\n            return y;\n        }\n        if (y < 0) {\n            long yi = (long) y;\n            if (y == yi && (yi & 1) == 1) {\n                return -0.0;\n            }\n            return 0.0;\n        }\n        if (y > 0) {\n            long yi = (long) y;\n            if (y == yi && (yi & 1) == 1) {\n                return Double.NEGATIVE_INFINITY;\n            }\n            return Double.POSITIVE_INFINITY;\n        }\n    }\n    if (y == Double.NEGATIVE_INFINITY) {\n        if (x * x == 1.0) {\n            return Double.NaN;\n        }\n        if (x * x < 1.0) {\n            return Double.POSITIVE_INFINITY;\n        } else {\n            return 0.0;\n        }\n    }\n    /* Handle special case x<0 */\n    if (x < 0) {\n        // y is an even integer in this case\n        if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {\n            return pow(-x, y);\n        }\n        if (y == (long) y) {\n            // If y is an integer\n            return ((long) y & 1) == 0 ? pow(-x, y) : -pow(-x, y);\n        } else {\n            return Double.NaN;\n        }\n    }\n    /* Split y into ya and yb such that y = ya+yb */\n    double ya;\n    double yb;\n    if (y < 8e298 && y > -8e298) {\n        double tmp1 = y * HEX_40000000;\n        ya = y + tmp1 - tmp1;\n        yb = y - ya;\n    } else {\n        double tmp1 = y * 9.31322574615478515625E-10;\n        double tmp2 = tmp1 * 9.31322574615478515625E-10;\n        ya = (tmp1 + tmp2 - tmp1) * HEX_40000000 * HEX_40000000;\n        yb = y - ya;\n    }\n    /* Compute ln(x) */\n    final double lores = log(x, lns);\n    if (Double.isInfinite(lores)) {\n        // don't allow this to be converted to NaN\n        return lores;\n    }\n    double lna = lns[0];\n    double lnb = lns[1];\n    /* resplit lns */\n    double tmp1 = lna * HEX_40000000;\n    double tmp2 = lna + tmp1 - tmp1;\n    lnb += lna - tmp2;\n    lna = tmp2;\n    // y*ln(x) = (aa+ab)\n    final double aa = lna * ya;\n    final double ab = lna * yb + lnb * ya + lnb * yb;\n    lna = aa + ab;\n    lnb = -(lna - aa - ab);\n    double z = 1.0 / 120.0;\n    z = z * lnb + (1.0 / 24.0);\n    z = z * lnb + (1.0 / 6.0);\n    z = z * lnb + 0.5;\n    z = z * lnb + 1.0;\n    z = z * lnb;\n    final double result = exp(lna, z, null);\n    // result = result + result * z;\n    return result;\n}", "code_comment": "/**\n * Power function.  Compute x^y.\n *\n * @param x   a double\n * @param y   a double\n * @return double\n */\n", "code_no_comment": "public static double pow(double x, double y) {\n    final double[] lns = new double[2];\n    if (y == 0.0) {\n        return 1.0;\n    }\n    if (x != x) {\n                return x;\n    }\n    if (x == 0) {\n        long bits = Double.doubleToLongBits(x);\n        if ((bits & 0x8000000000000000L) != 0) {\n                        long yi = (long) y;\n            if (y < 0 && y == yi && (yi & 1) == 1) {\n                return Double.NEGATIVE_INFINITY;\n            }\n            if (y > 0 && y == yi && (yi & 1) == 1) {\n                return -0.0;\n            }\n        }\n        if (y < 0) {\n            return Double.POSITIVE_INFINITY;\n        }\n        if (y > 0) {\n            return 0.0;\n        }\n        return Double.NaN;\n    }\n    if (x == Double.POSITIVE_INFINITY) {\n        if (y != y) {\n                        return y;\n        }\n        if (y < 0.0) {\n            return 0.0;\n        } else {\n            return Double.POSITIVE_INFINITY;\n        }\n    }\n    if (y == Double.POSITIVE_INFINITY) {\n        if (x * x == 1.0) {\n            return Double.NaN;\n        }\n        if (x * x > 1.0) {\n            return Double.POSITIVE_INFINITY;\n        } else {\n            return 0.0;\n        }\n    }\n    if (x == Double.NEGATIVE_INFINITY) {\n        if (y != y) {\n                        return y;\n        }\n        if (y < 0) {\n            long yi = (long) y;\n            if (y == yi && (yi & 1) == 1) {\n                return -0.0;\n            }\n            return 0.0;\n        }\n        if (y > 0) {\n            long yi = (long) y;\n            if (y == yi && (yi & 1) == 1) {\n                return Double.NEGATIVE_INFINITY;\n            }\n            return Double.POSITIVE_INFINITY;\n        }\n    }\n    if (y == Double.NEGATIVE_INFINITY) {\n        if (x * x == 1.0) {\n            return Double.NaN;\n        }\n        if (x * x < 1.0) {\n            return Double.POSITIVE_INFINITY;\n        } else {\n            return 0.0;\n        }\n    }\n        if (x < 0) {\n                if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {\n            return pow(-x, y);\n        }\n        if (y == (long) y) {\n                        return ((long) y & 1) == 0 ? pow(-x, y) : -pow(-x, y);\n        } else {\n            return Double.NaN;\n        }\n    }\n        double ya;\n    double yb;\n    if (y < 8e298 && y > -8e298) {\n        double tmp1 = y * HEX_40000000;\n        ya = y + tmp1 - tmp1;\n        yb = y - ya;\n    } else {\n        double tmp1 = y * 9.31322574615478515625E-10;\n        double tmp2 = tmp1 * 9.31322574615478515625E-10;\n        ya = (tmp1 + tmp2 - tmp1) * HEX_40000000 * HEX_40000000;\n        yb = y - ya;\n    }\n        final double lores = log(x, lns);\n    if (Double.isInfinite(lores)) {\n                return lores;\n    }\n    double lna = lns[0];\n    double lnb = lns[1];\n        double tmp1 = lna * HEX_40000000;\n    double tmp2 = lna + tmp1 - tmp1;\n    lnb += lna - tmp2;\n    lna = tmp2;\n        final double aa = lna * ya;\n    final double ab = lna * yb + lnb * ya + lnb * yb;\n    lna = aa + ab;\n    lnb = -(lna - aa - ab);\n    double z = 1.0 / 120.0;\n    z = z * lnb + (1.0 / 24.0);\n    z = z * lnb + (1.0 / 6.0);\n    z = z * lnb + 0.5;\n    z = z * lnb + 1.0;\n    z = z * lnb;\n    final double result = exp(lna, z, null);\n        return result;\n}", "lc": 4.863636363636363, "pi": 0.25837320574162664, "ma": 5.2, "nbd": 0.5, "ml": 3.1666666666666665, "d": 7.900793650793649, "mi": -1.5319238900634244, "fo": 0.08333333333333333, "r": -0.02631578947368421, "e": 41.21708591944583}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4441_54c86ebb", "label": 1, "code": "/**\n *  Looks up a page by id from the {@link IPageStore}. <br/>\n *  If {@linkplain #pageClass} is specified then compares it against the stored instance class\n *  and returns the found instance only if they match.\n *\n *  @param pageId\n *             the id of the page to look for.\n *  @return the found page instance by id.\n */\nprivate IRequestablePage getStoredPage(final int pageId) {\n    IRequestablePage storedPageInstance = getPageSource().getPageInstance(pageId);\n    if (storedPageInstance != null) {\n        if (pageClass == null || pageClass.equals(storedPageInstance.getClass())) {\n            pageInstance = storedPageInstance;\n            pageInstanceIsFresh = false;\n            if (renderCount != null && pageInstance.getRenderCount() != renderCount) {\n                throw new StalePageException(pageInstance);\n            }\n        } else {\n            // the found page class doesn't match the requested one\n            storedPageInstance = null;\n        }\n    }\n    return storedPageInstance;\n}", "code_comment": "/**\n *  Looks up a page by id from the {@link IPageStore}. <br/>\n *  If {@linkplain #pageClass} is specified then compares it against the stored instance class\n *  and returns the found instance only if they match.\n *\n *  @param pageId\n *             the id of the page to look for.\n *  @return the found page instance by id.\n */\n", "code_no_comment": "private IRequestablePage getStoredPage(final int pageId) {\n    IRequestablePage storedPageInstance = getPageSource().getPageInstance(pageId);\n    if (storedPageInstance != null) {\n        if (pageClass == null || pageClass.equals(storedPageInstance.getClass())) {\n            pageInstance = storedPageInstance;\n            pageInstanceIsFresh = false;\n            if (renderCount != null && pageInstance.getRenderCount() != renderCount) {\n                throw new StalePageException(pageInstance);\n            }\n        } else {\n                        storedPageInstance = null;\n        }\n    }\n    return storedPageInstance;\n}", "lc": 0.045454545454545456, "pi": 0.8325358851674642, "ma": 0.2, "nbd": 0.5, "ml": 0.5, "d": 0.3591269841269841, "mi": -0.05510923185341784, "fo": -0.08333333333333333, "r": 0.10526315789473684, "e": 0.1446332762803778}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2430_be3a9114", "label": 1, "code": "@Override\npublic boolean propertyAdded(PropertyState after) {\n    if (!loader.isRunning()) {\n        return false;\n    }\n    builder.setProperty(binaryCheck(after));\n    return true;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean propertyAdded(PropertyState after) {\n    if (!loader.isRunning()) {\n        return false;\n    }\n    builder.setProperty(binaryCheck(after));\n    return true;\n}", "lc": -0.2727272727272727, "pi": -0.16267942583732073, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": -0.3650793650793651, "mi": 0.4365045806906271, "fo": -0.25, "r": 1.263157894736842, "e": -0.16279340490885932}
{"project_name": "Cli", "project_version": 15, "label": 1, "code": "public List getValues(final Option option, List defaultValues) {\n    // initialize the return list\n    List valueList = (List) values.get(option);\n    // grab the correct default values\n    if ((valueList == null) || valueList.isEmpty()) {\n        valueList = defaultValues;\n    }\n    // augment the list with the default values\n    if ((valueList == null) || valueList.isEmpty()) {\n        valueList = (List) this.defaultValues.get(option);\n    }\n    return valueList == null ? Collections.EMPTY_LIST : valueList;\n}", "code_comment": NaN, "code_no_comment": "public List getValues(final Option option, List defaultValues) {\n        List valueList = (List) values.get(option);\n        if ((valueList == null) || valueList.isEmpty()) {\n        valueList = defaultValues;\n    }\n        if ((valueList == null) || valueList.isEmpty()) {\n        valueList = (List) this.defaultValues.get(option);\n    }\n    return valueList == null ? Collections.EMPTY_LIST : valueList;\n}", "lc": -0.18181818181818182, "pi": -0.2200956937799045, "ma": 0.0, "nbd": -0.5, "ml": 0.16666666666666666, "d": 0.13888888888888887, "mi": 0.15264270613107836, "fo": -0.16666666666666666, "r": 0.2894736842105263, "e": 0.029139652956668555}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-1008_0c20bfd8", "label": 1, "code": "/**\n * Finds matches in a physical directory on a filesystem.  Examines all\n * files within a directory - if the File object is not a directory, and ends with <i>.class</i>\n * the file is loaded and tested to see if it is acceptable according to the Test.  Operates\n * recursively to find classes within a folder structure matching the package structure.\n *\n * @param test a Test used to filter the classes that are discovered\n * @param parent the package name up to this directory in the package hierarchy.  E.g. if\n *        /classes is in the classpath and we wish to examine files in /classes/org/apache then\n *        the values of <i>parent</i> would be <i>org/apache</i>\n * @param location a File object representing a directory\n */\nprivate void loadImplementationsInDirectory(final Test test, final String parent, final File location) {\n    final File[] files = location.listFiles();\n    if (files == null) {\n        return;\n    }\n    StringBuilder builder;\n    for (final File file : files) {\n        builder = new StringBuilder();\n        builder.append(parent).append('/').append(file.getName());\n        final String packageOrClass = parent == null ? file.getName() : builder.toString();\n        if (file.isDirectory()) {\n            loadImplementationsInDirectory(test, packageOrClass, file);\n        } else if (isTestApplicable(test, file.getName())) {\n            addIfMatching(test, packageOrClass);\n        }\n    }\n}", "code_comment": "/**\n * Finds matches in a physical directory on a filesystem.  Examines all\n * files within a directory - if the File object is not a directory, and ends with <i>.class</i>\n * the file is loaded and tested to see if it is acceptable according to the Test.  Operates\n * recursively to find classes within a folder structure matching the package structure.\n *\n * @param test a Test used to filter the classes that are discovered\n * @param parent the package name up to this directory in the package hierarchy.  E.g. if\n *        /classes is in the classpath and we wish to examine files in /classes/org/apache then\n *        the values of <i>parent</i> would be <i>org/apache</i>\n * @param location a File object representing a directory\n */\n", "code_no_comment": "private void loadImplementationsInDirectory(final Test test, final String parent, final File location) {\n    final File[] files = location.listFiles();\n    if (files == null) {\n        return;\n    }\n    StringBuilder builder;\n    for (final File file : files) {\n        builder = new StringBuilder();\n        builder.append(parent).append('/').append(file.getName());\n        final String packageOrClass = parent == null ? file.getName() : builder.toString();\n        if (file.isDirectory()) {\n            loadImplementationsInDirectory(test, packageOrClass, file);\n        } else if (isTestApplicable(test, file.getName())) {\n            addIfMatching(test, packageOrClass);\n        }\n    }\n}", "lc": 0.13636363636363635, "pi": 0.1913875598086124, "ma": 0.4, "nbd": 0.5, "ml": 0.4166666666666667, "d": 0.0853174603174603, "mi": -0.16560958421423533, "fo": 0.5, "r": -0.02631578947368421, "e": 0.101434391982619}
{"project_name": "Closure", "project_version": 134, "label": 2, "code": "/**\n * Find the function that's being overridden on this type, if any.\n */\nprivate FunctionType findOverriddenFunction(ObjectType ownerType, String propName) {\n    // First, check to see if the property is implemented\n    // on a superclass.\n    JSType propType = ownerType.getPropertyType(propName);\n    if (propType instanceof FunctionType) {\n        return (FunctionType) propType;\n    }\n    return null;\n}", "code_comment": "/**\n * Find the function that's being overridden on this type, if any.\n */\n", "code_no_comment": "private FunctionType findOverriddenFunction(ObjectType ownerType, String propName) {\n            JSType propType = ownerType.getPropertyType(propName);\n    if (propType instanceof FunctionType) {\n        return (FunctionType) propType;\n    }\n    return null;\n}", "lc": -0.3181818181818182, "pi": -0.20574162679425848, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": -0.3650793650793651, "mi": 0.465257223396758, "fo": -0.4166666666666667, "r": 2.289473684210526, "e": -0.16279340490885932}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1199_813109d7", "label": 3, "code": "public void getResult() throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException {\n    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {\n        throw new IllegalStateException(\"Method call not finished!\");\n    }\n    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());\n    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);\n    (new Client(prot)).recv_setTableProperty();\n}", "code_comment": NaN, "code_no_comment": "public void getResult() throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException {\n    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {\n        throw new IllegalStateException(\"Method call not finished!\");\n    }\n    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());\n    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);\n    (new Client(prot)).recv_setTableProperty();\n}", "lc": -0.2727272727272727, "pi": -0.2822966507177035, "ma": -0.2, "nbd": -0.5, "ml": -0.25, "d": -0.053571428571428575, "mi": 0.21099365750528534, "fo": 0.0, "r": -0.02631578947368421, "e": 0.004289921220817992}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4309_b4274415", "label": 1, "code": "/**\n *  Convert to object types, returning null if text is null.\n *\n *  @return converted\n *  @throws StringValueConversionException\n */\npublic final Double toOptionalDouble() throws StringValueConversionException {\n    return (text == null) ? null : toDoubleObject();\n}", "code_comment": "/**\n *  Convert to object types, returning null if text is null.\n *\n *  @return converted\n *  @throws StringValueConversionException\n */\n", "code_no_comment": "public final Double toOptionalDouble() throws StringValueConversionException {\n    return (text == null) ? null : toDoubleObject();\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.4, "nbd": -1.0, "ml": -0.25, "d": -0.3650793650793651, "mi": 0.9797040169133189, "fo": -0.4166666666666667, "r": 2.6052631578947367, "e": -0.16279340490885932}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-1820_39d526e6", "label": 0, "code": "/**\n *  Static utility to parse a field of type long from a byte sequence that represents text characters\n *  (such as when read from a file stream).\n *\n *  @param bytes The bytes containing the text data that should be parsed.\n *  @param startPos The offset to start the parsing.\n *  @param length The length of the byte sequence (counting from the offset).\n *  @param delimiter The delimiter that terminates the field.\n *\n *  @return The parsed value.\n *\n *  @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\n */\npublic static final long parseField(byte[] bytes, int startPos, int length, char delimiter) {\n    if (length <= 0) {\n        throw new NumberFormatException(\"Invalid input: Empty string\");\n    }\n    long val = 0;\n    boolean neg = false;\n    if (bytes[startPos] == '-') {\n        neg = true;\n        startPos++;\n        length--;\n        if (length == 0 || bytes[startPos] == delimiter) {\n            throw new NumberFormatException(\"Orphaned minus sign.\");\n        }\n    }\n    for (; length > 0; startPos++, length--) {\n        if (bytes[startPos] == delimiter) {\n            return neg ? -val : val;\n        }\n        if (bytes[startPos] < 48 || bytes[startPos] > 57) {\n            throw new NumberFormatException(\"Invalid character.\");\n        }\n        val *= 10;\n        val += bytes[startPos] - 48;\n        // check for overflow / underflow\n        if (val < 0) {\n            // this is an overflow/underflow, unless we hit exactly the Long.MIN_VALUE\n            if (neg && val == Long.MIN_VALUE) {\n                if (length == 1 || bytes[startPos + 1] == delimiter) {\n                    return Long.MIN_VALUE;\n                } else {\n                    throw new NumberFormatException(\"value overflow\");\n                }\n            } else {\n                throw new NumberFormatException(\"value overflow\");\n            }\n        }\n    }\n    return neg ? -val : val;\n}", "code_comment": "/**\n *  Static utility to parse a field of type long from a byte sequence that represents text characters\n *  (such as when read from a file stream).\n *\n *  @param bytes The bytes containing the text data that should be parsed.\n *  @param startPos The offset to start the parsing.\n *  @param length The length of the byte sequence (counting from the offset).\n *  @param delimiter The delimiter that terminates the field.\n *\n *  @return The parsed value.\n *\n *  @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\n */\n", "code_no_comment": "public static final long parseField(byte[] bytes, int startPos, int length, char delimiter) {\n    if (length <= 0) {\n        throw new NumberFormatException(\"Invalid input: Empty string\");\n    }\n    long val = 0;\n    boolean neg = false;\n    if (bytes[startPos] == '-') {\n        neg = true;\n        startPos++;\n        length--;\n        if (length == 0 || bytes[startPos] == delimiter) {\n            throw new NumberFormatException(\"Orphaned minus sign.\");\n        }\n    }\n    for (; length > 0; startPos++, length--) {\n        if (bytes[startPos] == delimiter) {\n            return neg ? -val : val;\n        }\n        if (bytes[startPos] < 48 || bytes[startPos] > 57) {\n            throw new NumberFormatException(\"Invalid character.\");\n        }\n        val *= 10;\n        val += bytes[startPos] - 48;\n                if (val < 0) {\n                        if (neg && val == Long.MIN_VALUE) {\n                if (length == 1 || bytes[startPos + 1] == delimiter) {\n                    return Long.MIN_VALUE;\n                } else {\n                    throw new NumberFormatException(\"value overflow\");\n                }\n            } else {\n                throw new NumberFormatException(\"value overflow\");\n            }\n        }\n    }\n    return neg ? -val : val;\n}", "lc": 1.0454545454545454, "pi": 0.9186602870813397, "ma": 2.6, "nbd": 1.0, "ml": 1.1666666666666667, "d": 3.4126984126984126, "mi": -0.7003523608174769, "fo": -0.5, "r": -0.02631578947368421, "e": 4.467020510249361}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2528_239de7b8", "label": 1, "code": "private void removeGarbage() {\n    if (garbage.isEmpty()) {\n        return;\n    } else if (main == null) {\n        main = new UpdateOp(id, false);\n    }\n    for (Map.Entry<String, Set<Revision>> entry : garbage.entrySet()) {\n        for (Revision r : entry.getValue()) {\n            main.removeMapEntry(entry.getKey(), r);\n            NodeDocument.removeCommitRoot(main, r);\n            NodeDocument.removeRevision(main, r);\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "private void removeGarbage() {\n    if (garbage.isEmpty()) {\n        return;\n    } else if (main == null) {\n        main = new UpdateOp(id, false);\n    }\n    for (Map.Entry<String, Set<Revision>> entry : garbage.entrySet()) {\n        for (Revision r : entry.getValue()) {\n            main.removeMapEntry(entry.getKey(), r);\n            NodeDocument.removeCommitRoot(main, r);\n            NodeDocument.removeRevision(main, r);\n        }\n    }\n}", "lc": 0.0, "pi": 0.4449760765550238, "ma": 0.2, "nbd": 0.0, "ml": -0.08333333333333333, "d": -0.0634920634920635, "mi": -0.014235377026074568, "fo": 0.08333333333333333, "r": -0.02631578947368421, "e": -0.04224684912086581}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-393_d4b02f6a", "label": 3, "code": "/**\n * Get the result of the last run of the optimizer.\n *\n * @return the last result.\n * @throws IllegalStateException if there is no result available, either\n * because no result was yet computed or the last attempt failed.\n */\ndouble getResult();", "code_comment": "/**\n * Get the result of the last run of the optimizer.\n *\n * @return the last result.\n * @throws IllegalStateException if there is no result available, either\n * because no result was yet computed or the last attempt failed.\n */\n", "code_no_comment": "double getResult();", "lc": -0.5909090909090909, "pi": -1.4306220095693782, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.8696264975334735, "fo": -0.5, "r": 2.6052631578947367, "e": -0.16279340490885932}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4520_b91154ea", "label": 1, "code": "/**\n *  THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT OVERRIDE OR CALL.\n *\n *  Internal initialization.\n */\nprotected void internalInit() {\n    settingsAccessible = true;\n    IPageSettings pageSettings = getPageSettings();\n    // Install default component resolvers\n    pageSettings.addComponentResolver(new MarkupInheritanceResolver());\n    pageSettings.addComponentResolver(new HtmlHeaderResolver());\n    pageSettings.addComponentResolver(new WicketLinkTagHandler());\n    pageSettings.addComponentResolver(new WicketMessageResolver());\n    pageSettings.addComponentResolver(new WicketMessageTagHandler());\n    pageSettings.addComponentResolver(new FragmentResolver());\n    pageSettings.addComponentResolver(new RelativePathPrefixHandler());\n    pageSettings.addComponentResolver(new EnclosureHandler());\n    pageSettings.addComponentResolver(new InlineEnclosureHandler());\n    pageSettings.addComponentResolver(new WicketContainerResolver());\n    // Install button image resource factory\n    getResourceSettings().addResourceFactory(\"buttonFactory\", new DefaultButtonImageResourceFactory());\n    String applicationKey = getApplicationKey();\n    applicationKeyToApplication.put(applicationKey, this);\n    converterLocator = newConverterLocator();\n    setPageManagerProvider(new DefaultPageManagerProvider(this));\n    resourceReferenceRegistry = newResourceReferenceRegistry();\n    sharedResources = newSharedResources(resourceReferenceRegistry);\n    resourceBundles = newResourceBundles(resourceReferenceRegistry);\n    // set up default request mapper\n    setRootRequestMapper(new SystemMapper(this));\n    pageFactory = newPageFactory();\n    requestCycleProvider = new DefaultRequestCycleProvider();\n    exceptionMapperProvider = new DefaultExceptionMapperProvider();\n    // add a request cycle listener that logs each request for the requestlogger.\n    getRequestCycleListeners().add(new RequestLoggerRequestCycleListener());\n}", "code_comment": "/**\n *  THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT OVERRIDE OR CALL.\n *\n *  Internal initialization.\n */\n", "code_no_comment": "protected void internalInit() {\n    settingsAccessible = true;\n    IPageSettings pageSettings = getPageSettings();\n        pageSettings.addComponentResolver(new MarkupInheritanceResolver());\n    pageSettings.addComponentResolver(new HtmlHeaderResolver());\n    pageSettings.addComponentResolver(new WicketLinkTagHandler());\n    pageSettings.addComponentResolver(new WicketMessageResolver());\n    pageSettings.addComponentResolver(new WicketMessageTagHandler());\n    pageSettings.addComponentResolver(new FragmentResolver());\n    pageSettings.addComponentResolver(new RelativePathPrefixHandler());\n    pageSettings.addComponentResolver(new EnclosureHandler());\n    pageSettings.addComponentResolver(new InlineEnclosureHandler());\n    pageSettings.addComponentResolver(new WicketContainerResolver());\n        getResourceSettings().addResourceFactory(\"buttonFactory\", new DefaultButtonImageResourceFactory());\n    String applicationKey = getApplicationKey();\n    applicationKeyToApplication.put(applicationKey, this);\n    converterLocator = newConverterLocator();\n    setPageManagerProvider(new DefaultPageManagerProvider(this));\n    resourceReferenceRegistry = newResourceReferenceRegistry();\n    sharedResources = newSharedResources(resourceReferenceRegistry);\n    resourceBundles = newResourceBundles(resourceReferenceRegistry);\n        setRootRequestMapper(new SystemMapper(this));\n    pageFactory = newPageFactory();\n    requestCycleProvider = new DefaultRequestCycleProvider();\n    exceptionMapperProvider = new DefaultExceptionMapperProvider();\n        getRequestCycleListeners().add(new RequestLoggerRequestCycleListener());\n}", "lc": 0.5909090909090909, "pi": -0.9282296650717705, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": -0.42917547568710335, "fo": 1.5, "r": -0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "Csv", "project_version": 11, "label": 1, "code": "/**\n * Initializes the name to index mapping if the format defines a header.\n *\n * @return null if the format has no header.\n * @throws IOException if there is a problem reading the header or skipping the first record\n */\nprivate Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader != null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n        String[] headerRecord = null;\n        if (formatHeader.length == 0) {\n            // read the header from the first line of the file\n            final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord != null) {\n                headerRecord = nextRecord.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            headerRecord = formatHeader;\n        }\n        // build the name to index mappings\n        if (headerRecord != null) {\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                final boolean containsHeader = hdrMap.containsKey(header);\n                final boolean emptyHeader = header.trim().isEmpty();\n                if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                    throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header + \"\\\" in \" + Arrays.toString(headerRecord));\n                }\n                hdrMap.put(header, Integer.valueOf(i));\n            }\n        }\n    }\n    return hdrMap;\n}", "code_comment": "/**\n * Initializes the name to index mapping if the format defines a header.\n *\n * @return null if the format has no header.\n * @throws IOException if there is a problem reading the header or skipping the first record\n */\n", "code_no_comment": "private Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader != null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n        String[] headerRecord = null;\n        if (formatHeader.length == 0) {\n                        final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord != null) {\n                headerRecord = nextRecord.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            headerRecord = formatHeader;\n        }\n                if (headerRecord != null) {\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                final boolean containsHeader = hdrMap.containsKey(header);\n                final boolean emptyHeader = header.trim().isEmpty();\n                if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                    throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header + \"\\\" in \" + Arrays.toString(headerRecord));\n                }\n                hdrMap.put(header, Integer.valueOf(i));\n            }\n        }\n    }\n    return hdrMap;\n}", "lc": 0.7727272727272727, "pi": 1.0382775119617225, "ma": 1.0, "nbd": 1.0, "ml": 1.25, "d": 1.478174603174603, "mi": -0.5746300211416491, "fo": 0.5, "r": -0.02631578947368421, "e": 2.20881151201858}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2799_3979fa8d", "label": 1, "code": "@Override\npublic void readBytes(byte[] b, int o, int n) throws IOException {\n    file.readBytes(b, o, n);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void readBytes(byte[] b, int o, int n) throws IOException {\n    file.readBytes(b, o, n);\n}", "lc": -0.45454545454545453, "pi": -0.6028708133971293, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.8128259337561663, "fo": -0.4166666666666667, "r": 0.0, "e": -0.16279340490885932}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-2172_ea4a3f8a", "label": 3, "code": "/**\n *  @see IValueMap#getAsDouble(String, double)\n */\npublic double getAsDouble(String key, double defaultValue) {\n    try {\n        return getDouble(key, defaultValue);\n    } catch (StringValueConversionException ignored) {\n        return defaultValue;\n    }\n}", "code_comment": "/**\n *  @see IValueMap#getAsDouble(String, double)\n */\n", "code_no_comment": "public double getAsDouble(String key, double defaultValue) {\n    try {\n        return getDouble(key, defaultValue);\n    } catch (StringValueConversionException ignored) {\n        return defaultValue;\n    }\n}", "lc": -0.3181818181818182, "pi": 0.01435406698564584, "ma": -0.4, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.5633544749823818, "fo": -0.4166666666666667, "r": 2.131578947368421, "e": -0.16279340490885932}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-2121_03340919", "label": 3, "code": "/**\n *  Enumerate all files in the directory and recursive if enumerateNestedFiles is true.\n *  @return the total length of accepted files.\n */\nprivate long addFilesInDir(Path path, List<FileStatus> files, long length, boolean logExcludedFiles) throws IOException {\n    final FileSystem fs = path.getFileSystem();\n    for (FileStatus dir : fs.listStatus(path)) {\n        if (dir.isDir()) {\n            if (acceptFile(dir) && enumerateNestedFiles) {\n                length += addFilesInDir(dir.getPath(), files, length, logExcludedFiles);\n            } else {\n                if (logExcludedFiles && LOG.isDebugEnabled()) {\n                    LOG.debug(\"Directory \" + dir.getPath().toString() + \" did not pass the file-filter and is excluded.\");\n                }\n            }\n        } else {\n            if (acceptFile(dir)) {\n                files.add(dir);\n                length += dir.getLen();\n                testForUnsplittable(dir);\n            } else {\n                if (logExcludedFiles && LOG.isDebugEnabled()) {\n                    LOG.debug(\"Directory \" + dir.getPath().toString() + \" did not pass the file-filter and is excluded.\");\n                }\n            }\n        }\n    }\n    return length;\n}", "code_comment": "/**\n *  Enumerate all files in the directory and recursive if enumerateNestedFiles is true.\n *  @return the total length of accepted files.\n */\n", "code_no_comment": "private long addFilesInDir(Path path, List<FileStatus> files, long length, boolean logExcludedFiles) throws IOException {\n    final FileSystem fs = path.getFileSystem();\n    for (FileStatus dir : fs.listStatus(path)) {\n        if (dir.isDir()) {\n            if (acceptFile(dir) && enumerateNestedFiles) {\n                length += addFilesInDir(dir.getPath(), files, length, logExcludedFiles);\n            } else {\n                if (logExcludedFiles && LOG.isDebugEnabled()) {\n                    LOG.debug(\"Directory \" + dir.getPath().toString() + \" did not pass the file-filter and is excluded.\");\n                }\n            }\n        } else {\n            if (acceptFile(dir)) {\n                files.add(dir);\n                length += dir.getLen();\n                testForUnsplittable(dir);\n            } else {\n                if (logExcludedFiles && LOG.isDebugEnabled()) {\n                    LOG.debug(\"Directory \" + dir.getPath().toString() + \" did not pass the file-filter and is excluded.\");\n                }\n            }\n        }\n    }\n    return length;\n}", "lc": 0.5, "pi": 1.3301435406698563, "ma": 0.6, "nbd": 1.0, "ml": 0.75, "d": 0.5138888888888888, "mi": -0.39647639182522887, "fo": 1.0, "r": -0.02631578947368421, "e": 0.5518092702408325}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-843_65390f8c", "label": 3, "code": "@Override\npublic void setLocalityGroups(String tableName, Map<String, Set<Text>> groups) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {\n    throw new NotImplementedException();\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void setLocalityGroups(String tableName, Map<String, Set<Text>> groups) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {\n    throw new NotImplementedException();\n}", "lc": -0.45454545454545453, "pi": -0.6028708133971293, "ma": -0.4, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.7527836504580688, "fo": -0.5, "r": 0.0, "e": -0.16279340490885932}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-776_dc9f23d9", "label": 3, "code": "/**\n * A convenience method for setting the end timestamp accepted by the timestamp filter.\n *\n * @param is\n *          the iterator setting object to configure\n * @param end\n *          the end timestamp (yyyyMMddHHmmssz)\n * @param endInclusive\n *          boolean indicating whether the end is inclusive\n */\npublic static void setEnd(IteratorSetting is, String end, boolean endInclusive) {\n    is.addOption(END, end);\n    is.addOption(END_INCL, Boolean.toString(endInclusive));\n}", "code_comment": "/**\n * A convenience method for setting the end timestamp accepted by the timestamp filter.\n *\n * @param is\n *          the iterator setting object to configure\n * @param end\n *          the end timestamp (yyyyMMddHHmmssz)\n * @param endInclusive\n *          boolean indicating whether the end is inclusive\n */\n", "code_no_comment": "public static void setEnd(IteratorSetting is, String end, boolean endInclusive) {\n    is.addOption(END, end);\n    is.addOption(END_INCL, Boolean.toString(endInclusive));\n}", "lc": -0.45454545454545453, "pi": -0.47368421052631593, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.7355884425651865, "fo": -0.25, "r": 2.3157894736842106, "e": -0.16279340490885932}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-1640_8f321c72", "label": 1, "code": "/**\n *  Normalizes a path string.\n *\n *  @param path\n *         the path string to normalize\n *  @return the normalized path string\n */\nprivate String normalizePath(String path) {\n    // remove double slashes & backslashes\n    path = path.replace(\"//\", \"/\");\n    path = path.replace(\"\\\\\", \"/\");\n    return path;\n}", "code_comment": "/**\n *  Normalizes a path string.\n *\n *  @param path\n *         the path string to normalize\n *  @return the normalized path string\n */\n", "code_no_comment": "private String normalizePath(String path) {\n        path = path.replace(\"//\", \"/\");\n    path = path.replace(\"\\\\\", \"/\");\n    return path;\n}", "lc": -0.4090909090909091, "pi": -0.49282296650717716, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.6434108527131782, "fo": -0.3333333333333333, "r": 2.236842105263158, "e": -0.16279340490885932}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1364_05c89637", "label": 1, "code": "@SuppressWarnings(\"unchecked\")\n@Override\npublic V get(Object key) {\n    return CacheLIRS.this.getUnchecked((K) key);\n}", "code_comment": NaN, "code_no_comment": "@SuppressWarnings(\"unchecked\")\n@Override\npublic V get(Object key) {\n    return CacheLIRS.this.getUnchecked((K) key);\n}", "lc": -0.4090909090909091, "pi": -0.6650717703349284, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.6899224806201547, "fo": -0.4166666666666667, "r": 1.526315789473684, "e": -0.16279340490885932}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-4358_74cbba24", "label": 1, "code": "@Override\npublic Iterator<Revision> iterator() {\n    final Set<Revision> changes = getValueMap(property).keySet();\n    final Set<Integer> clusterIds = Sets.newHashSet();\n    for (Revision r : getLocalMap(property).keySet()) {\n        clusterIds.add(r.getClusterId());\n    }\n    for (Range r : getPreviousRanges().values()) {\n        if (min.isRevisionNewer(r.high)) {\n            clusterIds.add(r.high.getClusterId());\n        }\n    }\n    final Iterator<Revision> unfiltered = changes.iterator();\n    return new AbstractIterator<Revision>() {\n\n        @Override\n        protected Revision computeNext() {\n            while (unfiltered.hasNext()) {\n                Revision next = unfiltered.next();\n                if (min.isRevisionNewer(next)) {\n                    return next;\n                } else {\n                    // further revisions with this clusterId\n                    // are older than min revision\n                    clusterIds.remove(next.getClusterId());\n                    // no more revisions to check\n                    if (clusterIds.isEmpty()) {\n                        return endOfData();\n                    }\n                }\n            }\n            return endOfData();\n        }\n    };\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic Iterator<Revision> iterator() {\n    final Set<Revision> changes = getValueMap(property).keySet();\n    final Set<Integer> clusterIds = Sets.newHashSet();\n    for (Revision r : getLocalMap(property).keySet()) {\n        clusterIds.add(r.getClusterId());\n    }\n    for (Range r : getPreviousRanges().values()) {\n        if (min.isRevisionNewer(r.high)) {\n            clusterIds.add(r.high.getClusterId());\n        }\n    }\n    final Iterator<Revision> unfiltered = changes.iterator();\n    return new AbstractIterator<Revision>() {\n\n        @Override\n        protected Revision computeNext() {\n            while (unfiltered.hasNext()) {\n                Revision next = unfiltered.next();\n                if (min.isRevisionNewer(next)) {\n                    return next;\n                } else {\n                                                            clusterIds.remove(next.getClusterId());\n                                        if (clusterIds.isEmpty()) {\n                        return endOfData();\n                    }\n                }\n            }\n            return endOfData();\n        }\n    };\n}", "lc": 0.7727272727272727, "pi": 1.7846889952153109, "ma": 0.6, "nbd": 1.0, "ml": 0.4166666666666667, "d": -0.3650793650793651, "mi": -0.49598308668076097, "fo": 1.25, "r": -0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5898_ffdd0864", "label": 1, "code": "/**\n *  Search for the child's markup in the associated markup file.\n *\n *  @param parent\n *             The container expected to contain the markup for child\n *  @param child\n *             The child component to find the markup for\n *  @return The markup associated with the child\n */\n@Override\npublic IMarkupFragment getMarkup(final MarkupContainer parent, final Component child) {\n    Args.notNull(tagName, \"tagName\");\n    IMarkupFragment associatedMarkup = parent.getAssociatedMarkup();\n    if (associatedMarkup == null) {\n        throw new MarkupNotFoundException(\"Failed to find markup file associated. \" + Classes.simpleName(parent.getClass()) + \": \" + parent.toString());\n    }\n    // Find <wicket:panel>\n    IMarkupFragment markup = MarkupUtil.findStartTag(associatedMarkup, tagName);\n    if (markup == null) {\n        throw new MarkupNotFoundException(\"Expected to find <wicket:\" + tagName + \"> in associated markup file. Markup: \" + associatedMarkup.toString());\n    }\n    // If child == null, than return the markup fragment starting with <wicket:panel>\n    if (child == null) {\n        return markup;\n    }\n    // Find the markup for the child component\n    associatedMarkup = markup.find(child.getId());\n    if (associatedMarkup != null) {\n        return associatedMarkup;\n    }\n    associatedMarkup = searchMarkupInTransparentResolvers(parent, child);\n    if (associatedMarkup != null) {\n        return associatedMarkup;\n    }\n    return findMarkupInAssociatedFileHeader(parent, child);\n}", "code_comment": "/**\n *  Search for the child's markup in the associated markup file.\n *\n *  @param parent\n *             The container expected to contain the markup for child\n *  @param child\n *             The child component to find the markup for\n *  @return The markup associated with the child\n */\n", "code_no_comment": "@Override\npublic IMarkupFragment getMarkup(final MarkupContainer parent, final Component child) {\n    Args.notNull(tagName, \"tagName\");\n    IMarkupFragment associatedMarkup = parent.getAssociatedMarkup();\n    if (associatedMarkup == null) {\n        throw new MarkupNotFoundException(\"Failed to find markup file associated. \" + Classes.simpleName(parent.getClass()) + \": \" + parent.toString());\n    }\n        IMarkupFragment markup = MarkupUtil.findStartTag(associatedMarkup, tagName);\n    if (markup == null) {\n        throw new MarkupNotFoundException(\"Expected to find <wicket:\" + tagName + \"> in associated markup file. Markup: \" + associatedMarkup.toString());\n    }\n        if (child == null) {\n        return markup;\n    }\n        associatedMarkup = markup.find(child.getId());\n    if (associatedMarkup != null) {\n        return associatedMarkup;\n    }\n    associatedMarkup = searchMarkupInTransparentResolvers(parent, child);\n    if (associatedMarkup != null) {\n        return associatedMarkup;\n    }\n    return findMarkupInAssociatedFileHeader(parent, child);\n}", "lc": 0.45454545454545453, "pi": -0.33492822966507185, "ma": 0.8, "nbd": -0.5, "ml": 0.25, "d": 0.45436507936507936, "mi": -0.3928118393234672, "fo": 0.4166666666666667, "r": -0.02631578947368421, "e": 0.5449214225203574}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1655_c91bfa54", "label": 1, "code": "@Override\npublic boolean apply(DataIdentifier input) {\n    try {\n        DataRecord dr = delegate.getRecord(input);\n        if (dr != null && dr.getLastModified() < maxLastModifiedTime) {\n            return true;\n        }\n    } catch (DataStoreException e) {\n        log.warn(\"Error occurred while fetching DataRecord for identifier {}\", input, e);\n    }\n    return false;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean apply(DataIdentifier input) {\n    try {\n        DataRecord dr = delegate.getRecord(input);\n        if (dr != null && dr.getLastModified() < maxLastModifiedTime) {\n            return true;\n        }\n    } catch (DataStoreException e) {\n        log.warn(\"Error occurred while fetching DataRecord for identifier {}\", input, e);\n    }\n    return false;\n}", "lc": -0.09090909090909091, "pi": 0.3397129186602871, "ma": -0.2, "nbd": 0.0, "ml": 0.0, "d": 0.13690476190476186, "mi": 0.11374207188160664, "fo": -0.25, "r": 0.21052631578947367, "e": -0.015271750718924866}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-1096_faf99727", "label": 0, "code": "/**\n * Compute enclosing ball using Welzl's move to front heuristic.\n * @param extreme subset of extreme points\n * @param support points that must belong to the ball support\n * @return enclosing ball, for the extreme subset only\n */\nprivate EnclosingBall<S, P> moveToFrontBall(final List<P> extreme, final List<P> support) {\n    // create a new ball on the prescribed support\n    EnclosingBall<S, P> ball = generator.ballOnSupport(support);\n    if (ball.getSupportSize() < max) {\n        for (int i = 0; i < extreme.size(); ++i) {\n            final P pi = extreme.get(i);\n            if (!ball.contains(pi, tolerance)) {\n                // we have found an outside point,\n                // enlarge the ball by adding it to the support\n                support.add(pi);\n                ball = moveToFrontBall(extreme.subList(i + 1, extreme.size()), support);\n                // according to Welzl's heuristic\n                for (int j = i; j > 1; --j) {\n                    extreme.set(j, extreme.get(j - 1));\n                }\n                extreme.set(0, pi);\n            }\n        }\n    }\n    return ball;\n}", "code_comment": "/**\n * Compute enclosing ball using Welzl's move to front heuristic.\n * @param extreme subset of extreme points\n * @param support points that must belong to the ball support\n * @return enclosing ball, for the extreme subset only\n */\n", "code_no_comment": "private EnclosingBall<S, P> moveToFrontBall(final List<P> extreme, final List<P> support) {\n        EnclosingBall<S, P> ball = generator.ballOnSupport(support);\n    if (ball.getSupportSize() < max) {\n        for (int i = 0; i < extreme.size(); ++i) {\n            final P pi = extreme.get(i);\n            if (!ball.contains(pi, tolerance)) {\n                                                support.add(pi);\n                ball = moveToFrontBall(extreme.subList(i + 1, extreme.size()), support);\n                                for (int j = i; j > 1; --j) {\n                    extreme.set(j, extreme.get(j - 1));\n                }\n                extreme.set(0, pi);\n            }\n        }\n    }\n    return ball;\n}", "lc": 0.13636363636363635, "pi": 1.5119617224880384, "ma": 0.2, "nbd": 1.0, "ml": 0.5833333333333334, "d": 1.6984126984126986, "mi": -0.22452431289640595, "fo": 0.5, "r": -0.02631578947368421, "e": 1.723762267826167}
{"project_name": "maven", "project_version": "remotes/origin/bugs-dot-jar_MNG-5655_96337372", "label": 1, "code": "public void afterMojoExecutionSuccess(MojoExecutionEvent event) throws MojoExecutionException {\n    for (Object provided : getScopeState().provided.values()) {\n        if (provided instanceof WeakMojoExecutionListener) {\n            ((WeakMojoExecutionListener) provided).afterMojoExecutionSuccess(event);\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "public void afterMojoExecutionSuccess(MojoExecutionEvent event) throws MojoExecutionException {\n    for (Object provided : getScopeState().provided.values()) {\n        if (provided instanceof WeakMojoExecutionListener) {\n            ((WeakMojoExecutionListener) provided).afterMojoExecutionSuccess(event);\n        }\n    }\n}", "lc": -0.3181818181818182, "pi": 0.5406698564593301, "ma": -0.2, "nbd": 0.0, "ml": -0.25, "d": -0.3650793650793651, "mi": 0.4872445384073289, "fo": -0.25, "r": 0.15789473684210528, "e": -0.16279340490885932}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-276_1bf5c550", "label": 1, "code": "// ---------------------------------------------------< Persistence >\npublic void initialize(File homeDir) throws Exception {\n    File dbDir = new File(homeDir, \"db\");\n    if (!dbDir.exists()) {\n        dbDir.mkdirs();\n    }\n    Driver.load();\n    String url = \"jdbc:h2:\" + dbDir.getCanonicalPath() + \"/revs\";\n    if (FAST) {\n        url += \";log=0;undo_log=0\";\n    }\n    cp = JdbcConnectionPool.create(url, \"sa\", \"\");\n    cp.setMaxConnections(40);\n    Connection con = cp.getConnection();\n    try {\n        Statement stmt = con.createStatement();\n        stmt.execute(\"create table if not exists REVS(ID binary primary key, DATA binary, TIME timestamp)\");\n        stmt.execute(\"create table if not exists HEAD(ID binary) as select null\");\n        stmt.execute(\"create sequence if not exists DATASTORE_ID\");\n    /*\n            DbBlobStore store = new DbBlobStore();\n            store.setConnectionPool(cp);\n            blobStore = store;\n*/\n    } finally {\n        con.close();\n    }\n}", "code_comment": NaN, "code_no_comment": "public void initialize(File homeDir) throws Exception {\n    File dbDir = new File(homeDir, \"db\");\n    if (!dbDir.exists()) {\n        dbDir.mkdirs();\n    }\n    Driver.load();\n    String url = \"jdbc:h2:\" + dbDir.getCanonicalPath() + \"/revs\";\n    if (FAST) {\n        url += \";log=0;undo_log=0\";\n    }\n    cp = JdbcConnectionPool.create(url, \"sa\", \"\");\n    cp.setMaxConnections(40);\n    Connection con = cp.getConnection();\n    try {\n        Statement stmt = con.createStatement();\n        stmt.execute(\"create table if not exists REVS(ID binary primary key, DATA binary, TIME timestamp)\");\n        stmt.execute(\"create table if not exists HEAD(ID binary) as select null\");\n        stmt.execute(\"create sequence if not exists DATASTORE_ID\");\n        } finally {\n        con.close();\n    }\n}", "lc": 0.36363636363636365, "pi": -0.2870813397129187, "ma": -0.2, "nbd": -0.5, "ml": -0.16666666666666666, "d": 0.21825396825396823, "mi": -0.3009161381254403, "fo": 0.5, "r": 0.31578947368421056, "e": 0.2778997596860358}
{"project_name": "Closure", "project_version": 105, "label": 2, "code": "/**\n * Try to fold an array join: ['a', 'b', 'c'].join('') -> 'abc';\n */\nvoid tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right, Node parent) {\n    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n        return;\n    }\n    Node arrayNode = left.getFirstChild();\n    Node functionName = arrayNode.getNext();\n    if ((arrayNode.getType() != Token.ARRAYLIT) || !functionName.getString().equals(\"join\")) {\n        return;\n    }\n    String joinString = NodeUtil.getStringValue(right);\n    List<Node> arrayFoldedChildren = Lists.newLinkedList();\n    StringBuilder sb = new StringBuilder();\n    int foldedSize = 0;\n    Node elem = arrayNode.getFirstChild();\n    // Merges adjacent String nodes.\n    while (elem != null) {\n        if (NodeUtil.isImmutableValue(elem)) {\n            if (sb.length() > 0) {\n                sb.append(joinString);\n            }\n            sb.append(NodeUtil.getStringValue(elem));\n        } else {\n            if (sb.length() > 0) {\n                // + 2 for the quotes.\n                foldedSize += sb.length() + 2;\n                arrayFoldedChildren.add(Node.newString(sb.toString()));\n                sb = new StringBuilder();\n            }\n            foldedSize += InlineCostEstimator.getCost(elem);\n            arrayFoldedChildren.add(elem);\n        }\n        elem = elem.getNext();\n    }\n    if (sb.length() > 0) {\n        // + 2 for the quotes.\n        foldedSize += sb.length() + 2;\n        arrayFoldedChildren.add(Node.newString(sb.toString()));\n    }\n    // one for each comma.\n    foldedSize += arrayFoldedChildren.size() - 1;\n    int originalSize = InlineCostEstimator.getCost(n);\n    switch(arrayFoldedChildren.size()) {\n        case 0:\n            Node emptyStringNode = Node.newString(\"\");\n            parent.replaceChild(n, emptyStringNode);\n            break;\n        case 1:\n            Node foldedStringNode = arrayFoldedChildren.remove(0);\n            if (foldedSize > originalSize) {\n                return;\n            }\n            arrayNode.detachChildren();\n            if (foldedStringNode.getType() != Token.STRING) {\n                // If the Node is not a string literal, ensure that\n                // it is coerced to a string.\n                Node replacement = new Node(Token.ADD, Node.newString(\"\"), foldedStringNode);\n                foldedStringNode = replacement;\n            }\n            parent.replaceChild(n, foldedStringNode);\n            break;\n        default:\n            // No folding could actually be performed.\n            if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {\n                return;\n            }\n            int kJoinOverhead = \"[].join()\".length();\n            foldedSize += kJoinOverhead;\n            foldedSize += InlineCostEstimator.getCost(right);\n            if (foldedSize > originalSize) {\n                return;\n            }\n            arrayNode.detachChildren();\n            for (Node node : arrayFoldedChildren) {\n                arrayNode.addChildToBack(node);\n            }\n            break;\n    }\n    t.getCompiler().reportCodeChange();\n}", "code_comment": "/**\n * Try to fold an array join: ['a', 'b', 'c'].join('') -> 'abc';\n */\n", "code_no_comment": "void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right, Node parent) {\n    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n        return;\n    }\n    Node arrayNode = left.getFirstChild();\n    Node functionName = arrayNode.getNext();\n    if ((arrayNode.getType() != Token.ARRAYLIT) || !functionName.getString().equals(\"join\")) {\n        return;\n    }\n    String joinString = NodeUtil.getStringValue(right);\n    List<Node> arrayFoldedChildren = Lists.newLinkedList();\n    StringBuilder sb = new StringBuilder();\n    int foldedSize = 0;\n    Node elem = arrayNode.getFirstChild();\n        while (elem != null) {\n        if (NodeUtil.isImmutableValue(elem)) {\n            if (sb.length() > 0) {\n                sb.append(joinString);\n            }\n            sb.append(NodeUtil.getStringValue(elem));\n        } else {\n            if (sb.length() > 0) {\n                                foldedSize += sb.length() + 2;\n                arrayFoldedChildren.add(Node.newString(sb.toString()));\n                sb = new StringBuilder();\n            }\n            foldedSize += InlineCostEstimator.getCost(elem);\n            arrayFoldedChildren.add(elem);\n        }\n        elem = elem.getNext();\n    }\n    if (sb.length() > 0) {\n                foldedSize += sb.length() + 2;\n        arrayFoldedChildren.add(Node.newString(sb.toString()));\n    }\n        foldedSize += arrayFoldedChildren.size() - 1;\n    int originalSize = InlineCostEstimator.getCost(n);\n    switch(arrayFoldedChildren.size()) {\n        case 0:\n            Node emptyStringNode = Node.newString(\"\");\n            parent.replaceChild(n, emptyStringNode);\n            break;\n        case 1:\n            Node foldedStringNode = arrayFoldedChildren.remove(0);\n            if (foldedSize > originalSize) {\n                return;\n            }\n            arrayNode.detachChildren();\n            if (foldedStringNode.getType() != Token.STRING) {\n                                                Node replacement = new Node(Token.ADD, Node.newString(\"\"), foldedStringNode);\n                foldedStringNode = replacement;\n            }\n            parent.replaceChild(n, foldedStringNode);\n            break;\n        default:\n                        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {\n                return;\n            }\n            int kJoinOverhead = \"[].join()\".length();\n            foldedSize += kJoinOverhead;\n            foldedSize += InlineCostEstimator.getCost(right);\n            if (foldedSize > originalSize) {\n                return;\n            }\n            arrayNode.detachChildren();\n            for (Node node : arrayFoldedChildren) {\n                arrayNode.addChildToBack(node);\n            }\n            break;\n    }\n    t.getCompiler().reportCodeChange();\n}", "lc": 2.6363636363636362, "pi": 0.6889952153110046, "ma": 3.0, "nbd": 0.5, "ml": 2.0, "d": 1.9642857142857144, "mi": -1.1553206483439038, "fo": 3.3333333333333335, "r": -0.02631578947368421, "e": 7.161280060856485}
{"project_name": "Cli", "project_version": 9, "label": 1, "code": "/**\n * <p>Throws a {@link MissingOptionException} if all of the\n * required options are no present.</p>\n *\n * @throws MissingOptionException if any of the required Options\n * are not present.\n */\nprotected void checkRequiredOptions() throws MissingOptionException {\n    // processsed\n    if (getRequiredOptions().size() > 0) {\n        Iterator iter = getRequiredOptions().iterator();\n        StringBuffer buff = new StringBuffer(\"Missing required option\");\n        buff.append(getRequiredOptions().size() == 1 ? \"\" : \"s\");\n        buff.append(\": \");\n        // loop through the required options\n        while (iter.hasNext()) {\n            buff.append(iter.next());\n        }\n        throw new MissingOptionException(buff.toString());\n    }\n}", "code_comment": "/**\n * <p>Throws a {@link MissingOptionException} if all of the\n * required options are no present.</p>\n *\n * @throws MissingOptionException if any of the required Options\n * are not present.\n */\n", "code_no_comment": "protected void checkRequiredOptions() throws MissingOptionException {\n        if (getRequiredOptions().size() > 0) {\n        Iterator iter = getRequiredOptions().iterator();\n        StringBuffer buff = new StringBuffer(\"Missing required option\");\n        buff.append(getRequiredOptions().size() == 1 ? \"\" : \"s\");\n        buff.append(\": \");\n                while (iter.hasNext()) {\n            buff.append(iter.next());\n        }\n        throw new MissingOptionException(buff.toString());\n    }\n}", "lc": -0.09090909090909091, "pi": 0.22009569377990432, "ma": 0.2, "nbd": 0.0, "ml": 0.0, "d": -0.03769841269841273, "mi": 0.059901338971106395, "fo": 0.5, "r": 1.263157894736842, "e": -0.0354742598963826}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-4038_557eec4f", "label": 1, "code": "@Override\npublic double getCost(Filter filter, NodeState root) {\n    if (filter.getFullTextConstraint() != null) {\n        // not an appropriate index for full-text search\n        return Double.POSITIVE_INFINITY;\n    }\n    if (filter.containsNativeConstraint()) {\n        // not an appropriate index for native search\n        return Double.POSITIVE_INFINITY;\n    }\n    if (filter.getPropertyRestrictions().isEmpty() && filter.getSelector().getSelectorConstraints().isEmpty()) {\n        // not an appropriate index for no property restrictions & selector constraints\n        return Double.POSITIVE_INFINITY;\n    }\n    PropertyIndexPlan plan = getPlan(root, filter);\n    if (plan != null) {\n        return plan.getCost();\n    } else {\n        return Double.POSITIVE_INFINITY;\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic double getCost(Filter filter, NodeState root) {\n    if (filter.getFullTextConstraint() != null) {\n                return Double.POSITIVE_INFINITY;\n    }\n    if (filter.containsNativeConstraint()) {\n                return Double.POSITIVE_INFINITY;\n    }\n    if (filter.getPropertyRestrictions().isEmpty() && filter.getSelector().getSelectorConstraints().isEmpty()) {\n                return Double.POSITIVE_INFINITY;\n    }\n    PropertyIndexPlan plan = getPlan(root, filter);\n    if (plan != null) {\n        return plan.getCost();\n    } else {\n        return Double.POSITIVE_INFINITY;\n    }\n}", "lc": 0.18181818181818182, "pi": -0.17224880382775137, "ma": 0.2, "nbd": -0.5, "ml": 0.4166666666666667, "d": 0.009920634920634885, "mi": -0.134601832276251, "fo": 0.25, "r": 0.0, "e": -0.006973139007509089}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3930_b939aa6e", "label": 1, "code": "@Override\npublic void endElement(String namespaceURI, String localName, String qName) throws SAXException {\n    // check element name\n    ImportState state = stack.peek();\n    if (namespaceURI.equals(NamespaceConstants.NAMESPACE_SV) && \"node\".equals(localName)) {\n        // sv:node element\n        if (!state.started) {\n            // need to start & end current node\n            processNode(state, true, true);\n            state.started = true;\n        } else {\n            // need to end current node\n            processNode(state, false, true);\n        }\n        // pop current state from stack\n        stack.pop();\n    } else if (namespaceURI.equals(NamespaceConstants.NAMESPACE_SV) && \"property\".equals(localName)) {\n        // have been collected and create node as necessary primaryType\n        if (currentPropName != null && currentPropName.getNamespaceUri().equals(NamespaceRegistry.NAMESPACE_JCR) && currentPropName.getLocalName().equals(\"primaryType\")) {\n            BufferedStringValue val = currentPropValues.get(0);\n            String s = null;\n            try {\n                s = val.retrieve();\n                state.nodeTypeName = new NameInfo(s).getRepoQualifiedName();\n            } catch (IOException e) {\n                throw new SAXException(new InvalidSerializedDataException(\"illegal node type name: \" + s, e));\n            } catch (RepositoryException e) {\n                throw new SAXException(new InvalidSerializedDataException(\"illegal node type name: \" + s, e));\n            }\n        } else if (currentPropName != null && currentPropName.getNamespaceUri().equals(NamespaceRegistry.NAMESPACE_JCR) && currentPropName.getLocalName().equals(\"mixinTypes\")) {\n            if (state.mixinNames == null) {\n                state.mixinNames = new ArrayList<String>(currentPropValues.size());\n            }\n            for (BufferedStringValue val : currentPropValues) {\n                String s = null;\n                try {\n                    s = val.retrieve();\n                    state.mixinNames.add(new NameInfo(s).getRepoQualifiedName());\n                } catch (IOException ioe) {\n                    throw new SAXException(\"error while retrieving value\", ioe);\n                } catch (RepositoryException e) {\n                    throw new SAXException(new InvalidSerializedDataException(\"illegal mixin type name: \" + s, e));\n                }\n            }\n        } else if (currentPropName != null && currentPropName.getNamespaceUri().equals(NamespaceRegistry.NAMESPACE_JCR) && currentPropName.getLocalName().equals(\"uuid\")) {\n            BufferedStringValue val = currentPropValues.get(0);\n            try {\n                state.uuid = val.retrieve();\n            } catch (IOException ioe) {\n                throw new SAXException(\"error while retrieving value\", ioe);\n            }\n        } else {\n            if (currentPropMultipleStatus == PropInfo.MultipleStatus.UNKNOWN && currentPropValues.size() != 1) {\n                currentPropMultipleStatus = PropInfo.MultipleStatus.MULTIPLE;\n            }\n            PropInfo prop = new PropInfo(currentPropName == null ? null : currentPropName.getRepoQualifiedName(), currentPropType, currentPropValues);\n            state.props.add(prop);\n        }\n        // reset temp fields\n        currentPropValues.clear();\n    } else if (namespaceURI.equals(NamespaceConstants.NAMESPACE_SV) && \"value\".equals(localName)) {\n        // sv:value element\n        currentPropValues.add(currentPropValue);\n        // reset temp fields\n        currentPropValue = null;\n    } else {\n        throw new SAXException(new InvalidSerializedDataException(\"invalid element in system view xml document: \" + localName));\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void endElement(String namespaceURI, String localName, String qName) throws SAXException {\n        ImportState state = stack.peek();\n    if (namespaceURI.equals(NamespaceConstants.NAMESPACE_SV) && \"node\".equals(localName)) {\n                if (!state.started) {\n                        processNode(state, true, true);\n            state.started = true;\n        } else {\n                        processNode(state, false, true);\n        }\n                stack.pop();\n    } else if (namespaceURI.equals(NamespaceConstants.NAMESPACE_SV) && \"property\".equals(localName)) {\n                if (currentPropName != null && currentPropName.getNamespaceUri().equals(NamespaceRegistry.NAMESPACE_JCR) && currentPropName.getLocalName().equals(\"primaryType\")) {\n            BufferedStringValue val = currentPropValues.get(0);\n            String s = null;\n            try {\n                s = val.retrieve();\n                state.nodeTypeName = new NameInfo(s).getRepoQualifiedName();\n            } catch (IOException e) {\n                throw new SAXException(new InvalidSerializedDataException(\"illegal node type name: \" + s, e));\n            } catch (RepositoryException e) {\n                throw new SAXException(new InvalidSerializedDataException(\"illegal node type name: \" + s, e));\n            }\n        } else if (currentPropName != null && currentPropName.getNamespaceUri().equals(NamespaceRegistry.NAMESPACE_JCR) && currentPropName.getLocalName().equals(\"mixinTypes\")) {\n            if (state.mixinNames == null) {\n                state.mixinNames = new ArrayList<String>(currentPropValues.size());\n            }\n            for (BufferedStringValue val : currentPropValues) {\n                String s = null;\n                try {\n                    s = val.retrieve();\n                    state.mixinNames.add(new NameInfo(s).getRepoQualifiedName());\n                } catch (IOException ioe) {\n                    throw new SAXException(\"error while retrieving value\", ioe);\n                } catch (RepositoryException e) {\n                    throw new SAXException(new InvalidSerializedDataException(\"illegal mixin type name: \" + s, e));\n                }\n            }\n        } else if (currentPropName != null && currentPropName.getNamespaceUri().equals(NamespaceRegistry.NAMESPACE_JCR) && currentPropName.getLocalName().equals(\"uuid\")) {\n            BufferedStringValue val = currentPropValues.get(0);\n            try {\n                state.uuid = val.retrieve();\n            } catch (IOException ioe) {\n                throw new SAXException(\"error while retrieving value\", ioe);\n            }\n        } else {\n            if (currentPropMultipleStatus == PropInfo.MultipleStatus.UNKNOWN && currentPropValues.size() != 1) {\n                currentPropMultipleStatus = PropInfo.MultipleStatus.MULTIPLE;\n            }\n            PropInfo prop = new PropInfo(currentPropName == null ? null : currentPropName.getRepoQualifiedName(), currentPropType, currentPropValues);\n            state.props.add(prop);\n        }\n                currentPropValues.clear();\n    } else if (namespaceURI.equals(NamespaceConstants.NAMESPACE_SV) && \"value\".equals(localName)) {\n                currentPropValues.add(currentPropValue);\n                currentPropValue = null;\n    } else {\n        throw new SAXException(new InvalidSerializedDataException(\"invalid element in system view xml document: \" + localName));\n    }\n}", "lc": 2.090909090909091, "pi": 0.9138755980861245, "ma": 3.8, "nbd": 2.0, "ml": 2.4166666666666665, "d": 1.4305555555555558, "mi": -1.1082452431289638, "fo": 2.5, "r": -0.02631578947368421, "e": 5.883805605020659}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2642_36fe017c", "label": 0, "code": "/**\n * Creates a new merge commit. The caller must acknowledge the commit either with\n * {@link #done(Commit, boolean, CommitInfo)} or {@link #canceled(Commit)},\n * depending on the result of the commit.\n *\n * @param base the base revision for the commit or <code>null</code> if the\n *             commit should use the current head revision as base.\n * @param numBranchCommits the number of branch commits to merge.\n * @return a new merge commit.\n */\n@Nonnull\nMergeCommit newMergeCommit(@Nullable Revision base, int numBranchCommits) {\n    if (base == null) {\n        base = headRevision;\n    }\n    backgroundOperationLock.readLock().lock();\n    boolean success = false;\n    MergeCommit c;\n    try {\n        c = new MergeCommit(this, base, commitQueue.createRevisions(numBranchCommits));\n        success = true;\n    } finally {\n        if (!success) {\n            backgroundOperationLock.readLock().unlock();\n        }\n    }\n    return c;\n}", "code_comment": "/**\n * Creates a new merge commit. The caller must acknowledge the commit either with\n * {@link #done(Commit, boolean, CommitInfo)} or {@link #canceled(Commit)},\n * depending on the result of the commit.\n *\n * @param base the base revision for the commit or <code>null</code> if the\n *             commit should use the current head revision as base.\n * @param numBranchCommits the number of branch commits to merge.\n * @return a new merge commit.\n */\n", "code_no_comment": "@Nonnull\nMergeCommit newMergeCommit(@Nullable Revision base, int numBranchCommits) {\n    if (base == null) {\n        base = headRevision;\n    }\n    backgroundOperationLock.readLock().lock();\n    boolean success = false;\n    MergeCommit c;\n    try {\n        c = new MergeCommit(this, base, commitQueue.createRevisions(numBranchCommits));\n        success = true;\n    } finally {\n        if (!success) {\n            backgroundOperationLock.readLock().unlock();\n        }\n    }\n    return c;\n}", "lc": 0.18181818181818182, "pi": 0.07177033492822962, "ma": -0.2, "nbd": 0.0, "ml": -0.08333333333333333, "d": -0.047619047619047616, "mi": -0.11627906976744183, "fo": -0.08333333333333333, "r": 0.02631578947368421, "e": -0.03599522829826595}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-238_24ce6788", "label": 1, "code": "@Override\npublic Value createValue(String value, int type) throws ValueFormatException {\n    if (value == null) {\n        throw new ValueFormatException();\n    }\n    try {\n        CoreValue cv;\n        switch(type) {\n            case PropertyType.NAME:\n                String oakName = namePathMapper.getOakName(value);\n                if (oakName == null) {\n                    throw new ValueFormatException(\"Invalid name: \" + value);\n                }\n                cv = factory.createValue(oakName, type);\n                break;\n            case PropertyType.PATH:\n                // TODO we special case identifier paths here for now\n                // eventually this should be done in the path mapper (OAK-23)\n                String oakValue;\n                if (value.startsWith(\"[\") && value.endsWith(\"]\")) {\n                    oakValue = value;\n                } else {\n                    oakValue = namePathMapper.getOakPath(value);\n                    if (oakValue == null) {\n                        throw new ValueFormatException(\"Invalid path: \" + value);\n                    }\n                }\n                cv = factory.createValue(oakValue, type);\n                break;\n            case PropertyType.DATE:\n                if (ISO8601.parse(value) == null) {\n                    throw new ValueFormatException(\"Invalid date \" + value);\n                }\n                cv = factory.createValue(value, type);\n                break;\n            case PropertyType.BINARY:\n                cv = factory.createValue(new ByteArrayInputStream(value.getBytes(\"UTF-8\")));\n                break;\n            default:\n                cv = factory.createValue(value, type);\n                break;\n        }\n        return new ValueImpl(cv, namePathMapper);\n    } catch (UnsupportedEncodingException e) {\n        throw new ValueFormatException(\"Encoding UTF-8 not supported (this should not happen!)\", e);\n    } catch (IOException e) {\n        throw new ValueFormatException(e);\n    } catch (NumberFormatException e) {\n        throw new ValueFormatException(\"Invalid value \" + value + \" for type \" + PropertyType.nameFromValue(type));\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic Value createValue(String value, int type) throws ValueFormatException {\n    if (value == null) {\n        throw new ValueFormatException();\n    }\n    try {\n        CoreValue cv;\n        switch(type) {\n            case PropertyType.NAME:\n                String oakName = namePathMapper.getOakName(value);\n                if (oakName == null) {\n                    throw new ValueFormatException(\"Invalid name: \" + value);\n                }\n                cv = factory.createValue(oakName, type);\n                break;\n            case PropertyType.PATH:\n                                                String oakValue;\n                if (value.startsWith(\"[\") && value.endsWith(\"]\")) {\n                    oakValue = value;\n                } else {\n                    oakValue = namePathMapper.getOakPath(value);\n                    if (oakValue == null) {\n                        throw new ValueFormatException(\"Invalid path: \" + value);\n                    }\n                }\n                cv = factory.createValue(oakValue, type);\n                break;\n            case PropertyType.DATE:\n                if (ISO8601.parse(value) == null) {\n                    throw new ValueFormatException(\"Invalid date \" + value);\n                }\n                cv = factory.createValue(value, type);\n                break;\n            case PropertyType.BINARY:\n                cv = factory.createValue(new ByteArrayInputStream(value.getBytes(\"UTF-8\")));\n                break;\n            default:\n                cv = factory.createValue(value, type);\n                break;\n        }\n        return new ValueImpl(cv, namePathMapper);\n    } catch (UnsupportedEncodingException e) {\n        throw new ValueFormatException(\"Encoding UTF-8 not supported (this should not happen!)\", e);\n    } catch (IOException e) {\n        throw new ValueFormatException(e);\n    } catch (NumberFormatException e) {\n        throw new ValueFormatException(\"Invalid value \" + value + \" for type \" + PropertyType.nameFromValue(type));\n    }\n}", "lc": 1.5909090909090908, "pi": 1.4976076555023925, "ma": 4.4, "nbd": 1.5, "ml": 1.0, "d": 0.613095238095238, "mi": -0.9250176180408736, "fo": 0.5, "r": -0.02631578947368421, "e": 1.3901580770272526}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2021_004db804", "label": 1, "code": "public Statement optimize() {\n    if (explain || measure || orderList.size() > 0) {\n        return this;\n    }\n    if (where == null) {\n        return this;\n    }\n    ArrayList<Expression> unionList = new ArrayList<Expression>();\n    addToUnionList(where, unionList);\n    if (unionList.size() == 1) {\n        return this;\n    }\n    Statement union = null;\n    for (int i = 0; i < unionList.size(); i++) {\n        Expression e = unionList.get(i);\n        Statement s = new Statement();\n        s.columnSelector = columnSelector;\n        s.selectors = selectors;\n        s.columnList = columnList;\n        s.where = e;\n        if (i == unionList.size() - 1) {\n            s.xpathQuery = xpathQuery;\n        }\n        if (union == null) {\n            union = s;\n        } else {\n            union = new UnionStatement(union.optimize(), s.optimize());\n        }\n    }\n    return union;\n}", "code_comment": NaN, "code_no_comment": "public Statement optimize() {\n    if (explain || measure || orderList.size() > 0) {\n        return this;\n    }\n    if (where == null) {\n        return this;\n    }\n    ArrayList<Expression> unionList = new ArrayList<Expression>();\n    addToUnionList(where, unionList);\n    if (unionList.size() == 1) {\n        return this;\n    }\n    Statement union = null;\n    for (int i = 0; i < unionList.size(); i++) {\n        Expression e = unionList.get(i);\n        Statement s = new Statement();\n        s.columnSelector = columnSelector;\n        s.selectors = selectors;\n        s.columnList = columnList;\n        s.where = e;\n        if (i == unionList.size() - 1) {\n            s.xpathQuery = xpathQuery;\n        }\n        if (union == null) {\n            union = s;\n        } else {\n            union = new UnionStatement(union.optimize(), s.optimize());\n        }\n    }\n    return union;\n}", "lc": 0.7727272727272727, "pi": 0.009569377990430419, "ma": 0.6, "nbd": 0.0, "ml": 0.8333333333333334, "d": 1.253968253968254, "mi": -0.5298097251585623, "fo": 0.16666666666666666, "r": 0.0, "e": 1.5113131976740832}
{"project_name": "Time", "project_version": 16, "label": 2, "code": "// -----------------------------------------------------------------------\n/**\n * Parses a datetime from the given text, at the given position, saving the\n * result into the fields of the given ReadWritableInstant. If the parse\n * succeeds, the return value is the new text position. Note that the parse\n * may succeed without fully reading the text and in this case those fields\n * that were read will be set.\n * <p>\n * Only those fields present in the string will be changed in the specified\n * instant. All other fields will remain unaltered. Thus if the string only\n * contains a year and a month, then the day and time will be retained from\n * the input instant. If this is not the behaviour you want, then reset the\n * fields before calling this method, or use {@link #parseDateTime(String)}\n * or {@link #parseMutableDateTime(String)}.\n * <p>\n * If it fails, the return value is negative, but the instant may still be\n * modified. To determine the position where the parse failed, apply the\n * one's complement operator (~) on the return value.\n * <p>\n * This parse method ignores the {@link #getDefaultYear() default year} and\n * parses using the year from the supplied instant as the default.\n * <p>\n * The parse will use the chronology of the instant.\n *\n * @param instant  an instant that will be modified, not null\n * @param text  the text to parse\n * @param position  position to start parsing from\n * @return new position, negative value means parse failed -\n *  apply complement operator (~) to get position of failure\n * @throws UnsupportedOperationException if parsing is not supported\n * @throws IllegalArgumentException if the instant is null\n * @throws IllegalArgumentException if any field is out of range\n */\npublic int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, position);\n    instant.setMillis(bucket.computeMillis(false, text));\n    if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n        int parsedOffset = bucket.getOffsetInteger();\n        DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n        chrono = chrono.withZone(parsedZone);\n    } else if (bucket.getZone() != null) {\n        chrono = chrono.withZone(bucket.getZone());\n    }\n    instant.setChronology(chrono);\n    if (iZone != null) {\n        instant.setZone(iZone);\n    }\n    return newPos;\n}", "code_comment": "/**\n * Parses a datetime from the given text, at the given position, saving the\n * result into the fields of the given ReadWritableInstant. If the parse\n * succeeds, the return value is the new text position. Note that the parse\n * may succeed without fully reading the text and in this case those fields\n * that were read will be set.\n * <p>\n * Only those fields present in the string will be changed in the specified\n * instant. All other fields will remain unaltered. Thus if the string only\n * contains a year and a month, then the day and time will be retained from\n * the input instant. If this is not the behaviour you want, then reset the\n * fields before calling this method, or use {@link #parseDateTime(String)}\n * or {@link #parseMutableDateTime(String)}.\n * <p>\n * If it fails, the return value is negative, but the instant may still be\n * modified. To determine the position where the parse failed, apply the\n * one's complement operator (~) on the return value.\n * <p>\n * This parse method ignores the {@link #getDefaultYear() default year} and\n * parses using the year from the supplied instant as the default.\n * <p>\n * The parse will use the chronology of the instant.\n *\n * @param instant  an instant that will be modified, not null\n * @param text  the text to parse\n * @param position  position to start parsing from\n * @return new position, negative value means parse failed -\n *  apply complement operator (~) to get position of failure\n * @throws UnsupportedOperationException if parsing is not supported\n * @throws IllegalArgumentException if the instant is null\n * @throws IllegalArgumentException if any field is out of range\n */\n", "code_no_comment": "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, position);\n    instant.setMillis(bucket.computeMillis(false, text));\n    if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n        int parsedOffset = bucket.getOffsetInteger();\n        DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n        chrono = chrono.withZone(parsedZone);\n    } else if (bucket.getZone() != null) {\n        chrono = chrono.withZone(bucket.getZone());\n    }\n    instant.setChronology(chrono);\n    if (iZone != null) {\n        instant.setZone(iZone);\n    }\n    return newPos;\n}", "lc": 0.5, "pi": -0.39234449760765566, "ma": 0.4, "nbd": 0.0, "ml": 0.4166666666666667, "d": 0.4384920634920635, "mi": -0.4568005637773078, "fo": 1.0, "r": -0.02631578947368421, "e": 0.868249165816635}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-93_0be7e8f0", "label": 1, "code": "@Override\npublic boolean removeChild(String name) {\n    boolean result = builder.removeNode(name);\n    if (result) {\n        listener.removeChild(this, name);\n    }\n    return result;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean removeChild(String name) {\n    boolean result = builder.removeNode(name);\n    if (result) {\n        listener.removeChild(this, name);\n    }\n    return result;\n}", "lc": -0.2727272727272727, "pi": -0.16267942583732073, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": -0.3650793650793651, "mi": 0.44214235377026073, "fo": -0.3333333333333333, "r": 0.7894736842105263, "e": -0.16279340490885932}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-6447_020c451a", "label": 1, "code": "/**\n * Ends the current block and returns back to the {@link ChoiceDefinition choice()} DSL.\n *\n * @return the builder\n */\npublic ChoiceDefinition endChoice() {\n    // are we already a choice?\n    ProcessorDefinition<?> def = this;\n    if (def instanceof ChoiceDefinition) {\n        return (ChoiceDefinition) def;\n    }\n    // okay end this and get back to the choice\n    def = end();\n    if (def instanceof WhenDefinition) {\n        return (ChoiceDefinition) def.getParent();\n    } else if (def instanceof OtherwiseDefinition) {\n        return (ChoiceDefinition) def.getParent();\n    } else {\n        return (ChoiceDefinition) def;\n    }\n}", "code_comment": "/**\n * Ends the current block and returns back to the {@link ChoiceDefinition choice()} DSL.\n *\n * @return the builder\n */\n", "code_no_comment": "public ChoiceDefinition endChoice() {\n        ProcessorDefinition<?> def = this;\n    if (def instanceof ChoiceDefinition) {\n        return (ChoiceDefinition) def;\n    }\n        def = end();\n    if (def instanceof WhenDefinition) {\n        return (ChoiceDefinition) def.getParent();\n    } else if (def instanceof OtherwiseDefinition) {\n        return (ChoiceDefinition) def.getParent();\n    } else {\n        return (ChoiceDefinition) def;\n    }\n}", "lc": 0.0, "pi": -0.20574162679425848, "ma": 0.0, "nbd": 0.0, "ml": -0.08333333333333333, "d": -0.3650793650793651, "mi": 0.09880197322057772, "fo": -0.25, "r": 0.31578947368421056, "e": -0.16279340490885932}
{"project_name": "Closure", "project_version": 170, "label": 2, "code": "/**\n * Computes the number of uses of the variable varName and store it in\n * numUseWithinUseCfgNode.\n */\nprivate void getNumUseInUseCfgNode(final Node cfgNode) {\n    numUsesWithinCfgNode = 0;\n    AbstractCfgNodeTraversalCallback gatherCb = new AbstractCfgNodeTraversalCallback() {\n\n        @Override\n        public void visit(NodeTraversal t, Node n, Node parent) {\n            if (n.isName() && n.getString().equals(varName) && // and remove this special case.\n            !(parent.isAssign() && (parent.getFirstChild() == n))) {\n                // Don't count lhs of top-level assignment chain\n                numUsesWithinCfgNode++;\n            }\n        }\n    };\n    NodeTraversal.traverse(compiler, cfgNode, gatherCb);\n}", "code_comment": "/**\n * Computes the number of uses of the variable varName and store it in\n * numUseWithinUseCfgNode.\n */\n", "code_no_comment": "private void getNumUseInUseCfgNode(final Node cfgNode) {\n    numUsesWithinCfgNode = 0;\n    AbstractCfgNodeTraversalCallback gatherCb = new AbstractCfgNodeTraversalCallback() {\n\n        @Override\n        public void visit(NodeTraversal t, Node n, Node parent) {\n            if (n.isName() && n.getString().equals(varName) &&             !(parent.isAssign() && (parent.getFirstChild() == n))) {\n                                numUsesWithinCfgNode++;\n            }\n        }\n    };\n    NodeTraversal.traverse(compiler, cfgNode, gatherCb);\n}", "lc": -0.045454545454545456, "pi": 0.8421052631578947, "ma": -0.4, "nbd": 0.0, "ml": 0.4166666666666667, "d": 0.24801587301587297, "mi": 0.020436927413671434, "fo": 0.0, "r": 1.4736842105263157, "e": 0.11501184281046316}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4997_ee02c883", "label": 1, "code": "/**\n *  Gets a URL for the listener interface on a behavior (e.g. IBehaviorListener on\n *  AjaxPagingNavigationBehavior).\n *\n *  @param behaviour\n *             The behavior that the URL should point to\n *  @param listener\n *             The listener interface that the URL should call\n *  @param parameters\n *             The parameters that should be rendered into the urls\n *  @return The URL\n */\npublic final CharSequence urlFor(final Behavior behaviour, final RequestListenerInterface listener, final PageParameters parameters) {\n    int id = getBehaviorId(behaviour);\n    Page page = getPage();\n    PageAndComponentProvider provider = new PageAndComponentProvider(page, this, parameters);\n    IRequestHandler handler;\n    if (page.isBookmarkable()) {\n        handler = new BookmarkableListenerInterfaceRequestHandler(provider, listener, id);\n    } else {\n        handler = new ListenerInterfaceRequestHandler(provider, listener, id);\n    }\n    return getRequestCycle().urlFor(handler);\n}", "code_comment": "/**\n *  Gets a URL for the listener interface on a behavior (e.g. IBehaviorListener on\n *  AjaxPagingNavigationBehavior).\n *\n *  @param behaviour\n *             The behavior that the URL should point to\n *  @param listener\n *             The listener interface that the URL should call\n *  @param parameters\n *             The parameters that should be rendered into the urls\n *  @return The URL\n */\n", "code_no_comment": "public final CharSequence urlFor(final Behavior behaviour, final RequestListenerInterface listener, final PageParameters parameters) {\n    int id = getBehaviorId(behaviour);\n    Page page = getPage();\n    PageAndComponentProvider provider = new PageAndComponentProvider(page, this, parameters);\n    IRequestHandler handler;\n    if (page.isBookmarkable()) {\n        handler = new BookmarkableListenerInterfaceRequestHandler(provider, listener, id);\n    } else {\n        handler = new ListenerInterfaceRequestHandler(provider, listener, id);\n    }\n    return getRequestCycle().urlFor(handler);\n}", "lc": -0.09090909090909091, "pi": -0.32535885167464124, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": -0.3650793650793651, "mi": 0.06074700493305146, "fo": -0.08333333333333333, "r": 0.1842105263157895, "e": -0.16279340490885932}
{"project_name": "maven", "project_version": "remotes/origin/bugs-dot-jar_MNG-3616_912a565f", "label": 1, "code": "// ----------------------------------------------------------------------\n// Field validation\n// ----------------------------------------------------------------------\nprivate boolean validateStringNotEmpty(SettingsProblemCollector problems, String fieldName, String string) {\n    return validateStringNotEmpty(problems, fieldName, string, null);\n}", "code_comment": NaN, "code_no_comment": "private boolean validateStringNotEmpty(SettingsProblemCollector problems, String fieldName, String string) {\n    return validateStringNotEmpty(problems, fieldName, string, null);\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.9323467230443969, "fo": -0.4166666666666667, "r": 2.6052631578947367, "e": -0.16279340490885932}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3278_60d07288", "label": 1, "code": "/**\n *  The localizer will be ask for the property to display Depending on if null is allowed or not\n *  it will ask for:\n *\n *  <ul>\n *  <li>nullValid: when null is valid and by default it will show an empty string as a choice.</li>\n *  <li>null: when null is not a valid choice and it will make a choice with \"Choose One\"</li>\n *  </ul>\n *\n *  The choice for null is valid will always be returned. The choice when null is not valid will\n *  only be returned if the selected object is null.\n *\n *  @see org.apache.wicket.markup.html.form.AbstractChoice#getDefaultChoice(Object)\n */\n@Override\nprotected CharSequence getDefaultChoice(final Object selected) {\n    // Is null a valid selection value?\n    if (isNullValid()) {\n        // Null is valid, so look up the value for it\n        String option = getLocalizer().getStringIgnoreSettings(getNullValidKey(), this, null, null);\n        if (Strings.isEmpty(option)) {\n            option = getLocalizer().getString(\"nullValid\", this, \"\");\n        }\n        // The <option> tag buffer\n        final AppendingStringBuffer buffer = new AppendingStringBuffer(64 + option.length());\n        // Add option tag\n        buffer.append(\"\\n<option\");\n        // If null is selected, indicate that\n        if (selected == null) {\n            buffer.append(\" selected=\\\"selected\\\"\");\n        }\n        // Add body of option tag\n        buffer.append(\" value=\\\"\\\">\").append(option).append(\"</option>\");\n        return buffer;\n    } else {\n        // Null is not valid. Is it selected anyway?\n        if ((selected == null) || getNoSelectionValue().equals(selected) || selected.equals(EMPTY_STRING)) {\n            // Force the user to pick a non-null value\n            String option = getLocalizer().getStringIgnoreSettings(getNullKey(), this, null, null);\n            if (Strings.isEmpty(option)) {\n                option = getLocalizer().getString(\"null\", this, CHOOSE_ONE);\n            }\n            return \"\\n<option selected=\\\"selected\\\" value=\\\"\\\">\" + option + \"</option>\";\n        }\n    }\n    return \"\";\n}", "code_comment": "/**\n *  The localizer will be ask for the property to display Depending on if null is allowed or not\n *  it will ask for:\n *\n *  <ul>\n *  <li>nullValid: when null is valid and by default it will show an empty string as a choice.</li>\n *  <li>null: when null is not a valid choice and it will make a choice with \"Choose One\"</li>\n *  </ul>\n *\n *  The choice for null is valid will always be returned. The choice when null is not valid will\n *  only be returned if the selected object is null.\n *\n *  @see org.apache.wicket.markup.html.form.AbstractChoice#getDefaultChoice(Object)\n */\n", "code_no_comment": "@Override\nprotected CharSequence getDefaultChoice(final Object selected) {\n        if (isNullValid()) {\n                String option = getLocalizer().getStringIgnoreSettings(getNullValidKey(), this, null, null);\n        if (Strings.isEmpty(option)) {\n            option = getLocalizer().getString(\"nullValid\", this, \"\");\n        }\n                final AppendingStringBuffer buffer = new AppendingStringBuffer(64 + option.length());\n                buffer.append(\"\\n<option\");\n                if (selected == null) {\n            buffer.append(\" selected=\\\"selected\\\"\");\n        }\n                buffer.append(\" value=\\\"\\\">\").append(option).append(\"</option>\");\n        return buffer;\n    } else {\n                if ((selected == null) || getNoSelectionValue().equals(selected) || selected.equals(EMPTY_STRING)) {\n                        String option = getLocalizer().getStringIgnoreSettings(getNullKey(), this, null, null);\n            if (Strings.isEmpty(option)) {\n                option = getLocalizer().getString(\"null\", this, CHOOSE_ONE);\n            }\n            return \"\\n<option selected=\\\"selected\\\" value=\\\"\\\">\" + option + \"</option>\";\n        }\n    }\n    return \"\";\n}", "lc": 0.5, "pi": 0.5167464114832536, "ma": 0.4, "nbd": 0.5, "ml": 0.6666666666666666, "d": 0.4880952380952381, "mi": -0.41733615221987286, "fo": 1.3333333333333333, "r": -0.02631578947368421, "e": 0.6743198308005278}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5082_217fbb3b", "label": 1, "code": "@Override\npublic void component(final Component component, final IVisit<Void> visit) {\n    if (component.isVisibleInHierarchy()) {\n        component.renderHead(header);\n    } else {\n        visit.dontGoDeeper();\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void component(final Component component, final IVisit<Void> visit) {\n    if (component.isVisibleInHierarchy()) {\n        component.renderHead(header);\n    } else {\n        visit.dontGoDeeper();\n    }\n}", "lc": -0.2727272727272727, "pi": 0.06220095693779899, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": -0.3650793650793651, "mi": 0.43622269203664527, "fo": -0.25, "r": 0.21052631578947367, "e": -0.16279340490885932}
{"project_name": "Math", "project_version": 98, "label": 1, "code": "/**\n * Returns the result of multiplying this by the vector <code>v</code>.\n *\n * @param v the vector to operate on\n * @return this*v\n * @throws IllegalArgumentException if columnDimension != v.size()\n */\npublic BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length != this.getColumnDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n    final BigDecimal[] out = new BigDecimal[v.length];\n    for (int row = 0; row < nRows; row++) {\n        BigDecimal sum = ZERO;\n        for (int i = 0; i < nCols; i++) {\n            sum = sum.add(data[row][i].multiply(v[i]));\n        }\n        out[row] = sum;\n    }\n    return out;\n}", "code_comment": "/**\n * Returns the result of multiplying this by the vector <code>v</code>.\n *\n * @param v the vector to operate on\n * @return this*v\n * @throws IllegalArgumentException if columnDimension != v.size()\n */\n", "code_no_comment": "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length != this.getColumnDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n    final BigDecimal[] out = new BigDecimal[v.length];\n    for (int row = 0; row < nRows; row++) {\n        BigDecimal sum = ZERO;\n        for (int i = 0; i < nCols; i++) {\n            sum = sum.add(data[row][i].multiply(v[i]));\n        }\n        out[row] = sum;\n    }\n    return out;\n}", "lc": 0.09090909090909091, "pi": 0.03827751196172231, "ma": 0.2, "nbd": 0.0, "ml": 0.3333333333333333, "d": 0.5476190476190476, "mi": -0.14193093727977435, "fo": -0.08333333333333333, "r": 1.368421052631579, "e": 0.4108988433809926}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-776_dc9f23d9", "label": 3, "code": "@Override\npublic void init(SortedKeyValueIterator<Key, Value> source, Map<String, String> options, IteratorEnvironment env) throws IOException {\n    super.init(source, options, env);\n    if (options == null)\n        throw new IllegalArgumentException(\"start and/or end must be set for \" + TimestampFilter.class.getName());\n    hasStart = false;\n    hasEnd = false;\n    startInclusive = true;\n    endInclusive = true;\n    if (options.containsKey(START))\n        hasStart = true;\n    if (options.containsKey(END))\n        hasEnd = true;\n    if (!hasStart && !hasEnd)\n        throw new IllegalArgumentException(\"must have either start or end for \" + TimestampFilter.class.getName());\n    try {\n        if (hasStart)\n            start = dateParser.parse(options.get(START)).getTime();\n        if (hasEnd)\n            end = dateParser.parse(options.get(END)).getTime();\n    } catch (Exception e) {\n        throw new IllegalArgumentException(e);\n    }\n    if (options.get(START_INCL) != null)\n        startInclusive = Boolean.parseBoolean(options.get(START_INCL));\n    if (options.get(END_INCL) != null)\n        endInclusive = Boolean.parseBoolean(options.get(END_INCL));\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void init(SortedKeyValueIterator<Key, Value> source, Map<String, String> options, IteratorEnvironment env) throws IOException {\n    super.init(source, options, env);\n    if (options == null)\n        throw new IllegalArgumentException(\"start and/or end must be set for \" + TimestampFilter.class.getName());\n    hasStart = false;\n    hasEnd = false;\n    startInclusive = true;\n    endInclusive = true;\n    if (options.containsKey(START))\n        hasStart = true;\n    if (options.containsKey(END))\n        hasEnd = true;\n    if (!hasStart && !hasEnd)\n        throw new IllegalArgumentException(\"must have either start or end for \" + TimestampFilter.class.getName());\n    try {\n        if (hasStart)\n            start = dateParser.parse(options.get(START)).getTime();\n        if (hasEnd)\n            end = dateParser.parse(options.get(END)).getTime();\n    } catch (Exception e) {\n        throw new IllegalArgumentException(e);\n    }\n    if (options.get(START_INCL) != null)\n        startInclusive = Boolean.parseBoolean(options.get(START_INCL));\n    if (options.get(END_INCL) != null)\n        endInclusive = Boolean.parseBoolean(options.get(END_INCL));\n}", "lc": 0.6363636363636364, "pi": 0.0334928229665071, "ma": 1.8, "nbd": -0.5, "ml": 0.9166666666666666, "d": 0.9444444444444444, "mi": -0.5625088090204368, "fo": 0.9166666666666666, "r": -0.02631578947368421, "e": 1.6187709986572383}
{"project_name": "Closure", "project_version": 135, "label": 2, "code": "/**\n * Replaces references to \"this\" with references to name.  Do not\n * traverse function boundaries.\n */\nprivate void replaceReferencesToThis(Node node, String name) {\n    if (NodeUtil.isFunction(node)) {\n        return;\n    }\n    for (Node child : node.children()) {\n        if (NodeUtil.isThis(child)) {\n            Node newName = Node.newString(Token.NAME, name);\n            node.replaceChild(child, newName);\n        } else {\n            replaceReferencesToThis(child, name);\n        }\n    }\n}", "code_comment": "/**\n * Replaces references to \"this\" with references to name.  Do not\n * traverse function boundaries.\n */\n", "code_no_comment": "private void replaceReferencesToThis(Node node, String name) {\n    if (NodeUtil.isFunction(node)) {\n        return;\n    }\n    for (Node child : node.children()) {\n        if (NodeUtil.isThis(child)) {\n            Node newName = Node.newString(Token.NAME, name);\n            node.replaceChild(child, newName);\n        } else {\n            replaceReferencesToThis(child, name);\n        }\n    }\n}", "lc": -0.045454545454545456, "pi": 0.48803827751196155, "ma": 0.0, "nbd": 0.0, "ml": 0.08333333333333333, "d": -0.3650793650793651, "mi": 0.07061310782241001, "fo": 0.0, "r": 0.21052631578947367, "e": -0.16279340490885932}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-217_46f62443", "label": 1, "code": "@Override\npublic Iterable<Entry<String, String>> getProperties(String tableName) throws TableNotFoundException {\n    return acu.tables.get(tableName).settings.entrySet();\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic Iterable<Entry<String, String>> getProperties(String tableName) throws TableNotFoundException {\n    return acu.tables.get(tableName).settings.entrySet();\n}", "lc": -0.45454545454545453, "pi": -0.6028708133971293, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.7398167723749118, "fo": -0.3333333333333333, "r": 0.0, "e": -0.16279340490885932}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-3475_7651b777", "label": 1, "code": "public int start() throws IOException {\n    if (configError)\n        return 1;\n    String input;\n    if (isVerbose())\n        printInfo();\n    if (execFile != null) {\n        java.util.Scanner scanner = new java.util.Scanner(new File(execFile), UTF_8.name());\n        try {\n            while (scanner.hasNextLine() && !hasExited()) {\n                execCommand(scanner.nextLine(), true, isVerbose());\n            }\n        } finally {\n            scanner.close();\n        }\n    } else if (execCommand != null) {\n        for (String command : execCommand.split(\"\\n\")) {\n            execCommand(command, true, isVerbose());\n        }\n        return exitCode;\n    }\n    while (true) {\n        if (hasExited())\n            return exitCode;\n        reader.setDefaultPrompt(getDefaultPrompt());\n        input = reader.readLine();\n        if (input == null) {\n            reader.printNewline();\n            return exitCode;\n        }\n        // user canceled\n        execCommand(input, false, false);\n    }\n}", "code_comment": NaN, "code_no_comment": "public int start() throws IOException {\n    if (configError)\n        return 1;\n    String input;\n    if (isVerbose())\n        printInfo();\n    if (execFile != null) {\n        java.util.Scanner scanner = new java.util.Scanner(new File(execFile), UTF_8.name());\n        try {\n            while (scanner.hasNextLine() && !hasExited()) {\n                execCommand(scanner.nextLine(), true, isVerbose());\n            }\n        } finally {\n            scanner.close();\n        }\n    } else if (execCommand != null) {\n        for (String command : execCommand.split(\"\\n\")) {\n            execCommand(command, true, isVerbose());\n        }\n        return exitCode;\n    }\n    while (true) {\n        if (hasExited())\n            return exitCode;\n        reader.setDefaultPrompt(getDefaultPrompt());\n        input = reader.readLine();\n        if (input == null) {\n            reader.printNewline();\n            return exitCode;\n        }\n                execCommand(input, false, false);\n    }\n}", "lc": 0.8636363636363636, "pi": 0.29186602870813394, "ma": 1.2, "nbd": 0.5, "ml": 0.9166666666666666, "d": 0.3591269841269841, "mi": -0.5486962649753347, "fo": 1.0, "r": -0.02631578947368421, "e": 0.4504094558070111}
{"project_name": "Lang", "project_version": 43, "label": 1, "code": "/**\n * Consume a quoted string, adding it to <code>appendTo</code> if\n * specified.\n *\n * @param pattern pattern to parse\n * @param pos current parse position\n * @param appendTo optional StringBuffer to append\n * @param escapingOn whether to process escaped quotes\n * @return <code>appendTo</code>\n */\nprivate StringBuffer appendQuotedString(String pattern, ParsePosition pos, StringBuffer appendTo, boolean escapingOn) {\n    int start = pos.getIndex();\n    char[] c = pattern.toCharArray();\n    if (escapingOn && c[start] == QUOTE) {\n        return appendTo == null ? null : appendTo.append(QUOTE);\n    }\n    int lastHold = start;\n    for (int i = pos.getIndex(); i < pattern.length(); i++) {\n        if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {\n            appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(QUOTE);\n            pos.setIndex(i + ESCAPED_QUOTE.length());\n            lastHold = pos.getIndex();\n            continue;\n        }\n        switch(c[pos.getIndex()]) {\n            case QUOTE:\n                next(pos);\n                return appendTo == null ? null : appendTo.append(c, lastHold, pos.getIndex() - lastHold);\n            default:\n                next(pos);\n        }\n    }\n    throw new IllegalArgumentException(\"Unterminated quoted string at position \" + start);\n}", "code_comment": "/**\n * Consume a quoted string, adding it to <code>appendTo</code> if\n * specified.\n *\n * @param pattern pattern to parse\n * @param pos current parse position\n * @param appendTo optional StringBuffer to append\n * @param escapingOn whether to process escaped quotes\n * @return <code>appendTo</code>\n */\n", "code_no_comment": "private StringBuffer appendQuotedString(String pattern, ParsePosition pos, StringBuffer appendTo, boolean escapingOn) {\n    int start = pos.getIndex();\n    char[] c = pattern.toCharArray();\n    if (escapingOn && c[start] == QUOTE) {\n        return appendTo == null ? null : appendTo.append(QUOTE);\n    }\n    int lastHold = start;\n    for (int i = pos.getIndex(); i < pattern.length(); i++) {\n        if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {\n            appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(QUOTE);\n            pos.setIndex(i + ESCAPED_QUOTE.length());\n            lastHold = pos.getIndex();\n            continue;\n        }\n        switch(c[pos.getIndex()]) {\n            case QUOTE:\n                next(pos);\n                return appendTo == null ? null : appendTo.append(c, lastHold, pos.getIndex() - lastHold);\n            default:\n                next(pos);\n        }\n    }\n    throw new IllegalArgumentException(\"Unterminated quoted string at position \" + start);\n}", "lc": 0.45454545454545453, "pi": 0.8468899521531099, "ma": 1.2, "nbd": 0.5, "ml": 0.6666666666666666, "d": 1.4444444444444442, "mi": -0.4432699083861872, "fo": 1.0, "r": -0.02631578947368421, "e": 1.8511182955573608}
{"project_name": "Math", "project_version": 100, "label": 0, "code": "/**\n * Guess the errors in unbound estimated parameters.\n * <p>Guessing is covariance-based, it only gives rough order of magnitude.</p>\n * @param problem estimation problem\n * @return errors in estimated parameters\n * @exception EstimationException if the covariances matrix cannot be computed\n * or the number of degrees of freedom is not positive (number of measurements\n * lesser or equal to number of parameters)\n */\npublic double[] guessParametersErrors(EstimationProblem problem) throws EstimationException {\n    int m = problem.getMeasurements().length;\n    int p = problem.getAllParameters().length;\n    if (m <= p) {\n        throw new EstimationException(\"no degrees of freedom ({0} measurements, {1} parameters)\", new Object[] { new Integer(m), new Integer(p) });\n    }\n    double[] errors = new double[problem.getAllParameters().length];\n    final double c = Math.sqrt(getChiSquare(problem) / (m - p));\n    double[][] covar = getCovariances(problem);\n    for (int i = 0; i < errors.length; ++i) {\n        errors[i] = Math.sqrt(covar[i][i]) * c;\n    }\n    return errors;\n}", "code_comment": "/**\n * Guess the errors in unbound estimated parameters.\n * <p>Guessing is covariance-based, it only gives rough order of magnitude.</p>\n * @param problem estimation problem\n * @return errors in estimated parameters\n * @exception EstimationException if the covariances matrix cannot be computed\n * or the number of degrees of freedom is not positive (number of measurements\n * lesser or equal to number of parameters)\n */\n", "code_no_comment": "public double[] guessParametersErrors(EstimationProblem problem) throws EstimationException {\n    int m = problem.getMeasurements().length;\n    int p = problem.getAllParameters().length;\n    if (m <= p) {\n        throw new EstimationException(\"no degrees of freedom ({0} measurements, {1} parameters)\", new Object[] { new Integer(m), new Integer(p) });\n    }\n    double[] errors = new double[problem.getAllParameters().length];\n    final double c = Math.sqrt(getChiSquare(problem) / (m - p));\n    double[][] covar = getCovariances(problem);\n    for (int i = 0; i < errors.length; ++i) {\n        errors[i] = Math.sqrt(covar[i][i]) * c;\n    }\n    return errors;\n}", "lc": 0.0, "pi": -0.4066985645933015, "ma": 0.0, "nbd": -0.5, "ml": 0.08333333333333333, "d": 1.0138888888888888, "mi": -0.09485553206483423, "fo": 0.08333333333333333, "r": -0.02631578947368421, "e": 0.834072716585121}
{"project_name": "Compress", "project_version": 4, "label": 1, "code": "/**\n * Closes the CPIO output stream as well as the stream being filtered.\n *\n * @throws IOException\n *             if an I/O error has occurred or if a CPIO file error has\n *             occurred\n */\npublic void close() throws IOException {\n    if (!this.closed) {\n        this.finish();\n        out.close();\n        this.closed = true;\n    }\n}", "code_comment": "/**\n * Closes the CPIO output stream as well as the stream being filtered.\n *\n * @throws IOException\n *             if an I/O error has occurred or if a CPIO file error has\n *             occurred\n */\n", "code_no_comment": "public void close() throws IOException {\n    if (!this.closed) {\n        this.finish();\n        out.close();\n        this.closed = true;\n    }\n}", "lc": -0.3181818181818182, "pi": 0.1626794258373205, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": -0.10912698412698414, "mi": 0.5554615926708948, "fo": -0.3333333333333333, "r": 2.5789473684210527, "e": -0.14212525140759438}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4715_4fc82e35", "label": 1, "code": "/**\n *  @see org.apache.wicket.Component#onComponentTag(ComponentTag)\n */\n@Override\nprotected void onComponentTag(final ComponentTag tag) {\n    super.onComponentTag(tag);\n    checkComponentTag(tag, \"form\");\n    if (isRootForm()) {\n        String method = getMethod().toLowerCase(Locale.ENGLISH);\n        tag.put(\"method\", method);\n        String url = getActionUrl().toString();\n        if (encodeUrlInHiddenFields()) {\n            int i = url.indexOf('?');\n            String action = (i > -1) ? url.substring(0, i) : \"\";\n            tag.put(\"action\", action);\n        // alternatively, we could just put an empty string here, so\n        // that mounted paths stay in good order. I decided against this\n        // as I'm not sure whether that could have side effects with\n        // other encoders\n        } else {\n            tag.put(\"action\", url);\n        }\n        if (isMultiPart()) {\n            if (METHOD_GET.equalsIgnoreCase(method)) {\n                log.warn(\"Form with id '{}' is multipart. It should use method 'POST'!\", getId());\n                tag.put(\"method\", METHOD_POST.toLowerCase(Locale.ENGLISH));\n            }\n            tag.put(\"enctype\", \"multipart/form-data\");\n            // \n            // require the application-encoding for multipart/form-data to be sure to\n            // get multipart-uploaded characters with the proper encoding on the following\n            // request.\n            // \n            // for details see: http://stackoverflow.com/questions/546365\n            // \n            tag.put(\"accept-charset\", getApplication().getRequestCycleSettings().getResponseRequestEncoding());\n        } else {\n            // sanity check\n            String enctype = (String) tag.getAttributes().get(\"enctype\");\n            if (\"multipart/form-data\".equalsIgnoreCase(enctype)) {\n                // though not set explicitly in Java, this is a multipart\n                // form\n                setMultiPart(true);\n            }\n        }\n    } else {\n        tag.setName(\"div\");\n        tag.remove(\"method\");\n        tag.remove(\"action\");\n        tag.remove(\"enctype\");\n    }\n}", "code_comment": "/**\n *  @see org.apache.wicket.Component#onComponentTag(ComponentTag)\n */\n", "code_no_comment": "@Override\nprotected void onComponentTag(final ComponentTag tag) {\n    super.onComponentTag(tag);\n    checkComponentTag(tag, \"form\");\n    if (isRootForm()) {\n        String method = getMethod().toLowerCase(Locale.ENGLISH);\n        tag.put(\"method\", method);\n        String url = getActionUrl().toString();\n        if (encodeUrlInHiddenFields()) {\n            int i = url.indexOf('?');\n            String action = (i > -1) ? url.substring(0, i) : \"\";\n            tag.put(\"action\", action);\n                                        } else {\n            tag.put(\"action\", url);\n        }\n        if (isMultiPart()) {\n            if (METHOD_GET.equalsIgnoreCase(method)) {\n                log.warn(\"Form with id '{}' is multipart. It should use method 'POST'!\", getId());\n                tag.put(\"method\", METHOD_POST.toLowerCase(Locale.ENGLISH));\n            }\n            tag.put(\"enctype\", \"multipart/form-data\");\n                                                                                                tag.put(\"accept-charset\", getApplication().getRequestCycleSettings().getResponseRequestEncoding());\n        } else {\n                        String enctype = (String) tag.getAttributes().get(\"enctype\");\n            if (\"multipart/form-data\".equalsIgnoreCase(enctype)) {\n                                                setMultiPart(true);\n            }\n        }\n    } else {\n        tag.setName(\"div\");\n        tag.remove(\"method\");\n        tag.remove(\"action\");\n        tag.remove(\"enctype\");\n    }\n}", "lc": 0.9545454545454546, "pi": 0.5885167464114831, "ma": 0.6, "nbd": 0.5, "ml": 0.75, "d": 0.03174603174603173, "mi": -0.6250880902043691, "fo": 2.1666666666666665, "r": -0.02631578947368421, "e": 0.3759340260368942}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1081_4ce4e3c9", "label": 3, "code": "/**\n * Set a property\n *\n * @param propertyState\n * @return the set property\n */\n@Nonnull\npublic PropertyDelegate setProperty(PropertyState propertyState, boolean exactTypeMatch, boolean setProtected) throws RepositoryException {\n    Tree tree = getTree();\n    String name = propertyState.getName();\n    Type<?> type = propertyState.getType();\n    PropertyState old = tree.getProperty(name);\n    if (old != null && old.isArray() && !propertyState.isArray()) {\n        throw new ValueFormatException(\"Can not assign a single value to multi-valued property: \" + propertyState);\n    }\n    if (old != null && !old.isArray() && propertyState.isArray()) {\n        throw new ValueFormatException(\"Can not assign multiple values to single valued property: \" + propertyState);\n    }\n    Tree definition = findMatchingPropertyDefinition(getNodeTypes(tree), name, type, exactTypeMatch);\n    if (definition == null) {\n        throw new ConstraintViolationException(\"No matching property definition: \" + propertyState);\n    } else if (!setProtected && TreeUtil.getBoolean(definition, JCR_PROTECTED)) {\n        throw new ConstraintViolationException(\"Property is protected: \" + propertyState);\n    }\n    Type<?> requiredType = Type.fromString(TreeUtil.getString(definition, JCR_REQUIREDTYPE));\n    if (requiredType != Type.UNDEFINED) {\n        if (TreeUtil.getBoolean(definition, JCR_MULTIPLE)) {\n            requiredType = requiredType.getArrayType();\n        }\n        propertyState = PropertyStates.convert(propertyState, requiredType);\n    }\n    tree.setProperty(propertyState);\n    return new PropertyDelegate(sessionDelegate, tree, name);\n}", "code_comment": "/**\n * Set a property\n *\n * @param propertyState\n * @return the set property\n */\n", "code_no_comment": "@Nonnull\npublic PropertyDelegate setProperty(PropertyState propertyState, boolean exactTypeMatch, boolean setProtected) throws RepositoryException {\n    Tree tree = getTree();\n    String name = propertyState.getName();\n    Type<?> type = propertyState.getType();\n    PropertyState old = tree.getProperty(name);\n    if (old != null && old.isArray() && !propertyState.isArray()) {\n        throw new ValueFormatException(\"Can not assign a single value to multi-valued property: \" + propertyState);\n    }\n    if (old != null && !old.isArray() && propertyState.isArray()) {\n        throw new ValueFormatException(\"Can not assign multiple values to single valued property: \" + propertyState);\n    }\n    Tree definition = findMatchingPropertyDefinition(getNodeTypes(tree), name, type, exactTypeMatch);\n    if (definition == null) {\n        throw new ConstraintViolationException(\"No matching property definition: \" + propertyState);\n    } else if (!setProtected && TreeUtil.getBoolean(definition, JCR_PROTECTED)) {\n        throw new ConstraintViolationException(\"Property is protected: \" + propertyState);\n    }\n    Type<?> requiredType = Type.fromString(TreeUtil.getString(definition, JCR_REQUIREDTYPE));\n    if (requiredType != Type.UNDEFINED) {\n        if (TreeUtil.getBoolean(definition, JCR_MULTIPLE)) {\n            requiredType = requiredType.getArrayType();\n        }\n        propertyState = PropertyStates.convert(propertyState, requiredType);\n    }\n    tree.setProperty(propertyState);\n    return new PropertyDelegate(sessionDelegate, tree, name);\n}", "lc": 0.6363636363636364, "pi": -0.13875598086124405, "ma": 1.4, "nbd": 0.0, "ml": 1.1666666666666667, "d": 0.9067460317460317, "mi": -0.5684284707540518, "fo": 0.9166666666666666, "r": -0.02631578947368421, "e": 1.8050333385199653}
{"project_name": "Lang", "project_version": 34, "label": 1, "code": "/**\n * <p>\n * Returns <code>true</code> if the registry contains the given object.\n * Used by the reflection methods to avoid infinite loops.\n * </p>\n *\n * @param value\n *                  The object to lookup in the registry.\n * @return boolean <code>true</code> if the registry contains the given\n *             object.\n */\nstatic boolean isRegistered(Object value) {\n    Map<Object, Object> m = getRegistry();\n    return m.containsKey(value);\n}", "code_comment": "/**\n * <p>\n * Returns <code>true</code> if the registry contains the given object.\n * Used by the reflection methods to avoid infinite loops.\n * </p>\n *\n * @param value\n *                  The object to lookup in the registry.\n * @return boolean <code>true</code> if the registry contains the given\n *             object.\n */\n", "code_no_comment": "static boolean isRegistered(Object value) {\n    Map<Object, Object> m = getRegistry();\n    return m.containsKey(value);\n}", "lc": -0.45454545454545453, "pi": -0.47368421052631593, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.7930937279774485, "fo": -0.3333333333333333, "r": 2.3157894736842106, "e": -0.16279340490885932}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-208_b224bad8", "label": 3, "code": "/**\n *  @param updateInterval\n *             Duration between AJAX callbacks\n *  @return JS script\n */\nprotected final String getJsTimeoutCall(final Duration updateInterval) {\n    return \"setTimeout(function() { \" + getCallbackScript(false, true) + \" }, \" + updateInterval.getMilliseconds() + \");\";\n}", "code_comment": "/**\n *  @param updateInterval\n *             Duration between AJAX callbacks\n *  @return JS script\n */\n", "code_no_comment": "protected final String getJsTimeoutCall(final Duration updateInterval) {\n    return \"setTimeout(function() { \" + getCallbackScript(false, true) + \" }, \" + updateInterval.getMilliseconds() + \");\";\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.8909090909090904, "fo": -0.3333333333333333, "r": 2.6052631578947367, "e": -0.16279340490885932}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5418_e350f19e", "label": 1, "code": "@SuppressWarnings(\"unchecked\")\n@Override\npublic void bind(Component component) {\n    if (this.component != null) {\n        throw new // \n        IllegalStateException(\"This validator has already been added to component: \" + this.component + \". This validator does not support reusing instances, please create a new one\");\n    }\n    if (!(component instanceof FormComponent)) {\n        throw new IllegalStateException(getClass().getSimpleName() + \" can only be added to FormComponents\");\n    }\n    // TODO add a validation key that appends the type so we can have different messages for\n    // @Size on String vs Collection - done but need to add a key for each superclass/interface\n    this.component = (FormComponent<T>) component;\n}", "code_comment": NaN, "code_no_comment": "@SuppressWarnings(\"unchecked\")\n@Override\npublic void bind(Component component) {\n    if (this.component != null) {\n        throw new         IllegalStateException(\"This validator has already been added to component: \" + this.component + \". This validator does not support reusing instances, please create a new one\");\n    }\n    if (!(component instanceof FormComponent)) {\n        throw new IllegalStateException(getClass().getSimpleName() + \" can only be added to FormComponents\");\n    }\n            this.component = (FormComponent<T>) component;\n}", "lc": -0.09090909090909091, "pi": 0.02392344497607647, "ma": 0.2, "nbd": -0.5, "ml": -0.08333333333333333, "d": 0.2063492063492063, "mi": 0.10754052149400978, "fo": -0.3333333333333333, "r": 0.02631578947368421, "e": -0.002390461206871712}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-412_be2fdba7", "label": 1, "code": "/**\n * Iterates over the source until an acceptable key/value pair is found.\n */\nprotected void findTop() {\n    while (getSource().hasTop() && (negate == accept(getSource().getTopKey(), getSource().getTopValue()))) {\n        try {\n            getSource().next();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}", "code_comment": "/**\n * Iterates over the source until an acceptable key/value pair is found.\n */\n", "code_no_comment": "protected void findTop() {\n    while (getSource().hasTop() && (negate == accept(getSource().getTopKey(), getSource().getTopValue()))) {\n        try {\n            getSource().next();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}", "lc": -0.22727272727272727, "pi": 0.6076555023923443, "ma": 0.0, "nbd": 0.0, "ml": 0.16666666666666666, "d": -0.10119047619047619, "mi": 0.3285412262156448, "fo": 0.25, "r": 1.3157894736842106, "e": -0.12066411945390523}
{"project_name": "Cli", "project_version": 23, "label": 1, "code": "/**\n * Render the specified text and return the rendered Options\n * in a StringBuffer.\n *\n * @param sb The StringBuffer to place the rendered text into.\n * @param width The number of characters to display per line\n * @param nextLineTabStop The position on the next line for the first tab.\n * @param text The text to be rendered.\n *\n * @return the StringBuffer with the rendered Options contents.\n */\nprotected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) {\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1) {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    // all following lines must be padded with nextLineTabStop space\n    // characters\n    final String padding = createPadding(nextLineTabStop);\n    while (true) {\n        int lastPos = pos;\n        text = padding + text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1) {\n            sb.append(text);\n            return sb;\n        } else if (pos == lastPos) {\n            throw new RuntimeException(\"Text too long for line - throwing exception to avoid infinite loop [CLI-162]: \" + text);\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    }\n}", "code_comment": "/**\n * Render the specified text and return the rendered Options\n * in a StringBuffer.\n *\n * @param sb The StringBuffer to place the rendered text into.\n * @param width The number of characters to display per line\n * @param nextLineTabStop The position on the next line for the first tab.\n * @param text The text to be rendered.\n *\n * @return the StringBuffer with the rendered Options contents.\n */\n", "code_no_comment": "protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) {\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1) {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n            final String padding = createPadding(nextLineTabStop);\n    while (true) {\n        int lastPos = pos;\n        text = padding + text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1) {\n            sb.append(text);\n            return sb;\n        } else if (pos == lastPos) {\n            throw new RuntimeException(\"Text too long for line - throwing exception to avoid infinite loop [CLI-162]: \" + text);\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    }\n}", "lc": 0.3181818181818182, "pi": 0.186602870813397, "ma": 0.4, "nbd": 0.5, "ml": 0.08333333333333333, "d": 0.8075396825396826, "mi": -0.32262156448202933, "fo": 0.8333333333333334, "r": -0.02631578947368421, "e": 0.8741965042098164}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4173_84bbbf68", "label": 1, "code": "/*\n\t * TODO: simplify the code below. See WICKET-3347\n\t */\n@Override\npublic void respond(RequestCycle requestCycle) {\n    Url currentUrl = requestCycle.getUrlRenderer().getBaseUrl();\n    Url targetUrl = requestCycle.mapUrlFor(getRenderPageRequestHandler());\n    // \n    // the code below is little hairy but we have to handle 3 redirect policies,\n    // 3 rendering strategies and two kind of requests (ajax and normal)\n    // \n    // try to get an already rendered buffered response for current URL\n    BufferedWebResponse bufferedResponse = getAndRemoveBufferedResponse(currentUrl);\n    boolean isAjax = isAjax(requestCycle);\n    boolean shouldPreserveClientUrl = ((WebRequest) requestCycle.getRequest()).shouldPreserveClientUrl();\n    if (bufferedResponse != null) {\n        logger.warn(\"The Buffered response should be handled by BufferedResponseRequestHandler\");\n        // if there is saved response for this URL render it\n        bufferedResponse.writeTo((WebResponse) requestCycle.getResponse());\n    } else if (getRedirectPolicy() == RedirectPolicy.NEVER_REDIRECT || // \n    (isOnePassRender() && isAjax == false) || (// \n    !isAjax && // \n    (targetUrl.equals(currentUrl) && !getPageProvider().isNewPageInstance() && !getPage().isPageStateless()) || // \n    (targetUrl.equals(currentUrl) && isRedirectToRender())) || // \n    shouldPreserveClientUrl) {\n        // if the policy is never to redirect\n        // or one pass render mode is on\n        // or the targetUrl matches current url and the page is not stateless\n        // or the targetUrl matches current url, page is stateless but it's redirect-to-render\n        // or the request determines that the current url should be preserved\n        // just render the page\n        BufferedWebResponse response = renderPage(currentUrl, requestCycle);\n        if (response != null) {\n            response.writeTo((WebResponse) requestCycle.getResponse());\n        }\n    } else if (// \n    getRedirectPolicy() == RedirectPolicy.ALWAYS_REDIRECT || // \n    isRedirectToRender() || (isAjax && targetUrl.equals(currentUrl))) {\n        // if target URL is different\n        // and render policy is always-redirect or it's redirect-to-render\n        redirectTo(targetUrl, requestCycle);\n    } else if (// \n    !targetUrl.equals(currentUrl) && (getPageProvider().isNewPageInstance() || (isSessionTemporary() && getPage().isPageStateless()))) {\n        // if target URL is different and session is temporary and page is stateless\n        // this is special case when page is stateless but there is no session so we can't\n        // render it to buffer\n        // alternatively if URLs are different and we have a page class and not an instance we\n        // can redirect to the url which will instantiate the instance of us\n        // note: if we had session here we would render the page to buffer and then redirect to\n        // URL generated *after* page has been rendered (the statelessness may change during\n        // render). this would save one redirect because now we have to render to URL generated\n        // *before* page is rendered, render the page, get URL after render and if the URL is\n        // different (meaning page is not stateless), save the buffer and redirect again (which\n        // is pretty much what the next step does)\n        redirectTo(targetUrl, requestCycle);\n    } else {\n        if (isRedirectToBuffer() == false && logger.isWarnEnabled()) {\n            logger.warn(\"Falling back to Redirect_To_Buffer render strategy because none of the conditions matched.\");\n        }\n        // redirect to buffer\n        BufferedWebResponse response = renderPage(targetUrl, requestCycle);\n        if (response == null) {\n            return;\n        }\n        // check if the url hasn't changed after page has been rendered\n        // (i.e. the stateless flag might have changed which could result in different page url)\n        Url targetUrl2 = requestCycle.mapUrlFor(getRenderPageRequestHandler());\n        if (targetUrl.getSegments().equals(targetUrl2.getSegments()) == false) {\n            // the amount of segments is different - generated relative URLs will not work, we\n            // need to rerender the page. This shouldn't happen, but in theory it can - with\n            // RequestHandlerEncoders that produce different URLs with different amount of\n            // segments for stateless and stateful pages\n            response = renderPage(targetUrl2, requestCycle);\n        }\n        if (currentUrl.equals(targetUrl2)) {\n            // no need to redirect when both urls are exactly the same\n            response.writeTo((WebResponse) requestCycle.getResponse());\n        } else // if page is still stateless after render\n        if (getPage().isPageStateless() && !enableRedirectForStatelessPage()) {\n            // we don't want the redirect to happen for stateless page\n            // example:\n            // when a normal mounted stateful page is hit at /mount/point\n            // wicket renders the page to buffer and redirects to /mount/point?12\n            // but for stateless page the redirect is not necessary\n            // also for listener interface on stateful page we want to redirect\n            // after the listener is invoked, but on stateless page the user\n            // must ask for redirect explicitly\n            response.writeTo((WebResponse) requestCycle.getResponse());\n        } else {\n            storeBufferedResponse(targetUrl2, response);\n            redirectTo(targetUrl2, requestCycle);\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void respond(RequestCycle requestCycle) {\n    Url currentUrl = requestCycle.getUrlRenderer().getBaseUrl();\n    Url targetUrl = requestCycle.mapUrlFor(getRenderPageRequestHandler());\n                        BufferedWebResponse bufferedResponse = getAndRemoveBufferedResponse(currentUrl);\n    boolean isAjax = isAjax(requestCycle);\n    boolean shouldPreserveClientUrl = ((WebRequest) requestCycle.getRequest()).shouldPreserveClientUrl();\n    if (bufferedResponse != null) {\n        logger.warn(\"The Buffered response should be handled by BufferedResponseRequestHandler\");\n                bufferedResponse.writeTo((WebResponse) requestCycle.getResponse());\n    } else if (getRedirectPolicy() == RedirectPolicy.NEVER_REDIRECT ||     (isOnePassRender() && isAjax == false) || (    !isAjax &&     (targetUrl.equals(currentUrl) && !getPageProvider().isNewPageInstance() && !getPage().isPageStateless()) ||     (targetUrl.equals(currentUrl) && isRedirectToRender())) ||     shouldPreserveClientUrl) {\n                                                        BufferedWebResponse response = renderPage(currentUrl, requestCycle);\n        if (response != null) {\n            response.writeTo((WebResponse) requestCycle.getResponse());\n        }\n    } else if (    getRedirectPolicy() == RedirectPolicy.ALWAYS_REDIRECT ||     isRedirectToRender() || (isAjax && targetUrl.equals(currentUrl))) {\n                        redirectTo(targetUrl, requestCycle);\n    } else if (    !targetUrl.equals(currentUrl) && (getPageProvider().isNewPageInstance() || (isSessionTemporary() && getPage().isPageStateless()))) {\n                                                                                                redirectTo(targetUrl, requestCycle);\n    } else {\n        if (isRedirectToBuffer() == false && logger.isWarnEnabled()) {\n            logger.warn(\"Falling back to Redirect_To_Buffer render strategy because none of the conditions matched.\");\n        }\n                BufferedWebResponse response = renderPage(targetUrl, requestCycle);\n        if (response == null) {\n            return;\n        }\n                        Url targetUrl2 = requestCycle.mapUrlFor(getRenderPageRequestHandler());\n        if (targetUrl.getSegments().equals(targetUrl2.getSegments()) == false) {\n                                                            response = renderPage(targetUrl2, requestCycle);\n        }\n        if (currentUrl.equals(targetUrl2)) {\n                        response.writeTo((WebResponse) requestCycle.getResponse());\n        } else         if (getPage().isPageStateless() && !enableRedirectForStatelessPage()) {\n                                                                                                            response.writeTo((WebResponse) requestCycle.getResponse());\n        } else {\n            storeBufferedResponse(targetUrl2, response);\n            redirectTo(targetUrl2, requestCycle);\n        }\n    }\n}", "lc": 1.6363636363636365, "pi": 0.1291866028708132, "ma": 1.4, "nbd": 2.0, "ml": 3.4166666666666665, "d": 1.3472222222222223, "mi": -0.8976744186046509, "fo": 4.0, "r": -0.02631578947368421, "e": 3.955909014943264}
{"project_name": "Compress", "project_version": 19, "label": 1, "code": "/**\n * Parses the raw bytes read from the central directory extra\n * field with knowledge which fields are expected to be there.\n *\n * <p>All four fields inside the zip64 extended information extra\n * field are optional and must only be present if their corresponding\n * entry inside the central directory contains the correct magic\n * value.</p>\n */\npublic void reparseCentralDirectoryData(boolean hasUncompressedSize, boolean hasCompressedSize, boolean hasRelativeHeaderOffset, boolean hasDiskStart) throws ZipException {\n    if (rawCentralDirectoryData != null) {\n        int expectedLength = (hasUncompressedSize ? DWORD : 0) + (hasCompressedSize ? DWORD : 0) + (hasRelativeHeaderOffset ? DWORD : 0) + (hasDiskStart ? WORD : 0);\n        if (rawCentralDirectoryData.length != expectedLength) {\n            throw new ZipException(\"central directory zip64 extended\" + \" information extra field's length\" + \" doesn't match central directory\" + \" data.  Expected length \" + expectedLength + \" but is \" + rawCentralDirectoryData.length);\n        }\n        int offset = 0;\n        if (hasUncompressedSize) {\n            size = new ZipEightByteInteger(rawCentralDirectoryData, offset);\n            offset += DWORD;\n        }\n        if (hasCompressedSize) {\n            compressedSize = new ZipEightByteInteger(rawCentralDirectoryData, offset);\n            offset += DWORD;\n        }\n        if (hasRelativeHeaderOffset) {\n            relativeHeaderOffset = new ZipEightByteInteger(rawCentralDirectoryData, offset);\n            offset += DWORD;\n        }\n        if (hasDiskStart) {\n            diskStart = new ZipLong(rawCentralDirectoryData, offset);\n            offset += WORD;\n        }\n    }\n}", "code_comment": "/**\n * Parses the raw bytes read from the central directory extra\n * field with knowledge which fields are expected to be there.\n *\n * <p>All four fields inside the zip64 extended information extra\n * field are optional and must only be present if their corresponding\n * entry inside the central directory contains the correct magic\n * value.</p>\n */\n", "code_no_comment": "public void reparseCentralDirectoryData(boolean hasUncompressedSize, boolean hasCompressedSize, boolean hasRelativeHeaderOffset, boolean hasDiskStart) throws ZipException {\n    if (rawCentralDirectoryData != null) {\n        int expectedLength = (hasUncompressedSize ? DWORD : 0) + (hasCompressedSize ? DWORD : 0) + (hasRelativeHeaderOffset ? DWORD : 0) + (hasDiskStart ? WORD : 0);\n        if (rawCentralDirectoryData.length != expectedLength) {\n            throw new ZipException(\"central directory zip64 extended\" + \" information extra field's length\" + \" doesn't match central directory\" + \" data.  Expected length \" + expectedLength + \" but is \" + rawCentralDirectoryData.length);\n        }\n        int offset = 0;\n        if (hasUncompressedSize) {\n            size = new ZipEightByteInteger(rawCentralDirectoryData, offset);\n            offset += DWORD;\n        }\n        if (hasCompressedSize) {\n            compressedSize = new ZipEightByteInteger(rawCentralDirectoryData, offset);\n            offset += DWORD;\n        }\n        if (hasRelativeHeaderOffset) {\n            relativeHeaderOffset = new ZipEightByteInteger(rawCentralDirectoryData, offset);\n            offset += DWORD;\n        }\n        if (hasDiskStart) {\n            diskStart = new ZipLong(rawCentralDirectoryData, offset);\n            offset += WORD;\n        }\n    }\n}", "lc": 0.5, "pi": 0.22009569377990432, "ma": 1.6, "nbd": 0.0, "ml": 1.0, "d": 0.6111111111111112, "mi": -0.4438336856941508, "fo": -0.5, "r": -0.02631578947368421, "e": 0.7170438500948}
{"project_name": "Lang", "project_version": 32, "label": 1, "code": "@Override\nprotected Set<IDKey> initialValue() {\n    return new HashSet<IDKey>();\n}", "code_comment": NaN, "code_no_comment": "@Override\nprotected Set<IDKey> initialValue() {\n    return new HashSet<IDKey>();\n}", "lc": -0.45454545454545453, "pi": -0.6028708133971293, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.9134601832276249, "fo": -0.5, "r": 1.368421052631579, "e": -0.16279340490885932}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-217_add180fb", "label": 1, "code": "@Override\npublic void removeIterator(String tableName, String name, EnumSet<IteratorScope> scopes) throws AccumuloSecurityException, AccumuloException, TableNotFoundException {\n    Map<String, String> copy = new HashMap<String, String>();\n    for (Entry<String, String> property : this.getProperties(tableName)) {\n        copy.put(property.getKey(), property.getValue());\n    }\n    for (IteratorScope scope : scopes) {\n        String root = String.format(\"%s%s.%s\", Property.TABLE_ITERATOR_PREFIX, scope.name().toLowerCase(), name);\n        for (Entry<String, String> property : copy.entrySet()) {\n            if (property.getKey().equals(root) || property.getKey().startsWith(root + \".opt.\"))\n                this.removeProperty(tableName, property.getKey());\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void removeIterator(String tableName, String name, EnumSet<IteratorScope> scopes) throws AccumuloSecurityException, AccumuloException, TableNotFoundException {\n    Map<String, String> copy = new HashMap<String, String>();\n    for (Entry<String, String> property : this.getProperties(tableName)) {\n        copy.put(property.getKey(), property.getValue());\n    }\n    for (IteratorScope scope : scopes) {\n        String root = String.format(\"%s%s.%s\", Property.TABLE_ITERATOR_PREFIX, scope.name().toLowerCase(), name);\n        for (Entry<String, String> property : copy.entrySet()) {\n            if (property.getKey().equals(root) || property.getKey().startsWith(root + \".opt.\"))\n                this.removeProperty(tableName, property.getKey());\n        }\n    }\n}", "lc": 0.0, "pi": 0.7033492822966506, "ma": 0.2, "nbd": 0.0, "ml": 0.0, "d": 0.02579365079365077, "mi": -0.1213530655391118, "fo": 0.6666666666666666, "r": -0.02631578947368421, "e": 0.16114751358609516}
{"project_name": "Lang", "project_version": 32, "label": 1, "code": "/**\n * <p>\n * Registers the given object. Used by the reflection methods to avoid infinite loops.\n * </p>\n *\n * @param value\n *            The object to register.\n */\nstatic void register(Object value) {\n    getRegistry().add(new IDKey(value));\n}", "code_comment": "/**\n * <p>\n * Registers the given object. Used by the reflection methods to avoid infinite loops.\n * </p>\n *\n * @param value\n *            The object to register.\n */\n", "code_no_comment": "static void register(Object value) {\n    getRegistry().add(new IDKey(value));\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.0132487667371384, "fo": -0.3333333333333333, "r": 2.6052631578947367, "e": -0.16279340490885932}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-619_3b4b370e", "label": 0, "code": "@Override\npublic Configuration reconfigure() {\n    if (configFile != null) {\n        try {\n            final ConfigurationFactory.ConfigurationSource source = new ConfigurationFactory.ConfigurationSource(new FileInputStream(configFile), configFile);\n            final XmlConfiguration config = new XmlConfiguration(source);\n            if (config.rootElement == null) {\n                return null;\n            }\n        } catch (final FileNotFoundException ex) {\n            LOGGER.error(\"Cannot locate file \" + configFile, ex);\n        }\n    }\n    return null;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic Configuration reconfigure() {\n    if (configFile != null) {\n        try {\n            final ConfigurationFactory.ConfigurationSource source = new ConfigurationFactory.ConfigurationSource(new FileInputStream(configFile), configFile);\n            final XmlConfiguration config = new XmlConfiguration(source);\n            if (config.rootElement == null) {\n                return null;\n            }\n        } catch (final FileNotFoundException ex) {\n            LOGGER.error(\"Cannot locate file \" + configFile, ex);\n        }\n    }\n    return null;\n}", "lc": 0.045454545454545456, "pi": 0.9760765550239235, "ma": 0.0, "nbd": 0.5, "ml": -0.08333333333333333, "d": 0.29563492063492064, "mi": -0.025229034531359995, "fo": -0.4166666666666667, "r": 0.2368421052631579, "e": 0.07706874592993433}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-3314_4badd9c5", "label": 1, "code": "protected Processor createOutputsProcessor(RouteContext routeContext, Collection<ProcessorDefinition> outputs) throws Exception {\n    List<Processor> list = new ArrayList<Processor>();\n    for (ProcessorDefinition<?> output : outputs) {\n        Processor processor = null;\n        // at first use custom factory\n        if (routeContext.getCamelContext().getProcessorFactory() != null) {\n            processor = routeContext.getCamelContext().getProcessorFactory().createProcessor(routeContext, output);\n        }\n        // fallback to default implementation if factory did not create the processor\n        if (processor == null) {\n            processor = output.createProcessor(routeContext);\n        }\n        if (output instanceof Channel && processor == null) {\n            continue;\n        }\n        Processor channel = wrapChannel(routeContext, processor, output);\n        list.add(channel);\n    }\n    // if more than one output wrap than in a composite processor else just keep it as is\n    Processor processor = null;\n    if (!list.isEmpty()) {\n        if (list.size() == 1) {\n            processor = list.get(0);\n        } else {\n            processor = createCompositeProcessor(routeContext, list);\n        }\n    }\n    return processor;\n}", "code_comment": NaN, "code_no_comment": "protected Processor createOutputsProcessor(RouteContext routeContext, Collection<ProcessorDefinition> outputs) throws Exception {\n    List<Processor> list = new ArrayList<Processor>();\n    for (ProcessorDefinition<?> output : outputs) {\n        Processor processor = null;\n                if (routeContext.getCamelContext().getProcessorFactory() != null) {\n            processor = routeContext.getCamelContext().getProcessorFactory().createProcessor(routeContext, output);\n        }\n                if (processor == null) {\n            processor = output.createProcessor(routeContext);\n        }\n        if (output instanceof Channel && processor == null) {\n            continue;\n        }\n        Processor channel = wrapChannel(routeContext, processor, output);\n        list.add(channel);\n    }\n        Processor processor = null;\n    if (!list.isEmpty()) {\n        if (list.size() == 1) {\n            processor = list.get(0);\n        } else {\n            processor = createCompositeProcessor(routeContext, list);\n        }\n    }\n    return processor;\n}", "lc": 0.5454545454545454, "pi": 0.186602870813397, "ma": 0.8, "nbd": 0.0, "ml": 0.5, "d": 0.5853174603174603, "mi": -0.443551797040169, "fo": 0.5, "r": -0.02631578947368421, "e": 0.7387216680209538}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-7304_fa165d6b", "label": 3, "code": "public Endpoint registerEndpoint(String uri, Endpoint endpoint) {\n    if (endpoint instanceof InterceptSendToEndpoint) {\n        // endpoint already decorated\n        return endpoint;\n    } else if (getUri() == null || EndpointHelper.matchEndpoint(routeContext.getCamelContext(), uri, getUri())) {\n        // only proxy if the uri is matched decorate endpoint with our proxy\n        // should be false by default\n        boolean skip = isSkipSendToOriginalEndpoint();\n        InterceptSendToEndpoint proxy = new InterceptSendToEndpoint(endpoint, skip);\n        proxy.setDetour(detour);\n        return proxy;\n    } else {\n        // no proxy so return regular endpoint\n        return endpoint;\n    }\n}", "code_comment": NaN, "code_no_comment": "public Endpoint registerEndpoint(String uri, Endpoint endpoint) {\n    if (endpoint instanceof InterceptSendToEndpoint) {\n                return endpoint;\n    } else if (getUri() == null || EndpointHelper.matchEndpoint(routeContext.getCamelContext(), uri, getUri())) {\n                        boolean skip = isSkipSendToOriginalEndpoint();\n        InterceptSendToEndpoint proxy = new InterceptSendToEndpoint(endpoint, skip);\n        proxy.setDetour(detour);\n        return proxy;\n    } else {\n                return endpoint;\n    }\n}", "lc": -0.09090909090909091, "pi": -0.004784688995215422, "ma": -0.2, "nbd": 0.0, "ml": 0.25, "d": -0.03373015873015876, "mi": 0.08949964763918242, "fo": 0.0, "r": 0.21052631578947367, "e": -0.04804204629933784}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1731_024e5d37", "label": 1, "code": "private void copyNodeTypes(NodeBuilder root) throws RepositoryException {\n    NodeTypeRegistry sourceRegistry = source.getNodeTypeRegistry();\n    NodeBuilder system = root.child(JCR_SYSTEM);\n    NodeBuilder types = system.child(JCR_NODE_TYPES);\n    logger.info(\"Copying registered node types\");\n    for (Name name : sourceRegistry.getRegisteredNodeTypes()) {\n        String oakName = getOakName(name);\n        // skip built-in nodetypes (OAK-1235)\n        if (!types.hasChildNode(oakName)) {\n            QNodeTypeDefinition def = sourceRegistry.getNodeTypeDef(name);\n            NodeBuilder type = types.child(oakName);\n            copyNodeType(def, type);\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "private void copyNodeTypes(NodeBuilder root) throws RepositoryException {\n    NodeTypeRegistry sourceRegistry = source.getNodeTypeRegistry();\n    NodeBuilder system = root.child(JCR_SYSTEM);\n    NodeBuilder types = system.child(JCR_NODE_TYPES);\n    logger.info(\"Copying registered node types\");\n    for (Name name : sourceRegistry.getRegisteredNodeTypes()) {\n        String oakName = getOakName(name);\n                if (!types.hasChildNode(oakName)) {\n            QNodeTypeDefinition def = sourceRegistry.getNodeTypeDef(name);\n            NodeBuilder type = types.child(oakName);\n            copyNodeType(def, type);\n        }\n    }\n}", "lc": 0.0, "pi": 0.44976076555023925, "ma": -0.2, "nbd": 0.0, "ml": -0.16666666666666666, "d": -0.0496031746031746, "mi": -0.06356589147286808, "fo": 0.3333333333333333, "r": 0.10526315789473684, "e": 0.029222639073782718}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-668_60f64cc1", "label": 3, "code": "/**\n * Actual writing occurs here.\n * <p/>\n * @param logEvent The LogEvent.\n */\n@Override\npublic void append(final LogEvent logEvent) {\n    if (!isStarted()) {\n        throw new IllegalStateException(\"AsyncAppender \" + getName() + \" is not active\");\n    }\n    if (!(logEvent instanceof Log4jLogEvent)) {\n        // only know how to Serialize Log4jLogEvents\n        return;\n    }\n    Log4jLogEvent coreEvent = (Log4jLogEvent) logEvent;\n    boolean appendSuccessful = false;\n    if (blocking) {\n        if (isAppenderThread.get() == Boolean.TRUE && queue.remainingCapacity() == 0) {\n            // LOG4J2-485: avoid deadlock that would result from trying\n            // to add to a full queue from appender thread\n            // queue is definitely not empty!\n            coreEvent.setEndOfBatch(false);\n            appendSuccessful = thread.callAppenders(coreEvent);\n        } else {\n            try {\n                // wait for free slots in the queue\n                queue.put(Log4jLogEvent.serialize(coreEvent, includeLocation));\n                appendSuccessful = true;\n            } catch (final InterruptedException e) {\n                LOGGER.warn(\"Interrupted while waiting for a free slot in the AsyncAppender LogEvent-queue {}\", getName());\n            }\n        }\n    } else {\n        appendSuccessful = queue.offer(Log4jLogEvent.serialize(coreEvent, includeLocation));\n        if (!appendSuccessful) {\n            error(\"Appender \" + getName() + \" is unable to write primary appenders. queue is full\");\n        }\n    }\n    if (!appendSuccessful && errorAppender != null) {\n        errorAppender.callAppender(coreEvent);\n    }\n}", "code_comment": "/**\n * Actual writing occurs here.\n * <p/>\n * @param logEvent The LogEvent.\n */\n", "code_no_comment": "@Override\npublic void append(final LogEvent logEvent) {\n    if (!isStarted()) {\n        throw new IllegalStateException(\"AsyncAppender \" + getName() + \" is not active\");\n    }\n    if (!(logEvent instanceof Log4jLogEvent)) {\n                return;\n    }\n    Log4jLogEvent coreEvent = (Log4jLogEvent) logEvent;\n    boolean appendSuccessful = false;\n    if (blocking) {\n        if (isAppenderThread.get() == Boolean.TRUE && queue.remainingCapacity() == 0) {\n                                                coreEvent.setEndOfBatch(false);\n            appendSuccessful = thread.callAppenders(coreEvent);\n        } else {\n            try {\n                                queue.put(Log4jLogEvent.serialize(coreEvent, includeLocation));\n                appendSuccessful = true;\n            } catch (final InterruptedException e) {\n                LOGGER.warn(\"Interrupted while waiting for a free slot in the AsyncAppender LogEvent-queue {}\", getName());\n            }\n        }\n    } else {\n        appendSuccessful = queue.offer(Log4jLogEvent.serialize(coreEvent, includeLocation));\n        if (!appendSuccessful) {\n            error(\"Appender \" + getName() + \" is unable to write primary appenders. queue is full\");\n        }\n    }\n    if (!appendSuccessful && errorAppender != null) {\n        errorAppender.callAppender(coreEvent);\n    }\n}", "lc": 0.8181818181818182, "pi": 0.7129186602870815, "ma": 1.0, "nbd": 0.5, "ml": 0.8333333333333334, "d": 0.5793650793650793, "mi": -0.5588442565186751, "fo": 0.75, "r": -0.02631578947368421, "e": 0.8237593863637671}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1788_dd3437d4", "label": 3, "code": "/**\n * Get the seen-at revision from the revision range.\n * <p>\n * <ul>\n *     <li>\n *         {@code null} if the revision is older than the earliest range\n *     </li>\n *     <li>\n *         if the revision is newer than the lower bound of the newest\n *         range, then {@link #NEWEST} is returned for a local cluster\n *         revision and {@link #FUTURE} for a foreign cluster revision.\n *     </li>\n *     <li>\n *         if the revision matches the lower seen-at bound of a range,\n *         then this seen-at revision is returned.\n *     </li>\n *     <li>\n *         otherwise the lower bound seen-at revision of next higher\n *         range is returned.\n *     </li>\n * </ul>\n *\n * @param r the revision\n * @return the seen-at revision or {@code null} if the revision is older\n *          than the earliest range.\n */\nRevision getRevisionSeen(Revision r) {\n    List<RevisionRange> list = map.get(r.getClusterId());\n    if (list == null) {\n        if (r.getTimestamp() <= oldestTimestamp) {\n            // old revision with already purged range\n            return null;\n        }\n        if (r.getClusterId() != currentClusterNodeId) {\n            // see also OAK-1170\n            return FUTURE;\n        }\n        return null;\n    }\n    // at the end of the list)\n    for (int i = list.size() - 1; i >= 0; i--) {\n        RevisionRange range = list.get(i);\n        int compare = r.compareRevisionTime(range.revision);\n        if (compare == 0) {\n            return range.seenAt;\n        } else if (compare > 0) {\n            if (i == list.size() - 1) {\n                // newer than the newest range\n                if (r.getClusterId() == currentClusterNodeId) {\n                    // newer than all others, except for FUTURE\n                    return NEWEST;\n                }\n                // happens in the future (not visible yet)\n                return FUTURE;\n            } else {\n                // there is a newer range\n                return list.get(i + 1).seenAt;\n            }\n        }\n    }\n    return null;\n}", "code_comment": "/**\n * Get the seen-at revision from the revision range.\n * <p>\n * <ul>\n *     <li>\n *         {@code null} if the revision is older than the earliest range\n *     </li>\n *     <li>\n *         if the revision is newer than the lower bound of the newest\n *         range, then {@link #NEWEST} is returned for a local cluster\n *         revision and {@link #FUTURE} for a foreign cluster revision.\n *     </li>\n *     <li>\n *         if the revision matches the lower seen-at bound of a range,\n *         then this seen-at revision is returned.\n *     </li>\n *     <li>\n *         otherwise the lower bound seen-at revision of next higher\n *         range is returned.\n *     </li>\n * </ul>\n *\n * @param r the revision\n * @return the seen-at revision or {@code null} if the revision is older\n *          than the earliest range.\n */\n", "code_no_comment": "Revision getRevisionSeen(Revision r) {\n    List<RevisionRange> list = map.get(r.getClusterId());\n    if (list == null) {\n        if (r.getTimestamp() <= oldestTimestamp) {\n                        return null;\n        }\n        if (r.getClusterId() != currentClusterNodeId) {\n                        return FUTURE;\n        }\n        return null;\n    }\n        for (int i = list.size() - 1; i >= 0; i--) {\n        RevisionRange range = list.get(i);\n        int compare = r.compareRevisionTime(range.revision);\n        if (compare == 0) {\n            return range.seenAt;\n        } else if (compare > 0) {\n            if (i == list.size() - 1) {\n                                if (r.getClusterId() == currentClusterNodeId) {\n                                        return NEWEST;\n                }\n                                return FUTURE;\n            } else {\n                                return list.get(i + 1).seenAt;\n            }\n        }\n    }\n    return null;\n}", "lc": 0.6818181818181818, "pi": 0.909090909090909, "ma": 1.0, "nbd": 1.5, "ml": 0.9166666666666666, "d": 1.5714285714285714, "mi": -0.49372797744890756, "fo": 0.3333333333333333, "r": -0.02631578947368421, "e": 1.5998916570137673}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-16_6c5083b4", "label": 1, "code": "/**\n *  Encode a page class target.\n *\n *  If you override this method to behave different then also\n *  {@link #addBookmarkablePageParameters(Request, RequestParameters)} should\n *  be overridden to by in sync with that behaviour.\n *\n *  @param requestCycle\n *             the current request cycle\n *  @param requestTarget\n *             the target to encode\n *  @return the encoded url\n */\nprotected CharSequence encode(RequestCycle requestCycle, IBookmarkablePageRequestTarget requestTarget) {\n    // Begin encoding URL\n    final AppendingStringBuffer url = new AppendingStringBuffer(64);\n    url.append(urlPrefix(requestCycle));\n    // Get page Class\n    final Class pageClass = requestTarget.getPageClass();\n    final Application application = Application.get();\n    // Find pagemap name\n    String pageMapName = requestTarget.getPageMapName();\n    if (pageMapName == null) {\n        IRequestTarget currentTarget = requestCycle.getRequestTarget();\n        if (currentTarget instanceof IPageRequestTarget) {\n            Page currentPage = ((IPageRequestTarget) currentTarget).getPage();\n            final PageMap pageMap = currentPage.getPageMap();\n            if (pageMap.isDefault()) {\n                pageMapName = \"\";\n            } else {\n                pageMapName = pageMap.getName();\n            }\n        } else {\n            pageMapName = \"\";\n        }\n    }\n    boolean firstParameter = true;\n    if (!application.getHomePage().equals(pageClass) || !\"\".equals(pageMapName)) {\n        firstParameter = false;\n        url.append('?');\n        url.append(WebRequestCodingStrategy.BOOKMARKABLE_PAGE_PARAMETER_NAME);\n        url.append('=');\n        // Add <page-map-name>:<bookmarkable-page-class>\n        url.append(pageMapName + Component.PATH_SEPARATOR + pageClass.getName());\n    }\n    // Get page parameters\n    final PageParameters parameters = requestTarget.getPageParameters();\n    if (parameters != null) {\n        for (final Iterator iterator = parameters.keySet().iterator(); iterator.hasNext(); ) {\n            final String key = (String) iterator.next();\n            final String value = parameters.getString(key);\n            if (value != null) {\n                String escapedValue = value;\n                try {\n                    escapedValue = URLEncoder.encode(escapedValue, application.getRequestCycleSettings().getResponseRequestEncoding());\n                } catch (UnsupportedEncodingException ex) {\n                    log.error(ex.getMessage(), ex);\n                }\n                if (!firstParameter) {\n                    url.append('&');\n                } else {\n                    firstParameter = false;\n                    url.append('?');\n                }\n                url.append(key);\n                url.append('=');\n                url.append(escapedValue);\n            }\n        }\n    }\n    return requestCycle.getOriginalResponse().encodeURL(url);\n}", "code_comment": "/**\n *  Encode a page class target.\n *\n *  If you override this method to behave different then also\n *  {@link #addBookmarkablePageParameters(Request, RequestParameters)} should\n *  be overridden to by in sync with that behaviour.\n *\n *  @param requestCycle\n *             the current request cycle\n *  @param requestTarget\n *             the target to encode\n *  @return the encoded url\n */\n", "code_no_comment": "protected CharSequence encode(RequestCycle requestCycle, IBookmarkablePageRequestTarget requestTarget) {\n        final AppendingStringBuffer url = new AppendingStringBuffer(64);\n    url.append(urlPrefix(requestCycle));\n        final Class pageClass = requestTarget.getPageClass();\n    final Application application = Application.get();\n        String pageMapName = requestTarget.getPageMapName();\n    if (pageMapName == null) {\n        IRequestTarget currentTarget = requestCycle.getRequestTarget();\n        if (currentTarget instanceof IPageRequestTarget) {\n            Page currentPage = ((IPageRequestTarget) currentTarget).getPage();\n            final PageMap pageMap = currentPage.getPageMap();\n            if (pageMap.isDefault()) {\n                pageMapName = \"\";\n            } else {\n                pageMapName = pageMap.getName();\n            }\n        } else {\n            pageMapName = \"\";\n        }\n    }\n    boolean firstParameter = true;\n    if (!application.getHomePage().equals(pageClass) || !\"\".equals(pageMapName)) {\n        firstParameter = false;\n        url.append('?');\n        url.append(WebRequestCodingStrategy.BOOKMARKABLE_PAGE_PARAMETER_NAME);\n        url.append('=');\n                url.append(pageMapName + Component.PATH_SEPARATOR + pageClass.getName());\n    }\n        final PageParameters parameters = requestTarget.getPageParameters();\n    if (parameters != null) {\n        for (final Iterator iterator = parameters.keySet().iterator(); iterator.hasNext(); ) {\n            final String key = (String) iterator.next();\n            final String value = parameters.getString(key);\n            if (value != null) {\n                String escapedValue = value;\n                try {\n                    escapedValue = URLEncoder.encode(escapedValue, application.getRequestCycleSettings().getResponseRequestEncoding());\n                } catch (UnsupportedEncodingException ex) {\n                    log.error(ex.getMessage(), ex);\n                }\n                if (!firstParameter) {\n                    url.append('&');\n                } else {\n                    firstParameter = false;\n                    url.append('?');\n                }\n                url.append(key);\n                url.append('=');\n                url.append(escapedValue);\n            }\n        }\n    }\n    return requestCycle.getOriginalResponse().encodeURL(url);\n}", "lc": 1.8181818181818181, "pi": 1.2679425837320573, "ma": 1.2, "nbd": 1.0, "ml": 1.1666666666666667, "d": 0.8849206349206349, "mi": -0.9315010570824522, "fo": 2.5, "r": -0.02631578947368421, "e": 2.95112693994456}
{"project_name": "Csv", "project_version": 13, "label": 3, "code": "private void print(final Object object, final CharSequence value, final int offset, final int len) throws IOException {\n    if (!newRecord) {\n        out.append(format.getDelimiter());\n    }\n    if (format.isQuoteCharacterSet()) {\n        // the original object is needed so can check for Number\n        printAndQuote(object, value, offset, len);\n    } else if (format.isEscapeCharacterSet()) {\n        printAndEscape(value, offset, len);\n    } else {\n        out.append(value, offset, offset + len);\n    }\n    newRecord = false;\n}", "code_comment": NaN, "code_no_comment": "private void print(final Object object, final CharSequence value, final int offset, final int len) throws IOException {\n    if (!newRecord) {\n        out.append(format.getDelimiter());\n    }\n    if (format.isQuoteCharacterSet()) {\n                printAndQuote(object, value, offset, len);\n    } else if (format.isEscapeCharacterSet()) {\n        printAndEscape(value, offset, len);\n    } else {\n        out.append(value, offset, offset + len);\n    }\n    newRecord = false;\n}", "lc": -0.045454545454545456, "pi": -0.16267942583732073, "ma": 0.0, "nbd": 0.0, "ml": 0.08333333333333333, "d": 0.0, "mi": 0.028047921071177005, "fo": 0.08333333333333333, "r": -0.02631578947368421, "e": -0.01887703647355105}
{"project_name": "Closure", "project_version": 49, "label": 3, "code": "@Override\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.FUNCTION:\n            {\n                // Add recursive function name, if needed.\n                // NOTE: \"enterScope\" is called after we need to pick up this name.\n                Renamer renamer = nameStack.peek().forChildScope();\n                // If needed, add the function recursive name.\n                String name = n.getFirstChild().getString();\n                if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) {\n                    renamer.addDeclaredName(name);\n                }\n                // Add the function parameters\n                // Add the function body declarations\n                nameStack.push(renamer);\n            }\n            break;\n        case Token.CATCH:\n            {\n                Renamer renamer = nameStack.peek().forChildScope();\n                String name = n.getFirstChild().getString();\n                renamer.addDeclaredName(name);\n                nameStack.push(renamer);\n            }\n            break;\n    }\n    return true;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.FUNCTION:\n            {\n                                                Renamer renamer = nameStack.peek().forChildScope();\n                                String name = n.getFirstChild().getString();\n                if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) {\n                    renamer.addDeclaredName(name);\n                }\n                                                nameStack.push(renamer);\n            }\n            break;\n        case Token.CATCH:\n            {\n                Renamer renamer = nameStack.peek().forChildScope();\n                String name = n.getFirstChild().getString();\n                renamer.addDeclaredName(name);\n                nameStack.push(renamer);\n            }\n            break;\n    }\n    return true;\n}", "lc": 0.45454545454545453, "pi": 1.401913875598086, "ma": 0.4, "nbd": 0.5, "ml": 0.5833333333333334, "d": 0.44246031746031755, "mi": -0.36687808315715287, "fo": 0.75, "r": -0.02631578947368421, "e": 0.4754113287575709}
{"project_name": "maven", "project_version": "remotes/origin/bugs-dot-jar_MNG-4915_1c3abfba", "label": 1, "code": "private boolean validatePluginVersion(String fieldName, ModelProblemCollector problems, String string, String sourceHint, InputLocationTracker tracker, ModelBuildingRequest request) {\n    Severity errOn30 = getSeverity(request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0);\n    if (string == null) {\n        // NOTE: The check for missing plugin versions is handled directly by the model builder\n        return true;\n    }\n    if (string.length() > 0 && !hasExpression(string) && !\"RELEASE\".equals(string) && !\"LATEST\".equals(string)) {\n        return true;\n    }\n    addViolation(problems, errOn30, fieldName, sourceHint, \"must be a valid version but is '\" + string + \"'.\", tracker);\n    return false;\n}", "code_comment": NaN, "code_no_comment": "private boolean validatePluginVersion(String fieldName, ModelProblemCollector problems, String string, String sourceHint, InputLocationTracker tracker, ModelBuildingRequest request) {\n    Severity errOn30 = getSeverity(request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0);\n    if (string == null) {\n                return true;\n    }\n    if (string.length() > 0 && !hasExpression(string) && !\"RELEASE\".equals(string) && !\"LATEST\".equals(string)) {\n        return true;\n    }\n    addViolation(problems, errOn30, fieldName, sourceHint, \"must be a valid version but is '\" + string + \"'.\", tracker);\n    return false;\n}", "lc": -0.13636363636363635, "pi": -0.2775119617224881, "ma": -0.2, "nbd": -0.5, "ml": 0.4166666666666667, "d": 0.5912698412698414, "mi": 0.037350246652572305, "fo": 0.0, "r": -0.02631578947368421, "e": 0.4591829325219134}
{"project_name": "Math", "project_version": 89, "label": 1, "code": "/**\n * Adds 1 to the frequency count for v.\n * <p>\n * If other objects have already been added to this Frequency, v must\n * be comparable to those that have already been added.\n * </p>\n *\n * @param v the value to add.\n * @throws IllegalArgumentException if <code>v</code> is not Comparable,\n *         or is not comparable with previous entries\n * @deprecated use {@link #addValue(Comparable)} instead\n */\n@Deprecated\npublic void addValue(Object v) {\n    addValue((Comparable<?>) v);\n}", "code_comment": "/**\n * Adds 1 to the frequency count for v.\n * <p>\n * If other objects have already been added to this Frequency, v must\n * be comparable to those that have already been added.\n * </p>\n *\n * @param v the value to add.\n * @throws IllegalArgumentException if <code>v</code> is not Comparable,\n *         or is not comparable with previous entries\n * @deprecated use {@link #addValue(Comparable)} instead\n */\n", "code_no_comment": "@Deprecated\npublic void addValue(Object v) {\n    addValue((Comparable<?>) v);\n}", "lc": -0.45454545454545453, "pi": -0.6028708133971293, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.8940098661028892, "fo": -0.4166666666666667, "r": 2.5, "e": -0.16279340490885932}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-3394_18e1a142", "label": 3, "code": "public boolean process(Exchange exchange, AsyncCallback callback) {\n    final AtomicExchange result = new AtomicExchange();\n    final Iterable<ProcessorExchangePair> pairs;\n    // so use try .. catch to cater for this\n    try {\n        boolean sync = true;\n        pairs = createProcessorExchangePairs(exchange);\n        if (isParallelProcessing()) {\n            // ensure an executor is set when running in parallel\n            ObjectHelper.notNull(executorService, \"executorService\", this);\n            doProcessParallel(exchange, result, pairs, isStreaming(), callback);\n        } else {\n            sync = doProcessSequential(exchange, result, pairs, callback);\n        }\n        if (!sync) {\n            // so we break out now, then the callback will be invoked which then continue routing from where we left here\n            return false;\n        }\n    } catch (Throwable e) {\n        exchange.setException(e);\n        // and do the done work\n        doDone(exchange, null, callback, true);\n        return true;\n    }\n    // multicasting was processed successfully\n    // and do the done work\n    Exchange subExchange = result.get() != null ? result.get() : null;\n    doDone(exchange, subExchange, callback, true);\n    return true;\n}", "code_comment": NaN, "code_no_comment": "public boolean process(Exchange exchange, AsyncCallback callback) {\n    final AtomicExchange result = new AtomicExchange();\n    final Iterable<ProcessorExchangePair> pairs;\n        try {\n        boolean sync = true;\n        pairs = createProcessorExchangePairs(exchange);\n        if (isParallelProcessing()) {\n                        ObjectHelper.notNull(executorService, \"executorService\", this);\n            doProcessParallel(exchange, result, pairs, isStreaming(), callback);\n        } else {\n            sync = doProcessSequential(exchange, result, pairs, callback);\n        }\n        if (!sync) {\n                        return false;\n        }\n    } catch (Throwable e) {\n        exchange.setException(e);\n                doDone(exchange, null, callback, true);\n        return true;\n    }\n            Exchange subExchange = result.get() != null ? result.get() : null;\n    doDone(exchange, subExchange, callback, true);\n    return true;\n}", "lc": 0.45454545454545453, "pi": 0.1961722488038276, "ma": 0.2, "nbd": 0.0, "ml": 0.08333333333333333, "d": 0.05158730158730159, "mi": -0.36039464411557415, "fo": 0.4166666666666667, "r": -0.02631578947368421, "e": 0.16692426940520846}
{"project_name": "maven", "project_version": "remotes/origin/bugs-dot-jar_MNG-5209_87884c7b", "label": 3, "code": "public List<String> getCompileClasspathElements() throws DependencyResolutionRequiredException {\n    List<String> list = new ArrayList<String>(getArtifacts().size() + 1);\n    list.add(getBuild().getOutputDirectory());\n    for (Artifact a : getArtifacts()) {\n        if (a.getArtifactHandler().isAddedToClasspath()) {\n            // TODO: let the scope handler deal with this\n            if (Artifact.SCOPE_COMPILE.equals(a.getScope()) || Artifact.SCOPE_PROVIDED.equals(a.getScope()) || Artifact.SCOPE_SYSTEM.equals(a.getScope())) {\n                addArtifactPath(a, list);\n            }\n        }\n    }\n    return list;\n}", "code_comment": NaN, "code_no_comment": "public List<String> getCompileClasspathElements() throws DependencyResolutionRequiredException {\n    List<String> list = new ArrayList<String>(getArtifacts().size() + 1);\n    list.add(getBuild().getOutputDirectory());\n    for (Artifact a : getArtifacts()) {\n        if (a.getArtifactHandler().isAddedToClasspath()) {\n                        if (Artifact.SCOPE_COMPILE.equals(a.getScope()) || Artifact.SCOPE_PROVIDED.equals(a.getScope()) || Artifact.SCOPE_SYSTEM.equals(a.getScope())) {\n                addArtifactPath(a, list);\n            }\n        }\n    }\n    return list;\n}", "lc": -0.09090909090909091, "pi": 0.8421052631578947, "ma": 0.0, "nbd": 0.5, "ml": 0.3333333333333333, "d": -0.0019841269841269858, "mi": 0.0319943622269205, "fo": 0.75, "r": 0.0, "e": 0.01528097139860421}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-293_59a0da9c", "label": 1, "code": "/**\n * Returns the offset of the extra decision variable added when there is a\n * negative decision variable in the original problem.\n * @return the offset of x-\n */\nprotected final int getNegativeDecisionVariableOffset() {\n    return getNumObjectiveFunctions() + getOriginalNumDecisionVariables();\n}", "code_comment": "/**\n * Returns the offset of the extra decision variable added when there is a\n * negative decision variable in the original problem.\n * @return the offset of x-\n */\n", "code_no_comment": "protected final int getNegativeDecisionVariableOffset() {\n    return getNumObjectiveFunctions() + getOriginalNumDecisionVariables();\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.1099365750528538, "fo": -0.3333333333333333, "r": 2.6052631578947367, "e": -0.16279340490885932}
{"project_name": "Math", "project_version": 48, "label": 1, "code": "/**\n * {@inheritDoc}\n */\nprotected final double doSolve() {\n    // Get initial solution\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    // regardless of the allowed solutions.\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    // Verify bracketing of initial solution.\n    verifyBracketing(x0, x1);\n    // Get accuracies.\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    // Keep track of inverted intervals, meaning that the left bound is\n    // larger than the right bound.\n    boolean inverted = false;\n    // Keep finding better approximations.\n    while (true) {\n        // Calculate the next approximation.\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        // we can return it regardless of the allowed solutions.\n        if (fx == 0.0) {\n            return x;\n        }\n        // Update the bounds with the new approximation.\n        if (f1 * fx < 0) {\n            // The value of x1 has switched to the other bound, thus inverting\n            // the interval.\n            x0 = x1;\n            f0 = f1;\n            inverted = !inverted;\n        } else {\n            switch(method) {\n                case ILLINOIS:\n                    f0 *= 0.5;\n                    break;\n                case PEGASUS:\n                    f0 *= f1 / (f1 + fx);\n                    break;\n                case REGULA_FALSI:\n                    // for the maximum number of iterations to be exceeded.\n                    break;\n                default:\n                    // Should never happen.\n                    throw new MathInternalError();\n            }\n        }\n        // Update from [x0, x1] to [x0, x].\n        x1 = x;\n        f1 = fx;\n        // the root than we already are.\n        if (FastMath.abs(f1) <= ftol) {\n            switch(allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                case BELOW_SIDE:\n                    if (f1 <= 0) {\n                        return x1;\n                    }\n                    break;\n                case ABOVE_SIDE:\n                    if (f1 >= 0) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n        // are satisfied with the current approximation.\n        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {\n            switch(allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                case BELOW_SIDE:\n                    return (f1 <= 0) ? x1 : x0;\n                case ABOVE_SIDE:\n                    return (f1 >= 0) ? x1 : x0;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n    }\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "protected final double doSolve() {\n        double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n        if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n        verifyBracketing(x0, x1);\n        final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n            boolean inverted = false;\n        while (true) {\n                final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n                if (fx == 0.0) {\n            return x;\n        }\n                if (f1 * fx < 0) {\n                                    x0 = x1;\n            f0 = f1;\n            inverted = !inverted;\n        } else {\n            switch(method) {\n                case ILLINOIS:\n                    f0 *= 0.5;\n                    break;\n                case PEGASUS:\n                    f0 *= f1 / (f1 + fx);\n                    break;\n                case REGULA_FALSI:\n                                        break;\n                default:\n                                        throw new MathInternalError();\n            }\n        }\n                x1 = x;\n        f1 = fx;\n                if (FastMath.abs(f1) <= ftol) {\n            switch(allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                case BELOW_SIDE:\n                    if (f1 <= 0) {\n                        return x1;\n                    }\n                    break;\n                case ABOVE_SIDE:\n                    if (f1 >= 0) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n                if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {\n            switch(allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                case BELOW_SIDE:\n                    return (f1 <= 0) ? x1 : x0;\n                case ABOVE_SIDE:\n                    return (f1 >= 0) ? x1 : x0;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n    }\n}", "lc": 3.3636363636363638, "pi": 1.727272727272727, "ma": 7.6, "nbd": 1.5, "ml": 3.1666666666666665, "d": 2.8194444444444446, "mi": -1.3371388301620857, "fo": 0.5833333333333334, "r": -0.02631578947368421, "e": 6.527303008823037}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-9032_108d94f7", "label": 1, "code": "/**\n * Validates whether the given method is a valid candidate for Camel Bean Binding.\n *\n * @param clazz   the class\n * @param method  the method\n * @return true if valid, false to skip the method\n */\nprotected boolean isValidMethod(Class<?> clazz, Method method) {\n    // must not be in the excluded list\n    for (Method excluded : EXCLUDED_METHODS) {\n        if (ObjectHelper.isOverridingMethod(excluded, method)) {\n            // the method is overriding an excluded method so its not valid\n            return false;\n        }\n    }\n    // must be a public method\n    if (!Modifier.isPublic(method.getModifiers())) {\n        return false;\n    }\n    // must not be abstract\n    if (Modifier.isAbstract(method.getModifiers())) {\n        return false;\n    }\n    // return type must not be an Exchange and it should not be a bridge method\n    if ((method.getReturnType() != null && Exchange.class.isAssignableFrom(method.getReturnType())) || method.isBridge()) {\n        return false;\n    }\n    return true;\n}", "code_comment": "/**\n * Validates whether the given method is a valid candidate for Camel Bean Binding.\n *\n * @param clazz   the class\n * @param method  the method\n * @return true if valid, false to skip the method\n */\n", "code_no_comment": "protected boolean isValidMethod(Class<?> clazz, Method method) {\n        for (Method excluded : EXCLUDED_METHODS) {\n        if (ObjectHelper.isOverridingMethod(excluded, method)) {\n                        return false;\n        }\n    }\n        if (!Modifier.isPublic(method.getModifiers())) {\n        return false;\n    }\n        if (Modifier.isAbstract(method.getModifiers())) {\n        return false;\n    }\n        if ((method.getReturnType() != null && Exchange.class.isAssignableFrom(method.getReturnType())) || method.isBridge()) {\n        return false;\n    }\n    return true;\n}", "lc": 0.13636363636363635, "pi": 0.0, "ma": 0.4, "nbd": 0.0, "ml": 0.8333333333333334, "d": 0.29563492063492064, "mi": -0.11712473572938689, "fo": 0.25, "r": -0.02631578947368421, "e": 0.11553281121234649}
{"project_name": "Closure", "project_version": 149, "label": 2, "code": "/**\n * Sets options based on the configurations set flags API.\n * Called during the run() run() method.\n * If you want to ignore the flags API, or intepret flags your own way,\n * then you should override this method.\n */\nprotected final void setRunOptions(CompilerOptions options) throws FlagUsageException, IOException {\n    DiagnosticGroups diagnosticGroups = getDiagnosticGroups();\n    diagnosticGroups.setWarningLevels(options, config.jscompError, CheckLevel.ERROR);\n    diagnosticGroups.setWarningLevels(options, config.jscompWarning, CheckLevel.WARNING);\n    diagnosticGroups.setWarningLevels(options, config.jscompOff, CheckLevel.OFF);\n    createDefineReplacements(config.define, options);\n    options.manageClosureDependencies = config.manageClosureDependencies;\n    options.devMode = config.jscompDevMode;\n    options.setCodingConvention(config.codingConvention);\n    options.setSummaryDetailLevel(config.summaryDetailLevel);\n    inputCharset = getInputCharset();\n    if (config.jsOutputFile.length() > 0) {\n        options.jsOutputFile = config.jsOutputFile;\n    }\n    if (config.createSourceMap.length() > 0) {\n        options.sourceMapOutputPath = config.createSourceMap;\n    }\n    options.sourceMapDetailLevel = config.sourceMapDetailLevel;\n    if (!config.variableMapInputFile.equals(\"\")) {\n        options.inputVariableMapSerialized = VariableMap.load(config.variableMapInputFile).toBytes();\n    }\n    if (!config.propertyMapInputFile.equals(\"\")) {\n        options.inputPropertyMapSerialized = VariableMap.load(config.propertyMapInputFile).toBytes();\n    }\n}", "code_comment": "/**\n * Sets options based on the configurations set flags API.\n * Called during the run() run() method.\n * If you want to ignore the flags API, or intepret flags your own way,\n * then you should override this method.\n */\n", "code_no_comment": "protected final void setRunOptions(CompilerOptions options) throws FlagUsageException, IOException {\n    DiagnosticGroups diagnosticGroups = getDiagnosticGroups();\n    diagnosticGroups.setWarningLevels(options, config.jscompError, CheckLevel.ERROR);\n    diagnosticGroups.setWarningLevels(options, config.jscompWarning, CheckLevel.WARNING);\n    diagnosticGroups.setWarningLevels(options, config.jscompOff, CheckLevel.OFF);\n    createDefineReplacements(config.define, options);\n    options.manageClosureDependencies = config.manageClosureDependencies;\n    options.devMode = config.jscompDevMode;\n    options.setCodingConvention(config.codingConvention);\n    options.setSummaryDetailLevel(config.summaryDetailLevel);\n    inputCharset = getInputCharset();\n    if (config.jsOutputFile.length() > 0) {\n        options.jsOutputFile = config.jsOutputFile;\n    }\n    if (config.createSourceMap.length() > 0) {\n        options.sourceMapOutputPath = config.createSourceMap;\n    }\n    options.sourceMapDetailLevel = config.sourceMapDetailLevel;\n    if (!config.variableMapInputFile.equals(\"\")) {\n        options.inputVariableMapSerialized = VariableMap.load(config.variableMapInputFile).toBytes();\n    }\n    if (!config.propertyMapInputFile.equals(\"\")) {\n        options.inputPropertyMapSerialized = VariableMap.load(config.propertyMapInputFile).toBytes();\n    }\n}", "lc": 0.5, "pi": -0.5071770334928232, "ma": 0.2, "nbd": -0.5, "ml": 0.25, "d": 0.059523809523809534, "mi": -0.46102889358703314, "fo": 0.8333333333333334, "r": -0.02631578947368421, "e": 0.4225952755542492}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-2742_1f7dd2d5", "label": 1, "code": "@Override\npublic String next() {\n    return super.next().toString();\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic String next() {\n    return super.next().toString();\n}", "lc": -0.45454545454545453, "pi": -0.6028708133971293, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.9517970401691334, "fo": -0.3333333333333333, "r": 1.4999999999999998, "e": -0.16279340490885932}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-185_7fe28a0e", "label": 3, "code": "/**\n * @see Node#setProperty(String, javax.jcr.Value, int)\n */\n@Override\n@Nonnull\npublic Property setProperty(String jcrName, Value value, int type) throws RepositoryException {\n    checkStatus();\n    int targetType = getTargetType(value, type);\n    Value targetValue = ValueHelper.convert(value, targetType, getValueFactory());\n    if (value == null) {\n        Property p = getProperty(jcrName);\n        p.remove();\n        return p;\n    } else {\n        String oakName = sessionDelegate.getOakPathOrThrow(jcrName);\n        CoreValue oakValue = ValueConverter.toCoreValue(targetValue, sessionDelegate);\n        return new PropertyImpl(dlg.setProperty(oakName, oakValue));\n    }\n}", "code_comment": "/**\n * @see Node#setProperty(String, javax.jcr.Value, int)\n */\n", "code_no_comment": "@Override\n@Nonnull\npublic Property setProperty(String jcrName, Value value, int type) throws RepositoryException {\n    checkStatus();\n    int targetType = getTargetType(value, type);\n    Value targetValue = ValueHelper.convert(value, targetType, getValueFactory());\n    if (value == null) {\n        Property p = getProperty(jcrName);\n        p.remove();\n        return p;\n    } else {\n        String oakName = sessionDelegate.getOakPathOrThrow(jcrName);\n        CoreValue oakValue = ValueConverter.toCoreValue(targetValue, sessionDelegate);\n        return new PropertyImpl(dlg.setProperty(oakName, oakValue));\n    }\n}", "lc": 0.09090909090909091, "pi": 0.06220095693779899, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": -0.05753968253968254, "mi": -0.12332628611698376, "fo": 0.25, "r": 0.0, "e": 0.031661508848971}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-1677_01a3dd66", "label": 1, "code": "/**\n *  @see org.apache.wicket.ajax.AbstractDefaultAjaxBehavior#renderHead(org.apache.wicket.markup.html.IHeaderResponse)\n */\n@Override\npublic void renderHead(IHeaderResponse response) {\n    super.renderHead(response);\n    AppendingStringBuffer asb = new AppendingStringBuffer();\n    asb.append(\"function attachChoiceHandlers(markupId, callbackScript) {\\n\");\n    asb.append(\" var inputNodes = wicketGet(markupId).getElementsByTagName('input');\\n\");\n    asb.append(\" for (var i = 0 ; i < inputNodes.length ; i ++) {\\n\");\n    asb.append(\" var inputNode = inputNodes[i];\\n\");\n    asb.append(\" if (!inputNode.type) continue;\\n\");\n    asb.append(\" var inputType = inputNode.type.toLowerCase();\\n\");\n    asb.append(\" if (inputType == 'checkbox' || inputType == 'radio') {\\n\");\n    asb.append(\" Wicket.Event.add(inputNode, 'click', callbackScript);\\n\");\n    asb.append(\" }\\n\");\n    asb.append(\" }\\n\");\n    asb.append(\"}\\n\");\n    response.renderJavascript(asb, \"attachChoice\");\n    response.renderOnLoadJavascript(\"attachChoiceHandlers('\" + getComponent().getMarkupId() + \"', function() {\" + getEventHandler() + \"});\");\n}", "code_comment": "/**\n *  @see org.apache.wicket.ajax.AbstractDefaultAjaxBehavior#renderHead(org.apache.wicket.markup.html.IHeaderResponse)\n */\n", "code_no_comment": "@Override\npublic void renderHead(IHeaderResponse response) {\n    super.renderHead(response);\n    AppendingStringBuffer asb = new AppendingStringBuffer();\n    asb.append(\"function attachChoiceHandlers(markupId, callbackScript) {\\n\");\n    asb.append(\" var inputNodes = wicketGet(markupId).getElementsByTagName('input');\\n\");\n    asb.append(\" for (var i = 0 ; i < inputNodes.length ; i ++) {\\n\");\n    asb.append(\" var inputNode = inputNodes[i];\\n\");\n    asb.append(\" if (!inputNode.type) continue;\\n\");\n    asb.append(\" var inputType = inputNode.type.toLowerCase();\\n\");\n    asb.append(\" if (inputType == 'checkbox' || inputType == 'radio') {\\n\");\n    asb.append(\" Wicket.Event.add(inputNode, 'click', callbackScript);\\n\");\n    asb.append(\" }\\n\");\n    asb.append(\" }\\n\");\n    asb.append(\"}\\n\");\n    response.renderJavascript(asb, \"attachChoice\");\n    response.renderOnLoadJavascript(\"attachChoiceHandlers('\" + getComponent().getMarkupId() + \"', function() {\" + getEventHandler() + \"});\");\n}", "lc": 0.18181818181818182, "pi": -0.7177033492822968, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": 0.03968253968253967, "mi": -0.1732205778717405, "fo": 0.9166666666666666, "r": -0.02631578947368421, "e": 0.09726203442771275}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-614_6feacf6b", "label": 1, "code": "/**\n * Determine whether this child has been removed.\n * Assumes {@code read()}, {@code write()} needs not be called.\n * @return  {@code true} iff this child has been removed\n */\nprivate boolean removed() {\n    return !isRoot() && parent.writeState != null && parent.hasBaseState(name) && !parent.writeState.hasChildNode(name);\n}", "code_comment": "/**\n * Determine whether this child has been removed.\n * Assumes {@code read()}, {@code write()} needs not be called.\n * @return  {@code true} iff this child has been removed\n */\n", "code_no_comment": "private boolean removed() {\n    return !isRoot() && parent.writeState != null && parent.hasBaseState(name) && !parent.writeState.hasChildNode(name);\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.07936507936507939, "mi": 0.8505990133897112, "fo": -0.25, "r": 2.5, "e": -0.11743227122629277}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4696_f5f802c5", "label": 1, "code": "/**\n *  Returns the minimum value for the numberType's type\n *\n *  @param numberType\n *             the type of the number for which the minimum value will be returned\n *  @return the minimum value of the numberType or {@value Double#MIN_VALUE} if the numberType\n *          itself is either {@code null} or has no minimum value\n */\npublic static Number getMinValue(Class<? extends Number> numberType) {\n    Number result;\n    if (Integer.class == numberType || int.class == numberType) {\n        result = Integer.MIN_VALUE;\n    } else if (Long.class == numberType || long.class == numberType) {\n        result = Long.MIN_VALUE;\n    } else if (Float.class == numberType || float.class == numberType) {\n        result = Float.MIN_VALUE;\n    } else if (Double.class == numberType || double.class == numberType) {\n        result = Double.MIN_VALUE;\n    } else if (Byte.class == numberType || byte.class == numberType) {\n        result = Byte.MIN_VALUE;\n    } else if (Short.class == numberType || short.class == numberType) {\n        result = Short.MIN_VALUE;\n    } else {\n        // null of any other Number\n        LOG.debug(\"'{}' has no minimum value. Falling back to Double.MIN_VALUE.\", numberType);\n        result = Double.MIN_VALUE;\n    }\n    return result;\n}", "code_comment": "/**\n *  Returns the minimum value for the numberType's type\n *\n *  @param numberType\n *             the type of the number for which the minimum value will be returned\n *  @return the minimum value of the numberType or {@value Double#MIN_VALUE} if the numberType\n *          itself is either {@code null} or has no minimum value\n */\n", "code_no_comment": "public static Number getMinValue(Class<? extends Number> numberType) {\n    Number result;\n    if (Integer.class == numberType || int.class == numberType) {\n        result = Integer.MIN_VALUE;\n    } else if (Long.class == numberType || long.class == numberType) {\n        result = Long.MIN_VALUE;\n    } else if (Float.class == numberType || float.class == numberType) {\n        result = Float.MIN_VALUE;\n    } else if (Double.class == numberType || double.class == numberType) {\n        result = Double.MIN_VALUE;\n    } else if (Byte.class == numberType || byte.class == numberType) {\n        result = Byte.MIN_VALUE;\n    } else if (Short.class == numberType || short.class == numberType) {\n        result = Short.MIN_VALUE;\n    } else {\n                LOG.debug(\"'{}' has no minimum value. Falling back to Double.MIN_VALUE.\", numberType);\n        result = Double.MIN_VALUE;\n    }\n    return result;\n}", "lc": 0.2727272727272727, "pi": -0.20574162679425848, "ma": 0.6, "nbd": 2.0, "ml": 0.6666666666666666, "d": 0.27976190476190477, "mi": -0.2845665961945031, "fo": -0.4166666666666667, "r": -0.02631578947368421, "e": 0.32730416140799773}
{"project_name": "Closure", "project_version": 18, "label": 2, "code": "// ------------------------------------------------------------------------\n// Parsing\n// ------------------------------------------------------------------------\n/**\n * Parses the externs and main inputs.\n *\n * @return A synthetic root node whose two children are the externs root\n *     and the main root\n */\nNode parseInputs() {\n    boolean devMode = options.devMode != DevMode.OFF;\n    // individual file parse trees.\n    if (externsRoot != null) {\n        externsRoot.detachChildren();\n    }\n    if (jsRoot != null) {\n        jsRoot.detachChildren();\n    }\n    // Parse main JS sources.\n    jsRoot = IR.block();\n    jsRoot.setIsSyntheticBlock(true);\n    externsRoot = IR.block();\n    externsRoot.setIsSyntheticBlock(true);\n    externAndJsRoot = IR.block(externsRoot, jsRoot);\n    externAndJsRoot.setIsSyntheticBlock(true);\n    if (options.tracer.isOn()) {\n        tracker = new PerformanceTracker(jsRoot, options.tracer);\n        addChangeHandler(tracker.getCodeChangeHandler());\n    }\n    Tracer tracer = newTracer(\"parseInputs\");\n    try {\n        // Parse externs sources.\n        for (CompilerInput input : externs) {\n            Node n = input.getAstRoot(this);\n            if (hasErrors()) {\n                return null;\n            }\n            externsRoot.addChildToBack(n);\n        }\n        // Modules inferred in ProcessCommonJS pass.\n        if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n            processAMDAndCommonJSModules();\n        }\n        hoistExterns(externsRoot);\n        // Check if the sources need to be re-ordered.\n        boolean staleInputs = false;\n        if (options.dependencyOptions.needsManagement() && options.closurePass) {\n            for (CompilerInput input : inputs) {\n                // are not flagged even if they are dropped from the process.\n                for (String provide : input.getProvides()) {\n                    getTypeRegistry().forwardDeclareType(provide);\n                }\n            }\n            try {\n                inputs = (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph).manageDependencies(options.dependencyOptions, inputs);\n                staleInputs = true;\n            } catch (CircularDependencyException e) {\n                report(JSError.make(JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n                // If in IDE mode, we ignore the error and keep going.\n                if (hasErrors()) {\n                    return null;\n                }\n            } catch (MissingProvideException e) {\n                report(JSError.make(MISSING_ENTRY_ERROR, e.getMessage()));\n                // If in IDE mode, we ignore the error and keep going.\n                if (hasErrors()) {\n                    return null;\n                }\n            }\n        }\n        hoistNoCompileFiles();\n        if (staleInputs) {\n            repartitionInputs();\n        }\n        // Build the AST.\n        for (CompilerInput input : inputs) {\n            Node n = input.getAstRoot(this);\n            if (n == null) {\n                continue;\n            }\n            if (devMode) {\n                runSanityCheck();\n                if (hasErrors()) {\n                    return null;\n                }\n            }\n            if (options.sourceMapOutputPath != null || options.nameReferenceReportPath != null) {\n                // Annotate the nodes in the tree with information from the\n                // input file. This information is used to construct the SourceMap.\n                SourceInformationAnnotator sia = new SourceInformationAnnotator(input.getName(), options.devMode != DevMode.OFF);\n                NodeTraversal.traverse(this, n, sia);\n            }\n            jsRoot.addChildToBack(n);\n        }\n        if (hasErrors()) {\n            return null;\n        }\n        return externAndJsRoot;\n    } finally {\n        stopTracer(tracer, \"parseInputs\");\n    }\n}", "code_comment": "/**\n * Parses the externs and main inputs.\n *\n * @return A synthetic root node whose two children are the externs root\n *     and the main root\n */\n", "code_no_comment": "Node parseInputs() {\n    boolean devMode = options.devMode != DevMode.OFF;\n        if (externsRoot != null) {\n        externsRoot.detachChildren();\n    }\n    if (jsRoot != null) {\n        jsRoot.detachChildren();\n    }\n        jsRoot = IR.block();\n    jsRoot.setIsSyntheticBlock(true);\n    externsRoot = IR.block();\n    externsRoot.setIsSyntheticBlock(true);\n    externAndJsRoot = IR.block(externsRoot, jsRoot);\n    externAndJsRoot.setIsSyntheticBlock(true);\n    if (options.tracer.isOn()) {\n        tracker = new PerformanceTracker(jsRoot, options.tracer);\n        addChangeHandler(tracker.getCodeChangeHandler());\n    }\n    Tracer tracer = newTracer(\"parseInputs\");\n    try {\n                for (CompilerInput input : externs) {\n            Node n = input.getAstRoot(this);\n            if (hasErrors()) {\n                return null;\n            }\n            externsRoot.addChildToBack(n);\n        }\n                if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n            processAMDAndCommonJSModules();\n        }\n        hoistExterns(externsRoot);\n                boolean staleInputs = false;\n        if (options.dependencyOptions.needsManagement() && options.closurePass) {\n            for (CompilerInput input : inputs) {\n                                for (String provide : input.getProvides()) {\n                    getTypeRegistry().forwardDeclareType(provide);\n                }\n            }\n            try {\n                inputs = (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph).manageDependencies(options.dependencyOptions, inputs);\n                staleInputs = true;\n            } catch (CircularDependencyException e) {\n                report(JSError.make(JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n                                if (hasErrors()) {\n                    return null;\n                }\n            } catch (MissingProvideException e) {\n                report(JSError.make(MISSING_ENTRY_ERROR, e.getMessage()));\n                                if (hasErrors()) {\n                    return null;\n                }\n            }\n        }\n        hoistNoCompileFiles();\n        if (staleInputs) {\n            repartitionInputs();\n        }\n                for (CompilerInput input : inputs) {\n            Node n = input.getAstRoot(this);\n            if (n == null) {\n                continue;\n            }\n            if (devMode) {\n                runSanityCheck();\n                if (hasErrors()) {\n                    return null;\n                }\n            }\n            if (options.sourceMapOutputPath != null || options.nameReferenceReportPath != null) {\n                                                SourceInformationAnnotator sia = new SourceInformationAnnotator(input.getName(), options.devMode != DevMode.OFF);\n                NodeTraversal.traverse(this, n, sia);\n            }\n            jsRoot.addChildToBack(n);\n        }\n        if (hasErrors()) {\n            return null;\n        }\n        return externAndJsRoot;\n    } finally {\n        stopTracer(tracer, \"parseInputs\");\n    }\n}", "lc": 3.090909090909091, "pi": 0.923444976076555, "ma": 3.8, "nbd": 1.0, "ml": 2.25, "d": 0.5515873015873016, "mi": -1.2193093727977444, "fo": 2.8333333333333335, "r": -0.02631578947368421, "e": 2.3256421338957947}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-4166_374e3f3d", "label": 1, "code": "/**\n * Copies the full content from the source to the target repository.\n * <p>\n * The source repository <strong>must not be modified</strong> while\n * the copy operation is running to avoid an inconsistent copy.\n * <p>\n * Note that both the source and the target repository must be closed\n * during the copy operation as this method requires exclusive access\n * to the repositories.\n *\n * @param initializer optional extra repository initializer to use\n * @throws RepositoryException if the copy operation fails\n */\npublic void copy(RepositoryInitializer initializer) throws RepositoryException {\n    RepositoryConfig config = source.getRepositoryConfig();\n    logger.info(\"Copying repository content from {} to Oak\", config.getHomeDir());\n    try {\n        NodeBuilder targetBuilder = target.getRoot().builder();\n        final Root upgradeRoot = new UpgradeRoot(targetBuilder);\n        String workspaceName = source.getRepositoryConfig().getDefaultWorkspaceName();\n        SecurityProviderImpl security = new SecurityProviderImpl(mapSecurityConfig(config.getSecurityConfig()));\n        // init target repository first\n        logger.info(\"Initializing initial repository content from {}\", config.getHomeDir());\n        new InitialContent().initialize(targetBuilder);\n        if (initializer != null) {\n            initializer.initialize(targetBuilder);\n        }\n        logger.debug(\"InitialContent completed from {}\", config.getHomeDir());\n        for (SecurityConfiguration sc : security.getConfigurations()) {\n            RepositoryInitializer ri = sc.getRepositoryInitializer();\n            ri.initialize(targetBuilder);\n            logger.debug(\"Repository initializer '\" + ri.getClass().getName() + \"' completed\", config.getHomeDir());\n        }\n        for (SecurityConfiguration sc : security.getConfigurations()) {\n            WorkspaceInitializer wi = sc.getWorkspaceInitializer();\n            wi.initialize(targetBuilder, workspaceName);\n            logger.debug(\"Workspace initializer '\" + wi.getClass().getName() + \"' completed\", config.getHomeDir());\n        }\n        HashBiMap<String, String> uriToPrefix = HashBiMap.create();\n        logger.info(\"Copying registered namespaces\");\n        copyNamespaces(targetBuilder, uriToPrefix);\n        logger.debug(\"Namespace registration completed.\");\n        logger.info(\"Copying registered node types\");\n        NodeTypeManager ntMgr = new ReadWriteNodeTypeManager() {\n\n            @Override\n            protected Tree getTypes() {\n                return upgradeRoot.getTree(NODE_TYPES_PATH);\n            }\n\n            @Nonnull\n            @Override\n            protected Root getWriteRoot() {\n                return upgradeRoot;\n            }\n        };\n        copyNodeTypes(ntMgr, new ValueFactoryImpl(upgradeRoot, NamePathMapper.DEFAULT));\n        logger.debug(\"Node type registration completed.\");\n        // migrate privileges\n        logger.info(\"Copying registered privileges\");\n        PrivilegeConfiguration privilegeConfiguration = security.getConfiguration(PrivilegeConfiguration.class);\n        copyCustomPrivileges(privilegeConfiguration.getPrivilegeManager(upgradeRoot, NamePathMapper.DEFAULT));\n        logger.debug(\"Privilege registration completed.\");\n        // Triggers compilation of type information, which we need for\n        // the type predicates used by the bulk  copy operations below.\n        new TypeEditorProvider(false).getRootEditor(targetBuilder.getBaseState(), targetBuilder.getNodeState(), targetBuilder, null);\n        final NodeState reportingSourceRoot = ReportingNodeState.wrap(JackrabbitNodeState.createRootNodeState(source, workspaceName, targetBuilder.getNodeState(), uriToPrefix, copyBinariesByReference, skipOnError), new LoggingReporter(logger, \"Migrating\", 10000, -1));\n        final NodeState sourceRoot;\n        if (skipLongNames) {\n            sourceRoot = NameFilteringNodeState.wrap(reportingSourceRoot);\n        } else {\n            sourceRoot = reportingSourceRoot;\n        }\n        final Stopwatch watch = Stopwatch.createStarted();\n        logger.info(\"Copying workspace content\");\n        copyWorkspace(sourceRoot, targetBuilder, workspaceName);\n        // on TarMK this does call triggers the actual copy\n        targetBuilder.getNodeState();\n        logger.info(\"Upgrading workspace content completed in {}s ({})\", watch.elapsed(TimeUnit.SECONDS), watch);\n        if (!versionCopyConfiguration.skipOrphanedVersionsCopy()) {\n            logger.info(\"Copying version storage\");\n            watch.reset().start();\n            copyVersionStorage(sourceRoot, targetBuilder, versionCopyConfiguration);\n            // on TarMK this does call triggers the actual copy\n            targetBuilder.getNodeState();\n            logger.info(\"Version storage copied in {}s ({})\", watch.elapsed(TimeUnit.SECONDS), watch);\n        } else {\n            logger.info(\"Skipping the version storage as the copyOrphanedVersions is set to false\");\n        }\n        watch.reset().start();\n        logger.info(\"Applying default commit hooks\");\n        // TODO: default hooks?\n        List<CommitHook> hooks = newArrayList();\n        UserConfiguration userConf = security.getConfiguration(UserConfiguration.class);\n        String groupsPath = userConf.getParameters().getConfigValue(UserConstants.PARAM_GROUP_PATH, UserConstants.DEFAULT_GROUP_PATH);\n        // hooks specific to the upgrade, need to run first\n        hooks.add(new EditorHook(new CompositeEditorProvider(new RestrictionEditorProvider(), new GroupEditorProvider(groupsPath), // copy referenced version histories\n        new VersionableEditor.Provider(sourceRoot, workspaceName, versionCopyConfiguration), new SameNameSiblingsEditor.Provider())));\n        // security-related hooks\n        for (SecurityConfiguration sc : security.getConfigurations()) {\n            hooks.addAll(sc.getCommitHooks(workspaceName));\n        }\n        if (customCommitHooks != null) {\n            hooks.addAll(customCommitHooks);\n        }\n        // type validation, reference and indexing hooks\n        hooks.add(new EditorHook(new CompositeEditorProvider(createTypeEditorProvider(), createIndexEditorProvider())));\n        target.merge(targetBuilder, new LoggingCompositeHook(hooks, source, overrideEarlyShutdown()), CommitInfo.EMPTY);\n        logger.info(\"Processing commit hooks completed in {}s ({})\", watch.elapsed(TimeUnit.SECONDS), watch);\n        logger.debug(\"Repository upgrade completed.\");\n    } catch (Exception e) {\n        throw new RepositoryException(\"Failed to copy content\", e);\n    }\n}", "code_comment": "/**\n * Copies the full content from the source to the target repository.\n * <p>\n * The source repository <strong>must not be modified</strong> while\n * the copy operation is running to avoid an inconsistent copy.\n * <p>\n * Note that both the source and the target repository must be closed\n * during the copy operation as this method requires exclusive access\n * to the repositories.\n *\n * @param initializer optional extra repository initializer to use\n * @throws RepositoryException if the copy operation fails\n */\n", "code_no_comment": "public void copy(RepositoryInitializer initializer) throws RepositoryException {\n    RepositoryConfig config = source.getRepositoryConfig();\n    logger.info(\"Copying repository content from {} to Oak\", config.getHomeDir());\n    try {\n        NodeBuilder targetBuilder = target.getRoot().builder();\n        final Root upgradeRoot = new UpgradeRoot(targetBuilder);\n        String workspaceName = source.getRepositoryConfig().getDefaultWorkspaceName();\n        SecurityProviderImpl security = new SecurityProviderImpl(mapSecurityConfig(config.getSecurityConfig()));\n                logger.info(\"Initializing initial repository content from {}\", config.getHomeDir());\n        new InitialContent().initialize(targetBuilder);\n        if (initializer != null) {\n            initializer.initialize(targetBuilder);\n        }\n        logger.debug(\"InitialContent completed from {}\", config.getHomeDir());\n        for (SecurityConfiguration sc : security.getConfigurations()) {\n            RepositoryInitializer ri = sc.getRepositoryInitializer();\n            ri.initialize(targetBuilder);\n            logger.debug(\"Repository initializer '\" + ri.getClass().getName() + \"' completed\", config.getHomeDir());\n        }\n        for (SecurityConfiguration sc : security.getConfigurations()) {\n            WorkspaceInitializer wi = sc.getWorkspaceInitializer();\n            wi.initialize(targetBuilder, workspaceName);\n            logger.debug(\"Workspace initializer '\" + wi.getClass().getName() + \"' completed\", config.getHomeDir());\n        }\n        HashBiMap<String, String> uriToPrefix = HashBiMap.create();\n        logger.info(\"Copying registered namespaces\");\n        copyNamespaces(targetBuilder, uriToPrefix);\n        logger.debug(\"Namespace registration completed.\");\n        logger.info(\"Copying registered node types\");\n        NodeTypeManager ntMgr = new ReadWriteNodeTypeManager() {\n\n            @Override\n            protected Tree getTypes() {\n                return upgradeRoot.getTree(NODE_TYPES_PATH);\n            }\n\n            @Nonnull\n            @Override\n            protected Root getWriteRoot() {\n                return upgradeRoot;\n            }\n        };\n        copyNodeTypes(ntMgr, new ValueFactoryImpl(upgradeRoot, NamePathMapper.DEFAULT));\n        logger.debug(\"Node type registration completed.\");\n                logger.info(\"Copying registered privileges\");\n        PrivilegeConfiguration privilegeConfiguration = security.getConfiguration(PrivilegeConfiguration.class);\n        copyCustomPrivileges(privilegeConfiguration.getPrivilegeManager(upgradeRoot, NamePathMapper.DEFAULT));\n        logger.debug(\"Privilege registration completed.\");\n                        new TypeEditorProvider(false).getRootEditor(targetBuilder.getBaseState(), targetBuilder.getNodeState(), targetBuilder, null);\n        final NodeState reportingSourceRoot = ReportingNodeState.wrap(JackrabbitNodeState.createRootNodeState(source, workspaceName, targetBuilder.getNodeState(), uriToPrefix, copyBinariesByReference, skipOnError), new LoggingReporter(logger, \"Migrating\", 10000, -1));\n        final NodeState sourceRoot;\n        if (skipLongNames) {\n            sourceRoot = NameFilteringNodeState.wrap(reportingSourceRoot);\n        } else {\n            sourceRoot = reportingSourceRoot;\n        }\n        final Stopwatch watch = Stopwatch.createStarted();\n        logger.info(\"Copying workspace content\");\n        copyWorkspace(sourceRoot, targetBuilder, workspaceName);\n                targetBuilder.getNodeState();\n        logger.info(\"Upgrading workspace content completed in {}s ({})\", watch.elapsed(TimeUnit.SECONDS), watch);\n        if (!versionCopyConfiguration.skipOrphanedVersionsCopy()) {\n            logger.info(\"Copying version storage\");\n            watch.reset().start();\n            copyVersionStorage(sourceRoot, targetBuilder, versionCopyConfiguration);\n                        targetBuilder.getNodeState();\n            logger.info(\"Version storage copied in {}s ({})\", watch.elapsed(TimeUnit.SECONDS), watch);\n        } else {\n            logger.info(\"Skipping the version storage as the copyOrphanedVersions is set to false\");\n        }\n        watch.reset().start();\n        logger.info(\"Applying default commit hooks\");\n                List<CommitHook> hooks = newArrayList();\n        UserConfiguration userConf = security.getConfiguration(UserConfiguration.class);\n        String groupsPath = userConf.getParameters().getConfigValue(UserConstants.PARAM_GROUP_PATH, UserConstants.DEFAULT_GROUP_PATH);\n                hooks.add(new EditorHook(new CompositeEditorProvider(new RestrictionEditorProvider(), new GroupEditorProvider(groupsPath),         new VersionableEditor.Provider(sourceRoot, workspaceName, versionCopyConfiguration), new SameNameSiblingsEditor.Provider())));\n                for (SecurityConfiguration sc : security.getConfigurations()) {\n            hooks.addAll(sc.getCommitHooks(workspaceName));\n        }\n        if (customCommitHooks != null) {\n            hooks.addAll(customCommitHooks);\n        }\n                hooks.add(new EditorHook(new CompositeEditorProvider(createTypeEditorProvider(), createIndexEditorProvider())));\n        target.merge(targetBuilder, new LoggingCompositeHook(hooks, source, overrideEarlyShutdown()), CommitInfo.EMPTY);\n        logger.info(\"Processing commit hooks completed in {}s ({})\", watch.elapsed(TimeUnit.SECONDS), watch);\n        logger.debug(\"Repository upgrade completed.\");\n    } catch (Exception e) {\n        throw new RepositoryException(\"Failed to copy content\", e);\n    }\n}", "lc": 3.409090909090909, "pi": -0.13397129186602882, "ma": 1.2, "nbd": 0.0, "ml": 0.25, "d": 0.4761904761904763, "mi": -1.2816067653276952, "fo": 6.5, "r": -0.02631578947368421, "e": 4.65453225220864}
{"project_name": "Closure", "project_version": 137, "label": 2, "code": "@Override\npublic void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n    removeDuplicateDeclarations(root);\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n        NodeTraversal t = new NodeTraversal(compiler, renamer);\n        t.traverseRoots(externs, root);\n    }\n    // It is important that removeDuplicateDeclarations runs after\n    // MakeDeclaredNamesUnique in order for catch block exception names to be\n    // handled properly. Specifically, catch block exception names are\n    // only valid within the catch block, but our currect Scope logic\n    // has no concept of this and includes it in the containing function\n    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n    // names unique so that removeDuplicateDeclarations() will properly handle\n    // cases where a function scope variable conflict with a exception name:\n    // function f() {\n    // try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n    // var e = 1; // f scope 'e'\n    // }\n    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n    removeDuplicateDeclarations(root);\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n        NodeTraversal t = new NodeTraversal(compiler, renamer);\n        t.traverseRoots(externs, root);\n    }\n                                                            new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n}", "lc": -0.13636363636363635, "pi": -0.01913875598086126, "ma": -0.4, "nbd": -0.5, "ml": -0.3333333333333333, "d": -0.3650793650793651, "mi": 0.12840028188865416, "fo": -0.16666666666666666, "r": 0.0, "e": -0.16279340490885932}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1190_e29dc4f5", "label": 3, "code": "@Override\npublic void update(String writer, Map<ByteBuffer, List<ColumnUpdate>> cells) throws TException {\n    try {\n        BatchWriter batchwriter = writerCache.getIfPresent(UUID.fromString(writer));\n        if (batchwriter == null) {\n            throw new UnknownWriter(\"Writer never existed or no longer exists\");\n        }\n        addCellsToWriter(cells, batchwriter);\n    } catch (Exception e) {\n        throw translateException(e);\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void update(String writer, Map<ByteBuffer, List<ColumnUpdate>> cells) throws TException {\n    try {\n        BatchWriter batchwriter = writerCache.getIfPresent(UUID.fromString(writer));\n        if (batchwriter == null) {\n            throw new UnknownWriter(\"Writer never existed or no longer exists\");\n        }\n        addCellsToWriter(cells, batchwriter);\n    } catch (Exception e) {\n        throw translateException(e);\n    }\n}", "lc": -0.09090909090909091, "pi": 0.3732057416267942, "ma": 0.2, "nbd": 0.0, "ml": -0.25, "d": -0.12500000000000003, "mi": 0.08019732205778712, "fo": -0.16666666666666666, "r": 0.2894736842105263, "e": -0.08161915135169401}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5968_8b7946d8", "label": 1, "code": "@Override\npublic int hashCode() {\n    int result = super.hashCode();\n    result = 31 * result + (extension != null ? extension.hashCode() : 0);\n    return result;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic int hashCode() {\n    int result = super.hashCode();\n    result = 31 * result + (extension != null ? extension.hashCode() : 0);\n    return result;\n}", "lc": -0.36363636363636365, "pi": -0.47368421052631593, "ma": -0.4, "nbd": -1.0, "ml": -0.25, "d": 0.32936507936507936, "mi": 0.5275546159267089, "fo": -0.3333333333333333, "r": 1.2368421052631577, "e": -0.05288290313099704}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-7160_095fa2b4", "label": 1, "code": "// Implementation methods\n// -----------------------------------------------------------------------\nprotected long calculateDelay(Exchange exchange) {\n    // evaluate as Object first to see if we get any result at all\n    Object result = maxRequestsPerPeriodExpression.evaluate(exchange, Object.class);\n    if (result == null) {\n        throw new RuntimeExchangeException(\"The max requests per period expression was evaluated as null: \" + maxRequestsPerPeriodExpression, exchange);\n    }\n    // then must convert value to long\n    Long longValue = exchange.getContext().getTypeConverter().convertTo(Long.class, result);\n    if (longValue != null) {\n        // log if we changed max period after initial setting\n        if (maximumRequestsPerPeriod > 0 && longValue.longValue() != maximumRequestsPerPeriod) {\n            log.debug(\"Throttler changed maximum requests per period from {} to {}\", maximumRequestsPerPeriod, longValue);\n        }\n        maximumRequestsPerPeriod = longValue;\n    }\n    if (maximumRequestsPerPeriod <= 0) {\n        throw new IllegalStateException(\"The maximumRequestsPerPeriod must be a positive number, was: \" + maximumRequestsPerPeriod);\n    }\n    TimeSlot slot = nextSlot();\n    if (!slot.isActive()) {\n        long delay = slot.startTime - currentSystemTime();\n        return delay;\n    } else {\n        return 0;\n    }\n}", "code_comment": NaN, "code_no_comment": "protected long calculateDelay(Exchange exchange) {\n        Object result = maxRequestsPerPeriodExpression.evaluate(exchange, Object.class);\n    if (result == null) {\n        throw new RuntimeExchangeException(\"The max requests per period expression was evaluated as null: \" + maxRequestsPerPeriodExpression, exchange);\n    }\n        Long longValue = exchange.getContext().getTypeConverter().convertTo(Long.class, result);\n    if (longValue != null) {\n                if (maximumRequestsPerPeriod > 0 && longValue.longValue() != maximumRequestsPerPeriod) {\n            log.debug(\"Throttler changed maximum requests per period from {} to {}\", maximumRequestsPerPeriod, longValue);\n        }\n        maximumRequestsPerPeriod = longValue;\n    }\n    if (maximumRequestsPerPeriod <= 0) {\n        throw new IllegalStateException(\"The maximumRequestsPerPeriod must be a positive number, was: \" + maximumRequestsPerPeriod);\n    }\n    TimeSlot slot = nextSlot();\n    if (!slot.isActive()) {\n        long delay = slot.startTime - currentSystemTime();\n        return delay;\n    } else {\n        return 0;\n    }\n}", "lc": 0.4090909090909091, "pi": -0.09569377990430632, "ma": 0.8, "nbd": 0.0, "ml": 0.5, "d": 1.0634920634920635, "mi": -0.37082452431289636, "fo": 0.25, "r": -0.02631578947368421, "e": 1.0477850198532757}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-2487_f2920c26", "label": 0, "code": "/**\n * @param b\n *          Use passed bytes as backing array for this instance.\n */\npublic void set(final byte[] b) {\n    this.value = b;\n}", "code_comment": "/**\n * @param b\n *          Use passed bytes as backing array for this instance.\n */\n", "code_no_comment": "public void set(final byte[] b) {\n    this.value = b;\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.083157152924595, "fo": -0.5, "r": 2.6052631578947367, "e": -0.16279340490885932}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5326_ded3c583", "label": 1, "code": "protected Url decryptUrl(final Request request, final Url encryptedUrl) {\n    /*\n\t\t * If the encrypted URL has no segments it is the home page URL, and does not need\n\t\t * decrypting.\n\t\t */\n    if (encryptedUrl.getSegments().isEmpty()) {\n        return encryptedUrl;\n    }\n    List<String> encryptedSegments = encryptedUrl.getSegments();\n    Url url = new Url(request.getCharset());\n    try {\n        /*\n\t\t\t * The first encrypted segment contains an encrypted version of the entire plain text\n\t\t\t * url.\n\t\t\t */\n        String encryptedUrlString = encryptedSegments.get(0);\n        if (Strings.isEmpty(encryptedUrlString)) {\n            return null;\n        }\n        String decryptedUrl = getCrypt().decryptUrlSafe(encryptedUrlString);\n        if (decryptedUrl == null) {\n            return null;\n        }\n        Url originalUrl = Url.parse(decryptedUrl, request.getCharset());\n        int originalNumberOfSegments = originalUrl.getSegments().size();\n        int encryptedNumberOfSegments = encryptedUrl.getSegments().size();\n        HashedSegmentGenerator generator = new HashedSegmentGenerator(encryptedUrlString);\n        int segNo = 1;\n        for (; segNo < encryptedNumberOfSegments; segNo++) {\n            if (segNo > originalNumberOfSegments) {\n                break;\n            }\n            String next = generator.next();\n            String encryptedSegment = encryptedSegments.get(segNo);\n            if (!next.equals(encryptedSegment)) {\n                /*\n\t\t\t\t\t * This segment received from the browser is not the same as the expected\n\t\t\t\t\t * segment generated by the HashSegmentGenerator. Hence it, and all subsequent\n\t\t\t\t\t * segments are considered plain text siblings of the original encrypted url.\n\t\t\t\t\t */\n                break;\n            }\n            /*\n\t\t\t\t * This segments matches the expected checksum, so we add the corresponding segment\n\t\t\t\t * from the original URL.\n\t\t\t\t */\n            url.getSegments().add(originalUrl.getSegments().get(segNo - 1));\n        }\n        /*\n\t\t\t * Add all remaining segments from the encrypted url as plain text segments.\n\t\t\t */\n        for (; segNo < encryptedNumberOfSegments; segNo++) {\n            // modified or additional segment\n            url.getSegments().add(encryptedUrl.getSegments().get(segNo));\n        }\n        url.getQueryParameters().addAll(originalUrl.getQueryParameters());\n        // WICKET-4923 additional parameters\n        url.getQueryParameters().addAll(encryptedUrl.getQueryParameters());\n    } catch (Exception e) {\n        log.error(\"Error decrypting URL\", e);\n        url = null;\n    }\n    return url;\n}", "code_comment": NaN, "code_no_comment": "protected Url decryptUrl(final Request request, final Url encryptedUrl) {\n        if (encryptedUrl.getSegments().isEmpty()) {\n        return encryptedUrl;\n    }\n    List<String> encryptedSegments = encryptedUrl.getSegments();\n    Url url = new Url(request.getCharset());\n    try {\n                String encryptedUrlString = encryptedSegments.get(0);\n        if (Strings.isEmpty(encryptedUrlString)) {\n            return null;\n        }\n        String decryptedUrl = getCrypt().decryptUrlSafe(encryptedUrlString);\n        if (decryptedUrl == null) {\n            return null;\n        }\n        Url originalUrl = Url.parse(decryptedUrl, request.getCharset());\n        int originalNumberOfSegments = originalUrl.getSegments().size();\n        int encryptedNumberOfSegments = encryptedUrl.getSegments().size();\n        HashedSegmentGenerator generator = new HashedSegmentGenerator(encryptedUrlString);\n        int segNo = 1;\n        for (; segNo < encryptedNumberOfSegments; segNo++) {\n            if (segNo > originalNumberOfSegments) {\n                break;\n            }\n            String next = generator.next();\n            String encryptedSegment = encryptedSegments.get(segNo);\n            if (!next.equals(encryptedSegment)) {\n                                break;\n            }\n                        url.getSegments().add(originalUrl.getSegments().get(segNo - 1));\n        }\n                for (; segNo < encryptedNumberOfSegments; segNo++) {\n                        url.getSegments().add(encryptedUrl.getSegments().get(segNo));\n        }\n        url.getQueryParameters().addAll(originalUrl.getQueryParameters());\n                url.getQueryParameters().addAll(encryptedUrl.getQueryParameters());\n    } catch (Exception e) {\n        log.error(\"Error decrypting URL\", e);\n        url = null;\n    }\n    return url;\n}", "lc": 1.2727272727272727, "pi": 0.2870813397129185, "ma": 1.4, "nbd": 0.5, "ml": 0.9166666666666666, "d": 1.2757936507936507, "mi": -0.7694150810429878, "fo": 2.1666666666666665, "r": -0.02631578947368421, "e": 2.66873440408476}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-5826_a04674f2", "label": 1, "code": "@Override\nString getNext(boolean first) {\n    String next = scanner.next();\n    if (next == null) {\n        return null;\n    }\n    // initialize inherited namespaces on first\n    if (first && inheritNamespaceToken != null) {\n        rootTokenNamespaces = getNamespacesFromNamespaceToken(next);\n    }\n    // make sure next is positioned at start token as we can have leading data\n    // or we reached EOL and there is no more start tags\n    Matcher matcher = startTokenPattern.matcher(next);\n    if (!matcher.find()) {\n        return null;\n    } else {\n        int index = matcher.start();\n        next = next.substring(index);\n    }\n    // build answer accordingly to whether namespaces should be inherited or not\n    StringBuilder sb = new StringBuilder();\n    if (inheritNamespaceToken != null && rootTokenNamespaces != null) {\n        // append root namespaces to local start token\n        String tag = ObjectHelper.before(next, \">\");\n        // grab the text\n        String text = ObjectHelper.after(next, \">\");\n        // build result with inherited namespaces\n        next = sb.append(tag).append(rootTokenNamespaces).append(\">\").append(text).append(endToken).toString();\n    } else {\n        next = sb.append(next).append(endToken).toString();\n    }\n    return next;\n}", "code_comment": NaN, "code_no_comment": "@Override\nString getNext(boolean first) {\n    String next = scanner.next();\n    if (next == null) {\n        return null;\n    }\n        if (first && inheritNamespaceToken != null) {\n        rootTokenNamespaces = getNamespacesFromNamespaceToken(next);\n    }\n            Matcher matcher = startTokenPattern.matcher(next);\n    if (!matcher.find()) {\n        return null;\n    } else {\n        int index = matcher.start();\n        next = next.substring(index);\n    }\n        StringBuilder sb = new StringBuilder();\n    if (inheritNamespaceToken != null && rootTokenNamespaces != null) {\n                String tag = ObjectHelper.before(next, \">\");\n                String text = ObjectHelper.after(next, \">\");\n                next = sb.append(tag).append(rootTokenNamespaces).append(\">\").append(text).append(endToken).toString();\n    } else {\n        next = sb.append(next).append(endToken).toString();\n    }\n    return next;\n}", "lc": 0.5454545454545454, "pi": -0.20574162679425848, "ma": 0.2, "nbd": -0.5, "ml": 0.5, "d": 0.632936507936508, "mi": -0.4407329105003524, "fo": 0.9166666666666666, "r": -0.02631578947368421, "e": 0.8999590832339228}
{"project_name": "Closure", "project_version": 137, "label": 2, "code": "private static String getOrginalNameInternal(String name, int index) {\n    return name.substring(0, index);\n}", "code_comment": NaN, "code_no_comment": "private static String getOrginalNameInternal(String name, int index) {\n    return name.substring(0, index);\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.9805496828752639, "fo": -0.4166666666666667, "r": 0.07894736842105263, "e": -0.16279340490885932}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-1951_adb321d6", "label": 0, "code": "private void addLocalInfoFromChannelToConfig(Channel channel, TaskConfig config, int inputNum, boolean isBroadcastChannel) {\n    // serializer\n    if (isBroadcastChannel) {\n        config.setBroadcastInputSerializer(channel.getSerializer(), inputNum);\n        if (channel.getLocalStrategy() != LocalStrategy.NONE || (channel.getTempMode() != null && channel.getTempMode() != TempMode.NONE)) {\n            throw new CompilerException(\"Found local strategy or temp mode on a broadcast variable channel.\");\n        } else {\n            return;\n        }\n    } else {\n        config.setInputSerializer(channel.getSerializer(), inputNum);\n    }\n    // local strategy\n    if (channel.getLocalStrategy() != LocalStrategy.NONE) {\n        config.setInputLocalStrategy(inputNum, channel.getLocalStrategy());\n        if (channel.getLocalStrategyComparator() != null) {\n            config.setInputComparator(channel.getLocalStrategyComparator(), inputNum);\n        }\n    }\n    assignLocalStrategyResources(channel, config, inputNum);\n    // materialization / caching\n    if (channel.getTempMode() != null) {\n        final TempMode tm = channel.getTempMode();\n        boolean needsMemory = false;\n        // Don't add a pipeline breaker if the data exchange is already blocking.\n        if (tm.breaksPipeline() && channel.getDataExchangeMode() != DataExchangeMode.BATCH) {\n            config.setInputAsynchronouslyMaterialized(inputNum, true);\n            needsMemory = true;\n        }\n        if (tm.isCached()) {\n            config.setInputCached(inputNum, true);\n            needsMemory = true;\n        }\n        if (needsMemory) {\n            // sanity check\n            if (tm == null || tm == TempMode.NONE || channel.getRelativeTempMemory() <= 0) {\n                throw new CompilerException(\"Bug in compiler: Inconsistent description of input materialization.\");\n            }\n            config.setRelativeInputMaterializationMemory(inputNum, channel.getRelativeTempMemory());\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "private void addLocalInfoFromChannelToConfig(Channel channel, TaskConfig config, int inputNum, boolean isBroadcastChannel) {\n        if (isBroadcastChannel) {\n        config.setBroadcastInputSerializer(channel.getSerializer(), inputNum);\n        if (channel.getLocalStrategy() != LocalStrategy.NONE || (channel.getTempMode() != null && channel.getTempMode() != TempMode.NONE)) {\n            throw new CompilerException(\"Found local strategy or temp mode on a broadcast variable channel.\");\n        } else {\n            return;\n        }\n    } else {\n        config.setInputSerializer(channel.getSerializer(), inputNum);\n    }\n        if (channel.getLocalStrategy() != LocalStrategy.NONE) {\n        config.setInputLocalStrategy(inputNum, channel.getLocalStrategy());\n        if (channel.getLocalStrategyComparator() != null) {\n            config.setInputComparator(channel.getLocalStrategyComparator(), inputNum);\n        }\n    }\n    assignLocalStrategyResources(channel, config, inputNum);\n        if (channel.getTempMode() != null) {\n        final TempMode tm = channel.getTempMode();\n        boolean needsMemory = false;\n                if (tm.breaksPipeline() && channel.getDataExchangeMode() != DataExchangeMode.BATCH) {\n            config.setInputAsynchronouslyMaterialized(inputNum, true);\n            needsMemory = true;\n        }\n        if (tm.isCached()) {\n            config.setInputCached(inputNum, true);\n            needsMemory = true;\n        }\n        if (needsMemory) {\n                        if (tm == null || tm == TempMode.NONE || channel.getRelativeTempMemory() <= 0) {\n                throw new CompilerException(\"Bug in compiler: Inconsistent description of input materialization.\");\n            }\n            config.setRelativeInputMaterializationMemory(inputNum, channel.getRelativeTempMemory());\n        }\n    }\n}", "lc": 1.0454545454545454, "pi": 0.29186602870813394, "ma": 1.6, "nbd": 0.5, "ml": 1.5833333333333333, "d": 1.1706349206349207, "mi": -0.6961240310077516, "fo": 1.5, "r": -0.02631578947368421, "e": 2.1156042714798615}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-2172_ea4a3f8a", "label": 3, "code": "/**\n *  get enum implementation\n */\n@SuppressWarnings({ \"unchecked\" })\nprivate <T extends Enum<T>> T getEnumImpl(String key, Class<?> eClass, T defaultValue) {\n    if (eClass == null)\n        throw new IllegalArgumentException(\"eClass value cannot be null\");\n    String value = getString(key);\n    if (value == null)\n        return defaultValue;\n    Method valueOf = null;\n    try {\n        valueOf = eClass.getMethod(\"valueOf\", String.class);\n    } catch (NoSuchMethodException e) {\n        throw new RuntimeException(\"Could not find method valueOf(String s) for \" + eClass.getName(), e);\n    }\n    try {\n        return (T) valueOf.invoke(eClass, value);\n    } catch (IllegalAccessException e) {\n        throw new RuntimeException(\"Could not invoke method valueOf(String s) on \" + eClass.getName(), e);\n    } catch (InvocationTargetException e) {\n        // IllegalArgumentException thrown if enum isn't defined - just return default\n        if (e.getCause() instanceof IllegalArgumentException) {\n            return defaultValue;\n        }\n        // shouldn't happen\n        throw new RuntimeException(e);\n    }\n}", "code_comment": "/**\n *  get enum implementation\n */\n", "code_no_comment": "@SuppressWarnings({ \"unchecked\" })\nprivate <T extends Enum<T>> T getEnumImpl(String key, Class<?> eClass, T defaultValue) {\n    if (eClass == null)\n        throw new IllegalArgumentException(\"eClass value cannot be null\");\n    String value = getString(key);\n    if (value == null)\n        return defaultValue;\n    Method valueOf = null;\n    try {\n        valueOf = eClass.getMethod(\"valueOf\", String.class);\n    } catch (NoSuchMethodException e) {\n        throw new RuntimeException(\"Could not find method valueOf(String s) for \" + eClass.getName(), e);\n    }\n    try {\n        return (T) valueOf.invoke(eClass, value);\n    } catch (IllegalAccessException e) {\n        throw new RuntimeException(\"Could not invoke method valueOf(String s) on \" + eClass.getName(), e);\n    } catch (InvocationTargetException e) {\n                if (e.getCause() instanceof IllegalArgumentException) {\n            return defaultValue;\n        }\n                throw new RuntimeException(e);\n    }\n}", "lc": 0.45454545454545453, "pi": -0.004784688995215422, "ma": 1.4, "nbd": 0.0, "ml": 0.08333333333333333, "d": 0.045634920634920584, "mi": -0.39732205778717394, "fo": 0.0, "r": -0.02631578947368421, "e": 0.15674924937904483}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1208_cb3ac20d", "label": 1, "code": "private static void addNonFullTextConstraints(List<Query> qs, Filter filter, IndexReader reader) {\n    if (!filter.matchesAllTypes()) {\n        addNodeTypeConstraints(qs, filter);\n    }\n    String path = filter.getPath();\n    switch(filter.getPathRestriction()) {\n        case ALL_CHILDREN:\n            if (\"/\".equals(path)) {\n                break;\n            }\n            if (!path.endsWith(\"/\")) {\n                path += \"/\";\n            }\n            qs.add(new PrefixQuery(newPathTerm(path)));\n            break;\n        case DIRECT_CHILDREN:\n            if (!path.endsWith(\"/\")) {\n                path += \"/\";\n            }\n            qs.add(new PrefixQuery(newPathTerm(path)));\n            break;\n        case EXACT:\n            qs.add(new TermQuery(newPathTerm(path)));\n            break;\n        case PARENT:\n            if (PathUtils.denotesRoot(path)) {\n                // there's no parent of the root node\n                // we add a path that can not possibly occur because there\n                // is no way to say \"match no documents\" in Lucene\n                qs.add(new TermQuery(new Term(FieldNames.PATH, \"///\")));\n            } else {\n                qs.add(new TermQuery(newPathTerm(PathUtils.getParentPath(path))));\n            }\n            break;\n        case NO_RESTRICTION:\n            break;\n    }\n    for (PropertyRestriction pr : filter.getPropertyRestrictions()) {\n        String name = pr.propertyName;\n        if (name.contains(\"/\")) {\n            // lucene cannot handle child-level property restrictions\n            continue;\n        }\n        if (\"rep:excerpt\".equals(name)) {\n            continue;\n        }\n        // TODO OAK-985\n        if (JcrConstants.JCR_PRIMARYTYPE.equals(name)) {\n            continue;\n        }\n        String first = null;\n        String last = null;\n        boolean isLike = pr.isLike;\n        // TODO what to do with escaped tokens?\n        if (pr.first != null) {\n            first = pr.first.getValue(Type.STRING);\n            first = first.replace(\"\\\\\", \"\");\n        }\n        if (pr.last != null) {\n            last = pr.last.getValue(Type.STRING);\n            last = last.replace(\"\\\\\", \"\");\n        }\n        if (isLike) {\n            first = first.replace('%', WildcardQuery.WILDCARD_STRING);\n            first = first.replace('_', WildcardQuery.WILDCARD_CHAR);\n            int indexOfWS = first.indexOf(WildcardQuery.WILDCARD_STRING);\n            int indexOfWC = first.indexOf(WildcardQuery.WILDCARD_CHAR);\n            int len = first.length();\n            if (indexOfWS == len || indexOfWC == len) {\n                // remove trailing \"*\" for prefixquery\n                first = first.substring(0, first.length() - 1);\n                if (JCR_PATH.equals(name)) {\n                    qs.add(new PrefixQuery(newPathTerm(first)));\n                } else {\n                    qs.add(new PrefixQuery(new Term(name, first)));\n                }\n            } else {\n                if (JCR_PATH.equals(name)) {\n                    qs.add(new WildcardQuery(newPathTerm(first)));\n                } else {\n                    qs.add(new WildcardQuery(new Term(name, first)));\n                }\n            }\n            continue;\n        }\n        if (first != null && first.equals(last) && pr.firstIncluding && pr.lastIncluding) {\n            if (JCR_PATH.equals(name)) {\n                qs.add(new TermQuery(newPathTerm(first)));\n            } else {\n                if (\"*\".equals(name)) {\n                    addReferenceConstraint(first, qs, reader);\n                } else {\n                    qs.add(new TermQuery(new Term(name, first)));\n                }\n            }\n            continue;\n        }\n        qs.add(TermRangeQuery.newStringRange(name, first, last, pr.firstIncluding, pr.lastIncluding));\n    }\n}", "code_comment": NaN, "code_no_comment": "private static void addNonFullTextConstraints(List<Query> qs, Filter filter, IndexReader reader) {\n    if (!filter.matchesAllTypes()) {\n        addNodeTypeConstraints(qs, filter);\n    }\n    String path = filter.getPath();\n    switch(filter.getPathRestriction()) {\n        case ALL_CHILDREN:\n            if (\"/\".equals(path)) {\n                break;\n            }\n            if (!path.endsWith(\"/\")) {\n                path += \"/\";\n            }\n            qs.add(new PrefixQuery(newPathTerm(path)));\n            break;\n        case DIRECT_CHILDREN:\n            if (!path.endsWith(\"/\")) {\n                path += \"/\";\n            }\n            qs.add(new PrefixQuery(newPathTerm(path)));\n            break;\n        case EXACT:\n            qs.add(new TermQuery(newPathTerm(path)));\n            break;\n        case PARENT:\n            if (PathUtils.denotesRoot(path)) {\n                                                                qs.add(new TermQuery(new Term(FieldNames.PATH, \"///\")));\n            } else {\n                qs.add(new TermQuery(newPathTerm(PathUtils.getParentPath(path))));\n            }\n            break;\n        case NO_RESTRICTION:\n            break;\n    }\n    for (PropertyRestriction pr : filter.getPropertyRestrictions()) {\n        String name = pr.propertyName;\n        if (name.contains(\"/\")) {\n                        continue;\n        }\n        if (\"rep:excerpt\".equals(name)) {\n            continue;\n        }\n                if (JcrConstants.JCR_PRIMARYTYPE.equals(name)) {\n            continue;\n        }\n        String first = null;\n        String last = null;\n        boolean isLike = pr.isLike;\n                if (pr.first != null) {\n            first = pr.first.getValue(Type.STRING);\n            first = first.replace(\"\\\\\", \"\");\n        }\n        if (pr.last != null) {\n            last = pr.last.getValue(Type.STRING);\n            last = last.replace(\"\\\\\", \"\");\n        }\n        if (isLike) {\n            first = first.replace('%', WildcardQuery.WILDCARD_STRING);\n            first = first.replace('_', WildcardQuery.WILDCARD_CHAR);\n            int indexOfWS = first.indexOf(WildcardQuery.WILDCARD_STRING);\n            int indexOfWC = first.indexOf(WildcardQuery.WILDCARD_CHAR);\n            int len = first.length();\n            if (indexOfWS == len || indexOfWC == len) {\n                                first = first.substring(0, first.length() - 1);\n                if (JCR_PATH.equals(name)) {\n                    qs.add(new PrefixQuery(newPathTerm(first)));\n                } else {\n                    qs.add(new PrefixQuery(new Term(name, first)));\n                }\n            } else {\n                if (JCR_PATH.equals(name)) {\n                    qs.add(new WildcardQuery(newPathTerm(first)));\n                } else {\n                    qs.add(new WildcardQuery(new Term(name, first)));\n                }\n            }\n            continue;\n        }\n        if (first != null && first.equals(last) && pr.firstIncluding && pr.lastIncluding) {\n            if (JCR_PATH.equals(name)) {\n                qs.add(new TermQuery(newPathTerm(first)));\n            } else {\n                if (\"*\".equals(name)) {\n                    addReferenceConstraint(first, qs, reader);\n                } else {\n                    qs.add(new TermQuery(new Term(name, first)));\n                }\n            }\n            continue;\n        }\n        qs.add(TermRangeQuery.newStringRange(name, first, last, pr.firstIncluding, pr.lastIncluding));\n    }\n}", "lc": 3.590909090909091, "pi": 0.6315789473684208, "ma": 6.2, "nbd": 1.0, "ml": 3.6666666666666665, "d": 2.1468253968253967, "mi": -1.4056377730796332, "fo": 3.6666666666666665, "r": -0.02631578947368421, "e": 9.49330059992047}
{"project_name": "Math", "project_version": 10, "label": 3, "code": "/**\n * Compute two arguments arc tangent of a derivative structure.\n * @param y array holding the first operand\n * @param yOffset offset of the first operand in its array\n * @param x array holding the second operand\n * @param xOffset offset of the second operand in its array\n * @param result array where result must be stored (for\n * two arguments arc tangent the result array <em>cannot</em>\n * be the input array)\n * @param resultOffset offset of the result in its array\n */\npublic void atan2(final double[] y, final int yOffset, final double[] x, final int xOffset, final double[] result, final int resultOffset) {\n    // compute r = sqrt(x^2+y^2)\n    double[] tmp1 = new double[getSize()];\n    // x^2\n    multiply(x, xOffset, x, xOffset, tmp1, 0);\n    double[] tmp2 = new double[getSize()];\n    // y^2\n    multiply(y, yOffset, y, yOffset, tmp2, 0);\n    // x^2 + y^2\n    add(tmp1, 0, tmp2, 0, tmp2, 0);\n    // r = sqrt(x^2 + y^2)\n    rootN(tmp2, 0, 2, tmp1, 0);\n    if (x[xOffset] >= 0) {\n        // compute atan2(y, x) = 2 atan(y / (r + x))\n        // r + x\n        add(tmp1, 0, x, xOffset, tmp2, 0);\n        // y /(r + x)\n        divide(y, yOffset, tmp2, 0, tmp1, 0);\n        // atan(y / (r + x))\n        atan(tmp1, 0, tmp2, 0);\n        for (int i = 0; i < tmp2.length; ++i) {\n            // 2 * atan(y / (r + x))\n            result[resultOffset + i] = 2 * tmp2[i];\n        }\n    } else {\n        // compute atan2(y, x) = +/- pi - 2 atan(y / (r - x))\n        // r - x\n        subtract(tmp1, 0, x, xOffset, tmp2, 0);\n        // y /(r - x)\n        divide(y, yOffset, tmp2, 0, tmp1, 0);\n        // atan(y / (r - x))\n        atan(tmp1, 0, tmp2, 0);\n        result[resultOffset] = // +/-pi - 2 * atan(y / (r - x))\n        ((tmp2[0] <= 0) ? -FastMath.PI : FastMath.PI) - 2 * tmp2[0];\n        for (int i = 1; i < tmp2.length; ++i) {\n            // +/-pi - 2 * atan(y / (r - x))\n            result[resultOffset + i] = -2 * tmp2[i];\n        }\n    }\n// fix value to take special cases (+0/+0, +0/-0, -0/+0, -0/-0, +/-infinity) correctly\n}", "code_comment": "/**\n * Compute two arguments arc tangent of a derivative structure.\n * @param y array holding the first operand\n * @param yOffset offset of the first operand in its array\n * @param x array holding the second operand\n * @param xOffset offset of the second operand in its array\n * @param result array where result must be stored (for\n * two arguments arc tangent the result array <em>cannot</em>\n * be the input array)\n * @param resultOffset offset of the result in its array\n */\n", "code_no_comment": "public void atan2(final double[] y, final int yOffset, final double[] x, final int xOffset, final double[] result, final int resultOffset) {\n        double[] tmp1 = new double[getSize()];\n        multiply(x, xOffset, x, xOffset, tmp1, 0);\n    double[] tmp2 = new double[getSize()];\n        multiply(y, yOffset, y, yOffset, tmp2, 0);\n        add(tmp1, 0, tmp2, 0, tmp2, 0);\n        rootN(tmp2, 0, 2, tmp1, 0);\n    if (x[xOffset] >= 0) {\n                        add(tmp1, 0, x, xOffset, tmp2, 0);\n                divide(y, yOffset, tmp2, 0, tmp1, 0);\n                atan(tmp1, 0, tmp2, 0);\n        for (int i = 0; i < tmp2.length; ++i) {\n                        result[resultOffset + i] = 2 * tmp2[i];\n        }\n    } else {\n                        subtract(tmp1, 0, x, xOffset, tmp2, 0);\n                divide(y, yOffset, tmp2, 0, tmp1, 0);\n                atan(tmp1, 0, tmp2, 0);\n        result[resultOffset] =         ((tmp2[0] <= 0) ? -FastMath.PI : FastMath.PI) - 2 * tmp2[0];\n        for (int i = 1; i < tmp2.length; ++i) {\n                        result[resultOffset + i] = -2 * tmp2[i];\n        }\n    }\n}", "lc": 0.5, "pi": 0.009569377990430419, "ma": 0.2, "nbd": 0.0, "ml": 0.08333333333333333, "d": 3.470238095238095, "mi": -0.4818886539816771, "fo": 0.5, "r": -0.02631578947368421, "e": 5.942831785988024}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-7418_cabee0e9", "label": 3, "code": "public <T> Map<String, T> findByTypeWithName(Class<T> type) {\n    Map<String, T> answer = new LinkedHashMap<String, T>();\n    try {\n        NamingEnumeration<NameClassPair> list = getContext().list(\"\");\n        while (list.hasMore()) {\n            NameClassPair pair = list.next();\n            if (type.isInstance(pair.getClass()) || type.getName().equals(pair.getClassName())) {\n                Object instance = context.lookup(pair.getName());\n                answer.put(pair.getName(), type.cast(instance));\n            }\n        }\n    } catch (NamingException e) {\n    // ignore\n    }\n    return answer;\n}", "code_comment": NaN, "code_no_comment": "public <T> Map<String, T> findByTypeWithName(Class<T> type) {\n    Map<String, T> answer = new LinkedHashMap<String, T>();\n    try {\n        NamingEnumeration<NameClassPair> list = getContext().list(\"\");\n        while (list.hasMore()) {\n            NameClassPair pair = list.next();\n            if (type.isInstance(pair.getClass()) || type.getName().equals(pair.getClassName())) {\n                Object instance = context.lookup(pair.getName());\n                answer.put(pair.getName(), type.cast(instance));\n            }\n        }\n    } catch (NamingException e) {\n        }\n    return answer;\n}", "lc": 0.045454545454545456, "pi": 0.9760765550239235, "ma": 0.0, "nbd": 0.5, "ml": 0.25, "d": -0.0138888888888889, "mi": -0.11599718111346001, "fo": 0.6666666666666666, "r": -0.02631578947368421, "e": 0.07340813609723207}
{"project_name": "Closure", "project_version": 6, "label": 2, "code": "/**\n * Expect that the first type can be assigned to a symbol of the second\n * type.\n *\n * @param t The node traversal.\n * @param n The node to issue warnings on.\n * @param rightType The type on the RHS of the assign.\n * @param leftType The type of the symbol on the LHS of the assign.\n * @param msg An extra message for the mismatch warning, if necessary.\n * @return True if the types matched, false otherwise.\n */\nboolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) {\n    if (!rightType.canAssignTo(leftType)) {\n        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n            registerMismatch(rightType, leftType, null);\n        } else {\n            mismatch(t, n, msg, rightType, leftType);\n        }\n        return false;\n    }\n    return true;\n}", "code_comment": "/**\n * Expect that the first type can be assigned to a symbol of the second\n * type.\n *\n * @param t The node traversal.\n * @param n The node to issue warnings on.\n * @param rightType The type on the RHS of the assign.\n * @param leftType The type of the symbol on the LHS of the assign.\n * @param msg An extra message for the mismatch warning, if necessary.\n * @return True if the types matched, false otherwise.\n */\n", "code_no_comment": "boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) {\n    if (!rightType.canAssignTo(leftType)) {\n        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n            registerMismatch(rightType, leftType, null);\n        } else {\n            mismatch(t, n, msg, rightType, leftType);\n        }\n        return false;\n    }\n    return true;\n}", "lc": -0.13636363636363635, "pi": 0.45933014354066987, "ma": -0.2, "nbd": 0.0, "ml": 0.5, "d": 0.0, "mi": 0.10697674418604654, "fo": 0.08333333333333333, "r": -0.02631578947368421, "e": -0.01509194746517753}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-880_2a9cbbab", "label": 1, "code": "/**\n * Add a node whose hyperplane contains this vertex.\n * @param node node whose hyperplane contains this vertex\n */\npublic void addNode(final BSPTree<Euclidean2D> node) {\n    nodes.add(node);\n}", "code_comment": "/**\n * Add a node whose hyperplane contains this vertex.\n * @param node node whose hyperplane contains this vertex\n */\n", "code_no_comment": "public void addNode(final BSPTree<Euclidean2D> node) {\n    nodes.add(node);\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.0132487667371384, "fo": -0.4166666666666667, "r": 2.552631578947368, "e": -0.16279340490885932}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-498_f2a2edec", "label": 1, "code": "private String getOakPath(String jcrPath, final boolean keepIndex) {\n    if (\"/\".equals(jcrPath)) {\n        // avoid the need to special case the root path later on\n        return \"/\";\n    }\n    int length = jcrPath.length();\n    // identifier path?\n    if (length > 0 && jcrPath.charAt(0) == '[') {\n        if (jcrPath.charAt(length - 1) != ']') {\n            // TODO error handling?\n            log.debug(\"Could not parse path \" + jcrPath + \": unterminated identifier\");\n            return null;\n        }\n        if (this.idManager == null) {\n            // TODO error handling?\n            log.debug(\"Could not parse path \" + jcrPath + \": could not resolve identifier\");\n            return null;\n        }\n        return this.idManager.getPath(jcrPath.substring(1, length - 1));\n    }\n    boolean hasClarkBrackets = false;\n    boolean hasIndexBrackets = false;\n    boolean hasColon = false;\n    boolean hasNameStartingWithDot = false;\n    boolean hasTrailingSlash = false;\n    char prev = 0;\n    for (int i = 0; i < length; i++) {\n        char c = jcrPath.charAt(i);\n        if (c == '{' || c == '}') {\n            hasClarkBrackets = true;\n        } else if (c == '[' || c == ']') {\n            hasIndexBrackets = true;\n        } else if (c == ':') {\n            hasColon = true;\n        } else if (c == '.' && (prev == 0 || prev == '/')) {\n            hasNameStartingWithDot = true;\n        } else if (c == '/' && i == (length - 1)) {\n            hasTrailingSlash = true;\n        }\n        prev = c;\n    }\n    // try a shortcut\n    if (!hasNameStartingWithDot && !hasClarkBrackets && !hasIndexBrackets) {\n        if (!hasColon || !hasSessionLocalMappings()) {\n            if (JcrPathParser.validate(jcrPath)) {\n                if (hasTrailingSlash) {\n                    return jcrPath.substring(0, length - 1);\n                }\n                return jcrPath;\n            } else {\n                log.debug(\"Invalid path: {}\", jcrPath);\n                return null;\n            }\n        }\n    }\n    final List<String> elements = new ArrayList<String>();\n    final StringBuilder parseErrors = new StringBuilder();\n    JcrPathParser.Listener listener = new JcrPathParser.Listener() {\n\n        @Override\n        public boolean root() {\n            if (!elements.isEmpty()) {\n                parseErrors.append(\"/ on non-empty path\");\n                return false;\n            }\n            elements.add(\"\");\n            return true;\n        }\n\n        @Override\n        public boolean current() {\n            // nothing to do here\n            return true;\n        }\n\n        @Override\n        public boolean parent() {\n            if (elements.isEmpty() || \"..\".equals(elements.get(elements.size() - 1))) {\n                elements.add(\"..\");\n                return true;\n            }\n            elements.remove(elements.size() - 1);\n            return true;\n        }\n\n        @Override\n        public void error(String message) {\n            parseErrors.append(message);\n        }\n\n        @Override\n        public boolean name(String name, int index) {\n            if (!keepIndex && index > 1) {\n                parseErrors.append(\"index > 1\");\n                return false;\n            }\n            String p = nameMapper.getOakName(name);\n            if (p == null) {\n                parseErrors.append(\"Invalid name: \").append(name);\n                return false;\n            }\n            if (keepIndex && index > 0) {\n                p += \"[\" + index + ']';\n            }\n            elements.add(p);\n            return true;\n        }\n    };\n    JcrPathParser.parse(jcrPath, listener);\n    if (parseErrors.length() != 0) {\n        log.debug(\"Could not parse path \" + jcrPath + \": \" + parseErrors.toString());\n        return null;\n    }\n    // Empty path maps to \"\"\n    if (elements.isEmpty()) {\n        return \"\";\n    }\n    StringBuilder oakPath = new StringBuilder();\n    for (String element : elements) {\n        if (element.isEmpty()) {\n            // root\n            oakPath.append('/');\n        } else {\n            oakPath.append(element);\n            oakPath.append('/');\n        }\n    }\n    // root path is special-cased early on so it does not need to\n    // be considered here\n    oakPath.deleteCharAt(oakPath.length() - 1);\n    return oakPath.toString();\n}", "code_comment": NaN, "code_no_comment": "private String getOakPath(String jcrPath, final boolean keepIndex) {\n    if (\"/\".equals(jcrPath)) {\n                return \"/\";\n    }\n    int length = jcrPath.length();\n        if (length > 0 && jcrPath.charAt(0) == '[') {\n        if (jcrPath.charAt(length - 1) != ']') {\n                        log.debug(\"Could not parse path \" + jcrPath + \": unterminated identifier\");\n            return null;\n        }\n        if (this.idManager == null) {\n                        log.debug(\"Could not parse path \" + jcrPath + \": could not resolve identifier\");\n            return null;\n        }\n        return this.idManager.getPath(jcrPath.substring(1, length - 1));\n    }\n    boolean hasClarkBrackets = false;\n    boolean hasIndexBrackets = false;\n    boolean hasColon = false;\n    boolean hasNameStartingWithDot = false;\n    boolean hasTrailingSlash = false;\n    char prev = 0;\n    for (int i = 0; i < length; i++) {\n        char c = jcrPath.charAt(i);\n        if (c == '{' || c == '}') {\n            hasClarkBrackets = true;\n        } else if (c == '[' || c == ']') {\n            hasIndexBrackets = true;\n        } else if (c == ':') {\n            hasColon = true;\n        } else if (c == '.' && (prev == 0 || prev == '/')) {\n            hasNameStartingWithDot = true;\n        } else if (c == '/' && i == (length - 1)) {\n            hasTrailingSlash = true;\n        }\n        prev = c;\n    }\n        if (!hasNameStartingWithDot && !hasClarkBrackets && !hasIndexBrackets) {\n        if (!hasColon || !hasSessionLocalMappings()) {\n            if (JcrPathParser.validate(jcrPath)) {\n                if (hasTrailingSlash) {\n                    return jcrPath.substring(0, length - 1);\n                }\n                return jcrPath;\n            } else {\n                log.debug(\"Invalid path: {}\", jcrPath);\n                return null;\n            }\n        }\n    }\n    final List<String> elements = new ArrayList<String>();\n    final StringBuilder parseErrors = new StringBuilder();\n    JcrPathParser.Listener listener = new JcrPathParser.Listener() {\n\n        @Override\n        public boolean root() {\n            if (!elements.isEmpty()) {\n                parseErrors.append(\"/ on non-empty path\");\n                return false;\n            }\n            elements.add(\"\");\n            return true;\n        }\n\n        @Override\n        public boolean current() {\n                        return true;\n        }\n\n        @Override\n        public boolean parent() {\n            if (elements.isEmpty() || \"..\".equals(elements.get(elements.size() - 1))) {\n                elements.add(\"..\");\n                return true;\n            }\n            elements.remove(elements.size() - 1);\n            return true;\n        }\n\n        @Override\n        public void error(String message) {\n            parseErrors.append(message);\n        }\n\n        @Override\n        public boolean name(String name, int index) {\n            if (!keepIndex && index > 1) {\n                parseErrors.append(\"index > 1\");\n                return false;\n            }\n            String p = nameMapper.getOakName(name);\n            if (p == null) {\n                parseErrors.append(\"Invalid name: \").append(name);\n                return false;\n            }\n            if (keepIndex && index > 0) {\n                p += \"[\" + index + ']';\n            }\n            elements.add(p);\n            return true;\n        }\n    };\n    JcrPathParser.parse(jcrPath, listener);\n    if (parseErrors.length() != 0) {\n        log.debug(\"Could not parse path \" + jcrPath + \": \" + parseErrors.toString());\n        return null;\n    }\n        if (elements.isEmpty()) {\n        return \"\";\n    }\n    StringBuilder oakPath = new StringBuilder();\n    for (String element : elements) {\n        if (element.isEmpty()) {\n                        oakPath.append('/');\n        } else {\n            oakPath.append(element);\n            oakPath.append('/');\n        }\n    }\n            oakPath.deleteCharAt(oakPath.length() - 1);\n    return oakPath.toString();\n}", "lc": 4.681818181818182, "pi": 0.5645933014354066, "ma": 4.0, "nbd": 2.0, "ml": 4.5, "d": 3.6507936507936507, "mi": -1.4727272727272722, "fo": 2.9166666666666665, "r": -0.02631578947368421, "e": 19.25635909937011}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-8954_7b1253db", "label": 3, "code": "protected void doReleaseExclusiveReadLock(GenericFileOperations<File> operations, GenericFile<File> file, Exchange exchange) throws Exception {\n    if (!markerFile) {\n        // if not using marker file then nothing to release\n        return;\n    }\n    // only release the file if camel get the lock before\n    if (exchange.getProperty(Exchange.FILE_LOCK_FILE_ACQUIRED, false, Boolean.class)) {\n        String lockFileName = exchange.getProperty(Exchange.FILE_LOCK_FILE_NAME, getLockFileName(file), String.class);\n        File lock = new File(lockFileName);\n        if (lock.exists()) {\n            LOG.trace(\"Unlocking file: {}\", lockFileName);\n            boolean deleted = FileUtil.deleteFile(lock);\n            LOG.trace(\"Lock file: {} was deleted: {}\", lockFileName, deleted);\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "protected void doReleaseExclusiveReadLock(GenericFileOperations<File> operations, GenericFile<File> file, Exchange exchange) throws Exception {\n    if (!markerFile) {\n                return;\n    }\n        if (exchange.getProperty(Exchange.FILE_LOCK_FILE_ACQUIRED, false, Boolean.class)) {\n        String lockFileName = exchange.getProperty(Exchange.FILE_LOCK_FILE_NAME, getLockFileName(file), String.class);\n        File lock = new File(lockFileName);\n        if (lock.exists()) {\n            LOG.trace(\"Unlocking file: {}\", lockFileName);\n            boolean deleted = FileUtil.deleteFile(lock);\n            LOG.trace(\"Lock file: {} was deleted: {}\", lockFileName, deleted);\n        }\n    }\n}", "lc": 0.0, "pi": 0.43062200956937796, "ma": 0.0, "nbd": 0.0, "ml": 0.08333333333333333, "d": -0.039682539682539715, "mi": -0.06018322762508822, "fo": 0.08333333333333333, "r": -0.02631578947368421, "e": 0.023035563008938283}
{"project_name": "Codec", "project_version": 9, "label": 3, "code": "/**\n * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n *\n * @param binaryData\n *            Array containing binary data to encode.\n * @param isChunked\n *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n * @param urlSafe\n *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.\n * @param maxResultSize\n *            The maximum result size to accept.\n * @return Base64-encoded data.\n * @throws IllegalArgumentException\n *             Thrown when the input array needs an output array bigger than maxResultSize\n * @since 1.4\n */\npublic static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n    if (binaryData == null || binaryData.length == 0) {\n        return binaryData;\n    }\n    long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n    if (len > maxResultSize) {\n        throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" + len + \") than the specified maxium size of \" + maxResultSize);\n    }\n    Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n    return b64.encode(binaryData);\n}", "code_comment": "/**\n * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n *\n * @param binaryData\n *            Array containing binary data to encode.\n * @param isChunked\n *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n * @param urlSafe\n *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.\n * @param maxResultSize\n *            The maximum result size to accept.\n * @return Base64-encoded data.\n * @throws IllegalArgumentException\n *             Thrown when the input array needs an output array bigger than maxResultSize\n * @since 1.4\n */\n", "code_no_comment": "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n    if (binaryData == null || binaryData.length == 0) {\n        return binaryData;\n    }\n    long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n    if (len > maxResultSize) {\n        throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" + len + \") than the specified maxium size of \" + maxResultSize);\n    }\n    Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n    return b64.encode(binaryData);\n}", "lc": -0.13636363636363635, "pi": -0.2775119617224881, "ma": 0.2, "nbd": -0.5, "ml": 0.3333333333333333, "d": 0.3869047619047619, "mi": 0.07568710359408039, "fo": -0.3333333333333333, "r": 0.21052631578947367, "e": 0.18164969485313182}
{"project_name": "JxPath", "project_version": 9, "label": 1, "code": "protected boolean equal(Object l, Object r) {\n    if (l instanceof Pointer && r instanceof Pointer) {\n        if (l.equals(r)) {\n            return true;\n        }\n    }\n    if (l instanceof Pointer) {\n        l = ((Pointer) l).getValue();\n    }\n    if (r instanceof Pointer) {\n        r = ((Pointer) r).getValue();\n    }\n    if (l == r) {\n        return true;\n    }\n    if (l instanceof Boolean || r instanceof Boolean) {\n        return (InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r));\n    }\n    // if either side is NaN, no comparison returns true:\n    if (l instanceof Number || r instanceof Number) {\n        return (InfoSetUtil.doubleValue(l) == InfoSetUtil.doubleValue(r));\n    }\n    if (l instanceof String || r instanceof String) {\n        return (InfoSetUtil.stringValue(l).equals(InfoSetUtil.stringValue(r)));\n    }\n    return l != null && l.equals(r);\n}", "code_comment": NaN, "code_no_comment": "protected boolean equal(Object l, Object r) {\n    if (l instanceof Pointer && r instanceof Pointer) {\n        if (l.equals(r)) {\n            return true;\n        }\n    }\n    if (l instanceof Pointer) {\n        l = ((Pointer) l).getValue();\n    }\n    if (r instanceof Pointer) {\n        r = ((Pointer) r).getValue();\n    }\n    if (l == r) {\n        return true;\n    }\n    if (l instanceof Boolean || r instanceof Boolean) {\n        return (InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r));\n    }\n        if (l instanceof Number || r instanceof Number) {\n        return (InfoSetUtil.doubleValue(l) == InfoSetUtil.doubleValue(r));\n    }\n    if (l instanceof String || r instanceof String) {\n        return (InfoSetUtil.stringValue(l).equals(InfoSetUtil.stringValue(r)));\n    }\n    return l != null && l.equals(r);\n}", "lc": 0.5454545454545454, "pi": -0.1578947368421053, "ma": 1.0, "nbd": 0.0, "ml": 0.8333333333333334, "d": 1.152777777777778, "mi": -0.42269203664552507, "fo": 0.4166666666666667, "r": -0.02631578947368421, "e": 1.0320775920195016}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3053_7552a10b", "label": 1, "code": "protected Directory createLocalDirForIndexWriter(IndexDefinition definition) throws IOException {\n    String indexPath = definition.getIndexPathFromConfig();\n    File indexWriterDir;\n    if (indexPath == null) {\n        // If indexPath is not known create a unique directory for work\n        indexWriterDir = new File(indexWorkDir, String.valueOf(UNIQUE_COUNTER.incrementAndGet()));\n    } else {\n        File indexDir = getIndexDir(indexPath);\n        String newVersion = String.valueOf(definition.getReindexCount());\n        indexWriterDir = getVersionedDir(indexPath, indexDir, newVersion);\n    }\n    Directory dir = FSDirectory.open(indexWriterDir);\n    log.debug(\"IndexWriter would use {}\", indexWriterDir);\n    if (indexPath == null) {\n        dir = new DeleteOldDirOnClose(dir, indexWriterDir);\n        log.debug(\"IndexPath [{}] not configured in index definition {}. Writer would create index \" + \"files in temporary dir {} which would be deleted upon close. For better performance do \" + \"configure the 'indexPath' as part of your index definition\", LuceneIndexConstants.INDEX_PATH, definition, indexWriterDir);\n    }\n    return dir;\n}", "code_comment": NaN, "code_no_comment": "protected Directory createLocalDirForIndexWriter(IndexDefinition definition) throws IOException {\n    String indexPath = definition.getIndexPathFromConfig();\n    File indexWriterDir;\n    if (indexPath == null) {\n                indexWriterDir = new File(indexWorkDir, String.valueOf(UNIQUE_COUNTER.incrementAndGet()));\n    } else {\n        File indexDir = getIndexDir(indexPath);\n        String newVersion = String.valueOf(definition.getReindexCount());\n        indexWriterDir = getVersionedDir(indexPath, indexDir, newVersion);\n    }\n    Directory dir = FSDirectory.open(indexWriterDir);\n    log.debug(\"IndexWriter would use {}\", indexWriterDir);\n    if (indexPath == null) {\n        dir = new DeleteOldDirOnClose(dir, indexWriterDir);\n        log.debug(\"IndexPath [{}] not configured in index definition {}. Writer would create index \" + \"files in temporary dir {} which would be deleted upon close. For better performance do \" + \"configure the 'indexPath' as part of your index definition\", LuceneIndexConstants.INDEX_PATH, definition, indexWriterDir);\n    }\n    return dir;\n}", "lc": 0.18181818181818182, "pi": -0.22966507177033516, "ma": -0.2, "nbd": -0.5, "ml": -0.16666666666666666, "d": 0.0019841269841269858, "mi": -0.22734319943622258, "fo": 0.3333333333333333, "r": -0.02631578947368421, "e": 0.15002276355295835}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5319_c863b032", "label": 3, "code": "protected Url decryptUrl(final Request request, final Url encryptedUrl) {\n    /*\n\t\t * If the encrypted URL has no segments it is the home page URL,\n\t\t * and does not need decrypting.\n\t\t */\n    if (encryptedUrl.getSegments().isEmpty()) {\n        return encryptedUrl;\n    }\n    List<String> encryptedSegments = encryptedUrl.getSegments();\n    Url url = new Url(request.getCharset());\n    try {\n        /*\n\t\t\t * The first encrypted segment contains an encrypted version of the\n\t\t\t * entire plain text url.\n\t\t\t */\n        String encryptedUrlString = encryptedSegments.get(0);\n        if (Strings.isEmpty(encryptedUrlString)) {\n            return null;\n        }\n        String decryptedUrl = getCrypt().decryptUrlSafe(encryptedUrlString);\n        if (decryptedUrl == null) {\n            return null;\n        }\n        Url originalUrl = Url.parse(decryptedUrl, request.getCharset());\n        int originalNumberOfSegments = originalUrl.getSegments().size();\n        int encryptedNumberOfSegments = encryptedUrl.getSegments().size();\n        HashedSegmentGenerator generator = new HashedSegmentGenerator(encryptedUrlString);\n        int segNo = 1;\n        for (; segNo < encryptedNumberOfSegments; segNo++) {\n            if (segNo > originalNumberOfSegments) {\n                break;\n            }\n            String next = generator.next();\n            String encryptedSegment = encryptedSegments.get(segNo);\n            if (!next.equals(encryptedSegment)) {\n                /*\n\t\t\t\t\t * This segment received from the browser is not the same as the\n\t\t\t\t\t * expected segment generated by the HashSegmentGenerator. Hence it,\n\t\t\t\t\t * and all subsequent segments are considered plain text siblings of the\n\t\t\t\t\t * original encrypted url.\n\t\t\t\t\t */\n                break;\n            }\n            /*\n\t\t\t\t * This segments matches the expected checksum, so we add the corresponding\n\t\t\t\t * segment from the original URL.\n\t\t\t\t */\n            url.getSegments().add(originalUrl.getSegments().get(segNo - 1));\n        }\n        /*\n\t\t\t * Add all remaining segments from the encrypted url as plain text segments.\n\t\t\t */\n        for (; segNo < encryptedNumberOfSegments; segNo++) {\n            // modified or additional segment\n            url.getSegments().add(encryptedUrl.getSegments().get(segNo));\n        }\n        url.getQueryParameters().addAll(originalUrl.getQueryParameters());\n        // WICKET-4923 additional parameters\n        url.getQueryParameters().addAll(encryptedUrl.getQueryParameters());\n    } catch (Exception e) {\n        log.error(\"Error decrypting URL\", e);\n        url = null;\n    }\n    return url;\n}", "code_comment": NaN, "code_no_comment": "protected Url decryptUrl(final Request request, final Url encryptedUrl) {\n        if (encryptedUrl.getSegments().isEmpty()) {\n        return encryptedUrl;\n    }\n    List<String> encryptedSegments = encryptedUrl.getSegments();\n    Url url = new Url(request.getCharset());\n    try {\n                String encryptedUrlString = encryptedSegments.get(0);\n        if (Strings.isEmpty(encryptedUrlString)) {\n            return null;\n        }\n        String decryptedUrl = getCrypt().decryptUrlSafe(encryptedUrlString);\n        if (decryptedUrl == null) {\n            return null;\n        }\n        Url originalUrl = Url.parse(decryptedUrl, request.getCharset());\n        int originalNumberOfSegments = originalUrl.getSegments().size();\n        int encryptedNumberOfSegments = encryptedUrl.getSegments().size();\n        HashedSegmentGenerator generator = new HashedSegmentGenerator(encryptedUrlString);\n        int segNo = 1;\n        for (; segNo < encryptedNumberOfSegments; segNo++) {\n            if (segNo > originalNumberOfSegments) {\n                break;\n            }\n            String next = generator.next();\n            String encryptedSegment = encryptedSegments.get(segNo);\n            if (!next.equals(encryptedSegment)) {\n                                break;\n            }\n                        url.getSegments().add(originalUrl.getSegments().get(segNo - 1));\n        }\n                for (; segNo < encryptedNumberOfSegments; segNo++) {\n                        url.getSegments().add(encryptedUrl.getSegments().get(segNo));\n        }\n        url.getQueryParameters().addAll(originalUrl.getQueryParameters());\n                url.getQueryParameters().addAll(encryptedUrl.getQueryParameters());\n    } catch (Exception e) {\n        log.error(\"Error decrypting URL\", e);\n        url = null;\n    }\n    return url;\n}", "lc": 1.2727272727272727, "pi": 0.2870813397129185, "ma": 1.4, "nbd": 0.5, "ml": 0.9166666666666666, "d": 1.2757936507936507, "mi": -0.7694150810429878, "fo": 2.1666666666666665, "r": -0.02631578947368421, "e": 2.66873440408476}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3021_494da6de", "label": 1, "code": "@Override\npublic Validator childNodeAdded(String name, NodeState after) throws CommitFailedException {\n    Tree treeAfter = checkNotNull(parentAfter.getChild(name));\n    checkValidTree(parentAfter, treeAfter, after);\n    return new AccessControlValidator(this, treeAfter);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic Validator childNodeAdded(String name, NodeState after) throws CommitFailedException {\n    Tree treeAfter = checkNotNull(parentAfter.getChild(name));\n    checkValidTree(parentAfter, treeAfter, after);\n    return new AccessControlValidator(this, treeAfter);\n}", "lc": -0.36363636363636365, "pi": -0.47368421052631593, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.49344608879492574, "fo": -0.25, "r": 0.07894736842105263, "e": -0.16279340490885932}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1120_474b2577", "label": 0, "code": "public SecurityToken getToken() {\n    PasswordToken pt = new PasswordToken();\n    if (securePassword == null) {\n        if (password.value == null)\n            return null;\n        return pt.setPassword(password.value);\n    }\n    return pt.setPassword(securePassword.value);\n}", "code_comment": NaN, "code_no_comment": "public SecurityToken getToken() {\n    PasswordToken pt = new PasswordToken();\n    if (securePassword == null) {\n        if (password.value == null)\n            return null;\n        return pt.setPassword(password.value);\n    }\n    return pt.setPassword(securePassword.value);\n}", "lc": -0.22727272727272727, "pi": 0.32057416267942584, "ma": -0.2, "nbd": -0.5, "ml": -0.08333333333333333, "d": 0.03174603174603173, "mi": 0.30796335447498224, "fo": -0.3333333333333333, "r": 0.8421052631578947, "e": -0.08676429061277179}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-260_9d817953", "label": 1, "code": "@Override\npublic /**\n * @return The content type.\n */\nString getContentType() {\n    return \"text/xml\";\n}", "code_comment": "/**\n * @return The content type.\n */\n", "code_no_comment": "@Override\npublic String getContentType() {\n    return \"text/xml\";\n}", "lc": -0.4090909090909091, "pi": -0.6650717703349284, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.8768146582100066, "fo": -0.5, "r": 2.6052631578947367, "e": -0.16279340490885932}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-1458_91f9bfc7", "label": 1, "code": "/**\n *  Checks if the given field is a valid pojo field:\n *  - it is public\n *  OR\n *   - there are getter and setter methods for the field.\n *\n *  @param f field to check\n *  @param clazz class of field\n *  @param typeHierarchy type hierarchy for materializing generic types\n */\nprivate boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy) {\n    if (Modifier.isPublic(f.getModifiers())) {\n        return true;\n    } else {\n        boolean hasGetter = false, hasSetter = false;\n        final String fieldNameLow = f.getName().toLowerCase();\n        Type fieldType = f.getGenericType();\n        TypeVariable<?> fieldTypeGeneric = null;\n        if (fieldType instanceof TypeVariable) {\n            fieldTypeGeneric = (TypeVariable<?>) fieldType;\n            fieldType = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) fieldType);\n        }\n        for (Method m : clazz.getMethods()) {\n            // check for getter\n            if (// The name should be \"get<FieldName>\" or \"<fieldName>\" (for scala) or \"is<fieldName>\" for boolean fields.\n            (m.getName().toLowerCase().equals(\"get\" + fieldNameLow) || m.getName().toLowerCase().equals(\"is\" + fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow)) && // no arguments for the getter\n            m.getParameterTypes().length == 0 && // return type is same as field type (or the generic variant of it)\n            (m.getGenericReturnType().equals(fieldType) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)))) {\n                if (hasGetter) {\n                    throw new IllegalStateException(\"Detected more than one getter\");\n                }\n                hasGetter = true;\n            }\n            // check for setters (<FieldName>_$eq for scala)\n            if ((m.getName().toLowerCase().equals(\"set\" + fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow + \"_$eq\")) && // one parameter of the field's type\n            m.getParameterTypes().length == 1 && (m.getGenericParameterTypes()[0].equals(fieldType) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric))) && // return type is void.\n            m.getReturnType().equals(Void.TYPE)) {\n                if (hasSetter) {\n                    throw new IllegalStateException(\"Detected more than one setter\");\n                }\n                hasSetter = true;\n            }\n        }\n        if (hasGetter && hasSetter) {\n            return true;\n        } else {\n            if (!hasGetter) {\n                LOG.warn(\"Class \" + clazz + \" does not contain a getter for field \" + f.getName());\n            }\n            if (!hasSetter) {\n                LOG.warn(\"Class \" + clazz + \" does not contain a setter for field \" + f.getName());\n            }\n            return false;\n        }\n    }\n}", "code_comment": "/**\n *  Checks if the given field is a valid pojo field:\n *  - it is public\n *  OR\n *   - there are getter and setter methods for the field.\n *\n *  @param f field to check\n *  @param clazz class of field\n *  @param typeHierarchy type hierarchy for materializing generic types\n */\n", "code_no_comment": "private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy) {\n    if (Modifier.isPublic(f.getModifiers())) {\n        return true;\n    } else {\n        boolean hasGetter = false, hasSetter = false;\n        final String fieldNameLow = f.getName().toLowerCase();\n        Type fieldType = f.getGenericType();\n        TypeVariable<?> fieldTypeGeneric = null;\n        if (fieldType instanceof TypeVariable) {\n            fieldTypeGeneric = (TypeVariable<?>) fieldType;\n            fieldType = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) fieldType);\n        }\n        for (Method m : clazz.getMethods()) {\n                        if (            (m.getName().toLowerCase().equals(\"get\" + fieldNameLow) || m.getName().toLowerCase().equals(\"is\" + fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow)) &&             m.getParameterTypes().length == 0 &&             (m.getGenericReturnType().equals(fieldType) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)))) {\n                if (hasGetter) {\n                    throw new IllegalStateException(\"Detected more than one getter\");\n                }\n                hasGetter = true;\n            }\n                        if ((m.getName().toLowerCase().equals(\"set\" + fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow + \"_$eq\")) &&             m.getParameterTypes().length == 1 && (m.getGenericParameterTypes()[0].equals(fieldType) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric))) &&             m.getReturnType().equals(Void.TYPE)) {\n                if (hasSetter) {\n                    throw new IllegalStateException(\"Detected more than one setter\");\n                }\n                hasSetter = true;\n            }\n        }\n        if (hasGetter && hasSetter) {\n            return true;\n        } else {\n            if (!hasGetter) {\n                LOG.warn(\"Class \" + clazz + \" does not contain a getter for field \" + f.getName());\n            }\n            if (!hasSetter) {\n                LOG.warn(\"Class \" + clazz + \" does not contain a setter for field \" + f.getName());\n            }\n            return false;\n        }\n    }\n}", "lc": 1.3636363636363635, "pi": 0.7033492822966506, "ma": 1.8, "nbd": 1.0, "ml": 2.9166666666666665, "d": 1.2460317460317458, "mi": -0.8474982381959123, "fo": 2.6666666666666665, "r": -0.02631578947368421, "e": 3.5861367081020954}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2528_239de7b8", "label": 1, "code": "/**\n * Returns a map of all local property changes committed by the current\n * cluster node.\n *\n * @return local changes committed by the current cluster node.\n */\n@Nonnull\nprivate Map<String, NavigableMap<Revision, String>> getCommittedLocalChanges() {\n    Map<String, NavigableMap<Revision, String>> committedLocally = new HashMap<String, NavigableMap<Revision, String>>();\n    for (String property : filter(doc.keySet(), PROPERTY_OR_DELETED)) {\n        NavigableMap<Revision, String> splitMap = new TreeMap<Revision, String>(context.getRevisionComparator());\n        committedLocally.put(property, splitMap);\n        Map<Revision, String> valueMap = doc.getLocalMap(property);\n        // collect committed changes of this cluster node\n        for (Map.Entry<Revision, String> entry : valueMap.entrySet()) {\n            Revision rev = entry.getKey();\n            if (rev.getClusterId() != context.getClusterId()) {\n                continue;\n            }\n            if (doc.isCommitted(rev)) {\n                splitMap.put(rev, entry.getValue());\n            } else if (isGarbage(rev)) {\n                addGarbage(rev, property);\n            }\n        }\n    }\n    return committedLocally;\n}", "code_comment": "/**\n * Returns a map of all local property changes committed by the current\n * cluster node.\n *\n * @return local changes committed by the current cluster node.\n */\n", "code_no_comment": "@Nonnull\nprivate Map<String, NavigableMap<Revision, String>> getCommittedLocalChanges() {\n    Map<String, NavigableMap<Revision, String>> committedLocally = new HashMap<String, NavigableMap<Revision, String>>();\n    for (String property : filter(doc.keySet(), PROPERTY_OR_DELETED)) {\n        NavigableMap<Revision, String> splitMap = new TreeMap<Revision, String>(context.getRevisionComparator());\n        committedLocally.put(property, splitMap);\n        Map<Revision, String> valueMap = doc.getLocalMap(property);\n                for (Map.Entry<Revision, String> entry : valueMap.entrySet()) {\n            Revision rev = entry.getKey();\n            if (rev.getClusterId() != context.getClusterId()) {\n                continue;\n            }\n            if (doc.isCommitted(rev)) {\n                splitMap.put(rev, entry.getValue());\n            } else if (isGarbage(rev)) {\n                addGarbage(rev, property);\n            }\n        }\n    }\n    return committedLocally;\n}", "lc": 0.3181818181818182, "pi": 1.0, "ma": 0.6, "nbd": 1.0, "ml": 0.25, "d": 0.10912698412698414, "mi": -0.33587033121916815, "fo": 0.6666666666666666, "r": -0.02631578947368421, "e": 0.2757790033597851}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-2713_63d9800e", "label": 1, "code": "@Override\npublic void restoreState(StateHandle<Serializable> snapshots, ClassLoader userCodeClassLoader) throws Exception {\n    stateStore.restoreStates(snapshots, userCodeClassLoader);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void restoreState(StateHandle<Serializable> snapshots, ClassLoader userCodeClassLoader) throws Exception {\n    stateStore.restoreStates(snapshots, userCodeClassLoader);\n}", "lc": -0.45454545454545453, "pi": -0.6028708133971293, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.7801268498942919, "fo": -0.4166666666666667, "r": 0.1842105263157895, "e": -0.16279340490885932}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-1008_0c20bfd8", "label": 1, "code": "/**\n * Sets an explicit ClassLoader that should be used when scanning for classes. If none\n * is set then the context classloader will be used.\n *\n * @param classloader a ClassLoader to use when scanning for classes\n */\npublic void setClassLoader(final ClassLoader classloader) {\n    this.classloader = classloader;\n}", "code_comment": "/**\n * Sets an explicit ClassLoader that should be used when scanning for classes. If none\n * is set then the context classloader will be used.\n *\n * @param classloader a ClassLoader to use when scanning for classes\n */\n", "code_no_comment": "public void setClassLoader(final ClassLoader classloader) {\n    this.classloader = classloader;\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.0606060606060603, "fo": -0.5, "r": 2.4736842105263155, "e": -0.16279340490885932}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5138_e8dab4a0", "label": 1, "code": "/**\n *  A filterPath should have all leading slashes removed and exactly one trailing slash. A\n *  wildcard asterisk character has no special meaning. If your intention is to mean the top\n *  level \"/\" then an empty string should be used instead.\n *\n *  @param filterPath\n *  @return\n */\nstatic String canonicaliseFilterPath(String filterPath) {\n    if (Strings.isEmpty(filterPath)) {\n        return filterPath;\n    }\n    int beginIndex = 0;\n    int endIndex = filterPath.length();\n    while (beginIndex < endIndex) {\n        char c = filterPath.charAt(beginIndex);\n        if (c != '/') {\n            break;\n        }\n        beginIndex++;\n    }\n    int o;\n    int i = o = beginIndex;\n    while (i < endIndex) {\n        char c = filterPath.charAt(i);\n        i++;\n        if (c != '/') {\n            o = i;\n        }\n    }\n    if (o < endIndex) {\n        // include exactly one trailing slash\n        o++;\n        filterPath = filterPath.substring(beginIndex, o);\n    } else {\n        // ensure to append trailing slash\n        filterPath = filterPath.substring(beginIndex) + '/';\n    }\n    if (filterPath.equals(\"/\")) {\n        return \"\";\n    }\n    return filterPath;\n}", "code_comment": "/**\n *  A filterPath should have all leading slashes removed and exactly one trailing slash. A\n *  wildcard asterisk character has no special meaning. If your intention is to mean the top\n *  level \"/\" then an empty string should be used instead.\n *\n *  @param filterPath\n *  @return\n */\n", "code_no_comment": "static String canonicaliseFilterPath(String filterPath) {\n    if (Strings.isEmpty(filterPath)) {\n        return filterPath;\n    }\n    int beginIndex = 0;\n    int endIndex = filterPath.length();\n    while (beginIndex < endIndex) {\n        char c = filterPath.charAt(beginIndex);\n        if (c != '/') {\n            break;\n        }\n        beginIndex++;\n    }\n    int o;\n    int i = o = beginIndex;\n    while (i < endIndex) {\n        char c = filterPath.charAt(i);\n        i++;\n        if (c != '/') {\n            o = i;\n        }\n    }\n    if (o < endIndex) {\n                o++;\n        filterPath = filterPath.substring(beginIndex, o);\n    } else {\n                filterPath = filterPath.substring(beginIndex) + '/';\n    }\n    if (filterPath.equals(\"/\")) {\n        return \"\";\n    }\n    return filterPath;\n}", "lc": 0.8636363636363636, "pi": -0.0909090909090911, "ma": 1.0, "nbd": 0.0, "ml": 0.8333333333333334, "d": 0.8690476190476191, "mi": -0.5295278365045805, "fo": 0.08333333333333333, "r": -0.02631578947368421, "e": 0.7974712285979378}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5968_8b7946d8", "label": 1, "code": "@Override\npublic IResourceStream locate(Class<?> scope, String path, String style, String variation, Locale locale, String extension, boolean strict) {\n    CacheKey key = new CacheKey(scope.getName(), path, extension, locale, style, variation);\n    IResourceStreamReference resourceStreamReference = cache.get(key);\n    final IResourceStream result;\n    if (resourceStreamReference == null) {\n        result = delegate.locate(scope, path, style, variation, locale, extension, strict);\n        updateCache(key, result);\n    } else {\n        result = resourceStreamReference.getReference();\n    }\n    return result;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic IResourceStream locate(Class<?> scope, String path, String style, String variation, Locale locale, String extension, boolean strict) {\n    CacheKey key = new CacheKey(scope.getName(), path, extension, locale, style, variation);\n    IResourceStreamReference resourceStreamReference = cache.get(key);\n    final IResourceStream result;\n    if (resourceStreamReference == null) {\n        result = delegate.locate(scope, path, style, variation, locale, extension, strict);\n        updateCache(key, result);\n    } else {\n        result = resourceStreamReference.getReference();\n    }\n    return result;\n}", "lc": -0.045454545454545456, "pi": -0.1291866028708134, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": 0.03968253968253967, "mi": -0.0319943622269205, "fo": -0.08333333333333333, "r": -0.02631578947368421, "e": 0.09924909089861284}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4572_dfc56674", "label": 0, "code": "/**\n *  Splits the window with given index to two windows. First of those will have size specified by\n *  the argument, the other one will fill up the rest of the original window.\n *\n *  @param index\n *  @param size\n */\nprivate void splitWindow(int index, int size) {\n    PageWindowInternal window = windows.get(index);\n    int delta = window.filePartSize - size;\n    if (index == windows.size() - 1) {\n        // if this is last window\n        totalSize -= delta;\n        window.filePartSize = size;\n    } else if (window.filePartSize != size) {\n        PageWindowInternal newWindow = new PageWindowInternal();\n        newWindow.pageId = -1;\n        window.filePartSize = size;\n        windows.add(index + 1, newWindow);\n        newWindow.filePartOffset = getWindowFileOffset(index + 1);\n        newWindow.filePartSize = delta;\n    }\n    idToWindowIndex = null;\n}", "code_comment": "/**\n *  Splits the window with given index to two windows. First of those will have size specified by\n *  the argument, the other one will fill up the rest of the original window.\n *\n *  @param index\n *  @param size\n */\n", "code_no_comment": "private void splitWindow(int index, int size) {\n    PageWindowInternal window = windows.get(index);\n    int delta = window.filePartSize - size;\n    if (index == windows.size() - 1) {\n                totalSize -= delta;\n        window.filePartSize = size;\n    } else if (window.filePartSize != size) {\n        PageWindowInternal newWindow = new PageWindowInternal();\n        newWindow.pageId = -1;\n        window.filePartSize = size;\n        windows.add(index + 1, newWindow);\n        newWindow.filePartOffset = getWindowFileOffset(index + 1);\n        newWindow.filePartSize = delta;\n    }\n    idToWindowIndex = null;\n}", "lc": 0.09090909090909091, "pi": -0.10047846889952174, "ma": -0.2, "nbd": 0.0, "ml": 0.08333333333333333, "d": 1.1706349206349207, "mi": -0.14728682170542617, "fo": -0.16666666666666666, "r": 0.07894736842105263, "e": 0.9304564812733758}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5019_917dd2b5", "label": 3, "code": "/**\n *  Initializes the cache for the existence of the minified resource.\n *  @return the name of the minified resource or the special constant {@link #NO_MINIFIED_NAME}\n *  if there is no minified version\n */\nprivate String internalGetMinifiedName() {\n    String minifiedName = MINIFIED_NAMES_CACHE.get(this);\n    if (minifiedName != null && minifiedName != NO_MINIFIED_NAME) {\n        return minifiedName;\n    }\n    String name = getMinifiedName();\n    IResourceStreamLocator locator = Application.get().getResourceSettings().getResourceStreamLocator();\n    String absolutePath = Packages.absolutePath(getScope(), name);\n    IResourceStream stream = locator.locate(getScope(), absolutePath, getStyle(), getVariation(), getLocale(), null, true);\n    minifiedName = stream != null ? name : NO_MINIFIED_NAME;\n    MINIFIED_NAMES_CACHE.put(this, minifiedName);\n    if (minifiedName == NO_MINIFIED_NAME && log.isDebugEnabled()) {\n        log.debug(\"No minified version of '\" + super.getName() + \"' found, expected a file with the name '\" + name + \"', using full version\");\n    }\n    return minifiedName;\n}", "code_comment": "/**\n *  Initializes the cache for the existence of the minified resource.\n *  @return the name of the minified resource or the special constant {@link #NO_MINIFIED_NAME}\n *  if there is no minified version\n */\n", "code_no_comment": "private String internalGetMinifiedName() {\n    String minifiedName = MINIFIED_NAMES_CACHE.get(this);\n    if (minifiedName != null && minifiedName != NO_MINIFIED_NAME) {\n        return minifiedName;\n    }\n    String name = getMinifiedName();\n    IResourceStreamLocator locator = Application.get().getResourceSettings().getResourceStreamLocator();\n    String absolutePath = Packages.absolutePath(getScope(), name);\n    IResourceStream stream = locator.locate(getScope(), absolutePath, getStyle(), getVariation(), getLocale(), null, true);\n    minifiedName = stream != null ? name : NO_MINIFIED_NAME;\n    MINIFIED_NAMES_CACHE.put(this, minifiedName);\n    if (minifiedName == NO_MINIFIED_NAME && log.isDebugEnabled()) {\n        log.debug(\"No minified version of '\" + super.getName() + \"' found, expected a file with the name '\" + name + \"', using full version\");\n    }\n    return minifiedName;\n}", "lc": 0.09090909090909091, "pi": -0.47368421052631593, "ma": 0.0, "nbd": -0.5, "ml": 0.25, "d": 0.3333333333333333, "mi": -0.1822410147991544, "fo": 0.8333333333333334, "r": -0.02631578947368421, "e": 0.44105046593246994}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4927_8c827e33", "label": 1, "code": "@Override\npublic void clearCookie(Cookie cookie) {\n    checkHeader();\n    bufferedResponse.clearCookie(cookie);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void clearCookie(Cookie cookie) {\n    checkHeader();\n    bufferedResponse.clearCookie(cookie);\n}", "lc": -0.4090909090909091, "pi": -0.49282296650717716, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.7626497533474278, "fo": -0.3333333333333333, "r": 1.4736842105263157, "e": -0.16279340490885932}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-172_99e22ce4", "label": 1, "code": "/**\n *  @param component\n *             Component to remove from this container\n */\npublic void remove(final Component component) {\n    if (component == null) {\n        throw new IllegalArgumentException(\"argument component may not be null\");\n    }\n    if (children_remove(component) != null) {\n        component.setFlag(FLAG_REMOVED_FROM_PARENT, true);\n        removedComponent(component);\n    }\n}", "code_comment": "/**\n *  @param component\n *             Component to remove from this container\n */\n", "code_no_comment": "public void remove(final Component component) {\n    if (component == null) {\n        throw new IllegalArgumentException(\"argument component may not be null\");\n    }\n    if (children_remove(component) != null) {\n        component.setFlag(FLAG_REMOVED_FROM_PARENT, true);\n        removedComponent(component);\n    }\n}", "lc": -0.22727272727272727, "pi": -0.01913875598086126, "ma": 0.0, "nbd": -0.5, "ml": -0.08333333333333333, "d": -0.08333333333333336, "mi": 0.3206483439041578, "fo": -0.25, "r": 1.7631578947368423, "e": -0.11554664223186549}
{"project_name": "Math", "project_version": 81, "label": 1, "code": "/**\n * Compute the Gershgorin circles for all rows.\n */\nprivate void computeGershgorinCircles() {\n    final int m = main.length;\n    final int lowerStart = 4 * m;\n    final int upperStart = 5 * m;\n    lowerSpectra = Double.POSITIVE_INFINITY;\n    upperSpectra = Double.NEGATIVE_INFINITY;\n    double eMax = 0;\n    double eCurrent = 0;\n    for (int i = 0; i < m - 1; ++i) {\n        final double dCurrent = main[i];\n        final double ePrevious = eCurrent;\n        eCurrent = Math.abs(secondary[i]);\n        eMax = Math.max(eMax, eCurrent);\n        final double radius = ePrevious + eCurrent;\n        final double lower = dCurrent - radius;\n        work[lowerStart + i] = lower;\n        lowerSpectra = Math.min(lowerSpectra, lower);\n        final double upper = dCurrent + radius;\n        work[upperStart + i] = upper;\n        upperSpectra = Math.max(upperSpectra, upper);\n    }\n    final double dCurrent = main[m - 1];\n    final double lower = dCurrent - eCurrent;\n    work[lowerStart + m - 1] = lower;\n    lowerSpectra = Math.min(lowerSpectra, lower);\n    final double upper = dCurrent + eCurrent;\n    work[upperStart + m - 1] = upper;\n    minPivot = MathUtils.SAFE_MIN * Math.max(1.0, eMax * eMax);\n}", "code_comment": "/**\n * Compute the Gershgorin circles for all rows.\n */\n", "code_no_comment": "private void computeGershgorinCircles() {\n    final int m = main.length;\n    final int lowerStart = 4 * m;\n    final int upperStart = 5 * m;\n    lowerSpectra = Double.POSITIVE_INFINITY;\n    upperSpectra = Double.NEGATIVE_INFINITY;\n    double eMax = 0;\n    double eCurrent = 0;\n    for (int i = 0; i < m - 1; ++i) {\n        final double dCurrent = main[i];\n        final double ePrevious = eCurrent;\n        eCurrent = Math.abs(secondary[i]);\n        eMax = Math.max(eMax, eCurrent);\n        final double radius = ePrevious + eCurrent;\n        final double lower = dCurrent - radius;\n        work[lowerStart + i] = lower;\n        lowerSpectra = Math.min(lowerSpectra, lower);\n        final double upper = dCurrent + radius;\n        work[upperStart + i] = upper;\n        upperSpectra = Math.max(upperSpectra, upper);\n    }\n    final double dCurrent = main[m - 1];\n    final double lower = dCurrent - eCurrent;\n    work[lowerStart + m - 1] = lower;\n    lowerSpectra = Math.min(lowerSpectra, lower);\n    final double upper = dCurrent + eCurrent;\n    work[upperStart + m - 1] = upper;\n    minPivot = MathUtils.SAFE_MIN * Math.max(1.0, eMax * eMax);\n}", "lc": 0.6818181818181818, "pi": -0.29665071770334933, "ma": -0.4, "nbd": -0.5, "ml": -0.16666666666666666, "d": 1.4206349206349207, "mi": -0.5495419309372798, "fo": 0.0, "r": -0.02631578947368421, "e": 3.083305383148055}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-3433_e76d23b0", "label": 3, "code": "@Override\npublic String toString() {\n    return \"\" + expression + \".convertTo(\" + type.getCanonicalName() + \".class)\";\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic String toString() {\n    return \"\" + expression + \".convertTo(\" + type.getCanonicalName() + \".class)\";\n}", "lc": -0.45454545454545453, "pi": -0.6028708133971293, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.8046511627906971, "fo": -0.4166666666666667, "r": 1.8421052631578947, "e": -0.16279340490885932}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-412_5594b2e0", "label": 1, "code": "@Override\npublic void run() {\n    ClientService.Iface client = null;\n    try {\n        client = ServerClient.getConnection(HdfsZooInstance.getInstance());\n        List<String> fail = client.bulkImportFiles(null, SecurityConstants.getSystemCredentials(), tid, tableId, attempt, errorDir, setTime);\n        attempt.removeAll(fail);\n        filesToLoad.removeAll(attempt);\n    } catch (Exception ex) {\n        log.error(ex, ex);\n    } finally {\n        ServerClient.close(client);\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void run() {\n    ClientService.Iface client = null;\n    try {\n        client = ServerClient.getConnection(HdfsZooInstance.getInstance());\n        List<String> fail = client.bulkImportFiles(null, SecurityConstants.getSystemCredentials(), tid, tableId, attempt, errorDir, setTime);\n        attempt.removeAll(fail);\n        filesToLoad.removeAll(attempt);\n    } catch (Exception ex) {\n        log.error(ex, ex);\n    } finally {\n        ServerClient.close(client);\n    }\n}", "lc": 0.0, "pi": 0.04784688995215294, "ma": -0.4, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": -0.024947145877378573, "fo": 0.16666666666666666, "r": -0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "Closure", "project_version": 37, "label": 2, "code": "/**\n * Traverses a function.\n */\nprivate void traverseFunction(Node n, Node parent) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.isFunction());\n    final Node fnName = n.getFirstChild();\n    boolean isFunctionExpression = (parent != null) && NodeUtil.isFunctionExpression(n);\n    if (!isFunctionExpression) {\n        // Functions declarations are in the scope containing the declaration.\n        traverseBranch(fnName, n);\n    }\n    curNode = n;\n    pushScope(n);\n    if (isFunctionExpression) {\n        // Function expression names are only accessible within the function\n        // scope.\n        traverseBranch(fnName, n);\n    }\n    final Node args = fnName.getNext();\n    final Node body = args.getNext();\n    // Args\n    traverseBranch(args, n);\n    // Body\n    Preconditions.checkState(body.getNext() == null && body.isBlock());\n    traverseBranch(body, n);\n    popScope();\n}", "code_comment": "/**\n * Traverses a function.\n */\n", "code_no_comment": "private void traverseFunction(Node n, Node parent) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.isFunction());\n    final Node fnName = n.getFirstChild();\n    boolean isFunctionExpression = (parent != null) && NodeUtil.isFunctionExpression(n);\n    if (!isFunctionExpression) {\n                traverseBranch(fnName, n);\n    }\n    curNode = n;\n    pushScope(n);\n    if (isFunctionExpression) {\n                        traverseBranch(fnName, n);\n    }\n    final Node args = fnName.getNext();\n    final Node body = args.getNext();\n        traverseBranch(args, n);\n        Preconditions.checkState(body.getNext() == null && body.isBlock());\n    traverseBranch(body, n);\n    popScope();\n}", "lc": 0.2727272727272727, "pi": -0.5741626794258374, "ma": -0.2, "nbd": -0.5, "ml": -0.16666666666666666, "d": 0.6527777777777778, "mi": -0.262861169837914, "fo": 0.9166666666666666, "r": 0.2368421052631579, "e": 0.6331679373915848}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-1088_63d88c74", "label": 3, "code": "/**\n * @return the unidimensional count after the counter has been\n * incremented by {@code 1}.\n */\npublic Integer next() {\n    for (int i = last; i >= 0; i--) {\n        if (counter[i] == size[i] - 1) {\n            counter[i] = 0;\n        } else {\n            ++counter[i];\n            break;\n        }\n    }\n    return ++count;\n}", "code_comment": "/**\n * @return the unidimensional count after the counter has been\n * incremented by {@code 1}.\n */\n", "code_no_comment": "public Integer next() {\n    for (int i = last; i >= 0; i--) {\n        if (counter[i] == size[i] - 1) {\n            counter[i] = 0;\n        } else {\n            ++counter[i];\n            break;\n        }\n    }\n    return ++count;\n}", "lc": -0.13636363636363635, "pi": 0.6124401913875596, "ma": 0.0, "nbd": 0.0, "ml": -0.16666666666666666, "d": 0.7658730158730159, "mi": 0.1704016913319239, "fo": -0.5, "r": 2.3947368421052633, "e": 0.12101911562156023}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1727_26041fe7", "label": 1, "code": "@Override\npublic int compare(Revision o1, Revision o2) {\n    if (o1.getClusterId() == o2.getClusterId()) {\n        return o1.compareRevisionTime(o2);\n    }\n    Revision range1 = getRevisionSeen(o1);\n    Revision range2 = getRevisionSeen(o2);\n    if (range1 == FUTURE && range2 == FUTURE) {\n        return o1.compareRevisionTimeThenClusterId(o2);\n    }\n    if (range1 == null || range2 == null) {\n        return o1.compareRevisionTimeThenClusterId(o2);\n    }\n    int comp = range1.compareRevisionTimeThenClusterId(range2);\n    if (comp != 0) {\n        return comp;\n    }\n    return Integer.signum(o1.getClusterId() - o2.getClusterId());\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic int compare(Revision o1, Revision o2) {\n    if (o1.getClusterId() == o2.getClusterId()) {\n        return o1.compareRevisionTime(o2);\n    }\n    Revision range1 = getRevisionSeen(o1);\n    Revision range2 = getRevisionSeen(o2);\n    if (range1 == FUTURE && range2 == FUTURE) {\n        return o1.compareRevisionTimeThenClusterId(o2);\n    }\n    if (range1 == null || range2 == null) {\n        return o1.compareRevisionTimeThenClusterId(o2);\n    }\n    int comp = range1.compareRevisionTimeThenClusterId(range2);\n    if (comp != 0) {\n        return comp;\n    }\n    return Integer.signum(o1.getClusterId() - o2.getClusterId());\n}", "lc": 0.22727272727272727, "pi": -0.2727272727272729, "ma": 0.2, "nbd": -0.5, "ml": 0.5, "d": 1.255952380952381, "mi": -0.2250880902043692, "fo": 0.4166666666666667, "r": 0.02631578947368421, "e": 0.8902450971917265}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5447_2abc18f1", "label": 3, "code": "@Override\npublic void afterRender(Component component) {\n    Response response = component.getResponse();\n    for (int i = 0; i < branches.length; i++) {\n        response.write(\"</div>\");\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void afterRender(Component component) {\n    Response response = component.getResponse();\n    for (int i = 0; i < branches.length; i++) {\n        response.write(\"</div>\");\n    }\n}", "lc": -0.3181818181818182, "pi": -0.0909090909090911, "ma": -0.4, "nbd": -0.5, "ml": -0.16666666666666666, "d": -0.10912698412698414, "mi": 0.41649048625792817, "fo": -0.3333333333333333, "r": 0.6052631578947368, "e": -0.109488655682532}
{"project_name": "Lang", "project_version": 33, "label": 1, "code": "/**\n * <p>Converts an array of <code>Object</code> in to an array of <code>Class</code> objects.\n * If any of these objects is null, a null element will be inserted into the array.</p>\n *\n * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n *\n * @param array an <code>Object</code> array\n * @return a <code>Class</code> array, <code>null</code> if null array input\n * @since 2.4\n */\npublic static Class<?>[] toClass(Object[] array) {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return ArrayUtils.EMPTY_CLASS_ARRAY;\n    }\n    Class<?>[] classes = new Class[array.length];\n    for (int i = 0; i < array.length; i++) {\n        classes[i] = array[i].getClass();\n    }\n    return classes;\n}", "code_comment": "/**\n * <p>Converts an array of <code>Object</code> in to an array of <code>Class</code> objects.\n * If any of these objects is null, a null element will be inserted into the array.</p>\n *\n * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n *\n * @param array an <code>Object</code> array\n * @return a <code>Class</code> array, <code>null</code> if null array input\n * @since 2.4\n */\n", "code_no_comment": "public static Class<?>[] toClass(Object[] array) {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return ArrayUtils.EMPTY_CLASS_ARRAY;\n    }\n    Class<?>[] classes = new Class[array.length];\n    for (int i = 0; i < array.length; i++) {\n        classes[i] = array[i].getClass();\n    }\n    return classes;\n}", "lc": -0.09090909090909091, "pi": -0.20574162679425848, "ma": 0.0, "nbd": 0.0, "ml": 0.08333333333333333, "d": 0.5515873015873016, "mi": 0.081324876673714, "fo": -0.4166666666666667, "r": -0.02631578947368421, "e": 0.15901292624032545}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-621_00b4b8a0", "label": 1, "code": "@Override\nprotected synchronized NodeBuilder getNodeBuilder() {\n    if (nodeBuilder == null) {\n        nodeBuilder = root.createRootBuilder();\n    }\n    return nodeBuilder;\n}", "code_comment": NaN, "code_no_comment": "@Override\nprotected synchronized NodeBuilder getNodeBuilder() {\n    if (nodeBuilder == null) {\n        nodeBuilder = root.createRootBuilder();\n    }\n    return nodeBuilder;\n}", "lc": -0.3181818181818182, "pi": -0.0909090909090911, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": -0.11706349206349208, "mi": 0.5357293868921773, "fo": -0.4166666666666667, "r": 1.3157894736842106, "e": -0.13982008148775665}
{"project_name": "Lang", "project_version": 20, "label": 1, "code": "/**\n * <p>Joins the elements of the provided array into a single String\n * containing the provided list of elements.</p>\n *\n * <p>No delimiter is added before or after the list.\n * A {@code null} separator is the same as an empty String (\"\").\n * Null objects or empty strings within the array are represented by\n * empty strings.</p>\n *\n * <pre>\n * StringUtils.join(null, *)                = null\n * StringUtils.join([], *)                  = \"\"\n * StringUtils.join([null], *)              = \"\"\n * StringUtils.join([\"a\", \"b\", \"c\"], \"--\")  = \"a--b--c\"\n * StringUtils.join([\"a\", \"b\", \"c\"], null)  = \"abc\"\n * StringUtils.join([\"a\", \"b\", \"c\"], \"\")    = \"abc\"\n * StringUtils.join([null, \"\", \"a\"], ',')   = \",,a\"\n * </pre>\n *\n * @param array  the array of values to join together, may be null\n * @param separator  the separator character to use, null treated as \"\"\n * @param startIndex the first index to start joining from.  It is\n * an error to pass in an end index past the end of the array\n * @param endIndex the index to stop joining from (exclusive). It is\n * an error to pass in an end index past the end of the array\n * @return the joined String, {@code null} if null array input\n */\npublic static String join(Object[] array, String separator, int startIndex, int endIndex) {\n    if (array == null) {\n        return null;\n    }\n    if (separator == null) {\n        separator = EMPTY;\n    }\n    // endIndex - startIndex > 0:   Len = NofStrings *(len(firstString) + len(separator))\n    // (Assuming that all Strings are roughly equally long)\n    int noOfItems = (endIndex - startIndex);\n    if (noOfItems <= 0) {\n        return EMPTY;\n    }\n    StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length());\n    for (int i = startIndex; i < endIndex; i++) {\n        if (i > startIndex) {\n            buf.append(separator);\n        }\n        if (array[i] != null) {\n            buf.append(array[i]);\n        }\n    }\n    return buf.toString();\n}", "code_comment": "/**\n * <p>Joins the elements of the provided array into a single String\n * containing the provided list of elements.</p>\n *\n * <p>No delimiter is added before or after the list.\n * A {@code null} separator is the same as an empty String (\"\").\n * Null objects or empty strings within the array are represented by\n * empty strings.</p>\n *\n * <pre>\n * StringUtils.join(null, *)                = null\n * StringUtils.join([], *)                  = \"\"\n * StringUtils.join([null], *)              = \"\"\n * StringUtils.join([\"a\", \"b\", \"c\"], \"--\")  = \"a--b--c\"\n * StringUtils.join([\"a\", \"b\", \"c\"], null)  = \"abc\"\n * StringUtils.join([\"a\", \"b\", \"c\"], \"\")    = \"abc\"\n * StringUtils.join([null, \"\", \"a\"], ',')   = \",,a\"\n * </pre>\n *\n * @param array  the array of values to join together, may be null\n * @param separator  the separator character to use, null treated as \"\"\n * @param startIndex the first index to start joining from.  It is\n * an error to pass in an end index past the end of the array\n * @param endIndex the index to stop joining from (exclusive). It is\n * an error to pass in an end index past the end of the array\n * @return the joined String, {@code null} if null array input\n */\n", "code_no_comment": "public static String join(Object[] array, String separator, int startIndex, int endIndex) {\n    if (array == null) {\n        return null;\n    }\n    if (separator == null) {\n        separator = EMPTY;\n    }\n            int noOfItems = (endIndex - startIndex);\n    if (noOfItems <= 0) {\n        return EMPTY;\n    }\n    StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length());\n    for (int i = startIndex; i < endIndex; i++) {\n        if (i > startIndex) {\n            buf.append(separator);\n        }\n        if (array[i] != null) {\n            buf.append(array[i]);\n        }\n    }\n    return buf.toString();\n}", "lc": 0.36363636363636365, "pi": 0.057416267942583574, "ma": 0.8, "nbd": 0.0, "ml": 0.6666666666666666, "d": 1.8908730158730158, "mi": -0.3344608879492598, "fo": 0.0, "r": -0.02631578947368421, "e": 1.55056563106908}
{"project_name": "Math", "project_version": 34, "label": 1, "code": "/**\n * Returns an iterator over the unmodifiable list of chromosomes.\n * <p>Any call to {@link Iterator#remove()} will result in a {@link UnsupportedOperationException}.</p>\n *\n * @return chromosome iterator\n */\npublic Iterator<Chromosome> iterator() {\n    return chromosomes.iterator();\n}", "code_comment": "/**\n * Returns an iterator over the unmodifiable list of chromosomes.\n * <p>Any call to {@link Iterator#remove()} will result in a {@link UnsupportedOperationException}.</p>\n *\n * @return chromosome iterator\n */\n", "code_no_comment": "public Iterator<Chromosome> iterator() {\n    return chromosomes.iterator();\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.083157152924595, "fo": -0.4166666666666667, "r": 2.5789473684210527, "e": -0.16279340490885932}
{"project_name": "Compress", "project_version": 24, "label": 0, "code": "/**\n * Parse an octal string from a buffer.\n *\n * <p>Leading spaces are ignored.\n * The buffer must contain a trailing space or NUL,\n * and may contain an additional trailing space or NUL.</p>\n *\n * <p>The input buffer is allowed to contain all NULs,\n * in which case the method returns 0L\n * (this allows for missing fields).</p>\n *\n * <p>To work-around some tar implementations that insert a\n * leading NUL this method returns 0 if it detects a leading NUL\n * since Commons Compress 1.4.</p>\n *\n * @param buffer The buffer from which to parse.\n * @param offset The offset into the buffer from which to parse.\n * @param length The maximum number of bytes to parse - must be at least 2 bytes.\n * @return The long value of the octal string.\n * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n */\npublic static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long result = 0;\n    int end = offset + length;\n    int start = offset;\n    if (length < 2) {\n        throw new IllegalArgumentException(\"Length \" + length + \" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    // Skip leading spaces\n    while (start < end) {\n        if (buffer[start] == ' ') {\n            start++;\n        } else {\n            break;\n        }\n    }\n    // Trim all trailing NULs and spaces.\n    // The ustar and POSIX tar specs require a trailing NUL or\n    // space but some implementations use the extra digit for big\n    // sizes/uids/gids ...\n    byte trailer = buffer[end - 1];\n    if (trailer == 0 || trailer == ' ') {\n        end--;\n    } else {\n        throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, end - 1, trailer));\n    }\n    trailer = buffer[end - 1];\n    while (start < end - 1 && (trailer == 0 || trailer == ' ')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for (; start < end; start++) {\n        final byte currentByte = buffer[start];\n        // CheckStyle:MagicNumber OFF\n        if (currentByte < '0' || currentByte > '7') {\n            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));\n        }\n        // convert from ASCII\n        result = (result << 3) + (currentByte - '0');\n    // CheckStyle:MagicNumber ON\n    }\n    return result;\n}", "code_comment": "/**\n * Parse an octal string from a buffer.\n *\n * <p>Leading spaces are ignored.\n * The buffer must contain a trailing space or NUL,\n * and may contain an additional trailing space or NUL.</p>\n *\n * <p>The input buffer is allowed to contain all NULs,\n * in which case the method returns 0L\n * (this allows for missing fields).</p>\n *\n * <p>To work-around some tar implementations that insert a\n * leading NUL this method returns 0 if it detects a leading NUL\n * since Commons Compress 1.4.</p>\n *\n * @param buffer The buffer from which to parse.\n * @param offset The offset into the buffer from which to parse.\n * @param length The maximum number of bytes to parse - must be at least 2 bytes.\n * @return The long value of the octal string.\n * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n */\n", "code_no_comment": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long result = 0;\n    int end = offset + length;\n    int start = offset;\n    if (length < 2) {\n        throw new IllegalArgumentException(\"Length \" + length + \" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n        while (start < end) {\n        if (buffer[start] == ' ') {\n            start++;\n        } else {\n            break;\n        }\n    }\n                    byte trailer = buffer[end - 1];\n    if (trailer == 0 || trailer == ' ') {\n        end--;\n    } else {\n        throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, end - 1, trailer));\n    }\n    trailer = buffer[end - 1];\n    while (start < end - 1 && (trailer == 0 || trailer == ' ')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for (; start < end; start++) {\n        final byte currentByte = buffer[start];\n                if (currentByte < '0' || currentByte > '7') {\n            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));\n        }\n                result = (result << 3) + (currentByte - '0');\n        }\n    return result;\n}", "lc": 1.0454545454545454, "pi": -0.05263157894736858, "ma": 1.8, "nbd": 0.0, "ml": 1.0, "d": 3.6031746031746033, "mi": -0.6958421423537702, "fo": -0.3333333333333333, "r": -0.02631578947368421, "e": 5.461821199495167}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-621_00b4b8a0", "label": 1, "code": "@Override\npublic Iterable<? extends PropertyState> getProperties() {\n    root.checkLive();\n    return Iterables.filter(getNodeBuilder().getProperties(), new Predicate<PropertyState>() {\n\n        @Override\n        public boolean apply(PropertyState propertyState) {\n            return canRead(propertyState);\n        }\n    });\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic Iterable<? extends PropertyState> getProperties() {\n    root.checkLive();\n    return Iterables.filter(getNodeBuilder().getProperties(), new Predicate<PropertyState>() {\n\n        @Override\n        public boolean apply(PropertyState propertyState) {\n            return canRead(propertyState);\n        }\n    });\n}", "lc": -0.18181818181818182, "pi": 0.4449760765550238, "ma": -0.6, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.2918957011980268, "fo": -0.08333333333333333, "r": 0.3684210526315789, "e": -0.16279340490885932}
{"project_name": "Closure", "project_version": 11, "label": 2, "code": "/**\n * Visits a GETPROP node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n * @param parent The parent of <code>n</code>\n */\nprivate void visitGetProp(NodeTraversal t, Node n, Node parent) {\n    // obj.prop or obj.method()\n    // Lots of types can appear on the left, a call to a void function can\n    // never be on the left. getPropertyType will decide what is acceptable\n    // and what isn't.\n    Node property = n.getLastChild();\n    Node objNode = n.getFirstChild();\n    JSType childType = getJSType(objNode);\n    if (childType.isDict()) {\n        report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n    } else if (n.getJSType() != null && parent.isAssign()) {\n        return;\n    } else if (validator.expectNotNullOrUndefined(t, n, childType, \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n        checkPropertyAccess(childType, property.getString(), t, n);\n    }\n    ensureTyped(t, n);\n}", "code_comment": "/**\n * Visits a GETPROP node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n * @param parent The parent of <code>n</code>\n */\n", "code_no_comment": "private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n                    Node property = n.getLastChild();\n    Node objNode = n.getFirstChild();\n    JSType childType = getJSType(objNode);\n    if (childType.isDict()) {\n        report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n    } else if (n.getJSType() != null && parent.isAssign()) {\n        return;\n    } else if (validator.expectNotNullOrUndefined(t, n, childType, \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n        checkPropertyAccess(childType, property.getString(), t, n);\n    }\n    ensureTyped(t, n);\n}", "lc": -0.045454545454545456, "pi": -0.25358851674641164, "ma": 0.0, "nbd": 0.5, "ml": 0.5833333333333334, "d": -0.0277777777777778, "mi": -0.046934460887949024, "fo": 0.5, "r": 0.0, "e": 0.058608945211873924}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-43_668f08f2", "label": 1, "code": "void apply() throws Exception {\n    copyNode(srcPath, destPath);\n}", "code_comment": NaN, "code_no_comment": "void apply() throws Exception {\n    copyNode(srcPath, destPath);\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.0676532769556022, "fo": -0.4166666666666667, "r": 1.6578947368421053, "e": -0.16279340490885932}
{"project_name": "Lang", "project_version": 36, "label": 3, "code": "/**\n * <p>Checks whether the String a valid Java number.</p>\n *\n * <p>Valid numbers include hexadecimal marked with the <code>0x</code>\n * qualifier, scientific notation and numbers marked with a type\n * qualifier (e.g. 123L).</p>\n *\n * <p><code>Null</code> and empty String will return\n * <code>false</code>.</p>\n *\n * @param str  the <code>String</code> to check\n * @return <code>true</code> if the string is a correctly formatted number\n */\npublic static boolean isNumber(String str) {\n    if (StringUtils.isEmpty(str)) {\n        return false;\n    }\n    char[] chars = str.toCharArray();\n    int sz = chars.length;\n    boolean hasExp = false;\n    boolean hasDecPoint = false;\n    boolean allowSigns = false;\n    boolean foundDigit = false;\n    // deal with any possible sign up front\n    int start = (chars[0] == '-') ? 1 : 0;\n    if (sz > start + 1) {\n        if (chars[start] == '0' && chars[start + 1] == 'x') {\n            int i = start + 2;\n            if (i == sz) {\n                // str == \"0x\"\n                return false;\n            }\n            // checking hex (it can't be anything else)\n            for (; i < chars.length; i++) {\n                if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    // don't want to loop to the last char, check it afterwords\n    sz--;\n    // for type qualifiers\n    int i = start;\n    // make a valid number (e.g. chars[0..5] = \"1234E\")\n    while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {\n        if (chars[i] >= '0' && chars[i] <= '9') {\n            foundDigit = true;\n            allowSigns = false;\n        } else if (chars[i] == '.') {\n            if (hasDecPoint || hasExp) {\n                // two decimal points or dec in exponent\n                return false;\n            }\n            hasDecPoint = true;\n        } else if (chars[i] == 'e' || chars[i] == 'E') {\n            // we've already taken care of hex.\n            if (hasExp) {\n                // two E's\n                return false;\n            }\n            if (!foundDigit) {\n                return false;\n            }\n            hasExp = true;\n            allowSigns = true;\n        } else if (chars[i] == '+' || chars[i] == '-') {\n            if (!allowSigns) {\n                return false;\n            }\n            allowSigns = false;\n            // we need a digit after the E\n            foundDigit = false;\n        } else {\n            return false;\n        }\n        i++;\n    }\n    if (i < chars.length) {\n        if (chars[i] >= '0' && chars[i] <= '9') {\n            // no type qualifier, OK\n            return true;\n        }\n        if (chars[i] == 'e' || chars[i] == 'E') {\n            // can't have an E at the last byte\n            return false;\n        }\n        if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) {\n            return foundDigit;\n        }\n        if (chars[i] == 'l' || chars[i] == 'L') {\n            // not allowing L with an exponent\n            return foundDigit && !hasExp;\n        }\n        // last character is illegal\n        return false;\n    }\n    // found digit it to make sure weird stuff like '.' and '1E-' doesn't pass\n    return !allowSigns && foundDigit;\n}", "code_comment": "/**\n * <p>Checks whether the String a valid Java number.</p>\n *\n * <p>Valid numbers include hexadecimal marked with the <code>0x</code>\n * qualifier, scientific notation and numbers marked with a type\n * qualifier (e.g. 123L).</p>\n *\n * <p><code>Null</code> and empty String will return\n * <code>false</code>.</p>\n *\n * @param str  the <code>String</code> to check\n * @return <code>true</code> if the string is a correctly formatted number\n */\n", "code_no_comment": "public static boolean isNumber(String str) {\n    if (StringUtils.isEmpty(str)) {\n        return false;\n    }\n    char[] chars = str.toCharArray();\n    int sz = chars.length;\n    boolean hasExp = false;\n    boolean hasDecPoint = false;\n    boolean allowSigns = false;\n    boolean foundDigit = false;\n        int start = (chars[0] == '-') ? 1 : 0;\n    if (sz > start + 1) {\n        if (chars[start] == '0' && chars[start + 1] == 'x') {\n            int i = start + 2;\n            if (i == sz) {\n                                return false;\n            }\n                        for (; i < chars.length; i++) {\n                if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n        sz--;\n        int i = start;\n        while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {\n        if (chars[i] >= '0' && chars[i] <= '9') {\n            foundDigit = true;\n            allowSigns = false;\n        } else if (chars[i] == '.') {\n            if (hasDecPoint || hasExp) {\n                                return false;\n            }\n            hasDecPoint = true;\n        } else if (chars[i] == 'e' || chars[i] == 'E') {\n                        if (hasExp) {\n                                return false;\n            }\n            if (!foundDigit) {\n                return false;\n            }\n            hasExp = true;\n            allowSigns = true;\n        } else if (chars[i] == '+' || chars[i] == '-') {\n            if (!allowSigns) {\n                return false;\n            }\n            allowSigns = false;\n                        foundDigit = false;\n        } else {\n            return false;\n        }\n        i++;\n    }\n    if (i < chars.length) {\n        if (chars[i] >= '0' && chars[i] <= '9') {\n                        return true;\n        }\n        if (chars[i] == 'e' || chars[i] == 'E') {\n                        return false;\n        }\n        if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) {\n            return foundDigit;\n        }\n        if (chars[i] == 'l' || chars[i] == 'L') {\n                        return foundDigit && !hasExp;\n        }\n                return false;\n    }\n        return !allowSigns && foundDigit;\n}", "lc": 2.6818181818181817, "pi": 0.6076555023923443, "ma": 3.6, "nbd": 2.0, "ml": 3.8333333333333335, "d": 5.125, "mi": -1.1846370683579983, "fo": -0.3333333333333333, "r": -0.02631578947368421, "e": 17.504162560582742}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-498_f2a2edec", "label": 1, "code": "@Override\npublic boolean parent() {\n    if (elements.isEmpty() || \"..\".equals(elements.get(elements.size() - 1))) {\n        elements.add(\"..\");\n        return true;\n    }\n    elements.remove(elements.size() - 1);\n    return true;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean parent() {\n    if (elements.isEmpty() || \"..\".equals(elements.get(elements.size() - 1))) {\n        elements.add(\"..\");\n        return true;\n    }\n    elements.remove(elements.size() - 1);\n    return true;\n}", "lc": -0.22727272727272727, "pi": -0.01913875598086126, "ma": -0.4, "nbd": -0.5, "ml": 0.08333333333333333, "d": -0.029761904761904788, "mi": 0.2896405919661735, "fo": 0.08333333333333333, "r": -0.02631578947368421, "e": -0.08658909769886412}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-7239_ae419224", "label": 1, "code": "// Properties\n// -----------------------------------------------------------------------\npublic Schema getSchema() throws IOException, SAXException {\n    if (schema == null) {\n        schema = createSchema();\n    }\n    return schema;\n}", "code_comment": NaN, "code_no_comment": "public Schema getSchema() throws IOException, SAXException {\n    if (schema == null) {\n        schema = createSchema();\n    }\n    return schema;\n}", "lc": -0.36363636363636365, "pi": -0.11483253588516758, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": -0.11706349206349208, "mi": 0.6062015503875966, "fo": -0.4166666666666667, "r": 2.5789473684210527, "e": -0.13982008148775665}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5724_b92591f6", "label": 1, "code": "/**\n *  Creates a new instance of auto component to be queued\n */\nComponent newComponent(ComponentTag tag);", "code_comment": "/**\n *  Creates a new instance of auto component to be queued\n */\n", "code_no_comment": "Component newComponent(ComponentTag tag);", "lc": -0.5909090909090909, "pi": -1.4306220095693782, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.6116983791402395, "fo": -0.5, "r": 2.6052631578947367, "e": -0.16279340490885932}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-2713_6138a80f", "label": 0, "code": "public static CryptoModuleParameters fillParamsObjectFromConfiguration(CryptoModuleParameters params, AccumuloConfiguration conf) {\n    // Get all the options from the configuration\n    Map<String, String> cryptoOpts = conf.getAllPropertiesWithPrefix(Property.CRYPTO_PREFIX);\n    cryptoOpts.putAll(conf.getAllPropertiesWithPrefix(Property.INSTANCE_PREFIX));\n    cryptoOpts.put(Property.CRYPTO_BLOCK_STREAM_SIZE.getKey(), Integer.toString((int) conf.getMemoryInBytes(Property.CRYPTO_BLOCK_STREAM_SIZE)));\n    return fillParamsObjectFromStringMap(params, cryptoOpts);\n}", "code_comment": NaN, "code_no_comment": "public static CryptoModuleParameters fillParamsObjectFromConfiguration(CryptoModuleParameters params, AccumuloConfiguration conf) {\n        Map<String, String> cryptoOpts = conf.getAllPropertiesWithPrefix(Property.CRYPTO_PREFIX);\n    cryptoOpts.putAll(conf.getAllPropertiesWithPrefix(Property.INSTANCE_PREFIX));\n    cryptoOpts.put(Property.CRYPTO_BLOCK_STREAM_SIZE.getKey(), Integer.toString((int) conf.getMemoryInBytes(Property.CRYPTO_BLOCK_STREAM_SIZE)));\n    return fillParamsObjectFromStringMap(params, cryptoOpts);\n}", "lc": -0.36363636363636365, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.4085976039464412, "fo": 0.16666666666666666, "r": 0.0, "e": -0.16279340490885932}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-957_9aabf587", "label": 1, "code": "/**\n * {@inheritDoc}\n */\n@Override\nprotected double getSolverAbsoluteAccuracy() {\n    return solverAbsoluteAccuracy;\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "@Override\nprotected double getSolverAbsoluteAccuracy() {\n    return solverAbsoluteAccuracy;\n}", "lc": -0.45454545454545453, "pi": -0.6028708133971293, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.0332628611698378, "fo": -0.5, "r": 2.526315789473684, "e": -0.16279340490885932}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-3545_050c542e", "label": 1, "code": "@Override\npublic Expression createExpression(CamelContext camelContext) {\n    if (beanType != null) {\n        instance = ObjectHelper.newInstance(beanType);\n        return new BeanExpression(instance, getMethod(), parameterType);\n    } else if (instance != null) {\n        return new BeanExpression(instance, getMethod(), parameterType);\n    } else {\n        String ref = beanName();\n        // if its a ref then check that the ref exists\n        BeanHolder holder = new RegistryBean(camelContext, ref);\n        // get the bean which will check that it exists\n        instance = holder.getBean();\n        // only validate when it was a ref for a bean, so we can eager check\n        // this on startup of Camel\n        validateHasMethod(camelContext, instance, getMethod(), parameterType);\n        return new BeanExpression(ref, getMethod(), parameterType);\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic Expression createExpression(CamelContext camelContext) {\n    if (beanType != null) {\n        instance = ObjectHelper.newInstance(beanType);\n        return new BeanExpression(instance, getMethod(), parameterType);\n    } else if (instance != null) {\n        return new BeanExpression(instance, getMethod(), parameterType);\n    } else {\n        String ref = beanName();\n                BeanHolder holder = new RegistryBean(camelContext, ref);\n                instance = holder.getBean();\n                        validateHasMethod(camelContext, instance, getMethod(), parameterType);\n        return new BeanExpression(ref, getMethod(), parameterType);\n    }\n}", "lc": 0.045454545454545456, "pi": 0.08133971291866025, "ma": -0.2, "nbd": 0.0, "ml": -0.08333333333333333, "d": 0.013888888888888857, "mi": -0.0692036645525017, "fo": 0.16666666666666666, "r": -0.02631578947368421, "e": 0.03091002345510391}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-891_2b852d79", "label": 1, "code": "/**\n * Computes the Spearman's rank correlation matrix for the columns of the\n * input matrix.\n *\n * @param matrix matrix with columns representing variables to correlate\n * @return correlation matrix\n */\npublic RealMatrix computeCorrelationMatrix(RealMatrix matrix) {\n    RealMatrix matrixCopy = matrix.copy();\n    rankTransform(matrixCopy);\n    return new PearsonsCorrelation().computeCorrelationMatrix(matrixCopy);\n}", "code_comment": "/**\n * Computes the Spearman's rank correlation matrix for the columns of the\n * input matrix.\n *\n * @param matrix matrix with columns representing variables to correlate\n * @return correlation matrix\n */\n", "code_no_comment": "public RealMatrix computeCorrelationMatrix(RealMatrix matrix) {\n    RealMatrix matrixCopy = matrix.copy();\n    rankTransform(matrixCopy);\n    return new PearsonsCorrelation().computeCorrelationMatrix(matrixCopy);\n}", "lc": -0.4090909090909091, "pi": -0.49282296650717716, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.6701902748414377, "fo": -0.25, "r": 2.1842105263157894, "e": -0.16279340490885932}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1429_c2f5ca6c", "label": 1, "code": "@Override\npublic DocumentNodeState apply(String input) {\n    return getNode(input, readRevision);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic DocumentNodeState apply(String input) {\n    return getNode(input, readRevision);\n}", "lc": -0.45454545454545453, "pi": -0.6028708133971293, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.8548273431994357, "fo": -0.4166666666666667, "r": 1.526315789473684, "e": -0.16279340490885932}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-7795_19b2aa31", "label": 1, "code": "public void done(boolean doneSync) {\n    try {\n        if (!doneSync) {\n            // when done asynchronously then restore information from previous thread\n            if (breadcrumbId != null) {\n                MDC.put(MDC_BREADCRUMB_ID, breadcrumbId);\n            }\n            if (exchangeId != null) {\n                MDC.put(MDC_EXCHANGE_ID, exchangeId);\n            }\n            if (messageId != null) {\n                MDC.put(MDC_MESSAGE_ID, messageId);\n            }\n            if (correlationId != null) {\n                MDC.put(MDC_CORRELATION_ID, correlationId);\n            }\n            if (routeId != null) {\n                MDC.put(MDC_ROUTE_ID, routeId);\n            }\n            if (camelContextId != null) {\n                MDC.put(MDC_CAMEL_CONTEXT_ID, camelContextId);\n            }\n        }\n    } finally {\n        // muse ensure delegate is invoked\n        delegate.done(doneSync);\n    }\n}", "code_comment": NaN, "code_no_comment": "public void done(boolean doneSync) {\n    try {\n        if (!doneSync) {\n                        if (breadcrumbId != null) {\n                MDC.put(MDC_BREADCRUMB_ID, breadcrumbId);\n            }\n            if (exchangeId != null) {\n                MDC.put(MDC_EXCHANGE_ID, exchangeId);\n            }\n            if (messageId != null) {\n                MDC.put(MDC_MESSAGE_ID, messageId);\n            }\n            if (correlationId != null) {\n                MDC.put(MDC_CORRELATION_ID, correlationId);\n            }\n            if (routeId != null) {\n                MDC.put(MDC_ROUTE_ID, routeId);\n            }\n            if (camelContextId != null) {\n                MDC.put(MDC_CAMEL_CONTEXT_ID, camelContextId);\n            }\n        }\n    } finally {\n                delegate.done(doneSync);\n    }\n}", "lc": 0.5454545454545454, "pi": 0.8181818181818182, "ma": 0.8, "nbd": 0.5, "ml": 0.75, "d": 0.08333333333333327, "mi": -0.35250176180408715, "fo": 0.08333333333333333, "r": -0.02631578947368421, "e": 0.06635431614252862}
{"project_name": "Closure", "project_version": 98, "label": 1, "code": "/**\n * @return Whether the variable is only assigned a value once for its\n *     lifetime.\n */\nboolean isAssignedOnceInLifetime() {\n    Reference ref = getOneAndOnlyAssignment();\n    if (ref == null) {\n        return false;\n    }\n    return true;\n}", "code_comment": "/**\n * @return Whether the variable is only assigned a value once for its\n *     lifetime.\n */\n", "code_no_comment": "boolean isAssignedOnceInLifetime() {\n    Reference ref = getOneAndOnlyAssignment();\n    if (ref == null) {\n        return false;\n    }\n    return true;\n}", "lc": -0.3181818181818182, "pi": -0.20574162679425848, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": -0.14285714285714285, "mi": 0.5484143763213529, "fo": -0.4166666666666667, "r": 2.5, "e": -0.14384029782795363}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1287_14849e22", "label": 1, "code": "public List<RecordId> getEntries() {\n    if (size == 0) {\n        return emptyList();\n    } else if (size == 1) {\n        return singletonList(getRecordId());\n    } else {\n        List<RecordId> list = newArrayListWithCapacity(size);\n        Segment segment = getSegment();\n        int offset = getOffset();\n        for (int i = 0; i < size; i += bucketSize) {\n            RecordId id = segment.readRecordId(offset);\n            if (bucketSize == 1) {\n                list.add(id);\n            } else {\n                ListRecord bucket = new ListRecord(segment, id, Math.min(bucketSize, size - offset));\n                list.addAll(bucket.getEntries());\n            }\n            offset += Segment.RECORD_ID_BYTES;\n        }\n        return list;\n    }\n}", "code_comment": NaN, "code_no_comment": "public List<RecordId> getEntries() {\n    if (size == 0) {\n        return emptyList();\n    } else if (size == 1) {\n        return singletonList(getRecordId());\n    } else {\n        List<RecordId> list = newArrayListWithCapacity(size);\n        Segment segment = getSegment();\n        int offset = getOffset();\n        for (int i = 0; i < size; i += bucketSize) {\n            RecordId id = segment.readRecordId(offset);\n            if (bucketSize == 1) {\n                list.add(id);\n            } else {\n                ListRecord bucket = new ListRecord(segment, id, Math.min(bucketSize, size - offset));\n                list.addAll(bucket.getEntries());\n            }\n            offset += Segment.RECORD_ID_BYTES;\n        }\n        return list;\n    }\n}", "lc": 0.36363636363636365, "pi": 0.7511961722488036, "ma": 0.2, "nbd": 1.0, "ml": 0.16666666666666666, "d": 0.41468253968253965, "mi": -0.3220577871740661, "fo": 0.4166666666666667, "r": 0.02631578947368421, "e": 0.45848216086628274}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-2494_0dc92ca1", "label": 1, "code": "public double getAverage() {\n    return ((double) sum) / count;\n}", "code_comment": NaN, "code_no_comment": "public double getAverage() {\n    return ((double) sum) / count;\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.1099365750528538, "fo": -0.5, "r": 2.4473684210526314, "e": -0.16279340490885932}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-1283_9e0c5ad4", "label": 3, "code": "/**\n * Returns the value of \u0393(x). Based on the <em>NSWC Library of\n * Mathematics Subroutines</em> double precision implementation,\n * {@code DGAMMA}.\n *\n * @param x Argument.\n * @return the value of {@code Gamma(x)}.\n * @since 3.1\n */\npublic static double gamma(final double x) {\n    if ((x == FastMath.rint(x)) && (x <= 0.0)) {\n        return Double.NaN;\n    }\n    final double ret;\n    final double absX = FastMath.abs(x);\n    if (absX <= 20.0) {\n        if (x >= 1.0) {\n            /*\n                 * From the recurrence relation\n                 * Gamma(x) = (x - 1) * ... * (x - n) * Gamma(x - n),\n                 * then\n                 * Gamma(t) = 1 / [1 + invGamma1pm1(t - 1)],\n                 * where t = x - n. This means that t must satisfy\n                 * -0.5 <= t - 1 <= 1.5.\n                 */\n            double prod = 1.0;\n            double t = x;\n            while (t > 2.5) {\n                t -= 1.0;\n                prod *= t;\n            }\n            ret = prod / (1.0 + invGamma1pm1(t - 1.0));\n        } else {\n            /*\n                 * From the recurrence relation\n                 * Gamma(x) = Gamma(x + n + 1) / [x * (x + 1) * ... * (x + n)]\n                 * then\n                 * Gamma(x + n + 1) = 1 / [1 + invGamma1pm1(x + n)],\n                 * which requires -0.5 <= x + n <= 1.5.\n                 */\n            double prod = x;\n            double t = x;\n            while (t < -0.5) {\n                t += 1.0;\n                prod *= t;\n            }\n            ret = 1.0 / (prod * (1.0 + invGamma1pm1(t)));\n        }\n    } else {\n        final double y = absX + LANCZOS_G + 0.5;\n        final double gammaAbs = SQRT_TWO_PI / x * FastMath.pow(y, absX + 0.5) * FastMath.exp(-y) * lanczos(absX);\n        if (x > 0.0) {\n            ret = gammaAbs;\n        } else {\n            /*\n                 * From the reflection formula\n                 * Gamma(x) * Gamma(1 - x) * sin(pi * x) = pi,\n                 * and the recurrence relation\n                 * Gamma(1 - x) = -x * Gamma(-x),\n                 * it is found\n                 * Gamma(x) = -pi / [x * sin(pi * x) * Gamma(-x)].\n                 */\n            ret = -FastMath.PI / (x * FastMath.sin(FastMath.PI * x) * gammaAbs);\n        }\n    }\n    return ret;\n}", "code_comment": "/**\n * Returns the value of \u0393(x). Based on the <em>NSWC Library of\n * Mathematics Subroutines</em> double precision implementation,\n * {@code DGAMMA}.\n *\n * @param x Argument.\n * @return the value of {@code Gamma(x)}.\n * @since 3.1\n */\n", "code_no_comment": "public static double gamma(final double x) {\n    if ((x == FastMath.rint(x)) && (x <= 0.0)) {\n        return Double.NaN;\n    }\n    final double ret;\n    final double absX = FastMath.abs(x);\n    if (absX <= 20.0) {\n        if (x >= 1.0) {\n                        double prod = 1.0;\n            double t = x;\n            while (t > 2.5) {\n                t -= 1.0;\n                prod *= t;\n            }\n            ret = prod / (1.0 + invGamma1pm1(t - 1.0));\n        } else {\n                        double prod = x;\n            double t = x;\n            while (t < -0.5) {\n                t += 1.0;\n                prod *= t;\n            }\n            ret = 1.0 / (prod * (1.0 + invGamma1pm1(t)));\n        }\n    } else {\n        final double y = absX + LANCZOS_G + 0.5;\n        final double gammaAbs = SQRT_TWO_PI / x * FastMath.pow(y, absX + 0.5) * FastMath.exp(-y) * lanczos(absX);\n        if (x > 0.0) {\n            ret = gammaAbs;\n        } else {\n                        ret = -FastMath.PI / (x * FastMath.sin(FastMath.PI * x) * gammaAbs);\n        }\n    }\n    return ret;\n}", "lc": 0.9545454545454546, "pi": 0.6698564593301434, "ma": 0.6, "nbd": 0.5, "ml": 0.5, "d": 3.9563492063492065, "mi": -0.6451021846370684, "fo": 0.16666666666666666, "r": -0.02631578947368421, "e": 6.561133682566576}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-434_133cbc2d", "label": 1, "code": "/**\n * {@inheritDoc}\n */\n@Override\npublic boolean equals(Object other) {\n    if (this == other) {\n        return true;\n    }\n    if (other instanceof SimplexTableau) {\n        SimplexTableau rhs = (SimplexTableau) other;\n        return (restrictToNonNegative == rhs.restrictToNonNegative) && (numDecisionVariables == rhs.numDecisionVariables) && (numSlackVariables == rhs.numSlackVariables) && (numArtificialVariables == rhs.numArtificialVariables) && (epsilon == rhs.epsilon) && f.equals(rhs.f) && constraints.equals(rhs.constraints) && tableau.equals(rhs.tableau);\n    }\n    return false;\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "@Override\npublic boolean equals(Object other) {\n    if (this == other) {\n        return true;\n    }\n    if (other instanceof SimplexTableau) {\n        SimplexTableau rhs = (SimplexTableau) other;\n        return (restrictToNonNegative == rhs.restrictToNonNegative) && (numDecisionVariables == rhs.numDecisionVariables) && (numSlackVariables == rhs.numSlackVariables) && (numArtificialVariables == rhs.numArtificialVariables) && (epsilon == rhs.epsilon) && f.equals(rhs.f) && constraints.equals(rhs.constraints) && tableau.equals(rhs.tableau);\n    }\n    return false;\n}", "lc": -0.13636363636363635, "pi": -0.01913875598086126, "ma": -0.2, "nbd": -0.5, "ml": -0.16666666666666666, "d": 0.11309523809523811, "mi": 0.07822410147991557, "fo": -0.25, "r": 0.1842105263157895, "e": 0.07267970240256333}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-442_246d53c5", "label": 1, "code": "/**\n *  @return True if this component has an error message\n */\npublic final boolean hasErrorMessage() {\n    return getPage().getFeedbackMessages().hasErrorMessageFor(this);\n}", "code_comment": "/**\n *  @return True if this component has an error message\n */\n", "code_no_comment": "public final boolean hasErrorMessage() {\n    return getPage().getFeedbackMessages().hasErrorMessageFor(this);\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.1099365750528538, "fo": -0.25, "r": 2.5789473684210527, "e": -0.16279340490885932}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4824_ad849602", "label": 1, "code": "/**\n *  Creates a url for the handler. Modifies it with the correct {@link Scheme} if necessary.\n *\n *  @param handler\n *  @param request\n *  @return url\n */\nfinal Url mapHandler(IRequestHandler handler, Request request) {\n    Url url = delegate.mapHandler(handler);\n    Scheme desired = getDesiredSchemeFor(handler);\n    Scheme current = getSchemeOf(request);\n    if (!desired.isCompatibleWith(current)) {\n        // the generated url does not have the correct scheme, set it (which in turn will cause\n        // the url to be rendered in its full representation)\n        url.setProtocol(desired.urlName());\n        if (url.getPort() != null || !desired.usesStandardPort(config)) {\n            url.setPort(desired.getPort(config));\n        }\n    }\n    return url;\n}", "code_comment": "/**\n *  Creates a url for the handler. Modifies it with the correct {@link Scheme} if necessary.\n *\n *  @param handler\n *  @param request\n *  @return url\n */\n", "code_no_comment": "final Url mapHandler(IRequestHandler handler, Request request) {\n    Url url = delegate.mapHandler(handler);\n    Scheme desired = getDesiredSchemeFor(handler);\n    Scheme current = getSchemeOf(request);\n    if (!desired.isCompatibleWith(current)) {\n                        url.setProtocol(desired.urlName());\n        if (url.getPort() != null || !desired.usesStandardPort(config)) {\n            url.setPort(desired.getPort(config));\n        }\n    }\n    return url;\n}", "lc": -0.09090909090909091, "pi": 0.1578947368421051, "ma": -0.2, "nbd": 0.0, "ml": 0.25, "d": 0.33928571428571425, "mi": 0.035377026074700356, "fo": 0.3333333333333333, "r": 0.02631578947368421, "e": 0.19063524720065925}
{"project_name": "Math", "project_version": 83, "label": 1, "code": "/**\n * Get the current solution.\n *\n * @return current solution\n */\nprotected RealPointValuePair getSolution() {\n    double[] coefficients = new double[getOriginalNumDecisionVariables()];\n    Integer negativeVarBasicRow = getBasicRow(getNegativeDecisionVariableOffset());\n    double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());\n    Set<Integer> basicRows = new HashSet<Integer>();\n    for (int i = 0; i < coefficients.length; i++) {\n        Integer basicRow = getBasicRow(getNumObjectiveFunctions() + i);\n        if (basicRows.contains(basicRow)) {\n            // if multiple variables can take a given value\n            // then we choose the first and set the rest equal to 0\n            coefficients[i] = 0;\n        } else {\n            basicRows.add(basicRow);\n            coefficients[i] = (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) - (restrictToNonNegative ? 0 : mostNegative);\n        }\n    }\n    return new RealPointValuePair(coefficients, f.getValue(coefficients));\n}", "code_comment": "/**\n * Get the current solution.\n *\n * @return current solution\n */\n", "code_no_comment": "protected RealPointValuePair getSolution() {\n    double[] coefficients = new double[getOriginalNumDecisionVariables()];\n    Integer negativeVarBasicRow = getBasicRow(getNegativeDecisionVariableOffset());\n    double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());\n    Set<Integer> basicRows = new HashSet<Integer>();\n    for (int i = 0; i < coefficients.length; i++) {\n        Integer basicRow = getBasicRow(getNumObjectiveFunctions() + i);\n        if (basicRows.contains(basicRow)) {\n                                    coefficients[i] = 0;\n        } else {\n            basicRows.add(basicRow);\n            coefficients[i] = (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) - (restrictToNonNegative ? 0 : mostNegative);\n        }\n    }\n    return new RealPointValuePair(coefficients, f.getValue(coefficients));\n}", "lc": 0.09090909090909091, "pi": 0.35885167464114837, "ma": 0.4, "nbd": 0.0, "ml": 0.5, "d": 0.9404761904761905, "mi": -0.18816067653276944, "fo": 0.5, "r": 0.15789473684210528, "e": 0.9136333511984001}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-9444_baece126", "label": 1, "code": "private AggregationStrategy createAggregationStrategy(RouteContext routeContext) {\n    AggregationStrategy strategy = getAggregationStrategy();\n    if (strategy == null && strategyRef != null) {\n        Object aggStrategy = routeContext.lookup(strategyRef, Object.class);\n        if (aggStrategy instanceof AggregationStrategy) {\n            strategy = (AggregationStrategy) aggStrategy;\n        } else if (aggStrategy != null) {\n            AggregationStrategyBeanAdapter adapter = new AggregationStrategyBeanAdapter(aggStrategy, getStrategyMethodName());\n            if (getStrategyMethodAllowNull() != null) {\n                adapter.setAllowNullNewExchange(getStrategyMethodAllowNull());\n                adapter.setAllowNullOldExchange(getStrategyMethodAllowNull());\n            }\n            strategy = adapter;\n        } else {\n            throw new IllegalArgumentException(\"Cannot find AggregationStrategy in Registry with name: \" + strategyRef);\n        }\n    }\n    if (strategy != null && strategy instanceof CamelContextAware) {\n        ((CamelContextAware) strategy).setCamelContext(routeContext.getCamelContext());\n    }\n    return strategy;\n}", "code_comment": NaN, "code_no_comment": "private AggregationStrategy createAggregationStrategy(RouteContext routeContext) {\n    AggregationStrategy strategy = getAggregationStrategy();\n    if (strategy == null && strategyRef != null) {\n        Object aggStrategy = routeContext.lookup(strategyRef, Object.class);\n        if (aggStrategy instanceof AggregationStrategy) {\n            strategy = (AggregationStrategy) aggStrategy;\n        } else if (aggStrategy != null) {\n            AggregationStrategyBeanAdapter adapter = new AggregationStrategyBeanAdapter(aggStrategy, getStrategyMethodName());\n            if (getStrategyMethodAllowNull() != null) {\n                adapter.setAllowNullNewExchange(getStrategyMethodAllowNull());\n                adapter.setAllowNullOldExchange(getStrategyMethodAllowNull());\n            }\n            strategy = adapter;\n        } else {\n            throw new IllegalArgumentException(\"Cannot find AggregationStrategy in Registry with name: \" + strategyRef);\n        }\n    }\n    if (strategy != null && strategy instanceof CamelContextAware) {\n        ((CamelContextAware) strategy).setCamelContext(routeContext.getCamelContext());\n    }\n    return strategy;\n}", "lc": 0.36363636363636365, "pi": 0.7272727272727271, "ma": 0.6, "nbd": 1.0, "ml": 0.5, "d": 0.5496031746031746, "mi": -0.32374911909795623, "fo": 0.3333333333333333, "r": -0.02631578947368421, "e": 0.5113627588273599}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-1058_4ebd967c", "label": 3, "code": "/**\n * {@inheritDoc}\n *\n * Returns {@code 0} when {@code p == 0} and\n * {@code Double.POSITIVE_INFINITY} when {@code p == 1}.\n */\n@Override\npublic double inverseCumulativeProbability(double p) {\n    double ret;\n    if (p < 0.0 || p > 1.0) {\n        throw new OutOfRangeException(p, 0.0, 1.0);\n    } else if (p == 0) {\n        ret = 0.0;\n    } else if (p == 1) {\n        ret = Double.POSITIVE_INFINITY;\n    } else {\n        ret = scale * FastMath.pow(-FastMath.log(1.0 - p), 1.0 / shape);\n    }\n    return ret;\n}", "code_comment": "/**\n * {@inheritDoc}\n *\n * Returns {@code 0} when {@code p == 0} and\n * {@code Double.POSITIVE_INFINITY} when {@code p == 1}.\n */\n", "code_no_comment": "@Override\npublic double inverseCumulativeProbability(double p) {\n    double ret;\n    if (p < 0.0 || p > 1.0) {\n        throw new OutOfRangeException(p, 0.0, 1.0);\n    } else if (p == 0) {\n        ret = 0.0;\n    } else if (p == 1) {\n        ret = Double.POSITIVE_INFINITY;\n    } else {\n        ret = scale * FastMath.pow(-FastMath.log(1.0 - p), 1.0 / shape);\n    }\n    return ret;\n}", "lc": 0.0, "pi": -0.08612440191387569, "ma": 0.2, "nbd": 0.5, "ml": 0.0, "d": 1.1746031746031746, "mi": -0.04298801973220593, "fo": -0.3333333333333333, "r": 0.2894736842105263, "e": 0.5852895581565555}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3156_786b3d76", "label": 0, "code": "@Override\npublic IndexRow next() {\n    final IndexRow pathRow = pathCursor.next();\n    return new IndexRow() {\n\n        @Override\n        public boolean isVirtualRow() {\n            return getPath() == null;\n        }\n\n        @Override\n        public String getPath() {\n            return pathRow.getPath();\n        }\n\n        @Override\n        public PropertyValue getValue(String columnName) {\n            // overlay the score\n            if (QueryImpl.JCR_SCORE.equals(columnName)) {\n                return PropertyValues.newDouble(currentRow.score);\n            }\n            if (QueryImpl.REP_SPELLCHECK.equals(columnName) || QueryImpl.REP_SUGGEST.equals(columnName)) {\n                return PropertyValues.newString(Iterables.toString(currentRow.suggestWords));\n            }\n            return pathRow.getValue(columnName);\n        }\n    };\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic IndexRow next() {\n    final IndexRow pathRow = pathCursor.next();\n    return new IndexRow() {\n\n        @Override\n        public boolean isVirtualRow() {\n            return getPath() == null;\n        }\n\n        @Override\n        public String getPath() {\n            return pathRow.getPath();\n        }\n\n        @Override\n        public PropertyValue getValue(String columnName) {\n                        if (QueryImpl.JCR_SCORE.equals(columnName)) {\n                return PropertyValues.newDouble(currentRow.score);\n            }\n            if (QueryImpl.REP_SPELLCHECK.equals(columnName) || QueryImpl.REP_SUGGEST.equals(columnName)) {\n                return PropertyValues.newString(Iterables.toString(currentRow.suggestWords));\n            }\n            return pathRow.getValue(columnName);\n        }\n    };\n}", "lc": 0.45454545454545453, "pi": 0.7033492822966506, "ma": -0.2, "nbd": 0.0, "ml": 0.16666666666666666, "d": 0.0019841269841269858, "mi": -0.30119802677942215, "fo": 0.3333333333333333, "r": 0.07894736842105263, "e": 0.04808353935789489}
{"project_name": "JxPath", "project_version": 16, "label": 3, "code": "public static boolean testNode(NodePointer pointer, Object node, NodeTest test) {\n    if (test == null) {\n        return true;\n    }\n    if (test instanceof NodeNameTest) {\n        if (!(node instanceof Element)) {\n            return false;\n        }\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\n        QName testName = nodeNameTest.getNodeName();\n        String namespaceURI = nodeNameTest.getNamespaceURI();\n        boolean wildcard = nodeNameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard || testName.getName().equals(JDOMNodePointer.getLocalName(node))) {\n            String nodeNS = JDOMNodePointer.getNamespaceURI(node);\n            return equalStrings(namespaceURI, nodeNS) || nodeNS == null && equalStrings(testPrefix, getPrefix(node));\n        }\n        return false;\n    }\n    if (test instanceof NodeTypeTest) {\n        switch(((NodeTypeTest) test).getNodeType()) {\n            case Compiler.NODE_TYPE_NODE:\n                return (node instanceof Element) || (node instanceof Document);\n            case Compiler.NODE_TYPE_TEXT:\n                return (node instanceof Text) || (node instanceof CDATA);\n            case Compiler.NODE_TYPE_COMMENT:\n                return node instanceof Comment;\n            case Compiler.NODE_TYPE_PI:\n                return node instanceof ProcessingInstruction;\n        }\n        return false;\n    }\n    if (test instanceof ProcessingInstructionTest && node instanceof ProcessingInstruction) {\n        String testPI = ((ProcessingInstructionTest) test).getTarget();\n        String nodePI = ((ProcessingInstruction) node).getTarget();\n        return testPI.equals(nodePI);\n    }\n    return false;\n}", "code_comment": NaN, "code_no_comment": "public static boolean testNode(NodePointer pointer, Object node, NodeTest test) {\n    if (test == null) {\n        return true;\n    }\n    if (test instanceof NodeNameTest) {\n        if (!(node instanceof Element)) {\n            return false;\n        }\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\n        QName testName = nodeNameTest.getNodeName();\n        String namespaceURI = nodeNameTest.getNamespaceURI();\n        boolean wildcard = nodeNameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard || testName.getName().equals(JDOMNodePointer.getLocalName(node))) {\n            String nodeNS = JDOMNodePointer.getNamespaceURI(node);\n            return equalStrings(namespaceURI, nodeNS) || nodeNS == null && equalStrings(testPrefix, getPrefix(node));\n        }\n        return false;\n    }\n    if (test instanceof NodeTypeTest) {\n        switch(((NodeTypeTest) test).getNodeType()) {\n            case Compiler.NODE_TYPE_NODE:\n                return (node instanceof Element) || (node instanceof Document);\n            case Compiler.NODE_TYPE_TEXT:\n                return (node instanceof Text) || (node instanceof CDATA);\n            case Compiler.NODE_TYPE_COMMENT:\n                return node instanceof Comment;\n            case Compiler.NODE_TYPE_PI:\n                return node instanceof ProcessingInstruction;\n        }\n        return false;\n    }\n    if (test instanceof ProcessingInstructionTest && node instanceof ProcessingInstruction) {\n        String testPI = ((ProcessingInstructionTest) test).getTarget();\n        String nodePI = ((ProcessingInstruction) node).getTarget();\n        return testPI.equals(nodePI);\n    }\n    return false;\n}", "lc": 1.2727272727272727, "pi": 0.4545454545454545, "ma": 1.6, "nbd": 0.5, "ml": 1.3333333333333333, "d": 0.5416666666666667, "mi": -0.7680056377730796, "fo": 0.75, "r": -0.02631578947368421, "e": 1.3176282106694788}
{"project_name": "Closure", "project_version": 38, "label": 2, "code": "void addNumber(double x) {\n    // This is not pretty printing. This is to prevent misparsing of x- -4 as\n    // x--4 (which is a syntax error).\n    char prev = getLastChar();\n    boolean negativeZero = isNegativeZero(x);\n    if (x < 0 && prev == '-') {\n        add(\" \");\n    }\n    if ((long) x == x && !negativeZero) {\n        long value = (long) x;\n        long mantissa = value;\n        int exp = 0;\n        if (Math.abs(x) >= 100) {\n            while (mantissa / 10 * Math.pow(10, exp + 1) == value) {\n                mantissa /= 10;\n                exp++;\n            }\n        }\n        if (exp > 2) {\n            add(Long.toString(mantissa) + \"E\" + Integer.toString(exp));\n        } else {\n            add(Long.toString(value));\n        }\n    } else {\n        add(String.valueOf(x));\n    }\n}", "code_comment": NaN, "code_no_comment": "void addNumber(double x) {\n            char prev = getLastChar();\n    boolean negativeZero = isNegativeZero(x);\n    if (x < 0 && prev == '-') {\n        add(\" \");\n    }\n    if ((long) x == x && !negativeZero) {\n        long value = (long) x;\n        long mantissa = value;\n        int exp = 0;\n        if (Math.abs(x) >= 100) {\n            while (mantissa / 10 * Math.pow(10, exp + 1) == value) {\n                mantissa /= 10;\n                exp++;\n            }\n        }\n        if (exp > 2) {\n            add(Long.toString(mantissa) + \"E\" + Integer.toString(exp));\n        } else {\n            add(Long.toString(value));\n        }\n    } else {\n        add(String.valueOf(x));\n    }\n}", "lc": 0.5, "pi": 0.5454545454545453, "ma": 0.4, "nbd": 0.5, "ml": 0.8333333333333334, "d": 2.1031746031746033, "mi": -0.4100070472163495, "fo": 0.5, "r": 0.42105263157894735, "e": 2.1418324948277747}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5085_581c7306", "label": 1, "code": "/**\n *  {@link InlineEnclosure}s keep their own cache of their markup because Component#markup is\n *  detached and later during Ajax request it is hard to re-lookup {@link InlineEnclosure}'s\n *  markup from its parent.\n *\n *  @see org.apache.wicket.Component#getMarkup()\n */\n@Override\npublic IMarkupFragment getMarkup() {\n    IMarkupFragment enclosureMarkup = null;\n    if (enclosureMarkupAsString == null) {\n        IMarkupFragment markup = super.getMarkup();\n        if (markup != null && markup != Markup.NO_MARKUP) {\n            enclosureMarkup = markup;\n            enclosureMarkupAsString = markup.toString(true);\n        }\n    } else {\n        enclosureMarkup = Markup.of(enclosureMarkupAsString, getWicketNamespace());\n    }\n    return enclosureMarkup;\n}", "code_comment": "/**\n *  {@link InlineEnclosure}s keep their own cache of their markup because Component#markup is\n *  detached and later during Ajax request it is hard to re-lookup {@link InlineEnclosure}'s\n *  markup from its parent.\n *\n *  @see org.apache.wicket.Component#getMarkup()\n */\n", "code_no_comment": "@Override\npublic IMarkupFragment getMarkup() {\n    IMarkupFragment enclosureMarkup = null;\n    if (enclosureMarkupAsString == null) {\n        IMarkupFragment markup = super.getMarkup();\n        if (markup != null && markup != Markup.NO_MARKUP) {\n            enclosureMarkup = markup;\n            enclosureMarkupAsString = markup.toString(true);\n        }\n    } else {\n        enclosureMarkup = Markup.of(enclosureMarkupAsString, getWicketNamespace());\n    }\n    return enclosureMarkup;\n}", "lc": 0.0, "pi": 0.43062200956937796, "ma": -0.2, "nbd": 0.0, "ml": 0.0, "d": 0.45634920634920634, "mi": 0.010570824524312895, "fo": -0.16666666666666666, "r": 0.6578947368421053, "e": 0.13986157454631373}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-128_7e1000dd", "label": 1, "code": "/**\n *  Adds or replaces the attribute with the given name and value.\n *\n *  @param name\n *             The name of the attribute\n *  @param value\n *             The value of the attribute\n */\nprotected final void setAttribute(String name, Object value) {\n    RequestCycle cycle = RequestCycle.get();\n    if (cycle == null) {\n        throw new WicketRuntimeException(\"Can not set the attribute. No RequestCycle available\");\n    }\n    ISessionStore store = getSessionStore();\n    Request request = cycle.getRequest();\n    // extra check on session binding event\n    if (value == this) {\n        Object current = store.getAttribute(request, name);\n        if (current == null) {\n            String id = store.getSessionId(request, false);\n            if (id != null) {\n                // this is a new instance. wherever it came from, bind the\n                // session now\n                store.bind(request, (Session) value);\n            }\n        }\n    }\n    String valueTypeName = (value != null ? value.getClass().getName() : \"null\");\n    try {\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        new ObjectOutputStream(out).writeObject(value);\n        log.debug(\"Stored attribute \" + name + \"{ \" + valueTypeName + \"} with size: \" + Bytes.bytes(out.size()));\n    } catch (Exception e) {\n        throw new WicketRuntimeException(\"Internal error cloning object. Make sure all dependent objects implement Serializable. Class: \" + valueTypeName, e);\n    }\n    // Set the actual attribute\n    store.setAttribute(request, name, value);\n}", "code_comment": "/**\n *  Adds or replaces the attribute with the given name and value.\n *\n *  @param name\n *             The name of the attribute\n *  @param value\n *             The value of the attribute\n */\n", "code_no_comment": "protected final void setAttribute(String name, Object value) {\n    RequestCycle cycle = RequestCycle.get();\n    if (cycle == null) {\n        throw new WicketRuntimeException(\"Can not set the attribute. No RequestCycle available\");\n    }\n    ISessionStore store = getSessionStore();\n    Request request = cycle.getRequest();\n        if (value == this) {\n        Object current = store.getAttribute(request, name);\n        if (current == null) {\n            String id = store.getSessionId(request, false);\n            if (id != null) {\n                                                store.bind(request, (Session) value);\n            }\n        }\n    }\n    String valueTypeName = (value != null ? value.getClass().getName() : \"null\");\n    try {\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        new ObjectOutputStream(out).writeObject(value);\n        log.debug(\"Stored attribute \" + name + \"{ \" + valueTypeName + \"} with size: \" + Bytes.bytes(out.size()));\n    } catch (Exception e) {\n        throw new WicketRuntimeException(\"Internal error cloning object. Make sure all dependent objects implement Serializable. Class: \" + valueTypeName, e);\n    }\n        store.setAttribute(request, name, value);\n}", "lc": 0.5454545454545454, "pi": 0.3444976076555023, "ma": 1.0, "nbd": 0.5, "ml": 0.3333333333333333, "d": 0.373015873015873, "mi": -0.48583509513742057, "fo": 0.5833333333333334, "r": -0.02631578947368421, "e": 0.7329080294831232}
{"project_name": "Closure", "project_version": 47, "label": 2, "code": "/**\n * Creates an \"OriginalMapping\" object for the given entry object.\n */\nprivate OriginalMapping getOriginalMappingForEntry(Entry entry) {\n    if (entry.getSourceFileId() == UNMAPPED) {\n        return null;\n    } else {\n        // Adjust the line/column here to be start at 1.\n        Builder x = OriginalMapping.newBuilder().setOriginalFile(sources[entry.getSourceFileId()]).setLineNumber(entry.getSourceLine()).setColumnPosition(entry.getSourceColumn());\n        if (entry.getNameId() != UNMAPPED) {\n            x.setIdentifier(names[entry.getNameId()]);\n        }\n        return x.build();\n    }\n}", "code_comment": "/**\n * Creates an \"OriginalMapping\" object for the given entry object.\n */\n", "code_no_comment": "private OriginalMapping getOriginalMappingForEntry(Entry entry) {\n    if (entry.getSourceFileId() == UNMAPPED) {\n        return null;\n    } else {\n                Builder x = OriginalMapping.newBuilder().setOriginalFile(sources[entry.getSourceFileId()]).setLineNumber(entry.getSourceLine()).setColumnPosition(entry.getSourceColumn());\n        if (entry.getNameId() != UNMAPPED) {\n            x.setIdentifier(names[entry.getNameId()]);\n        }\n        return x.build();\n    }\n}", "lc": -0.13636363636363635, "pi": 0.27272727272727265, "ma": -0.2, "nbd": 0.0, "ml": -0.08333333333333333, "d": -0.053571428571428575, "mi": 0.11458773784355171, "fo": 0.5, "r": 0.02631578947368421, "e": -0.04321041014735799}
{"project_name": "Math", "project_version": 6, "label": 1, "code": "/**\n * {@inheritDoc}\n */\n@Override\nprotected PointValuePair doOptimize() {\n    // -------------------- Initialization --------------------------------\n    isMinimize = getGoalType().equals(GoalType.MINIMIZE);\n    final FitnessFunction fitfun = new FitnessFunction();\n    final double[] guess = getStartPoint();\n    // number of objective variables/problem dimension\n    dimension = guess.length;\n    initializeCMA(guess);\n    iterations = 0;\n    double bestValue = fitfun.value(guess);\n    push(fitnessHistory, bestValue);\n    PointValuePair optimum = new PointValuePair(getStartPoint(), isMinimize ? bestValue : -bestValue);\n    PointValuePair lastResult = null;\n    generationLoop: for (iterations = 1; iterations <= maxIterations; iterations++) {\n        // Generate and evaluate lambda offspring\n        final RealMatrix arz = randn1(dimension, lambda);\n        final RealMatrix arx = zeros(dimension, lambda);\n        final double[] fitness = new double[lambda];\n        // generate random offspring\n        for (int k = 0; k < lambda; k++) {\n            RealMatrix arxk = null;\n            for (int i = 0; i < checkFeasableCount + 1; i++) {\n                if (diagonalOnly <= 0) {\n                    arxk = xmean.add(BD.multiply(arz.getColumnMatrix(k)).scalarMultiply(// m + sig * Normal(0,C)\n                    sigma));\n                } else {\n                    arxk = xmean.add(times(diagD, arz.getColumnMatrix(k)).scalarMultiply(sigma));\n                }\n                if (i >= checkFeasableCount || fitfun.isFeasible(arxk.getColumn(0))) {\n                    break;\n                }\n                // regenerate random arguments for row\n                arz.setColumn(k, randn(dimension));\n            }\n            copyColumn(arxk, 0, arx, k);\n            try {\n                // compute fitness\n                fitness[k] = fitfun.value(arx.getColumn(k));\n            } catch (TooManyEvaluationsException e) {\n                break generationLoop;\n            }\n        }\n        // Sort by fitness and compute weighted mean into xmean\n        final int[] arindex = sortedIndices(fitness);\n        // Calculate new xmean, this is selection and recombination\n        // for speed up of Eq. (2) and (3)\n        final RealMatrix xold = xmean;\n        final RealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu));\n        xmean = bestArx.multiply(weights);\n        final RealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu));\n        final RealMatrix zmean = bestArz.multiply(weights);\n        final boolean hsig = updateEvolutionPaths(zmean, xold);\n        if (diagonalOnly <= 0) {\n            updateCovariance(hsig, bestArx, arz, arindex, xold);\n        } else {\n            updateCovarianceDiagonalOnly(hsig, bestArz);\n        }\n        // Adapt step size sigma - Eq. (5)\n        sigma *= Math.exp(Math.min(1, (normps / chiN - 1) * cs / damps));\n        final double bestFitness = fitness[arindex[0]];\n        final double worstFitness = fitness[arindex[arindex.length - 1]];\n        if (bestValue > bestFitness) {\n            bestValue = bestFitness;\n            lastResult = optimum;\n            optimum = new PointValuePair(fitfun.repair(bestArx.getColumn(0)), isMinimize ? bestFitness : -bestFitness);\n            if (getConvergenceChecker() != null && lastResult != null) {\n                if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {\n                    break generationLoop;\n                }\n            }\n        }\n        // Break, if fitness is good enough\n        if (stopFitness != 0) {\n            // only if stopFitness is defined\n            if (bestFitness < (isMinimize ? stopFitness : -stopFitness)) {\n                break generationLoop;\n            }\n        }\n        final double[] sqrtDiagC = sqrt(diagC).getColumn(0);\n        final double[] pcCol = pc.getColumn(0);\n        for (int i = 0; i < dimension; i++) {\n            if (sigma * Math.max(Math.abs(pcCol[i]), sqrtDiagC[i]) > stopTolX) {\n                break;\n            }\n            if (i >= dimension - 1) {\n                break generationLoop;\n            }\n        }\n        for (int i = 0; i < dimension; i++) {\n            if (sigma * sqrtDiagC[i] > stopTolUpX) {\n                break generationLoop;\n            }\n        }\n        final double historyBest = min(fitnessHistory);\n        final double historyWorst = max(fitnessHistory);\n        if (iterations > 2 && Math.max(historyWorst, worstFitness) - Math.min(historyBest, bestFitness) < stopTolFun) {\n            break generationLoop;\n        }\n        if (iterations > fitnessHistory.length && historyWorst - historyBest < stopTolHistFun) {\n            break generationLoop;\n        }\n        // condition number of the covariance matrix exceeds 1e14\n        if (max(diagD) / min(diagD) > 1e7) {\n            break generationLoop;\n        }\n        // user defined termination\n        if (getConvergenceChecker() != null) {\n            final PointValuePair current = new PointValuePair(bestArx.getColumn(0), isMinimize ? bestFitness : -bestFitness);\n            if (lastResult != null && getConvergenceChecker().converged(iterations, current, lastResult)) {\n                break generationLoop;\n            }\n            lastResult = current;\n        }\n        // Adjust step size in case of equal function values (flat fitness)\n        if (bestValue == fitness[arindex[(int) (0.1 + lambda / 4.)]]) {\n            sigma = sigma * Math.exp(0.2 + cs / damps);\n        }\n        if (iterations > 2 && Math.max(historyWorst, bestFitness) - Math.min(historyBest, bestFitness) == 0) {\n            sigma = sigma * Math.exp(0.2 + cs / damps);\n        }\n        // store best in history\n        push(fitnessHistory, bestFitness);\n        fitfun.setValueRange(worstFitness - bestFitness);\n        if (generateStatistics) {\n            statisticsSigmaHistory.add(sigma);\n            statisticsFitnessHistory.add(bestFitness);\n            statisticsMeanHistory.add(xmean.transpose());\n            statisticsDHistory.add(diagD.transpose().scalarMultiply(1E5));\n        }\n    }\n    return optimum;\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "@Override\nprotected PointValuePair doOptimize() {\n        isMinimize = getGoalType().equals(GoalType.MINIMIZE);\n    final FitnessFunction fitfun = new FitnessFunction();\n    final double[] guess = getStartPoint();\n        dimension = guess.length;\n    initializeCMA(guess);\n    iterations = 0;\n    double bestValue = fitfun.value(guess);\n    push(fitnessHistory, bestValue);\n    PointValuePair optimum = new PointValuePair(getStartPoint(), isMinimize ? bestValue : -bestValue);\n    PointValuePair lastResult = null;\n    generationLoop: for (iterations = 1; iterations <= maxIterations; iterations++) {\n                final RealMatrix arz = randn1(dimension, lambda);\n        final RealMatrix arx = zeros(dimension, lambda);\n        final double[] fitness = new double[lambda];\n                for (int k = 0; k < lambda; k++) {\n            RealMatrix arxk = null;\n            for (int i = 0; i < checkFeasableCount + 1; i++) {\n                if (diagonalOnly <= 0) {\n                    arxk = xmean.add(BD.multiply(arz.getColumnMatrix(k)).scalarMultiply(                    sigma));\n                } else {\n                    arxk = xmean.add(times(diagD, arz.getColumnMatrix(k)).scalarMultiply(sigma));\n                }\n                if (i >= checkFeasableCount || fitfun.isFeasible(arxk.getColumn(0))) {\n                    break;\n                }\n                                arz.setColumn(k, randn(dimension));\n            }\n            copyColumn(arxk, 0, arx, k);\n            try {\n                                fitness[k] = fitfun.value(arx.getColumn(k));\n            } catch (TooManyEvaluationsException e) {\n                break generationLoop;\n            }\n        }\n                final int[] arindex = sortedIndices(fitness);\n                        final RealMatrix xold = xmean;\n        final RealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu));\n        xmean = bestArx.multiply(weights);\n        final RealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu));\n        final RealMatrix zmean = bestArz.multiply(weights);\n        final boolean hsig = updateEvolutionPaths(zmean, xold);\n        if (diagonalOnly <= 0) {\n            updateCovariance(hsig, bestArx, arz, arindex, xold);\n        } else {\n            updateCovarianceDiagonalOnly(hsig, bestArz);\n        }\n                sigma *= Math.exp(Math.min(1, (normps / chiN - 1) * cs / damps));\n        final double bestFitness = fitness[arindex[0]];\n        final double worstFitness = fitness[arindex[arindex.length - 1]];\n        if (bestValue > bestFitness) {\n            bestValue = bestFitness;\n            lastResult = optimum;\n            optimum = new PointValuePair(fitfun.repair(bestArx.getColumn(0)), isMinimize ? bestFitness : -bestFitness);\n            if (getConvergenceChecker() != null && lastResult != null) {\n                if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {\n                    break generationLoop;\n                }\n            }\n        }\n                if (stopFitness != 0) {\n                        if (bestFitness < (isMinimize ? stopFitness : -stopFitness)) {\n                break generationLoop;\n            }\n        }\n        final double[] sqrtDiagC = sqrt(diagC).getColumn(0);\n        final double[] pcCol = pc.getColumn(0);\n        for (int i = 0; i < dimension; i++) {\n            if (sigma * Math.max(Math.abs(pcCol[i]), sqrtDiagC[i]) > stopTolX) {\n                break;\n            }\n            if (i >= dimension - 1) {\n                break generationLoop;\n            }\n        }\n        for (int i = 0; i < dimension; i++) {\n            if (sigma * sqrtDiagC[i] > stopTolUpX) {\n                break generationLoop;\n            }\n        }\n        final double historyBest = min(fitnessHistory);\n        final double historyWorst = max(fitnessHistory);\n        if (iterations > 2 && Math.max(historyWorst, worstFitness) - Math.min(historyBest, bestFitness) < stopTolFun) {\n            break generationLoop;\n        }\n        if (iterations > fitnessHistory.length && historyWorst - historyBest < stopTolHistFun) {\n            break generationLoop;\n        }\n                if (max(diagD) / min(diagD) > 1e7) {\n            break generationLoop;\n        }\n                if (getConvergenceChecker() != null) {\n            final PointValuePair current = new PointValuePair(bestArx.getColumn(0), isMinimize ? bestFitness : -bestFitness);\n            if (lastResult != null && getConvergenceChecker().converged(iterations, current, lastResult)) {\n                break generationLoop;\n            }\n            lastResult = current;\n        }\n                if (bestValue == fitness[arindex[(int) (0.1 + lambda / 4.)]]) {\n            sigma = sigma * Math.exp(0.2 + cs / damps);\n        }\n        if (iterations > 2 && Math.max(historyWorst, bestFitness) - Math.min(historyBest, bestFitness) == 0) {\n            sigma = sigma * Math.exp(0.2 + cs / damps);\n        }\n                push(fitnessHistory, bestFitness);\n        fitfun.setValueRange(worstFitness - bestFitness);\n        if (generateStatistics) {\n            statisticsSigmaHistory.add(sigma);\n            statisticsFitnessHistory.add(bestFitness);\n            statisticsMeanHistory.add(xmean.transpose());\n            statisticsDHistory.add(diagD.transpose().scalarMultiply(1E5));\n        }\n    }\n    return optimum;\n}", "lc": 4.681818181818182, "pi": 0.6124401913875596, "ma": 7.4, "nbd": 1.0, "ml": 5.583333333333333, "d": 4.2023809523809526, "mi": -1.649189570119802, "fo": 5.25, "r": -0.02631578947368421, "e": 34.56361404540032}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3021_494da6de", "label": 1, "code": "@Override\npublic Validator childNodeChanged(String name, NodeState before, NodeState after) throws CommitFailedException {\n    return new UserValidator(parentBefore.getChild(name), parentAfter.getChild(name), provider);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic Validator childNodeChanged(String name, NodeState before, NodeState after) throws CommitFailedException {\n    return new UserValidator(parentBefore.getChild(name), parentAfter.getChild(name), provider);\n}", "lc": -0.45454545454545453, "pi": -0.6028708133971293, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.7065539112050737, "fo": -0.3333333333333333, "r": -0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-4036_f4324736", "label": 1, "code": "private void initializeExtractedTextCache(BundleContext bundleContext, Map<String, ?> config) {\n    int cacheSizeInMB = PropertiesUtil.toInteger(config.get(PROP_EXTRACTED_TEXT_CACHE_SIZE), PROP_EXTRACTED_TEXT_CACHE_SIZE_DEFAULT);\n    int cacheExpiryInSecs = PropertiesUtil.toInteger(config.get(PROP_EXTRACTED_TEXT_CACHE_EXPIRY), PROP_EXTRACTED_TEXT_CACHE_EXPIRY_DEFAULT);\n    extractedTextCache = new ExtractedTextCache(cacheSizeInMB * ONE_MB, cacheExpiryInSecs);\n    CacheStats stats = extractedTextCache.getCacheStats();\n    if (stats != null) {\n        oakRegs.add(registerMBean(whiteboard, CacheStatsMBean.class, stats, CacheStatsMBean.TYPE, stats.getName()));\n        log.info(\"Extracted text caching enabled with maxSize {} MB, expiry time {} secs\", cacheSizeInMB, cacheExpiryInSecs);\n    }\n}", "code_comment": NaN, "code_no_comment": "private void initializeExtractedTextCache(BundleContext bundleContext, Map<String, ?> config) {\n    int cacheSizeInMB = PropertiesUtil.toInteger(config.get(PROP_EXTRACTED_TEXT_CACHE_SIZE), PROP_EXTRACTED_TEXT_CACHE_SIZE_DEFAULT);\n    int cacheExpiryInSecs = PropertiesUtil.toInteger(config.get(PROP_EXTRACTED_TEXT_CACHE_EXPIRY), PROP_EXTRACTED_TEXT_CACHE_EXPIRY_DEFAULT);\n    extractedTextCache = new ExtractedTextCache(cacheSizeInMB * ONE_MB, cacheExpiryInSecs);\n    CacheStats stats = extractedTextCache.getCacheStats();\n    if (stats != null) {\n        oakRegs.add(registerMBean(whiteboard, CacheStatsMBean.class, stats, CacheStatsMBean.TYPE, stats.getName()));\n        log.info(\"Extracted text caching enabled with maxSize {} MB, expiry time {} secs\", cacheSizeInMB, cacheExpiryInSecs);\n    }\n}", "lc": -0.18181818181818182, "pi": -0.2200956937799045, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": -0.08333333333333336, "mi": 0.09034531360112749, "fo": 0.25, "r": -0.02631578947368421, "e": 0.017125107334474383}
{"project_name": "Closure", "project_version": 72, "label": 2, "code": "/**\n * Rename or remove labels.\n * @param node  The label node.\n * @param parent The parent of the label node.\n */\nprivate void visitLabel(Node node, Node parent) {\n    Node nameNode = node.getFirstChild();\n    Preconditions.checkState(nameNode != null);\n    String name = nameNode.getString();\n    LabelInfo li = getLabelInfo(name);\n    // This is a label...\n    if (li.referenced) {\n        String newName = getNameForId(li.id);\n        if (!name.equals(newName)) {\n            // ... and it is used, give it the short name.\n            nameNode.setString(newName);\n            compiler.reportCodeChange();\n        }\n    } else {\n        // ... and it is not referenced, just remove it.\n        Node newChild = node.getLastChild();\n        node.removeChild(newChild);\n        parent.replaceChild(node, newChild);\n        if (newChild.getType() == Token.BLOCK) {\n            NodeUtil.tryMergeBlock(newChild);\n        }\n        compiler.reportCodeChange();\n    }\n    // Remove the label from the current stack of labels.\n    namespaceStack.peek().renameMap.remove(name);\n}", "code_comment": "/**\n * Rename or remove labels.\n * @param node  The label node.\n * @param parent The parent of the label node.\n */\n", "code_no_comment": "private void visitLabel(Node node, Node parent) {\n    Node nameNode = node.getFirstChild();\n    Preconditions.checkState(nameNode != null);\n    String name = nameNode.getString();\n    LabelInfo li = getLabelInfo(name);\n        if (li.referenced) {\n        String newName = getNameForId(li.id);\n        if (!name.equals(newName)) {\n                        nameNode.setString(newName);\n            compiler.reportCodeChange();\n        }\n    } else {\n                Node newChild = node.getLastChild();\n        node.removeChild(newChild);\n        parent.replaceChild(node, newChild);\n        if (newChild.getType() == Token.BLOCK) {\n            NodeUtil.tryMergeBlock(newChild);\n        }\n        compiler.reportCodeChange();\n    }\n        namespaceStack.peek().renameMap.remove(name);\n}", "lc": 0.36363636363636365, "pi": 0.16746411483253573, "ma": 0.0, "nbd": 0.0, "ml": 0.16666666666666666, "d": 0.2996031746031746, "mi": -0.3288231148696262, "fo": 0.8333333333333334, "r": -0.02631578947368421, "e": 0.4166571578407472}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1732_941e3cb1", "label": 3, "code": "/**\n * Initialize a scanner over the given input split using this task attempt configuration.\n */\n@Override\npublic void initialize(InputSplit inSplit, TaskAttemptContext attempt) throws IOException {\n    Scanner scanner;\n    split = (RangeInputSplit) inSplit;\n    log.debug(\"Initializing input split: \" + split.getRange());\n    Instance instance = getInstance(attempt);\n    String principal = getPrincipal(attempt);\n    AuthenticationToken token = getAuthenticationToken(attempt);\n    Authorizations authorizations = getScanAuthorizations(attempt);\n    // in case the table name changed, we can still use the previous name for terms of configuration,\n    // but the scanner will use the table id resolved at job setup time\n    BatchScanConfig tableConfig = getBatchScanConfig(attempt, split.getTableName());\n    try {\n        log.debug(\"Creating connector with user: \" + principal);\n        log.debug(\"Creating scanner for table: \" + split.getTableName());\n        log.debug(\"Authorizations are: \" + authorizations);\n        if (tableConfig.isOfflineScan()) {\n            scanner = new OfflineScanner(instance, new Credentials(principal, token), split.getTableId(), authorizations);\n        } else {\n            scanner = new ScannerImpl(instance, new Credentials(principal, token), split.getTableId(), authorizations);\n        }\n        if (tableConfig.shouldUseIsolatedScanners()) {\n            log.info(\"Creating isolated scanner\");\n            scanner = new IsolatedScanner(scanner);\n        }\n        if (tableConfig.shouldUseLocalIterators()) {\n            log.info(\"Using local iterators\");\n            scanner = new ClientSideIteratorScanner(scanner);\n        }\n        setupIterators(attempt, scanner, split.getTableId());\n    } catch (Exception e) {\n        throw new IOException(e);\n    }\n    // setup a scanner within the bounds of this split\n    for (Pair<Text, Text> c : tableConfig.getFetchedColumns()) {\n        if (c.getSecond() != null) {\n            log.debug(\"Fetching column \" + c.getFirst() + \":\" + c.getSecond());\n            scanner.fetchColumn(c.getFirst(), c.getSecond());\n        } else {\n            log.debug(\"Fetching column family \" + c.getFirst());\n            scanner.fetchColumnFamily(c.getFirst());\n        }\n    }\n    scanner.setRange(split.getRange());\n    numKeysRead = 0;\n    // do this last after setting all scanner options\n    scannerIterator = scanner.iterator();\n}", "code_comment": "/**\n * Initialize a scanner over the given input split using this task attempt configuration.\n */\n", "code_no_comment": "@Override\npublic void initialize(InputSplit inSplit, TaskAttemptContext attempt) throws IOException {\n    Scanner scanner;\n    split = (RangeInputSplit) inSplit;\n    log.debug(\"Initializing input split: \" + split.getRange());\n    Instance instance = getInstance(attempt);\n    String principal = getPrincipal(attempt);\n    AuthenticationToken token = getAuthenticationToken(attempt);\n    Authorizations authorizations = getScanAuthorizations(attempt);\n            BatchScanConfig tableConfig = getBatchScanConfig(attempt, split.getTableName());\n    try {\n        log.debug(\"Creating connector with user: \" + principal);\n        log.debug(\"Creating scanner for table: \" + split.getTableName());\n        log.debug(\"Authorizations are: \" + authorizations);\n        if (tableConfig.isOfflineScan()) {\n            scanner = new OfflineScanner(instance, new Credentials(principal, token), split.getTableId(), authorizations);\n        } else {\n            scanner = new ScannerImpl(instance, new Credentials(principal, token), split.getTableId(), authorizations);\n        }\n        if (tableConfig.shouldUseIsolatedScanners()) {\n            log.info(\"Creating isolated scanner\");\n            scanner = new IsolatedScanner(scanner);\n        }\n        if (tableConfig.shouldUseLocalIterators()) {\n            log.info(\"Using local iterators\");\n            scanner = new ClientSideIteratorScanner(scanner);\n        }\n        setupIterators(attempt, scanner, split.getTableId());\n    } catch (Exception e) {\n        throw new IOException(e);\n    }\n        for (Pair<Text, Text> c : tableConfig.getFetchedColumns()) {\n        if (c.getSecond() != null) {\n            log.debug(\"Fetching column \" + c.getFirst() + \":\" + c.getSecond());\n            scanner.fetchColumn(c.getFirst(), c.getSecond());\n        } else {\n            log.debug(\"Fetching column family \" + c.getFirst());\n            scanner.fetchColumnFamily(c.getFirst());\n        }\n    }\n    scanner.setRange(split.getRange());\n    numKeysRead = 0;\n        scannerIterator = scanner.iterator();\n}", "lc": 1.3636363636363635, "pi": 0.26794258373205726, "ma": 0.8, "nbd": 0.0, "ml": 0.25, "d": 0.045634920634920584, "mi": -0.8102889358703311, "fo": 2.5, "r": -0.02631578947368421, "e": 0.7634791929600109}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-1096_faf99727", "label": 0, "code": "/**\n * Find a ball enclosing a list of points.\n * @param points points to enclose\n * @return enclosing ball\n */\nEnclosingBall<S, P> enclose(List<P> points);", "code_comment": "/**\n * Find a ball enclosing a list of points.\n * @param points points to enclose\n * @return enclosing ball\n */\n", "code_no_comment": "EnclosingBall<S, P> enclose(List<P> points);", "lc": -0.5909090909090909, "pi": -1.4306220095693782, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.515010570824524, "fo": -0.5, "r": 2.6052631578947367, "e": -0.16279340490885932}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-8626_d063f471", "label": 0, "code": "@Override\npublic void init(ManagementStrategy strategy) {\n    super.init(strategy);\n    exchangesInFlightStartTimestamps.clear();\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void init(ManagementStrategy strategy) {\n    super.init(strategy);\n    exchangesInFlightStartTimestamps.clear();\n}", "lc": -0.4090909090909091, "pi": -0.49282296650717716, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.7626497533474278, "fo": -0.3333333333333333, "r": 1.2368421052631577, "e": -0.16279340490885932}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-464_484c865f", "label": 1, "code": "private Node constructNode(final String name, final Node parent, final JsonNode jsonNode) {\n    final PluginType<?> type = pluginManager.getPluginType(name);\n    final Node node = new Node(parent, name, type);\n    processAttributes(node, jsonNode);\n    final Iterator<Map.Entry<String, JsonNode>> iter = jsonNode.fields();\n    final List<Node> children = node.getChildren();\n    while (iter.hasNext()) {\n        final Map.Entry<String, JsonNode> entry = iter.next();\n        final JsonNode n = entry.getValue();\n        if (n.isArray() || n.isObject()) {\n            if (type == null) {\n                status.add(new Status(name, n, ErrorType.CLASS_NOT_FOUND));\n            }\n            if (n.isArray()) {\n                LOGGER.debug(\"Processing node for array \" + entry.getKey());\n                for (int i = 0; i < n.size(); ++i) {\n                    final String pluginType = getType(n.get(i), entry.getKey());\n                    final PluginType<?> entryType = pluginManager.getPluginType(pluginType);\n                    final Node item = new Node(node, entry.getKey(), entryType);\n                    processAttributes(item, n.get(i));\n                    if (pluginType.equals(entry.getKey())) {\n                        LOGGER.debug(\"Processing \" + entry.getKey() + \"[\" + i + \"]\");\n                    } else {\n                        LOGGER.debug(\"Processing \" + pluginType + \" \" + entry.getKey() + \"[\" + i + \"]\");\n                    }\n                    final Iterator<Map.Entry<String, JsonNode>> itemIter = n.get(i).fields();\n                    final List<Node> itemChildren = item.getChildren();\n                    while (itemIter.hasNext()) {\n                        final Map.Entry<String, JsonNode> itemEntry = itemIter.next();\n                        if (itemEntry.getValue().isObject()) {\n                            LOGGER.debug(\"Processing node for object \" + itemEntry.getKey());\n                            itemChildren.add(constructNode(itemEntry.getKey(), item, itemEntry.getValue()));\n                        }\n                    }\n                    children.add(item);\n                }\n            } else {\n                LOGGER.debug(\"Processing node for object \" + entry.getKey());\n                children.add(constructNode(entry.getKey(), node, n));\n            }\n        }\n    }\n    String t;\n    if (type == null) {\n        t = \"null\";\n    } else {\n        t = type.getElementName() + \":\" + type.getPluginClass();\n    }\n    final String p = node.getParent() == null ? \"null\" : node.getParent().getName() == null ? \"root\" : node.getParent().getName();\n    LOGGER.debug(\"Returning \" + node.getName() + \" with parent \" + p + \" of type \" + t);\n    return node;\n}", "code_comment": NaN, "code_no_comment": "private Node constructNode(final String name, final Node parent, final JsonNode jsonNode) {\n    final PluginType<?> type = pluginManager.getPluginType(name);\n    final Node node = new Node(parent, name, type);\n    processAttributes(node, jsonNode);\n    final Iterator<Map.Entry<String, JsonNode>> iter = jsonNode.fields();\n    final List<Node> children = node.getChildren();\n    while (iter.hasNext()) {\n        final Map.Entry<String, JsonNode> entry = iter.next();\n        final JsonNode n = entry.getValue();\n        if (n.isArray() || n.isObject()) {\n            if (type == null) {\n                status.add(new Status(name, n, ErrorType.CLASS_NOT_FOUND));\n            }\n            if (n.isArray()) {\n                LOGGER.debug(\"Processing node for array \" + entry.getKey());\n                for (int i = 0; i < n.size(); ++i) {\n                    final String pluginType = getType(n.get(i), entry.getKey());\n                    final PluginType<?> entryType = pluginManager.getPluginType(pluginType);\n                    final Node item = new Node(node, entry.getKey(), entryType);\n                    processAttributes(item, n.get(i));\n                    if (pluginType.equals(entry.getKey())) {\n                        LOGGER.debug(\"Processing \" + entry.getKey() + \"[\" + i + \"]\");\n                    } else {\n                        LOGGER.debug(\"Processing \" + pluginType + \" \" + entry.getKey() + \"[\" + i + \"]\");\n                    }\n                    final Iterator<Map.Entry<String, JsonNode>> itemIter = n.get(i).fields();\n                    final List<Node> itemChildren = item.getChildren();\n                    while (itemIter.hasNext()) {\n                        final Map.Entry<String, JsonNode> itemEntry = itemIter.next();\n                        if (itemEntry.getValue().isObject()) {\n                            LOGGER.debug(\"Processing node for object \" + itemEntry.getKey());\n                            itemChildren.add(constructNode(itemEntry.getKey(), item, itemEntry.getValue()));\n                        }\n                    }\n                    children.add(item);\n                }\n            } else {\n                LOGGER.debug(\"Processing node for object \" + entry.getKey());\n                children.add(constructNode(entry.getKey(), node, n));\n            }\n        }\n    }\n    String t;\n    if (type == null) {\n        t = \"null\";\n    } else {\n        t = type.getElementName() + \":\" + type.getPluginClass();\n    }\n    final String p = node.getParent() == null ? \"null\" : node.getParent().getName() == null ? \"root\" : node.getParent().getName();\n    LOGGER.debug(\"Returning \" + node.getName() + \" with parent \" + p + \" of type \" + t);\n    return node;\n}", "lc": 1.7272727272727273, "pi": 2.397129186602871, "ma": 1.6, "nbd": 2.0, "ml": 1.5833333333333333, "d": 1.5277777777777777, "mi": -0.9768851303735022, "fo": 4.083333333333333, "r": -0.02631578947368421, "e": 6.450891236320256}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3021_494da6de", "label": 1, "code": "@Override\npublic Validator childNodeAdded(String name, NodeState after) throws CommitFailedException {\n    Tree tree = checkNotNull(parentAfter.getChild(name));\n    validateAuthorizable(tree, UserUtil.getType(tree));\n    return new VisibleValidator(new UserValidator(null, tree, provider), true, true);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic Validator childNodeAdded(String name, NodeState after) throws CommitFailedException {\n    Tree tree = checkNotNull(parentAfter.getChild(name));\n    validateAuthorizable(tree, UserUtil.getType(tree));\n    return new VisibleValidator(new UserValidator(null, tree, provider), true, true);\n}", "lc": -0.36363636363636365, "pi": -0.47368421052631593, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.4432699083861872, "fo": -0.16666666666666666, "r": -0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3989_6a8fc1cc", "label": 1, "code": "/**\n *  Search for the child's markup in the associated markup file.\n *\n *  @param parent\n *             The container expected to contain the markup for child\n *  @param child\n *             The child component to find the markup for\n *  @return The markup associated with the child\n */\n@Override\npublic IMarkupFragment getMarkup(final MarkupContainer parent, final Component child) {\n    Args.notNull(tagName, \"tagName\");\n    IMarkupFragment associatedMarkup = parent.getAssociatedMarkup();\n    if (associatedMarkup == null) {\n        throw new MarkupNotFoundException(\"Failed to find markup file associated. \" + parent.getClass().getSimpleName() + \": \" + parent.toString());\n    }\n    // Find <wicket:panel>\n    IMarkupFragment markup = findStartTag(associatedMarkup);\n    if (markup == null) {\n        throw new MarkupNotFoundException(\"Expected to find <wicket:\" + tagName + \"> in associated markup file. Markup: \" + associatedMarkup.toString());\n    }\n    // If child == null, than return the markup fragment starting with <wicket:panel>\n    if (child == null) {\n        return markup;\n    }\n    // Find the markup for the child component\n    associatedMarkup = markup.find(child.getId());\n    if (associatedMarkup != null) {\n        return associatedMarkup;\n    }\n    return findMarkupInAssociatedFileHeader(parent, child);\n}", "code_comment": "/**\n *  Search for the child's markup in the associated markup file.\n *\n *  @param parent\n *             The container expected to contain the markup for child\n *  @param child\n *             The child component to find the markup for\n *  @return The markup associated with the child\n */\n", "code_no_comment": "@Override\npublic IMarkupFragment getMarkup(final MarkupContainer parent, final Component child) {\n    Args.notNull(tagName, \"tagName\");\n    IMarkupFragment associatedMarkup = parent.getAssociatedMarkup();\n    if (associatedMarkup == null) {\n        throw new MarkupNotFoundException(\"Failed to find markup file associated. \" + parent.getClass().getSimpleName() + \": \" + parent.toString());\n    }\n        IMarkupFragment markup = findStartTag(associatedMarkup);\n    if (markup == null) {\n        throw new MarkupNotFoundException(\"Expected to find <wicket:\" + tagName + \"> in associated markup file. Markup: \" + associatedMarkup.toString());\n    }\n        if (child == null) {\n        return markup;\n    }\n        associatedMarkup = markup.find(child.getId());\n    if (associatedMarkup != null) {\n        return associatedMarkup;\n    }\n    return findMarkupInAssociatedFileHeader(parent, child);\n}", "lc": 0.2727272727272727, "pi": -0.3014354066985648, "ma": 0.6, "nbd": -0.5, "ml": 0.16666666666666666, "d": 0.3988095238095238, "mi": -0.2730091613812544, "fo": 0.3333333333333333, "r": -0.02631578947368421, "e": 0.37387320412855923}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-949_f83bbc1d", "label": 1, "code": "/**\n * {@inheritDoc}\n */\n@Override\nprotected PointValuePair doOptimize() {\n    checkParameters();\n    final GoalType goal = getGoalType();\n    final double[] guess = getStartPoint();\n    final int n = guess.length;\n    final double[][] direc = new double[n][n];\n    for (int i = 0; i < n; i++) {\n        direc[i][i] = 1;\n    }\n    final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();\n    double[] x = guess;\n    double fVal = computeObjectiveValue(x);\n    double[] x1 = x.clone();\n    int iter = 0;\n    while (true) {\n        ++iter;\n        double fX = fVal;\n        double fX2 = 0;\n        double delta = 0;\n        int bigInd = 0;\n        double alphaMin = 0;\n        for (int i = 0; i < n; i++) {\n            final double[] d = MathArrays.copyOf(direc[i]);\n            fX2 = fVal;\n            final UnivariatePointValuePair optimum = line.search(x, d);\n            fVal = optimum.getValue();\n            alphaMin = optimum.getPoint();\n            final double[][] result = newPointAndDirection(x, d, alphaMin);\n            x = result[0];\n            if ((fX2 - fVal) > delta) {\n                delta = fX2 - fVal;\n                bigInd = i;\n            }\n        }\n        // Default convergence check.\n        boolean stop = 2 * (fX - fVal) <= (relativeThreshold * (FastMath.abs(fX) + FastMath.abs(fVal)) + absoluteThreshold);\n        final PointValuePair previous = new PointValuePair(x1, fX);\n        final PointValuePair current = new PointValuePair(x, fVal);\n        if (!stop) {\n            // User-defined stopping criteria.\n            if (checker != null) {\n                stop = checker.converged(iter, previous, current);\n            }\n        }\n        if (stop) {\n            if (goal == GoalType.MINIMIZE) {\n                return (fVal < fX) ? current : previous;\n            } else {\n                return (fVal > fX) ? current : previous;\n            }\n        }\n        final double[] d = new double[n];\n        final double[] x2 = new double[n];\n        for (int i = 0; i < n; i++) {\n            d[i] = x[i] - x1[i];\n            x2[i] = 2 * x[i] - x1[i];\n        }\n        x1 = x.clone();\n        fX2 = computeObjectiveValue(x2);\n        if (fX > fX2) {\n            double t = 2 * (fX + fX2 - 2 * fVal);\n            double temp = fX - fVal - delta;\n            t *= temp * temp;\n            temp = fX - fX2;\n            t -= delta * temp * temp;\n            if (t < 0.0) {\n                final UnivariatePointValuePair optimum = line.search(x, d);\n                fVal = optimum.getValue();\n                alphaMin = optimum.getPoint();\n                final double[][] result = newPointAndDirection(x, d, alphaMin);\n                x = result[0];\n                final int lastInd = n - 1;\n                direc[bigInd] = direc[lastInd];\n                direc[lastInd] = result[1];\n            }\n        }\n    }\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "@Override\nprotected PointValuePair doOptimize() {\n    checkParameters();\n    final GoalType goal = getGoalType();\n    final double[] guess = getStartPoint();\n    final int n = guess.length;\n    final double[][] direc = new double[n][n];\n    for (int i = 0; i < n; i++) {\n        direc[i][i] = 1;\n    }\n    final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();\n    double[] x = guess;\n    double fVal = computeObjectiveValue(x);\n    double[] x1 = x.clone();\n    int iter = 0;\n    while (true) {\n        ++iter;\n        double fX = fVal;\n        double fX2 = 0;\n        double delta = 0;\n        int bigInd = 0;\n        double alphaMin = 0;\n        for (int i = 0; i < n; i++) {\n            final double[] d = MathArrays.copyOf(direc[i]);\n            fX2 = fVal;\n            final UnivariatePointValuePair optimum = line.search(x, d);\n            fVal = optimum.getValue();\n            alphaMin = optimum.getPoint();\n            final double[][] result = newPointAndDirection(x, d, alphaMin);\n            x = result[0];\n            if ((fX2 - fVal) > delta) {\n                delta = fX2 - fVal;\n                bigInd = i;\n            }\n        }\n                boolean stop = 2 * (fX - fVal) <= (relativeThreshold * (FastMath.abs(fX) + FastMath.abs(fVal)) + absoluteThreshold);\n        final PointValuePair previous = new PointValuePair(x1, fX);\n        final PointValuePair current = new PointValuePair(x, fVal);\n        if (!stop) {\n                        if (checker != null) {\n                stop = checker.converged(iter, previous, current);\n            }\n        }\n        if (stop) {\n            if (goal == GoalType.MINIMIZE) {\n                return (fVal < fX) ? current : previous;\n            } else {\n                return (fVal > fX) ? current : previous;\n            }\n        }\n        final double[] d = new double[n];\n        final double[] x2 = new double[n];\n        for (int i = 0; i < n; i++) {\n            d[i] = x[i] - x1[i];\n            x2[i] = 2 * x[i] - x1[i];\n        }\n        x1 = x.clone();\n        fX2 = computeObjectiveValue(x2);\n        if (fX > fX2) {\n            double t = 2 * (fX + fX2 - 2 * fVal);\n            double temp = fX - fVal - delta;\n            t *= temp * temp;\n            temp = fX - fX2;\n            t -= delta * temp * temp;\n            if (t < 0.0) {\n                final UnivariatePointValuePair optimum = line.search(x, d);\n                fVal = optimum.getValue();\n                alphaMin = optimum.getPoint();\n                final double[][] result = newPointAndDirection(x, d, alphaMin);\n                x = result[0];\n                final int lastInd = n - 1;\n                direc[bigInd] = direc[lastInd];\n                direc[lastInd] = result[1];\n            }\n        }\n    }\n}", "lc": 2.8636363636363638, "pi": 0.6411483253588517, "ma": 2.0, "nbd": 0.5, "ml": 1.5, "d": 4.089285714285714, "mi": -1.2001409443269904, "fo": 1.1666666666666667, "r": -0.02631578947368421, "e": 19.058391106654444}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-6964_6b2ffb30", "label": 1, "code": "/**\n * Strategy when the file was processed and a commit should be executed.\n *\n * @param processStrategy the strategy to perform the commit\n * @param exchange        the exchange\n * @param file            the file processed\n */\nprotected void processStrategyCommit(GenericFileProcessStrategy<T> processStrategy, Exchange exchange, GenericFile<T> file) {\n    if (endpoint.isIdempotent()) {\n        // use absolute file path as default key, but evaluate if an expression key was configured\n        String key = absoluteFileName;\n        if (endpoint.getIdempotentKey() != null) {\n            Exchange dummy = endpoint.createExchange(file);\n            key = endpoint.getIdempotentKey().evaluate(dummy, String.class);\n        }\n        // only add to idempotent repository if we could process the file\n        if (key != null) {\n            endpoint.getIdempotentRepository().add(key);\n        }\n    }\n    // must be last in batch to delete the done file name\n    // delete done file if used (and not noop=true)\n    boolean complete = exchange.getProperty(Exchange.BATCH_COMPLETE, false, Boolean.class);\n    if (endpoint.getDoneFileName() != null && !endpoint.isNoop()) {\n        // done file must be in same path as the original input file\n        String doneFileName = endpoint.createDoneFileName(absoluteFileName);\n        ObjectHelper.notEmpty(doneFileName, \"doneFileName\", endpoint);\n        // we should delete the dynamic done file\n        if (endpoint.getDoneFileName().indexOf(\"{file:name\") > 0 || complete) {\n            try {\n                // delete done file\n                boolean deleted = operations.deleteFile(doneFileName);\n                log.trace(\"Done file: {} was deleted: {}\", doneFileName, deleted);\n                if (!deleted) {\n                    log.warn(\"Done file: \" + doneFileName + \" could not be deleted\");\n                }\n            } catch (Exception e) {\n                handleException(\"Error deleting done file: \" + doneFileName, exchange, e);\n            }\n        }\n    }\n    try {\n        log.trace(\"Commit file strategy: {} for file: {}\", processStrategy, file);\n        processStrategy.commit(operations, endpoint, exchange, file);\n    } catch (Exception e) {\n        handleException(\"Error during commit\", exchange, e);\n    }\n}", "code_comment": "/**\n * Strategy when the file was processed and a commit should be executed.\n *\n * @param processStrategy the strategy to perform the commit\n * @param exchange        the exchange\n * @param file            the file processed\n */\n", "code_no_comment": "protected void processStrategyCommit(GenericFileProcessStrategy<T> processStrategy, Exchange exchange, GenericFile<T> file) {\n    if (endpoint.isIdempotent()) {\n                String key = absoluteFileName;\n        if (endpoint.getIdempotentKey() != null) {\n            Exchange dummy = endpoint.createExchange(file);\n            key = endpoint.getIdempotentKey().evaluate(dummy, String.class);\n        }\n                if (key != null) {\n            endpoint.getIdempotentRepository().add(key);\n        }\n    }\n            boolean complete = exchange.getProperty(Exchange.BATCH_COMPLETE, false, Boolean.class);\n    if (endpoint.getDoneFileName() != null && !endpoint.isNoop()) {\n                String doneFileName = endpoint.createDoneFileName(absoluteFileName);\n        ObjectHelper.notEmpty(doneFileName, \"doneFileName\", endpoint);\n                if (endpoint.getDoneFileName().indexOf(\"{file:name\") > 0 || complete) {\n            try {\n                                boolean deleted = operations.deleteFile(doneFileName);\n                log.trace(\"Done file: {} was deleted: {}\", doneFileName, deleted);\n                if (!deleted) {\n                    log.warn(\"Done file: \" + doneFileName + \" could not be deleted\");\n                }\n            } catch (Exception e) {\n                handleException(\"Error deleting done file: \" + doneFileName, exchange, e);\n            }\n        }\n    }\n    try {\n        log.trace(\"Commit file strategy: {} for file: {}\", processStrategy, file);\n        processStrategy.commit(operations, endpoint, exchange, file);\n    } catch (Exception e) {\n        handleException(\"Error during commit\", exchange, e);\n    }\n}", "lc": 0.9090909090909091, "pi": 0.8803827751196173, "ma": 1.0, "nbd": 1.0, "ml": 0.9166666666666666, "d": 0.8253968253968255, "mi": -0.6496124031007751, "fo": 1.25, "r": -0.02631578947368421, "e": 1.7493219918973273}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-2172_ea4a3f8a", "label": 3, "code": "/**\n *  Generates a <code>String</code> representation of this object.\n *\n *  @return <code>String</code> representation of this <code>ValueMap</code> consistent with the\n *          tag-attribute style of markup elements. For example: <code>a=\"x\" b=\"y\" c=\"z\"</code>.\n */\n@Override\npublic String toString() {\n    final StringBuffer buffer = new StringBuffer();\n    for (final Iterator iterator = entrySet().iterator(); iterator.hasNext(); ) {\n        final Map.Entry entry = (Map.Entry) iterator.next();\n        buffer.append(entry.getKey());\n        buffer.append(\" = \\\"\");\n        final Object value = entry.getValue();\n        if (value == null) {\n            buffer.append(\"null\");\n        } else if (value.getClass().isArray()) {\n            buffer.append(Arrays.asList((Object[]) value));\n        } else {\n            buffer.append(value);\n        }\n        buffer.append('\\\"');\n        if (iterator.hasNext()) {\n            buffer.append(' ');\n        }\n    }\n    return buffer.toString();\n}", "code_comment": "/**\n *  Generates a <code>String</code> representation of this object.\n *\n *  @return <code>String</code> representation of this <code>ValueMap</code> consistent with the\n *          tag-attribute style of markup elements. For example: <code>a=\"x\" b=\"y\" c=\"z\"</code>.\n */\n", "code_no_comment": "@Override\npublic String toString() {\n    final StringBuffer buffer = new StringBuffer();\n    for (final Iterator iterator = entrySet().iterator(); iterator.hasNext(); ) {\n        final Map.Entry entry = (Map.Entry) iterator.next();\n        buffer.append(entry.getKey());\n        buffer.append(\" = \\\"\");\n        final Object value = entry.getValue();\n        if (value == null) {\n            buffer.append(\"null\");\n        } else if (value.getClass().isArray()) {\n            buffer.append(Arrays.asList((Object[]) value));\n        } else {\n            buffer.append(value);\n        }\n        buffer.append('\\\"');\n        if (iterator.hasNext()) {\n            buffer.append(' ');\n        }\n    }\n    return buffer.toString();\n}", "lc": 0.36363636363636365, "pi": 0.3157894736842104, "ma": 0.2, "nbd": 0.5, "ml": 0.16666666666666666, "d": 0.06150793650793648, "mi": -0.305426356589147, "fo": 1.0, "r": -0.02631578947368421, "e": 0.14031338785060193}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-1677_01a3dd66", "label": 1, "code": "/**\n *  @see org.apache.wicket.Component#onComponentTagBody(org.apache.wicket.markup.MarkupStream,\n *       org.apache.wicket.markup.ComponentTag)\n */\n@Override\nprotected final void onComponentTagBody(final MarkupStream markupStream, final ComponentTag openTag) {\n    // Iterate through choices\n    final List<? extends T> choices = getChoices();\n    // Buffer to hold generated body\n    final AppendingStringBuffer buffer = new AppendingStringBuffer(70 * (choices.size() + 1));\n    // Value of this choice\n    final String selected = getValue();\n    // Loop through choices\n    for (int index = 0; index < choices.size(); index++) {\n        // Get next choice\n        final T choice = choices.get(index);\n        Object displayValue = getChoiceRenderer().getDisplayValue(choice);\n        Class<?> objectClass = displayValue == null ? null : displayValue.getClass();\n        // Get label for choice\n        String label = \"\";\n        if (objectClass != null && objectClass != String.class) {\n            IConverter converter = getConverter(objectClass);\n            label = converter.convertToString(displayValue, getLocale());\n        } else if (displayValue != null) {\n            label = displayValue.toString();\n        }\n        // location in the page markup!\n        if (label != null) {\n            // Append option suffix\n            buffer.append(getPrefix());\n            String id = getChoiceRenderer().getIdValue(choice, index);\n            final String idAttr = getInputName() + \"_\" + id;\n            // Add checkbox element\n            buffer.append(\"<input name=\\\"\").append(getInputName()).append(\"\\\"\").append(\" type=\\\"checkbox\\\"\").append((isSelected(choice, index, selected) ? \" checked=\\\"checked\\\"\" : \"\")).append((isEnabled() ? \"\" : \" disabled=\\\"disabled\\\"\")).append(\" value=\\\"\").append(id).append(\"\\\" id=\\\"\").append(idAttr).append(\"\\\"/>\");\n            // Add label for checkbox\n            String display = label;\n            if (localizeDisplayValues()) {\n                display = getLocalizer().getString(label, this, label);\n            }\n            CharSequence escaped;\n            if (getEscapeModelStrings()) {\n                escaped = Strings.escapeMarkup(display, false, true);\n            } else {\n                escaped = display;\n            }\n            buffer.append(\"<label for=\\\"\");\n            buffer.append(idAttr);\n            buffer.append(\"\\\">\").append(escaped).append(\"</label>\");\n            // Append option suffix\n            buffer.append(getSuffix());\n        }\n    }\n    // Replace body\n    replaceComponentTagBody(markupStream, openTag, buffer);\n}", "code_comment": "/**\n *  @see org.apache.wicket.Component#onComponentTagBody(org.apache.wicket.markup.MarkupStream,\n *       org.apache.wicket.markup.ComponentTag)\n */\n", "code_no_comment": "@Override\nprotected final void onComponentTagBody(final MarkupStream markupStream, final ComponentTag openTag) {\n        final List<? extends T> choices = getChoices();\n        final AppendingStringBuffer buffer = new AppendingStringBuffer(70 * (choices.size() + 1));\n        final String selected = getValue();\n        for (int index = 0; index < choices.size(); index++) {\n                final T choice = choices.get(index);\n        Object displayValue = getChoiceRenderer().getDisplayValue(choice);\n        Class<?> objectClass = displayValue == null ? null : displayValue.getClass();\n                String label = \"\";\n        if (objectClass != null && objectClass != String.class) {\n            IConverter converter = getConverter(objectClass);\n            label = converter.convertToString(displayValue, getLocale());\n        } else if (displayValue != null) {\n            label = displayValue.toString();\n        }\n                if (label != null) {\n                        buffer.append(getPrefix());\n            String id = getChoiceRenderer().getIdValue(choice, index);\n            final String idAttr = getInputName() + \"_\" + id;\n                        buffer.append(\"<input name=\\\"\").append(getInputName()).append(\"\\\"\").append(\" type=\\\"checkbox\\\"\").append((isSelected(choice, index, selected) ? \" checked=\\\"checked\\\"\" : \"\")).append((isEnabled() ? \"\" : \" disabled=\\\"disabled\\\"\")).append(\" value=\\\"\").append(id).append(\"\\\" id=\\\"\").append(idAttr).append(\"\\\"/>\");\n                        String display = label;\n            if (localizeDisplayValues()) {\n                display = getLocalizer().getString(label, this, label);\n            }\n            CharSequence escaped;\n            if (getEscapeModelStrings()) {\n                escaped = Strings.escapeMarkup(display, false, true);\n            } else {\n                escaped = display;\n            }\n            buffer.append(\"<label for=\\\"\");\n            buffer.append(idAttr);\n            buffer.append(\"\\\">\").append(escaped).append(\"</label>\");\n                        buffer.append(getSuffix());\n        }\n    }\n        replaceComponentTagBody(markupStream, openTag, buffer);\n}", "lc": 1.1363636363636365, "pi": 0.6076555023923443, "ma": 1.2, "nbd": 0.5, "ml": 1.3333333333333333, "d": 1.2996031746031746, "mi": -0.7908386187455951, "fo": 3.1666666666666665, "r": -0.02631578947368421, "e": 4.213839087613745}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-2624_ef880545", "label": 1, "code": "/**\n *  @see org.apache.wicket.util.convert.IConverter#convertToObject(java.lang.String,\n *       java.util.Locale)\n */\npublic Object convertToObject(String value, Locale locale) {\n    if (value == null) {\n        return null;\n    }\n    Class<?> theType = type.get();\n    if (\"\".equals(value)) {\n        if (theType.equals(String.class)) {\n            return theType.cast(\"\");\n        }\n        return null;\n    }\n    try {\n        Object converted = Objects.convertValue(value, theType);\n        if (theType.isAssignableFrom(converted.getClass())) {\n            return theType.cast(converted);\n        } else {\n            throw new ConversionException(\"Could not convert value: \" + value + \" to type: \" + theType.getName() + \"(Could not find compatible converter).\").setSourceValue(value);\n        }\n    } catch (Exception e) {\n        throw new ConversionException(e.getMessage(), e).setSourceValue(value);\n    }\n}", "code_comment": "/**\n *  @see org.apache.wicket.util.convert.IConverter#convertToObject(java.lang.String,\n *       java.util.Locale)\n */\n", "code_no_comment": "public Object convertToObject(String value, Locale locale) {\n    if (value == null) {\n        return null;\n    }\n    Class<?> theType = type.get();\n    if (\"\".equals(value)) {\n        if (theType.equals(String.class)) {\n            return theType.cast(\"\");\n        }\n        return null;\n    }\n    try {\n        Object converted = Objects.convertValue(value, theType);\n        if (theType.isAssignableFrom(converted.getClass())) {\n            return theType.cast(converted);\n        } else {\n            throw new ConversionException(\"Could not convert value: \" + value + \" to type: \" + theType.getName() + \"(Could not find compatible converter).\").setSourceValue(value);\n        }\n    } catch (Exception e) {\n        throw new ConversionException(e.getMessage(), e).setSourceValue(value);\n    }\n}", "lc": 0.36363636363636365, "pi": 0.16746411483253573, "ma": 0.8, "nbd": 0.0, "ml": 0.3333333333333333, "d": 0.0039682539682539715, "mi": -0.31698379140239613, "fo": 0.5, "r": -0.02631578947368421, "e": 0.08616494643361397}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-2659_019edb16", "label": 0, "code": "@Override\nprotected void setupIterators(JobConf job, Scanner scanner, String tableName, org.apache.accumulo.core.client.mapred.RangeInputSplit split) {\n    List<IteratorSetting> iterators = null;\n    if (null == split) {\n        iterators = getIterators(job);\n    } else {\n        iterators = split.getIterators();\n    }\n    setupIterators(iterators, scanner);\n}", "code_comment": NaN, "code_no_comment": "@Override\nprotected void setupIterators(JobConf job, Scanner scanner, String tableName, org.apache.accumulo.core.client.mapred.RangeInputSplit split) {\n    List<IteratorSetting> iterators = null;\n    if (null == split) {\n        iterators = getIterators(job);\n    } else {\n        iterators = split.getIterators();\n    }\n    setupIterators(iterators, scanner);\n}", "lc": -0.18181818181818182, "pi": -0.0909090909090911, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": -0.07738095238095241, "mi": 0.16476391825229028, "fo": -0.25, "r": 0.0, "e": -0.05210375569809189}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-4358_74cbba24", "label": 1, "code": "@Override\npublic Iterator<Revision> iterator() {\n    final Iterator<NodeDocument> previousDocs = getPreviousDocLeaves();\n    return new AbstractIterator<Revision>() {\n\n        private NodeDocument nextDoc;\n\n        private Revision nextRevision;\n\n        @Override\n        protected Revision computeNext() {\n            if (stack.isEmpty()) {\n                return endOfData();\n            }\n            Revision next = stack.first();\n            stack.remove(next);\n            fillStackIfNeeded();\n            return next;\n        }\n\n        private void fillStackIfNeeded() {\n            for (; ; ) {\n                fetchNextDoc();\n                // no more changes to compare with\n                if (nextDoc == null) {\n                    return;\n                }\n                // most recent revision of next document\n                if (!stack.isEmpty()) {\n                    Revision top = stack.first();\n                    if (top.compareRevisionTimeThenClusterId(nextRevision) > 0) {\n                        return;\n                    }\n                }\n                // if we get here, we need to pull in changes\n                // from nextDoc\n                Iterables.addAll(stack, nextDoc.getAllChanges());\n                nextDoc = null;\n                nextRevision = null;\n            }\n        }\n\n        /**\n         * Fetch the next document if {@code nextDoc} is\n         * {@code null} and there are more documents.\n         */\n        private void fetchNextDoc() {\n            for (; ; ) {\n                if (nextDoc != null) {\n                    break;\n                }\n                if (!previousDocs.hasNext()) {\n                    // no more previous docs\n                    break;\n                }\n                nextDoc = previousDocs.next();\n                Iterator<Revision> changes = nextDoc.getAllChanges().iterator();\n                if (changes.hasNext()) {\n                    nextRevision = changes.next();\n                    break;\n                } else {\n                    // empty document, try next\n                    nextDoc = null;\n                }\n            }\n        }\n    };\n}", "code_comment": "/**\n * Fetch the next document if {@code nextDoc} is\n * {@code null} and there are more documents.\n */\n", "code_no_comment": "@Override\npublic Iterator<Revision> iterator() {\n    final Iterator<NodeDocument> previousDocs = getPreviousDocLeaves();\n    return new AbstractIterator<Revision>() {\n\n        private NodeDocument nextDoc;\n\n        private Revision nextRevision;\n\n        @Override\n        protected Revision computeNext() {\n            if (stack.isEmpty()) {\n                return endOfData();\n            }\n            Revision next = stack.first();\n            stack.remove(next);\n            fillStackIfNeeded();\n            return next;\n        }\n\n        private void fillStackIfNeeded() {\n            for (; ; ) {\n                fetchNextDoc();\n                                if (nextDoc == null) {\n                    return;\n                }\n                                if (!stack.isEmpty()) {\n                    Revision top = stack.first();\n                    if (top.compareRevisionTimeThenClusterId(nextRevision) > 0) {\n                        return;\n                    }\n                }\n                                                Iterables.addAll(stack, nextDoc.getAllChanges());\n                nextDoc = null;\n                nextRevision = null;\n            }\n        }\n\n        /**\n         * Fetch the next document if {@code nextDoc} is\n         * {@code null} and there are more documents.\n         */\n        private void fetchNextDoc() {\n            for (; ; ) {\n                if (nextDoc != null) {\n                    break;\n                }\n                if (!previousDocs.hasNext()) {\n                                        break;\n                }\n                nextDoc = previousDocs.next();\n                Iterator<Revision> changes = nextDoc.getAllChanges().iterator();\n                if (changes.hasNext()) {\n                    nextRevision = changes.next();\n                    break;\n                } else {\n                                        nextDoc = null;\n                }\n            }\n        }\n    };\n}", "lc": 1.9545454545454546, "pi": 1.2440191387559807, "ma": 1.8, "nbd": 1.0, "ml": 0.6666666666666666, "d": 0.6468253968253967, "mi": -0.8477801268498941, "fo": 1.0, "r": -0.02631578947368421, "e": 0.8905770416601833}
{"project_name": "maven", "project_version": "remotes/origin/bugs-dot-jar_MNG-1509_4e955c05", "label": 1, "code": "public boolean isActive(Profile profile) {\n    Activation activation = profile.getActivation();\n    ActivationOS os = activation.getOs();\n    boolean hasNonNull = ensureAtLeastOneNonNull(os);\n    boolean isFamily = determineFamilyMatch(os.getFamily());\n    boolean isName = determineNameMatch(os.getName());\n    boolean isArch = determineArchMatch(os.getArch());\n    boolean isVersion = determineVersionMatch(os.getVersion());\n    return hasNonNull && isFamily && isName && isArch && isVersion;\n}", "code_comment": NaN, "code_no_comment": "public boolean isActive(Profile profile) {\n    Activation activation = profile.getActivation();\n    ActivationOS os = activation.getOs();\n    boolean hasNonNull = ensureAtLeastOneNonNull(os);\n    boolean isFamily = determineFamilyMatch(os.getFamily());\n    boolean isName = determineNameMatch(os.getName());\n    boolean isArch = determineArchMatch(os.getArch());\n    boolean isVersion = determineVersionMatch(os.getVersion());\n    return hasNonNull && isFamily && isName && isArch && isVersion;\n}", "lc": -0.18181818181818182, "pi": -0.6650717703349284, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.06746031746031747, "mi": 0.13798449612403085, "fo": 0.4166666666666667, "r": 0.6052631578947368, "e": -0.019766832062608413}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-2812_e494c279", "label": 3, "code": "public static <X> KeySelector<X, Tuple> getSelectorForKeys(Keys<X> keys, TypeInformation<X> typeInfo, ExecutionConfig executionConfig) {\n    if (!(typeInfo instanceof CompositeType)) {\n        throw new InvalidTypesException(\"This key operation requires a composite type such as Tuples, POJOs, or Case Classes.\");\n    }\n    CompositeType<X> compositeType = (CompositeType<X>) typeInfo;\n    int[] logicalKeyPositions = keys.computeLogicalKeyPositions();\n    int numKeyFields = logicalKeyPositions.length;\n    // use ascending order here, the code paths for that are usually a slight bit faster\n    boolean[] orders = new boolean[numKeyFields];\n    for (int i = 0; i < numKeyFields; i++) {\n        orders[i] = true;\n    }\n    TypeComparator<X> comparator = compositeType.createComparator(logicalKeyPositions, orders, 0, executionConfig);\n    return new ComparableKeySelector<X>(comparator, numKeyFields);\n}", "code_comment": NaN, "code_no_comment": "public static <X> KeySelector<X, Tuple> getSelectorForKeys(Keys<X> keys, TypeInformation<X> typeInfo, ExecutionConfig executionConfig) {\n    if (!(typeInfo instanceof CompositeType)) {\n        throw new InvalidTypesException(\"This key operation requires a composite type such as Tuples, POJOs, or Case Classes.\");\n    }\n    CompositeType<X> compositeType = (CompositeType<X>) typeInfo;\n    int[] logicalKeyPositions = keys.computeLogicalKeyPositions();\n    int numKeyFields = logicalKeyPositions.length;\n        boolean[] orders = new boolean[numKeyFields];\n    for (int i = 0; i < numKeyFields; i++) {\n        orders[i] = true;\n    }\n    TypeComparator<X> comparator = compositeType.createComparator(logicalKeyPositions, orders, 0, executionConfig);\n    return new ComparableKeySelector<X>(comparator, numKeyFields);\n}", "lc": 0.0, "pi": -0.4066985645933015, "ma": 0.0, "nbd": -0.5, "ml": 0.0, "d": 0.41468253968253965, "mi": -0.09541930937279787, "fo": -0.3333333333333333, "r": -0.02631578947368421, "e": 0.40212997700592995}
{"project_name": "Closure", "project_version": 30, "label": 2, "code": "/**\n * Computes all the local variables that rValue reads from and store that\n * in the def's depends set.\n */\nprivate void computeDependence(final Definition def, Node rValue) {\n    NodeTraversal.traverse(compiler, rValue, new AbstractCfgNodeTraversalCallback() {\n\n        @Override\n        public void visit(NodeTraversal t, Node n, Node parent) {\n            if (n.isName() && jsScope.isDeclared(n.getString(), true)) {\n                Var dep = jsScope.getVar(n.getString());\n                def.depends.add(dep);\n            }\n        }\n    });\n}", "code_comment": "/**\n * Computes all the local variables that rValue reads from and store that\n * in the def's depends set.\n */\n", "code_no_comment": "private void computeDependence(final Definition def, Node rValue) {\n    NodeTraversal.traverse(compiler, rValue, new AbstractCfgNodeTraversalCallback() {\n\n        @Override\n        public void visit(NodeTraversal t, Node n, Node parent) {\n            if (n.isName() && jsScope.isDeclared(n.getString(), true)) {\n                Var dep = jsScope.getVar(n.getString());\n                def.depends.add(dep);\n            }\n        }\n    });\n}", "lc": -0.13636363636363635, "pi": 1.1483253588516744, "ma": -0.4, "nbd": 0.0, "ml": 0.0, "d": -0.07936507936507939, "mi": 0.1078224101479916, "fo": 0.08333333333333333, "r": 0.5263157894736842, "e": -0.04283697262034428}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-478_11763dee", "label": 1, "code": "/**\n * This method takes a string which may contain JSON reserved chars and\n * escapes them.\n *\n * @param input The text to be converted.\n * @return The input string with the special characters replaced.\n */\npublic static String escapeJsonControlCharacters(final String input) {\n    if (Strings.isEmpty(input) || (input.indexOf('\"') == -1 && input.indexOf('\\\\') == -1 && input.indexOf('/') == -1 && input.indexOf('\\b') == -1 && input.indexOf('\\f') == -1 && input.indexOf('\\n') == -1 && input.indexOf('\\r') == -1 && input.indexOf('\\t') == -1)) {\n        return input;\n    }\n    final StringBuilder buf = new StringBuilder(input.length() + 6);\n    final int len = input.length();\n    for (int i = 0; i < len; i++) {\n        final char ch = input.charAt(i);\n        final String escBs = \"\\\\\\\\\";\n        switch(ch) {\n            case '\"':\n                buf.append(escBs);\n                buf.append(ch);\n                break;\n            case '\\\\':\n                buf.append(escBs);\n                buf.append(ch);\n                break;\n            case '/':\n                buf.append(escBs);\n                buf.append(ch);\n                break;\n            case '\\b':\n                buf.append(escBs);\n                buf.append('b');\n                break;\n            case '\\f':\n                buf.append(escBs);\n                buf.append('f');\n                break;\n            case '\\n':\n                buf.append(escBs);\n                buf.append('n');\n                break;\n            case '\\r':\n                buf.append(escBs);\n                buf.append('r');\n                break;\n            case '\\t':\n                buf.append(escBs);\n                buf.append('t');\n                break;\n            default:\n                buf.append(ch);\n        }\n    }\n    return buf.toString();\n}", "code_comment": "/**\n * This method takes a string which may contain JSON reserved chars and\n * escapes them.\n *\n * @param input The text to be converted.\n * @return The input string with the special characters replaced.\n */\n", "code_no_comment": "public static String escapeJsonControlCharacters(final String input) {\n    if (Strings.isEmpty(input) || (input.indexOf('\"') == -1 && input.indexOf('\\\\') == -1 && input.indexOf('/') == -1 && input.indexOf('\\b') == -1 && input.indexOf('\\f') == -1 && input.indexOf('\\n') == -1 && input.indexOf('\\r') == -1 && input.indexOf('\\t') == -1)) {\n        return input;\n    }\n    final StringBuilder buf = new StringBuilder(input.length() + 6);\n    final int len = input.length();\n    for (int i = 0; i < len; i++) {\n        final char ch = input.charAt(i);\n        final String escBs = \"\\\\\\\\\";\n        switch(ch) {\n            case '\"':\n                buf.append(escBs);\n                buf.append(ch);\n                break;\n            case '\\\\':\n                buf.append(escBs);\n                buf.append(ch);\n                break;\n            case '/':\n                buf.append(escBs);\n                buf.append(ch);\n                break;\n            case '\\b':\n                buf.append(escBs);\n                buf.append('b');\n                break;\n            case '\\f':\n                buf.append(escBs);\n                buf.append('f');\n                break;\n            case '\\n':\n                buf.append(escBs);\n                buf.append('n');\n                break;\n            case '\\r':\n                buf.append(escBs);\n                buf.append('r');\n                break;\n            case '\\t':\n                buf.append(escBs);\n                buf.append('t');\n                break;\n            default:\n                buf.append(ch);\n        }\n    }\n    return buf.toString();\n}", "lc": 1.5454545454545454, "pi": 0.9760765550239235, "ma": 3.2, "nbd": 0.5, "ml": 2.1666666666666665, "d": 2.5297619047619047, "mi": -0.9069767441860462, "fo": 2.0, "r": -0.02631578947368421, "e": 5.494854284446442}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-1619_b154d12f", "label": 1, "code": "/**\n *  Create a new pagenumber link. May be subclassed to make use of specialized links, e.g.\n *  Ajaxian links.\n *\n *  @param id\n *             the link id\n *  @param pageable\n *             the pageable to control\n *  @param pageNumber\n *             the page to jump to\n *  @return the pagenumber link\n */\nprotected Link<?> newPagingNavigationLink(String id, IPageable pageable, int pageNumber) {\n    return new PagingNavigationLink<Void>(id, pageable, pageNumber) {\n\n        private static final long serialVersionUID = 1L;\n\n        @Override\n        public boolean isEnabled() {\n            return PagingNavigator.this.isEnabled() && PagingNavigator.this.isEnableAllowed();\n        }\n    };\n}", "code_comment": "/**\n *  Create a new pagenumber link. May be subclassed to make use of specialized links, e.g.\n *  Ajaxian links.\n *\n *  @param id\n *             the link id\n *  @param pageable\n *             the pageable to control\n *  @param pageNumber\n *             the page to jump to\n *  @return the pagenumber link\n */\n", "code_no_comment": "protected Link<?> newPagingNavigationLink(String id, IPageable pageable, int pageNumber) {\n    return new PagingNavigationLink<Void>(id, pageable, pageNumber) {\n\n        private static final long serialVersionUID = 1L;\n\n        @Override\n        public boolean isEnabled() {\n            return PagingNavigator.this.isEnabled() && PagingNavigator.this.isEnableAllowed();\n        }\n    };\n}", "lc": -0.22727272727272727, "pi": 0.39712918660287067, "ma": -0.6, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.10515873015873016, "mi": 0.29894291754756874, "fo": -0.3333333333333333, "r": 2.3421052631578947, "e": -0.104758447007025}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1250_0c3b3306", "label": 1, "code": "@Override\n@CheckForNull\npublic synchronized NodeState retrieve(@Nonnull String checkpoint) {\n    // TODO: Verify validity of the checkpoint\n    RecordId id = RecordId.fromString(checkNotNull(checkpoint));\n    SegmentNodeState root = new SegmentNodeState(store.getWriter().getDummySegment(), id);\n    return root.getChildNode(ROOT);\n}", "code_comment": NaN, "code_no_comment": "@Override\n@CheckForNull\npublic synchronized NodeState retrieve(@Nonnull String checkpoint) {\n        RecordId id = RecordId.fromString(checkNotNull(checkpoint));\n    SegmentNodeState root = new SegmentNodeState(store.getWriter().getDummySegment(), id);\n    return root.getChildNode(ROOT);\n}", "lc": -0.3181818181818182, "pi": -0.48325358851674655, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.390274841437632, "fo": -0.08333333333333333, "r": 1.263157894736842, "e": -0.16279340490885932}
{"project_name": "Closure", "project_version": 79, "label": 1, "code": "/**\n * Create a new variable in a synthetic script. This will prevent\n * subsequent compiler passes from crashing.\n */\nprivate void createSynthesizedExternVar(String varName) {\n    Node nameNode = Node.newString(Token.NAME, varName);\n    // cases for this configuration though, and it makes them happier.\n    if (compiler.getCodingConvention().isConstant(varName)) {\n        nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    }\n    getSynthesizedExternsRoot().addChildToBack(new Node(Token.VAR, nameNode));\n    varsToDeclareInExterns.remove(varName);\n}", "code_comment": "/**\n * Create a new variable in a synthetic script. This will prevent\n * subsequent compiler passes from crashing.\n */\n", "code_no_comment": "private void createSynthesizedExternVar(String varName) {\n    Node nameNode = Node.newString(Token.NAME, varName);\n        if (compiler.getCodingConvention().isConstant(varName)) {\n        nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    }\n    getSynthesizedExternsRoot().addChildToBack(new Node(Token.VAR, nameNode));\n    varsToDeclareInExterns.remove(varName);\n}", "lc": -0.2727272727272727, "pi": -0.2822966507177035, "ma": -0.4, "nbd": -0.5, "ml": -0.16666666666666666, "d": -0.3650793650793651, "mi": 0.299506694855532, "fo": 0.08333333333333333, "r": 0.21052631578947367, "e": -0.16279340490885932}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1348_ef0f6ddc", "label": 1, "code": "public int start() throws IOException {\n    if (configError)\n        return 1;\n    String input;\n    if (isVerbose())\n        printInfo();\n    String home = System.getProperty(\"HOME\");\n    if (home == null)\n        home = System.getenv(\"HOME\");\n    String configDir = home + \"/.accumulo\";\n    String historyPath = configDir + \"/shell_history.txt\";\n    File accumuloDir = new File(configDir);\n    if (!accumuloDir.exists() && !accumuloDir.mkdirs())\n        log.warn(\"Unable to make directory for history at \" + accumuloDir);\n    try {\n        History history = new History();\n        history.setHistoryFile(new File(historyPath));\n        reader.setHistory(history);\n    } catch (IOException e) {\n        log.warn(\"Unable to load history file at \" + historyPath);\n    }\n    ShellCompletor userCompletor = null;\n    if (execFile != null) {\n        java.util.Scanner scanner = new java.util.Scanner(new File(execFile));\n        while (scanner.hasNextLine()) execCommand(scanner.nextLine(), true, isVerbose());\n    } else if (execCommand != null) {\n        for (String command : execCommand.split(\"\\n\")) {\n            execCommand(command, true, isVerbose());\n        }\n        return exitCode;\n    }\n    while (true) {\n        if (hasExited())\n            return exitCode;\n        // If tab completion is true we need to reset\n        if (tabCompletion) {\n            if (userCompletor != null)\n                reader.removeCompletor(userCompletor);\n            userCompletor = setupCompletion();\n            reader.addCompletor(userCompletor);\n        }\n        reader.setDefaultPrompt(getDefaultPrompt());\n        input = reader.readLine();\n        if (input == null) {\n            reader.printNewline();\n            return exitCode;\n        }\n        // user canceled\n        execCommand(input, disableAuthTimeout, false);\n    }\n}", "code_comment": NaN, "code_no_comment": "public int start() throws IOException {\n    if (configError)\n        return 1;\n    String input;\n    if (isVerbose())\n        printInfo();\n    String home = System.getProperty(\"HOME\");\n    if (home == null)\n        home = System.getenv(\"HOME\");\n    String configDir = home + \"/.accumulo\";\n    String historyPath = configDir + \"/shell_history.txt\";\n    File accumuloDir = new File(configDir);\n    if (!accumuloDir.exists() && !accumuloDir.mkdirs())\n        log.warn(\"Unable to make directory for history at \" + accumuloDir);\n    try {\n        History history = new History();\n        history.setHistoryFile(new File(historyPath));\n        reader.setHistory(history);\n    } catch (IOException e) {\n        log.warn(\"Unable to load history file at \" + historyPath);\n    }\n    ShellCompletor userCompletor = null;\n    if (execFile != null) {\n        java.util.Scanner scanner = new java.util.Scanner(new File(execFile));\n        while (scanner.hasNextLine()) execCommand(scanner.nextLine(), true, isVerbose());\n    } else if (execCommand != null) {\n        for (String command : execCommand.split(\"\\n\")) {\n            execCommand(command, true, isVerbose());\n        }\n        return exitCode;\n    }\n    while (true) {\n        if (hasExited())\n            return exitCode;\n                if (tabCompletion) {\n            if (userCompletor != null)\n                reader.removeCompletor(userCompletor);\n            userCompletor = setupCompletion();\n            reader.addCompletor(userCompletor);\n        }\n        reader.setDefaultPrompt(getDefaultPrompt());\n        input = reader.readLine();\n        if (input == null) {\n            reader.printNewline();\n            return exitCode;\n        }\n                execCommand(input, disableAuthTimeout, false);\n    }\n}", "lc": 1.5909090909090908, "pi": 0.1531100478468899, "ma": 2.2, "nbd": 0.5, "ml": 1.6666666666666667, "d": 0.8253968253968255, "mi": -0.8844256518675121, "fo": 1.6666666666666667, "r": -0.02631578947368421, "e": 2.169480702846308}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2559_dfa87520", "label": 1, "code": "private Map<String, PropertyDefinition> collectPropConfigs(NodeState config, List<NamePattern> patterns, List<Aggregate.Include> propAggregate, List<PropertyDefinition> nonExistentProperties) {\n    Map<String, PropertyDefinition> propDefns = newHashMap();\n    NodeState propNode = config.getChildNode(LuceneIndexConstants.PROP_NODE);\n    if (!propNode.exists()) {\n        return Collections.emptyMap();\n    }\n    if (!hasOrderableChildren(propNode)) {\n        log.warn(\"Properties node for [{}] does not have orderable \" + \"children in [{}]\", this, IndexDefinition.this);\n    }\n    // Include all immediate child nodes to 'properties' node by default\n    Tree propTree = TreeFactory.createReadOnlyTree(propNode);\n    for (Tree prop : propTree.getChildren()) {\n        String propName = prop.getName();\n        NodeState propDefnNode = propNode.getChildNode(propName);\n        if (propDefnNode.exists() && !propDefns.containsKey(propName)) {\n            PropertyDefinition pd = new PropertyDefinition(this, propName, propDefnNode);\n            if (pd.isRegexp) {\n                patterns.add(new NamePattern(pd.name, pd));\n            } else {\n                propDefns.put(pd.name, pd);\n            }\n            if (pd.relative) {\n                propAggregate.add(new Aggregate.PropertyInclude(pd));\n            }\n            if (pd.nullCheckEnabled) {\n                nonExistentProperties.add(pd);\n            }\n        }\n    }\n    return ImmutableMap.copyOf(propDefns);\n}", "code_comment": NaN, "code_no_comment": "private Map<String, PropertyDefinition> collectPropConfigs(NodeState config, List<NamePattern> patterns, List<Aggregate.Include> propAggregate, List<PropertyDefinition> nonExistentProperties) {\n    Map<String, PropertyDefinition> propDefns = newHashMap();\n    NodeState propNode = config.getChildNode(LuceneIndexConstants.PROP_NODE);\n    if (!propNode.exists()) {\n        return Collections.emptyMap();\n    }\n    if (!hasOrderableChildren(propNode)) {\n        log.warn(\"Properties node for [{}] does not have orderable \" + \"children in [{}]\", this, IndexDefinition.this);\n    }\n        Tree propTree = TreeFactory.createReadOnlyTree(propNode);\n    for (Tree prop : propTree.getChildren()) {\n        String propName = prop.getName();\n        NodeState propDefnNode = propNode.getChildNode(propName);\n        if (propDefnNode.exists() && !propDefns.containsKey(propName)) {\n            PropertyDefinition pd = new PropertyDefinition(this, propName, propDefnNode);\n            if (pd.isRegexp) {\n                patterns.add(new NamePattern(pd.name, pd));\n            } else {\n                propDefns.put(pd.name, pd);\n            }\n            if (pd.relative) {\n                propAggregate.add(new Aggregate.PropertyInclude(pd));\n            }\n            if (pd.nullCheckEnabled) {\n                nonExistentProperties.add(pd);\n            }\n        }\n    }\n    return ImmutableMap.copyOf(propDefns);\n}", "lc": 0.7272727272727273, "pi": 0.8325358851674642, "ma": 0.8, "nbd": 0.5, "ml": 0.9166666666666666, "d": 0.40476190476190477, "mi": -0.5670190274841435, "fo": 0.9166666666666666, "r": -0.02631578947368421, "e": 0.9226142932060878}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-939_49444ee6", "label": 1, "code": "/**\n * Compute a covariance matrix from a matrix whose columns represent\n * covariates.\n * @param matrix input matrix (must have at least two columns and two rows)\n * @param biasCorrected determines whether or not covariance estimates are bias-corrected\n * @return covariance matrix\n * @throws MathIllegalArgumentException if the matrix does not contain sufficient data\n */\nprotected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected) throws MathIllegalArgumentException {\n    int dimension = matrix.getColumnDimension();\n    Variance variance = new Variance(biasCorrected);\n    RealMatrix outMatrix = new BlockRealMatrix(dimension, dimension);\n    for (int i = 0; i < dimension; i++) {\n        for (int j = 0; j < i; j++) {\n            double cov = covariance(matrix.getColumn(i), matrix.getColumn(j), biasCorrected);\n            outMatrix.setEntry(i, j, cov);\n            outMatrix.setEntry(j, i, cov);\n        }\n        outMatrix.setEntry(i, i, variance.evaluate(matrix.getColumn(i)));\n    }\n    return outMatrix;\n}", "code_comment": "/**\n * Compute a covariance matrix from a matrix whose columns represent\n * covariates.\n * @param matrix input matrix (must have at least two columns and two rows)\n * @param biasCorrected determines whether or not covariance estimates are bias-corrected\n * @return covariance matrix\n * @throws MathIllegalArgumentException if the matrix does not contain sufficient data\n */\n", "code_no_comment": "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected) throws MathIllegalArgumentException {\n    int dimension = matrix.getColumnDimension();\n    Variance variance = new Variance(biasCorrected);\n    RealMatrix outMatrix = new BlockRealMatrix(dimension, dimension);\n    for (int i = 0; i < dimension; i++) {\n        for (int j = 0; j < i; j++) {\n            double cov = covariance(matrix.getColumn(i), matrix.getColumn(j), biasCorrected);\n            outMatrix.setEntry(i, j, cov);\n            outMatrix.setEntry(j, i, cov);\n        }\n        outMatrix.setEntry(i, i, variance.evaluate(matrix.getColumn(i)));\n    }\n    return outMatrix;\n}", "lc": 0.0, "pi": 0.44976076555023925, "ma": -0.2, "nbd": 0.0, "ml": 0.0, "d": 0.2103174603174603, "mi": -0.08668076109936582, "fo": 0.25, "r": -0.02631578947368421, "e": 0.2484719604893875}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5662_9aec4f33", "label": 1, "code": "@Override\npublic Object getFieldValue(final Field field, final Object fieldOwner) {\n    if (supportsField(field)) {\n        String beanName = getBeanName(field);\n        if (beanName == null) {\n            return null;\n        }\n        SpringBeanLocator locator = new SpringBeanLocator(beanName, field.getType(), contextLocator);\n        // only check the cache if the bean is a singleton\n        Object cachedValue = cache.get(locator);\n        if (cachedValue != null) {\n            return cachedValue;\n        }\n        Object target;\n        if (wrapInProxies) {\n            target = LazyInitProxyFactory.createProxy(field.getType(), locator);\n        } else {\n            target = locator.locateProxyTarget();\n        }\n        // only put the proxy into the cache if the bean is a singleton\n        if (locator.isSingletonBean()) {\n            Object tmpTarget = cache.putIfAbsent(locator, target);\n            if (tmpTarget != null) {\n                target = tmpTarget;\n            }\n        }\n        return target;\n    }\n    return null;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic Object getFieldValue(final Field field, final Object fieldOwner) {\n    if (supportsField(field)) {\n        String beanName = getBeanName(field);\n        if (beanName == null) {\n            return null;\n        }\n        SpringBeanLocator locator = new SpringBeanLocator(beanName, field.getType(), contextLocator);\n                Object cachedValue = cache.get(locator);\n        if (cachedValue != null) {\n            return cachedValue;\n        }\n        Object target;\n        if (wrapInProxies) {\n            target = LazyInitProxyFactory.createProxy(field.getType(), locator);\n        } else {\n            target = locator.locateProxyTarget();\n        }\n                if (locator.isSingletonBean()) {\n            Object tmpTarget = cache.putIfAbsent(locator, target);\n            if (tmpTarget != null) {\n                target = tmpTarget;\n            }\n        }\n        return target;\n    }\n    return null;\n}", "lc": 0.6363636363636364, "pi": 0.41148325358851673, "ma": 0.6, "nbd": 0.5, "ml": 0.6666666666666666, "d": 0.06150793650793648, "mi": -0.44101479915433384, "fo": 0.25, "r": -0.02631578947368421, "e": 0.16766192377955655}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-935_48dde378", "label": 3, "code": "/**\n * Compute two arguments arc tangent of a derivative structure.\n * @param y array holding the first operand\n * @param yOffset offset of the first operand in its array\n * @param x array holding the second operand\n * @param xOffset offset of the second operand in its array\n * @param result array where result must be stored (for\n * two arguments arc tangent the result array <em>cannot</em>\n * be the input array)\n * @param resultOffset offset of the result in its array\n */\npublic void atan2(final double[] y, final int yOffset, final double[] x, final int xOffset, final double[] result, final int resultOffset) {\n    // compute r = sqrt(x^2+y^2)\n    double[] tmp1 = new double[getSize()];\n    // x^2\n    multiply(x, xOffset, x, xOffset, tmp1, 0);\n    double[] tmp2 = new double[getSize()];\n    // y^2\n    multiply(y, yOffset, y, yOffset, tmp2, 0);\n    // x^2 + y^2\n    add(tmp1, 0, tmp2, 0, tmp2, 0);\n    // r = sqrt(x^2 + y^2)\n    rootN(tmp2, 0, 2, tmp1, 0);\n    if (x[xOffset] >= 0) {\n        // compute atan2(y, x) = 2 atan(y / (r + x))\n        // r + x\n        add(tmp1, 0, x, xOffset, tmp2, 0);\n        // y /(r + x)\n        divide(y, yOffset, tmp2, 0, tmp1, 0);\n        // atan(y / (r + x))\n        atan(tmp1, 0, tmp2, 0);\n        for (int i = 0; i < tmp2.length; ++i) {\n            // 2 * atan(y / (r + x))\n            result[resultOffset + i] = 2 * tmp2[i];\n        }\n    } else {\n        // compute atan2(y, x) = +/- pi - 2 atan(y / (r - x))\n        // r - x\n        subtract(tmp1, 0, x, xOffset, tmp2, 0);\n        // y /(r - x)\n        divide(y, yOffset, tmp2, 0, tmp1, 0);\n        // atan(y / (r - x))\n        atan(tmp1, 0, tmp2, 0);\n        result[resultOffset] = // +/-pi - 2 * atan(y / (r - x))\n        ((tmp2[0] <= 0) ? -FastMath.PI : FastMath.PI) - 2 * tmp2[0];\n        for (int i = 1; i < tmp2.length; ++i) {\n            // +/-pi - 2 * atan(y / (r - x))\n            result[resultOffset + i] = -2 * tmp2[i];\n        }\n    }\n}", "code_comment": "/**\n * Compute two arguments arc tangent of a derivative structure.\n * @param y array holding the first operand\n * @param yOffset offset of the first operand in its array\n * @param x array holding the second operand\n * @param xOffset offset of the second operand in its array\n * @param result array where result must be stored (for\n * two arguments arc tangent the result array <em>cannot</em>\n * be the input array)\n * @param resultOffset offset of the result in its array\n */\n", "code_no_comment": "public void atan2(final double[] y, final int yOffset, final double[] x, final int xOffset, final double[] result, final int resultOffset) {\n        double[] tmp1 = new double[getSize()];\n        multiply(x, xOffset, x, xOffset, tmp1, 0);\n    double[] tmp2 = new double[getSize()];\n        multiply(y, yOffset, y, yOffset, tmp2, 0);\n        add(tmp1, 0, tmp2, 0, tmp2, 0);\n        rootN(tmp2, 0, 2, tmp1, 0);\n    if (x[xOffset] >= 0) {\n                        add(tmp1, 0, x, xOffset, tmp2, 0);\n                divide(y, yOffset, tmp2, 0, tmp1, 0);\n                atan(tmp1, 0, tmp2, 0);\n        for (int i = 0; i < tmp2.length; ++i) {\n                        result[resultOffset + i] = 2 * tmp2[i];\n        }\n    } else {\n                        subtract(tmp1, 0, x, xOffset, tmp2, 0);\n                divide(y, yOffset, tmp2, 0, tmp1, 0);\n                atan(tmp1, 0, tmp2, 0);\n        result[resultOffset] =         ((tmp2[0] <= 0) ? -FastMath.PI : FastMath.PI) - 2 * tmp2[0];\n        for (int i = 1; i < tmp2.length; ++i) {\n                        result[resultOffset + i] = -2 * tmp2[i];\n        }\n    }\n}", "lc": 0.5, "pi": 0.009569377990430419, "ma": 0.2, "nbd": 0.0, "ml": 0.08333333333333333, "d": 3.470238095238095, "mi": -0.4818886539816771, "fo": 0.5, "r": -0.02631578947368421, "e": 5.942831785988024}
{"project_name": "Closure", "project_version": 157, "label": 2, "code": "void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n    int type = n.getType();\n    String opstr = NodeUtil.opToStr(type);\n    int childCount = n.getChildCount();\n    Node first = n.getFirstChild();\n    Node last = n.getLastChild();\n    // Handle all binary operators\n    if (opstr != null && first != last) {\n        Preconditions.checkState(childCount == 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n        int p = NodeUtil.precedence(type);\n        addLeftExpr(first, p, context);\n        cc.addOp(opstr, true);\n        // For right-hand-side of operations, only pass context if it's\n        // the IN_FOR_INIT_CLAUSE one.\n        Context rhsContext = getContextForNoInOperator(context);\n        // we can simply generate a * b * c.\n        if (last.getType() == type && NodeUtil.isAssociative(type)) {\n            addExpr(last, p, rhsContext);\n        } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n            // Assignments are the only right-associative binary operators\n            addExpr(last, p, rhsContext);\n        } else {\n            addExpr(last, p + 1, rhsContext);\n        }\n        return;\n    }\n    cc.startSourceMapping(n);\n    switch(type) {\n        case Token.TRY:\n            {\n                Preconditions.checkState(first.getNext().getType() == Token.BLOCK && !first.getNext().hasMoreThanOneChild());\n                Preconditions.checkState(childCount >= 2 && childCount <= 3);\n                add(\"try\");\n                add(first, Context.PRESERVE_BLOCK);\n                // second child contains the catch block, or nothing if there\n                // isn't a catch block\n                Node catchblock = first.getNext().getFirstChild();\n                if (catchblock != null) {\n                    add(catchblock);\n                }\n                if (childCount == 3) {\n                    add(\"finally\");\n                    add(last, Context.PRESERVE_BLOCK);\n                }\n                break;\n            }\n        case Token.CATCH:\n            Preconditions.checkState(childCount == 2);\n            add(\"catch(\");\n            add(first);\n            add(\")\");\n            add(last, Context.PRESERVE_BLOCK);\n            break;\n        case Token.THROW:\n            Preconditions.checkState(childCount == 1);\n            add(\"throw\");\n            add(first);\n            // Must have a ';' after a throw statement, otherwise safari can't\n            // parse this.\n            cc.endStatement(true);\n            break;\n        case Token.RETURN:\n            add(\"return\");\n            if (childCount == 1) {\n                add(first);\n            } else {\n                Preconditions.checkState(childCount == 0);\n            }\n            cc.endStatement();\n            break;\n        case Token.VAR:\n            if (first != null) {\n                add(\"var \");\n                addList(first, false, getContextForNoInOperator(context));\n            }\n            break;\n        case Token.LABEL_NAME:\n            Preconditions.checkState(!n.getString().isEmpty());\n            addIdentifier(n.getString());\n            break;\n        case Token.NAME:\n            if (first == null || first.getType() == Token.EMPTY) {\n                addIdentifier(n.getString());\n            } else {\n                Preconditions.checkState(childCount == 1);\n                addIdentifier(n.getString());\n                cc.addOp(\"=\", true);\n                if (first.getType() == Token.COMMA) {\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                } else {\n                    // Add expression, consider nearby code at lowest level of\n                    // precedence.\n                    addExpr(first, 0, getContextForNoInOperator(context));\n                }\n            }\n            break;\n        case Token.ARRAYLIT:\n            add(\"[\");\n            addArrayList(first);\n            add(\"]\");\n            break;\n        case Token.LP:\n            add(\"(\");\n            addList(first);\n            add(\")\");\n            break;\n        case Token.COMMA:\n            Preconditions.checkState(childCount == 2);\n            addList(first, false, context);\n            break;\n        case Token.NUMBER:\n            Preconditions.checkState(childCount == ((n.getParent() != null && n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0));\n            cc.addNumber(n.getDouble());\n            break;\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS:\n            {\n                // All of these unary operators are right-associative\n                Preconditions.checkState(childCount == 1);\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                addExpr(first, NodeUtil.precedence(type));\n                break;\n            }\n        case Token.NEG:\n            {\n                Preconditions.checkState(childCount == 1);\n                // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n                if (n.getFirstChild().getType() == Token.NUMBER) {\n                    cc.addNumber(-n.getFirstChild().getDouble());\n                } else {\n                    cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                    addExpr(first, NodeUtil.precedence(type));\n                }\n                break;\n            }\n        case Token.HOOK:\n            {\n                Preconditions.checkState(childCount == 3);\n                int p = NodeUtil.precedence(type);\n                addLeftExpr(first, p + 1, context);\n                cc.addOp(\"?\", true);\n                addExpr(first.getNext(), 1);\n                cc.addOp(\":\", true);\n                addExpr(last, 1);\n                break;\n            }\n        case Token.REGEXP:\n            if (first.getType() != Token.STRING || last.getType() != Token.STRING) {\n                throw new Error(\"Expected children to be strings\");\n            }\n            String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n            // I only use one .add because whitespace matters\n            if (childCount == 2) {\n                add(regexp + last.getString());\n            } else {\n                Preconditions.checkState(childCount == 1);\n                add(regexp);\n            }\n            break;\n        case Token.GET_REF:\n            add(first);\n            break;\n        case Token.REF_SPECIAL:\n            Preconditions.checkState(childCount == 1);\n            add(first);\n            add(\".\");\n            add((String) n.getProp(Node.NAME_PROP));\n            break;\n        case Token.FUNCTION:\n            if (n.getClass() != Node.class) {\n                throw new Error(\"Unexpected Node subclass.\");\n            }\n            Preconditions.checkState(childCount == 3);\n            boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n            if (funcNeedsParens) {\n                add(\"(\");\n            }\n            add(\"function\");\n            add(first);\n            add(first.getNext());\n            add(last, Context.PRESERVE_BLOCK);\n            cc.endFunction(context == Context.STATEMENT);\n            if (funcNeedsParens) {\n                add(\")\");\n            }\n            break;\n        case Token.GET:\n        case Token.SET:\n            Preconditions.checkState(n.getParent().getType() == Token.OBJECTLIT);\n            Preconditions.checkState(childCount == 1);\n            Preconditions.checkState(first.getType() == Token.FUNCTION);\n            // Get methods are unnamed\n            Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n            if (type == Token.GET) {\n                // Get methods have no parameters.\n                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n                add(\"get \");\n            } else {\n                // Set methods have one parameter.\n                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n                add(\"set \");\n            }\n            // The name is on the GET or SET node.\n            String name = n.getString();\n            Node fn = first;\n            Node parameters = fn.getChildAtIndex(1);\n            Node body = fn.getLastChild();\n            // Add the property name.\n            if (TokenStream.isJSIdentifier(name) && // unicode escaped.\n            NodeUtil.isLatin(name)) {\n                add(name);\n            } else {\n                // Determine if the string is a simple number.\n                add(jsString(n.getString(), outputCharsetEncoder));\n            }\n            add(parameters);\n            add(body, Context.PRESERVE_BLOCK);\n            break;\n        case Token.SCRIPT:\n        case Token.BLOCK:\n            {\n                if (n.getClass() != Node.class) {\n                    throw new Error(\"Unexpected Node subclass.\");\n                }\n                boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n                if (preserveBlock) {\n                    cc.beginBlock();\n                }\n                boolean preferLineBreaks = type == Token.SCRIPT || (type == Token.BLOCK && !preserveBlock && n.getParent() != null && n.getParent().getType() == Token.SCRIPT);\n                for (Node c = first; c != null; c = c.getNext()) {\n                    add(c, Context.STATEMENT);\n                    // VAR doesn't include ';' since it gets used in expressions\n                    if (c.getType() == Token.VAR) {\n                        cc.endStatement();\n                    }\n                    if (c.getType() == Token.FUNCTION) {\n                        cc.maybeLineBreak();\n                    }\n                    // because top level statements are more homogeneous.\n                    if (preferLineBreaks) {\n                        cc.notePreferredLineBreak();\n                    }\n                }\n                if (preserveBlock) {\n                    cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n                }\n                break;\n            }\n        case Token.FOR:\n            if (childCount == 4) {\n                add(\"for(\");\n                if (first.getType() == Token.VAR) {\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(first.getNext());\n                add(\";\");\n                add(first.getNext().getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                Preconditions.checkState(childCount == 3);\n                add(\"for(\");\n                add(first);\n                add(\"in\");\n                add(first.getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n        case Token.DO:\n            Preconditions.checkState(childCount == 2);\n            add(\"do\");\n            addNonEmptyStatement(first, Context.OTHER, false);\n            add(\"while(\");\n            add(last);\n            add(\")\");\n            cc.endStatement();\n            break;\n        case Token.WHILE:\n            Preconditions.checkState(childCount == 2);\n            add(\"while(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.EMPTY:\n            Preconditions.checkState(childCount == 0);\n            break;\n        case Token.GETPROP:\n            {\n                Preconditions.checkState(childCount == 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                Preconditions.checkState(last.getType() == Token.STRING, \"Bad GETPROP: RHS should be STRING\");\n                boolean needsParens = (first.getType() == Token.NUMBER);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n                if (needsParens) {\n                    add(\")\");\n                }\n                add(\".\");\n                addIdentifier(last.getString());\n                break;\n            }\n        case Token.GETELEM:\n            Preconditions.checkState(childCount == 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n            addLeftExpr(first, NodeUtil.precedence(type), context);\n            add(\"[\");\n            add(first.getNext());\n            add(\"]\");\n            break;\n        case Token.WITH:\n            Preconditions.checkState(childCount == 2);\n            add(\"with(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.INC:\n        case Token.DEC:\n            {\n                Preconditions.checkState(childCount == 1);\n                String o = type == Token.INC ? \"++\" : \"--\";\n                int postProp = n.getIntProp(Node.INCRDECR_PROP);\n                // is a pre-inc/dec.\n                if (postProp != 0) {\n                    addLeftExpr(first, NodeUtil.precedence(type), context);\n                    cc.addOp(o, false);\n                } else {\n                    cc.addOp(o, false);\n                    add(first);\n                }\n                break;\n            }\n        case Token.CALL:\n            // that must be preserved.\n            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n                add(\"(0,\");\n                addExpr(first, NodeUtil.precedence(Token.COMMA));\n                add(\")\");\n            } else {\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n            }\n            add(\"(\");\n            addList(first.getNext());\n            add(\")\");\n            break;\n        case Token.IF:\n            boolean hasElse = childCount == 3;\n            boolean ambiguousElseClause = context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n            if (ambiguousElseClause) {\n                cc.beginBlock();\n            }\n            add(\"if(\");\n            add(first);\n            add(\")\");\n            if (hasElse) {\n                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                add(\"else\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                Preconditions.checkState(childCount == 2);\n            }\n            if (ambiguousElseClause) {\n                cc.endBlock();\n            }\n            break;\n        case Token.NULL:\n        case Token.THIS:\n        case Token.FALSE:\n        case Token.TRUE:\n            Preconditions.checkState(childCount == 0);\n            add(Node.tokenToName(type));\n            break;\n        case Token.CONTINUE:\n            Preconditions.checkState(childCount <= 1);\n            add(\"continue\");\n            if (childCount == 1) {\n                if (first.getType() != Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.DEBUGGER:\n            Preconditions.checkState(childCount == 0);\n            add(\"debugger\");\n            cc.endStatement();\n            break;\n        case Token.BREAK:\n            Preconditions.checkState(childCount <= 1);\n            add(\"break\");\n            if (childCount == 1) {\n                if (first.getType() != Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.EXPR_VOID:\n            throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n        case Token.EXPR_RESULT:\n            Preconditions.checkState(childCount == 1);\n            add(first, Context.START_OF_EXPR);\n            cc.endStatement();\n            break;\n        case Token.NEW:\n            add(\"new \");\n            int precedence = NodeUtil.precedence(type);\n            // first viable parentheses (don't traverse into functions).\n            if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {\n                precedence = NodeUtil.precedence(first.getType()) + 1;\n            }\n            addExpr(first, precedence);\n            // '()' is optional when no arguments are present\n            Node next = first.getNext();\n            if (next != null) {\n                add(\"(\");\n                addList(next);\n                add(\")\");\n            }\n            break;\n        case Token.STRING:\n            if (childCount != ((n.getParent() != null && n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0)) {\n                throw new IllegalStateException(\"Unexpected String children: \" + n.getParent().toStringTree());\n            }\n            add(jsString(n.getString(), outputCharsetEncoder));\n            break;\n        case Token.DELPROP:\n            Preconditions.checkState(childCount == 1);\n            add(\"delete \");\n            add(first);\n            break;\n        case Token.OBJECTLIT:\n            {\n                boolean needsParens = (context == Context.START_OF_EXPR);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                add(\"{\");\n                for (Node c = first; c != null; c = c.getNext()) {\n                    if (c != first) {\n                        cc.listSeparator();\n                    }\n                    if (c.getType() == Token.GET || c.getType() == Token.SET) {\n                        add(c);\n                    } else {\n                        // are not JavaScript keywords\n                        if (c.getType() == Token.STRING && !c.isQuotedString() && !TokenStream.isKeyword(c.getString()) && TokenStream.isJSIdentifier(c.getString()) && // were unicode escaped.\n                        NodeUtil.isLatin(c.getString())) {\n                            add(c.getString());\n                        } else {\n                            // Determine if the string is a simple number.\n                            addExpr(c, 1);\n                        }\n                        add(\":\");\n                        addExpr(c.getFirstChild(), 1);\n                    }\n                }\n                add(\"}\");\n                if (needsParens) {\n                    add(\")\");\n                }\n                break;\n            }\n        case Token.SWITCH:\n            add(\"switch(\");\n            add(first);\n            add(\")\");\n            cc.beginBlock();\n            addAllSiblings(first.getNext());\n            cc.endBlock(context == Context.STATEMENT);\n            break;\n        case Token.CASE:\n            Preconditions.checkState(childCount == 2);\n            add(\"case \");\n            add(first);\n            addCaseBody(last);\n            break;\n        case Token.DEFAULT:\n            Preconditions.checkState(childCount == 1);\n            add(\"default\");\n            addCaseBody(first);\n            break;\n        case Token.LABEL:\n            Preconditions.checkState(childCount == 2);\n            if (first.getType() != Token.LABEL_NAME) {\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n            }\n            add(first);\n            add(\":\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n            break;\n        // ignored for our purposes.\n        case Token.SETNAME:\n            break;\n        default:\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n    cc.endSourceMapping(n);\n}", "code_comment": NaN, "code_no_comment": "void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n    int type = n.getType();\n    String opstr = NodeUtil.opToStr(type);\n    int childCount = n.getChildCount();\n    Node first = n.getFirstChild();\n    Node last = n.getLastChild();\n        if (opstr != null && first != last) {\n        Preconditions.checkState(childCount == 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n        int p = NodeUtil.precedence(type);\n        addLeftExpr(first, p, context);\n        cc.addOp(opstr, true);\n                        Context rhsContext = getContextForNoInOperator(context);\n                if (last.getType() == type && NodeUtil.isAssociative(type)) {\n            addExpr(last, p, rhsContext);\n        } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n                        addExpr(last, p, rhsContext);\n        } else {\n            addExpr(last, p + 1, rhsContext);\n        }\n        return;\n    }\n    cc.startSourceMapping(n);\n    switch(type) {\n        case Token.TRY:\n            {\n                Preconditions.checkState(first.getNext().getType() == Token.BLOCK && !first.getNext().hasMoreThanOneChild());\n                Preconditions.checkState(childCount >= 2 && childCount <= 3);\n                add(\"try\");\n                add(first, Context.PRESERVE_BLOCK);\n                                                Node catchblock = first.getNext().getFirstChild();\n                if (catchblock != null) {\n                    add(catchblock);\n                }\n                if (childCount == 3) {\n                    add(\"finally\");\n                    add(last, Context.PRESERVE_BLOCK);\n                }\n                break;\n            }\n        case Token.CATCH:\n            Preconditions.checkState(childCount == 2);\n            add(\"catch(\");\n            add(first);\n            add(\")\");\n            add(last, Context.PRESERVE_BLOCK);\n            break;\n        case Token.THROW:\n            Preconditions.checkState(childCount == 1);\n            add(\"throw\");\n            add(first);\n                                    cc.endStatement(true);\n            break;\n        case Token.RETURN:\n            add(\"return\");\n            if (childCount == 1) {\n                add(first);\n            } else {\n                Preconditions.checkState(childCount == 0);\n            }\n            cc.endStatement();\n            break;\n        case Token.VAR:\n            if (first != null) {\n                add(\"var \");\n                addList(first, false, getContextForNoInOperator(context));\n            }\n            break;\n        case Token.LABEL_NAME:\n            Preconditions.checkState(!n.getString().isEmpty());\n            addIdentifier(n.getString());\n            break;\n        case Token.NAME:\n            if (first == null || first.getType() == Token.EMPTY) {\n                addIdentifier(n.getString());\n            } else {\n                Preconditions.checkState(childCount == 1);\n                addIdentifier(n.getString());\n                cc.addOp(\"=\", true);\n                if (first.getType() == Token.COMMA) {\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                } else {\n                                                            addExpr(first, 0, getContextForNoInOperator(context));\n                }\n            }\n            break;\n        case Token.ARRAYLIT:\n            add(\"[\");\n            addArrayList(first);\n            add(\"]\");\n            break;\n        case Token.LP:\n            add(\"(\");\n            addList(first);\n            add(\")\");\n            break;\n        case Token.COMMA:\n            Preconditions.checkState(childCount == 2);\n            addList(first, false, context);\n            break;\n        case Token.NUMBER:\n            Preconditions.checkState(childCount == ((n.getParent() != null && n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0));\n            cc.addNumber(n.getDouble());\n            break;\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS:\n            {\n                                Preconditions.checkState(childCount == 1);\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                addExpr(first, NodeUtil.precedence(type));\n                break;\n            }\n        case Token.NEG:\n            {\n                Preconditions.checkState(childCount == 1);\n                                if (n.getFirstChild().getType() == Token.NUMBER) {\n                    cc.addNumber(-n.getFirstChild().getDouble());\n                } else {\n                    cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                    addExpr(first, NodeUtil.precedence(type));\n                }\n                break;\n            }\n        case Token.HOOK:\n            {\n                Preconditions.checkState(childCount == 3);\n                int p = NodeUtil.precedence(type);\n                addLeftExpr(first, p + 1, context);\n                cc.addOp(\"?\", true);\n                addExpr(first.getNext(), 1);\n                cc.addOp(\":\", true);\n                addExpr(last, 1);\n                break;\n            }\n        case Token.REGEXP:\n            if (first.getType() != Token.STRING || last.getType() != Token.STRING) {\n                throw new Error(\"Expected children to be strings\");\n            }\n            String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n                        if (childCount == 2) {\n                add(regexp + last.getString());\n            } else {\n                Preconditions.checkState(childCount == 1);\n                add(regexp);\n            }\n            break;\n        case Token.GET_REF:\n            add(first);\n            break;\n        case Token.REF_SPECIAL:\n            Preconditions.checkState(childCount == 1);\n            add(first);\n            add(\".\");\n            add((String) n.getProp(Node.NAME_PROP));\n            break;\n        case Token.FUNCTION:\n            if (n.getClass() != Node.class) {\n                throw new Error(\"Unexpected Node subclass.\");\n            }\n            Preconditions.checkState(childCount == 3);\n            boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n            if (funcNeedsParens) {\n                add(\"(\");\n            }\n            add(\"function\");\n            add(first);\n            add(first.getNext());\n            add(last, Context.PRESERVE_BLOCK);\n            cc.endFunction(context == Context.STATEMENT);\n            if (funcNeedsParens) {\n                add(\")\");\n            }\n            break;\n        case Token.GET:\n        case Token.SET:\n            Preconditions.checkState(n.getParent().getType() == Token.OBJECTLIT);\n            Preconditions.checkState(childCount == 1);\n            Preconditions.checkState(first.getType() == Token.FUNCTION);\n                        Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n            if (type == Token.GET) {\n                                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n                add(\"get \");\n            } else {\n                                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n                add(\"set \");\n            }\n                        String name = n.getString();\n            Node fn = first;\n            Node parameters = fn.getChildAtIndex(1);\n            Node body = fn.getLastChild();\n                        if (TokenStream.isJSIdentifier(name) &&             NodeUtil.isLatin(name)) {\n                add(name);\n            } else {\n                                add(jsString(n.getString(), outputCharsetEncoder));\n            }\n            add(parameters);\n            add(body, Context.PRESERVE_BLOCK);\n            break;\n        case Token.SCRIPT:\n        case Token.BLOCK:\n            {\n                if (n.getClass() != Node.class) {\n                    throw new Error(\"Unexpected Node subclass.\");\n                }\n                boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n                if (preserveBlock) {\n                    cc.beginBlock();\n                }\n                boolean preferLineBreaks = type == Token.SCRIPT || (type == Token.BLOCK && !preserveBlock && n.getParent() != null && n.getParent().getType() == Token.SCRIPT);\n                for (Node c = first; c != null; c = c.getNext()) {\n                    add(c, Context.STATEMENT);\n                                        if (c.getType() == Token.VAR) {\n                        cc.endStatement();\n                    }\n                    if (c.getType() == Token.FUNCTION) {\n                        cc.maybeLineBreak();\n                    }\n                                        if (preferLineBreaks) {\n                        cc.notePreferredLineBreak();\n                    }\n                }\n                if (preserveBlock) {\n                    cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n                }\n                break;\n            }\n        case Token.FOR:\n            if (childCount == 4) {\n                add(\"for(\");\n                if (first.getType() == Token.VAR) {\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(first.getNext());\n                add(\";\");\n                add(first.getNext().getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                Preconditions.checkState(childCount == 3);\n                add(\"for(\");\n                add(first);\n                add(\"in\");\n                add(first.getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n        case Token.DO:\n            Preconditions.checkState(childCount == 2);\n            add(\"do\");\n            addNonEmptyStatement(first, Context.OTHER, false);\n            add(\"while(\");\n            add(last);\n            add(\")\");\n            cc.endStatement();\n            break;\n        case Token.WHILE:\n            Preconditions.checkState(childCount == 2);\n            add(\"while(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.EMPTY:\n            Preconditions.checkState(childCount == 0);\n            break;\n        case Token.GETPROP:\n            {\n                Preconditions.checkState(childCount == 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                Preconditions.checkState(last.getType() == Token.STRING, \"Bad GETPROP: RHS should be STRING\");\n                boolean needsParens = (first.getType() == Token.NUMBER);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n                if (needsParens) {\n                    add(\")\");\n                }\n                add(\".\");\n                addIdentifier(last.getString());\n                break;\n            }\n        case Token.GETELEM:\n            Preconditions.checkState(childCount == 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n            addLeftExpr(first, NodeUtil.precedence(type), context);\n            add(\"[\");\n            add(first.getNext());\n            add(\"]\");\n            break;\n        case Token.WITH:\n            Preconditions.checkState(childCount == 2);\n            add(\"with(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.INC:\n        case Token.DEC:\n            {\n                Preconditions.checkState(childCount == 1);\n                String o = type == Token.INC ? \"++\" : \"--\";\n                int postProp = n.getIntProp(Node.INCRDECR_PROP);\n                                if (postProp != 0) {\n                    addLeftExpr(first, NodeUtil.precedence(type), context);\n                    cc.addOp(o, false);\n                } else {\n                    cc.addOp(o, false);\n                    add(first);\n                }\n                break;\n            }\n        case Token.CALL:\n                        if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n                add(\"(0,\");\n                addExpr(first, NodeUtil.precedence(Token.COMMA));\n                add(\")\");\n            } else {\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n            }\n            add(\"(\");\n            addList(first.getNext());\n            add(\")\");\n            break;\n        case Token.IF:\n            boolean hasElse = childCount == 3;\n            boolean ambiguousElseClause = context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n            if (ambiguousElseClause) {\n                cc.beginBlock();\n            }\n            add(\"if(\");\n            add(first);\n            add(\")\");\n            if (hasElse) {\n                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                add(\"else\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                Preconditions.checkState(childCount == 2);\n            }\n            if (ambiguousElseClause) {\n                cc.endBlock();\n            }\n            break;\n        case Token.NULL:\n        case Token.THIS:\n        case Token.FALSE:\n        case Token.TRUE:\n            Preconditions.checkState(childCount == 0);\n            add(Node.tokenToName(type));\n            break;\n        case Token.CONTINUE:\n            Preconditions.checkState(childCount <= 1);\n            add(\"continue\");\n            if (childCount == 1) {\n                if (first.getType() != Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.DEBUGGER:\n            Preconditions.checkState(childCount == 0);\n            add(\"debugger\");\n            cc.endStatement();\n            break;\n        case Token.BREAK:\n            Preconditions.checkState(childCount <= 1);\n            add(\"break\");\n            if (childCount == 1) {\n                if (first.getType() != Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.EXPR_VOID:\n            throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n        case Token.EXPR_RESULT:\n            Preconditions.checkState(childCount == 1);\n            add(first, Context.START_OF_EXPR);\n            cc.endStatement();\n            break;\n        case Token.NEW:\n            add(\"new \");\n            int precedence = NodeUtil.precedence(type);\n                        if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {\n                precedence = NodeUtil.precedence(first.getType()) + 1;\n            }\n            addExpr(first, precedence);\n                        Node next = first.getNext();\n            if (next != null) {\n                add(\"(\");\n                addList(next);\n                add(\")\");\n            }\n            break;\n        case Token.STRING:\n            if (childCount != ((n.getParent() != null && n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0)) {\n                throw new IllegalStateException(\"Unexpected String children: \" + n.getParent().toStringTree());\n            }\n            add(jsString(n.getString(), outputCharsetEncoder));\n            break;\n        case Token.DELPROP:\n            Preconditions.checkState(childCount == 1);\n            add(\"delete \");\n            add(first);\n            break;\n        case Token.OBJECTLIT:\n            {\n                boolean needsParens = (context == Context.START_OF_EXPR);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                add(\"{\");\n                for (Node c = first; c != null; c = c.getNext()) {\n                    if (c != first) {\n                        cc.listSeparator();\n                    }\n                    if (c.getType() == Token.GET || c.getType() == Token.SET) {\n                        add(c);\n                    } else {\n                                                if (c.getType() == Token.STRING && !c.isQuotedString() && !TokenStream.isKeyword(c.getString()) && TokenStream.isJSIdentifier(c.getString()) &&                         NodeUtil.isLatin(c.getString())) {\n                            add(c.getString());\n                        } else {\n                                                        addExpr(c, 1);\n                        }\n                        add(\":\");\n                        addExpr(c.getFirstChild(), 1);\n                    }\n                }\n                add(\"}\");\n                if (needsParens) {\n                    add(\")\");\n                }\n                break;\n            }\n        case Token.SWITCH:\n            add(\"switch(\");\n            add(first);\n            add(\")\");\n            cc.beginBlock();\n            addAllSiblings(first.getNext());\n            cc.endBlock(context == Context.STATEMENT);\n            break;\n        case Token.CASE:\n            Preconditions.checkState(childCount == 2);\n            add(\"case \");\n            add(first);\n            addCaseBody(last);\n            break;\n        case Token.DEFAULT:\n            Preconditions.checkState(childCount == 1);\n            add(\"default\");\n            addCaseBody(first);\n            break;\n        case Token.LABEL:\n            Preconditions.checkState(childCount == 2);\n            if (first.getType() != Token.LABEL_NAME) {\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n            }\n            add(first);\n            add(\":\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n            break;\n                case Token.SETNAME:\n            break;\n        default:\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n    cc.endSourceMapping(n);\n}", "lc": 21.454545454545453, "pi": 0.5071770334928228, "ma": 31.4, "nbd": 1.5, "ml": 13.0, "d": 4.962301587301588, "mi": -3.247780126849894, "fo": 28.666666666666668, "r": -0.02631578947368421, "e": 129.28478414965164}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-373_bfe4623c", "label": 1, "code": "/**\n * {@inheritDoc}\n */\n@Override\npublic void increment(final double d) {\n    if (n == 0) {\n        value = d;\n    } else {\n        value *= d;\n    }\n    n++;\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "@Override\npublic void increment(final double d) {\n    if (n == 0) {\n        value = d;\n    } else {\n        value *= d;\n    }\n    n++;\n}", "lc": -0.22727272727272727, "pi": -0.01913875598086126, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": 0.25793650793650796, "mi": 0.38238195912614503, "fo": -0.5, "r": 2.5789473684210527, "e": -0.08760337246359272}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5398_19e7c1cd", "label": 3, "code": "/**\n *  Parse the given string.\n *  <p>\n *  Note: xml character encoding is NOT applied. It is assumed the input provided does have the\n *  correct encoding already.\n *\n *  @param string\n *             The input string\n *  @throws IOException\n *              Error while reading the resource\n */\n@Override\npublic void parse(final CharSequence string) throws IOException {\n    parse(new ByteArrayInputStream(string.toString().getBytes()), null);\n}", "code_comment": "/**\n *  Parse the given string.\n *  <p>\n *  Note: xml character encoding is NOT applied. It is assumed the input provided does have the\n *  correct encoding already.\n *\n *  @param string\n *             The input string\n *  @throws IOException\n *              Error while reading the resource\n */\n", "code_no_comment": "@Override\npublic void parse(final CharSequence string) throws IOException {\n    parse(new ByteArrayInputStream(string.toString().getBytes()), null);\n}", "lc": -0.45454545454545453, "pi": -0.6028708133971293, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.7978858350951374, "fo": -0.25, "r": 2.552631578947368, "e": -0.16279340490885932}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-763_97203de8", "label": 1, "code": "/**\n * Returns the object formatted using its toString method.\n * @return the String representation of the object.\n */\n@Override\npublic String getFormat() {\n    return obj.toString();\n}", "code_comment": "/**\n * Returns the object formatted using its toString method.\n * @return the String representation of the object.\n */\n", "code_no_comment": "@Override\npublic String getFormat() {\n    return obj.toString();\n}", "lc": -0.45454545454545453, "pi": -0.6028708133971293, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.9362931642001409, "fo": -0.4166666666666667, "r": 2.526315789473684, "e": -0.16279340490885932}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-1067_aff82362", "label": 1, "code": "/**\n * Returns the regularized beta function I(x, a, b).\n *\n * The implementation of this method is based on:\n * <ul>\n * <li>\n * <a href=\"http://mathworld.wolfram.com/RegularizedBetaFunction.html\">\n * Regularized Beta Function</a>.</li>\n * <li>\n * <a href=\"http://functions.wolfram.com/06.21.10.0001.01\">\n * Regularized Beta Function</a>.</li>\n * </ul>\n *\n * @param x the value.\n * @param a Parameter {@code a}.\n * @param b Parameter {@code b}.\n * @param epsilon When the absolute value of the nth item in the\n * series is less than epsilon the approximation ceases to calculate\n * further elements in the series.\n * @param maxIterations Maximum number of \"iterations\" to complete.\n * @return the regularized beta function I(x, a, b)\n * @throws org.apache.commons.math3.exception.MaxCountExceededException\n * if the algorithm fails to converge.\n */\npublic static double regularizedBeta(double x, final double a, final double b, double epsilon, int maxIterations) {\n    double ret;\n    if (Double.isNaN(x) || Double.isNaN(a) || Double.isNaN(b) || x < 0 || x > 1 || a <= 0.0 || b <= 0.0) {\n        ret = Double.NaN;\n    } else if (x > (a + 1.0) / (a + b + 2.0)) {\n        ret = 1.0 - regularizedBeta(1.0 - x, b, a, epsilon, maxIterations);\n    } else {\n        ContinuedFraction fraction = new ContinuedFraction() {\n\n            @Override\n            protected double getB(int n, double x) {\n                double ret;\n                double m;\n                if (n % 2 == 0) {\n                    // even\n                    m = n / 2.0;\n                    ret = (m * (b - m) * x) / ((a + (2 * m) - 1) * (a + (2 * m)));\n                } else {\n                    m = (n - 1.0) / 2.0;\n                    ret = -((a + m) * (a + b + m) * x) / ((a + (2 * m)) * (a + (2 * m) + 1.0));\n                }\n                return ret;\n            }\n\n            @Override\n            protected double getA(int n, double x) {\n                return 1.0;\n            }\n        };\n        ret = FastMath.exp((a * FastMath.log(x)) + (b * FastMath.log1p(-x)) - FastMath.log(a) - logBeta(a, b)) * 1.0 / fraction.evaluate(x, epsilon, maxIterations);\n    }\n    return ret;\n}", "code_comment": "/**\n * Returns the regularized beta function I(x, a, b).\n *\n * The implementation of this method is based on:\n * <ul>\n * <li>\n * <a href=\"http://mathworld.wolfram.com/RegularizedBetaFunction.html\">\n * Regularized Beta Function</a>.</li>\n * <li>\n * <a href=\"http://functions.wolfram.com/06.21.10.0001.01\">\n * Regularized Beta Function</a>.</li>\n * </ul>\n *\n * @param x the value.\n * @param a Parameter {@code a}.\n * @param b Parameter {@code b}.\n * @param epsilon When the absolute value of the nth item in the\n * series is less than epsilon the approximation ceases to calculate\n * further elements in the series.\n * @param maxIterations Maximum number of \"iterations\" to complete.\n * @return the regularized beta function I(x, a, b)\n * @throws org.apache.commons.math3.exception.MaxCountExceededException\n * if the algorithm fails to converge.\n */\n", "code_no_comment": "public static double regularizedBeta(double x, final double a, final double b, double epsilon, int maxIterations) {\n    double ret;\n    if (Double.isNaN(x) || Double.isNaN(a) || Double.isNaN(b) || x < 0 || x > 1 || a <= 0.0 || b <= 0.0) {\n        ret = Double.NaN;\n    } else if (x > (a + 1.0) / (a + b + 2.0)) {\n        ret = 1.0 - regularizedBeta(1.0 - x, b, a, epsilon, maxIterations);\n    } else {\n        ContinuedFraction fraction = new ContinuedFraction() {\n\n            @Override\n            protected double getB(int n, double x) {\n                double ret;\n                double m;\n                if (n % 2 == 0) {\n                                        m = n / 2.0;\n                    ret = (m * (b - m) * x) / ((a + (2 * m) - 1) * (a + (2 * m)));\n                } else {\n                    m = (n - 1.0) / 2.0;\n                    ret = -((a + m) * (a + b + m) * x) / ((a + (2 * m)) * (a + (2 * m) + 1.0));\n                }\n                return ret;\n            }\n\n            @Override\n            protected double getA(int n, double x) {\n                return 1.0;\n            }\n        };\n        ret = FastMath.exp((a * FastMath.log(x)) + (b * FastMath.log1p(-x)) - FastMath.log(a) - logBeta(a, b)) * 1.0 / fraction.evaluate(x, epsilon, maxIterations);\n    }\n    return ret;\n}", "lc": 0.7272727272727273, "pi": 1.449760765550239, "ma": 0.0, "nbd": 1.0, "ml": 0.9166666666666666, "d": 3.537698412698413, "mi": -0.6019732205778717, "fo": 0.3333333333333333, "r": -0.02631578947368421, "e": 8.192437890077972}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-4138_eb0f9b41", "label": 1, "code": "@Override\npublic Options getOptions() {\n    final Options o = new Options();\n    scanOptAuths = new Option(\"s\", \"scan-authorizations\", true, \"scan authorizations (all user auths are used if this argument is not specified)\");\n    optStartRowExclusive = new Option(\"be\", \"begin-exclusive\", false, \"make start row exclusive (by default it's inclusive)\");\n    optStartRowExclusive.setArgName(\"begin-exclusive\");\n    optEndRowExclusive = new Option(\"ee\", \"end-exclusive\", false, \"make end row exclusive (by default it's inclusive)\");\n    optEndRowExclusive.setArgName(\"end-exclusive\");\n    scanOptRow = new Option(\"r\", \"row\", true, \"row to scan\");\n    scanOptColumns = new Option(\"c\", \"columns\", true, \"comma-separated columns\");\n    timestampOpt = new Option(\"st\", \"show-timestamps\", false, \"display timestamps\");\n    disablePaginationOpt = new Option(\"np\", \"no-pagination\", false, \"disable pagination of output\");\n    showFewOpt = new Option(\"f\", \"show-few\", true, \"show only a specified number of characters\");\n    formatterOpt = new Option(\"fm\", \"formatter\", true, \"fully qualified name of the formatter class to use\");\n    interpreterOpt = new Option(\"i\", \"interpreter\", true, \"fully qualified name of the interpreter class to use\");\n    formatterInterpeterOpt = new Option(\"fi\", \"fmt-interpreter\", true, \"fully qualified name of a class that is a formatter and interpreter\");\n    timeoutOption = new Option(null, \"timeout\", true, \"time before scan should fail if no data is returned. If no unit is given assumes seconds.  Units d,h,m,s,and ms are supported.  e.g. 30s or 100ms\");\n    outputFileOpt = new Option(\"o\", \"output\", true, \"local file to write the scan output to\");\n    scanOptAuths.setArgName(\"comma-separated-authorizations\");\n    scanOptRow.setArgName(\"row\");\n    scanOptColumns.setArgName(\"<columnfamily>[:<columnqualifier>]{,<columnfamily>[:<columnqualifier>]}\");\n    showFewOpt.setRequired(false);\n    showFewOpt.setArgName(\"int\");\n    formatterOpt.setArgName(\"className\");\n    timeoutOption.setArgName(\"timeout\");\n    outputFileOpt.setArgName(\"file\");\n    profileOpt = new Option(\"pn\", \"profile\", true, \"iterator profile name\");\n    profileOpt.setArgName(\"profile\");\n    o.addOption(scanOptAuths);\n    o.addOption(scanOptRow);\n    o.addOption(OptUtil.startRowOpt());\n    o.addOption(OptUtil.endRowOpt());\n    o.addOption(optStartRowExclusive);\n    o.addOption(optEndRowExclusive);\n    o.addOption(scanOptColumns);\n    o.addOption(timestampOpt);\n    o.addOption(disablePaginationOpt);\n    o.addOption(OptUtil.tableOpt(\"table to be scanned\"));\n    o.addOption(showFewOpt);\n    o.addOption(formatterOpt);\n    o.addOption(interpreterOpt);\n    o.addOption(formatterInterpeterOpt);\n    o.addOption(timeoutOption);\n    o.addOption(outputFileOpt);\n    o.addOption(profileOpt);\n    return o;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic Options getOptions() {\n    final Options o = new Options();\n    scanOptAuths = new Option(\"s\", \"scan-authorizations\", true, \"scan authorizations (all user auths are used if this argument is not specified)\");\n    optStartRowExclusive = new Option(\"be\", \"begin-exclusive\", false, \"make start row exclusive (by default it's inclusive)\");\n    optStartRowExclusive.setArgName(\"begin-exclusive\");\n    optEndRowExclusive = new Option(\"ee\", \"end-exclusive\", false, \"make end row exclusive (by default it's inclusive)\");\n    optEndRowExclusive.setArgName(\"end-exclusive\");\n    scanOptRow = new Option(\"r\", \"row\", true, \"row to scan\");\n    scanOptColumns = new Option(\"c\", \"columns\", true, \"comma-separated columns\");\n    timestampOpt = new Option(\"st\", \"show-timestamps\", false, \"display timestamps\");\n    disablePaginationOpt = new Option(\"np\", \"no-pagination\", false, \"disable pagination of output\");\n    showFewOpt = new Option(\"f\", \"show-few\", true, \"show only a specified number of characters\");\n    formatterOpt = new Option(\"fm\", \"formatter\", true, \"fully qualified name of the formatter class to use\");\n    interpreterOpt = new Option(\"i\", \"interpreter\", true, \"fully qualified name of the interpreter class to use\");\n    formatterInterpeterOpt = new Option(\"fi\", \"fmt-interpreter\", true, \"fully qualified name of a class that is a formatter and interpreter\");\n    timeoutOption = new Option(null, \"timeout\", true, \"time before scan should fail if no data is returned. If no unit is given assumes seconds.  Units d,h,m,s,and ms are supported.  e.g. 30s or 100ms\");\n    outputFileOpt = new Option(\"o\", \"output\", true, \"local file to write the scan output to\");\n    scanOptAuths.setArgName(\"comma-separated-authorizations\");\n    scanOptRow.setArgName(\"row\");\n    scanOptColumns.setArgName(\"<columnfamily>[:<columnqualifier>]{,<columnfamily>[:<columnqualifier>]}\");\n    showFewOpt.setRequired(false);\n    showFewOpt.setArgName(\"int\");\n    formatterOpt.setArgName(\"className\");\n    timeoutOption.setArgName(\"timeout\");\n    outputFileOpt.setArgName(\"file\");\n    profileOpt = new Option(\"pn\", \"profile\", true, \"iterator profile name\");\n    profileOpt.setArgName(\"profile\");\n    o.addOption(scanOptAuths);\n    o.addOption(scanOptRow);\n    o.addOption(OptUtil.startRowOpt());\n    o.addOption(OptUtil.endRowOpt());\n    o.addOption(optStartRowExclusive);\n    o.addOption(optEndRowExclusive);\n    o.addOption(scanOptColumns);\n    o.addOption(timestampOpt);\n    o.addOption(disablePaginationOpt);\n    o.addOption(OptUtil.tableOpt(\"table to be scanned\"));\n    o.addOption(showFewOpt);\n    o.addOption(formatterOpt);\n    o.addOption(interpreterOpt);\n    o.addOption(formatterInterpeterOpt);\n    o.addOption(timeoutOption);\n    o.addOption(outputFileOpt);\n    o.addOption(profileOpt);\n    return o;\n}", "lc": 1.5, "pi": -0.9617224880382776, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": -0.8291754756871031, "fo": 2.0833333333333335, "r": -0.02631578947368421, "e": -0.16279340490885932}
{"project_name": "Compress", "project_version": 47, "label": 1, "code": "/**\n * Whether this class is able to read the given entry.\n *\n * <p>May return false if it is set up to use encryption or a\n * compression method that hasn't been implemented yet.</p>\n * @since 1.1\n */\n@Override\npublic boolean canReadEntryData(final ArchiveEntry ae) {\n    if (ae instanceof ZipArchiveEntry) {\n        final ZipArchiveEntry ze = (ZipArchiveEntry) ae;\n        return ZipUtil.canHandleEntryData(ze) && supportsDataDescriptorFor(ze);\n    }\n    return false;\n}", "code_comment": "/**\n * Whether this class is able to read the given entry.\n *\n * <p>May return false if it is set up to use encryption or a\n * compression method that hasn't been implemented yet.</p>\n * @since 1.1\n */\n", "code_no_comment": "@Override\npublic boolean canReadEntryData(final ArchiveEntry ae) {\n    if (ae instanceof ZipArchiveEntry) {\n        final ZipArchiveEntry ze = (ZipArchiveEntry) ae;\n        return ZipUtil.canHandleEntryData(ze) && supportsDataDescriptorFor(ze);\n    }\n    return false;\n}", "lc": -0.2727272727272727, "pi": 0.06220095693779899, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": -0.05753968253968254, "mi": 0.3916842847075403, "fo": -0.3333333333333333, "r": 2.4736842105263155, "e": -0.11269745221094608}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-5707_3f70d612", "label": 3, "code": "@Override\npublic boolean onExchangeCompleted(Exchange exchange) {\n    if (exchange.getExchangeId().equals(id)) {\n        done.set(false);\n    }\n    return true;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean onExchangeCompleted(Exchange exchange) {\n    if (exchange.getExchangeId().equals(id)) {\n        done.set(false);\n    }\n    return true;\n}", "lc": -0.3181818181818182, "pi": -0.0909090909090911, "ma": -0.4, "nbd": -0.5, "ml": -0.16666666666666666, "d": -0.3650793650793651, "mi": 0.5128964059196618, "fo": -0.25, "r": 1.0526315789473684, "e": -0.16279340490885932}
{"project_name": "Closure", "project_version": 54, "label": 2, "code": "/**\n * Declare the symbol for a qualified name in the global scope.\n *\n * @param info The doc info for this property.\n * @param n A top-level GETPROP node (it should not be contained inside\n *     another GETPROP).\n * @param parent The parent of {@code n}.\n * @param rhsValue The node that {@code n} is being initialized to,\n *     or {@code null} if this is a stub declaration.\n */\nvoid maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n    Node ownerNode = n.getFirstChild();\n    String ownerName = ownerNode.getQualifiedName();\n    String qName = n.getQualifiedName();\n    String propName = n.getLastChild().getString();\n    Preconditions.checkArgument(qName != null && ownerName != null);\n    // Precedence of type information on GETPROPs:\n    // 1) @type annnotation / @enum annotation\n    // 2) ASSIGN to FUNCTION literal\n    // 3) @param/@return annotation (with no function literal)\n    // 4) ASSIGN to something marked @const\n    // 5) ASSIGN to anything else\n    // \n    // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n    // the function has jsdoc or has not been declared before.\n    // \n    // FUNCTION literals are special because TypedScopeCreator is very smart\n    // about getting as much type information as possible for them.\n    // Determining type for #1 + #2 + #3 + #4\n    JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n    if (valueType == null && rhsValue != null) {\n        // Determining type for #5\n        valueType = rhsValue.getJSType();\n    }\n    // allow F.prototype to be redefined arbitrarily.\n    if (\"prototype\".equals(propName)) {\n        Var qVar = scope.getVar(qName);\n        if (qVar != null) {\n            // the @extends tag.\n            if (!qVar.isTypeInferred()) {\n                // what props are going to be on that prototype.\n                return;\n            }\n            if (qVar.getScope() == scope) {\n                scope.undeclare(qVar);\n            }\n        }\n    }\n    if (valueType == null) {\n        if (parent.getType() == Token.EXPR_RESULT) {\n            stubDeclarations.add(new StubDeclaration(n, t.getInput() != null && t.getInput().isExtern(), ownerName));\n        }\n        return;\n    }\n    boolean inferred = true;\n    if (info != null) {\n        // Determining declaration for #1 + #3 + #4\n        inferred = !(info.hasType() || info.hasEnumParameterType() || (info.isConstant() && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (inferred) {\n        // Determining declaration for #2\n        inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && (info != null || !scope.isDeclared(qName, false)));\n    }\n    if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n            // Only declare this as an official property if it has not been\n            // declared yet.\n            boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) && ((isExtern && !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {\n                // If the property is undeclared or inferred, declare it now.\n                ownerType.defineDeclaredProperty(propName, valueType, n);\n            }\n        }\n        // If the property is already declared, the error will be\n        // caught when we try to declare it in the current scope.\n        defineSlot(n, parent, valueType, inferred);\n    } else if (rhsValue != null && rhsValue.getType() == Token.TRUE) {\n        // We declare these for delegate proxy method properties.\n        FunctionType ownerType = JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n        if (ownerType != null) {\n            JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n            String delegateName = codingConvention.getDelegateSuperclassName();\n            JSType delegateType = delegateName == null ? null : typeRegistry.getType(delegateName);\n            if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) {\n                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n            }\n        }\n    }\n}", "code_comment": "/**\n * Declare the symbol for a qualified name in the global scope.\n *\n * @param info The doc info for this property.\n * @param n A top-level GETPROP node (it should not be contained inside\n *     another GETPROP).\n * @param parent The parent of {@code n}.\n * @param rhsValue The node that {@code n} is being initialized to,\n *     or {@code null} if this is a stub declaration.\n */\n", "code_no_comment": "void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n    Node ownerNode = n.getFirstChild();\n    String ownerName = ownerNode.getQualifiedName();\n    String qName = n.getQualifiedName();\n    String propName = n.getLastChild().getString();\n    Preconditions.checkArgument(qName != null && ownerName != null);\n                                                        JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n    if (valueType == null && rhsValue != null) {\n                valueType = rhsValue.getJSType();\n    }\n        if (\"prototype\".equals(propName)) {\n        Var qVar = scope.getVar(qName);\n        if (qVar != null) {\n                        if (!qVar.isTypeInferred()) {\n                                return;\n            }\n            if (qVar.getScope() == scope) {\n                scope.undeclare(qVar);\n            }\n        }\n    }\n    if (valueType == null) {\n        if (parent.getType() == Token.EXPR_RESULT) {\n            stubDeclarations.add(new StubDeclaration(n, t.getInput() != null && t.getInput().isExtern(), ownerName));\n        }\n        return;\n    }\n    boolean inferred = true;\n    if (info != null) {\n                inferred = !(info.hasType() || info.hasEnumParameterType() || (info.isConstant() && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (inferred) {\n                inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && (info != null || !scope.isDeclared(qName, false)));\n    }\n    if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n                                    boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) && ((isExtern && !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {\n                                ownerType.defineDeclaredProperty(propName, valueType, n);\n            }\n        }\n                        defineSlot(n, parent, valueType, inferred);\n    } else if (rhsValue != null && rhsValue.getType() == Token.TRUE) {\n                FunctionType ownerType = JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n        if (ownerType != null) {\n            JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n            String delegateName = codingConvention.getDelegateSuperclassName();\n            JSType delegateType = delegateName == null ? null : typeRegistry.getType(delegateName);\n            if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) {\n                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n            }\n        }\n    }\n}", "lc": 1.8636363636363635, "pi": 0.5167464114832536, "ma": 2.6, "nbd": 1.0, "ml": 3.25, "d": 1.126984126984127, "mi": -1.0465116279069764, "fo": 3.25, "r": -0.02631578947368421, "e": 5.472853742731511}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-5140_8898d491", "label": 3, "code": "public boolean process(Exchange exchange, AsyncCallback callback) {\n    // do we have an explicit method name we always should invoke (either configured on endpoint or as a header)\n    String explicitMethodName = exchange.getIn().getHeader(Exchange.BEAN_METHOD_NAME, method, String.class);\n    Object bean;\n    BeanInfo beanInfo;\n    try {\n        bean = beanHolder.getBean();\n        beanInfo = beanHolder.getBeanInfo();\n    } catch (Throwable e) {\n        exchange.setException(e);\n        callback.done(true);\n        return true;\n    }\n    // do we have a custom adapter for this POJO to a Processor\n    // should not be invoked if an explicit method has been set\n    Processor processor = getProcessor();\n    if (explicitMethodName == null && processor != null) {\n        LOG.trace(\"Using a custom adapter as bean invocation: {}\", processor);\n        try {\n            processor.process(exchange);\n        } catch (Throwable e) {\n            exchange.setException(e);\n        }\n        callback.done(true);\n        return true;\n    }\n    Message in = exchange.getIn();\n    // is the message proxied using a BeanInvocation?\n    BeanInvocation beanInvoke = null;\n    if (in.getBody() != null && in.getBody() instanceof BeanInvocation) {\n        // BeanInvocation would be stored directly as the message body\n        // do not force any type conversion attempts as it would just be unnecessary and cost a bit performance\n        // so a regular instanceof check is sufficient\n        beanInvoke = (BeanInvocation) in.getBody();\n    }\n    if (beanInvoke != null) {\n        // Now it gets a bit complicated as ProxyHelper can proxy beans which we later\n        // intend to invoke (for example to proxy and invoke using spring remoting).\n        // and therefore the message body contains a BeanInvocation object.\n        // However this can causes problem if we in a Camel route invokes another bean,\n        // so we must test whether BeanHolder and BeanInvocation is the same bean or not\n        LOG.trace(\"Exchange IN body is a BeanInvocation instance: {}\", beanInvoke);\n        Class<?> clazz = beanInvoke.getMethod().getDeclaringClass();\n        boolean sameBean = clazz.isInstance(bean);\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"BeanHolder bean: {} and beanInvocation bean: {} is same instance: {}\", new Object[] { bean.getClass(), clazz, sameBean });\n        }\n        if (sameBean) {\n            beanInvoke.invoke(bean, exchange);\n            // propagate headers\n            exchange.getOut().getHeaders().putAll(exchange.getIn().getHeaders());\n            callback.done(true);\n            return true;\n        }\n    }\n    // set temporary header which is a hint for the bean info that introspect the bean\n    if (in.getHeader(Exchange.BEAN_MULTI_PARAMETER_ARRAY) == null) {\n        in.setHeader(Exchange.BEAN_MULTI_PARAMETER_ARRAY, isMultiParameterArray());\n    }\n    MethodInvocation invocation;\n    // set explicit method name to invoke as a header, which is how BeanInfo can detect it\n    if (explicitMethodName != null) {\n        in.setHeader(Exchange.BEAN_METHOD_NAME, explicitMethodName);\n    }\n    try {\n        invocation = beanInfo.createInvocation(bean, exchange);\n    } catch (Throwable e) {\n        exchange.setException(e);\n        callback.done(true);\n        return true;\n    } finally {\n        // must remove headers as they were provisional\n        in.removeHeader(Exchange.BEAN_MULTI_PARAMETER_ARRAY);\n        in.removeHeader(Exchange.BEAN_METHOD_NAME);\n    }\n    if (invocation == null) {\n        throw new IllegalStateException(\"No method invocation could be created, no matching method could be found on: \" + bean);\n    }\n    Object value;\n    try {\n        AtomicBoolean sync = new AtomicBoolean(true);\n        value = invocation.proceed(callback, sync);\n        if (!sync.get()) {\n            LOG.trace(\"Processing exchangeId: {} is continued being processed asynchronously\", exchange.getExchangeId());\n            // so we break out now, then the callback will be invoked which then continue routing from where we left here\n            return false;\n        }\n        LOG.trace(\"Processing exchangeId: {} is continued being processed synchronously\", exchange.getExchangeId());\n    } catch (InvocationTargetException e) {\n        // let's unwrap the exception when it's an invocation target exception\n        exchange.setException(e.getCause());\n        callback.done(true);\n        return true;\n    } catch (Throwable e) {\n        exchange.setException(e);\n        callback.done(true);\n        return true;\n    }\n    // if the method returns something then set the value returned on the Exchange\n    if (!invocation.getMethod().getReturnType().equals(Void.TYPE) && value != Void.TYPE) {\n        if (exchange.getPattern().isOutCapable()) {\n            // force out creating if not already created (as its lazy)\n            LOG.debug(\"Setting bean invocation result on the OUT message: {}\", value);\n            exchange.getOut().setBody(value);\n            // propagate headers\n            exchange.getOut().getHeaders().putAll(exchange.getIn().getHeaders());\n        } else {\n            // if not out then set it on the in\n            LOG.debug(\"Setting bean invocation result on the IN message: {}\", value);\n            exchange.getIn().setBody(value);\n        }\n    }\n    callback.done(true);\n    return true;\n}", "code_comment": NaN, "code_no_comment": "public boolean process(Exchange exchange, AsyncCallback callback) {\n        String explicitMethodName = exchange.getIn().getHeader(Exchange.BEAN_METHOD_NAME, method, String.class);\n    Object bean;\n    BeanInfo beanInfo;\n    try {\n        bean = beanHolder.getBean();\n        beanInfo = beanHolder.getBeanInfo();\n    } catch (Throwable e) {\n        exchange.setException(e);\n        callback.done(true);\n        return true;\n    }\n            Processor processor = getProcessor();\n    if (explicitMethodName == null && processor != null) {\n        LOG.trace(\"Using a custom adapter as bean invocation: {}\", processor);\n        try {\n            processor.process(exchange);\n        } catch (Throwable e) {\n            exchange.setException(e);\n        }\n        callback.done(true);\n        return true;\n    }\n    Message in = exchange.getIn();\n        BeanInvocation beanInvoke = null;\n    if (in.getBody() != null && in.getBody() instanceof BeanInvocation) {\n                                beanInvoke = (BeanInvocation) in.getBody();\n    }\n    if (beanInvoke != null) {\n                                                LOG.trace(\"Exchange IN body is a BeanInvocation instance: {}\", beanInvoke);\n        Class<?> clazz = beanInvoke.getMethod().getDeclaringClass();\n        boolean sameBean = clazz.isInstance(bean);\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"BeanHolder bean: {} and beanInvocation bean: {} is same instance: {}\", new Object[] { bean.getClass(), clazz, sameBean });\n        }\n        if (sameBean) {\n            beanInvoke.invoke(bean, exchange);\n                        exchange.getOut().getHeaders().putAll(exchange.getIn().getHeaders());\n            callback.done(true);\n            return true;\n        }\n    }\n        if (in.getHeader(Exchange.BEAN_MULTI_PARAMETER_ARRAY) == null) {\n        in.setHeader(Exchange.BEAN_MULTI_PARAMETER_ARRAY, isMultiParameterArray());\n    }\n    MethodInvocation invocation;\n        if (explicitMethodName != null) {\n        in.setHeader(Exchange.BEAN_METHOD_NAME, explicitMethodName);\n    }\n    try {\n        invocation = beanInfo.createInvocation(bean, exchange);\n    } catch (Throwable e) {\n        exchange.setException(e);\n        callback.done(true);\n        return true;\n    } finally {\n                in.removeHeader(Exchange.BEAN_MULTI_PARAMETER_ARRAY);\n        in.removeHeader(Exchange.BEAN_METHOD_NAME);\n    }\n    if (invocation == null) {\n        throw new IllegalStateException(\"No method invocation could be created, no matching method could be found on: \" + bean);\n    }\n    Object value;\n    try {\n        AtomicBoolean sync = new AtomicBoolean(true);\n        value = invocation.proceed(callback, sync);\n        if (!sync.get()) {\n            LOG.trace(\"Processing exchangeId: {} is continued being processed asynchronously\", exchange.getExchangeId());\n                        return false;\n        }\n        LOG.trace(\"Processing exchangeId: {} is continued being processed synchronously\", exchange.getExchangeId());\n    } catch (InvocationTargetException e) {\n                exchange.setException(e.getCause());\n        callback.done(true);\n        return true;\n    } catch (Throwable e) {\n        exchange.setException(e);\n        callback.done(true);\n        return true;\n    }\n        if (!invocation.getMethod().getReturnType().equals(Void.TYPE) && value != Void.TYPE) {\n        if (exchange.getPattern().isOutCapable()) {\n                        LOG.debug(\"Setting bean invocation result on the OUT message: {}\", value);\n            exchange.getOut().setBody(value);\n                        exchange.getOut().getHeaders().putAll(exchange.getIn().getHeaders());\n        } else {\n                        LOG.debug(\"Setting bean invocation result on the IN message: {}\", value);\n            exchange.getIn().setBody(value);\n        }\n    }\n    callback.done(true);\n    return true;\n}", "lc": 3.590909090909091, "pi": -0.023923444976076683, "ma": 2.8, "nbd": 0.0, "ml": 1.75, "d": 1.4424603174603174, "mi": -1.3016208597603942, "fo": 5.0, "r": -0.02631578947368421, "e": 7.099625986180505}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-9700_4d03e9de", "label": 1, "code": "/**\n * Strategy method for adding the exchange to the queue.\n * <p>\n * Will perform a blocking \"put\" if blockWhenFull is true, otherwise it will\n * simply add which will throw exception if the queue is full\n *\n * @param exchange the exchange to add to the queue\n */\nprotected void addToQueue(Exchange exchange) throws SedaConsumerNotAvailableException {\n    BlockingQueue<Exchange> queue = null;\n    QueueReference queueReference = endpoint.getQueueReference();\n    if (queueReference != null) {\n        queue = queueReference.getQueue();\n    }\n    if (queue == null) {\n        throw new SedaConsumerNotAvailableException(\"No queue available on endpoint: \" + endpoint, exchange);\n    }\n    boolean empty = !queueReference.hasConsumers();\n    if (empty) {\n        if (endpoint.isFailIfNoConsumers()) {\n            throw new SedaConsumerNotAvailableException(\"No consumers available on endpoint: \" + endpoint, exchange);\n        } else if (endpoint.isDiscardIfNoConsumers()) {\n            log.debug(\"Discard message as no active consumers on endpoint: \" + endpoint);\n            return;\n        }\n    }\n    if (blockWhenFull) {\n        try {\n            queue.put(exchange);\n        } catch (InterruptedException e) {\n            // ignore\n            log.debug(\"Put interrupted, are we stopping? {}\", isStopping() || isStopped());\n        }\n    } else {\n        queue.add(exchange);\n    }\n}", "code_comment": "/**\n * Strategy method for adding the exchange to the queue.\n * <p>\n * Will perform a blocking \"put\" if blockWhenFull is true, otherwise it will\n * simply add which will throw exception if the queue is full\n *\n * @param exchange the exchange to add to the queue\n */\n", "code_no_comment": "protected void addToQueue(Exchange exchange) throws SedaConsumerNotAvailableException {\n    BlockingQueue<Exchange> queue = null;\n    QueueReference queueReference = endpoint.getQueueReference();\n    if (queueReference != null) {\n        queue = queueReference.getQueue();\n    }\n    if (queue == null) {\n        throw new SedaConsumerNotAvailableException(\"No queue available on endpoint: \" + endpoint, exchange);\n    }\n    boolean empty = !queueReference.hasConsumers();\n    if (empty) {\n        if (endpoint.isFailIfNoConsumers()) {\n            throw new SedaConsumerNotAvailableException(\"No consumers available on endpoint: \" + endpoint, exchange);\n        } else if (endpoint.isDiscardIfNoConsumers()) {\n            log.debug(\"Discard message as no active consumers on endpoint: \" + endpoint);\n            return;\n        }\n    }\n    if (blockWhenFull) {\n        try {\n            queue.put(exchange);\n        } catch (InterruptedException e) {\n                        log.debug(\"Put interrupted, are we stopping? {}\", isStopping() || isStopped());\n        }\n    } else {\n        queue.add(exchange);\n    }\n}", "lc": 0.6363636363636364, "pi": 0.21531100478468887, "ma": 1.2, "nbd": 0.5, "ml": 0.5833333333333334, "d": 0.7063492063492064, "mi": -0.4615926708949964, "fo": 0.4166666666666667, "r": -0.02631578947368421, "e": 0.6738173037580032}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3861_d1e0e411", "label": 3, "code": "@Override\npublic void onComponentTag(final Component component, final ComponentTag tag) {\n    tag.put(\"xmlns:wicket\", \"http://wicket.apache.org\");\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void onComponentTag(final Component component, final ComponentTag tag) {\n    tag.put(\"xmlns:wicket\", \"http://wicket.apache.org\");\n}", "lc": -0.45454545454545453, "pi": -0.6028708133971293, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.8105708245243126, "fo": -0.4166666666666667, "r": 0.10526315789473684, "e": -0.16279340490885932}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-3077_17654199", "label": 0, "code": "private int write(final Collection<CommitSession> sessions, boolean mincFinish, Writer writer) throws IOException {\n    // Work very hard not to lock this during calls to the outside world\n    int currentLogSet = logSetId.get();\n    int seq = -1;\n    int attempt = 1;\n    boolean success = false;\n    while (!success) {\n        try {\n            // get a reference to the loggers that no other thread can touch\n            ArrayList<DfsLogger> copy = new ArrayList<DfsLogger>();\n            currentLogSet = initializeLoggers(copy);\n            if (currentLogSet == logSetId.get()) {\n                for (CommitSession commitSession : sessions) {\n                    if (commitSession.beginUpdatingLogsUsed(copy, mincFinish)) {\n                        try {\n                            // Scribble out a tablet definition and then write to the metadata table\n                            defineTablet(commitSession);\n                            if (currentLogSet == logSetId.get())\n                                tserver.addLoggersToMetadata(copy, commitSession.getExtent(), commitSession.getLogId());\n                        } finally {\n                            commitSession.finishUpdatingLogsUsed();\n                        }\n                        // Need to release\n                        KeyExtent extent = commitSession.getExtent();\n                        if (ReplicationConfigurationUtil.isEnabled(extent, tserver.getTableConfiguration(extent))) {\n                            Set<String> logs = new HashSet<String>();\n                            for (DfsLogger logger : copy) {\n                                logs.add(logger.getFileName());\n                            }\n                            Status status = StatusUtil.fileCreated(System.currentTimeMillis());\n                            log.debug(\"Writing \" + ProtobufUtil.toString(status) + \" to replication table for \" + logs);\n                            // Got some new WALs, note this in the replication table\n                            ReplicationTableUtil.updateFiles(SystemCredentials.get(), commitSession.getExtent(), logs, status);\n                        }\n                    }\n                }\n            }\n            // Make sure that the logs haven't changed out from underneath our copy\n            if (currentLogSet == logSetId.get()) {\n                // write the mutation to the logs\n                seq = seqGen.incrementAndGet();\n                if (seq < 0)\n                    throw new RuntimeException(\"Logger sequence generator wrapped!  Onos!!!11!eleven\");\n                ArrayList<LoggerOperation> queuedOperations = new ArrayList<LoggerOperation>(copy.size());\n                for (DfsLogger wal : copy) {\n                    LoggerOperation lop = writer.write(wal, seq);\n                    if (lop != null)\n                        queuedOperations.add(lop);\n                }\n                for (LoggerOperation lop : queuedOperations) {\n                    lop.await();\n                }\n                // double-check: did the log set change?\n                success = (currentLogSet == logSetId.get());\n            }\n        } catch (DfsLogger.LogClosedException ex) {\n            log.debug(\"Logs closed while writing, retrying \" + attempt);\n        } catch (Exception t) {\n            if (attempt != 1) {\n                log.error(\"Unexpected error writing to log, retrying attempt \" + attempt, t);\n            }\n            UtilWaitThread.sleep(100);\n        } finally {\n            attempt++;\n        }\n        // Some sort of write failure occurred. Grab the write lock and reset the logs.\n        // But since multiple threads will attempt it, only attempt the reset when\n        // the logs haven't changed.\n        final int finalCurrent = currentLogSet;\n        if (!success) {\n            testLockAndRun(logSetLock, new TestCallWithWriteLock() {\n\n                @Override\n                boolean test() {\n                    return finalCurrent == logSetId.get();\n                }\n\n                @Override\n                void withWriteLock() throws IOException {\n                    close();\n                    closeForReplication(sessions);\n                }\n            });\n        }\n    }\n    // if the log gets too big, reset it .. grab the write lock first\n    // event, tid, seq overhead\n    logSizeEstimate.addAndGet(4 * 3);\n    testLockAndRun(logSetLock, new TestCallWithWriteLock() {\n\n        @Override\n        boolean test() {\n            return logSizeEstimate.get() > maxSize;\n        }\n\n        @Override\n        void withWriteLock() throws IOException {\n            close();\n            closeForReplication(sessions);\n        }\n    });\n    return seq;\n}", "code_comment": NaN, "code_no_comment": "private int write(final Collection<CommitSession> sessions, boolean mincFinish, Writer writer) throws IOException {\n        int currentLogSet = logSetId.get();\n    int seq = -1;\n    int attempt = 1;\n    boolean success = false;\n    while (!success) {\n        try {\n                        ArrayList<DfsLogger> copy = new ArrayList<DfsLogger>();\n            currentLogSet = initializeLoggers(copy);\n            if (currentLogSet == logSetId.get()) {\n                for (CommitSession commitSession : sessions) {\n                    if (commitSession.beginUpdatingLogsUsed(copy, mincFinish)) {\n                        try {\n                                                        defineTablet(commitSession);\n                            if (currentLogSet == logSetId.get())\n                                tserver.addLoggersToMetadata(copy, commitSession.getExtent(), commitSession.getLogId());\n                        } finally {\n                            commitSession.finishUpdatingLogsUsed();\n                        }\n                                                KeyExtent extent = commitSession.getExtent();\n                        if (ReplicationConfigurationUtil.isEnabled(extent, tserver.getTableConfiguration(extent))) {\n                            Set<String> logs = new HashSet<String>();\n                            for (DfsLogger logger : copy) {\n                                logs.add(logger.getFileName());\n                            }\n                            Status status = StatusUtil.fileCreated(System.currentTimeMillis());\n                            log.debug(\"Writing \" + ProtobufUtil.toString(status) + \" to replication table for \" + logs);\n                                                        ReplicationTableUtil.updateFiles(SystemCredentials.get(), commitSession.getExtent(), logs, status);\n                        }\n                    }\n                }\n            }\n                        if (currentLogSet == logSetId.get()) {\n                                seq = seqGen.incrementAndGet();\n                if (seq < 0)\n                    throw new RuntimeException(\"Logger sequence generator wrapped!  Onos!!!11!eleven\");\n                ArrayList<LoggerOperation> queuedOperations = new ArrayList<LoggerOperation>(copy.size());\n                for (DfsLogger wal : copy) {\n                    LoggerOperation lop = writer.write(wal, seq);\n                    if (lop != null)\n                        queuedOperations.add(lop);\n                }\n                for (LoggerOperation lop : queuedOperations) {\n                    lop.await();\n                }\n                                success = (currentLogSet == logSetId.get());\n            }\n        } catch (DfsLogger.LogClosedException ex) {\n            log.debug(\"Logs closed while writing, retrying \" + attempt);\n        } catch (Exception t) {\n            if (attempt != 1) {\n                log.error(\"Unexpected error writing to log, retrying attempt \" + attempt, t);\n            }\n            UtilWaitThread.sleep(100);\n        } finally {\n            attempt++;\n        }\n                                final int finalCurrent = currentLogSet;\n        if (!success) {\n            testLockAndRun(logSetLock, new TestCallWithWriteLock() {\n\n                @Override\n                boolean test() {\n                    return finalCurrent == logSetId.get();\n                }\n\n                @Override\n                void withWriteLock() throws IOException {\n                    close();\n                    closeForReplication(sessions);\n                }\n            });\n        }\n    }\n            logSizeEstimate.addAndGet(4 * 3);\n    testLockAndRun(logSetLock, new TestCallWithWriteLock() {\n\n        @Override\n        boolean test() {\n            return logSizeEstimate.get() > maxSize;\n        }\n\n        @Override\n        void withWriteLock() throws IOException {\n            close();\n            closeForReplication(sessions);\n        }\n    });\n    return seq;\n}", "lc": 3.272727272727273, "pi": 2.3588516746411483, "ma": 2.8, "nbd": 2.5, "ml": 1.4166666666666667, "d": 1.6944444444444446, "mi": -1.2432699083861871, "fo": 2.9166666666666665, "r": -0.02631578947368421, "e": 6.926208053111114}
{"project_name": "Closure", "project_version": 162, "label": 2, "code": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, n.getParent());\n    }\n    // Validate the top level of the goog.scope block.\n    if (t.getScopeDepth() == 2) {\n        int type = n.getType();\n        if (type == Token.NAME && parent.getType() == Token.VAR) {\n            if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n                String name = n.getString();\n                Var aliasVar = t.getScope().getVar(name);\n                aliases.put(name, aliasVar);\n                aliasDefinitionsInOrder.add(n);\n                String qualifiedName = aliasVar.getInitialValue().getQualifiedName();\n                transformation.addAlias(name, qualifiedName);\n                // twice.\n                return;\n            } else {\n                report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n            }\n        }\n        if (type == Token.NAME && NodeUtil.isAssignmentOp(parent) && n == parent.getFirstChild()) {\n            report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n        }\n        if (type == Token.RETURN) {\n            report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n            report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n    }\n    // Validate all descendent scopes of the goog.scope block.\n    if (t.getScopeDepth() >= 2) {\n        // Check if this name points to an alias.\n        if (n.getType() == Token.NAME) {\n            String name = n.getString();\n            Var aliasVar = aliases.get(name);\n            if (aliasVar != null && t.getScope().getVar(name) == aliasVar) {\n                // Note, to support the transitive case, it's important we don't\n                // clone aliasedNode here.  For example,\n                // var g = goog; var d = g.dom; d.createElement('DIV');\n                // The node in aliasedNode (which is \"g\") will be replaced in the\n                // changes pass above with \"goog\".  If we cloned here, we'd end up\n                // with <code>g.dom.createElement('DIV')</code>.\n                Node aliasedNode = aliasVar.getInitialValue();\n                aliasUsages.add(new AliasedNode(n, aliasedNode));\n            }\n        }\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n            for (Node node : info.getTypeNodes()) {\n                fixTypeNode(node);\n            }\n        }\n    // TODO(robbyw): Error for goog.scope not at root.\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, n.getParent());\n    }\n        if (t.getScopeDepth() == 2) {\n        int type = n.getType();\n        if (type == Token.NAME && parent.getType() == Token.VAR) {\n            if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n                String name = n.getString();\n                Var aliasVar = t.getScope().getVar(name);\n                aliases.put(name, aliasVar);\n                aliasDefinitionsInOrder.add(n);\n                String qualifiedName = aliasVar.getInitialValue().getQualifiedName();\n                transformation.addAlias(name, qualifiedName);\n                                return;\n            } else {\n                report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n            }\n        }\n        if (type == Token.NAME && NodeUtil.isAssignmentOp(parent) && n == parent.getFirstChild()) {\n            report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n        }\n        if (type == Token.RETURN) {\n            report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n            report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n    }\n        if (t.getScopeDepth() >= 2) {\n                if (n.getType() == Token.NAME) {\n            String name = n.getString();\n            Var aliasVar = aliases.get(name);\n            if (aliasVar != null && t.getScope().getVar(name) == aliasVar) {\n                                                                                                                Node aliasedNode = aliasVar.getInitialValue();\n                aliasUsages.add(new AliasedNode(n, aliasedNode));\n            }\n        }\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n            for (Node node : info.getTypeNodes()) {\n                fixTypeNode(node);\n            }\n        }\n        }\n}", "lc": 1.5454545454545454, "pi": 0.7799043062200957, "ma": 2.0, "nbd": 1.0, "ml": 2.25, "d": 0.6170634920634921, "mi": -0.8982381959126141, "fo": 2.5833333333333335, "r": -0.02631578947368421, "e": 2.191951499224886}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4072_7d5b8645", "label": 1, "code": "/**\n *  render full representation of url (including protocol, host and port)\n *  into string representation\n *\n *  @param charset\n *\n *  @return see toStringRepresentation\n */\npublic String toAbsoluteString(final Charset charset) {\n    StringBuilder result = new StringBuilder();\n    // output scheme://host:port if specified\n    if (protocol != null && Strings.isEmpty(host) == false) {\n        result.append(protocol);\n        result.append(\"://\");\n        result.append(host);\n        if (port != null && port.equals(getDefaultPortForProtocol(protocol)) == false) {\n            result.append(':');\n            result.append(port);\n        }\n    }\n    // append relative part\n    result.append(this.toString());\n    // return url string\n    return result.toString();\n}", "code_comment": "/**\n *  render full representation of url (including protocol, host and port)\n *  into string representation\n *\n *  @param charset\n *\n *  @return see toStringRepresentation\n */\n", "code_no_comment": "public String toAbsoluteString(final Charset charset) {\n    StringBuilder result = new StringBuilder();\n        if (protocol != null && Strings.isEmpty(host) == false) {\n        result.append(protocol);\n        result.append(\"://\");\n        result.append(host);\n        if (port != null && port.equals(getDefaultPortForProtocol(protocol)) == false) {\n            result.append(':');\n            result.append(port);\n        }\n    }\n        result.append(this.toString());\n        return result.toString();\n}", "lc": 0.0, "pi": 0.3062200956937798, "ma": -0.2, "nbd": 0.0, "ml": 0.4166666666666667, "d": 0.4484126984126984, "mi": -0.037632135306553724, "fo": 0.4166666666666667, "r": 0.8157894736842105, "e": 0.2532067795047342}
{"project_name": "Compress", "project_version": 2, "label": 1, "code": "public int read() throws IOException {\n    final int ret = input.read();\n    offset += (ret > 0 ? 1 : 0);\n    return ret;\n}", "code_comment": NaN, "code_no_comment": "public int read() throws IOException {\n    final int ret = input.read();\n    offset += (ret > 0 ? 1 : 0);\n    return ret;\n}", "lc": -0.4090909090909091, "pi": -0.49282296650717716, "ma": -0.4, "nbd": -1.0, "ml": -0.25, "d": -0.06746031746031747, "mi": 0.650739957716702, "fo": -0.4166666666666667, "r": 1.5789473684210527, "e": -0.12690651959682575}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-757_76b7413d", "label": 1, "code": "/**\n * Notice the package scope on this method.   This method is simply here\n * for the JUnit test, it allows us check if the expansion is working\n * properly after a number of expansions.  This is not meant to be a part\n * of the public interface of this class.\n *\n * @return the length of the internal storage array.\n * @deprecated As of 3.1. Please use {@link #getCapacity()} instead.\n */\n@Deprecated\nsynchronized int getInternalLength() {\n    return internalArray.length;\n}", "code_comment": "/**\n * Notice the package scope on this method.   This method is simply here\n * for the JUnit test, it allows us check if the expansion is working\n * properly after a number of expansions.  This is not meant to be a part\n * of the public interface of this class.\n *\n * @return the length of the internal storage array.\n * @deprecated As of 3.1. Please use {@link #getCapacity()} instead.\n */\n", "code_no_comment": "@Deprecated\nsynchronized int getInternalLength() {\n    return internalArray.length;\n}", "lc": -0.45454545454545453, "pi": -0.6028708133971293, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.9785764622973924, "fo": -0.5, "r": 1.894736842105263, "e": -0.16279340490885932}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-492_a759d8ae", "label": 3, "code": "/**\n * Either returns the specified name as is, or returns a quoted value\n * containing the specified name with the special characters (comma, equals,\n * colon, quote, asterisk, or question mark) preceded with a backslash.\n *\n * @param name\n *            the name to escape so it can be used as a value in an\n *            {@link ObjectName}.\n * @return the escaped name\n */\npublic static String escape(final String name) {\n    final StringBuilder sb = new StringBuilder(name.length() * 2);\n    boolean needsQuotes = false;\n    for (int i = 0; i < name.length(); i++) {\n        final char c = name.charAt(i);\n        switch(c) {\n            case ',':\n            case '=':\n            case ':':\n            case '\\\\':\n            case '*':\n            case '?':\n                sb.append('\\\\');\n                needsQuotes = true;\n        }\n        sb.append(c);\n    }\n    if (needsQuotes) {\n        sb.insert(0, '\\\"');\n        sb.append('\\\"');\n    }\n    return sb.toString();\n}", "code_comment": "/**\n * Either returns the specified name as is, or returns a quoted value\n * containing the specified name with the special characters (comma, equals,\n * colon, quote, asterisk, or question mark) preceded with a backslash.\n *\n * @param name\n *            the name to escape so it can be used as a value in an\n *            {@link ObjectName}.\n * @return the escaped name\n */\n", "code_no_comment": "public static String escape(final String name) {\n    final StringBuilder sb = new StringBuilder(name.length() * 2);\n    boolean needsQuotes = false;\n    for (int i = 0; i < name.length(); i++) {\n        final char c = name.charAt(i);\n        switch(c) {\n            case ',':\n            case '=':\n            case ':':\n            case '\\\\':\n            case '*':\n            case '?':\n                sb.append('\\\\');\n                needsQuotes = true;\n        }\n        sb.append(c);\n    }\n    if (needsQuotes) {\n        sb.insert(0, '\\\"');\n        sb.append('\\\"');\n    }\n    return sb.toString();\n}", "lc": 0.4090909090909091, "pi": 0.7177033492822967, "ma": 1.0, "nbd": 0.5, "ml": 0.5833333333333334, "d": 0.3968253968253968, "mi": -0.3344608879492598, "fo": 0.16666666666666666, "r": 0.0, "e": 0.3188303567826743}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-949_f83bbc1d", "label": 1, "code": "/**\n * {@inheritDoc}\n */\n@Override\nprotected PointVectorValuePair doOptimize() {\n    checkParameters();\n    // Number of observed data.\n    final int nR = getTarget().length;\n    final double[] currentPoint = getStartPoint();\n    // Number of parameters.\n    final int nC = currentPoint.length;\n    // arrays shared with the other private methods\n    solvedCols = FastMath.min(nR, nC);\n    diagR = new double[nC];\n    jacNorm = new double[nC];\n    beta = new double[nC];\n    permutation = new int[nC];\n    lmDir = new double[nC];\n    // local point\n    double delta = 0;\n    double xNorm = 0;\n    double[] diag = new double[nC];\n    double[] oldX = new double[nC];\n    double[] oldRes = new double[nR];\n    double[] oldObj = new double[nR];\n    double[] qtf = new double[nR];\n    double[] work1 = new double[nC];\n    double[] work2 = new double[nC];\n    double[] work3 = new double[nC];\n    final RealMatrix weightMatrixSqrt = getWeightSquareRoot();\n    // Evaluate the function at the starting point and calculate its norm.\n    double[] currentObjective = computeObjectiveValue(currentPoint);\n    double[] currentResiduals = computeResiduals(currentObjective);\n    PointVectorValuePair current = new PointVectorValuePair(currentPoint, currentObjective);\n    double currentCost = computeCost(currentResiduals);\n    // Outer loop.\n    lmPar = 0;\n    boolean firstIteration = true;\n    int iter = 0;\n    final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker();\n    while (true) {\n        ++iter;\n        final PointVectorValuePair previous = current;\n        // QR decomposition of the jacobian matrix\n        qrDecomposition(computeWeightedJacobian(currentPoint));\n        weightedResidual = weightMatrixSqrt.operate(currentResiduals);\n        for (int i = 0; i < nR; i++) {\n            qtf[i] = weightedResidual[i];\n        }\n        // compute Qt.res\n        qTy(qtf);\n        // so let jacobian contain the R matrix with its diagonal elements\n        for (int k = 0; k < solvedCols; ++k) {\n            int pk = permutation[k];\n            weightedJacobian[k][pk] = diagR[pk];\n        }\n        if (firstIteration) {\n            // scale the point according to the norms of the columns\n            // of the initial jacobian\n            xNorm = 0;\n            for (int k = 0; k < nC; ++k) {\n                double dk = jacNorm[k];\n                if (dk == 0) {\n                    dk = 1.0;\n                }\n                double xk = dk * currentPoint[k];\n                xNorm += xk * xk;\n                diag[k] = dk;\n            }\n            xNorm = FastMath.sqrt(xNorm);\n            // initialize the step bound delta\n            delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n        }\n        // check orthogonality between function vector and jacobian columns\n        double maxCosine = 0;\n        if (currentCost != 0) {\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double s = jacNorm[pj];\n                if (s != 0) {\n                    double sum = 0;\n                    for (int i = 0; i <= j; ++i) {\n                        sum += weightedJacobian[i][pj] * qtf[i];\n                    }\n                    maxCosine = FastMath.max(maxCosine, FastMath.abs(sum) / (s * currentCost));\n                }\n            }\n        }\n        if (maxCosine <= orthoTolerance) {\n            // Convergence has been reached.\n            setCost(currentCost);\n            return current;\n        }\n        // rescale if necessary\n        for (int j = 0; j < nC; ++j) {\n            diag[j] = FastMath.max(diag[j], jacNorm[j]);\n        }\n        // Inner loop.\n        for (double ratio = 0; ratio < 1.0e-4; ) {\n            // save the state\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                oldX[pj] = currentPoint[pj];\n            }\n            final double previousCost = currentCost;\n            double[] tmpVec = weightedResidual;\n            weightedResidual = oldRes;\n            oldRes = tmpVec;\n            tmpVec = currentObjective;\n            currentObjective = oldObj;\n            oldObj = tmpVec;\n            // determine the Levenberg-Marquardt parameter\n            determineLMParameter(qtf, delta, diag, work1, work2, work3);\n            // compute the new point and the norm of the evolution direction\n            double lmNorm = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                lmDir[pj] = -lmDir[pj];\n                currentPoint[pj] = oldX[pj] + lmDir[pj];\n                double s = diag[pj] * lmDir[pj];\n                lmNorm += s * s;\n            }\n            lmNorm = FastMath.sqrt(lmNorm);\n            // on the first iteration, adjust the initial step bound.\n            if (firstIteration) {\n                delta = FastMath.min(delta, lmNorm);\n            }\n            // Evaluate the function at x + p and calculate its norm.\n            currentObjective = computeObjectiveValue(currentPoint);\n            currentResiduals = computeResiduals(currentObjective);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n            currentCost = computeCost(currentResiduals);\n            // compute the scaled actual reduction\n            double actRed = -1.0;\n            if (0.1 * currentCost < previousCost) {\n                double r = currentCost / previousCost;\n                actRed = 1.0 - r * r;\n            }\n            // and the scaled directional derivative\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double dirJ = lmDir[pj];\n                work1[j] = 0;\n                for (int i = 0; i <= j; ++i) {\n                    work1[i] += weightedJacobian[i][pj] * dirJ;\n                }\n            }\n            double coeff1 = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                coeff1 += work1[j] * work1[j];\n            }\n            double pc2 = previousCost * previousCost;\n            coeff1 = coeff1 / pc2;\n            double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n            double preRed = coeff1 + 2 * coeff2;\n            double dirDer = -(coeff1 + coeff2);\n            // ratio of the actual to the predicted reduction\n            ratio = (preRed == 0) ? 0 : (actRed / preRed);\n            // update the step bound\n            if (ratio <= 0.25) {\n                double tmp = (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                if ((0.1 * currentCost >= previousCost) || (tmp < 0.1)) {\n                    tmp = 0.1;\n                }\n                delta = tmp * FastMath.min(delta, 10.0 * lmNorm);\n                lmPar /= tmp;\n            } else if ((lmPar == 0) || (ratio >= 0.75)) {\n                delta = 2 * lmNorm;\n                lmPar *= 0.5;\n            }\n            // test for successful iteration.\n            if (ratio >= 1.0e-4) {\n                // successful iteration, update the norm\n                firstIteration = false;\n                xNorm = 0;\n                for (int k = 0; k < nC; ++k) {\n                    double xK = diag[k] * currentPoint[k];\n                    xNorm += xK * xK;\n                }\n                xNorm = FastMath.sqrt(xNorm);\n                // tests for convergence.\n                if (checker != null) {\n                    // we use the vectorial convergence checker\n                    if (checker.converged(iter, previous, current)) {\n                        setCost(currentCost);\n                        return current;\n                    }\n                }\n            } else {\n                // failed iteration, reset the previous values\n                currentCost = previousCost;\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    currentPoint[pj] = oldX[pj];\n                }\n                tmpVec = weightedResidual;\n                weightedResidual = oldRes;\n                oldRes = tmpVec;\n                tmpVec = currentObjective;\n                currentObjective = oldObj;\n                oldObj = tmpVec;\n                // Reset \"current\" to previous values.\n                current = new PointVectorValuePair(currentPoint, currentObjective);\n            }\n            // Default convergence criteria.\n            if ((FastMath.abs(actRed) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0) || delta <= parRelativeTolerance * xNorm) {\n                setCost(currentCost);\n                return current;\n            }\n            // (2.2204e-16 is the machine epsilon for IEEE754)\n            if ((FastMath.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n                throw new ConvergenceException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance);\n            } else if (delta <= 2.2204e-16 * xNorm) {\n                throw new ConvergenceException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance);\n            } else if (maxCosine <= 2.2204e-16) {\n                throw new ConvergenceException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance);\n            }\n        }\n    }\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "@Override\nprotected PointVectorValuePair doOptimize() {\n    checkParameters();\n        final int nR = getTarget().length;\n    final double[] currentPoint = getStartPoint();\n        final int nC = currentPoint.length;\n        solvedCols = FastMath.min(nR, nC);\n    diagR = new double[nC];\n    jacNorm = new double[nC];\n    beta = new double[nC];\n    permutation = new int[nC];\n    lmDir = new double[nC];\n        double delta = 0;\n    double xNorm = 0;\n    double[] diag = new double[nC];\n    double[] oldX = new double[nC];\n    double[] oldRes = new double[nR];\n    double[] oldObj = new double[nR];\n    double[] qtf = new double[nR];\n    double[] work1 = new double[nC];\n    double[] work2 = new double[nC];\n    double[] work3 = new double[nC];\n    final RealMatrix weightMatrixSqrt = getWeightSquareRoot();\n        double[] currentObjective = computeObjectiveValue(currentPoint);\n    double[] currentResiduals = computeResiduals(currentObjective);\n    PointVectorValuePair current = new PointVectorValuePair(currentPoint, currentObjective);\n    double currentCost = computeCost(currentResiduals);\n        lmPar = 0;\n    boolean firstIteration = true;\n    int iter = 0;\n    final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker();\n    while (true) {\n        ++iter;\n        final PointVectorValuePair previous = current;\n                qrDecomposition(computeWeightedJacobian(currentPoint));\n        weightedResidual = weightMatrixSqrt.operate(currentResiduals);\n        for (int i = 0; i < nR; i++) {\n            qtf[i] = weightedResidual[i];\n        }\n                qTy(qtf);\n                for (int k = 0; k < solvedCols; ++k) {\n            int pk = permutation[k];\n            weightedJacobian[k][pk] = diagR[pk];\n        }\n        if (firstIteration) {\n                                    xNorm = 0;\n            for (int k = 0; k < nC; ++k) {\n                double dk = jacNorm[k];\n                if (dk == 0) {\n                    dk = 1.0;\n                }\n                double xk = dk * currentPoint[k];\n                xNorm += xk * xk;\n                diag[k] = dk;\n            }\n            xNorm = FastMath.sqrt(xNorm);\n                        delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n        }\n                double maxCosine = 0;\n        if (currentCost != 0) {\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double s = jacNorm[pj];\n                if (s != 0) {\n                    double sum = 0;\n                    for (int i = 0; i <= j; ++i) {\n                        sum += weightedJacobian[i][pj] * qtf[i];\n                    }\n                    maxCosine = FastMath.max(maxCosine, FastMath.abs(sum) / (s * currentCost));\n                }\n            }\n        }\n        if (maxCosine <= orthoTolerance) {\n                        setCost(currentCost);\n            return current;\n        }\n                for (int j = 0; j < nC; ++j) {\n            diag[j] = FastMath.max(diag[j], jacNorm[j]);\n        }\n                for (double ratio = 0; ratio < 1.0e-4; ) {\n                        for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                oldX[pj] = currentPoint[pj];\n            }\n            final double previousCost = currentCost;\n            double[] tmpVec = weightedResidual;\n            weightedResidual = oldRes;\n            oldRes = tmpVec;\n            tmpVec = currentObjective;\n            currentObjective = oldObj;\n            oldObj = tmpVec;\n                        determineLMParameter(qtf, delta, diag, work1, work2, work3);\n                        double lmNorm = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                lmDir[pj] = -lmDir[pj];\n                currentPoint[pj] = oldX[pj] + lmDir[pj];\n                double s = diag[pj] * lmDir[pj];\n                lmNorm += s * s;\n            }\n            lmNorm = FastMath.sqrt(lmNorm);\n                        if (firstIteration) {\n                delta = FastMath.min(delta, lmNorm);\n            }\n                        currentObjective = computeObjectiveValue(currentPoint);\n            currentResiduals = computeResiduals(currentObjective);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n            currentCost = computeCost(currentResiduals);\n                        double actRed = -1.0;\n            if (0.1 * currentCost < previousCost) {\n                double r = currentCost / previousCost;\n                actRed = 1.0 - r * r;\n            }\n                        for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double dirJ = lmDir[pj];\n                work1[j] = 0;\n                for (int i = 0; i <= j; ++i) {\n                    work1[i] += weightedJacobian[i][pj] * dirJ;\n                }\n            }\n            double coeff1 = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                coeff1 += work1[j] * work1[j];\n            }\n            double pc2 = previousCost * previousCost;\n            coeff1 = coeff1 / pc2;\n            double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n            double preRed = coeff1 + 2 * coeff2;\n            double dirDer = -(coeff1 + coeff2);\n                        ratio = (preRed == 0) ? 0 : (actRed / preRed);\n                        if (ratio <= 0.25) {\n                double tmp = (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                if ((0.1 * currentCost >= previousCost) || (tmp < 0.1)) {\n                    tmp = 0.1;\n                }\n                delta = tmp * FastMath.min(delta, 10.0 * lmNorm);\n                lmPar /= tmp;\n            } else if ((lmPar == 0) || (ratio >= 0.75)) {\n                delta = 2 * lmNorm;\n                lmPar *= 0.5;\n            }\n                        if (ratio >= 1.0e-4) {\n                                firstIteration = false;\n                xNorm = 0;\n                for (int k = 0; k < nC; ++k) {\n                    double xK = diag[k] * currentPoint[k];\n                    xNorm += xK * xK;\n                }\n                xNorm = FastMath.sqrt(xNorm);\n                                if (checker != null) {\n                                        if (checker.converged(iter, previous, current)) {\n                        setCost(currentCost);\n                        return current;\n                    }\n                }\n            } else {\n                                currentCost = previousCost;\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    currentPoint[pj] = oldX[pj];\n                }\n                tmpVec = weightedResidual;\n                weightedResidual = oldRes;\n                oldRes = tmpVec;\n                tmpVec = currentObjective;\n                currentObjective = oldObj;\n                oldObj = tmpVec;\n                                current = new PointVectorValuePair(currentPoint, currentObjective);\n            }\n                        if ((FastMath.abs(actRed) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0) || delta <= parRelativeTolerance * xNorm) {\n                setCost(currentCost);\n                return current;\n            }\n                        if ((FastMath.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n                throw new ConvergenceException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance);\n            } else if (delta <= 2.2204e-16 * xNorm) {\n                throw new ConvergenceException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance);\n            } else if (maxCosine <= 2.2204e-16) {\n                throw new ConvergenceException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance);\n            }\n        }\n    }\n}", "lc": 7.7272727272727275, "pi": 1.0334928229665072, "ma": 7.0, "nbd": 1.5, "ml": 5.416666666666667, "d": 7.224206349206349, "mi": -1.9040169133192384, "fo": 2.0833333333333335, "r": -0.02631578947368421, "e": 87.31367484425694}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-217_46f62443", "label": 1, "code": "@Override\npublic void offline(String tableName) throws AccumuloSecurityException, AccumuloException {\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void offline(String tableName) throws AccumuloSecurityException, AccumuloException {\n}", "lc": -0.5, "pi": -1.4306220095693782, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.0329809725158563, "fo": -0.5, "r": 1.6578947368421053, "e": -0.16279340490885932}
{"project_name": "Math", "project_version": 49, "label": 1, "code": "/**\n * {@inheritDoc}\n */\npublic OpenMapRealVector ebeMultiply(RealVector v) {\n    checkVectorDimensions(v.getDimension());\n    OpenMapRealVector res = new OpenMapRealVector(this);\n    Iterator iter = res.entries.iterator();\n    while (iter.hasNext()) {\n        iter.advance();\n        res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));\n    }\n    return res;\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "public OpenMapRealVector ebeMultiply(RealVector v) {\n    checkVectorDimensions(v.getDimension());\n    OpenMapRealVector res = new OpenMapRealVector(this);\n    Iterator iter = res.entries.iterator();\n    while (iter.hasNext()) {\n        iter.advance();\n        res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));\n    }\n    return res;\n}", "lc": -0.18181818181818182, "pi": -0.2200956937799045, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": -0.02380952380952383, "mi": 0.18167723749119113, "fo": 0.3333333333333333, "r": 0.13157894736842105, "e": -0.04611953458619319}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-1148_4080feff", "label": 1, "code": "public int compare(final Vector2D o1, final Vector2D o2) {\n    final int diff = (int) FastMath.signum(o1.getX() - o2.getX());\n    if (diff == 0) {\n        return (int) FastMath.signum(o1.getY() - o2.getY());\n    } else {\n        return diff;\n    }\n}", "code_comment": NaN, "code_no_comment": "public int compare(final Vector2D o1, final Vector2D o2) {\n    final int diff = (int) FastMath.signum(o1.getX() - o2.getX());\n    if (diff == 0) {\n        return (int) FastMath.signum(o1.getY() - o2.getY());\n    } else {\n        return diff;\n    }\n}", "lc": -0.2727272727272727, "pi": -0.07655502392344504, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": 0.03174603174603173, "mi": 0.34150810429880174, "fo": 0.0, "r": 0.21052631578947367, "e": -0.07151789676296515}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-678_6c54045d", "label": 1, "code": "/**\n * Determine whether this child exists at its direct parent.\n * @return  {@code true} iff this child exists at its direct parent.\n */\nprivate boolean exists() {\n    // retrieved from the base state.\n    return isRoot() || parent.writeState == null || parent.writeState.hasChildNode(name);\n}", "code_comment": "/**\n * Determine whether this child exists at its direct parent.\n * @return  {@code true} iff this child exists at its direct parent.\n */\n", "code_no_comment": "private boolean exists() {\n        return isRoot() || parent.writeState == null || parent.writeState.hasChildNode(name);\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.11706349206349208, "mi": 0.917406624383368, "fo": -0.3333333333333333, "r": 2.552631578947368, "e": -0.13790679045429133}
{"project_name": "Chart", "project_version": 2, "label": 3, "code": "/**\n * Iterates over the data items of the xy dataset to find\n * the range bounds.\n *\n * @param dataset  the dataset (<code>null</code> not permitted).\n * @param includeInterval  a flag that determines, for an\n *          {@link IntervalXYDataset}, whether the y-interval or just the\n *          y-value is used to determine the overall range.\n *\n * @return The range (possibly <code>null</code>).\n *\n * @since 1.0.10\n */\npublic static Range iterateRangeBounds(XYDataset dataset, boolean includeInterval) {\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    int seriesCount = dataset.getSeriesCount();\n    // handle three cases by dataset type\n    if (includeInterval && dataset instanceof IntervalXYDataset) {\n        // handle special case of IntervalXYDataset\n        IntervalXYDataset ixyd = (IntervalXYDataset) dataset;\n        for (int series = 0; series < seriesCount; series++) {\n            int itemCount = dataset.getItemCount(series);\n            for (int item = 0; item < itemCount; item++) {\n                double lvalue = ixyd.getStartYValue(series, item);\n                double uvalue = ixyd.getEndYValue(series, item);\n                if (!Double.isNaN(lvalue)) {\n                    minimum = Math.min(minimum, lvalue);\n                }\n                if (!Double.isNaN(uvalue)) {\n                    maximum = Math.max(maximum, uvalue);\n                }\n            }\n        }\n    } else if (includeInterval && dataset instanceof OHLCDataset) {\n        // handle special case of OHLCDataset\n        OHLCDataset ohlc = (OHLCDataset) dataset;\n        for (int series = 0; series < seriesCount; series++) {\n            int itemCount = dataset.getItemCount(series);\n            for (int item = 0; item < itemCount; item++) {\n                double lvalue = ohlc.getLowValue(series, item);\n                double uvalue = ohlc.getHighValue(series, item);\n                if (!Double.isNaN(lvalue)) {\n                    minimum = Math.min(minimum, lvalue);\n                }\n                if (!Double.isNaN(uvalue)) {\n                    maximum = Math.max(maximum, uvalue);\n                }\n            }\n        }\n    } else {\n        // standard case - plain XYDataset\n        for (int series = 0; series < seriesCount; series++) {\n            int itemCount = dataset.getItemCount(series);\n            for (int item = 0; item < itemCount; item++) {\n                double value = dataset.getYValue(series, item);\n                if (!Double.isNaN(value)) {\n                    minimum = Math.min(minimum, value);\n                    maximum = Math.max(maximum, value);\n                }\n            }\n        }\n    }\n    if (minimum == Double.POSITIVE_INFINITY) {\n        return null;\n    } else {\n        return new Range(minimum, maximum);\n    }\n}", "code_comment": "/**\n * Iterates over the data items of the xy dataset to find\n * the range bounds.\n *\n * @param dataset  the dataset (<code>null</code> not permitted).\n * @param includeInterval  a flag that determines, for an\n *          {@link IntervalXYDataset}, whether the y-interval or just the\n *          y-value is used to determine the overall range.\n *\n * @return The range (possibly <code>null</code>).\n *\n * @since 1.0.10\n */\n", "code_no_comment": "public static Range iterateRangeBounds(XYDataset dataset, boolean includeInterval) {\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    int seriesCount = dataset.getSeriesCount();\n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n                IntervalXYDataset ixyd = (IntervalXYDataset) dataset;\n        for (int series = 0; series < seriesCount; series++) {\n            int itemCount = dataset.getItemCount(series);\n            for (int item = 0; item < itemCount; item++) {\n                double lvalue = ixyd.getStartYValue(series, item);\n                double uvalue = ixyd.getEndYValue(series, item);\n                if (!Double.isNaN(lvalue)) {\n                    minimum = Math.min(minimum, lvalue);\n                }\n                if (!Double.isNaN(uvalue)) {\n                    maximum = Math.max(maximum, uvalue);\n                }\n            }\n        }\n    } else if (includeInterval && dataset instanceof OHLCDataset) {\n                OHLCDataset ohlc = (OHLCDataset) dataset;\n        for (int series = 0; series < seriesCount; series++) {\n            int itemCount = dataset.getItemCount(series);\n            for (int item = 0; item < itemCount; item++) {\n                double lvalue = ohlc.getLowValue(series, item);\n                double uvalue = ohlc.getHighValue(series, item);\n                if (!Double.isNaN(lvalue)) {\n                    minimum = Math.min(minimum, lvalue);\n                }\n                if (!Double.isNaN(uvalue)) {\n                    maximum = Math.max(maximum, uvalue);\n                }\n            }\n        }\n    } else {\n                for (int series = 0; series < seriesCount; series++) {\n            int itemCount = dataset.getItemCount(series);\n            for (int item = 0; item < itemCount; item++) {\n                double value = dataset.getYValue(series, item);\n                if (!Double.isNaN(value)) {\n                    minimum = Math.min(minimum, value);\n                    maximum = Math.max(maximum, value);\n                }\n            }\n        }\n    }\n    if (minimum == Double.POSITIVE_INFINITY) {\n        return null;\n    } else {\n        return new Range(minimum, maximum);\n    }\n}", "lc": 1.7272727272727273, "pi": 1.2966507177033493, "ma": 2.2, "nbd": 1.5, "ml": 2.0, "d": 2.1527777777777777, "mi": -0.9413671599718108, "fo": 1.1666666666666667, "r": -0.02631578947368421, "e": 5.88464468687148}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-1619_b154d12f", "label": 1, "code": "@Override\npublic boolean isEnabled() {\n    return PagingNavigator.this.isEnabled() && PagingNavigator.this.isEnableAllowed();\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean isEnabled() {\n    return PagingNavigator.this.isEnabled() && PagingNavigator.this.isEnableAllowed();\n}", "lc": -0.45454545454545453, "pi": -0.6028708133971293, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.8940098661028892, "fo": -0.3333333333333333, "r": 0.2631578947368421, "e": -0.16279340490885932}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-2800_b654e989", "label": 1, "code": "@Override\npublic void serialize(T record, DataOutputView target) throws IOException {\n    checkKryoInitialized();\n    if (target != previousOut) {\n        DataOutputViewStream outputStream = new DataOutputViewStream(target);\n        output = new Output(outputStream);\n        previousOut = target;\n    }\n    try {\n        kryo.writeClassAndObject(output, record);\n        output.flush();\n    } catch (KryoException ke) {\n        Throwable cause = ke.getCause();\n        if (cause instanceof EOFException) {\n            throw (EOFException) cause;\n        } else {\n            throw ke;\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void serialize(T record, DataOutputView target) throws IOException {\n    checkKryoInitialized();\n    if (target != previousOut) {\n        DataOutputViewStream outputStream = new DataOutputViewStream(target);\n        output = new Output(outputStream);\n        previousOut = target;\n    }\n    try {\n        kryo.writeClassAndObject(output, record);\n        output.flush();\n    } catch (KryoException ke) {\n        Throwable cause = ke.getCause();\n        if (cause instanceof EOFException) {\n            throw (EOFException) cause;\n        } else {\n            throw ke;\n        }\n    }\n}", "lc": 0.2727272727272727, "pi": 0.22488038277511951, "ma": 0.4, "nbd": 0.0, "ml": 0.0, "d": -0.04563492063492063, "mi": -0.2022551092318533, "fo": -0.16666666666666666, "r": 0.2368421052631579, "e": -0.018139382099202996}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-1257_03178c8b", "label": 3, "code": "/**\n * {@inheritDoc}\n *\n * If {@code x} is more than 40 standard deviations from the mean, 0 or 1\n * is returned, as in these cases the actual value is within\n * {@code Double.MIN_VALUE} of 0 or 1.\n */\n@Override\npublic double cumulativeProbability(double x) {\n    final double dev = x - mean;\n    if (FastMath.abs(dev) > 40 * standardDeviation) {\n        return dev < 0 ? 0.0d : 1.0d;\n    }\n    return 0.5 * (1 + Erf.erf(dev / (standardDeviation * SQRT2)));\n}", "code_comment": "/**\n * {@inheritDoc}\n *\n * If {@code x} is more than 40 standard deviations from the mean, 0 or 1\n * is returned, as in these cases the actual value is within\n * {@code Double.MIN_VALUE} of 0 or 1.\n */\n", "code_no_comment": "@Override\npublic double cumulativeProbability(double x) {\n    final double dev = x - mean;\n    if (FastMath.abs(dev) > 40 * standardDeviation) {\n        return dev < 0 ? 0.0d : 1.0d;\n    }\n    return 0.5 * (1 + Erf.erf(dev / (standardDeviation * SQRT2)));\n}", "lc": -0.2727272727272727, "pi": -0.16267942583732073, "ma": -0.2, "nbd": -0.5, "ml": 0.0, "d": 0.3948412698412698, "mi": 0.2755461592670896, "fo": -0.3333333333333333, "r": 1.631578947368421, "e": 0.0998346040582516}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5072_381b90fd", "label": 1, "code": "/**\n *  Checks whether two cookies are equal.\n *  See http://www.ietf.org/rfc/rfc2109.txt, p.4.3.3\n *\n *  @param c1\n *       the first cookie\n *  @param c2\n *       the second cookie\n *  @return {@code true} only if the cookies have the same name, path and domain\n */\npublic static boolean isEqual(Cookie c1, Cookie c2) {\n    Args.notNull(c1, \"c1\");\n    Args.notNull(c2, \"c2\");\n    return c1.getName().equals(c2.getName()) && ((c1.getPath() == null && c2.getPath() == null) || (c1.getPath().equals(c2.getPath()))) && ((c1.getDomain() == null && c2.getDomain() == null) || (c1.getDomain().equals(c2.getDomain())));\n}", "code_comment": "/**\n *  Checks whether two cookies are equal.\n *  See http://www.ietf.org/rfc/rfc2109.txt, p.4.3.3\n *\n *  @param c1\n *       the first cookie\n *  @param c2\n *       the second cookie\n *  @return {@code true} only if the cookies have the same name, path and domain\n */\n", "code_no_comment": "public static boolean isEqual(Cookie c1, Cookie c2) {\n    Args.notNull(c1, \"c1\");\n    Args.notNull(c2, \"c2\");\n    return c1.getName().equals(c2.getName()) && ((c1.getPath() == null && c2.getPath() == null) || (c1.getPath().equals(c2.getPath()))) && ((c1.getDomain() == null && c2.getDomain() == null) || (c1.getDomain().equals(c2.getDomain())));\n}", "lc": -0.4090909090909091, "pi": -0.49282296650717716, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": 0.31349206349206343, "mi": 0.46300211416490467, "fo": 0.75, "r": 0.02631578947368421, "e": 0.14491450701059796}
{"project_name": "Time", "project_version": 25, "label": 2, "code": "/**\n * Gets the millisecond offset to subtract from local time to get UTC time.\n * This offset can be used to undo adding the offset obtained by getOffset.\n *\n * <pre>\n * millisLocal == millisUTC   + getOffset(millisUTC)\n * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n * </pre>\n *\n * NOTE: After calculating millisLocal, some error may be introduced. At\n * offset transitions (due to DST or other historical changes), ranges of\n * local times may map to different UTC times.\n * <p>\n * This method will return an offset suitable for calculating an instant\n * after any DST gap. For example, consider a zone with a cutover\n * from 01:00 to 01:59:<br />\n * Input: 00:00  Output: 00:00<br />\n * Input: 00:30  Output: 00:30<br />\n * Input: 01:00  Output: 02:00<br />\n * Input: 01:30  Output: 02:30<br />\n * Input: 02:00  Output: 02:00<br />\n * Input: 02:30  Output: 02:30<br />\n * <p>\n * During a DST overlap (where the local time is ambiguous) this method will return\n * the earlier instant. The combination of these two rules is to always favour\n * daylight (summer) time over standard (winter) time.\n * <p>\n * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n * Prior to v1.5, the DST gap behaviour was also not defined.\n *\n * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n * @return the millisecond offset to subtract from local time to get UTC time\n */\npublic int getOffsetFromLocal(long instantLocal) {\n    // get the offset at instantLocal (first estimate)\n    final int offsetLocal = getOffset(instantLocal);\n    // adjust instantLocal using the estimate and recalc the offset\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n    // if the offsets differ, we must be near a DST boundary\n    if (offsetLocal != offsetAdjusted) {\n        // this happens naturally for positive offsets, but not for negative\n        if ((offsetLocal - offsetAdjusted) < 0) {\n            // if we just return offsetAdjusted then the time is pushed\n            // back before the transition, whereas it should be\n            // on or after the transition\n            long nextLocal = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal != nextAdjusted) {\n                return offsetLocal;\n            }\n        }\n    }\n    return offsetAdjusted;\n}", "code_comment": "/**\n * Gets the millisecond offset to subtract from local time to get UTC time.\n * This offset can be used to undo adding the offset obtained by getOffset.\n *\n * <pre>\n * millisLocal == millisUTC   + getOffset(millisUTC)\n * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n * </pre>\n *\n * NOTE: After calculating millisLocal, some error may be introduced. At\n * offset transitions (due to DST or other historical changes), ranges of\n * local times may map to different UTC times.\n * <p>\n * This method will return an offset suitable for calculating an instant\n * after any DST gap. For example, consider a zone with a cutover\n * from 01:00 to 01:59:<br />\n * Input: 00:00  Output: 00:00<br />\n * Input: 00:30  Output: 00:30<br />\n * Input: 01:00  Output: 02:00<br />\n * Input: 01:30  Output: 02:30<br />\n * Input: 02:00  Output: 02:00<br />\n * Input: 02:30  Output: 02:30<br />\n * <p>\n * During a DST overlap (where the local time is ambiguous) this method will return\n * the earlier instant. The combination of these two rules is to always favour\n * daylight (summer) time over standard (winter) time.\n * <p>\n * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n * Prior to v1.5, the DST gap behaviour was also not defined.\n *\n * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n * @return the millisecond offset to subtract from local time to get UTC time\n */\n", "code_no_comment": "public int getOffsetFromLocal(long instantLocal) {\n        final int offsetLocal = getOffset(instantLocal);\n        final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n        if (offsetLocal != offsetAdjusted) {\n                if ((offsetLocal - offsetAdjusted) < 0) {\n                                                long nextLocal = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal != nextAdjusted) {\n                return offsetLocal;\n            }\n        }\n    }\n    return offsetAdjusted;\n}", "lc": 0.045454545454545456, "pi": 0.8325358851674642, "ma": 0.0, "nbd": 0.5, "ml": 0.16666666666666666, "d": 0.6448412698412699, "mi": -0.02184637068358014, "fo": -0.16666666666666666, "r": -0.02631578947368421, "e": 0.1948306564547639}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-43_668f08f2", "label": 1, "code": "void apply() throws Exception {\n    setProperty(nodePath, propName, propValue);\n}", "code_comment": NaN, "code_no_comment": "void apply() throws Exception {\n    setProperty(nodePath, propName, propValue);\n}", "lc": -0.5, "pi": -0.5263157894736844, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.0329809725158563, "fo": -0.4166666666666667, "r": 0.5263157894736842, "e": -0.16279340490885932}
{"project_name": "Compress", "project_version": 20, "label": 1, "code": "private CpioArchiveEntry readOldAsciiEntry() throws IOException {\n    CpioArchiveEntry ret = new CpioArchiveEntry(FORMAT_OLD_ASCII);\n    ret.setDevice(readAsciiLong(6, 8));\n    ret.setInode(readAsciiLong(6, 8));\n    final long mode = readAsciiLong(6, 8);\n    if (mode != 0) {\n        ret.setMode(mode);\n    }\n    ret.setUID(readAsciiLong(6, 8));\n    ret.setGID(readAsciiLong(6, 8));\n    ret.setNumberOfLinks(readAsciiLong(6, 8));\n    ret.setRemoteDevice(readAsciiLong(6, 8));\n    ret.setTime(readAsciiLong(11, 8));\n    long namesize = readAsciiLong(6, 8);\n    ret.setSize(readAsciiLong(11, 8));\n    final String name = readCString((int) namesize);\n    ret.setName(name);\n    if (mode == 0 && !name.equals(CPIO_TRAILER)) {\n        throw new IOException(\"Mode 0 only allowed in the trailer. Found entry: \" + name + \" Occured at byte: \" + getBytesRead());\n    }\n    return ret;\n}", "code_comment": NaN, "code_no_comment": "private CpioArchiveEntry readOldAsciiEntry() throws IOException {\n    CpioArchiveEntry ret = new CpioArchiveEntry(FORMAT_OLD_ASCII);\n    ret.setDevice(readAsciiLong(6, 8));\n    ret.setInode(readAsciiLong(6, 8));\n    final long mode = readAsciiLong(6, 8);\n    if (mode != 0) {\n        ret.setMode(mode);\n    }\n    ret.setUID(readAsciiLong(6, 8));\n    ret.setGID(readAsciiLong(6, 8));\n    ret.setNumberOfLinks(readAsciiLong(6, 8));\n    ret.setRemoteDevice(readAsciiLong(6, 8));\n    ret.setTime(readAsciiLong(11, 8));\n    long namesize = readAsciiLong(6, 8);\n    ret.setSize(readAsciiLong(11, 8));\n    final String name = readCString((int) namesize);\n    ret.setName(name);\n    if (mode == 0 && !name.equals(CPIO_TRAILER)) {\n        throw new IOException(\"Mode 0 only allowed in the trailer. Found entry: \" + name + \" Occured at byte: \" + getBytesRead());\n    }\n    return ret;\n}", "lc": 0.36363636363636365, "pi": -0.61244019138756, "ma": 0.0, "nbd": -0.5, "ml": 0.0, "d": 1.152777777777778, "mi": -0.3581395348837208, "fo": 1.4166666666666667, "r": -0.02631578947368421, "e": 1.4530338917607462}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-848_ad252a8c", "label": 1, "code": "/**\n * Perform a double QR step involving rows l:idx and columns m:n\n *\n * @param l the index of the small sub-diagonal element\n * @param m the start index for the QR step\n * @param idx the current eigenvalue index\n * @param shift shift information holder\n * @param hVec the initial houseHolder vector\n */\nprivate void performDoubleQRStep(final int l, final int m, final int idx, final ShiftInfo shift, final double[] hVec) {\n    final int n = matrixT.length;\n    double p = hVec[0];\n    double q = hVec[1];\n    double r = hVec[2];\n    for (int k = m; k <= idx - 1; k++) {\n        boolean notlast = k != idx - 1;\n        if (k != m) {\n            p = matrixT[k][k - 1];\n            q = matrixT[k + 1][k - 1];\n            r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n            shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n            if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                p = p / shift.x;\n                q = q / shift.x;\n                r = r / shift.x;\n            }\n        }\n        if (Precision.equals(shift.x, 0.0, epsilon)) {\n            break;\n        }\n        double s = FastMath.sqrt(p * p + q * q + r * r);\n        if (p < 0.0) {\n            s = -s;\n        }\n        if (!Precision.equals(s, 0.0, epsilon)) {\n            if (k != m) {\n                matrixT[k][k - 1] = -s * shift.x;\n            } else if (l != m) {\n                matrixT[k][k - 1] = -matrixT[k][k - 1];\n            }\n            p = p + s;\n            shift.x = p / s;\n            shift.y = q / s;\n            double z = r / s;\n            q = q / p;\n            r = r / p;\n            // Row modification\n            for (int j = k; j < n; j++) {\n                p = matrixT[k][j] + q * matrixT[k + 1][j];\n                if (notlast) {\n                    p = p + r * matrixT[k + 2][j];\n                    matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                }\n                matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n            }\n            // Column modification\n            for (int i = 0; i <= FastMath.min(idx, k + 3); i++) {\n                p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                if (notlast) {\n                    p = p + z * matrixT[i][k + 2];\n                    matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                }\n                matrixT[i][k] = matrixT[i][k] - p;\n                matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n            }\n            // Accumulate transformations\n            final int high = matrixT.length - 1;\n            for (int i = 0; i <= high; i++) {\n                p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                if (notlast) {\n                    p = p + z * matrixP[i][k + 2];\n                    matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                }\n                matrixP[i][k] = matrixP[i][k] - p;\n                matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n            }\n        }\n    // (s != 0)\n    }\n    // clean up pollution due to round-off errors\n    for (int i = m + 2; i <= idx; i++) {\n        matrixT[i][i - 2] = 0.0;\n        if (i > m + 2) {\n            matrixT[i][i - 3] = 0.0;\n        }\n    }\n}", "code_comment": "/**\n * Perform a double QR step involving rows l:idx and columns m:n\n *\n * @param l the index of the small sub-diagonal element\n * @param m the start index for the QR step\n * @param idx the current eigenvalue index\n * @param shift shift information holder\n * @param hVec the initial houseHolder vector\n */\n", "code_no_comment": "private void performDoubleQRStep(final int l, final int m, final int idx, final ShiftInfo shift, final double[] hVec) {\n    final int n = matrixT.length;\n    double p = hVec[0];\n    double q = hVec[1];\n    double r = hVec[2];\n    for (int k = m; k <= idx - 1; k++) {\n        boolean notlast = k != idx - 1;\n        if (k != m) {\n            p = matrixT[k][k - 1];\n            q = matrixT[k + 1][k - 1];\n            r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n            shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n            if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                p = p / shift.x;\n                q = q / shift.x;\n                r = r / shift.x;\n            }\n        }\n        if (Precision.equals(shift.x, 0.0, epsilon)) {\n            break;\n        }\n        double s = FastMath.sqrt(p * p + q * q + r * r);\n        if (p < 0.0) {\n            s = -s;\n        }\n        if (!Precision.equals(s, 0.0, epsilon)) {\n            if (k != m) {\n                matrixT[k][k - 1] = -s * shift.x;\n            } else if (l != m) {\n                matrixT[k][k - 1] = -matrixT[k][k - 1];\n            }\n            p = p + s;\n            shift.x = p / s;\n            shift.y = q / s;\n            double z = r / s;\n            q = q / p;\n            r = r / p;\n                        for (int j = k; j < n; j++) {\n                p = matrixT[k][j] + q * matrixT[k + 1][j];\n                if (notlast) {\n                    p = p + r * matrixT[k + 2][j];\n                    matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                }\n                matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n            }\n                        for (int i = 0; i <= FastMath.min(idx, k + 3); i++) {\n                p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                if (notlast) {\n                    p = p + z * matrixT[i][k + 2];\n                    matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                }\n                matrixT[i][k] = matrixT[i][k] - p;\n                matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n            }\n                        final int high = matrixT.length - 1;\n            for (int i = 0; i <= high; i++) {\n                p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                if (notlast) {\n                    p = p + z * matrixP[i][k + 2];\n                    matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                }\n                matrixP[i][k] = matrixP[i][k] - p;\n                matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n            }\n        }\n        }\n        for (int i = m + 2; i <= idx; i++) {\n        matrixT[i][i - 2] = 0.0;\n        if (i > m + 2) {\n            matrixT[i][i - 3] = 0.0;\n        }\n    }\n}", "lc": 2.727272727272727, "pi": 0.8708133971291864, "ma": 3.0, "nbd": 1.0, "ml": 2.3333333333333335, "d": 8.619047619047619, "mi": -1.2649753347427763, "fo": 0.16666666666666666, "r": -0.02631578947368421, "e": 54.56550889507442}
{"project_name": "Closure", "project_version": 53, "label": 2, "code": "/**\n * Replaces an assignment like x = {...} with t1=a,t2=b,t3=c,true.\n * Note that the resulting expression will always evaluate to\n * true, as would the x = {...} expression.\n */\nprivate void replaceAssignmentExpression(Var v, Reference ref, Map<String, String> varmap) {\n    // Compute all of the assignments necessary\n    List<Node> nodes = Lists.newArrayList();\n    Node val = ref.getAssignedValue();\n    blacklistVarReferencesInTree(val, v.scope);\n    Preconditions.checkState(val.getType() == Token.OBJECTLIT);\n    Set<String> all = Sets.newLinkedHashSet(varmap.keySet());\n    for (Node key = val.getFirstChild(); key != null; key = key.getNext()) {\n        String var = key.getString();\n        Node value = key.removeFirstChild();\n        // TODO(user): Copy type information.\n        nodes.add(new Node(Token.ASSIGN, Node.newString(Token.NAME, varmap.get(var)), value));\n        all.remove(var);\n    }\n    // TODO(user): Better source information.\n    for (String var : all) {\n        nodes.add(new Node(Token.ASSIGN, Node.newString(Token.NAME, varmap.get(var)), NodeUtil.newUndefinedNode(null)));\n    }\n    Node replacement;\n    // All assignments evaluate to true, so make sure that the\n    // expr statement evaluates to true in case it matters.\n    nodes.add(new Node(Token.TRUE));\n    // Join these using COMMA.  A COMMA node must have 2 children, so we\n    // create a tree. In the tree the first child be the COMMA to match\n    // the parser, otherwise tree equality tests fail.\n    nodes = Lists.reverse(nodes);\n    replacement = new Node(Token.COMMA);\n    Node cur = replacement;\n    int i;\n    for (i = 0; i < nodes.size() - 2; i++) {\n        cur.addChildToFront(nodes.get(i));\n        Node t = new Node(Token.COMMA);\n        cur.addChildToFront(t);\n        cur = t;\n    }\n    cur.addChildToFront(nodes.get(i));\n    cur.addChildToFront(nodes.get(i + 1));\n    Node replace = ref.getParent();\n    replacement.copyInformationFromForTree(replace);\n    if (replace.getType() == Token.VAR) {\n        replace.getParent().replaceChild(replace, NodeUtil.newExpr(replacement));\n    } else {\n        replace.getParent().replaceChild(replace, replacement);\n    }\n}", "code_comment": "/**\n * Replaces an assignment like x = {...} with t1=a,t2=b,t3=c,true.\n * Note that the resulting expression will always evaluate to\n * true, as would the x = {...} expression.\n */\n", "code_no_comment": "private void replaceAssignmentExpression(Var v, Reference ref, Map<String, String> varmap) {\n        List<Node> nodes = Lists.newArrayList();\n    Node val = ref.getAssignedValue();\n    blacklistVarReferencesInTree(val, v.scope);\n    Preconditions.checkState(val.getType() == Token.OBJECTLIT);\n    Set<String> all = Sets.newLinkedHashSet(varmap.keySet());\n    for (Node key = val.getFirstChild(); key != null; key = key.getNext()) {\n        String var = key.getString();\n        Node value = key.removeFirstChild();\n                nodes.add(new Node(Token.ASSIGN, Node.newString(Token.NAME, varmap.get(var)), value));\n        all.remove(var);\n    }\n        for (String var : all) {\n        nodes.add(new Node(Token.ASSIGN, Node.newString(Token.NAME, varmap.get(var)), NodeUtil.newUndefinedNode(null)));\n    }\n    Node replacement;\n            nodes.add(new Node(Token.TRUE));\n                nodes = Lists.reverse(nodes);\n    replacement = new Node(Token.COMMA);\n    Node cur = replacement;\n    int i;\n    for (i = 0; i < nodes.size() - 2; i++) {\n        cur.addChildToFront(nodes.get(i));\n        Node t = new Node(Token.COMMA);\n        cur.addChildToFront(t);\n        cur = t;\n    }\n    cur.addChildToFront(nodes.get(i));\n    cur.addChildToFront(nodes.get(i + 1));\n    Node replace = ref.getParent();\n    replacement.copyInformationFromForTree(replace);\n    if (replace.getType() == Token.VAR) {\n        replace.getParent().replaceChild(replace, NodeUtil.newExpr(replacement));\n    } else {\n        replace.getParent().replaceChild(replace, replacement);\n    }\n}", "lc": 1.0454545454545454, "pi": -0.3971291866028709, "ma": 0.2, "nbd": -0.5, "ml": 0.16666666666666666, "d": 1.1904761904761905, "mi": -0.73276955602537, "fo": 2.5833333333333335, "r": -0.02631578947368421, "e": 3.877053762325455}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3110_d10362c0", "label": 1, "code": "@Override\npublic IndexOutput createOutput(String name, IOContext context) throws IOException {\n    COWFileReference ref = fileMap.remove(name);\n    if (ref != null) {\n        ref.delete();\n    }\n    ref = new COWLocalFileReference(name);\n    fileMap.put(name, ref);\n    return ref.createOutput(context);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic IndexOutput createOutput(String name, IOContext context) throws IOException {\n    COWFileReference ref = fileMap.remove(name);\n    if (ref != null) {\n        ref.delete();\n    }\n    ref = new COWLocalFileReference(name);\n    fileMap.put(name, ref);\n    return ref.createOutput(context);\n}", "lc": -0.18181818181818182, "pi": -0.2822966507177035, "ma": -0.4, "nbd": -0.5, "ml": -0.25, "d": -0.03769841269841273, "mi": 0.19774489076814655, "fo": -0.16666666666666666, "r": 0.02631578947368421, "e": -0.0627997441261389}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-3395_8433e6db", "label": 3, "code": "@SuppressWarnings(\"unchecked\")\nprivate Iterable<ProcessorExchangePair> createProcessorExchangePairsIterable(final Exchange exchange, final Object value) {\n    final Iterator iterator = ObjectHelper.createIterator(value);\n    return new Iterable() {\n\n        public Iterator iterator() {\n            return new Iterator() {\n\n                private int index;\n\n                private boolean closed;\n\n                public boolean hasNext() {\n                    if (closed) {\n                        return false;\n                    }\n                    boolean answer = iterator.hasNext();\n                    if (!answer) {\n                        // we are now closed\n                        closed = true;\n                        // nothing more so we need to close the expression value in case it needs to be\n                        if (value instanceof Closeable) {\n                            IOHelper.close((Closeable) value, value.getClass().getName(), LOG);\n                        } else if (value instanceof Scanner) {\n                            // special for Scanner as it does not implement Closeable\n                            ((Scanner) value).close();\n                        }\n                    }\n                    return answer;\n                }\n\n                public Object next() {\n                    Object part = iterator.next();\n                    Exchange newExchange = exchange.copy();\n                    if (part instanceof Message) {\n                        newExchange.setIn((Message) part);\n                    } else {\n                        Message in = newExchange.getIn();\n                        in.setBody(part);\n                    }\n                    return createProcessorExchangePair(index++, getProcessors().iterator().next(), newExchange);\n                }\n\n                public void remove() {\n                    throw new UnsupportedOperationException(\"Remove is not supported by this iterator\");\n                }\n            };\n        }\n    };\n}", "code_comment": NaN, "code_no_comment": "@SuppressWarnings(\"unchecked\")\nprivate Iterable<ProcessorExchangePair> createProcessorExchangePairsIterable(final Exchange exchange, final Object value) {\n    final Iterator iterator = ObjectHelper.createIterator(value);\n    return new Iterable() {\n\n        public Iterator iterator() {\n            return new Iterator() {\n\n                private int index;\n\n                private boolean closed;\n\n                public boolean hasNext() {\n                    if (closed) {\n                        return false;\n                    }\n                    boolean answer = iterator.hasNext();\n                    if (!answer) {\n                                                closed = true;\n                                                if (value instanceof Closeable) {\n                            IOHelper.close((Closeable) value, value.getClass().getName(), LOG);\n                        } else if (value instanceof Scanner) {\n                                                        ((Scanner) value).close();\n                        }\n                    }\n                    return answer;\n                }\n\n                public Object next() {\n                    Object part = iterator.next();\n                    Exchange newExchange = exchange.copy();\n                    if (part instanceof Message) {\n                        newExchange.setIn((Message) part);\n                    } else {\n                        Message in = newExchange.getIn();\n                        in.setBody(part);\n                    }\n                    return createProcessorExchangePair(index++, getProcessors().iterator().next(), newExchange);\n                }\n\n                public void remove() {\n                    throw new UnsupportedOperationException(\"Remove is not supported by this iterator\");\n                }\n            };\n        }\n    };\n}", "lc": 1.2272727272727273, "pi": 2.186602870813397, "ma": 0.6, "nbd": 1.5, "ml": 0.3333333333333333, "d": 0.011904761904761871, "mi": -0.665398167723749, "fo": 0.75, "r": -0.02631578947368421, "e": 0.24901137025062955}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1364_b481a14c", "label": 1, "code": "/**\n * Try to find an entry in the map.\n *\n * @param key the key\n * @param hash the hash\n * @return the entry (might be a non-resident)\n */\nEntry<K, V> find(Object key, int hash) {\n    int index = hash & mask;\n    Entry<K, V> e = entries[index];\n    while (e != null && !e.key.equals(key)) {\n        e = e.mapNext;\n    }\n    return e;\n}", "code_comment": "/**\n * Try to find an entry in the map.\n *\n * @param key the key\n * @param hash the hash\n * @return the entry (might be a non-resident)\n */\n", "code_no_comment": "Entry<K, V> find(Object key, int hash) {\n    int index = hash & mask;\n    Entry<K, V> e = entries[index];\n    while (e != null && !e.key.equals(key)) {\n        e = e.mapNext;\n    }\n    return e;\n}", "lc": -0.2727272727272727, "pi": -0.2822966507177035, "ma": -0.4, "nbd": -0.5, "ml": 0.0, "d": 0.3492063492063492, "mi": 0.2834390415785766, "fo": -0.4166666666666667, "r": 1.8421052631578947, "e": 0.08109357260997099}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-1058_c8fd3c53", "label": 3, "code": "@Override\npublic boolean contains(final org.slf4j.Marker marker) {\n    return this.marker.isInstanceOf(marker.getName());\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean contains(final org.slf4j.Marker marker) {\n    return this.marker.isInstanceOf(marker.getName());\n}", "lc": -0.45454545454545453, "pi": -0.6028708133971293, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.8173361522198731, "fo": -0.3333333333333333, "r": 0.13157894736842105, "e": -0.16279340490885932}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-172_99e22ce4", "label": 1, "code": "/**\n *  Get a child component by looking it up with the given path.\n *\n *  @param path\n *             Path to component\n *  @return The component at the path\n */\n@Override\npublic final Component get(final String path) {\n    // Reference to this container\n    if (path == null || path.trim().equals(\"\")) {\n        return this;\n    }\n    // Get child's id, if any\n    final String id = Strings.firstPathComponent(path, Component.PATH_SEPARATOR);\n    // Get child by id\n    Component child = children_get(id);\n    // optimization.\n    if ((child == null) && isTransparentResolver() && (getParent() != null)) {\n        // IComponentResolver if they want to be transparent.\n        if (path.startsWith(\"_\") == false) {\n            child = getParent().get(path);\n        }\n    }\n    // Found child?\n    final String path2 = Strings.afterFirstPathComponent(path, Component.PATH_SEPARATOR);\n    if (child != null) {\n        // Recurse on latter part of path\n        return child.get(path2);\n    }\n    return child;\n}", "code_comment": "/**\n *  Get a child component by looking it up with the given path.\n *\n *  @param path\n *             Path to component\n *  @return The component at the path\n */\n", "code_no_comment": "@Override\npublic final Component get(final String path) {\n        if (path == null || path.trim().equals(\"\")) {\n        return this;\n    }\n        final String id = Strings.firstPathComponent(path, Component.PATH_SEPARATOR);\n        Component child = children_get(id);\n        if ((child == null) && isTransparentResolver() && (getParent() != null)) {\n                if (path.startsWith(\"_\") == false) {\n            child = getParent().get(path);\n        }\n    }\n        final String path2 = Strings.afterFirstPathComponent(path, Component.PATH_SEPARATOR);\n    if (child != null) {\n                return child.get(path2);\n    }\n    return child;\n}", "lc": 0.18181818181818182, "pi": 0.0334928229665071, "ma": 0.2, "nbd": 0.0, "ml": 0.6666666666666666, "d": 0.4801587301587301, "mi": -0.2050739957716703, "fo": 0.4166666666666667, "r": 0.05263157894736841, "e": 0.40382197172709083}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-172_99e22ce4", "label": 1, "code": "/**\n *  Traverses all child components of the given class in this container,\n *  calling the visitor's visit method at each one.\n *\n *  @param clazz\n *             The class of child to visit, or null to visit all children\n *  @param visitor\n *             The visitor to call back to\n *  @return The return value from a visitor which halted the traversal, or\n *          null if the entire traversal occurred\n */\npublic final Object visitChildren(final Class clazz, final IVisitor visitor) {\n    if (visitor == null) {\n        throw new IllegalArgumentException(\"argument visitor may not be null\");\n    }\n    // Iterate through children of this container\n    for (int i = 0; i < children_size(); i++) {\n        // Get next child component\n        final Component child = children_get(i);\n        Object value = null;\n        // Is the child of the correct class (or was no class specified)?\n        if (clazz == null || clazz.isInstance(child)) {\n            // Call visitor\n            value = visitor.component(child);\n            // If visitor returns a non-null value, it halts the traversal\n            if ((value != IVisitor.CONTINUE_TRAVERSAL) && (value != IVisitor.CONTINUE_TRAVERSAL_BUT_DONT_GO_DEEPER)) {\n                return value;\n            }\n        }\n        // If child is a container\n        if ((child instanceof MarkupContainer) && (value != IVisitor.CONTINUE_TRAVERSAL_BUT_DONT_GO_DEEPER)) {\n            // visit the children in the container\n            value = ((MarkupContainer<?>) child).visitChildren(clazz, visitor);\n            // If visitor returns a non-null value, it halts the traversal\n            if ((value != IVisitor.CONTINUE_TRAVERSAL) && (value != IVisitor.CONTINUE_TRAVERSAL_BUT_DONT_GO_DEEPER)) {\n                return value;\n            }\n        }\n    }\n    return null;\n}", "code_comment": "/**\n *  Traverses all child components of the given class in this container,\n *  calling the visitor's visit method at each one.\n *\n *  @param clazz\n *             The class of child to visit, or null to visit all children\n *  @param visitor\n *             The visitor to call back to\n *  @return The return value from a visitor which halted the traversal, or\n *          null if the entire traversal occurred\n */\n", "code_no_comment": "public final Object visitChildren(final Class clazz, final IVisitor visitor) {\n    if (visitor == null) {\n        throw new IllegalArgumentException(\"argument visitor may not be null\");\n    }\n        for (int i = 0; i < children_size(); i++) {\n                final Component child = children_get(i);\n        Object value = null;\n                if (clazz == null || clazz.isInstance(child)) {\n                        value = visitor.component(child);\n                        if ((value != IVisitor.CONTINUE_TRAVERSAL) && (value != IVisitor.CONTINUE_TRAVERSAL_BUT_DONT_GO_DEEPER)) {\n                return value;\n            }\n        }\n                if ((child instanceof MarkupContainer) && (value != IVisitor.CONTINUE_TRAVERSAL_BUT_DONT_GO_DEEPER)) {\n                        value = ((MarkupContainer<?>) child).visitChildren(clazz, visitor);\n                        if ((value != IVisitor.CONTINUE_TRAVERSAL) && (value != IVisitor.CONTINUE_TRAVERSAL_BUT_DONT_GO_DEEPER)) {\n                return value;\n            }\n        }\n    }\n    return null;\n}", "lc": 0.36363636363636365, "pi": 0.6889952153110046, "ma": 0.8, "nbd": 0.5, "ml": 1.0, "d": 1.2043650793650793, "mi": -0.3522198731501058, "fo": -0.08333333333333333, "r": -0.02631578947368421, "e": 1.1834673213349238}
{"project_name": "Closure", "project_version": 69, "label": 2, "code": "/**\n * Visits a CALL node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n */\nprivate void visitCall(NodeTraversal t, Node n) {\n    Node child = n.getFirstChild();\n    JSType childType = getJSType(child).restrictByNotNullOrUndefined();\n    if (!childType.canBeCalled()) {\n        report(t, n, NOT_CALLABLE, childType.toString());\n        ensureTyped(t, n);\n        return;\n    }\n    // If it is a function type, then validate parameters.\n    if (childType instanceof FunctionType) {\n        FunctionType functionType = (FunctionType) childType;\n        boolean isExtern = false;\n        JSDocInfo functionJSDocInfo = functionType.getJSDocInfo();\n        if (functionJSDocInfo != null) {\n            String sourceName = functionJSDocInfo.getSourceName();\n            CompilerInput functionSource = compiler.getInput(sourceName);\n            isExtern = functionSource.isExtern();\n        }\n        // in an extern.\n        if (functionType.isConstructor() && !functionType.isNativeObjectType() && (functionType.getReturnType().isUnknownType() || functionType.getReturnType().isVoidType() || !isExtern)) {\n            report(t, n, CONSTRUCTOR_NOT_CALLABLE, childType.toString());\n        }\n        // Functions with explcit 'this' types must be called in a GETPROP\n        // or GETELEM.\n        visitParameterList(t, n, functionType);\n        ensureTyped(t, n, functionType.getReturnType());\n    } else {\n        ensureTyped(t, n);\n    }\n// TODO: Add something to check for calls of RegExp objects, which is not\n// supported by IE.  Either say something about the return type or warn\n// about the non-portability of the call or both.\n}", "code_comment": "/**\n * Visits a CALL node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n */\n", "code_no_comment": "private void visitCall(NodeTraversal t, Node n) {\n    Node child = n.getFirstChild();\n    JSType childType = getJSType(child).restrictByNotNullOrUndefined();\n    if (!childType.canBeCalled()) {\n        report(t, n, NOT_CALLABLE, childType.toString());\n        ensureTyped(t, n);\n        return;\n    }\n        if (childType instanceof FunctionType) {\n        FunctionType functionType = (FunctionType) childType;\n        boolean isExtern = false;\n        JSDocInfo functionJSDocInfo = functionType.getJSDocInfo();\n        if (functionJSDocInfo != null) {\n            String sourceName = functionJSDocInfo.getSourceName();\n            CompilerInput functionSource = compiler.getInput(sourceName);\n            isExtern = functionSource.isExtern();\n        }\n                if (functionType.isConstructor() && !functionType.isNativeObjectType() && (functionType.getReturnType().isUnknownType() || functionType.getReturnType().isVoidType() || !isExtern)) {\n            report(t, n, CONSTRUCTOR_NOT_CALLABLE, childType.toString());\n        }\n                        visitParameterList(t, n, functionType);\n        ensureTyped(t, n, functionType.getReturnType());\n    } else {\n        ensureTyped(t, n);\n    }\n}", "lc": 0.5454545454545454, "pi": 0.12440191387559799, "ma": 0.2, "nbd": 0.0, "ml": 0.9166666666666666, "d": 0.4583333333333334, "mi": -0.45905567300916117, "fo": 1.4166666666666667, "r": -0.02631578947368421, "e": 0.8304489894711363}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2389_8079f7b5", "label": 1, "code": "/**\n * Escape a string into the target buffer.\n *\n * @param s      the string to escape\n * @param length the number of characters.\n * @param buff   the target buffer\n */\nprivate static void escape(String s, int length, StringBuilder buff) {\n    for (int i = 0; i < length; i++) {\n        char c = s.charAt(i);\n        switch(c) {\n            case '\"':\n                // quotation mark\n                buff.append(\"\\\\\\\"\");\n                break;\n            case '\\\\':\n                // backslash\n                buff.append(\"\\\\\\\\\");\n                break;\n            case '\\b':\n                // backspace\n                buff.append(\"\\\\b\");\n                break;\n            case '\\f':\n                // formfeed\n                buff.append(\"\\\\f\");\n                break;\n            case '\\n':\n                // newline\n                buff.append(\"\\\\n\");\n                break;\n            case '\\r':\n                // carriage return\n                buff.append(\"\\\\r\");\n                break;\n            case '\\t':\n                // horizontal tab\n                buff.append(\"\\\\t\");\n                break;\n            default:\n                if (c < ' ') {\n                    buff.append(\"\\\\u00\");\n                    // guaranteed to be 1 or 2 hex digits only\n                    buff.append(Character.forDigit(c >>> 4, 16));\n                    buff.append(Character.forDigit(c & 15, 16));\n                } else {\n                    buff.append(c);\n                }\n        }\n    }\n}", "code_comment": "/**\n * Escape a string into the target buffer.\n *\n * @param s      the string to escape\n * @param length the number of characters.\n * @param buff   the target buffer\n */\n", "code_no_comment": "private static void escape(String s, int length, StringBuilder buff) {\n    for (int i = 0; i < length; i++) {\n        char c = s.charAt(i);\n        switch(c) {\n            case '\"':\n                                buff.append(\"\\\\\\\"\");\n                break;\n            case '\\\\':\n                                buff.append(\"\\\\\\\\\");\n                break;\n            case '\\b':\n                                buff.append(\"\\\\b\");\n                break;\n            case '\\f':\n                                buff.append(\"\\\\f\");\n                break;\n            case '\\n':\n                                buff.append(\"\\\\n\");\n                break;\n            case '\\r':\n                                buff.append(\"\\\\r\");\n                break;\n            case '\\t':\n                                buff.append(\"\\\\t\");\n                break;\n            default:\n                if (c < ' ') {\n                    buff.append(\"\\\\u00\");\n                                        buff.append(Character.forDigit(c >>> 4, 16));\n                    buff.append(Character.forDigit(c & 15, 16));\n                } else {\n                    buff.append(c);\n                }\n        }\n    }\n}", "lc": 1.0, "pi": 1.0, "ma": 2.8, "nbd": 1.0, "ml": 0.5833333333333334, "d": 0.4404761904761904, "mi": -0.6493305144467932, "fo": 0.6666666666666666, "r": -0.02631578947368421, "e": 0.5642203050892388}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-4211_4efddb3f", "label": 1, "code": "public static Map<String, Object> parseQuery(String uri) throws URISyntaxException {\n    // must check for trailing & as the uri.split(\"&\") will ignore those\n    if (uri != null && uri.endsWith(\"&\")) {\n        throw new URISyntaxException(uri, \"Invalid uri syntax: Trailing & marker found. \" + \"Check the uri and remove the trailing & marker.\");\n    }\n    try {\n        // use a linked map so the parameters is in the same order\n        Map<String, Object> rc = new LinkedHashMap<String, Object>();\n        if (uri != null) {\n            String[] parameters = uri.split(\"&\");\n            for (String parameter : parameters) {\n                int p = parameter.indexOf(\"=\");\n                if (p >= 0) {\n                    String name = URLDecoder.decode(parameter.substring(0, p), CHARSET);\n                    String value = URLDecoder.decode(parameter.substring(p + 1), CHARSET);\n                    rc.put(name, value);\n                } else {\n                    rc.put(parameter, null);\n                }\n            }\n        }\n        return rc;\n    } catch (UnsupportedEncodingException e) {\n        URISyntaxException se = new URISyntaxException(e.toString(), \"Invalid encoding\");\n        se.initCause(e);\n        throw se;\n    }\n}", "code_comment": NaN, "code_no_comment": "public static Map<String, Object> parseQuery(String uri) throws URISyntaxException {\n        if (uri != null && uri.endsWith(\"&\")) {\n        throw new URISyntaxException(uri, \"Invalid uri syntax: Trailing & marker found. \" + \"Check the uri and remove the trailing & marker.\");\n    }\n    try {\n                Map<String, Object> rc = new LinkedHashMap<String, Object>();\n        if (uri != null) {\n            String[] parameters = uri.split(\"&\");\n            for (String parameter : parameters) {\n                int p = parameter.indexOf(\"=\");\n                if (p >= 0) {\n                    String name = URLDecoder.decode(parameter.substring(0, p), CHARSET);\n                    String value = URLDecoder.decode(parameter.substring(p + 1), CHARSET);\n                    rc.put(name, value);\n                } else {\n                    rc.put(parameter, null);\n                }\n            }\n        }\n        return rc;\n    } catch (UnsupportedEncodingException e) {\n        URISyntaxException se = new URISyntaxException(e.toString(), \"Invalid encoding\");\n        se.initCause(e);\n        throw se;\n    }\n}", "lc": 0.5454545454545454, "pi": 1.4880382775119616, "ma": 0.8, "nbd": 1.0, "ml": 0.16666666666666666, "d": 0.5297619047619048, "mi": -0.4683579985905565, "fo": 0.4166666666666667, "r": -0.02631578947368421, "e": 0.8451421425401818}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3511_4a875f46", "label": 1, "code": "/**\n *  Make a copy before returning an item from the cache as resource streams are not thread-safe.\n *\n *  @param key\n *             the cache key\n *  @return the cached File or Url resource stream\n */\nprivate IResourceStream getCopyFromCache(Key key) {\n    final IResourceStreamReference orig = cache.get(key);\n    if (NullResourceStreamReference.INSTANCE == orig) {\n        return null;\n    }\n    if (orig instanceof UrlResourceStreamReference) {\n        UrlResourceStreamReference resourceStreamReference = (UrlResourceStreamReference) orig;\n        String url = resourceStreamReference.getReference();\n        try {\n            return new UrlResourceStream(new URL(url));\n        } catch (MalformedURLException e) {\n            return null;\n        }\n    }\n    if (orig instanceof FileResourceStreamReference) {\n        FileResourceStreamReference resourceStreamReference = (FileResourceStreamReference) orig;\n        String absolutePath = resourceStreamReference.getReference();\n        return new FileResourceStream(new File(absolutePath));\n    }\n    return null;\n}", "code_comment": "/**\n *  Make a copy before returning an item from the cache as resource streams are not thread-safe.\n *\n *  @param key\n *             the cache key\n *  @return the cached File or Url resource stream\n */\n", "code_no_comment": "private IResourceStream getCopyFromCache(Key key) {\n    final IResourceStreamReference orig = cache.get(key);\n    if (NullResourceStreamReference.INSTANCE == orig) {\n        return null;\n    }\n    if (orig instanceof UrlResourceStreamReference) {\n        UrlResourceStreamReference resourceStreamReference = (UrlResourceStreamReference) orig;\n        String url = resourceStreamReference.getReference();\n        try {\n            return new UrlResourceStream(new URL(url));\n        } catch (MalformedURLException e) {\n            return null;\n        }\n    }\n    if (orig instanceof FileResourceStreamReference) {\n        FileResourceStreamReference resourceStreamReference = (FileResourceStreamReference) orig;\n        String absolutePath = resourceStreamReference.getReference();\n        return new FileResourceStream(new File(absolutePath));\n    }\n    return null;\n}", "lc": 0.3181818181818182, "pi": 0.09090909090909088, "ma": 0.2, "nbd": 0.0, "ml": -0.08333333333333333, "d": -0.015873015873015886, "mi": -0.24707540521494006, "fo": -0.25, "r": -0.02631578947368421, "e": 0.03011704500267975}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-4474_06a8489a", "label": 1, "code": "public FileConsumer createConsumer(Processor processor) throws Exception {\n    ObjectHelper.notNull(operations, \"operations\");\n    ObjectHelper.notNull(file, \"file\");\n    // we assume its a file if the name has a dot in it (eg foo.txt)\n    boolean isDirectory = file.isDirectory();\n    if (!isDirectory && file.getName().contains(\".\")) {\n        throw new IllegalArgumentException(\"Only directory is supported. Endpoint must be configured with a valid starting directory: \" + file);\n    }\n    // auto create starting directory if needed\n    if (!file.exists() && !isDirectory) {\n        if (isAutoCreate()) {\n            log.debug(\"Creating non existing starting directory: {}\", file);\n            boolean absolute = FileUtil.isAbsolute(file);\n            operations.buildDirectory(file.getPath(), absolute);\n        } else if (isStartingDirectoryMustExist()) {\n            throw new FileNotFoundException(\"Starting directory does not exist: \" + file);\n        }\n    }\n    FileConsumer result = new FileConsumer(this, processor, operations);\n    if (isDelete() && getMove() != null) {\n        throw new IllegalArgumentException(\"You cannot set both delete=true and move options\");\n    }\n    // if noop=true then idempotent should also be configured\n    if (isNoop() && !isIdempotentSet()) {\n        log.info(\"Endpoint is configured with noop=true so forcing endpoint to be idempotent as well\");\n        setIdempotent(true);\n    }\n    // if idempotent and no repository set then create a default one\n    if (isIdempotentSet() && isIdempotent() && idempotentRepository == null) {\n        log.info(\"Using default memory based idempotent repository with cache max size: \" + DEFAULT_IDEMPOTENT_CACHE_SIZE);\n        idempotentRepository = MemoryIdempotentRepository.memoryIdempotentRepository(DEFAULT_IDEMPOTENT_CACHE_SIZE);\n    }\n    // set max messages per poll\n    result.setMaxMessagesPerPoll(getMaxMessagesPerPoll());\n    configureConsumer(result);\n    return result;\n}", "code_comment": NaN, "code_no_comment": "public FileConsumer createConsumer(Processor processor) throws Exception {\n    ObjectHelper.notNull(operations, \"operations\");\n    ObjectHelper.notNull(file, \"file\");\n        boolean isDirectory = file.isDirectory();\n    if (!isDirectory && file.getName().contains(\".\")) {\n        throw new IllegalArgumentException(\"Only directory is supported. Endpoint must be configured with a valid starting directory: \" + file);\n    }\n        if (!file.exists() && !isDirectory) {\n        if (isAutoCreate()) {\n            log.debug(\"Creating non existing starting directory: {}\", file);\n            boolean absolute = FileUtil.isAbsolute(file);\n            operations.buildDirectory(file.getPath(), absolute);\n        } else if (isStartingDirectoryMustExist()) {\n            throw new FileNotFoundException(\"Starting directory does not exist: \" + file);\n        }\n    }\n    FileConsumer result = new FileConsumer(this, processor, operations);\n    if (isDelete() && getMove() != null) {\n        throw new IllegalArgumentException(\"You cannot set both delete=true and move options\");\n    }\n        if (isNoop() && !isIdempotentSet()) {\n        log.info(\"Endpoint is configured with noop=true so forcing endpoint to be idempotent as well\");\n        setIdempotent(true);\n    }\n        if (isIdempotentSet() && isIdempotent() && idempotentRepository == null) {\n        log.info(\"Using default memory based idempotent repository with cache max size: \" + DEFAULT_IDEMPOTENT_CACHE_SIZE);\n        idempotentRepository = MemoryIdempotentRepository.memoryIdempotentRepository(DEFAULT_IDEMPOTENT_CACHE_SIZE);\n    }\n        result.setMaxMessagesPerPoll(getMaxMessagesPerPoll());\n    configureConsumer(result);\n    return result;\n}", "lc": 0.8181818181818182, "pi": 0.08133971291866025, "ma": 1.4, "nbd": 0.5, "ml": 1.5833333333333333, "d": 0.6190476190476191, "mi": -0.6070472163495417, "fo": 1.5833333333333333, "r": -0.02631578947368421, "e": 1.1458100655244547}
{"project_name": "Lang", "project_version": 36, "label": 3, "code": "// -----------------------------------------------------------------------\n// must handle Long, Float, Integer, Float, Short,\n// BigDecimal, BigInteger and Byte\n// useful methods:\n// Byte.decode(String)\n// Byte.valueOf(String,int radix)\n// Byte.valueOf(String)\n// Double.valueOf(String)\n// Float.valueOf(String)\n// new Float(String)\n// Integer.valueOf(String,int radix)\n// Integer.valueOf(String)\n// Integer.decode(String)\n// Integer.getInteger(String)\n// Integer.getInteger(String,int val)\n// Integer.getInteger(String,Integer val)\n// new Integer(String)\n// new Double(String)\n// new Byte(String)\n// new Long(String)\n// Long.getLong(String)\n// Long.getLong(String,int)\n// Long.getLong(String,Integer)\n// Long.valueOf(String,int)\n// Long.valueOf(String)\n// new Short(String)\n// Short.decode(String)\n// Short.valueOf(String,int)\n// Short.valueOf(String)\n// new BigDecimal(String)\n// new BigInteger(String)\n// new BigInteger(String,int radix)\n// Possible inputs:\n// 45 45.5 45E7 4.5E7 Hex Oct Binary xxxF xxxD xxxf xxxd\n// plus minus everything. Prolly more. A lot are not separable.\n/**\n * <p>Turns a string value into a java.lang.Number.</p>\n *\n * <p>First, the value is examined for a type qualifier on the end\n * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts\n * trying to create successively larger types from the type specified\n * until one is found that can represent the value.</p>\n *\n * <p>If a type specifier is not found, it will check for a decimal point\n * and then try successively larger types from <code>Integer</code> to\n * <code>BigInteger</code> and from <code>Float</code> to\n * <code>BigDecimal</code>.</p>\n *\n * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it\n * will be interpreted as a hexadecimal integer.  Values with leading\n * <code>0</code>'s will not be interpreted as octal.</p>\n *\n * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n *\n * <p>This method does not trim the input string, i.e., strings with leading\n * or trailing spaces will generate NumberFormatExceptions.</p>\n *\n * @param str  String containing a number, may be null\n * @return Number created from the string\n * @throws NumberFormatException if the value cannot be converted\n */\npublic static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    if (str.startsWith(\"--\")) {\n        // a wrong value.\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return createInteger(str);\n    }\n    char lastChar = str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos = str.indexOf('.');\n    int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n    if (decPos > -1) {\n        if (expPos > -1) {\n            if (expPos < decPos) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec = str.substring(decPos + 1, expPos);\n        } else {\n            dec = str.substring(decPos + 1);\n        }\n        mant = str.substring(0, decPos);\n    } else {\n        if (expPos > -1) {\n            mant = str.substring(0, expPos);\n        } else {\n            mant = str;\n        }\n        dec = null;\n    }\n    if (!Character.isDigit(lastChar)) {\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp = null;\n        }\n        // Requesting a specific type..\n        String numeric = str.substring(0, str.length() - 1);\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        switch(lastChar) {\n            case 'l':\n            case 'L':\n                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) {\n                    // Too big for a long\n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case 'f':\n            case 'F':\n                try {\n                    Float f = NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        // has non-zeros in it, then float does not have the precision we want\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                // ignore the bad number\n                }\n            // $FALL-THROUGH$\n            case 'd':\n            case 'D':\n                try {\n                    Double d = NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                // ignore the bad number\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) {\n                // ignore the bad number\n                }\n            // $FALL-THROUGH$\n            default:\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    } else {\n        // small and go from there...\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length());\n        } else {\n            exp = null;\n        }\n        if (dec == null && exp == null) {\n            // Must be an int,long,bigint\n            try {\n                return createInteger(str);\n            } catch (NumberFormatException nfe) {\n            // ignore the bad number\n            }\n            try {\n                return createLong(str);\n            } catch (NumberFormatException nfe) {\n            // ignore the bad number\n            }\n            return createBigInteger(str);\n        } else {\n            // Must be a float,double,BigDec\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            try {\n                Float f = createFloat(str);\n                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) {\n            // ignore the bad number\n            }\n            try {\n                Double d = createDouble(str);\n                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) {\n            // ignore the bad number\n            }\n            return createBigDecimal(str);\n        }\n    }\n}", "code_comment": "/**\n * <p>Turns a string value into a java.lang.Number.</p>\n *\n * <p>First, the value is examined for a type qualifier on the end\n * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts\n * trying to create successively larger types from the type specified\n * until one is found that can represent the value.</p>\n *\n * <p>If a type specifier is not found, it will check for a decimal point\n * and then try successively larger types from <code>Integer</code> to\n * <code>BigInteger</code> and from <code>Float</code> to\n * <code>BigDecimal</code>.</p>\n *\n * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it\n * will be interpreted as a hexadecimal integer.  Values with leading\n * <code>0</code>'s will not be interpreted as octal.</p>\n *\n * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n *\n * <p>This method does not trim the input string, i.e., strings with leading\n * or trailing spaces will generate NumberFormatExceptions.</p>\n *\n * @param str  String containing a number, may be null\n * @return Number created from the string\n * @throws NumberFormatException if the value cannot be converted\n */\n", "code_no_comment": "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    if (str.startsWith(\"--\")) {\n                return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return createInteger(str);\n    }\n    char lastChar = str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos = str.indexOf('.');\n    int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n    if (decPos > -1) {\n        if (expPos > -1) {\n            if (expPos < decPos) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec = str.substring(decPos + 1, expPos);\n        } else {\n            dec = str.substring(decPos + 1);\n        }\n        mant = str.substring(0, decPos);\n    } else {\n        if (expPos > -1) {\n            mant = str.substring(0, expPos);\n        } else {\n            mant = str;\n        }\n        dec = null;\n    }\n    if (!Character.isDigit(lastChar)) {\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp = null;\n        }\n                String numeric = str.substring(0, str.length() - 1);\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        switch(lastChar) {\n            case 'l':\n            case 'L':\n                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) {\n                                        }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case 'f':\n            case 'F':\n                try {\n                    Float f = NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                                                return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                                }\n                        case 'd':\n            case 'D':\n                try {\n                    Double d = NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) {\n                                }\n                        default:\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    } else {\n                if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length());\n        } else {\n            exp = null;\n        }\n        if (dec == null && exp == null) {\n                        try {\n                return createInteger(str);\n            } catch (NumberFormatException nfe) {\n                        }\n            try {\n                return createLong(str);\n            } catch (NumberFormatException nfe) {\n                        }\n            return createBigInteger(str);\n        } else {\n                        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            try {\n                Float f = createFloat(str);\n                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) {\n                        }\n            try {\n                Double d = createDouble(str);\n                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) {\n                        }\n            return createBigDecimal(str);\n        }\n    }\n}", "lc": 4.681818181818182, "pi": 1.2057416267942582, "ma": 6.6, "nbd": 1.5, "ml": 4.75, "d": 2.9880952380952377, "mi": -1.550528541226215, "fo": 3.6666666666666665, "r": -0.02631578947368421, "e": 15.336560571221103}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4610_b19a3d69", "label": 1, "code": "/**\n *  Indicate sending of a redirectLocation to a particular named resource. This implementation\n *  just keeps hold of the redirectLocation info and makes it available for query.\n *\n *  @param location\n *             The location to redirectLocation to\n *  @throws IOException\n *              Not used\n */\n@Override\npublic void sendRedirect(String location) throws IOException {\n    redirectLocation = location;\n}", "code_comment": "/**\n *  Indicate sending of a redirectLocation to a particular named resource. This implementation\n *  just keeps hold of the redirectLocation info and makes it available for query.\n *\n *  @param location\n *             The location to redirectLocation to\n *  @throws IOException\n *              Not used\n */\n", "code_no_comment": "@Override\npublic void sendRedirect(String location) throws IOException {\n    redirectLocation = location;\n}", "lc": -0.45454545454545453, "pi": -0.6028708133971293, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.8548273431994357, "fo": -0.5, "r": 2.6052631578947367, "e": -0.16279340490885932}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-309_0596e314", "label": 3, "code": "/**\n * Returns a random value from an Exponential distribution with the given\n * mean.\n * <p>\n * <strong>Algorithm Description</strong>: Uses the <a\n * href=\"http://www.jesus.ox.ac.uk/~clifford/a5/chap1/node5.html\"> Inversion\n * Method</a> to generate exponentially distributed random values from\n * uniform deviates.\n * </p>\n *\n * @param mean\n *            the mean of the distribution\n * @return the random Exponential value\n */\npublic double nextExponential(double mean) {\n    if (mean < 0.0) {\n        throw MathRuntimeException.createIllegalArgumentException(\"mean must be positive ({0})\", mean);\n    }\n    final RandomGenerator generator = getRan();\n    double unif = generator.nextDouble();\n    while (unif == 0.0d) {\n        unif = generator.nextDouble();\n    }\n    return -mean * Math.log(unif);\n}", "code_comment": "/**\n * Returns a random value from an Exponential distribution with the given\n * mean.\n * <p>\n * <strong>Algorithm Description</strong>: Uses the <a\n * href=\"http://www.jesus.ox.ac.uk/~clifford/a5/chap1/node5.html\"> Inversion\n * Method</a> to generate exponentially distributed random values from\n * uniform deviates.\n * </p>\n *\n * @param mean\n *            the mean of the distribution\n * @return the random Exponential value\n */\n", "code_no_comment": "public double nextExponential(double mean) {\n    if (mean < 0.0) {\n        throw MathRuntimeException.createIllegalArgumentException(\"mean must be positive ({0})\", mean);\n    }\n    final RandomGenerator generator = getRan();\n    double unif = generator.nextDouble();\n    while (unif == 0.0d) {\n        unif = generator.nextDouble();\n    }\n    return -mean * Math.log(unif);\n}", "lc": -0.13636363636363635, "pi": -0.2775119617224881, "ma": 0.0, "nbd": -0.5, "ml": -0.08333333333333333, "d": 0.2698412698412699, "mi": 0.13883016208597593, "fo": -0.08333333333333333, "r": 0.2631578947368421, "e": 0.03487030537738512}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-4011_cbffff59", "label": 3, "code": "/**\n * Returns the converted value, or null if the value is null\n */\n@Converter\npublic static Short toShort(Object value) {\n    if (value instanceof Short) {\n        return (Short) value;\n    } else if (value instanceof Number) {\n        Number number = (Number) value;\n        return number.shortValue();\n    } else if (value instanceof String) {\n        return Short.valueOf((String) value);\n    } else {\n        return null;\n    }\n}", "code_comment": "/**\n * Returns the converted value, or null if the value is null\n */\n", "code_no_comment": "@Converter\npublic static Short toShort(Object value) {\n    if (value instanceof Short) {\n        return (Short) value;\n    } else if (value instanceof Number) {\n        Number number = (Number) value;\n        return number.shortValue();\n    } else if (value instanceof String) {\n        return Short.valueOf((String) value);\n    } else {\n        return null;\n    }\n}", "lc": -0.045454545454545456, "pi": 0.04306220095693773, "ma": 0.0, "nbd": 0.5, "ml": -0.08333333333333333, "d": -0.3650793650793651, "mi": 0.11092318534179003, "fo": -0.3333333333333333, "r": 0.2368421052631579, "e": -0.16279340490885932}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3065_b293b75c", "label": 1, "code": "public IRequestHandler mapRequest(Request request) {\n    final Url url = request.getUrl();\n    if (url.getSegments().size() == 0) {\n        final Class<? extends IRequestablePage> homePageClass = getContext().getHomePageClass();\n        final PageProvider pageProvider;\n        if (url.getQueryParameters().size() > 0) {\n            PageParameters pageParameters = extractPageParameters(request, 0, pageParametersEncoder);\n            pageProvider = new PageProvider(homePageClass, pageParameters);\n        } else {\n            pageProvider = new PageProvider(homePageClass);\n        }\n        return new RenderPageRequestHandler(pageProvider);\n    } else {\n        return null;\n    }\n}", "code_comment": NaN, "code_no_comment": "public IRequestHandler mapRequest(Request request) {\n    final Url url = request.getUrl();\n    if (url.getSegments().size() == 0) {\n        final Class<? extends IRequestablePage> homePageClass = getContext().getHomePageClass();\n        final PageProvider pageProvider;\n        if (url.getQueryParameters().size() > 0) {\n            PageParameters pageParameters = extractPageParameters(request, 0, pageParametersEncoder);\n            pageProvider = new PageProvider(homePageClass, pageParameters);\n        } else {\n            pageProvider = new PageProvider(homePageClass);\n        }\n        return new RenderPageRequestHandler(pageProvider);\n    } else {\n        return null;\n    }\n}", "lc": 0.09090909090909091, "pi": 0.325358851674641, "ma": -0.2, "nbd": 0.0, "ml": -0.08333333333333333, "d": -0.047619047619047616, "mi": -0.1024665257223398, "fo": 0.16666666666666666, "r": -0.02631578947368421, "e": 0.0038749906352471873}
{"project_name": "Math", "project_version": 23, "label": 3, "code": "/**\n * {@inheritDoc}\n */\n@Override\nprotected UnivariatePointValuePair doOptimize() {\n    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n    final double lo = getMin();\n    final double mid = getStartValue();\n    final double hi = getMax();\n    // Optional additional convergence criteria.\n    final ConvergenceChecker<UnivariatePointValuePair> checker = getConvergenceChecker();\n    double a;\n    double b;\n    if (lo < hi) {\n        a = lo;\n        b = hi;\n    } else {\n        a = hi;\n        b = lo;\n    }\n    double x = mid;\n    double v = x;\n    double w = x;\n    double d = 0;\n    double e = 0;\n    double fx = computeObjectiveValue(x);\n    if (!isMinim) {\n        fx = -fx;\n    }\n    double fv = fx;\n    double fw = fx;\n    UnivariatePointValuePair previous = null;\n    UnivariatePointValuePair current = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n    // Best point encountered so far (which is the initial guess).\n    int iter = 0;\n    while (true) {\n        final double m = 0.5 * (a + b);\n        final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n        final double tol2 = 2 * tol1;\n        // Default stopping criterion.\n        final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n        if (!stop) {\n            double p = 0;\n            double q = 0;\n            double r = 0;\n            double u = 0;\n            if (FastMath.abs(e) > tol1) {\n                // Fit parabola.\n                r = (x - w) * (fx - fv);\n                q = (x - v) * (fx - fw);\n                p = (x - v) * q - (x - w) * r;\n                q = 2 * (q - r);\n                if (q > 0) {\n                    p = -p;\n                } else {\n                    q = -q;\n                }\n                r = e;\n                e = d;\n                if (p > q * (a - x) && p < q * (b - x) && FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n                    // Parabolic interpolation step.\n                    d = p / q;\n                    u = x + d;\n                    // f must not be evaluated too close to a or b.\n                    if (u - a < tol2 || b - u < tol2) {\n                        if (x <= m) {\n                            d = tol1;\n                        } else {\n                            d = -tol1;\n                        }\n                    }\n                } else {\n                    // Golden section step.\n                    if (x < m) {\n                        e = b - x;\n                    } else {\n                        e = a - x;\n                    }\n                    d = GOLDEN_SECTION * e;\n                }\n            } else {\n                // Golden section step.\n                if (x < m) {\n                    e = b - x;\n                } else {\n                    e = a - x;\n                }\n                d = GOLDEN_SECTION * e;\n            }\n            // Update by at least \"tol1\".\n            if (FastMath.abs(d) < tol1) {\n                if (d >= 0) {\n                    u = x + tol1;\n                } else {\n                    u = x - tol1;\n                }\n            } else {\n                u = x + d;\n            }\n            double fu = computeObjectiveValue(u);\n            if (!isMinim) {\n                fu = -fu;\n            }\n            // User-defined convergence checker.\n            previous = current;\n            current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n            if (checker != null) {\n                if (checker.converged(iter, previous, current)) {\n                    return best(current, previous, isMinim);\n                }\n            }\n            // Update a, b, v, w and x.\n            if (fu <= fx) {\n                if (u < x) {\n                    b = x;\n                } else {\n                    a = x;\n                }\n                v = w;\n                fv = fw;\n                w = x;\n                fw = fx;\n                x = u;\n                fx = fu;\n            } else {\n                if (u < x) {\n                    a = u;\n                } else {\n                    b = u;\n                }\n                if (fu <= fw || Precision.equals(w, x)) {\n                    v = w;\n                    fv = fw;\n                    w = u;\n                    fw = fu;\n                } else if (fu <= fv || Precision.equals(v, x) || Precision.equals(v, w)) {\n                    v = u;\n                    fv = fu;\n                }\n            }\n        } else {\n            // Default termination (Brent's criterion).\n            return best(current, previous, isMinim);\n        }\n        ++iter;\n    }\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "@Override\nprotected UnivariatePointValuePair doOptimize() {\n    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n    final double lo = getMin();\n    final double mid = getStartValue();\n    final double hi = getMax();\n        final ConvergenceChecker<UnivariatePointValuePair> checker = getConvergenceChecker();\n    double a;\n    double b;\n    if (lo < hi) {\n        a = lo;\n        b = hi;\n    } else {\n        a = hi;\n        b = lo;\n    }\n    double x = mid;\n    double v = x;\n    double w = x;\n    double d = 0;\n    double e = 0;\n    double fx = computeObjectiveValue(x);\n    if (!isMinim) {\n        fx = -fx;\n    }\n    double fv = fx;\n    double fw = fx;\n    UnivariatePointValuePair previous = null;\n    UnivariatePointValuePair current = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n        int iter = 0;\n    while (true) {\n        final double m = 0.5 * (a + b);\n        final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n        final double tol2 = 2 * tol1;\n                final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n        if (!stop) {\n            double p = 0;\n            double q = 0;\n            double r = 0;\n            double u = 0;\n            if (FastMath.abs(e) > tol1) {\n                                r = (x - w) * (fx - fv);\n                q = (x - v) * (fx - fw);\n                p = (x - v) * q - (x - w) * r;\n                q = 2 * (q - r);\n                if (q > 0) {\n                    p = -p;\n                } else {\n                    q = -q;\n                }\n                r = e;\n                e = d;\n                if (p > q * (a - x) && p < q * (b - x) && FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n                                        d = p / q;\n                    u = x + d;\n                                        if (u - a < tol2 || b - u < tol2) {\n                        if (x <= m) {\n                            d = tol1;\n                        } else {\n                            d = -tol1;\n                        }\n                    }\n                } else {\n                                        if (x < m) {\n                        e = b - x;\n                    } else {\n                        e = a - x;\n                    }\n                    d = GOLDEN_SECTION * e;\n                }\n            } else {\n                                if (x < m) {\n                    e = b - x;\n                } else {\n                    e = a - x;\n                }\n                d = GOLDEN_SECTION * e;\n            }\n                        if (FastMath.abs(d) < tol1) {\n                if (d >= 0) {\n                    u = x + tol1;\n                } else {\n                    u = x - tol1;\n                }\n            } else {\n                u = x + d;\n            }\n            double fu = computeObjectiveValue(u);\n            if (!isMinim) {\n                fu = -fu;\n            }\n                        previous = current;\n            current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n            if (checker != null) {\n                if (checker.converged(iter, previous, current)) {\n                    return best(current, previous, isMinim);\n                }\n            }\n                        if (fu <= fx) {\n                if (u < x) {\n                    b = x;\n                } else {\n                    a = x;\n                }\n                v = w;\n                fv = fw;\n                w = x;\n                fw = fx;\n                x = u;\n                fx = fu;\n            } else {\n                if (u < x) {\n                    a = u;\n                } else {\n                    b = u;\n                }\n                if (fu <= fw || Precision.equals(w, x)) {\n                    v = w;\n                    fv = fw;\n                    w = u;\n                    fw = fu;\n                } else if (fu <= fv || Precision.equals(v, x) || Precision.equals(v, w)) {\n                    v = u;\n                    fv = fu;\n                }\n            }\n        } else {\n                        return best(current, previous, isMinim);\n        }\n        ++iter;\n    }\n}", "lc": 5.363636363636363, "pi": 1.6555023923444978, "ma": 4.0, "nbd": 2.0, "ml": 4.833333333333333, "d": 6.938492063492063, "mi": -1.5626497533474275, "fo": 1.0833333333333333, "r": -0.02631578947368421, "e": 44.626644306518436}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3511_4a875f46", "label": 1, "code": "String getReference();", "code_comment": NaN, "code_no_comment": "String getReference();", "lc": -0.5909090909090909, "pi": -1.4306220095693782, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 1.7424947145877374, "fo": -0.5, "r": 2.3684210526315788, "e": -0.16279340490885932}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-537_a8493efc", "label": 3, "code": "/**\n * Searches for a given value within this index.\n *\n * @param name the property name\n * @param value the property value (null to check for property existence)\n * @return the set of matched paths\n */\npublic Set<String> find(String name, PropertyValue value) {\n    Set<String> paths = Sets.newHashSet();\n    NodeState state = getIndexDefinitionNode(name);\n    if (state != null && state.getChildNode(\":index\") != null) {\n        state = state.getChildNode(\":index\");\n        if (value == null) {\n            paths.addAll(store.find(state, null));\n        } else {\n            paths.addAll(store.find(state, Property2Index.encode(value)));\n        }\n    } else {\n        // No index available, so first check this node for a match\n        PropertyState property = root.getProperty(name);\n        if (property != null) {\n            if (value == null || value.isArray()) {\n                // let query engine handle property existence and\n                // multi-valued look ups;\n                // simply return all nodes that have this property\n                paths.add(\"\");\n            } else {\n                // does it match any of the values of this property?\n                for (int i = 0; i < property.count(); i++) {\n                    if (property.getValue(value.getType(), i).equals(value.getValue(value.getType()))) {\n                        paths.add(\"\");\n                        // no need to check for more matches in this property\n                        break;\n                    }\n                }\n            }\n        }\n        // ... and then recursively look up from the rest of the tree\n        for (ChildNodeEntry entry : root.getChildNodeEntries()) {\n            String base = entry.getName();\n            Property2IndexLookup lookup = new Property2IndexLookup(entry.getNodeState());\n            for (String path : lookup.find(name, value)) {\n                if (path.isEmpty()) {\n                    paths.add(base);\n                } else {\n                    paths.add(base + \"/\" + path);\n                }\n            }\n        }\n    }\n    return paths;\n}", "code_comment": "/**\n * Searches for a given value within this index.\n *\n * @param name the property name\n * @param value the property value (null to check for property existence)\n * @return the set of matched paths\n */\n", "code_no_comment": "public Set<String> find(String name, PropertyValue value) {\n    Set<String> paths = Sets.newHashSet();\n    NodeState state = getIndexDefinitionNode(name);\n    if (state != null && state.getChildNode(\":index\") != null) {\n        state = state.getChildNode(\":index\");\n        if (value == null) {\n            paths.addAll(store.find(state, null));\n        } else {\n            paths.addAll(store.find(state, Property2Index.encode(value)));\n        }\n    } else {\n                PropertyState property = root.getProperty(name);\n        if (property != null) {\n            if (value == null || value.isArray()) {\n                                                                paths.add(\"\");\n            } else {\n                                for (int i = 0; i < property.count(); i++) {\n                    if (property.getValue(value.getType(), i).equals(value.getValue(value.getType()))) {\n                        paths.add(\"\");\n                                                break;\n                    }\n                }\n            }\n        }\n                for (ChildNodeEntry entry : root.getChildNodeEntries()) {\n            String base = entry.getName();\n            Property2IndexLookup lookup = new Property2IndexLookup(entry.getNodeState());\n            for (String path : lookup.find(name, value)) {\n                if (path.isEmpty()) {\n                    paths.add(base);\n                } else {\n                    paths.add(base + \"/\" + path);\n                }\n            }\n        }\n    }\n    return paths;\n}", "lc": 1.0909090909090908, "pi": 1.5119617224880384, "ma": 1.4, "nbd": 1.5, "ml": 1.25, "d": 1.5476190476190477, "mi": -0.7152924594785058, "fo": 1.6666666666666667, "r": -0.02631578947368421, "e": 2.9522195904865636}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1035_b2ca8baa", "label": 1, "code": "@Override\npublic long count(NodeState indexMeta, Set<String> values, int max) {\n    NodeState index = indexMeta.getChildNode(INDEX_CONTENT_NODE_NAME);\n    int count = 0;\n    if (values == null) {\n        PropertyState ec = indexMeta.getProperty(ENTRY_COUNT_PROPERTY_NAME);\n        if (ec != null) {\n            return ec.getValue(Type.LONG);\n        }\n        CountingNodeVisitor v = new CountingNodeVisitor(max);\n        v.visit(index);\n        count = v.getEstimatedCount();\n        // \"is not null\" queries typically read more data\n        count *= 10;\n    } else {\n        int size = values.size();\n        if (size == 0) {\n            return 0;\n        }\n        max = Math.max(10, max / size);\n        int i = 0;\n        for (String p : values) {\n            if (count > max && i > 3) {\n                count = count / size / i;\n                break;\n            }\n            NodeState s = index.getChildNode(p);\n            if (s.exists()) {\n                CountingNodeVisitor v = new CountingNodeVisitor(max);\n                v.visit(s);\n                count += v.getEstimatedCount();\n            }\n            i++;\n        }\n    }\n    return count;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic long count(NodeState indexMeta, Set<String> values, int max) {\n    NodeState index = indexMeta.getChildNode(INDEX_CONTENT_NODE_NAME);\n    int count = 0;\n    if (values == null) {\n        PropertyState ec = indexMeta.getProperty(ENTRY_COUNT_PROPERTY_NAME);\n        if (ec != null) {\n            return ec.getValue(Type.LONG);\n        }\n        CountingNodeVisitor v = new CountingNodeVisitor(max);\n        v.visit(index);\n        count = v.getEstimatedCount();\n                count *= 10;\n    } else {\n        int size = values.size();\n        if (size == 0) {\n            return 0;\n        }\n        max = Math.max(10, max / size);\n        int i = 0;\n        for (String p : values) {\n            if (count > max && i > 3) {\n                count = count / size / i;\n                break;\n            }\n            NodeState s = index.getChildNode(p);\n            if (s.exists()) {\n                CountingNodeVisitor v = new CountingNodeVisitor(max);\n                v.visit(s);\n                count += v.getEstimatedCount();\n            }\n            i++;\n        }\n    }\n    return count;\n}", "lc": 1.0, "pi": 0.7081339712918658, "ma": 0.8, "nbd": 0.5, "ml": 0.6666666666666666, "d": 1.6785714285714288, "mi": -0.6425651867512332, "fo": 0.4166666666666667, "r": -0.02631578947368421, "e": 2.577878436864277}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-618_2123f780", "label": 1, "code": "/**\n * Return the sum of this complex number and the given complex number.\n * <p>\n * Uses the definitional formula\n * <pre>\n * (a + bi) + (c + di) = (a+c) + (b+d)i\n * </pre></p>\n * <p>\n * If either this or <code>rhs</code> has a NaN value in either part,\n * {@link #NaN} is returned; otherwise Infinite and NaN values are\n * returned in the parts of the result according to the rules for\n * {@link java.lang.Double} arithmetic.</p>\n *\n * @param rhs the other complex number\n * @return the complex number sum\n * @throws NullArgumentException if <code>rhs</code> is null\n */\npublic Complex add(Complex rhs) throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary());\n}", "code_comment": "/**\n * Return the sum of this complex number and the given complex number.\n * <p>\n * Uses the definitional formula\n * <pre>\n * (a + bi) + (c + di) = (a+c) + (b+d)i\n * </pre></p>\n * <p>\n * If either this or <code>rhs</code> has a NaN value in either part,\n * {@link #NaN} is returned; otherwise Infinite and NaN values are\n * returned in the parts of the result according to the rules for\n * {@link java.lang.Double} arithmetic.</p>\n *\n * @param rhs the other complex number\n * @return the complex number sum\n * @throws NullArgumentException if <code>rhs</code> is null\n */\n", "code_no_comment": "public Complex add(Complex rhs) throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary());\n}", "lc": -0.45454545454545453, "pi": -0.47368421052631593, "ma": -0.6, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3650793650793651, "mi": 0.7226215644820295, "fo": -0.16666666666666666, "r": 1.1578947368421053, "e": -0.16279340490885932}
