project_name,project_version,label,code,code_comment,code_no_comment,lc,pi,ma,nbd,ml,d,mi,fo,r,e
flink,remotes/origin/bugs-dot-jar_FLINK-3260_6968a57a,0,"public void cancel() {
    // successful atomic state transition
    while (true) {
        ExecutionState current = this.state;
        if (current == CANCELING || current == CANCELED) {
            // already taken care of, no need to cancel again
            return;
        } else // these two are the common cases where we need to send a cancel call
        if (current == RUNNING || current == DEPLOYING) {
            // try to transition to canceling, if successful, send the cancel call
            if (transitionState(current, CANCELING)) {
                sendCancelRpcCall();
                return;
            }
        // else: fall through the loop
        } else if (current == FINISHED || current == FAILED) {
            // nothing to do any more. finished failed before it could be cancelled.
            // in any case, the task is removed from the TaskManager already
            sendFailIntermediateResultPartitionsRpcCall();
            return;
        } else if (current == CREATED || current == SCHEDULED) {
            // from here, we can directly switch to cancelled, because the no task has been deployed
            if (transitionState(current, CANCELED)) {
                // we skip the canceling state. set the timestamp, for a consistent appearance
                markTimestamp(CANCELING, getStateTimestamp(CANCELED));
                try {
                    vertex.getExecutionGraph().deregisterExecution(this);
                    if (assignedResource != null) {
                        assignedResource.releaseSlot();
                    }
                } finally {
                    vertex.executionCanceled();
                }
                return;
            }
        // else: fall through the loop
        } else {
            throw new IllegalStateException(current.name());
        }
    }
}",,"public void cancel() {
        while (true) {
        ExecutionState current = this.state;
        if (current == CANCELING || current == CANCELED) {
                        return;
        } else         if (current == RUNNING || current == DEPLOYING) {
                        if (transitionState(current, CANCELING)) {
                sendCancelRpcCall();
                return;
            }
                } else if (current == FINISHED || current == FAILED) {
                                    sendFailIntermediateResultPartitionsRpcCall();
            return;
        } else if (current == CREATED || current == SCHEDULED) {
                        if (transitionState(current, CANCELED)) {
                                markTimestamp(CANCELING, getStateTimestamp(CANCELED));
                try {
                    vertex.getExecutionGraph().deregisterExecution(this);
                    if (assignedResource != null) {
                        assignedResource.releaseSlot();
                    }
                } finally {
                    vertex.executionCanceled();
                }
                return;
            }
                } else {
            throw new IllegalStateException(current.name());
        }
    }
}",0.8181818181818182,1.3157894736842106,1.2,3.0,0.9166666666666666,0.2876984126984127,-0.5058491895701195,0.4166666666666667,-0.02631578947368421,0.29165240342778764
wicket,remotes/origin/bugs-dot-jar_WICKET-172_99e22ce4,1,"private final Component children_remove(Component<?> component) {
    int index = children_indexOf(component);
    if (index != -1) {
        return children_remove(index);
    }
    return null;
}",,"private final Component children_remove(Component<?> component) {
    int index = children_indexOf(component);
    if (index != -1) {
        return children_remove(index);
    }
    return null;
}",-0.3181818181818182,-0.20574162679425848,-0.4,-0.5,-0.25,-0.04365079365079365,0.48780831571529254,-0.3333333333333333,1.6052631578947367,-0.12132339805097883
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-639_a5a1f1a2,1,"@Override
public void logMessage(final String fqcn, final Level level, final Marker marker, final Message message, final Throwable thrown) {
    Info info = threadlocalInfo.get();
    if (info == null) {
        info = new Info(new RingBufferLogEventTranslator(), Thread.currentThread().getName(), false);
        threadlocalInfo.set(info);
    }
    // being logged calls Logger.log() from its toString() method
    if (info.isAppenderThread && disruptor.getRingBuffer().remainingCapacity() == 0) {
        // bypass RingBuffer and invoke Appender directly
        config.loggerConfig.log(getName(), fqcn, marker, level, message, thrown);
        return;
    }
    final boolean includeLocation = config.loggerConfig.isIncludeLocation();
    // 
    info.translator.setValues(// 
    this, // 
    getName(), // 
    marker, // 
    fqcn, // 
    level, // 
    message, // 
    thrown, // 
    ThreadContext.getImmutableContext(), // 
    ThreadContext.getImmutableStack(), // LOG4J2-467
    THREAD_NAME_STRATEGY.getThreadName(info), // exclude if not specified or if ""false"" was specified.
    includeLocation ? location(fqcn) : null, // CachedClock: 10% faster than system clock, smaller gaps
    clock.currentTimeMillis());
    disruptor.publishEvent(info.translator);
}",,"@Override
public void logMessage(final String fqcn, final Level level, final Marker marker, final Message message, final Throwable thrown) {
    Info info = threadlocalInfo.get();
    if (info == null) {
        info = new Info(new RingBufferLogEventTranslator(), Thread.currentThread().getName(), false);
        threadlocalInfo.set(info);
    }
        if (info.isAppenderThread && disruptor.getRingBuffer().remainingCapacity() == 0) {
                config.loggerConfig.log(getName(), fqcn, marker, level, message, thrown);
        return;
    }
    final boolean includeLocation = config.loggerConfig.isIncludeLocation();
        info.translator.setValues(    this,     getName(),     marker,     fqcn,     level,     message,     thrown,     ThreadContext.getImmutableContext(),     ThreadContext.getImmutableStack(),     THREAD_NAME_STRATEGY.getThreadName(info),     includeLocation ? location(fqcn) : null,     clock.currentTimeMillis());
    disruptor.publishEvent(info.translator);
}",0.5909090909090909,-0.4593301435406701,0.0,-0.5,0.25,-0.039682539682539715,-0.4477801268498943,0.9166666666666666,-0.02631578947368421,0.17594209413161366
wicket,remotes/origin/bugs-dot-jar_WICKET-4301_50b52742,3,"@Override
protected ResourceResponse newResourceResponse(final Attributes attributes) {
    final ResourceResponse response = new ResourceResponse();
    if (lastModifiedTime != null) {
        response.setLastModified(lastModifiedTime);
    } else {
        response.setLastModified(Time.now());
    }
    if (response.dataNeedsToBeWritten(attributes)) {
        response.setContentType(""image/"" + getFormat());
        response.setContentDisposition(ContentDisposition.INLINE);
        final byte[] imageData = getImageData(attributes);
        if (imageData == null) {
            response.setError(HttpServletResponse.SC_NOT_FOUND);
        } else {
            response.setWriteCallback(new WriteCallback() {

                @Override
                public void writeData(final Attributes attributes) {
                    attributes.getResponse().write(imageData);
                }
            });
        }
        configureResponse(response, attributes);
    }
    return response;
}",,"@Override
protected ResourceResponse newResourceResponse(final Attributes attributes) {
    final ResourceResponse response = new ResourceResponse();
    if (lastModifiedTime != null) {
        response.setLastModified(lastModifiedTime);
    } else {
        response.setLastModified(Time.now());
    }
    if (response.dataNeedsToBeWritten(attributes)) {
        response.setContentType(""image/"" + getFormat());
        response.setContentDisposition(ContentDisposition.INLINE);
        final byte[] imageData = getImageData(attributes);
        if (imageData == null) {
            response.setError(HttpServletResponse.SC_NOT_FOUND);
        } else {
            response.setWriteCallback(new WriteCallback() {

                @Override
                public void writeData(final Attributes attributes) {
                    attributes.getResponse().write(imageData);
                }
            });
        }
        configureResponse(response, attributes);
    }
    return response;
}",0.5454545454545454,1.0287081339712916,0.0,0.5,0.16666666666666666,0.33531746031746024,-0.36969696969696947,0.5833333333333334,-0.02631578947368421,0.31787601643586144
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-639_a5a1f1a2,1,"/**
 * If possible, delegates the invocation to {@code callAppenders} to another
 * thread and returns {@code true}. If this is not possible (if it detects
 * that delegating to another thread would cause deadlock because the
 * current call to Logger.log() originated from the appender thread and the
 * ringbuffer is full) then this method does nothing and returns {@code false}.
 * It is the responsibility of the caller to process the event when this
 * method returns {@code false}.
 *
 * @param event the event to delegate to another thread
 * @return {@code true} if delegation was successful, {@code false} if the
 *          calling thread needs to process the event itself
 */
public boolean callAppendersFromAnotherThread(final LogEvent event) {
    // being logged calls Logger.log() from its toString() method
    if (// 
    isAppenderThread.get() == Boolean.TRUE && disruptor.getRingBuffer().remainingCapacity() == 0) {
        // bypass RingBuffer and invoke Appender directly
        return false;
    }
    disruptor.getRingBuffer().publishEvent(translator, event, asyncLoggerConfig);
    return true;
}","/**
 * If possible, delegates the invocation to {@code callAppenders} to another
 * thread and returns {@code true}. If this is not possible (if it detects
 * that delegating to another thread would cause deadlock because the
 * current call to Logger.log() originated from the appender thread and the
 * ringbuffer is full) then this method does nothing and returns {@code false}.
 * It is the responsibility of the caller to process the event when this
 * method returns {@code false}.
 *
 * @param event the event to delegate to another thread
 * @return {@code true} if delegation was successful, {@code false} if the
 *          calling thread needs to process the event itself
 */
","public boolean callAppendersFromAnotherThread(final LogEvent event) {
        if (    isAppenderThread.get() == Boolean.TRUE && disruptor.getRingBuffer().remainingCapacity() == 0) {
                return false;
    }
    disruptor.getRingBuffer().publishEvent(translator, event, asyncLoggerConfig);
    return true;
}",-0.2727272727272727,-0.2822966507177035,-0.4,-0.5,-0.08333333333333333,-0.130952380952381,0.3434813248766737,-0.08333333333333333,0.02631578947368421,-0.10980215879162993
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-3229_891584fb,1,"public void printVerboseInfo() throws IOException {
    StringBuilder sb = new StringBuilder(""-\n"");
    sb.append(""- Current user: "").append(connector.whoami()).append(""\n"");
    if (execFile != null)
        sb.append(""- Executing commands from: "").append(execFile).append(""\n"");
    if (disableAuthTimeout)
        sb.append(""- Authorization timeout: disabled\n"");
    else
        sb.append(""- Authorization timeout: "").append(String.format(""%.2fs%n"", TimeUnit.NANOSECONDS.toSeconds(authTimeout)));
    sb.append(""- Debug: "").append(isDebuggingEnabled() ? ""on"" : ""off"").append(""\n"");
    if (!scanIteratorOptions.isEmpty()) {
        for (Entry<String, List<IteratorSetting>> entry : scanIteratorOptions.entrySet()) {
            sb.append(""- Session scan iterators for table "").append(entry.getKey()).append("":\n"");
            for (IteratorSetting setting : entry.getValue()) {
                sb.append(""-    Iterator "").append(setting.getName()).append("" options:\n"");
                sb.append(""-        "").append(""iteratorPriority"").append("" = "").append(setting.getPriority()).append(""\n"");
                sb.append(""-        "").append(""iteratorClassName"").append("" = "").append(setting.getIteratorClass()).append(""\n"");
                for (Entry<String, String> optEntry : setting.getOptions().entrySet()) {
                    sb.append(""-        "").append(optEntry.getKey()).append("" = "").append(optEntry.getValue()).append(""\n"");
                }
            }
        }
    }
    sb.append(""-\n"");
    reader.printString(sb.toString());
}",,"public void printVerboseInfo() throws IOException {
    StringBuilder sb = new StringBuilder(""-\n"");
    sb.append(""- Current user: "").append(connector.whoami()).append(""\n"");
    if (execFile != null)
        sb.append(""- Executing commands from: "").append(execFile).append(""\n"");
    if (disableAuthTimeout)
        sb.append(""- Authorization timeout: disabled\n"");
    else
        sb.append(""- Authorization timeout: "").append(String.format(""%.2fs%n"", TimeUnit.NANOSECONDS.toSeconds(authTimeout)));
    sb.append(""- Debug: "").append(isDebuggingEnabled() ? ""on"" : ""off"").append(""\n"");
    if (!scanIteratorOptions.isEmpty()) {
        for (Entry<String, List<IteratorSetting>> entry : scanIteratorOptions.entrySet()) {
            sb.append(""- Session scan iterators for table "").append(entry.getKey()).append("":\n"");
            for (IteratorSetting setting : entry.getValue()) {
                sb.append(""-    Iterator "").append(setting.getName()).append("" options:\n"");
                sb.append(""-        "").append(""iteratorPriority"").append("" = "").append(setting.getPriority()).append(""\n"");
                sb.append(""-        "").append(""iteratorClassName"").append("" = "").append(setting.getIteratorClass()).append(""\n"");
                for (Entry<String, String> optEntry : setting.getOptions().entrySet()) {
                    sb.append(""-        "").append(optEntry.getKey()).append("" = "").append(optEntry.getValue()).append(""\n"");
                }
            }
        }
    }
    sb.append(""-\n"");
    reader.printString(sb.toString());
}",0.5454545454545454,1.2200956937799043,0.8,1.0,0.25,0.10515873015873016,-0.5351656095842141,3.75,-0.02631578947368421,0.6722405675328341
Math,84,0,"/**
 * {@inheritDoc}
 */
@Override
protected void iterateSimplex(final Comparator<RealPointValuePair> comparator) throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {
    while (true) {
        incrementIterationsCounter();
        // save the original vertex
        final RealPointValuePair[] original = simplex;
        final RealPointValuePair best = original[0];
        // perform a reflection step
        final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);
        if (comparator.compare(reflected, best) < 0) {
            // compute the expanded simplex
            final RealPointValuePair[] reflectedSimplex = simplex;
            final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);
            if (comparator.compare(reflected, expanded) <= 0) {
                // accept the reflected simplex
                simplex = reflectedSimplex;
            }
            return;
        }
        // compute the contracted simplex
        final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);
        if (comparator.compare(contracted, best) < 0) {
            // check convergence
            return;
        }
    }
}","/**
 * {@inheritDoc}
 */
","@Override
protected void iterateSimplex(final Comparator<RealPointValuePair> comparator) throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {
    while (true) {
        incrementIterationsCounter();
                final RealPointValuePair[] original = simplex;
        final RealPointValuePair best = original[0];
                final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);
        if (comparator.compare(reflected, best) < 0) {
                        final RealPointValuePair[] reflectedSimplex = simplex;
            final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);
            if (comparator.compare(reflected, expanded) <= 0) {
                                simplex = reflectedSimplex;
            }
            return;
        }
                final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);
        if (comparator.compare(contracted, best) < 0) {
                        return;
        }
    }
}",0.3181818181818182,0.6172248803827752,0.2,0.5,0.5,0.09722222222222222,-0.28794926004228333,0.08333333333333333,-0.02631578947368421,0.17479872985137412
Closure,148,2,"/**
 * Folds 'typeof(foo)' if foo is a literal, e.g.
 * typeof(""bar"") --> ""string""
 * typeof(6) --> ""number""
 */
private Node tryFoldTypeof(Node originalTypeofNode) {
    Preconditions.checkArgument(originalTypeofNode.getType() == Token.TYPEOF);
    Node argumentNode = originalTypeofNode.getFirstChild();
    if (argumentNode == null || !NodeUtil.isLiteralValue(argumentNode)) {
        return originalTypeofNode;
    }
    String typeNameString = null;
    switch(argumentNode.getType()) {
        case Token.STRING:
            typeNameString = ""string"";
            break;
        case Token.NUMBER:
            typeNameString = ""number"";
            break;
        case Token.TRUE:
        case Token.FALSE:
            typeNameString = ""boolean"";
            break;
        case Token.NULL:
        case Token.OBJECTLIT:
        case Token.ARRAYLIT:
            typeNameString = ""object"";
            break;
        case Token.NAME:
            // keyword undefined to something other than the value undefined.
            if (""undefined"".equals(argumentNode.getString())) {
                typeNameString = ""undefined"";
            }
            break;
    }
    if (typeNameString != null) {
        Node newNode = Node.newString(typeNameString);
        originalTypeofNode.getParent().replaceChild(originalTypeofNode, newNode);
        reportCodeChange();
        return newNode;
    }
    return originalTypeofNode;
}","/**
 * Folds 'typeof(foo)' if foo is a literal, e.g.
 * typeof(""bar"") --> ""string""
 * typeof(6) --> ""number""
 */
","private Node tryFoldTypeof(Node originalTypeofNode) {
    Preconditions.checkArgument(originalTypeofNode.getType() == Token.TYPEOF);
    Node argumentNode = originalTypeofNode.getFirstChild();
    if (argumentNode == null || !NodeUtil.isLiteralValue(argumentNode)) {
        return originalTypeofNode;
    }
    String typeNameString = null;
    switch(argumentNode.getType()) {
        case Token.STRING:
            typeNameString = ""string"";
            break;
        case Token.NUMBER:
            typeNameString = ""number"";
            break;
        case Token.TRUE:
        case Token.FALSE:
            typeNameString = ""boolean"";
            break;
        case Token.NULL:
        case Token.OBJECTLIT:
        case Token.ARRAYLIT:
            typeNameString = ""object"";
            break;
        case Token.NAME:
                        if (""undefined"".equals(argumentNode.getString())) {
                typeNameString = ""undefined"";
            }
            break;
    }
    if (typeNameString != null) {
        Node newNode = Node.newString(typeNameString);
        originalTypeofNode.getParent().replaceChild(originalTypeofNode, newNode);
        reportCodeChange();
        return newNode;
    }
    return originalTypeofNode;
}",1.0454545454545454,0.3779904306220094,2.6,0.5,1.0833333333333333,0.4166666666666666,-0.6772374911909795,0.4166666666666667,-0.02631578947368421,0.6556064613912852
wicket,remotes/origin/bugs-dot-jar_WICKET-4839_8b294488,1,"/**
 *  Gets the type converter that is registered for class c.
 *
 *  @param <C>
 *             The object to convert from and to String
 *  @param c
 *             The class to get the type converter for
 *  @return The type converter that is registered for class c or null if no type converter was
 *          registered for class c
 */
public final <C> IConverter<C> get(Class<C> c) {
    @SuppressWarnings(""unchecked"")
    final IConverter<C> converter;
    // a new instance should be created for each usage
    if (Date.class.equals(c)) {
        converter = (IConverter<C>) new DateConverter();
    } else if (java.sql.Date.class.equals(c)) {
        converter = (IConverter<C>) new SqlDateConverter();
    } else if (java.sql.Time.class.equals(c)) {
        converter = (IConverter<C>) new SqlTimeConverter();
    } else if (java.sql.Timestamp.class.equals(c)) {
        converter = (IConverter<C>) new SqlTimestampConverter();
    } else if (Calendar.class.equals(c)) {
        converter = (IConverter<C>) new CalendarConverter();
    } else {
        converter = (IConverter<C>) classToConverter.get(c.getName());
    }
    return converter;
}","/**
 *  Gets the type converter that is registered for class c.
 *
 *  @param <C>
 *             The object to convert from and to String
 *  @param c
 *             The class to get the type converter for
 *  @return The type converter that is registered for class c or null if no type converter was
 *          registered for class c
 */
","public final <C> IConverter<C> get(Class<C> c) {
    @SuppressWarnings(""unchecked"")
    final IConverter<C> converter;
        if (Date.class.equals(c)) {
        converter = (IConverter<C>) new DateConverter();
    } else if (java.sql.Date.class.equals(c)) {
        converter = (IConverter<C>) new SqlDateConverter();
    } else if (java.sql.Time.class.equals(c)) {
        converter = (IConverter<C>) new SqlTimeConverter();
    } else if (java.sql.Timestamp.class.equals(c)) {
        converter = (IConverter<C>) new SqlTimestampConverter();
    } else if (Calendar.class.equals(c)) {
        converter = (IConverter<C>) new CalendarConverter();
    } else {
        converter = (IConverter<C>) classToConverter.get(c.getName());
    }
    return converter;
}",0.18181818181818182,-0.22966507177033516,0.4,1.5,0.5,-0.3650793650793651,-0.22283298097251583,0.08333333333333333,-0.02631578947368421,-0.16279340490885932
Cli,22,1,"/**
 * <p>If an {@link Option} exists for <code>token</code> then
 * add the token to the processed list.</p>
 *
 * <p>If an {@link Option} does not exist and <code>stopAtNonOption</code>
 * is set then add the remaining tokens to the processed tokens list
 * directly.</p>
 *
 * @param token The current option token
 * @param stopAtNonOption Specifies whether flattening should halt
 * at the first non option.
 */
private void processOptionToken(String token, boolean stopAtNonOption) {
    if (stopAtNonOption && !options.hasOption(token)) {
        eatTheRest = true;
    }
    tokens.add(token);
}","/**
 * <p>If an {@link Option} exists for <code>token</code> then
 * add the token to the processed list.</p>
 *
 * <p>If an {@link Option} does not exist and <code>stopAtNonOption</code>
 * is set then add the remaining tokens to the processed tokens list
 * directly.</p>
 *
 * @param token The current option token
 * @param stopAtNonOption Specifies whether flattening should halt
 * at the first non option.
 */
","private void processOptionToken(String token, boolean stopAtNonOption) {
    if (stopAtNonOption && !options.hasOption(token)) {
        eatTheRest = true;
    }
    tokens.add(token);
}",-0.36363636363636365,-0.11483253588516758,-0.4,-0.5,0.0,-0.11309523809523811,0.5351656095842141,-0.3333333333333333,1.2105263157894737,-0.12481342530961312
camel,remotes/origin/bugs-dot-jar_CAMEL-5515_b3bb8670,1,"/**
 * Continues processing the {@link org.apache.camel.Exchange} using asynchronous routing engine.
 *
 * @param poolSize the core pool size
 * @return the builder
 */
public ThreadsDefinition threads(int poolSize) {
    ThreadsDefinition answer = threads();
    answer.setPoolSize(poolSize);
    addOutput(answer);
    return answer;
}","/**
 * Continues processing the {@link org.apache.camel.Exchange} using asynchronous routing engine.
 *
 * @param poolSize the core pool size
 * @return the builder
 */
","public ThreadsDefinition threads(int poolSize) {
    ThreadsDefinition answer = threads();
    answer.setPoolSize(poolSize);
    addOutput(answer);
    return answer;
}",-0.36363636363636365,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.6050739957716701,-0.25,2.5,-0.16279340490885932
camel,remotes/origin/bugs-dot-jar_CAMEL-9238_169b981e,1,"/**
 * Changes the name of this remote file. This method alters the absolute and
 * relative names as well.
 *
 * @param newName the new name
 */
public void changeFileName(String newName) {
    LOG.trace(""Changing name to: {}"", newName);
    // Make sure the names is normalized.
    String newFileName = FileUtil.normalizePath(newName);
    String newEndpointPath = FileUtil.normalizePath(endpointPath);
    LOG.trace(""Normalized endpointPath: {}"", newEndpointPath);
    LOG.trace(""Normalized newFileName: ()"", newFileName);
    File file = new File(newFileName);
    if (!absolute) {
        // for relative then we should avoid having the endpoint path duplicated so clip it
        if (ObjectHelper.isNotEmpty(newEndpointPath) && newFileName.startsWith(newEndpointPath)) {
            // in this logic here
            if (newEndpointPath.endsWith("""" + File.separatorChar)) {
                newFileName = ObjectHelper.after(newFileName, newEndpointPath);
            } else {
                newFileName = ObjectHelper.after(newFileName, newEndpointPath + File.separatorChar);
            }
            // reconstruct file with clipped name
            file = new File(newFileName);
        }
    }
    // store the file name only
    setFileNameOnly(file.getName());
    setFileName(file.getName());
    // relative path
    if (file.getParent() != null) {
        setRelativeFilePath(file.getParent() + getFileSeparator() + file.getName());
    } else {
        setRelativeFilePath(file.getName());
    }
    // absolute path
    if (isAbsolute(newFileName)) {
        setAbsolute(true);
        setAbsoluteFilePath(newFileName);
    } else {
        setAbsolute(false);
        // construct a pseudo absolute filename that the file operations uses even for relative only
        String path = ObjectHelper.isEmpty(endpointPath) ? """" : endpointPath + getFileSeparator();
        setAbsoluteFilePath(path + getRelativeFilePath());
    }
    if (LOG.isTraceEnabled()) {
        LOG.trace(""FileNameOnly: {}"", getFileNameOnly());
        LOG.trace(""FileName: {}"", getFileName());
        LOG.trace(""Absolute: {}"", isAbsolute());
        LOG.trace(""Relative path: {}"", getRelativeFilePath());
        LOG.trace(""Absolute path: {}"", getAbsoluteFilePath());
        LOG.trace(""Name changed to: {}"", this);
    }
}","/**
 * Changes the name of this remote file. This method alters the absolute and
 * relative names as well.
 *
 * @param newName the new name
 */
","public void changeFileName(String newName) {
    LOG.trace(""Changing name to: {}"", newName);
        String newFileName = FileUtil.normalizePath(newName);
    String newEndpointPath = FileUtil.normalizePath(endpointPath);
    LOG.trace(""Normalized endpointPath: {}"", newEndpointPath);
    LOG.trace(""Normalized newFileName: ()"", newFileName);
    File file = new File(newFileName);
    if (!absolute) {
                if (ObjectHelper.isNotEmpty(newEndpointPath) && newFileName.startsWith(newEndpointPath)) {
                        if (newEndpointPath.endsWith("""" + File.separatorChar)) {
                newFileName = ObjectHelper.after(newFileName, newEndpointPath);
            } else {
                newFileName = ObjectHelper.after(newFileName, newEndpointPath + File.separatorChar);
            }
                        file = new File(newFileName);
        }
    }
        setFileNameOnly(file.getName());
    setFileName(file.getName());
        if (file.getParent() != null) {
        setRelativeFilePath(file.getParent() + getFileSeparator() + file.getName());
    } else {
        setRelativeFilePath(file.getName());
    }
        if (isAbsolute(newFileName)) {
        setAbsolute(true);
        setAbsoluteFilePath(newFileName);
    } else {
        setAbsolute(false);
                String path = ObjectHelper.isEmpty(endpointPath) ? """" : endpointPath + getFileSeparator();
        setAbsoluteFilePath(path + getRelativeFilePath());
    }
    if (LOG.isTraceEnabled()) {
        LOG.trace(""FileNameOnly: {}"", getFileNameOnly());
        LOG.trace(""FileName: {}"", getFileName());
        LOG.trace(""Absolute: {}"", isAbsolute());
        LOG.trace(""Relative path: {}"", getRelativeFilePath());
        LOG.trace(""Absolute path: {}"", getAbsoluteFilePath());
        LOG.trace(""Name changed to: {}"", this);
    }
}",1.2272727272727273,0.29186602870813394,0.8,0.5,1.25,0.5992063492063493,-0.7446088794926,2.9166666666666665,-0.02631578947368421,1.5640600957798099
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1977_4bfbfcdd,1,"@Override
public PropertyValue getValue(String columnName) {
    return r.getValue(columnName);
}",,"@Override
public PropertyValue getValue(String columnName) {
    return r.getValue(columnName);
}",-0.45454545454545453,-0.6028708133971293,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.8646934460887951,-0.4166666666666667,1.7631578947368423,-0.16279340490885932
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-606_f0fbacab,1,"/**
 * Determine whether this item is stale
 * @return  {@code true} iff stale
 */
public boolean isStale() {
    Status status = getLocationOrNull().getStatus();
    return status == Status.DISCONNECTED || status == null;
}","/**
 * Determine whether this item is stale
 * @return  {@code true} iff stale
 */
","public boolean isStale() {
    Status status = getLocationOrNull().getStatus();
    return status == Status.DISCONNECTED || status == null;
}",-0.45454545454545453,-0.47368421052631593,-0.6,-1.0,-0.4166666666666667,-0.0912698412698413,0.7592670894996475,-0.3333333333333333,2.6052631578947367,-0.1298986301527751
wicket,remotes/origin/bugs-dot-jar_WICKET-428_d906576c,3,"/**
 *  @see java.util.Map#keySet()
 */
public Set keySet() {
    return new AbstractSet() {

        public Iterator iterator() {
            return new Iterator() {

                public boolean hasNext() {
                    return index < MicroMap.this.size();
                }

                public Object next() {
                    index++;
                    return key;
                }

                public void remove() {
                    MicroMap.this.clear();
                }

                int index;
            };
        }

        public int size() {
            return MicroMap.this.size();
        }
    };
}","/**
 *  @see java.util.Map#keySet()
 */
","public Set keySet() {
    return new AbstractSet() {

        public Iterator iterator() {
            return new Iterator() {

                public boolean hasNext() {
                    return index < MicroMap.this.size();
                }

                public Object next() {
                    index++;
                    return key;
                }

                public void remove() {
                    MicroMap.this.clear();
                }

                int index;
            };
        }

        public int size() {
            return MicroMap.this.size();
        }
    };
}",0.36363636363636365,1.5406698564593302,-0.6,0.0,-0.4166666666666667,-0.07341269841269843,-0.11261451726568016,-0.25,1.6842105263157894,-0.09645983529560923
camel,remotes/origin/bugs-dot-jar_CAMEL-3791_52106681,1,"/**
 * All redelivery attempts failed so move the exchange to the dead letter queue
 */
protected boolean deliverToFailureProcessor(final Processor processor, final Exchange exchange, final RedeliveryData data, final AsyncCallback callback) {
    boolean sync = true;
    Exception caught = exchange.getException();
    // we did not success with the redelivery so now we let the failure processor handle it
    // clear exception as we let the failure processor handle it
    exchange.setException(null);
    boolean handled = false;
    // regard both handled or continued as being handled
    if (shouldHandled(exchange, data) || shouldContinue(exchange, data)) {
        // its handled then remove traces of redelivery attempted
        exchange.getIn().removeHeader(Exchange.REDELIVERED);
        exchange.getIn().removeHeader(Exchange.REDELIVERY_COUNTER);
        exchange.getIn().removeHeader(Exchange.REDELIVERY_MAX_COUNTER);
        handled = true;
    } else {
        // must decrement the redelivery counter as we didn't process the redelivery but is
        // handling by the failure handler. So we must -1 to not let the counter be out-of-sync
        decrementRedeliveryCounter(exchange);
    }
    // is the a failure processor to process the Exchange
    if (processor != null) {
        // reset cached streams so they can be read again
        MessageHelper.resetStreamCache(exchange.getIn());
        // prepare original IN body if it should be moved instead of current body
        if (data.useOriginalInMessage) {
            if (log.isTraceEnabled()) {
                log.trace(""Using the original IN message instead of current"");
            }
            Message original = exchange.getUnitOfWork().getOriginalInMessage();
            exchange.setIn(original);
        }
        if (log.isTraceEnabled()) {
            log.trace(""Failure processor "" + processor + "" is processing Exchange: "" + exchange);
        }
        // store the last to endpoint as the failure endpoint
        exchange.setProperty(Exchange.FAILURE_ENDPOINT, exchange.getProperty(Exchange.TO_ENDPOINT));
        // the failure processor could also be asynchronous
        AsyncProcessor afp = AsyncProcessorTypeConverter.convert(processor);
        sync = AsyncProcessorHelper.process(afp, exchange, new AsyncCallback() {

            public void done(boolean sync) {
                if (log.isTraceEnabled()) {
                    log.trace(""Failure processor done: "" + processor + "" processing Exchange: "" + exchange);
                }
                try {
                    prepareExchangeAfterFailure(exchange, data);
                    // fire event as we had a failure processor to handle it, which there is a event for
                    boolean deadLetterChannel = processor == data.deadLetterProcessor && data.deadLetterProcessor != null;
                    EventHelper.notifyExchangeFailureHandled(exchange.getContext(), exchange, processor, deadLetterChannel);
                } finally {
                    // if the fault was handled asynchronously, this should be reflected in the callback as well
                    data.sync &= sync;
                    callback.done(data.sync);
                }
            }
        });
    } else {
        try {
            // no processor but we need to prepare after failure as well
            prepareExchangeAfterFailure(exchange, data);
        } finally {
            // callback we are done
            callback.done(data.sync);
        }
    }
    // create log message
    String msg = ""Failed delivery for exchangeId: "" + exchange.getExchangeId();
    msg = msg + "". Exhausted after delivery attempt: "" + data.redeliveryCounter + "" caught: "" + caught;
    if (processor != null) {
        msg = msg + "". Processed by failure processor: "" + processor;
    }
    // log that we failed delivery as we are exhausted
    logFailedDelivery(false, handled, false, exchange, msg, data, null);
    return sync;
}","/**
 * All redelivery attempts failed so move the exchange to the dead letter queue
 */
","protected boolean deliverToFailureProcessor(final Processor processor, final Exchange exchange, final RedeliveryData data, final AsyncCallback callback) {
    boolean sync = true;
    Exception caught = exchange.getException();
            exchange.setException(null);
    boolean handled = false;
        if (shouldHandled(exchange, data) || shouldContinue(exchange, data)) {
                exchange.getIn().removeHeader(Exchange.REDELIVERED);
        exchange.getIn().removeHeader(Exchange.REDELIVERY_COUNTER);
        exchange.getIn().removeHeader(Exchange.REDELIVERY_MAX_COUNTER);
        handled = true;
    } else {
                        decrementRedeliveryCounter(exchange);
    }
        if (processor != null) {
                MessageHelper.resetStreamCache(exchange.getIn());
                if (data.useOriginalInMessage) {
            if (log.isTraceEnabled()) {
                log.trace(""Using the original IN message instead of current"");
            }
            Message original = exchange.getUnitOfWork().getOriginalInMessage();
            exchange.setIn(original);
        }
        if (log.isTraceEnabled()) {
            log.trace(""Failure processor "" + processor + "" is processing Exchange: "" + exchange);
        }
                exchange.setProperty(Exchange.FAILURE_ENDPOINT, exchange.getProperty(Exchange.TO_ENDPOINT));
                AsyncProcessor afp = AsyncProcessorTypeConverter.convert(processor);
        sync = AsyncProcessorHelper.process(afp, exchange, new AsyncCallback() {

            public void done(boolean sync) {
                if (log.isTraceEnabled()) {
                    log.trace(""Failure processor done: "" + processor + "" processing Exchange: "" + exchange);
                }
                try {
                    prepareExchangeAfterFailure(exchange, data);
                                        boolean deadLetterChannel = processor == data.deadLetterProcessor && data.deadLetterProcessor != null;
                    EventHelper.notifyExchangeFailureHandled(exchange.getContext(), exchange, processor, deadLetterChannel);
                } finally {
                                        data.sync &= sync;
                    callback.done(data.sync);
                }
            }
        });
    } else {
        try {
                        prepareExchangeAfterFailure(exchange, data);
        } finally {
                        callback.done(data.sync);
        }
    }
        String msg = ""Failed delivery for exchangeId: "" + exchange.getExchangeId();
    msg = msg + "". Exhausted after delivery attempt: "" + data.redeliveryCounter + "" caught: "" + caught;
    if (processor != null) {
        msg = msg + "". Processed by failure processor: "" + processor;
    }
        logFailedDelivery(false, handled, false, exchange, msg, data, null);
    return sync;
}",1.9545454545454546,1.1626794258373205,0.8,0.5,0.8333333333333334,1.0317460317460319,-0.9543340380549682,2.3333333333333335,-0.02631578947368421,3.590631789445779
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-4113_27300d81,0,"public static List<byte[]> toBytesList(Collection<ByteBuffer> bytesList) {
    if (bytesList == null)
        return null;
    ArrayList<byte[]> result = new ArrayList<byte[]>();
    for (ByteBuffer bytes : bytesList) {
        result.add(toBytes(bytes));
    }
    return result;
}",,"public static List<byte[]> toBytesList(Collection<ByteBuffer> bytesList) {
    if (bytesList == null)
        return null;
    ArrayList<byte[]> result = new ArrayList<byte[]>();
    for (ByteBuffer bytes : bytesList) {
        result.add(toBytes(bytes));
    }
    return result;
}",-0.22727272727272727,-0.15311004784689008,-0.2,-0.5,-0.25,-0.03373015873015876,0.30570824524312884,-0.3333333333333333,0.31578947368421056,-0.0984330607469903
wicket,remotes/origin/bugs-dot-jar_WICKET-4932_f20b2d70,1,"/**
 *  Cleans the original parameters from entries used by Wicket internals.
 *
 *  @param originalParameters
 *             the current request's non-modified parameters
 *  @return all parameters but Wicket internal ones
 */
private PageParameters cleanPageParameters(final PageParameters originalParameters) {
    PageParameters cleanParameters = null;
    if (originalParameters != null) {
        cleanParameters = new PageParameters(originalParameters);
        // WICKET-4038: Ajax related parameters are set by wicket-ajax.js when needed.
        // They shouldn't be propagated to the next requests
        cleanParameters.remove(WebRequest.PARAM_AJAX);
        cleanParameters.remove(WebRequest.PARAM_AJAX_BASE_URL);
        cleanParameters.remove(WebRequest.PARAM_AJAX_REQUEST_ANTI_CACHE);
        if (cleanParameters.isEmpty()) {
            cleanParameters = null;
        }
    }
    return cleanParameters;
}","/**
 *  Cleans the original parameters from entries used by Wicket internals.
 *
 *  @param originalParameters
 *             the current request's non-modified parameters
 *  @return all parameters but Wicket internal ones
 */
","private PageParameters cleanPageParameters(final PageParameters originalParameters) {
    PageParameters cleanParameters = null;
    if (originalParameters != null) {
        cleanParameters = new PageParameters(originalParameters);
                        cleanParameters.remove(WebRequest.PARAM_AJAX);
        cleanParameters.remove(WebRequest.PARAM_AJAX_BASE_URL);
        cleanParameters.remove(WebRequest.PARAM_AJAX_REQUEST_ANTI_CACHE);
        if (cleanParameters.isEmpty()) {
            cleanParameters = null;
        }
    }
    return cleanParameters;
}",-0.045454545454545456,0.18181818181818177,-0.2,0.0,-0.08333333333333333,0.13095238095238093,0.07399577167019025,-0.16666666666666666,0.05263157894736841,-0.013588976677443344
commons-math,remotes/origin/bugs-dot-jar_MATH-1068_b12610d3,3,"/**
 * Computes the Kendall's Tau rank correlation coefficient between the two arrays.
 *
 * @param xArray first data array
 * @param yArray second data array
 * @return Returns Kendall's Tau rank correlation coefficient for the two arrays
 * @throws DimensionMismatchException if the arrays lengths do not match
 */
public double correlation(final double[] xArray, final double[] yArray) throws DimensionMismatchException {
    if (xArray.length != yArray.length) {
        throw new DimensionMismatchException(xArray.length, yArray.length);
    }
    final int n = xArray.length;
    final int numPairs = n * (n - 1) / 2;
    @SuppressWarnings(""unchecked"")
    Pair<Double, Double>[] pairs = new Pair[n];
    for (int i = 0; i < n; i++) {
        pairs[i] = new Pair<Double, Double>(xArray[i], yArray[i]);
    }
    Arrays.sort(pairs, new Comparator<Pair<Double, Double>>() {

        public int compare(Pair<Double, Double> pair1, Pair<Double, Double> pair2) {
            int compareFirst = pair1.getFirst().compareTo(pair2.getFirst());
            return compareFirst != 0 ? compareFirst : pair1.getSecond().compareTo(pair2.getSecond());
        }
    });
    int tiedXPairs = 0;
    int tiedXYPairs = 0;
    int consecutiveXTies = 1;
    int consecutiveXYTies = 1;
    Pair<Double, Double> prev = pairs[0];
    for (int i = 1; i < n; i++) {
        final Pair<Double, Double> curr = pairs[i];
        if (curr.getFirst().equals(prev.getFirst())) {
            consecutiveXTies++;
            if (curr.getSecond().equals(prev.getSecond())) {
                consecutiveXYTies++;
            } else {
                tiedXYPairs += consecutiveXYTies * (consecutiveXYTies - 1) / 2;
                consecutiveXYTies = 1;
            }
        } else {
            tiedXPairs += consecutiveXTies * (consecutiveXTies - 1) / 2;
            consecutiveXTies = 1;
            tiedXYPairs += consecutiveXYTies * (consecutiveXYTies - 1) / 2;
            consecutiveXYTies = 1;
        }
        prev = curr;
    }
    tiedXPairs += consecutiveXTies * (consecutiveXTies - 1) / 2;
    tiedXYPairs += consecutiveXYTies * (consecutiveXYTies - 1) / 2;
    int swaps = 0;
    @SuppressWarnings(""unchecked"")
    Pair<Double, Double>[] pairsDestination = new Pair[n];
    for (int segmentSize = 1; segmentSize < n; segmentSize <<= 1) {
        for (int offset = 0; offset < n; offset += 2 * segmentSize) {
            int i = offset;
            final int iEnd = FastMath.min(i + segmentSize, n);
            int j = iEnd;
            final int jEnd = FastMath.min(j + segmentSize, n);
            int copyLocation = offset;
            while (i < iEnd || j < jEnd) {
                if (i < iEnd) {
                    if (j < jEnd) {
                        if (pairs[i].getSecond().compareTo(pairs[j].getSecond()) <= 0) {
                            pairsDestination[copyLocation] = pairs[i];
                            i++;
                        } else {
                            pairsDestination[copyLocation] = pairs[j];
                            j++;
                            swaps += iEnd - i;
                        }
                    } else {
                        pairsDestination[copyLocation] = pairs[i];
                        i++;
                    }
                } else {
                    pairsDestination[copyLocation] = pairs[j];
                    j++;
                }
                copyLocation++;
            }
        }
        final Pair<Double, Double>[] pairsTemp = pairs;
        pairs = pairsDestination;
        pairsDestination = pairsTemp;
    }
    int tiedYPairs = 0;
    int consecutiveYTies = 1;
    prev = pairs[0];
    for (int i = 1; i < n; i++) {
        final Pair<Double, Double> curr = pairs[i];
        if (curr.getSecond().equals(prev.getSecond())) {
            consecutiveYTies++;
        } else {
            tiedYPairs += consecutiveYTies * (consecutiveYTies - 1) / 2;
            consecutiveYTies = 1;
        }
        prev = curr;
    }
    tiedYPairs += consecutiveYTies * (consecutiveYTies - 1) / 2;
    int concordantMinusDiscordant = numPairs - tiedXPairs - tiedYPairs + tiedXYPairs - 2 * swaps;
    return concordantMinusDiscordant / FastMath.sqrt((numPairs - tiedXPairs) * (numPairs - tiedYPairs));
}","/**
 * Computes the Kendall's Tau rank correlation coefficient between the two arrays.
 *
 * @param xArray first data array
 * @param yArray second data array
 * @return Returns Kendall's Tau rank correlation coefficient for the two arrays
 * @throws DimensionMismatchException if the arrays lengths do not match
 */
","public double correlation(final double[] xArray, final double[] yArray) throws DimensionMismatchException {
    if (xArray.length != yArray.length) {
        throw new DimensionMismatchException(xArray.length, yArray.length);
    }
    final int n = xArray.length;
    final int numPairs = n * (n - 1) / 2;
    @SuppressWarnings(""unchecked"")
    Pair<Double, Double>[] pairs = new Pair[n];
    for (int i = 0; i < n; i++) {
        pairs[i] = new Pair<Double, Double>(xArray[i], yArray[i]);
    }
    Arrays.sort(pairs, new Comparator<Pair<Double, Double>>() {

        public int compare(Pair<Double, Double> pair1, Pair<Double, Double> pair2) {
            int compareFirst = pair1.getFirst().compareTo(pair2.getFirst());
            return compareFirst != 0 ? compareFirst : pair1.getSecond().compareTo(pair2.getSecond());
        }
    });
    int tiedXPairs = 0;
    int tiedXYPairs = 0;
    int consecutiveXTies = 1;
    int consecutiveXYTies = 1;
    Pair<Double, Double> prev = pairs[0];
    for (int i = 1; i < n; i++) {
        final Pair<Double, Double> curr = pairs[i];
        if (curr.getFirst().equals(prev.getFirst())) {
            consecutiveXTies++;
            if (curr.getSecond().equals(prev.getSecond())) {
                consecutiveXYTies++;
            } else {
                tiedXYPairs += consecutiveXYTies * (consecutiveXYTies - 1) / 2;
                consecutiveXYTies = 1;
            }
        } else {
            tiedXPairs += consecutiveXTies * (consecutiveXTies - 1) / 2;
            consecutiveXTies = 1;
            tiedXYPairs += consecutiveXYTies * (consecutiveXYTies - 1) / 2;
            consecutiveXYTies = 1;
        }
        prev = curr;
    }
    tiedXPairs += consecutiveXTies * (consecutiveXTies - 1) / 2;
    tiedXYPairs += consecutiveXYTies * (consecutiveXYTies - 1) / 2;
    int swaps = 0;
    @SuppressWarnings(""unchecked"")
    Pair<Double, Double>[] pairsDestination = new Pair[n];
    for (int segmentSize = 1; segmentSize < n; segmentSize <<= 1) {
        for (int offset = 0; offset < n; offset += 2 * segmentSize) {
            int i = offset;
            final int iEnd = FastMath.min(i + segmentSize, n);
            int j = iEnd;
            final int jEnd = FastMath.min(j + segmentSize, n);
            int copyLocation = offset;
            while (i < iEnd || j < jEnd) {
                if (i < iEnd) {
                    if (j < jEnd) {
                        if (pairs[i].getSecond().compareTo(pairs[j].getSecond()) <= 0) {
                            pairsDestination[copyLocation] = pairs[i];
                            i++;
                        } else {
                            pairsDestination[copyLocation] = pairs[j];
                            j++;
                            swaps += iEnd - i;
                        }
                    } else {
                        pairsDestination[copyLocation] = pairs[i];
                        i++;
                    }
                } else {
                    pairsDestination[copyLocation] = pairs[j];
                    j++;
                }
                copyLocation++;
            }
        }
        final Pair<Double, Double>[] pairsTemp = pairs;
        pairs = pairsDestination;
        pairsDestination = pairsTemp;
    }
    int tiedYPairs = 0;
    int consecutiveYTies = 1;
    prev = pairs[0];
    for (int i = 1; i < n; i++) {
        final Pair<Double, Double> curr = pairs[i];
        if (curr.getSecond().equals(prev.getSecond())) {
            consecutiveYTies++;
        } else {
            tiedYPairs += consecutiveYTies * (consecutiveYTies - 1) / 2;
            consecutiveYTies = 1;
        }
        prev = curr;
    }
    tiedYPairs += consecutiveYTies * (consecutiveYTies - 1) / 2;
    int concordantMinusDiscordant = numPairs - tiedXPairs - tiedYPairs + tiedXYPairs - 2 * swaps;
    return concordantMinusDiscordant / FastMath.sqrt((numPairs - tiedXPairs) * (numPairs - tiedYPairs));
}",3.6818181818181817,1.9856459330143539,2.4,2.0,2.1666666666666665,6.583333333333333,-1.3439041578576458,1.3333333333333333,-0.02631578947368421,37.852063415224485
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-3634_9339ecf8,3,"private int updateAuthKeys(String path) throws KeeperException, InterruptedException {
    int keysAdded = 0;
    for (String child : zk.getChildren(path, this)) {
        String childPath = path + ""/"" + child;
        // Get the node data and reset the watcher
        AuthenticationKey key = deserializeKey(zk.getData(childPath, this, null));
        secretManager.addKey(key);
        keysAdded++;
    }
    return keysAdded;
}",,"private int updateAuthKeys(String path) throws KeeperException, InterruptedException {
    int keysAdded = 0;
    for (String child : zk.getChildren(path, this)) {
        String childPath = path + ""/"" + child;
                AuthenticationKey key = deserializeKey(zk.getData(childPath, this, null));
        secretManager.addKey(key);
        keysAdded++;
    }
    return keysAdded;
}",-0.18181818181818182,0.0,-0.4,-0.5,-0.4166666666666667,-0.06746031746031747,0.17068357998590572,-0.16666666666666666,0.34210526315789475,-0.0533024440564075
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3879_4faf31e3,1,"/**
 * Following logic is taken from org.apache.jackrabbit.core.query.lucene.JackrabbitQueryParser#parse(java.lang.String)
 */
static String rewriteQueryText(String textsearch) {
    // replace escaped ' with just '
    StringBuilder rewritten = new StringBuilder();
    // the default lucene query parser recognizes 'AND' and 'NOT' as
    // keywords.
    textsearch = textsearch.replaceAll(""AND"", ""and"");
    textsearch = textsearch.replaceAll(""NOT"", ""not"");
    boolean escaped = false;
    for (int i = 0; i < textsearch.length(); i++) {
        char c = textsearch.charAt(i);
        if (c == '\\') {
            if (escaped) {
                rewritten.append(""\\\\"");
                escaped = false;
            } else {
                escaped = true;
            }
        } else if (c == '\'') {
            if (escaped) {
                escaped = false;
            }
            rewritten.append(c);
        } else if (c == ':' || c == '/') {
            // TODO Some other chars are also considered special See OAK-3769 for details
            // ':' fields as known in lucene are not supported
            // '/' its a special char used for regex search in Lucene
            rewritten.append('\\').append(c);
        } else {
            if (escaped) {
                rewritten.append('\\');
                escaped = false;
            }
            rewritten.append(c);
        }
    }
    return rewritten.toString();
}","/**
 * Following logic is taken from org.apache.jackrabbit.core.query.lucene.JackrabbitQueryParser#parse(java.lang.String)
 */
","static String rewriteQueryText(String textsearch) {
        StringBuilder rewritten = new StringBuilder();
            textsearch = textsearch.replaceAll(""AND"", ""and"");
    textsearch = textsearch.replaceAll(""NOT"", ""not"");
    boolean escaped = false;
    for (int i = 0; i < textsearch.length(); i++) {
        char c = textsearch.charAt(i);
        if (c == '\\') {
            if (escaped) {
                rewritten.append(""\\\\"");
                escaped = false;
            } else {
                escaped = true;
            }
        } else if (c == '\'') {
            if (escaped) {
                escaped = false;
            }
            rewritten.append(c);
        } else if (c == ':' || c == '/') {
                                                rewritten.append('\\').append(c);
        } else {
            if (escaped) {
                rewritten.append('\\');
                escaped = false;
            }
            rewritten.append(c);
        }
    }
    return rewritten.toString();
}",0.7727272727272727,0.875598086124402,0.8,1.5,0.5833333333333334,0.6726190476190477,-0.5281183932346721,0.4166666666666667,-0.02631578947368421,0.8527307619162876
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1199_813109d7,3,"public void getResult() throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException {
    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
        throw new IllegalStateException(""Method call not finished!"");
    }
    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
    (new Client(prot)).recv_removeConstraint();
}",,"public void getResult() throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException {
    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
        throw new IllegalStateException(""Method call not finished!"");
    }
    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
    (new Client(prot)).recv_removeConstraint();
}",-0.2727272727272727,-0.2822966507177035,-0.2,-0.5,-0.25,-0.053571428571428575,0.21099365750528534,0.0,-0.02631578947368421,0.004289921220817992
wicket,remotes/origin/bugs-dot-jar_WICKET-3428_ffc0cae9,1,"/**
 *  Convenience method that processes the request and detaches the {@link RequestCycle}.
 *
 *  @return <code>true</code> if the request resolved to a Wicket request, <code>false</code>
 *          otherwise.
 */
public boolean processRequestAndDetach() {
    boolean result;
    try {
        listeners.onBeginRequest(this);
        onBeginRequest();
        result = processRequest();
    } finally {
        detach();
    }
    return result;
}","/**
 *  Convenience method that processes the request and detaches the {@link RequestCycle}.
 *
 *  @return <code>true</code> if the request resolved to a Wicket request, <code>false</code>
 *          otherwise.
 */
","public boolean processRequestAndDetach() {
    boolean result;
    try {
        listeners.onBeginRequest(this);
        onBeginRequest();
        result = processRequest();
    } finally {
        detach();
    }
    return result;
}",-0.13636363636363635,-0.06220095693779921,-0.6,-0.5,-0.4166666666666667,-0.3650793650793651,0.3634954193093726,-0.16666666666666666,1.4999999999999998,-0.16279340490885932
camel,remotes/origin/bugs-dot-jar_CAMEL-3690_2a3f3392,3,"public void addService(Object object) throws Exception {
    if (object instanceof Service) {
        Service service = (Service) object;
        for (LifecycleStrategy strategy : lifecycleStrategies) {
            if (service instanceof Endpoint) {
                // use specialized endpoint add
                strategy.onEndpointAdd((Endpoint) service);
            } else {
                strategy.onServiceAdd(this, service, null);
            }
        }
        // only add to services to close if its a singleton
        // otherwise we could for example end up with a lot of prototype scope endpoints
        // assume singleton by default
        boolean singleton = true;
        if (service instanceof IsSingleton) {
            singleton = ((IsSingleton) service).isSingleton();
        }
        if (singleton) {
            servicesToClose.add(service);
        }
    }
    startServices(object);
}",,"public void addService(Object object) throws Exception {
    if (object instanceof Service) {
        Service service = (Service) object;
        for (LifecycleStrategy strategy : lifecycleStrategies) {
            if (service instanceof Endpoint) {
                                strategy.onEndpointAdd((Endpoint) service);
            } else {
                strategy.onServiceAdd(this, service, null);
            }
        }
                                boolean singleton = true;
        if (service instanceof IsSingleton) {
            singleton = ((IsSingleton) service).isSingleton();
        }
        if (singleton) {
            servicesToClose.add(service);
        }
    }
    startServices(object);
}",0.2727272727272727,0.6555023923444977,0.4,0.5,0.16666666666666666,-0.3650793650793651,-0.19295278365045798,-0.08333333333333333,0.02631578947368421,-0.16279340490885932
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1178_f2bb1a17,1,"/**
 * Internal method for checking whether this node exists and is visible
 * (i.e. not hidden).
 *
 * @return {@true} if the node is visible, {@code false} if not
 */
private boolean isVisible() {
    return !isHidden(name) && nodeBuilder.exists();
}","/**
 * Internal method for checking whether this node exists and is visible
 * (i.e. not hidden).
 *
 * @return {@true} if the node is visible, {@code false} if not
 */
","private boolean isVisible() {
    return !isHidden(name) && nodeBuilder.exists();
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.16666666666666669,1.0036645525017613,-0.3333333333333333,2.5789473684210527,-0.15172858929363828
Closure,87,2,"/**
 * @return Whether the node is a block with a single statement that is
 *     an expression.
 */
private boolean isFoldableExpressBlock(Node n) {
    if (n.getType() == Token.BLOCK) {
        if (n.hasOneChild()) {
            Node maybeExpr = n.getFirstChild();
            return NodeUtil.isExpressionNode(maybeExpr);
        }
    }
    return false;
}","/**
 * @return Whether the node is a block with a single statement that is
 *     an expression.
 */
","private boolean isFoldableExpressBlock(Node n) {
    if (n.getType() == Token.BLOCK) {
        if (n.hasOneChild()) {
            Node maybeExpr = n.getFirstChild();
            return NodeUtil.isExpressionNode(maybeExpr);
        }
    }
    return false;
}",-0.22727272727272727,0.6076555023923443,-0.2,0.0,-0.08333333333333333,-0.0912698412698413,0.31585623678646924,-0.16666666666666666,2.3684210526315788,-0.11291413818341084
wicket,remotes/origin/bugs-dot-jar_WICKET-2065_9da430fb,1,"protected void appendParameters(AppendingStringBuffer url, Map parameters) {
    int i = 0;
    while (parameters.containsKey(String.valueOf(i))) {
        String value = (String) parameters.get(String.valueOf(i));
        if (!url.endsWith(""/"")) {
            url.append(""/"");
        }
        url.append(urlEncodePathComponent(value)).append(""/"");
        i++;
    }
    String pageMap = (String) parameters.get(WebRequestCodingStrategy.PAGEMAP);
    if (pageMap != null) {
        i++;
        pageMap = WebRequestCodingStrategy.encodePageMapName(pageMap);
        if (!url.endsWith(""/"")) {
            url.append(""/"");
        }
        url.append(WebRequestCodingStrategy.PAGEMAP).append(""/"").append(urlEncodePathComponent(pageMap)).append(""/"");
    }
    if (i != parameters.size()) {
        throw new WicketRuntimeException(""Not all parameters were encoded. Make sure all parameter names are integers in consecutive order starting with zero. Current parameter names are: "" + parameters.keySet().toString());
    }
}",,"protected void appendParameters(AppendingStringBuffer url, Map parameters) {
    int i = 0;
    while (parameters.containsKey(String.valueOf(i))) {
        String value = (String) parameters.get(String.valueOf(i));
        if (!url.endsWith(""/"")) {
            url.append(""/"");
        }
        url.append(urlEncodePathComponent(value)).append(""/"");
        i++;
    }
    String pageMap = (String) parameters.get(WebRequestCodingStrategy.PAGEMAP);
    if (pageMap != null) {
        i++;
        pageMap = WebRequestCodingStrategy.encodePageMapName(pageMap);
        if (!url.endsWith(""/"")) {
            url.append(""/"");
        }
        url.append(WebRequestCodingStrategy.PAGEMAP).append(""/"").append(urlEncodePathComponent(pageMap)).append(""/"");
    }
    if (i != parameters.size()) {
        throw new WicketRuntimeException(""Not all parameters were encoded. Make sure all parameter names are integers in consecutive order starting with zero. Current parameter names are: "" + parameters.keySet().toString());
    }
}",0.4090909090909091,0.04306220095693773,0.6,0.0,0.5,0.7083333333333334,-0.3849189570119802,1.25,-0.02631578947368421,0.8842654864196676
wicket,remotes/origin/bugs-dot-jar_WICKET-4102_e743fd7e,1,"@Override
public void onComponentTagBody(final MarkupStream markupStream, final ComponentTag openTag) {
    boolean storeLabelText = false;
    // try and find some form of label content...
    String labelText = null;
    if (labeled instanceof ILabelProvider) {
        ILabelProvider<String> provider = (ILabelProvider<String>) labeled;
        if (provider.getLabel() != null) {
            String text = provider.getLabel().getObject();
            if (!Strings.isEmpty(text)) {
                labelText = text;
            }
        }
    }
    if (labelText == null && labeled instanceof FormComponent) {
        String text = ((FormComponent<?>) labeled).getDefaultLabel(""wicket:unknown"");
        if (!""wicket:unknown"".equals(text) && !Strings.isEmpty(text)) {
            labelText = text;
        }
    }
    // check if wicket:label tag has a message key
    if (labelText == null && openTag.getAttribute(""key"") != null) {
        String text = labeled.getString(openTag.getAttribute(""key""));
        if (!Strings.isEmpty(text)) {
            labelText = text;
            storeLabelText = true;
        }
    }
    // as last resort use the tag body
    if (labelText == null) {
        String text = new ResponseBufferZone(RequestCycle.get(), markupStream) {

            @Override
            protected void executeInsideBufferedZone() {
                TextLabel.super.onComponentTagBody(markupStream, openTag);
            }
        }.execute().toString();
        if (!Strings.isEmpty(text)) {
            labelText = text;
            storeLabelText = true;
        }
    }
    // print the label text
    replaceComponentTagBody(markupStream, openTag, labelText);
    // store the label text in FormComponent's label model so its available to errors
    if (labeled instanceof FormComponent) {
        FormComponent<?> fc = (FormComponent<?>) labeled;
        fc.setLabel(Model.of(labelText));
    }
}",,"@Override
public void onComponentTagBody(final MarkupStream markupStream, final ComponentTag openTag) {
    boolean storeLabelText = false;
        String labelText = null;
    if (labeled instanceof ILabelProvider) {
        ILabelProvider<String> provider = (ILabelProvider<String>) labeled;
        if (provider.getLabel() != null) {
            String text = provider.getLabel().getObject();
            if (!Strings.isEmpty(text)) {
                labelText = text;
            }
        }
    }
    if (labelText == null && labeled instanceof FormComponent) {
        String text = ((FormComponent<?>) labeled).getDefaultLabel(""wicket:unknown"");
        if (!""wicket:unknown"".equals(text) && !Strings.isEmpty(text)) {
            labelText = text;
        }
    }
        if (labelText == null && openTag.getAttribute(""key"") != null) {
        String text = labeled.getString(openTag.getAttribute(""key""));
        if (!Strings.isEmpty(text)) {
            labelText = text;
            storeLabelText = true;
        }
    }
        if (labelText == null) {
        String text = new ResponseBufferZone(RequestCycle.get(), markupStream) {

            @Override
            protected void executeInsideBufferedZone() {
                TextLabel.super.onComponentTagBody(markupStream, openTag);
            }
        }.execute().toString();
        if (!Strings.isEmpty(text)) {
            labelText = text;
            storeLabelText = true;
        }
    }
        replaceComponentTagBody(markupStream, openTag, labelText);
        if (labeled instanceof FormComponent) {
        FormComponent<?> fc = (FormComponent<?>) labeled;
        fc.setLabel(Model.of(labelText));
    }
}",1.3636363636363635,0.4736842105263157,1.4,0.5,1.25,0.7162698412698413,-0.7916842847075402,1.0833333333333333,-0.02631578947368421,1.713873088870063
flink,remotes/origin/bugs-dot-jar_FLINK-3740_f2f5bd5b,1,"private void processTriggersFor(Watermark mark) throws Exception {
    boolean fire;
    do {
        Timer<K, W> timer = watermarkTimersQueue.peek();
        if (timer != null && timer.timestamp <= mark.getTimestamp()) {
            fire = true;
            watermarkTimers.remove(timer);
            watermarkTimersQueue.remove();
            context.key = timer.key;
            context.window = timer.window;
            setKeyContext(timer.key);
            TriggerResult triggerResult = context.onEventTime(timer.timestamp);
            processTriggerResult(triggerResult, context.key, context.window);
        } else {
            fire = false;
        }
    } while (fire);
}",,"private void processTriggersFor(Watermark mark) throws Exception {
    boolean fire;
    do {
        Timer<K, W> timer = watermarkTimersQueue.peek();
        if (timer != null && timer.timestamp <= mark.getTimestamp()) {
            fire = true;
            watermarkTimers.remove(timer);
            watermarkTimersQueue.remove();
            context.key = timer.key;
            context.window = timer.window;
            setKeyContext(timer.key);
            TriggerResult triggerResult = context.onEventTime(timer.timestamp);
            processTriggerResult(triggerResult, context.key, context.window);
        } else {
            fire = false;
        }
    } while (fire);
}",0.18181818181818182,0.5741626794258374,-0.2,0.0,0.16666666666666666,0.3849206349206349,-0.19661733615221966,0.08333333333333333,-0.02631578947368421,0.35492470738749327
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-366_db4a291f,1,"void initiateClose(boolean saveState, boolean queueMinC, boolean disableWrites) {
    if (!saveState && queueMinC) {
        throw new IllegalArgumentException(""Not saving state on close and requesting minor compactions queue does not make sense"");
    }
    log.debug(""initiateClose(saveState="" + saveState + "" queueMinC="" + queueMinC + "" disableWrites="" + disableWrites + "") "" + getExtent());
    MinorCompactionTask mct = null;
    synchronized (this) {
        if (closed || closing || closeComplete) {
            String msg = ""Tablet "" + getExtent() + "" already"";
            if (closed)
                msg += "" closed"";
            if (closing)
                msg += "" closing"";
            if (closeComplete)
                msg += "" closeComplete"";
            throw new IllegalStateException(msg);
        }
        // enter the closing state, no splits, minor, or major compactions can start
        // should cause running major compactions to stop
        closing = true;
        this.notifyAll();
        // determines if inserts and queries can still continue while minor compacting
        closed = disableWrites;
        // true should cause any running major compactions to abort
        while (majorCompactionInProgress) {
            try {
                this.wait(50);
            } catch (InterruptedException e) {
                log.error(e.toString());
            }
        }
        if (!saveState || tabletMemory.getMemTable().getNumEntries() == 0) {
            return;
        }
        tabletMemory.waitForMinC();
        mct = prepareForMinC(getFlushID());
        if (queueMinC) {
            tabletResources.executeMinorCompaction(mct);
            return;
        }
    }
    // do minor compaction outside of synch block so that tablet can be read and written to while
    // compaction runs
    mct.run();
}",,"void initiateClose(boolean saveState, boolean queueMinC, boolean disableWrites) {
    if (!saveState && queueMinC) {
        throw new IllegalArgumentException(""Not saving state on close and requesting minor compactions queue does not make sense"");
    }
    log.debug(""initiateClose(saveState="" + saveState + "" queueMinC="" + queueMinC + "" disableWrites="" + disableWrites + "") "" + getExtent());
    MinorCompactionTask mct = null;
    synchronized (this) {
        if (closed || closing || closeComplete) {
            String msg = ""Tablet "" + getExtent() + "" already"";
            if (closed)
                msg += "" closed"";
            if (closing)
                msg += "" closing"";
            if (closeComplete)
                msg += "" closeComplete"";
            throw new IllegalStateException(msg);
        }
                        closing = true;
        this.notifyAll();
                closed = disableWrites;
                while (majorCompactionInProgress) {
            try {
                this.wait(50);
            } catch (InterruptedException e) {
                log.error(e.toString());
            }
        }
        if (!saveState || tabletMemory.getMemTable().getNumEntries() == 0) {
            return;
        }
        tabletMemory.waitForMinC();
        mct = prepareForMinC(getFlushID());
        if (queueMinC) {
            tabletResources.executeMinorCompaction(mct);
            return;
        }
    }
            mct.run();
}",1.1363636363636365,0.5885167464114831,1.6,0.5,1.1666666666666667,0.5337301587301588,-0.6842847075405215,0.6666666666666666,-0.02631578947368421,0.8833019253931754
wicket,remotes/origin/bugs-dot-jar_WICKET-1931_986848f7,1,"@Override
public int read() {
    return -1;
}",,"@Override
public int read() {
    return -1;
}",-0.45454545454545453,-0.6028708133971293,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.9785764622973924,-0.5,2.289473684210526,-0.16279340490885932
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1505_b082fc1e,1,"@Override
public void addMutations(Iterable<Mutation> iterable) throws MutationsRejectedException {
    for (Mutation m : iterable) {
        acu.addMutation(tablename, m);
    }
}",,"@Override
public void addMutations(Iterable<Mutation> iterable) throws MutationsRejectedException {
    for (Mutation m : iterable) {
        acu.addMutation(tablename, m);
    }
}",-0.36363636363636365,-0.004784688995215422,-0.4,-0.5,-0.4166666666666667,-0.3650793650793651,0.5777307963354474,-0.4166666666666667,0.5,-0.16279340490885932
commons-math,remotes/origin/bugs-dot-jar_MATH-320_c06cc933,1,"/**
 * {@inheritDoc}
 */
public RealMatrix getU() throws InvalidMatrixException {
    if (cachedU == null) {
        if (m >= n) {
            // the tridiagonal matrix is Bt.B, where B is upper bidiagonal
            final double[][] eData = eigenDecomposition.getV().getData();
            final double[][] iData = new double[m][];
            double[] ei1 = eData[0];
            iData[0] = ei1;
            for (int i = 0; i < n - 1; ++i) {
                // compute B.E.S^(-1) where E is the eigenvectors matrix
                // we reuse the array from matrix E to store the result
                final double mi = mainBidiagonal[i];
                final double si = secondaryBidiagonal[i];
                final double[] ei0 = ei1;
                ei1 = eData[i + 1];
                iData[i + 1] = ei1;
                for (int j = 0; j < n; ++j) {
                    ei0[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];
                }
            }
            // last row
            final double lastMain = mainBidiagonal[n - 1];
            for (int j = 0; j < n; ++j) {
                ei1[j] *= lastMain / singularValues[j];
            }
            for (int i = n; i < m; ++i) {
                iData[i] = new double[n];
            }
            cachedU = transformer.getU().multiply(MatrixUtils.createRealMatrix(iData));
        } else {
            // the tridiagonal matrix is B.Bt, where B is lower bidiagonal
            cachedU = transformer.getU().multiply(eigenDecomposition.getV());
        }
    }
    // return the cached matrix
    return cachedU;
}","/**
 * {@inheritDoc}
 */
","public RealMatrix getU() throws InvalidMatrixException {
    if (cachedU == null) {
        if (m >= n) {
                        final double[][] eData = eigenDecomposition.getV().getData();
            final double[][] iData = new double[m][];
            double[] ei1 = eData[0];
            iData[0] = ei1;
            for (int i = 0; i < n - 1; ++i) {
                                                final double mi = mainBidiagonal[i];
                final double si = secondaryBidiagonal[i];
                final double[] ei0 = ei1;
                ei1 = eData[i + 1];
                iData[i + 1] = ei1;
                for (int j = 0; j < n; ++j) {
                    ei0[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];
                }
            }
                        final double lastMain = mainBidiagonal[n - 1];
            for (int j = 0; j < n; ++j) {
                ei1[j] *= lastMain / singularValues[j];
            }
            for (int i = n; i < m; ++i) {
                iData[i] = new double[n];
            }
            cachedU = transformer.getU().multiply(MatrixUtils.createRealMatrix(iData));
        } else {
                        cachedU = transformer.getU().multiply(eigenDecomposition.getV());
        }
    }
        return cachedU;
}",0.7727272727272727,0.8899521531100476,0.6,1.0,0.5,2.8154761904761907,-0.5946441155743479,0.16666666666666666,-0.02631578947368421,4.955642767817522
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-579_7d72e6ed,3,"public QueryIndex getBestIndex(Query query, NodeState rootState, Filter filter) {
    QueryIndex best = null;
    if (LOG.isDebugEnabled()) {
        LOG.debug(""cost using filter "" + filter);
    }
    double bestCost = Double.POSITIVE_INFINITY;
    for (QueryIndex index : getIndexes(rootState)) {
        double cost = index.getCost(filter, rootState);
        if (LOG.isDebugEnabled()) {
            LOG.debug(""cost for "" + index.getIndexName() + "" is "" + cost);
        }
        if (cost < bestCost) {
            bestCost = cost;
            best = index;
        }
    }
    if (best == null) {
        if (LOG.isDebugEnabled()) {
            LOG.debug(""no indexes found - using TraversingIndex; indexProvider: "" + indexProvider);
        }
        best = new TraversingIndex();
    }
    return best;
}",,"public QueryIndex getBestIndex(Query query, NodeState rootState, Filter filter) {
    QueryIndex best = null;
    if (LOG.isDebugEnabled()) {
        LOG.debug(""cost using filter "" + filter);
    }
    double bestCost = Double.POSITIVE_INFINITY;
    for (QueryIndex index : getIndexes(rootState)) {
        double cost = index.getCost(filter, rootState);
        if (LOG.isDebugEnabled()) {
            LOG.debug(""cost for "" + index.getIndexName() + "" is "" + cost);
        }
        if (cost < bestCost) {
            bestCost = cost;
            best = index;
        }
    }
    if (best == null) {
        if (LOG.isDebugEnabled()) {
            LOG.debug(""no indexes found - using TraversingIndex; indexProvider: "" + indexProvider);
        }
        best = new TraversingIndex();
    }
    return best;
}",0.45454545454545453,0.21052631578947367,0.6,0.0,0.3333333333333333,0.4285714285714286,-0.3713883016208596,0.25,0.0,0.45499213360764845
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3324_5f863af6,1,"@Override
public boolean isGranted(long repositoryPermissions) {
    return hasPermissions(getEntryIterator(new EntryPredicate()), repositoryPermissions, null);
}",,"@Override
public boolean isGranted(long repositoryPermissions) {
    return hasPermissions(getEntryIterator(new EntryPredicate()), repositoryPermissions, null);
}",-0.45454545454545453,-0.6028708133971293,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.8548273431994357,-0.3333333333333333,0.31578947368421056,-0.16279340490885932
commons-math,remotes/origin/bugs-dot-jar_MATH-371_bb005b56,1,"/**
 * Returns a matrix of p-values associated with the (two-sided) null
 * hypothesis that the corresponding correlation coefficient is zero.
 * <p><code>getCorrelationPValues().getEntry(i,j)</code> is the probability
 * that a random variable distributed as <code>t<sub>n-2</sub></code> takes
 * a value with absolute value greater than or equal to <br>
 * <code>|r|((n - 2) / (1 - r<sup>2</sup>))<sup>1/2</sup></code></p>
 * <p>The values in the matrix are sometimes referred to as the
 * <i>significance</i> of the corresponding correlation coefficients.</p>
 *
 * @return matrix of p-values
 * @throws MathException if an error occurs estimating probabilities
 */
public RealMatrix getCorrelationPValues() throws MathException {
    TDistribution tDistribution = new TDistributionImpl(nObs - 2);
    int nVars = correlationMatrix.getColumnDimension();
    double[][] out = new double[nVars][nVars];
    for (int i = 0; i < nVars; i++) {
        for (int j = 0; j < nVars; j++) {
            if (i == j) {
                out[i][j] = 0d;
            } else {
                double r = correlationMatrix.getEntry(i, j);
                double t = Math.abs(r * Math.sqrt((nObs - 2) / (1 - r * r)));
                out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));
            }
        }
    }
    return new BlockRealMatrix(out);
}","/**
 * Returns a matrix of p-values associated with the (two-sided) null
 * hypothesis that the corresponding correlation coefficient is zero.
 * <p><code>getCorrelationPValues().getEntry(i,j)</code> is the probability
 * that a random variable distributed as <code>t<sub>n-2</sub></code> takes
 * a value with absolute value greater than or equal to <br>
 * <code>|r|((n - 2) / (1 - r<sup>2</sup>))<sup>1/2</sup></code></p>
 * <p>The values in the matrix are sometimes referred to as the
 * <i>significance</i> of the corresponding correlation coefficients.</p>
 *
 * @return matrix of p-values
 * @throws MathException if an error occurs estimating probabilities
 */
","public RealMatrix getCorrelationPValues() throws MathException {
    TDistribution tDistribution = new TDistributionImpl(nObs - 2);
    int nVars = correlationMatrix.getColumnDimension();
    double[][] out = new double[nVars][nVars];
    for (int i = 0; i < nVars; i++) {
        for (int j = 0; j < nVars; j++) {
            if (i == j) {
                out[i][j] = 0d;
            } else {
                double r = correlationMatrix.getEntry(i, j);
                double t = Math.abs(r * Math.sqrt((nObs - 2) / (1 - r * r)));
                out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));
            }
        }
    }
    return new BlockRealMatrix(out);
}",0.13636363636363635,1.2344497607655505,0.0,0.5,0.08333333333333333,0.9404761904761905,-0.2197322057787174,-0.08333333333333333,0.02631578947368421,1.0455536153708727
flink,remotes/origin/bugs-dot-jar_FLINK-3011_5a86a0a1,0,"public void cancel() {
    while (true) {
        JobStatus current = state;
        if (current == JobStatus.RUNNING || current == JobStatus.CREATED) {
            if (transitionState(current, JobStatus.CANCELLING)) {
                for (ExecutionJobVertex ejv : verticesInCreationOrder) {
                    ejv.cancel();
                }
                return;
            }
        } else {
            // no need to treat other states
            return;
        }
    }
}",,"public void cancel() {
    while (true) {
        JobStatus current = state;
        if (current == JobStatus.RUNNING || current == JobStatus.CREATED) {
            if (transitionState(current, JobStatus.CANCELLING)) {
                for (ExecutionJobVertex ejv : verticesInCreationOrder) {
                    ejv.cancel();
                }
                return;
            }
        } else {
                        return;
        }
    }
}",0.045454545454545456,1.3492822966507174,0.2,1.0,0.08333333333333333,-0.04365079365079365,0.03340380549682881,-0.3333333333333333,0.5263157894736842,-0.08831797513874241
Cli,27,1,"/**
 * Set the selected option of this group to <code>name</code>.
 *
 * @param option the option that is selected
 * @throws AlreadySelectedException if an option from this group has
 * already been selected.
 */
public void setSelected(Option option) throws AlreadySelectedException {
    if (option == null) {
        // reset the option previously selected
        selected = null;
        return;
    }
    // selected member variable
    if (selected == null || selected.equals(option.getOpt())) {
        selected = option.getOpt();
    } else {
        throw new AlreadySelectedException(this, option);
    }
}","/**
 * Set the selected option of this group to <code>name</code>.
 *
 * @param option the option that is selected
 * @throws AlreadySelectedException if an option from this group has
 * already been selected.
 */
","public void setSelected(Option option) throws AlreadySelectedException {
    if (option == null) {
                selected = null;
        return;
    }
        if (selected == null || selected.equals(option.getOpt())) {
        selected = option.getOpt();
    } else {
        throw new AlreadySelectedException(this, option);
    }
}",-0.13636363636363635,-0.06220095693779921,0.0,-0.5,0.16666666666666666,0.07539682539682542,0.19774489076814655,-0.25,0.21052631578947367,-0.07097387666188344
camel,remotes/origin/bugs-dot-jar_CAMEL-6779_f412d744,1,"@Converter
public XMLStreamReader createXMLStreamReader(InputStream in, Exchange exchange) throws XMLStreamException {
    XMLInputFactory factory = getInputFactory();
    try {
        return factory.createXMLStreamReader(IOHelper.buffered(in), IOHelper.getCharsetName(exchange));
    } finally {
        returnXMLInputFactory(factory);
    }
}",,"@Converter
public XMLStreamReader createXMLStreamReader(InputStream in, Exchange exchange) throws XMLStreamException {
    XMLInputFactory factory = getInputFactory();
    try {
        return factory.createXMLStreamReader(IOHelper.buffered(in), IOHelper.getCharsetName(exchange));
    } finally {
        returnXMLInputFactory(factory);
    }
}",-0.22727272727272727,-0.01913875598086126,-0.6,-0.5,-0.4166666666666667,-0.3650793650793651,0.30176180408738534,-0.08333333333333333,0.2894736842105263,-0.16279340490885932
Closure,4,2,"/**
 * Resolve the referenced type within the enclosing scope.
 */
@Override
JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {
    // TODO(user): Investigate whether it is really necessary to keep two
    // different mechanisms for resolving named types, and if so, which order
    // makes more sense. Now, resolution via registry is first in order to
    // avoid triggering the warnings built into the resolution via properties.
    boolean resolved = resolveViaRegistry(t, enclosing);
    if (detectImplicitPrototypeCycle()) {
        handleTypeCycle(t);
    }
    if (resolved) {
        super.resolveInternal(t, enclosing);
        finishPropertyContinuations();
        return registry.isLastGeneration() ? getReferencedType() : this;
    }
    resolveViaProperties(t, enclosing);
    if (detectImplicitPrototypeCycle()) {
        handleTypeCycle(t);
    }
    super.resolveInternal(t, enclosing);
    if (isResolved()) {
        finishPropertyContinuations();
    }
    return registry.isLastGeneration() ? getReferencedType() : this;
}","/**
 * Resolve the referenced type within the enclosing scope.
 */
","@Override
JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {
                    boolean resolved = resolveViaRegistry(t, enclosing);
    if (detectImplicitPrototypeCycle()) {
        handleTypeCycle(t);
    }
    if (resolved) {
        super.resolveInternal(t, enclosing);
        finishPropertyContinuations();
        return registry.isLastGeneration() ? getReferencedType() : this;
    }
    resolveViaProperties(t, enclosing);
    if (detectImplicitPrototypeCycle()) {
        handleTypeCycle(t);
    }
    super.resolveInternal(t, enclosing);
    if (isResolved()) {
        finishPropertyContinuations();
    }
    return registry.isLastGeneration() ? getReferencedType() : this;
}",0.3181818181818182,-0.20574162679425848,0.6,-0.5,0.4166666666666667,-0.3650793650793651,-0.20704721634954185,0.75,-0.02631578947368421,-0.16279340490885932
Math,50,1,"/**
 * {@inheritDoc}
 */
protected final double doSolve() {
    // Get initial solution
    double x0 = getMin();
    double x1 = getMax();
    double f0 = computeObjectiveValue(x0);
    double f1 = computeObjectiveValue(x1);
    // regardless of the allowed solutions.
    if (f0 == 0.0) {
        return x0;
    }
    if (f1 == 0.0) {
        return x1;
    }
    // Verify bracketing of initial solution.
    verifyBracketing(x0, x1);
    // Get accuracies.
    final double ftol = getFunctionValueAccuracy();
    final double atol = getAbsoluteAccuracy();
    final double rtol = getRelativeAccuracy();
    // Keep track of inverted intervals, meaning that the left bound is
    // larger than the right bound.
    boolean inverted = false;
    // Keep finding better approximations.
    while (true) {
        // Calculate the next approximation.
        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
        final double fx = computeObjectiveValue(x);
        // we can return it regardless of the allowed solutions.
        if (fx == 0.0) {
            return x;
        }
        // Update the bounds with the new approximation.
        if (f1 * fx < 0) {
            // The value of x1 has switched to the other bound, thus inverting
            // the interval.
            x0 = x1;
            f0 = f1;
            inverted = !inverted;
        } else {
            switch(method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                    break;
                case REGULA_FALSI:
                    // Nothing.
                    if (x == x1) {
                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));
                        f0 = computeObjectiveValue(x0);
                    }
                    break;
                default:
                    // Should never happen.
                    throw new MathInternalError();
            }
        }
        // Update from [x0, x1] to [x0, x].
        x1 = x;
        f1 = fx;
        // the root than we already are.
        if (FastMath.abs(f1) <= ftol) {
            switch(allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
            }
        }
        // are satisfied with the current approximation.
        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {
            switch(allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
            }
        }
    }
}","/**
 * {@inheritDoc}
 */
","protected final double doSolve() {
        double x0 = getMin();
    double x1 = getMax();
    double f0 = computeObjectiveValue(x0);
    double f1 = computeObjectiveValue(x1);
        if (f0 == 0.0) {
        return x0;
    }
    if (f1 == 0.0) {
        return x1;
    }
        verifyBracketing(x0, x1);
        final double ftol = getFunctionValueAccuracy();
    final double atol = getAbsoluteAccuracy();
    final double rtol = getRelativeAccuracy();
            boolean inverted = false;
        while (true) {
                final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
        final double fx = computeObjectiveValue(x);
                if (fx == 0.0) {
            return x;
        }
                if (f1 * fx < 0) {
                                    x0 = x1;
            f0 = f1;
            inverted = !inverted;
        } else {
            switch(method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                    break;
                case REGULA_FALSI:
                                        if (x == x1) {
                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));
                        f0 = computeObjectiveValue(x0);
                    }
                    break;
                default:
                                        throw new MathInternalError();
            }
        }
                x1 = x;
        f1 = fx;
                if (FastMath.abs(f1) <= ftol) {
            switch(allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
            }
        }
                if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {
            switch(allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
            }
        }
    }
}",3.5454545454545454,1.7751196172248804,7.8,1.5,3.3333333333333335,3.238095238095238,-1.3833685694150806,0.8333333333333334,-0.02631578947368421,8.485761541697642
Compress,32,3,"private void applyPaxHeadersToCurrentEntry(Map<String, String> headers) {
    /*
         * The following headers are defined for Pax.
         * atime, ctime, charset: cannot use these without changing TarArchiveEntry fields
         * mtime
         * comment
         * gid, gname
         * linkpath
         * size
         * uid,uname
         * SCHILY.devminor, SCHILY.devmajor: don't have setters/getters for those
         */
    for (Entry<String, String> ent : headers.entrySet()) {
        String key = ent.getKey();
        String val = ent.getValue();
        if (""path"".equals(key)) {
            currEntry.setName(val);
        } else if (""linkpath"".equals(key)) {
            currEntry.setLinkName(val);
        } else if (""gid"".equals(key)) {
            currEntry.setGroupId(Integer.parseInt(val));
        } else if (""gname"".equals(key)) {
            currEntry.setGroupName(val);
        } else if (""uid"".equals(key)) {
            currEntry.setUserId(Integer.parseInt(val));
        } else if (""uname"".equals(key)) {
            currEntry.setUserName(val);
        } else if (""size"".equals(key)) {
            currEntry.setSize(Long.parseLong(val));
        } else if (""mtime"".equals(key)) {
            currEntry.setModTime((long) (Double.parseDouble(val) * 1000));
        } else if (""SCHILY.devminor"".equals(key)) {
            currEntry.setDevMinor(Integer.parseInt(val));
        } else if (""SCHILY.devmajor"".equals(key)) {
            currEntry.setDevMajor(Integer.parseInt(val));
        }
    }
}",,"private void applyPaxHeadersToCurrentEntry(Map<String, String> headers) {
        for (Entry<String, String> ent : headers.entrySet()) {
        String key = ent.getKey();
        String val = ent.getValue();
        if (""path"".equals(key)) {
            currEntry.setName(val);
        } else if (""linkpath"".equals(key)) {
            currEntry.setLinkName(val);
        } else if (""gid"".equals(key)) {
            currEntry.setGroupId(Integer.parseInt(val));
        } else if (""gname"".equals(key)) {
            currEntry.setGroupName(val);
        } else if (""uid"".equals(key)) {
            currEntry.setUserId(Integer.parseInt(val));
        } else if (""uname"".equals(key)) {
            currEntry.setUserName(val);
        } else if (""size"".equals(key)) {
            currEntry.setSize(Long.parseLong(val));
        } else if (""mtime"".equals(key)) {
            currEntry.setModTime((long) (Double.parseDouble(val) * 1000));
        } else if (""SCHILY.devminor"".equals(key)) {
            currEntry.setDevMinor(Integer.parseInt(val));
        } else if (""SCHILY.devmajor"".equals(key)) {
            currEntry.setDevMajor(Integer.parseInt(val));
        }
    }
}",0.5909090909090909,0.1913875598086124,1.6,4.5,1.3333333333333333,0.0853174603174603,-0.5221987315010571,1.9166666666666667,-0.02631578947368421,0.3819643505471896
commons-math,remotes/origin/bugs-dot-jar_MATH-343_f6dd42b4,0,"/**
 * Find a zero in the given interval with an initial guess.
 * <p>Throws <code>IllegalArgumentException</code> if the values of the
 * function at the three points have the same sign (note that it is
 * allowed to have endpoints with the same sign if the initial point has
 * opposite sign function-wise).</p>
 *
 * @param f function to solve.
 * @param min the lower bound for the interval.
 * @param max the upper bound for the interval.
 * @param initial the start value to use (must be set to min if no
 * initial point is known).
 * @return the value where the function is zero
 * @throws MaxIterationsExceededException the maximum iteration count
 * is exceeded
 * @throws FunctionEvaluationException if an error occurs evaluating
 *  the function
 * @throws IllegalArgumentException if initial is not between min and max
 * (even if it <em>is</em> a root)
 */
public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial) throws MaxIterationsExceededException, FunctionEvaluationException {
    clearResult();
    verifySequence(min, initial, max);
    // return the initial guess if it is good enough
    double yInitial = f.value(initial);
    if (Math.abs(yInitial) <= functionValueAccuracy) {
        setResult(initial, 0);
        return result;
    }
    // return the first endpoint if it is good enough
    double yMin = f.value(min);
    if (Math.abs(yMin) <= functionValueAccuracy) {
        setResult(yMin, 0);
        return result;
    }
    // reduce interval if min and initial bracket the root
    if (yInitial * yMin < 0) {
        return solve(f, min, yMin, initial, yInitial, min, yMin);
    }
    // return the second endpoint if it is good enough
    double yMax = f.value(max);
    if (Math.abs(yMax) <= functionValueAccuracy) {
        setResult(yMax, 0);
        return result;
    }
    // reduce interval if initial and max bracket the root
    if (yInitial * yMax < 0) {
        return solve(f, initial, yInitial, max, yMax, initial, yInitial);
    }
    // full Brent algorithm starting with provided initial guess
    return solve(f, min, yMin, max, yMax, initial, yInitial);
}","/**
 * Find a zero in the given interval with an initial guess.
 * <p>Throws <code>IllegalArgumentException</code> if the values of the
 * function at the three points have the same sign (note that it is
 * allowed to have endpoints with the same sign if the initial point has
 * opposite sign function-wise).</p>
 *
 * @param f function to solve.
 * @param min the lower bound for the interval.
 * @param max the upper bound for the interval.
 * @param initial the start value to use (must be set to min if no
 * initial point is known).
 * @return the value where the function is zero
 * @throws MaxIterationsExceededException the maximum iteration count
 * is exceeded
 * @throws FunctionEvaluationException if an error occurs evaluating
 *  the function
 * @throws IllegalArgumentException if initial is not between min and max
 * (even if it <em>is</em> a root)
 */
","public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial) throws MaxIterationsExceededException, FunctionEvaluationException {
    clearResult();
    verifySequence(min, initial, max);
        double yInitial = f.value(initial);
    if (Math.abs(yInitial) <= functionValueAccuracy) {
        setResult(initial, 0);
        return result;
    }
        double yMin = f.value(min);
    if (Math.abs(yMin) <= functionValueAccuracy) {
        setResult(yMin, 0);
        return result;
    }
        if (yInitial * yMin < 0) {
        return solve(f, min, yMin, initial, yInitial, min, yMin);
    }
        double yMax = f.value(max);
    if (Math.abs(yMax) <= functionValueAccuracy) {
        setResult(yMax, 0);
        return result;
    }
        if (yInitial * yMax < 0) {
        return solve(f, initial, yInitial, max, yMax, initial, yInitial);
    }
        return solve(f, min, yMin, max, yMax, initial, yInitial);
}",0.5454545454545454,-0.3301435406698567,0.4,-0.5,0.5833333333333334,1.146825396825397,-0.4339675828047919,0.6666666666666666,-0.02631578947368421,1.3053047722780264
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-258_7b38965d,1,"/**
 * Create an HTML Layout.
 * @param locationInfo If ""true"", location information will be included. The default is false.
 * @param title The title to include in the file header. If none is specified the default title will be used.
 * @param contentType The content type. Defaults to ""text/html"".
 * @param charsetName The character set to use. If not specified, the default will be used.
 * @param fontSize The font size of the text.
 * @param font The font to use for the text.
 * @return An HTML Layout.
 */
@PluginFactory
public static HTMLLayout createLayout(@PluginAttr(""locationInfo"") final String locationInfo, @PluginAttr(""title"") String title, @PluginAttr(""contentType"") String contentType, @PluginAttr(""charset"") final String charsetName, @PluginAttr(""fontSize"") String fontSize, @PluginAttr(""fontName"") String font) {
    final Charset charset = Charsets.getSupportedCharset(charsetName);
    if (font == null) {
        font = ""arial,sans-serif"";
    }
    final FontSize fs = FontSize.getFontSize(fontSize);
    fontSize = fs.getFontSize();
    final String headerSize = fs.larger().getFontSize();
    final boolean info = locationInfo == null ? false : Boolean.valueOf(locationInfo);
    if (title == null) {
        title = DEFAULT_TITLE;
    }
    if (contentType == null) {
        contentType = DEFAULT_CONTENT_TYPE;
    }
    return new HTMLLayout(info, title, contentType, charset, font, fontSize, headerSize);
}","/**
 * Create an HTML Layout.
 * @param locationInfo If ""true"", location information will be included. The default is false.
 * @param title The title to include in the file header. If none is specified the default title will be used.
 * @param contentType The content type. Defaults to ""text/html"".
 * @param charsetName The character set to use. If not specified, the default will be used.
 * @param fontSize The font size of the text.
 * @param font The font to use for the text.
 * @return An HTML Layout.
 */
","@PluginFactory
public static HTMLLayout createLayout(@PluginAttr(""locationInfo"") final String locationInfo, @PluginAttr(""title"") String title, @PluginAttr(""contentType"") String contentType, @PluginAttr(""charset"") final String charsetName, @PluginAttr(""fontSize"") String fontSize, @PluginAttr(""fontName"") String font) {
    final Charset charset = Charsets.getSupportedCharset(charsetName);
    if (font == null) {
        font = ""arial,sans-serif"";
    }
    final FontSize fs = FontSize.getFontSize(fontSize);
    fontSize = fs.getFontSize();
    final String headerSize = fs.larger().getFontSize();
    final boolean info = locationInfo == null ? false : Boolean.valueOf(locationInfo);
    if (title == null) {
        title = DEFAULT_TITLE;
    }
    if (contentType == null) {
        contentType = DEFAULT_CONTENT_TYPE;
    }
    return new HTMLLayout(info, title, contentType, charset, font, fontSize, headerSize);
}",0.18181818181818182,-0.32535885167464124,0.2,-0.5,0.25,0.11706349206349208,-0.2617336152219872,0.0,-0.02631578947368421,0.3139941102908548
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1199_813109d7,3,"public int compareTo(setTableProperty_result other) {
    if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
    }
    int lastComparison = 0;
    setTableProperty_result typedOther = (setTableProperty_result) other;
    lastComparison = Boolean.valueOf(isSetOuch1()).compareTo(typedOther.isSetOuch1());
    if (lastComparison != 0) {
        return lastComparison;
    }
    if (isSetOuch1()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.ouch1, typedOther.ouch1);
        if (lastComparison != 0) {
            return lastComparison;
        }
    }
    lastComparison = Boolean.valueOf(isSetOuch2()).compareTo(typedOther.isSetOuch2());
    if (lastComparison != 0) {
        return lastComparison;
    }
    if (isSetOuch2()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.ouch2, typedOther.ouch2);
        if (lastComparison != 0) {
            return lastComparison;
        }
    }
    return 0;
}",,"public int compareTo(setTableProperty_result other) {
    if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
    }
    int lastComparison = 0;
    setTableProperty_result typedOther = (setTableProperty_result) other;
    lastComparison = Boolean.valueOf(isSetOuch1()).compareTo(typedOther.isSetOuch1());
    if (lastComparison != 0) {
        return lastComparison;
    }
    if (isSetOuch1()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.ouch1, typedOther.ouch1);
        if (lastComparison != 0) {
            return lastComparison;
        }
    }
    lastComparison = Boolean.valueOf(isSetOuch2()).compareTo(typedOther.isSetOuch2());
    if (lastComparison != 0) {
        return lastComparison;
    }
    if (isSetOuch2()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.ouch2, typedOther.ouch2);
        if (lastComparison != 0) {
            return lastComparison;
        }
    }
    return 0;
}",0.6363636363636364,-0.04306220095693795,0.8,0.0,0.5833333333333334,0.2996031746031746,-0.4556730091613809,1.1666666666666667,-0.02631578947368421,0.3821533744806163
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-217_add180fb,1,"@Override
public void rename(String oldTableName, String newTableName) throws AccumuloSecurityException, TableNotFoundException, AccumuloException, TableExistsException {
    MockTable t = acu.tables.remove(oldTableName);
    acu.tables.put(newTableName, t);
}",,"@Override
public void rename(String oldTableName, String newTableName) throws AccumuloSecurityException, TableNotFoundException, AccumuloException, TableExistsException {
    MockTable t = acu.tables.remove(oldTableName);
    acu.tables.put(newTableName, t);
}",-0.4090909090909091,-0.49282296650717716,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.5701198026779419,-0.3333333333333333,-0.02631578947368421,-0.16279340490885932
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3082_29e5b734,3,"@Nonnull
@Override
public AccessControlPolicy[] getEffectivePolicies(@Nonnull Set<Principal> principals) throws RepositoryException {
    Util.checkValidPrincipals(principals, principalManager);
    Root r = getLatestRoot();
    Result aceResult = searchAces(principals, r);
    List<AccessControlPolicy> effective = new ArrayList<AccessControlPolicy>();
    for (ResultRow row : aceResult.getRows()) {
        String acePath = row.getPath();
        String aclName = Text.getName(Text.getRelativeParent(acePath, 1));
        Tree accessControlledTree = r.getTree(Text.getRelativeParent(acePath, 2));
        if (aclName.isEmpty() || !accessControlledTree.exists()) {
            log.debug(""Isolated access control entry -> ignore query result at "" + acePath);
            continue;
        }
        String path = (REP_REPO_POLICY.equals(aclName)) ? null : accessControlledTree.getPath();
        AccessControlPolicy policy = createACL(path, accessControlledTree, true);
        if (policy != null) {
            effective.add(policy);
        }
    }
    return effective.toArray(new AccessControlPolicy[effective.size()]);
}",,"@Nonnull
@Override
public AccessControlPolicy[] getEffectivePolicies(@Nonnull Set<Principal> principals) throws RepositoryException {
    Util.checkValidPrincipals(principals, principalManager);
    Root r = getLatestRoot();
    Result aceResult = searchAces(principals, r);
    List<AccessControlPolicy> effective = new ArrayList<AccessControlPolicy>();
    for (ResultRow row : aceResult.getRows()) {
        String acePath = row.getPath();
        String aclName = Text.getName(Text.getRelativeParent(acePath, 1));
        Tree accessControlledTree = r.getTree(Text.getRelativeParent(acePath, 2));
        if (aclName.isEmpty() || !accessControlledTree.exists()) {
            log.debug(""Isolated access control entry -> ignore query result at "" + acePath);
            continue;
        }
        String path = (REP_REPO_POLICY.equals(aclName)) ? null : accessControlledTree.getPath();
        AccessControlPolicy policy = createACL(path, accessControlledTree, true);
        if (policy != null) {
            effective.add(policy);
        }
    }
    return effective.toArray(new AccessControlPolicy[effective.size()]);
}",0.4090909090909091,0.3444976076555023,0.4,0.0,0.3333333333333333,0.27976190476190477,-0.41846370683579975,1.0,-0.02631578947368421,0.6650991511211769
wicket,remotes/origin/bugs-dot-jar_WICKET-5359_61122bab,3,"/**
 *  Convert to character, returning default value if text is inconvertible.
 *
 *  @param defaultValue
 *             the default value
 *  @return the converted text as a primitive char or the default value if text is not a single character
 */
public final char toChar(final char defaultValue) {
    if (text != null) {
        try {
            return toChar();
        } catch (StringValueConversionException x) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(String.format(""An error occurred while converting '%s' to a character: %s"", text, x.getMessage()), x);
            }
        }
    }
    return defaultValue;
}","/**
 *  Convert to character, returning default value if text is inconvertible.
 *
 *  @param defaultValue
 *             the default value
 *  @return the converted text as a primitive char or the default value if text is not a single character
 */
","public final char toChar(final char defaultValue) {
    if (text != null) {
        try {
            return toChar();
        } catch (StringValueConversionException x) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(String.format(""An error occurred while converting '%s' to a character: %s"", text, x.getMessage()), x);
            }
        }
    }
    return defaultValue;
}",-0.09090909090909091,0.8899521531100476,0.0,0.5,-0.08333333333333333,-0.3650793650793651,0.17096546863988715,-0.08333333333333333,1.0789473684210527,-0.16279340490885932
flink,remotes/origin/bugs-dot-jar_FLINK-1820_39d526e6,0,"@Override
public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, Integer reusable) {
    long val = 0;
    boolean neg = false;
    final int delimLimit = limit - delimiter.length + 1;
    if (bytes[startPos] == '-') {
        neg = true;
        startPos++;
        // check for empty field with only the sign
        if (startPos == limit || (startPos < delimLimit && delimiterNext(bytes, startPos, delimiter))) {
            setErrorState(ParseErrorState.NUMERIC_VALUE_ORPHAN_SIGN);
            return -1;
        }
    }
    for (int i = startPos; i < limit; i++) {
        if (i < delimLimit && delimiterNext(bytes, i, delimiter)) {
            this.result = (int) (neg ? -val : val);
            return i + delimiter.length;
        }
        if (bytes[i] < 48 || bytes[i] > 57) {
            setErrorState(ParseErrorState.NUMERIC_VALUE_ILLEGAL_CHARACTER);
            return -1;
        }
        val *= 10;
        val += bytes[i] - 48;
        if (val > OVERFLOW_BOUND && (!neg || val > UNDERFLOW_BOUND)) {
            setErrorState(ParseErrorState.NUMERIC_VALUE_OVERFLOW_UNDERFLOW);
            return -1;
        }
    }
    this.result = (int) (neg ? -val : val);
    return limit;
}",,"@Override
public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, Integer reusable) {
    long val = 0;
    boolean neg = false;
    final int delimLimit = limit - delimiter.length + 1;
    if (bytes[startPos] == '-') {
        neg = true;
        startPos++;
                if (startPos == limit || (startPos < delimLimit && delimiterNext(bytes, startPos, delimiter))) {
            setErrorState(ParseErrorState.NUMERIC_VALUE_ORPHAN_SIGN);
            return -1;
        }
    }
    for (int i = startPos; i < limit; i++) {
        if (i < delimLimit && delimiterNext(bytes, i, delimiter)) {
            this.result = (int) (neg ? -val : val);
            return i + delimiter.length;
        }
        if (bytes[i] < 48 || bytes[i] > 57) {
            setErrorState(ParseErrorState.NUMERIC_VALUE_ILLEGAL_CHARACTER);
            return -1;
        }
        val *= 10;
        val += bytes[i] - 48;
        if (val > OVERFLOW_BOUND && (!neg || val > UNDERFLOW_BOUND)) {
            setErrorState(ParseErrorState.NUMERIC_VALUE_OVERFLOW_UNDERFLOW);
            return -1;
        }
    }
    this.result = (int) (neg ? -val : val);
    return limit;
}",0.8181818181818182,0.3444976076555023,1.0,0.0,1.5833333333333333,2.8611111111111116,-0.6129668780831571,-0.08333333333333333,-0.02631578947368421,4.717929035344017
flink,remotes/origin/bugs-dot-jar_FLINK-2734_8b40bb7a,0,"@Override
public Tuple getKey(IN value) throws Exception {
    key = (Tuple) tupleClasses[keyLength - 1].newInstance();
    comparator.extractKeys(value, keyArray, 0);
    for (int i = 0; i < keyLength; i++) {
        key.setField(keyArray[i], i);
    }
    return key;
}",,"@Override
public Tuple getKey(IN value) throws Exception {
    key = (Tuple) tupleClasses[keyLength - 1].newInstance();
    comparator.extractKeys(value, keyArray, 0);
    for (int i = 0; i < keyLength; i++) {
        key.setField(keyArray[i], i);
    }
    return key;
}",-0.22727272727272727,-0.22966507177033516,-0.4,-0.5,-0.16666666666666666,0.27380952380952384,0.2250880902043692,-0.25,0.05263157894736841,0.06244935829832355
flink,remotes/origin/bugs-dot-jar_FLINK-3052_8dc70f2e,1,"@Override
protected void instantiateCandidate(OperatorDescriptorSingle dps, Channel in, List<Set<? extends NamedChannel>> broadcastPlanChannels, List<PlanNode> target, CostEstimator estimator, RequestedGlobalProperties globPropsReq, RequestedLocalProperties locPropsReq) {
    // NOTES ON THE ENUMERATION OF THE STEP FUNCTION PLANS:
    // Whenever we instantiate the iteration, we enumerate new candidates for the step function.
    // That way, we make sure we have an appropriate plan for each candidate for the initial partial solution,
    // we have a fitting candidate for the step function (often, work is pushed out of the step function).
    // Among the candidates of the step function, we keep only those that meet the requested properties of the
    // current candidate initial partial solution. That makes sure these properties exist at the beginning of
    // the successive iteration.
    // 1) Because we enumerate multiple times, we may need to clean the cached plans
    // before starting another enumeration
    this.nextPartialSolution.accept(PlanCacheCleaner.INSTANCE);
    if (this.terminationCriterion != null) {
        this.terminationCriterion.accept(PlanCacheCleaner.INSTANCE);
    }
    // 2) Give the partial solution the properties of the current candidate for the initial partial solution
    this.partialSolution.setCandidateProperties(in.getGlobalProperties(), in.getLocalProperties(), in);
    final BulkPartialSolutionPlanNode pspn = this.partialSolution.getCurrentPartialSolutionPlanNode();
    // 3) Get the alternative plans
    List<PlanNode> candidates = this.nextPartialSolution.getAlternativePlans(estimator);
    // 4) Make sure that the beginning of the step function does not assume properties that
    // are not also produced by the end of the step function.
    {
        List<PlanNode> newCandidates = new ArrayList<PlanNode>();
        for (Iterator<PlanNode> planDeleter = candidates.iterator(); planDeleter.hasNext(); ) {
            PlanNode candidate = planDeleter.next();
            GlobalProperties atEndGlobal = candidate.getGlobalProperties();
            LocalProperties atEndLocal = candidate.getLocalProperties();
            FeedbackPropertiesMeetRequirementsReport report = candidate.checkPartialSolutionPropertiesMet(pspn, atEndGlobal, atEndLocal);
            if (report == FeedbackPropertiesMeetRequirementsReport.NO_PARTIAL_SOLUTION) {
                // depends only through broadcast variable on the partial solution
                ;
            } else if (report == FeedbackPropertiesMeetRequirementsReport.NOT_MET) {
                // attach a no-op node through which we create the properties of the original input
                Channel toNoOp = new Channel(candidate);
                globPropsReq.parameterizeChannel(toNoOp, false, rootConnection.getDataExchangeMode(), false);
                locPropsReq.parameterizeChannel(toNoOp);
                UnaryOperatorNode rebuildPropertiesNode = new UnaryOperatorNode(""Rebuild Partial Solution Properties"", FieldList.EMPTY_LIST);
                rebuildPropertiesNode.setParallelism(candidate.getParallelism());
                SingleInputPlanNode rebuildPropertiesPlanNode = new SingleInputPlanNode(rebuildPropertiesNode, ""Rebuild Partial Solution Properties"", toNoOp, DriverStrategy.UNARY_NO_OP);
                rebuildPropertiesPlanNode.initProperties(toNoOp.getGlobalProperties(), toNoOp.getLocalProperties());
                estimator.costOperator(rebuildPropertiesPlanNode);
                GlobalProperties atEndGlobalModified = rebuildPropertiesPlanNode.getGlobalProperties();
                LocalProperties atEndLocalModified = rebuildPropertiesPlanNode.getLocalProperties();
                if (!(atEndGlobalModified.equals(atEndGlobal) && atEndLocalModified.equals(atEndLocal))) {
                    FeedbackPropertiesMeetRequirementsReport report2 = candidate.checkPartialSolutionPropertiesMet(pspn, atEndGlobalModified, atEndLocalModified);
                    if (report2 != FeedbackPropertiesMeetRequirementsReport.NOT_MET) {
                        newCandidates.add(rebuildPropertiesPlanNode);
                    }
                }
                planDeleter.remove();
            }
        }
    }
    if (candidates.isEmpty()) {
        return;
    }
    // 5) Create a candidate for the Iteration Node for every remaining plan of the step function.
    if (terminationCriterion == null) {
        for (PlanNode candidate : candidates) {
            BulkIterationPlanNode node = new BulkIterationPlanNode(this, this.getOperator().getName(), in, pspn, candidate);
            GlobalProperties gProps = candidate.getGlobalProperties().clone();
            LocalProperties lProps = candidate.getLocalProperties().clone();
            node.initProperties(gProps, lProps);
            target.add(node);
        }
    } else if (candidates.size() > 0) {
        List<PlanNode> terminationCriterionCandidates = this.terminationCriterion.getAlternativePlans(estimator);
        SingleRootJoiner singleRoot = (SingleRootJoiner) this.singleRoot;
        for (PlanNode candidate : candidates) {
            for (PlanNode terminationCandidate : terminationCriterionCandidates) {
                if (singleRoot.areBranchCompatible(candidate, terminationCandidate)) {
                    BulkIterationPlanNode node = new BulkIterationPlanNode(this, ""BulkIteration ("" + this.getOperator().getName() + "")"", in, pspn, candidate, terminationCandidate);
                    GlobalProperties gProps = candidate.getGlobalProperties().clone();
                    LocalProperties lProps = candidate.getLocalProperties().clone();
                    node.initProperties(gProps, lProps);
                    target.add(node);
                }
            }
        }
    }
}",,"@Override
protected void instantiateCandidate(OperatorDescriptorSingle dps, Channel in, List<Set<? extends NamedChannel>> broadcastPlanChannels, List<PlanNode> target, CostEstimator estimator, RequestedGlobalProperties globPropsReq, RequestedLocalProperties locPropsReq) {
                                        this.nextPartialSolution.accept(PlanCacheCleaner.INSTANCE);
    if (this.terminationCriterion != null) {
        this.terminationCriterion.accept(PlanCacheCleaner.INSTANCE);
    }
        this.partialSolution.setCandidateProperties(in.getGlobalProperties(), in.getLocalProperties(), in);
    final BulkPartialSolutionPlanNode pspn = this.partialSolution.getCurrentPartialSolutionPlanNode();
        List<PlanNode> candidates = this.nextPartialSolution.getAlternativePlans(estimator);
            {
        List<PlanNode> newCandidates = new ArrayList<PlanNode>();
        for (Iterator<PlanNode> planDeleter = candidates.iterator(); planDeleter.hasNext(); ) {
            PlanNode candidate = planDeleter.next();
            GlobalProperties atEndGlobal = candidate.getGlobalProperties();
            LocalProperties atEndLocal = candidate.getLocalProperties();
            FeedbackPropertiesMeetRequirementsReport report = candidate.checkPartialSolutionPropertiesMet(pspn, atEndGlobal, atEndLocal);
            if (report == FeedbackPropertiesMeetRequirementsReport.NO_PARTIAL_SOLUTION) {
                                ;
            } else if (report == FeedbackPropertiesMeetRequirementsReport.NOT_MET) {
                                Channel toNoOp = new Channel(candidate);
                globPropsReq.parameterizeChannel(toNoOp, false, rootConnection.getDataExchangeMode(), false);
                locPropsReq.parameterizeChannel(toNoOp);
                UnaryOperatorNode rebuildPropertiesNode = new UnaryOperatorNode(""Rebuild Partial Solution Properties"", FieldList.EMPTY_LIST);
                rebuildPropertiesNode.setParallelism(candidate.getParallelism());
                SingleInputPlanNode rebuildPropertiesPlanNode = new SingleInputPlanNode(rebuildPropertiesNode, ""Rebuild Partial Solution Properties"", toNoOp, DriverStrategy.UNARY_NO_OP);
                rebuildPropertiesPlanNode.initProperties(toNoOp.getGlobalProperties(), toNoOp.getLocalProperties());
                estimator.costOperator(rebuildPropertiesPlanNode);
                GlobalProperties atEndGlobalModified = rebuildPropertiesPlanNode.getGlobalProperties();
                LocalProperties atEndLocalModified = rebuildPropertiesPlanNode.getLocalProperties();
                if (!(atEndGlobalModified.equals(atEndGlobal) && atEndLocalModified.equals(atEndLocal))) {
                    FeedbackPropertiesMeetRequirementsReport report2 = candidate.checkPartialSolutionPropertiesMet(pspn, atEndGlobalModified, atEndLocalModified);
                    if (report2 != FeedbackPropertiesMeetRequirementsReport.NOT_MET) {
                        newCandidates.add(rebuildPropertiesPlanNode);
                    }
                }
                planDeleter.remove();
            }
        }
    }
    if (candidates.isEmpty()) {
        return;
    }
        if (terminationCriterion == null) {
        for (PlanNode candidate : candidates) {
            BulkIterationPlanNode node = new BulkIterationPlanNode(this, this.getOperator().getName(), in, pspn, candidate);
            GlobalProperties gProps = candidate.getGlobalProperties().clone();
            LocalProperties lProps = candidate.getLocalProperties().clone();
            node.initProperties(gProps, lProps);
            target.add(node);
        }
    } else if (candidates.size() > 0) {
        List<PlanNode> terminationCriterionCandidates = this.terminationCriterion.getAlternativePlans(estimator);
        SingleRootJoiner singleRoot = (SingleRootJoiner) this.singleRoot;
        for (PlanNode candidate : candidates) {
            for (PlanNode terminationCandidate : terminationCriterionCandidates) {
                if (singleRoot.areBranchCompatible(candidate, terminationCandidate)) {
                    BulkIterationPlanNode node = new BulkIterationPlanNode(this, ""BulkIteration ("" + this.getOperator().getName() + "")"", in, pspn, candidate, terminationCandidate);
                    GlobalProperties gProps = candidate.getGlobalProperties().clone();
                    LocalProperties lProps = candidate.getLocalProperties().clone();
                    node.initProperties(gProps, lProps);
                    target.add(node);
                }
            }
        }
    }
}",2.3636363636363638,1.4066985645933012,2.0,1.5,1.6666666666666667,1.1686507936507937,-1.1231853417899926,3.5833333333333335,-0.02631578947368421,6.1674567636566895
flink,remotes/origin/bugs-dot-jar_FLINK-3740_f2f5bd5b,1,"// ------------------------------------------------------------------------
// Checkpointing
// ------------------------------------------------------------------------
@Override
public StreamTaskState snapshotOperatorState(long checkpointId, long timestamp) throws Exception {
    StreamTaskState taskState = super.snapshotOperatorState(checkpointId, timestamp);
    AbstractStateBackend.CheckpointStateOutputView out = getStateBackend().createCheckpointStateOutputView(checkpointId, timestamp);
    out.writeInt(watermarkTimersQueue.size());
    for (Timer<K, W> timer : watermarkTimersQueue) {
        keySerializer.serialize(timer.key, out);
        windowSerializer.serialize(timer.window, out);
        out.writeLong(timer.timestamp);
    }
    out.writeInt(processingTimeTimers.size());
    for (Timer<K, W> timer : processingTimeTimersQueue) {
        keySerializer.serialize(timer.key, out);
        windowSerializer.serialize(timer.window, out);
        out.writeLong(timer.timestamp);
    }
    taskState.setOperatorState(out.closeAndGetHandle());
    return taskState;
}",,"@Override
public StreamTaskState snapshotOperatorState(long checkpointId, long timestamp) throws Exception {
    StreamTaskState taskState = super.snapshotOperatorState(checkpointId, timestamp);
    AbstractStateBackend.CheckpointStateOutputView out = getStateBackend().createCheckpointStateOutputView(checkpointId, timestamp);
    out.writeInt(watermarkTimersQueue.size());
    for (Timer<K, W> timer : watermarkTimersQueue) {
        keySerializer.serialize(timer.key, out);
        windowSerializer.serialize(timer.window, out);
        out.writeLong(timer.timestamp);
    }
    out.writeInt(processingTimeTimers.size());
    for (Timer<K, W> timer : processingTimeTimersQueue) {
        keySerializer.serialize(timer.key, out);
        windowSerializer.serialize(timer.window, out);
        out.writeLong(timer.timestamp);
    }
    taskState.setOperatorState(out.closeAndGetHandle());
    return taskState;
}",0.22727272727272727,-0.14832535885167467,-0.2,-0.5,-0.4166666666666667,-0.3650793650793651,-0.2479210711768851,0.75,-0.02631578947368421,-0.16279340490885932
flink,remotes/origin/bugs-dot-jar_FLINK-1922_ccd574a4,1,"@Override
public InputSplit getNextInputSplit() {
    try {
        final Future<Object> response = Patterns.ask(jobManager, new JobManagerMessages.RequestNextInputSplit(jobId, vertexId, executionID), timeout);
        final Object result = Await.result(response, timeout.duration());
        if (result == null) {
            return null;
        }
        if (!(result instanceof JobManagerMessages.NextInputSplit)) {
            throw new RuntimeException(""RequestNextInputSplit requires a response of type "" + ""NextInputSplit. Instead response is of type "" + result.getClass() + ""."");
        } else {
            final JobManagerMessages.NextInputSplit nextInputSplit = (JobManagerMessages.NextInputSplit) result;
            byte[] serializedData = nextInputSplit.splitData();
            Object deserialized = InstantiationUtil.deserializeObject(serializedData, usercodeClassLoader);
            return (InputSplit) deserialized;
        }
    } catch (Exception e) {
        throw new RuntimeException(""Requesting the next InputSplit failed."", e);
    }
}",,"@Override
public InputSplit getNextInputSplit() {
    try {
        final Future<Object> response = Patterns.ask(jobManager, new JobManagerMessages.RequestNextInputSplit(jobId, vertexId, executionID), timeout);
        final Object result = Await.result(response, timeout.duration());
        if (result == null) {
            return null;
        }
        if (!(result instanceof JobManagerMessages.NextInputSplit)) {
            throw new RuntimeException(""RequestNextInputSplit requires a response of type "" + ""NextInputSplit. Instead response is of type "" + result.getClass() + ""."");
        } else {
            final JobManagerMessages.NextInputSplit nextInputSplit = (JobManagerMessages.NextInputSplit) result;
            byte[] serializedData = nextInputSplit.splitData();
            Object deserialized = InstantiationUtil.deserializeObject(serializedData, usercodeClassLoader);
            return (InputSplit) deserialized;
        }
    } catch (Exception e) {
        throw new RuntimeException(""Requesting the next InputSplit failed."", e);
    }
}",0.2727272727272727,0.5071770334928228,0.4,0.0,-0.16666666666666666,0.26388888888888884,-0.2885130373502466,0.0,-0.02631578947368421,0.35000547477855953
wicket,remotes/origin/bugs-dot-jar_WICKET-4105_64656c98,1,"/**
 *  Create a new response object which is used to store the markup generated by the child
 *  objects.
 *
 *  @param originalResponse
 *
 *  @return Response object. Must not be null
 */
protected BufferedWebResponse newResponse(final WebResponse originalResponse) {
    return new BufferedWebResponse(originalResponse);
}","/**
 *  Create a new response object which is used to store the markup generated by the child
 *  objects.
 *
 *  @param originalResponse
 *
 *  @return Response object. Must not be null
 */
","protected BufferedWebResponse newResponse(final WebResponse originalResponse) {
    return new BufferedWebResponse(originalResponse);
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,1.0606060606060603,-0.5,2.6052631578947367,-0.16279340490885932
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-412_5594b2e0,1,"private List<List<String>> groupFiles(List<String> files, int groups) {
    List<List<String>> result = new ArrayList<List<String>>();
    Iterator<String> iter = files.iterator();
    for (int i = 0; i < groups && iter.hasNext(); i++) {
        List<String> group = new ArrayList<String>();
        for (int j = 0; j < Math.ceil(files.size() / (double) groups) && iter.hasNext(); j++) {
            group.add(iter.next());
        }
        result.add(group);
    }
    return result;
}",,"private List<List<String>> groupFiles(List<String> files, int groups) {
    List<List<String>> result = new ArrayList<List<String>>();
    Iterator<String> iter = files.iterator();
    for (int i = 0; i < groups && iter.hasNext(); i++) {
        List<String> group = new ArrayList<String>();
        for (int j = 0; j < Math.ceil(files.size() / (double) groups) && iter.hasNext(); j++) {
            group.add(iter.next());
        }
        result.add(group);
    }
    return result;
}",-0.09090909090909091,0.1961722488038276,-0.2,0.0,0.4166666666666667,0.6170634920634921,-0.013107822410148084,0.16666666666666666,-0.02631578947368421,0.5240642450856657
Closure,29,1,"/**
 * Counts the number of direct (full) references to an object.
 * Specifically we check for references of the following type:
 * <pre>
 *   x;
 *   x.fn();
 * </pre>
 */
private boolean isInlinableObject(List<Reference> refs) {
    boolean ret = false;
    for (Reference ref : refs) {
        Node name = ref.getNode();
        Node parent = ref.getParent();
        Node gramps = ref.getGrandparent();
        // 
        if (parent.isGetProp()) {
            Preconditions.checkState(parent.getFirstChild() == name);
            // A call target maybe using the object as a 'this' value.
            if (gramps.isCall() && gramps.getFirstChild() == parent) {
                return false;
            }
            // isn't a perfect algorithm, but it should catch most cases.
            continue;
        }
        // Only rewrite VAR declarations or simple assignment statements
        if (!isVarOrAssignExprLhs(name)) {
            return false;
        }
        Node val = ref.getAssignedValue();
        if (val == null) {
            // A var with no assignment.
            continue;
        }
        // We're looking for object literal assignments only.
        if (!val.isObjectLit()) {
            return false;
        }
        // Also, ES5 getters/setters aren't handled by this pass.
        for (Node child = val.getFirstChild(); child != null; child = child.getNext()) {
            if (child.isGetterDef() || child.isSetterDef()) {
                // ES5 get/set not supported.
                return false;
            }
            Node childVal = child.getFirstChild();
            // will happen.
            for (Reference t : refs) {
                Node refNode = t.getParent();
                while (!NodeUtil.isStatementBlock(refNode)) {
                    if (refNode == childVal) {
                        // There's a self-referential assignment
                        return false;
                    }
                    refNode = refNode.getParent();
                }
            }
        }
        // We have found an acceptable object literal assignment. As
        // long as there are no other assignments that mess things up,
        // we can inline.
        ret = true;
    }
    return ret;
}","/**
 * Counts the number of direct (full) references to an object.
 * Specifically we check for references of the following type:
 * <pre>
 *   x;
 *   x.fn();
 * </pre>
 */
","private boolean isInlinableObject(List<Reference> refs) {
    boolean ret = false;
    for (Reference ref : refs) {
        Node name = ref.getNode();
        Node parent = ref.getParent();
        Node gramps = ref.getGrandparent();
                if (parent.isGetProp()) {
            Preconditions.checkState(parent.getFirstChild() == name);
                        if (gramps.isCall() && gramps.getFirstChild() == parent) {
                return false;
            }
                        continue;
        }
                if (!isVarOrAssignExprLhs(name)) {
            return false;
        }
        Node val = ref.getAssignedValue();
        if (val == null) {
                        continue;
        }
                if (!val.isObjectLit()) {
            return false;
        }
                for (Node child = val.getFirstChild(); child != null; child = child.getNext()) {
            if (child.isGetterDef() || child.isSetterDef()) {
                                return false;
            }
            Node childVal = child.getFirstChild();
                        for (Reference t : refs) {
                Node refNode = t.getParent();
                while (!NodeUtil.isStatementBlock(refNode)) {
                    if (refNode == childVal) {
                                                return false;
                    }
                    refNode = refNode.getParent();
                }
            }
        }
                                ret = true;
    }
    return ret;
}",1.2727272727272727,1.0334928229665072,2.0,1.5,1.6666666666666667,1.0634920634920635,-0.7482734319943621,1.0833333333333333,-0.02631578947368421,1.7045371506947202
commons-math,remotes/origin/bugs-dot-jar_MATH-738_f64b6a90,1,"/**
 * Returns the natural logarithm of the beta function B(a, b).
 *
 * The implementation of this method is based on:
 * <ul>
 * <li><a href=""http://mathworld.wolfram.com/BetaFunction.html"">
 * Beta Function</a>, equation (1).</li>
 * </ul>
 *
 * @param a Parameter {@code a}.
 * @param b Parameter {@code b}.
 * @param epsilon When the absolute value of the nth item in the
 * series is less than epsilon the approximation ceases to calculate
 * further elements in the series.
 * @param maxIterations Maximum number of ""iterations"" to complete.
 * @return log(B(a, b)).
 */
public static double logBeta(double a, double b, double epsilon, int maxIterations) {
    double ret;
    if (Double.isNaN(a) || Double.isNaN(b) || a <= 0.0 || b <= 0.0) {
        ret = Double.NaN;
    } else {
        ret = Gamma.logGamma(a) + Gamma.logGamma(b) - Gamma.logGamma(a + b);
    }
    return ret;
}","/**
 * Returns the natural logarithm of the beta function B(a, b).
 *
 * The implementation of this method is based on:
 * <ul>
 * <li><a href=""http://mathworld.wolfram.com/BetaFunction.html"">
 * Beta Function</a>, equation (1).</li>
 * </ul>
 *
 * @param a Parameter {@code a}.
 * @param b Parameter {@code b}.
 * @param epsilon When the absolute value of the nth item in the
 * series is less than epsilon the approximation ceases to calculate
 * further elements in the series.
 * @param maxIterations Maximum number of ""iterations"" to complete.
 * @return log(B(a, b)).
 */
","public static double logBeta(double a, double b, double epsilon, int maxIterations) {
    double ret;
    if (Double.isNaN(a) || Double.isNaN(b) || a <= 0.0 || b <= 0.0) {
        ret = Double.NaN;
    } else {
        ret = Gamma.logGamma(a) + Gamma.logGamma(b) - Gamma.logGamma(a + b);
    }
    return ret;
}",-0.22727272727272727,-0.15311004784689008,-0.4,-0.5,0.25,0.6111111111111112,0.2076109936575051,-0.08333333333333333,0.21052631578947367,0.22524967871694235
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-217_46f62443,1,"@Override
public void removeIterator(String tableName, String name, EnumSet<IteratorScope> scopes) throws AccumuloSecurityException, AccumuloException, TableNotFoundException {
    Map<String, String> copy = new TreeMap<String, String>();
    for (Entry<String, String> property : this.getProperties(tableName)) {
        copy.put(property.getKey(), property.getValue());
    }
    for (IteratorScope scope : scopes) {
        String root = String.format(""%s%s.%s"", Property.TABLE_ITERATOR_PREFIX, scope.name().toLowerCase(), name);
        for (Entry<String, String> property : copy.entrySet()) {
            if (property.getKey().equals(root) || property.getKey().startsWith(root + "".opt.""))
                this.removeProperty(tableName, property.getKey());
        }
    }
}",,"@Override
public void removeIterator(String tableName, String name, EnumSet<IteratorScope> scopes) throws AccumuloSecurityException, AccumuloException, TableNotFoundException {
    Map<String, String> copy = new TreeMap<String, String>();
    for (Entry<String, String> property : this.getProperties(tableName)) {
        copy.put(property.getKey(), property.getValue());
    }
    for (IteratorScope scope : scopes) {
        String root = String.format(""%s%s.%s"", Property.TABLE_ITERATOR_PREFIX, scope.name().toLowerCase(), name);
        for (Entry<String, String> property : copy.entrySet()) {
            if (property.getKey().equals(root) || property.getKey().startsWith(root + "".opt.""))
                this.removeProperty(tableName, property.getKey());
        }
    }
}",0.0,0.7033492822966506,0.2,0.0,0.0,0.02579365079365077,-0.1213530655391118,0.6666666666666666,-0.02631578947368421,0.16114751358609516
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-2899_31aea2ad,0,"// given a wal path, transform it to a recovery path
public static Path getRecoveryPath(VolumeManager fs, Path walPath) throws IOException {
    if (walPath.depth() >= 3 && walPath.toUri().getScheme() != null) {
        // its a fully qualified path
        String uuid = walPath.getName();
        // drop uuid
        walPath = walPath.getParent();
        // drop server
        walPath = walPath.getParent();
        if (!walPath.getName().equals(FileType.WAL.getDirectory()))
            throw new IllegalArgumentException(""Bad path "" + walPath);
        // drop wal
        walPath = walPath.getParent();
        walPath = new Path(walPath, FileType.RECOVERY.getDirectory());
        walPath = new Path(walPath, uuid);
        return walPath;
    }
    throw new IllegalArgumentException(""Bad path "" + walPath);
}",,"public static Path getRecoveryPath(VolumeManager fs, Path walPath) throws IOException {
    if (walPath.depth() >= 3 && walPath.toUri().getScheme() != null) {
                String uuid = walPath.getName();
                walPath = walPath.getParent();
                walPath = walPath.getParent();
        if (!walPath.getName().equals(FileType.WAL.getDirectory()))
            throw new IllegalArgumentException(""Bad path "" + walPath);
                walPath = walPath.getParent();
        walPath = new Path(walPath, FileType.RECOVERY.getDirectory());
        walPath = new Path(walPath, uuid);
        return walPath;
    }
    throw new IllegalArgumentException(""Bad path "" + walPath);
}",0.0,0.13875598086124383,0.2,-0.5,0.16666666666666666,0.9543650793650794,-0.09908386187455955,0.4166666666666667,-0.02631578947368421,0.7758349037303411
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-94_d8af1c93,1,"/**
 * Resolves the specified variable. This implementation will try to extract
 * a variable prefix from the given variable name (the first colon (':') is
 * used as prefix separator). It then passes the name of the variable with
 * the prefix stripped to the lookup object registered for this prefix. If
 * no prefix can be found or if the associated lookup object cannot resolve
 * this variable, the default lookup object will be used.
 *
 * @param event The current LogEvent or null.
 * @param var the name of the variable whose value is to be looked up
 * @return the value of this variable or <b>null</b> if it cannot be
 * resolved
 */
public String lookup(LogEvent event, String var) {
    if (var == null) {
        return null;
    }
    int prefixPos = var.indexOf(PREFIX_SEPARATOR);
    if (prefixPos >= 0) {
        String prefix = var.substring(0, prefixPos);
        String name = var.substring(prefixPos + 1);
        StrLookup lookup = lookups.get(prefix);
        String value = null;
        if (lookup != null) {
            value = event == null ? lookup.lookup(name) : lookup.lookup(event, name);
        }
        if (value != null) {
            return value;
        }
        var = var.substring(prefixPos);
    }
    if (defaultLookup != null) {
        return event == null ? defaultLookup.lookup(var) : defaultLookup.lookup(event, var);
    }
    return null;
}","/**
 * Resolves the specified variable. This implementation will try to extract
 * a variable prefix from the given variable name (the first colon (':') is
 * used as prefix separator). It then passes the name of the variable with
 * the prefix stripped to the lookup object registered for this prefix. If
 * no prefix can be found or if the associated lookup object cannot resolve
 * this variable, the default lookup object will be used.
 *
 * @param event The current LogEvent or null.
 * @param var the name of the variable whose value is to be looked up
 * @return the value of this variable or <b>null</b> if it cannot be
 * resolved
 */
","public String lookup(LogEvent event, String var) {
    if (var == null) {
        return null;
    }
    int prefixPos = var.indexOf(PREFIX_SEPARATOR);
    if (prefixPos >= 0) {
        String prefix = var.substring(0, prefixPos);
        String name = var.substring(prefixPos + 1);
        StrLookup lookup = lookups.get(prefix);
        String value = null;
        if (lookup != null) {
            value = event == null ? lookup.lookup(name) : lookup.lookup(event, name);
        }
        if (value != null) {
            return value;
        }
        var = var.substring(prefixPos);
    }
    if (defaultLookup != null) {
        return event == null ? defaultLookup.lookup(var) : defaultLookup.lookup(event, var);
    }
    return null;
}",0.4090909090909091,0.04306220095693773,0.8,0.0,0.6666666666666666,0.9642857142857143,-0.3770260747004932,0.25,-0.02631578947368421,1.0134564294070525
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-209_397f86f6,1,"private boolean matches(Matcher matcher, byte[] data, int offset, int len) {
    if (matcher != null) {
        babcs.set(data, offset, len);
        matcher.reset(babcs);
        return matcher.matches();
    }
    return !orFields;
}",,"private boolean matches(Matcher matcher, byte[] data, int offset, int len) {
    if (matcher != null) {
        babcs.set(data, offset, len);
        matcher.reset(babcs);
        return matcher.matches();
    }
    return !orFields;
}",-0.2727272727272727,0.06220095693779899,-0.4,-0.5,-0.25,-0.03373015873015876,0.3660324171952078,-0.25,0.0,-0.0984330607469903
wicket,remotes/origin/bugs-dot-jar_WICKET-4251_53bcb78d,1,"public static void set() {
    Session session = Session.get();
    session.bind();
    InterceptData data = new InterceptData();
    Request request = RequestCycle.get().getRequest();
    data.originalUrl = request.getOriginalUrl();
    data.postParameters = new HashMap<String, List<StringValue>>();
    for (String s : request.getPostParameters().getParameterNames()) {
        data.postParameters.put(s, new ArrayList<StringValue>(request.getPostParameters().getParameterValues(s)));
    }
    data.continueOk = false;
    session.setMetaData(key, data);
}",,"public static void set() {
    Session session = Session.get();
    session.bind();
    InterceptData data = new InterceptData();
    Request request = RequestCycle.get().getRequest();
    data.originalUrl = request.getOriginalUrl();
    data.postParameters = new HashMap<String, List<StringValue>>();
    for (String s : request.getPostParameters().getParameterNames()) {
        data.postParameters.put(s, new ArrayList<StringValue>(request.getPostParameters().getParameterValues(s)));
    }
    data.continueOk = false;
    session.setMetaData(key, data);
}",-0.045454545454545456,-0.5215311004784691,-0.4,-0.5,-0.4166666666666667,-0.3650793650793651,-0.024665257223396752,0.4166666666666667,-0.02631578947368421,-0.16279340490885932
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1044_9396979b,0,"public String getViolationDescription(short violationCode) {
    switch(violationCode) {
        case 1:
            return ""data file size must be a non-negative integer"";
        case 2:
            return ""Invalid column name given."";
        case 3:
            return ""Prev end row is greater than or equal to end row."";
        case 4:
            return ""Invalid metadata row format"";
        case 5:
            return ""Row can not be less than "" + Constants.METADATA_TABLE_ID;
        case 6:
            return ""Empty values are not allowed for any "" + Constants.METADATA_TABLE_NAME + "" column"";
        case 7:
            return ""Lock not held in zookeeper by writer"";
    }
    return null;
}",,"public String getViolationDescription(short violationCode) {
    switch(violationCode) {
        case 1:
            return ""data file size must be a non-negative integer"";
        case 2:
            return ""Invalid column name given."";
        case 3:
            return ""Prev end row is greater than or equal to end row."";
        case 4:
            return ""Invalid metadata row format"";
        case 5:
            return ""Row can not be less than "" + Constants.METADATA_TABLE_ID;
        case 6:
            return ""Empty values are not allowed for any "" + Constants.METADATA_TABLE_NAME + "" column"";
        case 7:
            return ""Lock not held in zookeeper by writer"";
    }
    return null;
}",0.22727272727272727,0.43062200956937796,0.8,0.0,0.25,-0.3650793650793651,-0.12529950669485532,-0.5,0.0,-0.16279340490885932
wicket,remotes/origin/bugs-dot-jar_WICKET-4777_eccb3b11,3,"/**
 *  Write a reference to a javascript file to the response object
 *
 *  @param response
 *             The HTTP response
 *  @param url
 *             The javascript file URL
 *  @param id
 *             Unique identifier of element
 *  @param defer
 *             specifies that the execution of a script should be deferred (delayed) until after
 *             the page has been loaded.
 *  @param charset
 *             a non null value specifies the charset attribute of the script tag
 */
public static void writeJavaScriptUrl(final Response response, final CharSequence url, final String id, boolean defer, String charset) {
    response.write(""<script type=\""text/javascript\"" "");
    if (id != null) {
        response.write(""id=\"""" + Strings.escapeMarkup(id) + ""\"" "");
    }
    if (defer) {
        response.write(""defer=\""defer\"" "");
    }
    if (charset != null) {
        response.write(""charset=\"""" + Strings.escapeMarkup(charset) + ""\"" "");
    }
    response.write(""src=\"""");
    response.write(Strings.escapeMarkup(url));
    response.write(""\""></script>"");
    response.write(""\n"");
}","/**
 *  Write a reference to a javascript file to the response object
 *
 *  @param response
 *             The HTTP response
 *  @param url
 *             The javascript file URL
 *  @param id
 *             Unique identifier of element
 *  @param defer
 *             specifies that the execution of a script should be deferred (delayed) until after
 *             the page has been loaded.
 *  @param charset
 *             a non null value specifies the charset attribute of the script tag
 */
","public static void writeJavaScriptUrl(final Response response, final CharSequence url, final String id, boolean defer, String charset) {
    response.write(""<script type=\""text/javascript\"" "");
    if (id != null) {
        response.write(""id=\"""" + Strings.escapeMarkup(id) + ""\"" "");
    }
    if (defer) {
        response.write(""defer=\""defer\"" "");
    }
    if (charset != null) {
        response.write(""charset=\"""" + Strings.escapeMarkup(charset) + ""\"" "");
    }
    response.write(""src=\"""");
    response.write(Strings.escapeMarkup(url));
    response.write(""\""></script>"");
    response.write(""\n"");
}",0.09090909090909091,-0.368421052631579,0.0,-0.5,0.08333333333333333,0.0853174603174603,-0.1224806201550387,0.4166666666666667,-0.02631578947368421,0.09663041786967722
flink,remotes/origin/bugs-dot-jar_FLINK-2437_a41bc8cc,3,"/**
 *  Checks if the given field is a valid pojo field:
 *  - it is public
 *  OR
 *   - there are getter and setter methods for the field.
 *
 *  @param f field to check
 *  @param clazz class of field
 *  @param typeHierarchy type hierarchy for materializing generic types
 */
private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy) {
    if (Modifier.isPublic(f.getModifiers())) {
        return true;
    } else {
        boolean hasGetter = false, hasSetter = false;
        final String fieldNameLow = f.getName().toLowerCase();
        Type fieldType = f.getGenericType();
        TypeVariable<?> fieldTypeGeneric = null;
        if (fieldType instanceof TypeVariable) {
            fieldTypeGeneric = (TypeVariable<?>) fieldType;
            fieldType = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) fieldType);
        }
        for (Method m : clazz.getMethods()) {
            // check for getter
            if (// The name should be ""get<FieldName>"" or ""<fieldName>"" (for scala) or ""is<fieldName>"" for boolean fields.
            (m.getName().toLowerCase().equals(""get"" + fieldNameLow) || m.getName().toLowerCase().equals(""is"" + fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow)) && // no arguments for the getter
            m.getParameterTypes().length == 0 && // return type is same as field type (or the generic variant of it)
            (m.getGenericReturnType().equals(fieldType) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)))) {
                if (hasGetter) {
                    throw new IllegalStateException(""Detected more than one getter"");
                }
                hasGetter = true;
            }
            // check for setters (<FieldName>_$eq for scala)
            if ((m.getName().toLowerCase().equals(""set"" + fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow + ""_$eq"")) && // one parameter of the field's type
            m.getParameterTypes().length == 1 && (m.getGenericParameterTypes()[0].equals(fieldType) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric))) && // return type is void.
            m.getReturnType().equals(Void.TYPE)) {
                if (hasSetter) {
                    throw new IllegalStateException(""Detected more than one setter"");
                }
                hasSetter = true;
            }
        }
        if (hasGetter && hasSetter) {
            return true;
        } else {
            if (!hasGetter) {
                LOG.debug(""Class "" + clazz + "" does not contain a getter for field "" + f.getName());
            }
            if (!hasSetter) {
                LOG.debug(""Class "" + clazz + "" does not contain a setter for field "" + f.getName());
            }
            return false;
        }
    }
}","/**
 *  Checks if the given field is a valid pojo field:
 *  - it is public
 *  OR
 *   - there are getter and setter methods for the field.
 *
 *  @param f field to check
 *  @param clazz class of field
 *  @param typeHierarchy type hierarchy for materializing generic types
 */
","private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy) {
    if (Modifier.isPublic(f.getModifiers())) {
        return true;
    } else {
        boolean hasGetter = false, hasSetter = false;
        final String fieldNameLow = f.getName().toLowerCase();
        Type fieldType = f.getGenericType();
        TypeVariable<?> fieldTypeGeneric = null;
        if (fieldType instanceof TypeVariable) {
            fieldTypeGeneric = (TypeVariable<?>) fieldType;
            fieldType = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) fieldType);
        }
        for (Method m : clazz.getMethods()) {
                        if (            (m.getName().toLowerCase().equals(""get"" + fieldNameLow) || m.getName().toLowerCase().equals(""is"" + fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow)) &&             m.getParameterTypes().length == 0 &&             (m.getGenericReturnType().equals(fieldType) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)))) {
                if (hasGetter) {
                    throw new IllegalStateException(""Detected more than one getter"");
                }
                hasGetter = true;
            }
                        if ((m.getName().toLowerCase().equals(""set"" + fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow + ""_$eq"")) &&             m.getParameterTypes().length == 1 && (m.getGenericParameterTypes()[0].equals(fieldType) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric))) &&             m.getReturnType().equals(Void.TYPE)) {
                if (hasSetter) {
                    throw new IllegalStateException(""Detected more than one setter"");
                }
                hasSetter = true;
            }
        }
        if (hasGetter && hasSetter) {
            return true;
        } else {
            if (!hasGetter) {
                LOG.debug(""Class "" + clazz + "" does not contain a getter for field "" + f.getName());
            }
            if (!hasSetter) {
                LOG.debug(""Class "" + clazz + "" does not contain a setter for field "" + f.getName());
            }
            return false;
        }
    }
}",1.3636363636363635,0.7033492822966506,1.8,1.0,2.9166666666666665,1.2460317460317458,-0.8474982381959123,2.6666666666666665,-0.02631578947368421,3.5861367081020954
Math,6,1,"/**
 * {@inheritDoc}
 */
@Override
protected PointValuePair doOptimize() {
    checkParameters();
    // Indirect call to ""computeObjectiveValue"" in order to update the
    // evaluations counter.
    final MultivariateFunction evalFunc = new MultivariateFunction() {

        public double value(double[] point) {
            return computeObjectiveValue(point);
        }
    };
    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
    final Comparator<PointValuePair> comparator = new Comparator<PointValuePair>() {

        public int compare(final PointValuePair o1, final PointValuePair o2) {
            final double v1 = o1.getValue();
            final double v2 = o2.getValue();
            return isMinim ? Double.compare(v1, v2) : Double.compare(v2, v1);
        }
    };
    // Initialize search.
    simplex.build(getStartPoint());
    simplex.evaluate(evalFunc, comparator);
    PointValuePair[] previous = null;
    int iteration = 0;
    final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();
    while (true) {
        if (iteration > 0) {
            boolean converged = true;
            for (int i = 0; i < simplex.getSize(); i++) {
                PointValuePair prev = previous[i];
                converged = converged && checker.converged(iteration, prev, simplex.getPoint(i));
            }
            if (converged) {
                // We have found an optimum.
                return simplex.getPoint(0);
            }
        }
        // We still need to search.
        previous = simplex.getPoints();
        simplex.iterate(evalFunc, comparator);
        ++iteration;
    }
}","/**
 * {@inheritDoc}
 */
","@Override
protected PointValuePair doOptimize() {
    checkParameters();
            final MultivariateFunction evalFunc = new MultivariateFunction() {

        public double value(double[] point) {
            return computeObjectiveValue(point);
        }
    };
    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
    final Comparator<PointValuePair> comparator = new Comparator<PointValuePair>() {

        public int compare(final PointValuePair o1, final PointValuePair o2) {
            final double v1 = o1.getValue();
            final double v2 = o2.getValue();
            return isMinim ? Double.compare(v1, v2) : Double.compare(v2, v1);
        }
    };
        simplex.build(getStartPoint());
    simplex.evaluate(evalFunc, comparator);
    PointValuePair[] previous = null;
    int iteration = 0;
    final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();
    while (true) {
        if (iteration > 0) {
            boolean converged = true;
            for (int i = 0; i < simplex.getSize(); i++) {
                PointValuePair prev = previous[i];
                converged = converged && checker.converged(iteration, prev, simplex.getPoint(i));
            }
            if (converged) {
                                return simplex.getPoint(0);
            }
        }
                previous = simplex.getPoints();
        simplex.iterate(evalFunc, comparator);
        ++iteration;
    }
}",1.0454545454545454,0.6937799043062203,0.4,0.5,0.4166666666666667,0.9523809523809523,-0.6541226215644819,0.9166666666666666,-0.02631578947368421,1.7528996156129155
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1883_9c2421ed,1,"public void releaseRecoveryLock(int clusterId) {
    UpdateOp update = new UpdateOp(Integer.toString(clusterId), true);
    update.set(ClusterNodeInfo.REV_RECOVERY_LOCK, null);
    store.createOrUpdate(Collection.CLUSTER_NODES, update);
}",,"public void releaseRecoveryLock(int clusterId) {
    UpdateOp update = new UpdateOp(Integer.toString(clusterId), true);
    update.set(ClusterNodeInfo.REV_RECOVERY_LOCK, null);
    store.createOrUpdate(Collection.CLUSTER_NODES, update);
}",-0.4090909090909091,-0.49282296650717716,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.5833685694150811,-0.25,0.0,-0.16279340490885932
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1977_4bfbfcdd,1,"// ------------------------------------------------------------< Object >--
public String toString() {
    StringBuilder buffer = new StringBuilder(""property "");
    buffer.append(name);
    if (values == null) {
        buffer.append("" IS NOT NULL"");
    } else if (values.isEmpty()) {
        buffer.append("" NOT APPLICABLE"");
    } else if (values.size() == 1) {
        buffer.append("" = "");
        buffer.append(values.iterator().next());
    } else {
        buffer.append("" IN ("");
        boolean comma = false;
        for (String value : values) {
            if (comma) {
                buffer.append("", "");
            }
            buffer.append(value);
            comma = true;
        }
        buffer.append("")"");
    }
    return buffer.toString();
}",,"public String toString() {
    StringBuilder buffer = new StringBuilder(""property "");
    buffer.append(name);
    if (values == null) {
        buffer.append("" IS NOT NULL"");
    } else if (values.isEmpty()) {
        buffer.append("" NOT APPLICABLE"");
    } else if (values.size() == 1) {
        buffer.append("" = "");
        buffer.append(values.iterator().next());
    } else {
        buffer.append("" IN ("");
        boolean comma = false;
        for (String value : values) {
            if (comma) {
                buffer.append("", "");
            }
            buffer.append(value);
            comma = true;
        }
        buffer.append("")"");
    }
    return buffer.toString();
}",0.45454545454545453,0.42105263157894735,0.4,1.5,0.25,0.05555555555555556,-0.3364341085271318,0.6666666666666666,-0.02631578947368421,0.10675472415760442
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-3424_27d4ee21,1,"// Not for client use
public boolean config(String... args) {
    ShellOptionsJC options = new ShellOptionsJC();
    JCommander jc = new JCommander();
    jc.setProgramName(""accumulo shell"");
    jc.addObject(options);
    try {
        jc.parse(args);
    } catch (ParameterException e) {
        configError = true;
    }
    if (options.isHelpEnabled()) {
        configError = true;
    }
    if (!configError && options.getUnrecognizedOptions() != null) {
        configError = true;
        logError(""Unrecognized Options: "" + options.getUnrecognizedOptions().toString());
    }
    if (configError) {
        jc.usage();
        return true;
    }
    setDebugging(options.isDebugEnabled());
    authTimeout = TimeUnit.MINUTES.toNanos(options.getAuthTimeout());
    disableAuthTimeout = options.isAuthTimeoutDisabled();
    // get the options that were parsed
    String user = options.getUsername();
    String password = options.getPassword();
    tabCompletion = !options.isTabCompletionDisabled();
    // Use a fake (Mock), ZK, or HdfsZK Accumulo instance
    setInstance(options);
    // AuthenticationToken options
    token = options.getAuthenticationToken();
    Map<String, String> loginOptions = options.getTokenProperties();
    // process default parameters if unspecified
    try {
        boolean hasToken = (token != null);
        boolean hasTokenOptions = !loginOptions.isEmpty();
        if (hasToken && password != null) {
            throw new ParameterException(""Can not supply '--pass' option with '--tokenClass' option"");
        }
        Runtime.getRuntime().addShutdownHook(new Thread() {

            @Override
            public void run() {
                reader.getTerminal().setEchoEnabled(true);
            }
        });
        // Need either both a token and options, or neither, but not just one.
        if (hasToken != hasTokenOptions) {
            throw new ParameterException(""Must supply either both or neither of '--tokenClass' and '--tokenProperty'"");
        } else if (hasToken) {
            // implied hasTokenOptions
            // Fully qualified name so we don't shadow java.util.Properties
            org.apache.accumulo.core.client.security.tokens.AuthenticationToken.Properties props;
            // and line wrap it because the package name is so long
            props = new org.apache.accumulo.core.client.security.tokens.AuthenticationToken.Properties();
            props.putAllStrings(loginOptions);
            token.init(props);
        } else {
            // Read password if the user explicitly asked for it, or didn't specify anything at all
            if (""stdin"".equals(password) || password == null) {
                password = reader.readLine(""Password: "", '*');
            }
            if (password == null) {
                // User cancel, e.g. Ctrl-D pressed
                throw new ParameterException(""No password or token option supplied"");
            } else {
                this.token = new PasswordToken(password);
            }
        }
        if (!options.isFake()) {
            ZooReader zr = new ZooReader(instance.getZooKeepers(), instance.getZooKeepersSessionTimeOut());
            DistributedTrace.enable(instance, zr, ""shell"", InetAddress.getLocalHost().getHostName());
        }
        this.setTableName("""");
        this.principal = user;
        connector = instance.getConnector(this.principal, token);
    } catch (Exception e) {
        printException(e);
        configError = true;
    }
    // decide whether to execute commands from a file and quit
    if (options.getExecFile() != null) {
        execFile = options.getExecFile();
        verbose = false;
    } else if (options.getExecFileVerbose() != null) {
        execFile = options.getExecFileVerbose();
        verbose = true;
    }
    execCommand = options.getExecCommand();
    if (execCommand != null) {
        verbose = false;
    }
    rootToken = new Token();
    Command[] dataCommands = { new DeleteCommand(), new DeleteManyCommand(), new DeleteRowsCommand(), new EGrepCommand(), new FormatterCommand(), new InterpreterCommand(), new GrepCommand(), new ImportDirectoryCommand(), new InsertCommand(), new MaxRowCommand(), new ScanCommand() };
    Command[] debuggingCommands = { new ClasspathCommand(), new DebugCommand(), new ListScansCommand(), new ListCompactionsCommand(), new TraceCommand(), new PingCommand() };
    Command[] execCommands = { new ExecfileCommand(), new HistoryCommand(), new ExtensionCommand(), new ScriptCommand() };
    Command[] exitCommands = { new ByeCommand(), new ExitCommand(), new QuitCommand() };
    Command[] helpCommands = { new AboutCommand(), new HelpCommand(), new InfoCommand(), new QuestionCommand() };
    Command[] iteratorCommands = { new DeleteIterCommand(), new DeleteScanIterCommand(), new ListIterCommand(), new SetIterCommand(), new SetScanIterCommand(), new SetShellIterCommand(), new ListShellIterCommand(), new DeleteShellIterCommand() };
    Command[] otherCommands = { new HiddenCommand() };
    Command[] permissionsCommands = { new GrantCommand(), new RevokeCommand(), new SystemPermissionsCommand(), new TablePermissionsCommand(), new UserPermissionsCommand(), new NamespacePermissionsCommand() };
    Command[] stateCommands = { new AuthenticateCommand(), new ClsCommand(), new ClearCommand(), new FateCommand(), new NoTableCommand(), new SleepCommand(), new TableCommand(), new UserCommand(), new WhoAmICommand() };
    Command[] tableCommands = { new CloneTableCommand(), new ConfigCommand(), new CreateTableCommand(), new DeleteTableCommand(), new DropTableCommand(), new DUCommand(), new ExportTableCommand(), new ImportTableCommand(), new OfflineCommand(), new OnlineCommand(), new RenameTableCommand(), new TablesCommand(), new NamespacesCommand(), new CreateNamespaceCommand(), new DeleteNamespaceCommand(), new RenameNamespaceCommand() };
    Command[] tableControlCommands = { new AddSplitsCommand(), new CompactCommand(), new ConstraintCommand(), new FlushCommand(), new GetGroupsCommand(), new GetSplitsCommand(), new MergeCommand(), new SetGroupsCommand() };
    Command[] userCommands = { new AddAuthsCommand(), new CreateUserCommand(), new DeleteUserCommand(), new DropUserCommand(), new GetAuthsCommand(), new PasswdCommand(), new SetAuthsCommand(), new UsersCommand() };
    commandGrouping.put(""-- Writing, Reading, and Removing Data --"", dataCommands);
    commandGrouping.put(""-- Debugging Commands -------------------"", debuggingCommands);
    commandGrouping.put(""-- Shell Execution Commands -------------"", execCommands);
    commandGrouping.put(""-- Exiting Commands ---------------------"", exitCommands);
    commandGrouping.put(""-- Help Commands ------------------------"", helpCommands);
    commandGrouping.put(""-- Iterator Configuration ---------------"", iteratorCommands);
    commandGrouping.put(""-- Permissions Administration Commands --"", permissionsCommands);
    commandGrouping.put(""-- Shell State Commands -----------------"", stateCommands);
    commandGrouping.put(""-- Table Administration Commands --------"", tableCommands);
    commandGrouping.put(""-- Table Control Commands ---------------"", tableControlCommands);
    commandGrouping.put(""-- User Administration Commands ---------"", userCommands);
    for (Command[] cmds : commandGrouping.values()) {
        for (Command cmd : cmds) commandFactory.put(cmd.getName(), cmd);
    }
    for (Command cmd : otherCommands) {
        commandFactory.put(cmd.getName(), cmd);
    }
    return configError;
}",,"public boolean config(String... args) {
    ShellOptionsJC options = new ShellOptionsJC();
    JCommander jc = new JCommander();
    jc.setProgramName(""accumulo shell"");
    jc.addObject(options);
    try {
        jc.parse(args);
    } catch (ParameterException e) {
        configError = true;
    }
    if (options.isHelpEnabled()) {
        configError = true;
    }
    if (!configError && options.getUnrecognizedOptions() != null) {
        configError = true;
        logError(""Unrecognized Options: "" + options.getUnrecognizedOptions().toString());
    }
    if (configError) {
        jc.usage();
        return true;
    }
    setDebugging(options.isDebugEnabled());
    authTimeout = TimeUnit.MINUTES.toNanos(options.getAuthTimeout());
    disableAuthTimeout = options.isAuthTimeoutDisabled();
        String user = options.getUsername();
    String password = options.getPassword();
    tabCompletion = !options.isTabCompletionDisabled();
        setInstance(options);
        token = options.getAuthenticationToken();
    Map<String, String> loginOptions = options.getTokenProperties();
        try {
        boolean hasToken = (token != null);
        boolean hasTokenOptions = !loginOptions.isEmpty();
        if (hasToken && password != null) {
            throw new ParameterException(""Can not supply '--pass' option with '--tokenClass' option"");
        }
        Runtime.getRuntime().addShutdownHook(new Thread() {

            @Override
            public void run() {
                reader.getTerminal().setEchoEnabled(true);
            }
        });
                if (hasToken != hasTokenOptions) {
            throw new ParameterException(""Must supply either both or neither of '--tokenClass' and '--tokenProperty'"");
        } else if (hasToken) {
                                    org.apache.accumulo.core.client.security.tokens.AuthenticationToken.Properties props;
                        props = new org.apache.accumulo.core.client.security.tokens.AuthenticationToken.Properties();
            props.putAllStrings(loginOptions);
            token.init(props);
        } else {
                        if (""stdin"".equals(password) || password == null) {
                password = reader.readLine(""Password: "", '*');
            }
            if (password == null) {
                                throw new ParameterException(""No password or token option supplied"");
            } else {
                this.token = new PasswordToken(password);
            }
        }
        if (!options.isFake()) {
            ZooReader zr = new ZooReader(instance.getZooKeepers(), instance.getZooKeepersSessionTimeOut());
            DistributedTrace.enable(instance, zr, ""shell"", InetAddress.getLocalHost().getHostName());
        }
        this.setTableName("""");
        this.principal = user;
        connector = instance.getConnector(this.principal, token);
    } catch (Exception e) {
        printException(e);
        configError = true;
    }
        if (options.getExecFile() != null) {
        execFile = options.getExecFile();
        verbose = false;
    } else if (options.getExecFileVerbose() != null) {
        execFile = options.getExecFileVerbose();
        verbose = true;
    }
    execCommand = options.getExecCommand();
    if (execCommand != null) {
        verbose = false;
    }
    rootToken = new Token();
    Command[] dataCommands = { new DeleteCommand(), new DeleteManyCommand(), new DeleteRowsCommand(), new EGrepCommand(), new FormatterCommand(), new InterpreterCommand(), new GrepCommand(), new ImportDirectoryCommand(), new InsertCommand(), new MaxRowCommand(), new ScanCommand() };
    Command[] debuggingCommands = { new ClasspathCommand(), new DebugCommand(), new ListScansCommand(), new ListCompactionsCommand(), new TraceCommand(), new PingCommand() };
    Command[] execCommands = { new ExecfileCommand(), new HistoryCommand(), new ExtensionCommand(), new ScriptCommand() };
    Command[] exitCommands = { new ByeCommand(), new ExitCommand(), new QuitCommand() };
    Command[] helpCommands = { new AboutCommand(), new HelpCommand(), new InfoCommand(), new QuestionCommand() };
    Command[] iteratorCommands = { new DeleteIterCommand(), new DeleteScanIterCommand(), new ListIterCommand(), new SetIterCommand(), new SetScanIterCommand(), new SetShellIterCommand(), new ListShellIterCommand(), new DeleteShellIterCommand() };
    Command[] otherCommands = { new HiddenCommand() };
    Command[] permissionsCommands = { new GrantCommand(), new RevokeCommand(), new SystemPermissionsCommand(), new TablePermissionsCommand(), new UserPermissionsCommand(), new NamespacePermissionsCommand() };
    Command[] stateCommands = { new AuthenticateCommand(), new ClsCommand(), new ClearCommand(), new FateCommand(), new NoTableCommand(), new SleepCommand(), new TableCommand(), new UserCommand(), new WhoAmICommand() };
    Command[] tableCommands = { new CloneTableCommand(), new ConfigCommand(), new CreateTableCommand(), new DeleteTableCommand(), new DropTableCommand(), new DUCommand(), new ExportTableCommand(), new ImportTableCommand(), new OfflineCommand(), new OnlineCommand(), new RenameTableCommand(), new TablesCommand(), new NamespacesCommand(), new CreateNamespaceCommand(), new DeleteNamespaceCommand(), new RenameNamespaceCommand() };
    Command[] tableControlCommands = { new AddSplitsCommand(), new CompactCommand(), new ConstraintCommand(), new FlushCommand(), new GetGroupsCommand(), new GetSplitsCommand(), new MergeCommand(), new SetGroupsCommand() };
    Command[] userCommands = { new AddAuthsCommand(), new CreateUserCommand(), new DeleteUserCommand(), new DropUserCommand(), new GetAuthsCommand(), new PasswdCommand(), new SetAuthsCommand(), new UsersCommand() };
    commandGrouping.put(""-- Writing, Reading, and Removing Data --"", dataCommands);
    commandGrouping.put(""-- Debugging Commands -------------------"", debuggingCommands);
    commandGrouping.put(""-- Shell Execution Commands -------------"", execCommands);
    commandGrouping.put(""-- Exiting Commands ---------------------"", exitCommands);
    commandGrouping.put(""-- Help Commands ------------------------"", helpCommands);
    commandGrouping.put(""-- Iterator Configuration ---------------"", iteratorCommands);
    commandGrouping.put(""-- Permissions Administration Commands --"", permissionsCommands);
    commandGrouping.put(""-- Shell State Commands -----------------"", stateCommands);
    commandGrouping.put(""-- Table Administration Commands --------"", tableCommands);
    commandGrouping.put(""-- Table Control Commands ---------------"", tableControlCommands);
    commandGrouping.put(""-- User Administration Commands ---------"", userCommands);
    for (Command[] cmds : commandGrouping.values()) {
        for (Command cmd : cmds) commandFactory.put(cmd.getName(), cmd);
    }
    for (Command cmd : otherCommands) {
        commandFactory.put(cmd.getName(), cmd);
    }
    return configError;
}",4.5,0.23923444976076558,3.4,1.0,1.75,0.648809523809524,-1.5085271317829454,4.416666666666667,-0.02631578947368421,7.808281322937017
wicket,remotes/origin/bugs-dot-jar_WICKET-4686_89184b79,1,"private void resolvePageInstance(Integer pageId, Class<? extends IRequestablePage> pageClass, PageParameters pageParameters, Integer renderCount) {
    IRequestablePage page = null;
    boolean freshCreated = false;
    if (pageId != null) {
        page = getStoredPage(pageId);
        if (page == null) {
            // WICKET-4594 - ignore the parsed parameters for stateful pages
            pageParameters = null;
        }
    }
    if (page == null) {
        if (pageClass != null) {
            page = getPageSource().newPageInstance(pageClass, pageParameters);
            freshCreated = true;
        }
    }
    if (page != null && !freshCreated) {
        if (renderCount != null && page.getRenderCount() != renderCount) {
            throw new StalePageException(page);
        }
    }
    pageInstanceIsFresh = freshCreated;
    pageInstance = page;
}",,"private void resolvePageInstance(Integer pageId, Class<? extends IRequestablePage> pageClass, PageParameters pageParameters, Integer renderCount) {
    IRequestablePage page = null;
    boolean freshCreated = false;
    if (pageId != null) {
        page = getStoredPage(pageId);
        if (page == null) {
                        pageParameters = null;
        }
    }
    if (page == null) {
        if (pageClass != null) {
            page = getPageSource().newPageInstance(pageClass, pageParameters);
            freshCreated = true;
        }
    }
    if (page != null && !freshCreated) {
        if (renderCount != null && page.getRenderCount() != renderCount) {
            throw new StalePageException(page);
        }
    }
    pageInstanceIsFresh = freshCreated;
    pageInstance = page;
}",0.4090909090909091,0.24401913875598077,0.8,0.0,0.75,0.5376984126984127,-0.3530655391120508,-0.16666666666666666,-0.02631578947368421,0.5147836309883992
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-926_e1ae968c,1,"@Override
@Nonnull
protected Map<?, ?> transformAndSeal(@Nonnull Map<Object, Object> map, @Nullable String key, int level) {
    if (level == 1) {
        if (PREVIOUS.equals(key)) {
            SortedMap<Revision, Range> transformed = new TreeMap<Revision, Range>(new Comparator<Revision>() {

                @Override
                public int compare(Revision o1, Revision o2) {
                    // in reverse order!
                    int c = o2.compareRevisionTime(o1);
                    if (c == 0) {
                        c = o1.getClusterId() < o2.getClusterId() ? -1 : (o1.getClusterId() == o2.getClusterId() ? 0 : 1);
                    }
                    return c;
                }
            });
            for (Map.Entry<Object, Object> entry : map.entrySet()) {
                Revision high = Revision.fromString(entry.getKey().toString());
                Revision low = Revision.fromString(entry.getValue().toString());
                transformed.put(high, new Range(high, low));
            }
            return Collections.unmodifiableSortedMap(transformed);
        }
    }
    return super.transformAndSeal(map, key, level);
}",,"@Override
@Nonnull
protected Map<?, ?> transformAndSeal(@Nonnull Map<Object, Object> map, @Nullable String key, int level) {
    if (level == 1) {
        if (PREVIOUS.equals(key)) {
            SortedMap<Revision, Range> transformed = new TreeMap<Revision, Range>(new Comparator<Revision>() {

                @Override
                public int compare(Revision o1, Revision o2) {
                                        int c = o2.compareRevisionTime(o1);
                    if (c == 0) {
                        c = o1.getClusterId() < o2.getClusterId() ? -1 : (o1.getClusterId() == o2.getClusterId() ? 0 : 1);
                    }
                    return c;
                }
            });
            for (Map.Entry<Object, Object> entry : map.entrySet()) {
                Revision high = Revision.fromString(entry.getKey().toString());
                Revision low = Revision.fromString(entry.getValue().toString());
                transformed.put(high, new Range(high, low));
            }
            return Collections.unmodifiableSortedMap(transformed);
        }
    }
    return super.transformAndSeal(map, key, level);
}",0.5,2.004784688995215,0.6,1.0,0.5,0.5198412698412699,-0.45623678646934457,0.8333333333333334,-0.02631578947368421,0.9198619203218016
camel,remotes/origin/bugs-dot-jar_CAMEL-7275_44cad623,1,"protected boolean process(final Exchange exchange, final AsyncCallback callback, final Iterator<Processor> processors, final AsyncProcessor processor, final Object lastHandled) {
    // this does the actual processing so log at trace level
    LOG.trace(""Processing exchangeId: {} >>> {}"", exchange.getExchangeId(), exchange);
    // implement asynchronous routing logic in callback so we can have the callback being
    // triggered and then continue routing where we left
    boolean sync = processor.process(exchange, new AsyncCallback() {

        public void done(boolean doneSync) {
            // we only have to handle async completion of the pipeline
            if (doneSync) {
                return;
            }
            // continue processing the try .. catch .. finally asynchronously
            while (continueRouting(processors, exchange)) {
                ExchangeHelper.prepareOutToIn(exchange);
                // process the next processor
                AsyncProcessor processor = AsyncProcessorConverterHelper.convert(processors.next());
                doneSync = process(exchange, callback, processors, processor, lastHandled);
                if (!doneSync) {
                    LOG.trace(""Processing exchangeId: {} is continued being processed asynchronously"", exchange.getExchangeId());
                    // so we break out now, then the callback will be invoked which then continue routing from where we left here
                    return;
                }
            }
            ExchangeHelper.prepareOutToIn(exchange);
            exchange.setProperty(Exchange.EXCEPTION_HANDLED, lastHandled);
            LOG.trace(""Processing complete for exchangeId: {} >>> {}"", exchange.getExchangeId(), exchange);
            callback.done(false);
        }
    });
    return sync;
}",,"protected boolean process(final Exchange exchange, final AsyncCallback callback, final Iterator<Processor> processors, final AsyncProcessor processor, final Object lastHandled) {
        LOG.trace(""Processing exchangeId: {} >>> {}"", exchange.getExchangeId(), exchange);
            boolean sync = processor.process(exchange, new AsyncCallback() {

        public void done(boolean doneSync) {
                        if (doneSync) {
                return;
            }
                        while (continueRouting(processors, exchange)) {
                ExchangeHelper.prepareOutToIn(exchange);
                                AsyncProcessor processor = AsyncProcessorConverterHelper.convert(processors.next());
                doneSync = process(exchange, callback, processors, processor, lastHandled);
                if (!doneSync) {
                    LOG.trace(""Processing exchangeId: {} is continued being processed asynchronously"", exchange.getExchangeId());
                                        return;
                }
            }
            ExchangeHelper.prepareOutToIn(exchange);
            exchange.setProperty(Exchange.EXCEPTION_HANDLED, lastHandled);
            LOG.trace(""Processing complete for exchangeId: {} >>> {}"", exchange.getExchangeId(), exchange);
            callback.done(false);
        }
    });
    return sync;
}",0.45454545454545453,1.291866028708134,0.0,0.5,0.16666666666666666,0.08333333333333327,-0.36772374911909794,0.75,-0.02631578947368421,0.22581214017738277
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3310_4416a9f8,1,"@Override
public void remove() throws RepositoryException {
    sessionDelegate.performVoid(new ItemWriteOperation(""remove"") {

        @Override
        public void performVoid() {
            dlg.remove();
        }

        @Override
        public String toString() {
            return String.format(""Removing property [%s/%s] "", dlg.getPath(), dlg.getName());
        }
    });
}",,"@Override
public void remove() throws RepositoryException {
    sessionDelegate.performVoid(new ItemWriteOperation(""remove"") {

        @Override
        public void performVoid() {
            dlg.remove();
        }

        @Override
        public String toString() {
            return String.format(""Removing property [%s/%s] "", dlg.getPath(), dlg.getName());
        }
    });
}",-0.045454545454545456,0.5023923444976076,-0.6,-0.5,-0.4166666666666667,-0.3650793650793651,0.15066948555320642,-0.08333333333333333,0.47368421052631576,-0.16279340490885932
wicket,remotes/origin/bugs-dot-jar_WICKET-2334_96330447,1,"private static List<IDebugBarContributor> getContributors() {
    List<IDebugBarContributor> list = Application.get().getMetaData(CONTRIBS_META_KEY);
    return list == null ? new ArrayList<IDebugBarContributor>() : list;
}",,"private static List<IDebugBarContributor> getContributors() {
    List<IDebugBarContributor> list = Application.get().getMetaData(CONTRIBS_META_KEY);
    return list == null ? new ArrayList<IDebugBarContributor>() : list;
}",-0.45454545454545453,-0.47368421052631593,-0.4,-1.0,-0.25,-0.07738095238095241,0.7161381254404509,-0.3333333333333333,0.7368421052631579,-0.11812843254208374
Cli,32,0,"/**
 * Finds the next text wrap position after <code>startPos</code> for the
 * text in <code>text</code> with the column width <code>width</code>.
 * The wrap point is the last position before startPos+width having a
 * whitespace character (space, \n, \r). If there is no whitespace character
 * before startPos+width, it will return startPos+width.
 *
 * @param text The text being searched for the wrap position
 * @param width width of the wrapped text
 * @param startPos position from which to start the lookup whitespace
 * character
 * @return postion on which the text must be wrapped or -1 if the wrap
 * position is at the end of the text
 */
protected int findWrapPos(String text, int width, int startPos) {
    int pos;
    // the line ends before the max wrap pos or a new line char found
    if (((pos = text.indexOf('\n', startPos)) != -1 && pos <= width) || ((pos = text.indexOf('\t', startPos)) != -1 && pos <= width)) {
        return pos + 1;
    } else if (startPos + width >= text.length()) {
        return -1;
    }
    // look for the last whitespace character before startPos+width
    pos = startPos + width;
    char c;
    while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ') && (c != '\n') && (c != '\r')) {
        --pos;
    }
    // if we found it - just return
    if (pos > startPos) {
        return pos;
    }
    // if we didn't find one, simply chop at startPos+width
    pos = startPos + width;
    while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ') && (c != '\n') && (c != '\r')) {
        ++pos;
    }
    return pos == text.length() ? -1 : pos;
}","/**
 * Finds the next text wrap position after <code>startPos</code> for the
 * text in <code>text</code> with the column width <code>width</code>.
 * The wrap point is the last position before startPos+width having a
 * whitespace character (space, \n, \r). If there is no whitespace character
 * before startPos+width, it will return startPos+width.
 *
 * @param text The text being searched for the wrap position
 * @param width width of the wrapped text
 * @param startPos position from which to start the lookup whitespace
 * character
 * @return postion on which the text must be wrapped or -1 if the wrap
 * position is at the end of the text
 */
","protected int findWrapPos(String text, int width, int startPos) {
    int pos;
        if (((pos = text.indexOf('\n', startPos)) != -1 && pos <= width) || ((pos = text.indexOf('\t', startPos)) != -1 && pos <= width)) {
        return pos + 1;
    } else if (startPos + width >= text.length()) {
        return -1;
    }
        pos = startPos + width;
    char c;
    while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ') && (c != '\n') && (c != '\r')) {
        --pos;
    }
        if (pos > startPos) {
        return pos;
    }
        pos = startPos + width;
    while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ') && (c != '\n') && (c != '\r')) {
        ++pos;
    }
    return pos == text.length() ? -1 : pos;
}",0.3181818181818182,-0.35885167464114837,0.6,0.0,1.25,4.843253968253968,-0.3719520789288228,0.08333333333333333,-0.02631578947368421,6.004213850613462
flink,remotes/origin/bugs-dot-jar_FLINK-1761_380ef878,1,"private void notifyAllChannelsOfErrorAndClose(Throwable cause) {
    if (channelError.compareAndSet(false, true)) {
        for (RemoteInputChannel inputChannel : inputChannels.values()) {
            inputChannel.onError(cause);
        }
        inputChannels.clear();
        ctx.close();
    }
}",,"private void notifyAllChannelsOfErrorAndClose(Throwable cause) {
    if (channelError.compareAndSet(false, true)) {
        for (RemoteInputChannel inputChannel : inputChannels.values()) {
            inputChannel.onError(cause);
        }
        inputChannels.clear();
        ctx.close();
    }
}",-0.22727272727272727,0.39712918660287067,-0.2,0.0,-0.25,-0.3650793650793651,0.32008456659619455,-0.08333333333333333,0.2368421052631579,-0.16279340490885932
flink,remotes/origin/bugs-dot-jar_FLINK-1820_39d526e6,0,"/**
 *  Static utility to parse a field of type byte from a byte sequence that represents text characters
 *  (such as when read from a file stream).
 *
 *  @param bytes The bytes containing the text data that should be parsed.
 *  @param startPos The offset to start the parsing.
 *  @param length The length of the byte sequence (counting from the offset).
 *  @param delimiter The delimiter that terminates the field.
 *
 *  @return The parsed value.
 *
 *  @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.
 */
public static final byte parseField(byte[] bytes, int startPos, int length, char delimiter) {
    if (length <= 0) {
        throw new NumberFormatException(""Invalid input: Empty string"");
    }
    long val = 0;
    boolean neg = false;
    if (bytes[startPos] == '-') {
        neg = true;
        startPos++;
        length--;
        if (length == 0 || bytes[startPos] == delimiter) {
            throw new NumberFormatException(""Orphaned minus sign."");
        }
    }
    for (; length > 0; startPos++, length--) {
        if (bytes[startPos] == delimiter) {
            return (byte) (neg ? -val : val);
        }
        if (bytes[startPos] < 48 || bytes[startPos] > 57) {
            throw new NumberFormatException(""Invalid character."");
        }
        val *= 10;
        val += bytes[startPos] - 48;
        if (val > Byte.MAX_VALUE && (!neg || val > -Byte.MIN_VALUE)) {
            throw new NumberFormatException(""Value overflow/underflow"");
        }
    }
    return (byte) (neg ? -val : val);
}","/**
 *  Static utility to parse a field of type byte from a byte sequence that represents text characters
 *  (such as when read from a file stream).
 *
 *  @param bytes The bytes containing the text data that should be parsed.
 *  @param startPos The offset to start the parsing.
 *  @param length The length of the byte sequence (counting from the offset).
 *  @param delimiter The delimiter that terminates the field.
 *
 *  @return The parsed value.
 *
 *  @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.
 */
","public static final byte parseField(byte[] bytes, int startPos, int length, char delimiter) {
    if (length <= 0) {
        throw new NumberFormatException(""Invalid input: Empty string"");
    }
    long val = 0;
    boolean neg = false;
    if (bytes[startPos] == '-') {
        neg = true;
        startPos++;
        length--;
        if (length == 0 || bytes[startPos] == delimiter) {
            throw new NumberFormatException(""Orphaned minus sign."");
        }
    }
    for (; length > 0; startPos++, length--) {
        if (bytes[startPos] == delimiter) {
            return (byte) (neg ? -val : val);
        }
        if (bytes[startPos] < 48 || bytes[startPos] > 57) {
            throw new NumberFormatException(""Invalid character."");
        }
        val *= 10;
        val += bytes[startPos] - 48;
        if (val > Byte.MAX_VALUE && (!neg || val > -Byte.MIN_VALUE)) {
            throw new NumberFormatException(""Value overflow/underflow"");
        }
    }
    return (byte) (neg ? -val : val);
}",0.6818181818181818,0.08612440191387546,2.0,0.0,1.0,2.948412698412698,-0.5546159267089498,-0.5,-0.02631578947368421,3.498277461777401
Closure,153,2,"/**
 * Remove duplicate VAR declarations encountered discovered during
 * scope creation.
 */
@Override
public void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {
    Preconditions.checkState(n.getType() == Token.NAME);
    Var v = s.getVar(name);
    // If name is ""arguments"", Var maybe null.
    if (v != null && v.getParentNode().getType() == Token.CATCH) {
        // Redeclaration of a catch expression variable is hard to model
        // without support for ""with"" expressions.
        // The EcmaScript spec (section 12.14), declares that a catch
        // ""catch (e) {}"" is handled like ""with ({'e': e}) {}"" so that
        // ""var e"" would refer to the scope variable, but any following
        // reference would still refer to ""e"" of the catch expression.
        // Until we have support for this disallow it.
        // Currently the Scope object adds the catch expression to the
        // function scope, which is technically not true but a good
        // approximation for most uses.
        // TODO(johnlenz): Consider improving how scope handles catch
        // expression.
        // Use the name of the var before it was made unique.
        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);
        compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));
    } else if (v != null && parent.getType() == Token.FUNCTION) {
        if (v.getParentNode().getType() == Token.VAR) {
            s.undeclare(v);
            s.declare(name, n, n.getJSType(), v.input);
            replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());
        }
    } else if (parent.getType() == Token.VAR) {
        Preconditions.checkState(parent.hasOneChild());
        replaceVarWithAssignment(n, parent, gramps);
    }
}","/**
 * Remove duplicate VAR declarations encountered discovered during
 * scope creation.
 */
","@Override
public void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {
    Preconditions.checkState(n.getType() == Token.NAME);
    Var v = s.getVar(name);
        if (v != null && v.getParentNode().getType() == Token.CATCH) {
                                                                                                                name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);
        compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));
    } else if (v != null && parent.getType() == Token.FUNCTION) {
        if (v.getParentNode().getType() == Token.VAR) {
            s.undeclare(v);
            s.declare(name, n, n.getJSType(), v.input);
            replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());
        }
    } else if (parent.getType() == Token.VAR) {
        Preconditions.checkState(parent.hasOneChild());
        replaceVarWithAssignment(n, parent, gramps);
    }
}",0.18181818181818182,0.40191387559808606,0.2,0.5,0.3333333333333333,0.4662698412698414,-0.3026074700493304,1.5,-0.02631578947368421,0.9199126340600379
Compress,38,1,"/**
 * Return whether or not this entry represents a directory.
 *
 * @return True if this entry is a directory.
 */
@Override
public boolean isDirectory() {
    if (file != null) {
        return file.isDirectory();
    }
    if (linkFlag == LF_DIR) {
        return true;
    }
    if (getName().endsWith(""/"")) {
        return true;
    }
    return false;
}","/**
 * Return whether or not this entry represents a directory.
 *
 * @return True if this entry is a directory.
 */
","@Override
public boolean isDirectory() {
    if (file != null) {
        return file.isDirectory();
    }
    if (linkFlag == LF_DIR) {
        return true;
    }
    if (getName().endsWith(""/"")) {
        return true;
    }
    return false;
}",-0.045454545454545456,-0.1291866028708134,0.0,-0.5,0.08333333333333333,-0.11706349206349208,0.1689922480620156,-0.25,2.0,-0.12549114526604543
commons-math,remotes/origin/bugs-dot-jar_MATH-1135_a7363a2a,3,"/**
 * Update the partial hull with the current point.
 *
 * @param point the current point
 * @param hull the partial hull
 */
private void updateHull(final Vector2D point, final List<Vector2D> hull) {
    final double tolerance = getTolerance();
    if (hull.size() == 1) {
        // ensure that we do not add an identical point
        final Vector2D p1 = hull.get(0);
        if (p1.distance(point) < tolerance) {
            return;
        }
    }
    while (hull.size() >= 2) {
        final int size = hull.size();
        final Vector2D p1 = hull.get(size - 2);
        final Vector2D p2 = hull.get(size - 1);
        final double offset = new Line(p1, p2, tolerance).getOffset(point);
        if (FastMath.abs(offset) < tolerance) {
            // the point is collinear to the line (p1, p2)
            final double distanceToCurrent = p1.distance(point);
            if (distanceToCurrent < tolerance || p2.distance(point) < tolerance) {
                // the point is assumed to be identical to either p1 or p2
                return;
            }
            final double distanceToLast = p1.distance(p2);
            if (isIncludeCollinearPoints()) {
                final int index = distanceToCurrent < distanceToLast ? size - 1 : size;
                hull.add(index, point);
            } else {
                if (distanceToCurrent > distanceToLast) {
                    hull.remove(size - 1);
                }
                hull.add(point);
            }
            return;
        } else if (offset > 0) {
            hull.remove(size - 1);
        } else {
            break;
        }
    }
    hull.add(point);
}","/**
 * Update the partial hull with the current point.
 *
 * @param point the current point
 * @param hull the partial hull
 */
","private void updateHull(final Vector2D point, final List<Vector2D> hull) {
    final double tolerance = getTolerance();
    if (hull.size() == 1) {
                final Vector2D p1 = hull.get(0);
        if (p1.distance(point) < tolerance) {
            return;
        }
    }
    while (hull.size() >= 2) {
        final int size = hull.size();
        final Vector2D p1 = hull.get(size - 2);
        final Vector2D p2 = hull.get(size - 1);
        final double offset = new Line(p1, p2, tolerance).getOffset(point);
        if (FastMath.abs(offset) < tolerance) {
                        final double distanceToCurrent = p1.distance(point);
            if (distanceToCurrent < tolerance || p2.distance(point) < tolerance) {
                                return;
            }
            final double distanceToLast = p1.distance(p2);
            if (isIncludeCollinearPoints()) {
                final int index = distanceToCurrent < distanceToLast ? size - 1 : size;
                hull.add(index, point);
            } else {
                if (distanceToCurrent > distanceToLast) {
                    hull.remove(size - 1);
                }
                hull.add(point);
            }
            return;
        } else if (offset > 0) {
            hull.remove(size - 1);
        } else {
            break;
        }
    }
    hull.add(point);
}",1.0454545454545454,0.8181818181818182,1.4,1.0,1.25,1.6845238095238095,-0.6792107117688511,1.0833333333333333,-0.02631578947368421,2.672906761639667
commons-math,remotes/origin/bugs-dot-jar_MATH-395_962315ba,1,"/**
 * {@inheritDoc}
 */
public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max, final double startValue) throws MaxIterationsExceededException, FunctionEvaluationException {
    clearResult();
    return localMin(f, goalType, min, startValue, max, getRelativeAccuracy(), getAbsoluteAccuracy());
}","/**
 * {@inheritDoc}
 */
","public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max, final double startValue) throws MaxIterationsExceededException, FunctionEvaluationException {
    clearResult();
    return localMin(f, goalType, min, startValue, max, getRelativeAccuracy(), getAbsoluteAccuracy());
}",-0.45454545454545453,-0.47368421052631593,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.6992248062015504,-0.16666666666666666,0.02631578947368421,-0.16279340490885932
wicket,remotes/origin/bugs-dot-jar_WICKET-5570_57d8f051,1,"/**
 *  @return the name of the handle that is used to stop any scheduled timer
 */
private String getTimeoutHandle() {
    return ""Wicket.TimerHandles['"" + getComponent().getMarkupId() + ""']"";
}","/**
 *  @return the name of the handle that is used to stop any scheduled timer
 */
","private String getTimeoutHandle() {
    return ""Wicket.TimerHandles['"" + getComponent().getMarkupId() + ""']"";
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,1.0036645525017613,-0.3333333333333333,2.6052631578947367,-0.16279340490885932
camel,remotes/origin/bugs-dot-jar_CAMEL-9673_7944093f,3,"@Override
public boolean process(final Exchange exchange, final AsyncCallback callback) {
    // clear exception so finally block can be executed
    final Exception e = exchange.getException();
    exchange.setException(null);
    // but store the caught exception as a property
    if (e != null) {
        exchange.setProperty(Exchange.EXCEPTION_CAUGHT, e);
    }
    // store the last to endpoint as the failure endpoint
    if (exchange.getProperty(Exchange.FAILURE_ENDPOINT) == null) {
        exchange.setProperty(Exchange.FAILURE_ENDPOINT, exchange.getProperty(Exchange.TO_ENDPOINT));
    }
    boolean sync = processor.process(exchange, new AsyncCallback() {

        public void done(boolean doneSync) {
            if (e == null) {
                exchange.removeProperty(Exchange.FAILURE_ENDPOINT);
            } else {
                // set exception back on exchange
                exchange.setException(e);
                exchange.setProperty(Exchange.EXCEPTION_CAUGHT, e);
            }
            if (!doneSync) {
                // signal callback to continue routing async
                ExchangeHelper.prepareOutToIn(exchange);
                LOG.trace(""Processing complete for exchangeId: {} >>> {}"", exchange.getExchangeId(), exchange);
            }
            callback.done(doneSync);
        }
    });
    return sync;
}",,"@Override
public boolean process(final Exchange exchange, final AsyncCallback callback) {
        final Exception e = exchange.getException();
    exchange.setException(null);
        if (e != null) {
        exchange.setProperty(Exchange.EXCEPTION_CAUGHT, e);
    }
        if (exchange.getProperty(Exchange.FAILURE_ENDPOINT) == null) {
        exchange.setProperty(Exchange.FAILURE_ENDPOINT, exchange.getProperty(Exchange.TO_ENDPOINT));
    }
    boolean sync = processor.process(exchange, new AsyncCallback() {

        public void done(boolean doneSync) {
            if (e == null) {
                exchange.removeProperty(Exchange.FAILURE_ENDPOINT);
            } else {
                                exchange.setException(e);
                exchange.setProperty(Exchange.EXCEPTION_CAUGHT, e);
            }
            if (!doneSync) {
                                ExchangeHelper.prepareOutToIn(exchange);
                LOG.trace(""Processing complete for exchangeId: {} >>> {}"", exchange.getExchangeId(), exchange);
            }
            callback.done(doneSync);
        }
    });
    return sync;
}",0.5909090909090909,1.0956937799043063,0.2,0.0,0.16666666666666666,0.613095238095238,-0.4286116983791401,0.6666666666666666,-0.02631578947368421,0.6892942145997936
wicket,remotes/origin/bugs-dot-jar_WICKET-5734_71674df5,3,"/**
 *  Creates a {@code IRequestHandler} that processes a hybrid request. When the page identified
 *  by {@code pageInfo} was not available, the request should be treated as a bookmarkable
 *  request.
 *
 *  @param pageInfo
 *  @param pageClass
 *  @param pageParameters
 *  @param renderCount
 *  @return a {@code IRequestHandler} capable of processing the hybrid request.
 */
protected IRequestHandler processHybrid(PageInfo pageInfo, Class<? extends IRequestablePage> pageClass, PageParameters pageParameters, Integer renderCount) {
    PageProvider provider = new PageProvider(pageInfo.getPageId(), pageClass, pageParameters, renderCount);
    provider.setPageSource(getContext());
    if (provider.isNewPageInstance() && !getRecreateMountedPagesAfterExpiry()) {
        throw new PageExpiredException(String.format(""Bookmarkable page id '%d' has expired."", pageInfo.getPageId()));
    } else {
        PageParameters constructionPageParameters = provider.getPageInstance().getPageParameters();
        if (PageParameters.equals(constructionPageParameters, pageParameters) == false) {
            // when the resolved page by id has been created
            return new RenderPageRequestHandler(new PageProvider(pageClass, pageParameters));
        }
        return new RenderPageRequestHandler(provider);
    }
}","/**
 *  Creates a {@code IRequestHandler} that processes a hybrid request. When the page identified
 *  by {@code pageInfo} was not available, the request should be treated as a bookmarkable
 *  request.
 *
 *  @param pageInfo
 *  @param pageClass
 *  @param pageParameters
 *  @param renderCount
 *  @return a {@code IRequestHandler} capable of processing the hybrid request.
 */
","protected IRequestHandler processHybrid(PageInfo pageInfo, Class<? extends IRequestablePage> pageClass, PageParameters pageParameters, Integer renderCount) {
    PageProvider provider = new PageProvider(pageInfo.getPageId(), pageClass, pageParameters, renderCount);
    provider.setPageSource(getContext());
    if (provider.isNewPageInstance() && !getRecreateMountedPagesAfterExpiry()) {
        throw new PageExpiredException(String.format(""Bookmarkable page id '%d' has expired."", pageInfo.getPageId()));
    } else {
        PageParameters constructionPageParameters = provider.getPageInstance().getPageParameters();
        if (PageParameters.equals(constructionPageParameters, pageParameters) == false) {
                        return new RenderPageRequestHandler(new PageProvider(pageClass, pageParameters));
        }
        return new RenderPageRequestHandler(provider);
    }
}",-0.045454545454545456,0.16746411483253573,0.0,0.0,0.25,0.2916666666666667,-0.03875968992248061,0.3333333333333333,-0.02631578947368421,0.24523550192193536
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1364_05c89637,1,"synchronized V get(K key, int hash, CacheLoader<K, V> loader) throws ExecutionException {
    V value = get(key, hash);
    if (value == null) {
        long start = System.nanoTime();
        try {
            value = loader.load(key);
            loadSuccessCount++;
        } catch (Exception e) {
            loadExceptionCount++;
            throw new ExecutionException(e);
        } finally {
            long time = System.nanoTime() - start;
            totalLoadTime += time;
        }
        put(key, hash, value, cache.sizeOf(key, value));
    }
    return value;
}",,"synchronized V get(K key, int hash, CacheLoader<K, V> loader) throws ExecutionException {
    V value = get(key, hash);
    if (value == null) {
        long start = System.nanoTime();
        try {
            value = loader.load(key);
            loadSuccessCount++;
        } catch (Exception e) {
            loadExceptionCount++;
            throw new ExecutionException(e);
        } finally {
            long time = System.nanoTime() - start;
            totalLoadTime += time;
        }
        put(key, hash, value, cache.sizeOf(key, value));
    }
    return value;
}",0.18181818181818182,0.4736842105263157,0.0,0.0,-0.25,0.3948412698412698,-0.18731501057082436,0.0,0.02631578947368421,0.30940682215037774
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-2742_1f7dd2d5,1,"@SuppressWarnings(""unchecked"")
@Override
public int execute(final String fullCommand, final CommandLine cl, final Shell shellState) throws IOException {
    if (cl.hasOption(clearHist.getOpt())) {
        shellState.getReader().getHistory().clear();
    } else {
        ListIterator<Entry> it = shellState.getReader().getHistory().entries();
        shellState.printLines(new HistoryLineIterator(it), !cl.hasOption(disablePaginationOpt.getOpt()));
    }
    return 0;
}",,"@SuppressWarnings(""unchecked"")
@Override
public int execute(final String fullCommand, final CommandLine cl, final Shell shellState) throws IOException {
    if (cl.hasOption(clearHist.getOpt())) {
        shellState.getReader().getHistory().clear();
    } else {
        ListIterator<Entry> it = shellState.getReader().getHistory().entries();
        shellState.printLines(new HistoryLineIterator(it), !cl.hasOption(disablePaginationOpt.getOpt()));
    }
    return 0;
}",-0.13636363636363635,0.08612440191387546,-0.4,-0.5,-0.16666666666666666,-0.0912698412698413,0.10613107822410148,0.4166666666666667,-0.02631578947368421,-0.046179469004108964
commons-math,remotes/origin/bugs-dot-jar_MATH-744_8a83581e,1,"/**
 * <p>
 * Gets the fraction as a <tt>float</tt>. This calculates the fraction as
 * the numerator divided by denominator.
 * </p>
 *
 * @return the fraction as a <tt>float</tt>.
 * @see java.lang.Number#floatValue()
 */
@Override
public float floatValue() {
    return numerator.floatValue() / denominator.floatValue();
}","/**
 * <p>
 * Gets the fraction as a <tt>float</tt>. This calculates the fraction as
 * the numerator divided by denominator.
 * </p>
 *
 * @return the fraction as a <tt>float</tt>.
 * @see java.lang.Number#floatValue()
 */
","@Override
public float floatValue() {
    return numerator.floatValue() / denominator.floatValue();
}",-0.45454545454545453,-0.6028708133971293,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.8940098661028892,-0.3333333333333333,2.4736842105263155,-0.16279340490885932
wicket,remotes/origin/bugs-dot-jar_WICKET-2993_0b4f78cc,1,"/**
 *  @see org.apache.wicket.request.mapper.AbstractBookmarkableMapper#parseRequest(org.apache.wicket.request.Request)
 */
@Override
protected UrlInfo parseRequest(Request request) {
    Url url = request.getUrl();
    if (url.getSegments().size() >= 3 && urlStartsWith(url, getContext().getNamespace(), getContext().getBookmarkableIdentifier())) {
        // try to extract page and component information from URL
        PageComponentInfo info = getPageComponentInfo(url);
        // load the page class
        String className = url.getSegments().get(2);
        Class<? extends IRequestablePage> pageClass = getPageClass(className);
        if (Page.class.isAssignableFrom(pageClass)) {
            // extract the PageParameters from URL if there are any
            PageParameters pageParameters = extractPageParameters(request, 3, pageParametersEncoder);
            return new UrlInfo(info, pageClass, pageParameters);
        }
    }
    return null;
}","/**
 *  @see org.apache.wicket.request.mapper.AbstractBookmarkableMapper#parseRequest(org.apache.wicket.request.Request)
 */
","@Override
protected UrlInfo parseRequest(Request request) {
    Url url = request.getUrl();
    if (url.getSegments().size() >= 3 && urlStartsWith(url, getContext().getNamespace(), getContext().getBookmarkableIdentifier())) {
                PageComponentInfo info = getPageComponentInfo(url);
                String className = url.getSegments().get(2);
        Class<? extends IRequestablePage> pageClass = getPageClass(className);
        if (Page.class.isAssignableFrom(pageClass)) {
                        PageParameters pageParameters = extractPageParameters(request, 3, pageParametersEncoder);
            return new UrlInfo(info, pageClass, pageParameters);
        }
    }
    return null;
}",0.0,0.4449760765550238,-0.2,0.0,0.4166666666666667,-0.07936507936507939,-0.07906976744186024,0.6666666666666666,-0.02631578947368421,0.031039112970614836
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2047_a0a495f0,0,"private PrivilegeBits resolvePrivilegeBits(NodeBuilder privileges, String name) {
    NodeBuilder def = privileges.getChildNode(name);
    PropertyState b = def.getProperty(REP_BITS);
    if (b != null) {
        return PrivilegeBits.getInstance(b);
    }
    PrivilegeBits bits = PrivilegeBits.getInstance();
    for (String n : def.getNames(REP_AGGREGATES)) {
        bits.add(resolvePrivilegeBits(privileges, n));
    }
    def.setProperty(bits.asPropertyState(REP_BITS));
    return bits;
}",,"private PrivilegeBits resolvePrivilegeBits(NodeBuilder privileges, String name) {
    NodeBuilder def = privileges.getChildNode(name);
    PropertyState b = def.getProperty(REP_BITS);
    if (b != null) {
        return PrivilegeBits.getInstance(b);
    }
    PrivilegeBits bits = PrivilegeBits.getInstance();
    for (String n : def.getNames(REP_AGGREGATES)) {
        bits.add(resolvePrivilegeBits(privileges, n));
    }
    def.setProperty(bits.asPropertyState(REP_BITS));
    return bits;
}",-0.045454545454545456,-0.368421052631579,-0.2,-0.5,-0.25,0.013888888888888857,0.0023960535588444802,0.25,0.02631578947368421,0.022837318395832234
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-177_f91ce934,1,"/**
 * Set the header to write when the stream is opened.
 * @param header The header.
 */
public synchronized void setHeader(final byte[] header) {
    if (header != null) {
        try {
            this.os.write(header, 0, header.length);
        } catch (final IOException ioe) {
            LOGGER.error(""Unable to write header"", ioe);
        }
    }
}","/**
 * Set the header to write when the stream is opened.
 * @param header The header.
 */
","public synchronized void setHeader(final byte[] header) {
    if (header != null) {
        try {
            this.os.write(header, 0, header.length);
        } catch (final IOException ioe) {
            LOGGER.error(""Unable to write header"", ioe);
        }
    }
}",-0.22727272727272727,0.6076555023923443,-0.2,0.0,-0.25,-0.3650793650793651,0.33502466525722346,-0.3333333333333333,0.13157894736842105,-0.16279340490885932
wicket,remotes/origin/bugs-dot-jar_WICKET-4757_fd910746,1,"@Override
public void component(final FormComponent<?> formComponent, final IVisit<Void> visit) {
    Form<?> form = formComponent.getForm();
    if (!form.isVisibleInHierarchy() || !form.isEnabledInHierarchy()) {
        // do not validate formComponent or any of formComponent's children
        visit.dontGoDeeper();
        return;
    }
    if (formComponent.isVisibleInHierarchy() && formComponent.isValid() && formComponent.isEnabledInHierarchy()) {
        validate(formComponent);
    }
    if (formComponent.processChildren() == false) {
        visit.dontGoDeeper();
    }
}",,"@Override
public void component(final FormComponent<?> formComponent, final IVisit<Void> visit) {
    Form<?> form = formComponent.getForm();
    if (!form.isVisibleInHierarchy() || !form.isEnabledInHierarchy()) {
                visit.dontGoDeeper();
        return;
    }
    if (formComponent.isVisibleInHierarchy() && formComponent.isValid() && formComponent.isEnabledInHierarchy()) {
        validate(formComponent);
    }
    if (formComponent.processChildren() == false) {
        visit.dontGoDeeper();
    }
}",0.0,-0.08612440191387569,0.0,-0.5,0.5833333333333334,0.31746031746031744,-0.004087385482734207,0.3333333333333333,-0.02631578947368421,0.10299268684842929
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-4423_08f0b280,3,"@Override
public Boolean call() {
    long now = System.currentTimeMillis();
    refreshHead();
    SegmentNodeState state = head.get();
    SegmentNodeBuilder builder = state.builder();
    NodeBuilder checkpoints = builder.child(""checkpoints"");
    for (String n : checkpoints.getChildNodeNames()) {
        NodeBuilder cp = checkpoints.getChildNode(n);
        PropertyState ts = cp.getProperty(""timestamp"");
        if (ts == null || ts.getType() != LONG || now > ts.getValue(LONG)) {
            cp.remove();
        }
    }
    NodeBuilder cp = checkpoints.child(name);
    cp.setProperty(""timestamp"", now + lifetime);
    cp.setProperty(""created"", now);
    NodeBuilder props = cp.setChildNode(""properties"");
    for (Entry<String, String> p : properties.entrySet()) {
        props.setProperty(p.getKey(), p.getValue());
    }
    cp.setChildNode(ROOT, state.getChildNode(ROOT));
    SegmentNodeState newState = builder.getNodeState();
    if (revisions.setHead(state.getRecordId(), newState.getRecordId())) {
        refreshHead();
        return true;
    } else {
        return false;
    }
}",,"@Override
public Boolean call() {
    long now = System.currentTimeMillis();
    refreshHead();
    SegmentNodeState state = head.get();
    SegmentNodeBuilder builder = state.builder();
    NodeBuilder checkpoints = builder.child(""checkpoints"");
    for (String n : checkpoints.getChildNodeNames()) {
        NodeBuilder cp = checkpoints.getChildNode(n);
        PropertyState ts = cp.getProperty(""timestamp"");
        if (ts == null || ts.getType() != LONG || now > ts.getValue(LONG)) {
            cp.remove();
        }
    }
    NodeBuilder cp = checkpoints.child(name);
    cp.setProperty(""timestamp"", now + lifetime);
    cp.setProperty(""created"", now);
    NodeBuilder props = cp.setChildNode(""properties"");
    for (Entry<String, String> p : properties.entrySet()) {
        props.setProperty(p.getKey(), p.getValue());
    }
    cp.setChildNode(ROOT, state.getChildNode(ROOT));
    SegmentNodeState newState = builder.getNodeState();
    if (revisions.setHead(state.getRecordId(), newState.getRecordId())) {
        refreshHead();
        return true;
    } else {
        return false;
    }
}",0.7272727272727273,-0.15311004784689008,0.2,0.0,0.5,0.7777777777777778,-0.5563072586328399,1.6666666666666667,-0.02631578947368421,1.5490211672227885
Closure,89,2,"/**
 * Updates the initial assignment to a collapsible property at global scope
 * by changing it to a variable declaration (e.g. a.b = 1 -> var a$b = 1).
 * The property's value may either be a primitive or an object literal or
 * function whose properties aren't collapsible.
 *
 * @param alias The flattened property name (e.g. ""a$b"")
 * @param refName The name for the reference being updated.
 * @param ref An object containing information about the assignment getting
 *     updated
 */
private void updateSimpleDeclaration(String alias, Name refName, Ref ref) {
    Node rvalue = ref.node.getNext();
    Node parent = ref.node.getParent();
    Node gramps = parent.getParent();
    Node greatGramps = gramps.getParent();
    Node greatGreatGramps = greatGramps.getParent();
    // Create the new alias node.
    Node nameNode = NodeUtil.newName(compiler.getCodingConvention(), alias, gramps.getFirstChild(), refName.fullName());
    NodeUtil.copyNameAnnotations(ref.node.getLastChild(), nameNode);
    if (gramps.getType() == Token.EXPR_RESULT) {
        // BEFORE: a.b.c = ...;
        // exprstmt
        // assign
        // getprop
        // getprop
        // name a
        // string b
        // string c
        // NODE
        // AFTER: var a$b$c = ...;
        // var
        // name a$b$c
        // NODE
        // Remove the rvalue (NODE).
        parent.removeChild(rvalue);
        nameNode.addChildToFront(rvalue);
        Node varNode = new Node(Token.VAR, nameNode);
        greatGramps.replaceChild(gramps, varNode);
    } else {
        // This must be a complex assignment.
        Preconditions.checkNotNull(ref.getTwin());
        // BEFORE:
        // ... (x.y = 3);
        // 
        // AFTER:
        // var x$y;
        // ... (x$y = 3);
        Node current = gramps;
        Node currentParent = gramps.getParent();
        for (; currentParent.getType() != Token.SCRIPT && currentParent.getType() != Token.BLOCK; current = currentParent, currentParent = currentParent.getParent()) {
        }
        // Create a stub variable declaration right
        // before the current statement.
        Node stubVar = new Node(Token.VAR, nameNode.cloneTree()).copyInformationFrom(nameNode);
        currentParent.addChildBefore(stubVar, current);
        parent.replaceChild(ref.node, nameNode);
    }
    compiler.reportCodeChange();
}","/**
 * Updates the initial assignment to a collapsible property at global scope
 * by changing it to a variable declaration (e.g. a.b = 1 -> var a$b = 1).
 * The property's value may either be a primitive or an object literal or
 * function whose properties aren't collapsible.
 *
 * @param alias The flattened property name (e.g. ""a$b"")
 * @param refName The name for the reference being updated.
 * @param ref An object containing information about the assignment getting
 *     updated
 */
","private void updateSimpleDeclaration(String alias, Name refName, Ref ref) {
    Node rvalue = ref.node.getNext();
    Node parent = ref.node.getParent();
    Node gramps = parent.getParent();
    Node greatGramps = gramps.getParent();
    Node greatGreatGramps = greatGramps.getParent();
        Node nameNode = NodeUtil.newName(compiler.getCodingConvention(), alias, gramps.getFirstChild(), refName.fullName());
    NodeUtil.copyNameAnnotations(ref.node.getLastChild(), nameNode);
    if (gramps.getType() == Token.EXPR_RESULT) {
                                                                                                                        parent.removeChild(rvalue);
        nameNode.addChildToFront(rvalue);
        Node varNode = new Node(Token.VAR, nameNode);
        greatGramps.replaceChild(gramps, varNode);
    } else {
                Preconditions.checkNotNull(ref.getTwin());
                                                        Node current = gramps;
        Node currentParent = gramps.getParent();
        for (; currentParent.getType() != Token.SCRIPT && currentParent.getType() != Token.BLOCK; current = currentParent, currentParent = currentParent.getParent()) {
        }
                        Node stubVar = new Node(Token.VAR, nameNode.cloneTree()).copyInformationFrom(nameNode);
        currentParent.addChildBefore(stubVar, current);
        parent.replaceChild(ref.node, nameNode);
    }
    compiler.reportCodeChange();
}",0.5,-0.2200956937799045,-0.2,0.0,0.0,0.5932539682539683,-0.4754052149400984,1.6666666666666667,-0.02631578947368421,1.4320107420918262
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-579_7d72e6ed,3,"/**
 * Prepare executing the query. This method will decide which index to use.
 */
public abstract void prepare();","/**
 * Prepare executing the query. This method will decide which index to use.
 */
",public abstract void prepare();,-0.5909090909090909,-1.4306220095693782,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,1.8696264975334735,-0.5,2.6052631578947367,-0.16279340490885932
Closure,169,2,"boolean checkRecordEquivalenceHelper(RecordType otherRecord, boolean tolerateUnknowns) {
    Set<String> keySet = properties.keySet();
    Map<String, JSType> otherProps = otherRecord.properties;
    if (!otherProps.keySet().equals(keySet)) {
        return false;
    }
    for (String key : keySet) {
        if (!otherProps.get(key).checkEquivalenceHelper(properties.get(key), tolerateUnknowns)) {
            return false;
        }
    }
    return true;
}",,"boolean checkRecordEquivalenceHelper(RecordType otherRecord, boolean tolerateUnknowns) {
    Set<String> keySet = properties.keySet();
    Map<String, JSType> otherProps = otherRecord.properties;
    if (!otherProps.keySet().equals(keySet)) {
        return false;
    }
    for (String key : keySet) {
        if (!otherProps.get(key).checkEquivalenceHelper(properties.get(key), tolerateUnknowns)) {
            return false;
        }
    }
    return true;
}",-0.045454545454545456,0.10047846889952151,0.0,0.0,0.25,0.009920634920634885,0.03255813953488375,0.0,-0.02631578947368421,-0.019771442402448082
wicket,remotes/origin/bugs-dot-jar_WICKET-4511_4ee5ad1f,1,"@Override
protected final MarkupElement onComponentTag(ComponentTag tag) throws ParseException {
    // Whatever there is left in the markup, ignore it
    if (ignoreTheRest == true) {
        return tag;
    }
    // if it is <head> or </head>
    if (HEAD.equalsIgnoreCase(tag.getName())) {
        if (tag.getNamespace() == null) {
            // we found <head>
            if (tag.isClose()) {
                foundHead = true;
            } else if (tag.getId() == null) {
                tag.setId(HEADER_ID);
                tag.setAutoComponentTag(true);
                tag.setModified(true);
            }
            return tag;
        } else {
            // we found <wicket:head>
            foundHead = true;
        }
    } else if (BODY.equalsIgnoreCase(tag.getName()) && (tag.getNamespace() == null)) {
        // We found <body>
        if (foundHead == false) {
            insertHeadTag();
        }
        // <head> must always be before <body>
        ignoreTheRest = true;
        return tag;
    }
    return tag;
}",,"@Override
protected final MarkupElement onComponentTag(ComponentTag tag) throws ParseException {
        if (ignoreTheRest == true) {
        return tag;
    }
        if (HEAD.equalsIgnoreCase(tag.getName())) {
        if (tag.getNamespace() == null) {
                        if (tag.isClose()) {
                foundHead = true;
            } else if (tag.getId() == null) {
                tag.setId(HEADER_ID);
                tag.setAutoComponentTag(true);
                tag.setModified(true);
            }
            return tag;
        } else {
                        foundHead = true;
        }
    } else if (BODY.equalsIgnoreCase(tag.getName()) && (tag.getNamespace() == null)) {
                if (foundHead == false) {
            insertHeadTag();
        }
                ignoreTheRest = true;
        return tag;
    }
    return tag;
}",0.5909090909090909,0.8947368421052633,0.8,1.0,0.9166666666666666,0.047619047619047616,-0.40549682875264276,0.5,-0.02631578947368421,0.10665790702097128
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3897_94c6c575,1,"@Nonnull
RevisionVector reset(@Nonnull RevisionVector branchHead, @Nonnull RevisionVector ancestor, @Nullable DocumentNodeStoreBranch branch) {
    checkNotNull(branchHead);
    checkNotNull(ancestor);
    Branch b = getBranches().getBranch(branchHead);
    if (b == null) {
        throw new DocumentStoreException(""Empty branch cannot be reset"");
    }
    if (!b.getCommits().last().equals(branchHead.getRevision(getClusterId()))) {
        throw new DocumentStoreException(branchHead + "" is not the head "" + ""of a branch"");
    }
    if (!b.containsCommit(ancestor.getBranchRevision())) {
        throw new DocumentStoreException(ancestor + "" is not "" + ""an ancestor revision of "" + branchHead);
    }
    if (branchHead.equals(ancestor)) {
        // trivial
        return branchHead;
    }
    boolean success = false;
    Commit commit = newCommit(branchHead, branch);
    try {
        Iterator<Revision> it = b.getCommits().tailSet(ancestor.getBranchRevision()).iterator();
        // first revision is the ancestor (tailSet is inclusive)
        // do not undo changes for this revision
        it.next();
        Map<String, UpdateOp> operations = Maps.newHashMap();
        if (it.hasNext()) {
            Revision reset = it.next();
            // TODO: correct?
            getRoot(b.getCommit(reset).getBase().update(reset)).compareAgainstBaseState(getRoot(ancestor), new ResetDiff(reset.asTrunkRevision(), operations));
            UpdateOp rootOp = operations.get(""/"");
            if (rootOp == null) {
                rootOp = new UpdateOp(Utils.getIdFromPath(""/""), false);
                NodeDocument.setModified(rootOp, commit.getRevision());
                operations.put(""/"", rootOp);
            }
            NodeDocument.removeCollision(rootOp, reset.asTrunkRevision());
            NodeDocument.removeRevision(rootOp, reset.asTrunkRevision());
        }
        // update root document first
        if (store.findAndUpdate(Collection.NODES, operations.get(""/"")) != null) {
            // clean up in-memory branch data
            // first revision is the ancestor (tailSet is inclusive)
            List<Revision> revs = Lists.newArrayList(b.getCommits().tailSet(ancestor.getBranchRevision()));
            for (Revision r : revs.subList(1, revs.size())) {
                b.removeCommit(r);
            }
            // successfully updating the root document can be considered
            // as success because the changes are not marked as committed
            // anymore
            success = true;
        }
        operations.remove(""/"");
        // update remaining documents
        for (UpdateOp op : operations.values()) {
            store.findAndUpdate(Collection.NODES, op);
        }
    } finally {
        if (!success) {
            canceled(commit);
        } else {
            done(commit, true, null);
        }
    }
    return ancestor;
}",,"@Nonnull
RevisionVector reset(@Nonnull RevisionVector branchHead, @Nonnull RevisionVector ancestor, @Nullable DocumentNodeStoreBranch branch) {
    checkNotNull(branchHead);
    checkNotNull(ancestor);
    Branch b = getBranches().getBranch(branchHead);
    if (b == null) {
        throw new DocumentStoreException(""Empty branch cannot be reset"");
    }
    if (!b.getCommits().last().equals(branchHead.getRevision(getClusterId()))) {
        throw new DocumentStoreException(branchHead + "" is not the head "" + ""of a branch"");
    }
    if (!b.containsCommit(ancestor.getBranchRevision())) {
        throw new DocumentStoreException(ancestor + "" is not "" + ""an ancestor revision of "" + branchHead);
    }
    if (branchHead.equals(ancestor)) {
                return branchHead;
    }
    boolean success = false;
    Commit commit = newCommit(branchHead, branch);
    try {
        Iterator<Revision> it = b.getCommits().tailSet(ancestor.getBranchRevision()).iterator();
                        it.next();
        Map<String, UpdateOp> operations = Maps.newHashMap();
        if (it.hasNext()) {
            Revision reset = it.next();
                        getRoot(b.getCommit(reset).getBase().update(reset)).compareAgainstBaseState(getRoot(ancestor), new ResetDiff(reset.asTrunkRevision(), operations));
            UpdateOp rootOp = operations.get(""/"");
            if (rootOp == null) {
                rootOp = new UpdateOp(Utils.getIdFromPath(""/""), false);
                NodeDocument.setModified(rootOp, commit.getRevision());
                operations.put(""/"", rootOp);
            }
            NodeDocument.removeCollision(rootOp, reset.asTrunkRevision());
            NodeDocument.removeRevision(rootOp, reset.asTrunkRevision());
        }
                if (store.findAndUpdate(Collection.NODES, operations.get(""/"")) != null) {
                                    List<Revision> revs = Lists.newArrayList(b.getCommits().tailSet(ancestor.getBranchRevision()));
            for (Revision r : revs.subList(1, revs.size())) {
                b.removeCommit(r);
            }
                                                success = true;
        }
        operations.remove(""/"");
                for (UpdateOp op : operations.values()) {
            store.findAndUpdate(Collection.NODES, op);
        }
    } finally {
        if (!success) {
            canceled(commit);
        } else {
            done(commit, true, null);
        }
    }
    return ancestor;
}",1.8636363636363635,0.5502392344497605,2.0,0.5,1.3333333333333333,0.48611111111111116,-0.9884425651867509,3.75,-0.02631578947368421,2.3109120981080316
Compress,23,3,"@Override
InputStream decode(final InputStream in, final Coder coder, byte[] password) throws IOException {
    byte propsByte = coder.properties[0];
    long dictSize = coder.properties[1];
    for (int i = 1; i < 4; i++) {
        dictSize |= (coder.properties[i + 1] << (8 * i));
    }
    if (dictSize > LZMAInputStream.DICT_SIZE_MAX) {
        throw new IOException(""Dictionary larger than 4GiB maximum size"");
    }
    return new LZMAInputStream(in, -1, propsByte, (int) dictSize);
}",,"@Override
InputStream decode(final InputStream in, final Coder coder, byte[] password) throws IOException {
    byte propsByte = coder.properties[0];
    long dictSize = coder.properties[1];
    for (int i = 1; i < 4; i++) {
        dictSize |= (coder.properties[i + 1] << (8 * i));
    }
    if (dictSize > LZMAInputStream.DICT_SIZE_MAX) {
        throw new IOException(""Dictionary larger than 4GiB maximum size"");
    }
    return new LZMAInputStream(in, -1, propsByte, (int) dictSize);
}",-0.09090909090909091,-0.20574162679425848,0.0,-0.5,-0.08333333333333333,1.2222222222222223,0.008879492600422766,-0.5,0.0,0.7510036133538491
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2740_429baf4d,0,"@Override
public boolean definesContextRoot(@Nonnull Tree tree) {
    String name = tree.getName();
    return POLICY_NODE_NAMES.contains(name) || REP_PERMISSION_STORE.equals(name);
}",,"@Override
public boolean definesContextRoot(@Nonnull Tree tree) {
    String name = tree.getName();
    return POLICY_NODE_NAMES.contains(name) || REP_PERMISSION_STORE.equals(name);
}",-0.4090909090909091,-0.49282296650717716,-0.6,-1.0,-0.4166666666666667,-0.12103174603174605,0.6126849894291753,-0.25,1.1052631578947367,-0.12289091359646846
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-366_db4a291f,1,"@Override
public void flush(TInfo tinfo, AuthInfo credentials, String lock, String tableId, ByteBuffer startRow, ByteBuffer endRow) {
    try {
        checkPermission(credentials, lock, true, ""flush"");
    } catch (ThriftSecurityException e) {
        log.error(e, e);
        throw new RuntimeException(e);
    }
    ArrayList<Tablet> tabletsToFlush = new ArrayList<Tablet>();
    KeyExtent ke = new KeyExtent(new Text(tableId), ByteBufferUtil.toText(endRow), ByteBufferUtil.toText(startRow));
    synchronized (onlineTablets) {
        for (Tablet tablet : onlineTablets.values()) if (ke.overlaps(tablet.getExtent()))
            tabletsToFlush.add(tablet);
    }
    Long flushID = null;
    for (Tablet tablet : tabletsToFlush) {
        if (flushID == null) {
            // read the flush id once from zookeeper instead of reading
            // it for each tablet
            flushID = tablet.getFlushID();
        }
        tablet.flush(flushID);
    }
}",,"@Override
public void flush(TInfo tinfo, AuthInfo credentials, String lock, String tableId, ByteBuffer startRow, ByteBuffer endRow) {
    try {
        checkPermission(credentials, lock, true, ""flush"");
    } catch (ThriftSecurityException e) {
        log.error(e, e);
        throw new RuntimeException(e);
    }
    ArrayList<Tablet> tabletsToFlush = new ArrayList<Tablet>();
    KeyExtent ke = new KeyExtent(new Text(tableId), ByteBufferUtil.toText(endRow), ByteBufferUtil.toText(startRow));
    synchronized (onlineTablets) {
        for (Tablet tablet : onlineTablets.values()) if (ke.overlaps(tablet.getExtent()))
            tabletsToFlush.add(tablet);
    }
    Long flushID = null;
    for (Tablet tablet : tabletsToFlush) {
        if (flushID == null) {
                                    flushID = tablet.getFlushID();
        }
        tablet.flush(flushID);
    }
}",0.36363636363636365,0.1531100478468899,0.6,0.0,0.0,0.0,-0.3572938689217757,0.3333333333333333,-0.02631578947368421,0.1761910524829561
flink,remotes/origin/bugs-dot-jar_FLINK-1978_0078c44e,1,"@Override
@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
public T deserialize(T reuse, DataInputView source) throws IOException {
    // handle null values
    int flags = source.readByte();
    if ((flags & IS_NULL) != 0) {
        return null;
    }
    Class<?> subclass = null;
    TypeSerializer subclassSerializer = null;
    if ((flags & IS_SUBCLASS) != 0) {
        String subclassName = source.readUTF();
        try {
            subclass = Class.forName(subclassName, true, cl);
        } catch (ClassNotFoundException e) {
            throw new RuntimeException(""Cannot instantiate class."", e);
        }
        subclassSerializer = getSubclassSerializer(subclass);
        if (reuse == null || subclass != reuse.getClass()) {
            // cannot reuse
            reuse = (T) subclassSerializer.createInstance();
            // also initialize fields for which the subclass serializer is not responsible
            initializeFields(reuse);
        }
    } else if ((flags & IS_TAGGED_SUBCLASS) != 0) {
        int subclassTag = source.readByte();
        subclassSerializer = registeredSerializers[subclassTag];
        if (reuse == null || ((PojoSerializer) subclassSerializer).clazz != reuse.getClass()) {
            // cannot reuse
            reuse = (T) subclassSerializer.createInstance();
            // also initialize fields for which the subclass serializer is not responsible
            initializeFields(reuse);
        }
    } else {
        if (reuse == null || clazz != reuse.getClass()) {
            reuse = createInstance();
        }
    }
    if ((flags & NO_SUBCLASS) != 0) {
        try {
            for (int i = 0; i < numFields; i++) {
                boolean isNull = source.readBoolean();
                if (isNull) {
                    fields[i].set(reuse, null);
                } else {
                    Object field = fieldSerializers[i].deserialize(fields[i].get(reuse), source);
                    fields[i].set(reuse, field);
                }
            }
        } catch (IllegalAccessException e) {
            throw new RuntimeException(""Error during POJO copy, this should not happen since we check the fields before."");
        }
    } else {
        if (subclassSerializer != null) {
            reuse = (T) subclassSerializer.deserialize(reuse, source);
        }
    }
    return reuse;
}",,"@Override
@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
public T deserialize(T reuse, DataInputView source) throws IOException {
        int flags = source.readByte();
    if ((flags & IS_NULL) != 0) {
        return null;
    }
    Class<?> subclass = null;
    TypeSerializer subclassSerializer = null;
    if ((flags & IS_SUBCLASS) != 0) {
        String subclassName = source.readUTF();
        try {
            subclass = Class.forName(subclassName, true, cl);
        } catch (ClassNotFoundException e) {
            throw new RuntimeException(""Cannot instantiate class."", e);
        }
        subclassSerializer = getSubclassSerializer(subclass);
        if (reuse == null || subclass != reuse.getClass()) {
                        reuse = (T) subclassSerializer.createInstance();
                        initializeFields(reuse);
        }
    } else if ((flags & IS_TAGGED_SUBCLASS) != 0) {
        int subclassTag = source.readByte();
        subclassSerializer = registeredSerializers[subclassTag];
        if (reuse == null || ((PojoSerializer) subclassSerializer).clazz != reuse.getClass()) {
                        reuse = (T) subclassSerializer.createInstance();
                        initializeFields(reuse);
        }
    } else {
        if (reuse == null || clazz != reuse.getClass()) {
            reuse = createInstance();
        }
    }
    if ((flags & NO_SUBCLASS) != 0) {
        try {
            for (int i = 0; i < numFields; i++) {
                boolean isNull = source.readBoolean();
                if (isNull) {
                    fields[i].set(reuse, null);
                } else {
                    Object field = fieldSerializers[i].deserialize(fields[i].get(reuse), source);
                    fields[i].set(reuse, field);
                }
            }
        } catch (IllegalAccessException e) {
            throw new RuntimeException(""Error during POJO copy, this should not happen since we check the fields before."");
        }
    } else {
        if (subclassSerializer != null) {
            reuse = (T) subclassSerializer.deserialize(reuse, source);
        }
    }
    return reuse;
}",1.8181818181818181,0.9282296650717702,2.2,1.0,1.5,1.1071428571428572,-0.9509513742071879,1.0833333333333333,-0.02631578947368421,3.1893063167418725
wicket,remotes/origin/bugs-dot-jar_WICKET-5398_19e7c1cd,3,"/**
 *  Reads and parses markup from an input stream
 *
 *  @param inputStream
 *             The input stream to read and parse
 *  @param encoding
 *             The default character encoding of the input
 *  @throws IOException
 */
@Override
public void parse(final InputStream inputStream, final String encoding) throws IOException {
    Args.notNull(inputStream, ""inputStream"");
    try {
        xmlReader = new XmlReader(new BufferedInputStream(inputStream, 4000), encoding);
        input = new FullyBufferedReader(xmlReader);
    } finally {
        IOUtils.closeQuietly(inputStream);
        IOUtils.closeQuietly(xmlReader);
    }
}","/**
 *  Reads and parses markup from an input stream
 *
 *  @param inputStream
 *             The input stream to read and parse
 *  @param encoding
 *             The default character encoding of the input
 *  @throws IOException
 */
","@Override
public void parse(final InputStream inputStream, final String encoding) throws IOException {
    Args.notNull(inputStream, ""inputStream"");
    try {
        xmlReader = new XmlReader(new BufferedInputStream(inputStream, 4000), encoding);
        input = new FullyBufferedReader(xmlReader);
    } finally {
        IOUtils.closeQuietly(inputStream);
        IOUtils.closeQuietly(xmlReader);
    }
}",-0.13636363636363635,0.08612440191387546,-0.6,-0.5,-0.4166666666666667,-0.3650793650793651,0.1704016913319239,-0.25,1.6842105263157894,-0.16279340490885932
camel,remotes/origin/bugs-dot-jar_CAMEL-8227_54d7fc59,3,"public boolean process(Exchange exchange, final AsyncCallback callback) {
    if (!isStarted()) {
        exchange.setException(new IllegalStateException(""SendProcessor has not been started: "" + this));
        callback.done(true);
        return true;
    }
    // we should preserve existing MEP so remember old MEP
    // if you want to permanently to change the MEP then use .setExchangePattern in the DSL
    final ExchangePattern existingPattern = exchange.getPattern();
    // if we have a producer then use that as its optimized
    if (producer != null) {
        // record timing for sending the exchange using the producer
        final StopWatch watch = new StopWatch();
        final Exchange target = configureExchange(exchange, pattern);
        EventHelper.notifyExchangeSending(exchange.getContext(), target, destination);
        LOG.debug("">>>> {} {}"", destination, exchange);
        boolean sync = true;
        try {
            sync = producer.process(exchange, new AsyncCallback() {

                @Override
                public void done(boolean doneSync) {
                    try {
                        // restore previous MEP
                        target.setPattern(existingPattern);
                        // emit event that the exchange was sent to the endpoint
                        long timeTaken = watch.stop();
                        EventHelper.notifyExchangeSent(target.getContext(), target, destination, timeTaken);
                    } finally {
                        checkException(target);
                        callback.done(doneSync);
                    }
                }
            });
        } catch (Throwable throwable) {
            if (exchange != null) {
                exchange.setException(throwable);
                checkException(exchange);
            }
        }
        return sync;
    }
    // send the exchange to the destination using the producer cache for the non optimized producers
    return producerCache.doInAsyncProducer(destination, exchange, pattern, callback, new AsyncProducerCallback() {

        public boolean doInAsyncProducer(Producer producer, AsyncProcessor asyncProducer, final Exchange exchange, ExchangePattern pattern, final AsyncCallback callback) {
            final Exchange target = configureExchange(exchange, pattern);
            LOG.debug("">>>> {} {}"", destination, exchange);
            return asyncProducer.process(target, new AsyncCallback() {

                public void done(boolean doneSync) {
                    // restore previous MEP
                    target.setPattern(existingPattern);
                    checkException(target);
                    // signal we are done
                    callback.done(doneSync);
                }
            });
        }
    });
}",,"public boolean process(Exchange exchange, final AsyncCallback callback) {
    if (!isStarted()) {
        exchange.setException(new IllegalStateException(""SendProcessor has not been started: "" + this));
        callback.done(true);
        return true;
    }
            final ExchangePattern existingPattern = exchange.getPattern();
        if (producer != null) {
                final StopWatch watch = new StopWatch();
        final Exchange target = configureExchange(exchange, pattern);
        EventHelper.notifyExchangeSending(exchange.getContext(), target, destination);
        LOG.debug("">>>> {} {}"", destination, exchange);
        boolean sync = true;
        try {
            sync = producer.process(exchange, new AsyncCallback() {

                @Override
                public void done(boolean doneSync) {
                    try {
                                                target.setPattern(existingPattern);
                                                long timeTaken = watch.stop();
                        EventHelper.notifyExchangeSent(target.getContext(), target, destination, timeTaken);
                    } finally {
                        checkException(target);
                        callback.done(doneSync);
                    }
                }
            });
        } catch (Throwable throwable) {
            if (exchange != null) {
                exchange.setException(throwable);
                checkException(exchange);
            }
        }
        return sync;
    }
        return producerCache.doInAsyncProducer(destination, exchange, pattern, callback, new AsyncProducerCallback() {

        public boolean doInAsyncProducer(Producer producer, AsyncProcessor asyncProducer, final Exchange exchange, ExchangePattern pattern, final AsyncCallback callback) {
            final Exchange target = configureExchange(exchange, pattern);
            LOG.debug("">>>> {} {}"", destination, exchange);
            return asyncProducer.process(target, new AsyncCallback() {

                public void done(boolean doneSync) {
                                        target.setPattern(existingPattern);
                    checkException(target);
                                        callback.done(doneSync);
                }
            });
        }
    });
}",1.5909090909090908,1.7559808612440193,0.2,1.0,0.08333333333333333,0.6924603174603174,-0.7995771670190271,1.5,-0.02631578947368421,1.6457553177388584
Closure,148,2,"/**
 * Write any needed entries from the current position to the end of the
 * provided mapping.
 */
private void writeClosedMapping(Mapping m) throws IOException {
    int nextLine = getAdjustedLine(m.endPosition);
    int nextCol = getAdjustedCol(m.endPosition);
    // current line and column position, write it out now.
    if (line < nextLine || (line == nextLine && col < nextCol)) {
        writeCharsUpTo(nextLine, nextCol, m.id);
    }
}","/**
 * Write any needed entries from the current position to the end of the
 * provided mapping.
 */
","private void writeClosedMapping(Mapping m) throws IOException {
    int nextLine = getAdjustedLine(m.endPosition);
    int nextCol = getAdjustedCol(m.endPosition);
        if (line < nextLine || (line == nextLine && col < nextCol)) {
        writeCharsUpTo(nextLine, nextCol, m.id);
    }
}",-0.3181818181818182,-0.20574162679425848,-0.4,-0.5,0.16666666666666666,0.31547619047619047,0.36067653276955597,-0.25,1.8421052631578947,0.04535882851264673
Collections,26,1,"/**
 * Recalculate the hash code after deserialization. The hash code of some
 * keys might have change (hash codes based on the system hash code are
 * only stable for the same process).
 * @return the instance with recalculated hash code
 */
private Object readResolve() {
    calculateHashCode(keys);
    return this;
}","/**
 * Recalculate the hash code after deserialization. The hash code of some
 * keys might have change (hash codes based on the system hash code are
 * only stable for the same process).
 * @return the instance with recalculated hash code
 */
","private Object readResolve() {
    calculateHashCode(keys);
    return this;
}",-0.45454545454545453,-0.47368421052631593,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.9785764622973924,-0.4166666666666667,2.5,-0.16279340490885932
camel,remotes/origin/bugs-dot-jar_CAMEL-5261_55c2e2d8,1,"@Override
protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {
    int consumers = getAndRemoveParameter(parameters, ""concurrentConsumers"", Integer.class, defaultConcurrentConsumers);
    boolean limitConcurrentConsumers = getAndRemoveParameter(parameters, ""limitConcurrentConsumers"", Boolean.class, true);
    if (limitConcurrentConsumers && consumers > maxConcurrentConsumers) {
        throw new IllegalArgumentException(""The limitConcurrentConsumers flag in set to true. ConcurrentConsumers cannot be set at a value greater than "" + maxConcurrentConsumers + "" was "" + consumers);
    }
    SedaEndpoint answer = new SedaEndpoint(uri, this, createQueue(uri, parameters), consumers);
    answer.configureProperties(parameters);
    return answer;
}",,"@Override
protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {
    int consumers = getAndRemoveParameter(parameters, ""concurrentConsumers"", Integer.class, defaultConcurrentConsumers);
    boolean limitConcurrentConsumers = getAndRemoveParameter(parameters, ""limitConcurrentConsumers"", Boolean.class, true);
    if (limitConcurrentConsumers && consumers > maxConcurrentConsumers) {
        throw new IllegalArgumentException(""The limitConcurrentConsumers flag in set to true. ConcurrentConsumers cannot be set at a value greater than "" + maxConcurrentConsumers + "" was "" + consumers);
    }
    SedaEndpoint answer = new SedaEndpoint(uri, this, createQueue(uri, parameters), consumers);
    answer.configureProperties(parameters);
    return answer;
}",-0.13636363636363635,-0.3301435406698567,-0.2,-0.5,0.0,0.29563492063492064,0.05229034531360123,-0.16666666666666666,-0.02631578947368421,0.22549402672844518
wicket,remotes/origin/bugs-dot-jar_WICKET-5853_b80f6640,3,"/**
 *  @param locale
 *  @return Returns the numberFormat.
 */
@Override
public NumberFormat getNumberFormat(final Locale locale) {
    NumberFormat numberFormat = numberFormats.get(locale);
    if (numberFormat == null) {
        numberFormat = newNumberFormat(locale);
        setNumberFormat(locale, numberFormat);
    }
    return (NumberFormat) numberFormat.clone();
}","/**
 *  @param locale
 *  @return Returns the numberFormat.
 */
","@Override
public NumberFormat getNumberFormat(final Locale locale) {
    NumberFormat numberFormat = numberFormats.get(locale);
    if (numberFormat == null) {
        numberFormat = newNumberFormat(locale);
        setNumberFormat(locale, numberFormat);
    }
    return (NumberFormat) numberFormat.clone();
}",-0.22727272727272727,-0.01913875598086126,-0.4,-0.5,-0.25,-0.029761904761904788,0.2896405919661735,-0.16666666666666666,1.4999999999999998,-0.08658909769886412
wicket,remotes/origin/bugs-dot-jar_WICKET-5147_184e51e9,1,"/**
 *  @see javax.servlet.Filter#destroy()
 */
@Override
public void destroy() {
    if (application != null) {
        try {
            ThreadContext.setApplication(application);
            application.internalDestroy();
        } finally {
            ThreadContext.detach();
            application = null;
        }
    }
    if (applicationFactory != null) {
        applicationFactory.destroy(this);
    }
}","/**
 *  @see javax.servlet.Filter#destroy()
 */
","@Override
public void destroy() {
    if (application != null) {
        try {
            ThreadContext.setApplication(application);
            application.internalDestroy();
        } finally {
            ThreadContext.detach();
            application = null;
        }
    }
    if (applicationFactory != null) {
        applicationFactory.destroy(this);
    }
}",0.045454545454545456,0.6411483253588517,-0.2,0.0,-0.08333333333333333,-0.007936507936507943,0.08809020436927412,-0.16666666666666666,1.1842105263157894,-0.10031868974141755
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1877_716e1237,0,"private static CommitHook newCommitHook(final String name, final String checkpoint) {
    return new CompositeHook(new ConflictHook(new AnnotatingConflictHandler()), new EditorHook(new ConflictValidatorProvider()), new CommitHook() {

        @Override
        @Nonnull
        public NodeState processCommit(NodeState before, NodeState after, CommitInfo info) throws CommitFailedException {
            // check for concurrent updates by this async task
            String checkpointAfterRebase = before.getChildNode(ASYNC).getString(name);
            if (Objects.equal(checkpoint, checkpointAfterRebase)) {
                return postAsyncRunNodeStatus(after.builder(), name).getNodeState();
            } else {
                throw CONCURRENT_UPDATE;
            }
        }
    });
}",,"private static CommitHook newCommitHook(final String name, final String checkpoint) {
    return new CompositeHook(new ConflictHook(new AnnotatingConflictHandler()), new EditorHook(new ConflictValidatorProvider()), new CommitHook() {

        @Override
        @Nonnull
        public NodeState processCommit(NodeState before, NodeState after, CommitInfo info) throws CommitFailedException {
                        String checkpointAfterRebase = before.getChildNode(ASYNC).getString(name);
            if (Objects.equal(checkpoint, checkpointAfterRebase)) {
                return postAsyncRunNodeStatus(after.builder(), name).getNodeState();
            } else {
                throw CONCURRENT_UPDATE;
            }
        }
    });
}",0.0,0.9521531100478471,-0.2,0.0,-0.08333333333333333,-0.3650793650793651,-0.029457364341085313,0.0,-0.02631578947368421,-0.16279340490885932
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-499_61381ea2,3,"private StaticOperandImpl parseStaticOperand() throws ParseException {
    if (currentTokenType == PLUS) {
        read();
    } else if (currentTokenType == MINUS) {
        read();
        if (currentTokenType != VALUE) {
            throw getSyntaxError(""number"");
        }
        int valueType = currentValue.getType().tag();
        switch(valueType) {
            case PropertyType.LONG:
                currentValue = PropertyValues.newLong(-currentValue.getValue(Type.LONG));
                break;
            case PropertyType.DOUBLE:
                currentValue = PropertyValues.newDouble(-currentValue.getValue(Type.DOUBLE));
                break;
            case PropertyType.BOOLEAN:
                currentValue = PropertyValues.newBoolean(!currentValue.getValue(Type.BOOLEAN));
                break;
            case PropertyType.DECIMAL:
                currentValue = PropertyValues.newDecimal(currentValue.getValue(Type.DECIMAL).negate());
                break;
            default:
                throw getSyntaxError(""Illegal operation: -"" + currentValue);
        }
    }
    if (currentTokenType == VALUE) {
        LiteralImpl literal = getUncastLiteral(currentValue);
        read();
        return literal;
    } else if (currentTokenType == PARAMETER) {
        read();
        String name = readName();
        if (readIf("":"")) {
            name = name + ':' + readName();
        }
        BindVariableValueImpl var = bindVariables.get(name);
        if (var == null) {
            var = factory.bindVariable(name);
            bindVariables.put(name, var);
        }
        return var;
    } else if (readIf(""TRUE"")) {
        LiteralImpl literal = getUncastLiteral(PropertyValues.newBoolean(true));
        return literal;
    } else if (readIf(""FALSE"")) {
        LiteralImpl literal = getUncastLiteral(PropertyValues.newBoolean(false));
        return literal;
    } else if (readIf(""CAST"")) {
        read(""("");
        StaticOperandImpl op = parseStaticOperand();
        if (!(op instanceof LiteralImpl)) {
            throw getSyntaxError(""literal"");
        }
        LiteralImpl literal = (LiteralImpl) op;
        PropertyValue value = literal.getLiteralValue();
        read(""AS"");
        value = parseCastAs(value);
        read("")"");
        // CastLiteral
        literal = factory.literal(value);
        return literal;
    } else {
        if (supportSQL1) {
            if (readIf(""TIMESTAMP"")) {
                StaticOperandImpl op = parseStaticOperand();
                if (!(op instanceof LiteralImpl)) {
                    throw getSyntaxError(""literal"");
                }
                LiteralImpl literal = (LiteralImpl) op;
                PropertyValue value = literal.getLiteralValue();
                value = PropertyValues.newDate(value.getValue(Type.STRING));
                literal = factory.literal(value);
                return literal;
            }
        }
        throw getSyntaxError(""static operand"");
    }
}",,"private StaticOperandImpl parseStaticOperand() throws ParseException {
    if (currentTokenType == PLUS) {
        read();
    } else if (currentTokenType == MINUS) {
        read();
        if (currentTokenType != VALUE) {
            throw getSyntaxError(""number"");
        }
        int valueType = currentValue.getType().tag();
        switch(valueType) {
            case PropertyType.LONG:
                currentValue = PropertyValues.newLong(-currentValue.getValue(Type.LONG));
                break;
            case PropertyType.DOUBLE:
                currentValue = PropertyValues.newDouble(-currentValue.getValue(Type.DOUBLE));
                break;
            case PropertyType.BOOLEAN:
                currentValue = PropertyValues.newBoolean(!currentValue.getValue(Type.BOOLEAN));
                break;
            case PropertyType.DECIMAL:
                currentValue = PropertyValues.newDecimal(currentValue.getValue(Type.DECIMAL).negate());
                break;
            default:
                throw getSyntaxError(""Illegal operation: -"" + currentValue);
        }
    }
    if (currentTokenType == VALUE) {
        LiteralImpl literal = getUncastLiteral(currentValue);
        read();
        return literal;
    } else if (currentTokenType == PARAMETER) {
        read();
        String name = readName();
        if (readIf("":"")) {
            name = name + ':' + readName();
        }
        BindVariableValueImpl var = bindVariables.get(name);
        if (var == null) {
            var = factory.bindVariable(name);
            bindVariables.put(name, var);
        }
        return var;
    } else if (readIf(""TRUE"")) {
        LiteralImpl literal = getUncastLiteral(PropertyValues.newBoolean(true));
        return literal;
    } else if (readIf(""FALSE"")) {
        LiteralImpl literal = getUncastLiteral(PropertyValues.newBoolean(false));
        return literal;
    } else if (readIf(""CAST"")) {
        read(""("");
        StaticOperandImpl op = parseStaticOperand();
        if (!(op instanceof LiteralImpl)) {
            throw getSyntaxError(""literal"");
        }
        LiteralImpl literal = (LiteralImpl) op;
        PropertyValue value = literal.getLiteralValue();
        read(""AS"");
        value = parseCastAs(value);
        read("")"");
                literal = factory.literal(value);
        return literal;
    } else {
        if (supportSQL1) {
            if (readIf(""TIMESTAMP"")) {
                StaticOperandImpl op = parseStaticOperand();
                if (!(op instanceof LiteralImpl)) {
                    throw getSyntaxError(""literal"");
                }
                LiteralImpl literal = (LiteralImpl) op;
                PropertyValue value = literal.getLiteralValue();
                value = PropertyValues.newDate(value.getValue(Type.STRING));
                literal = factory.literal(value);
                return literal;
            }
        }
        throw getSyntaxError(""static operand"");
    }
}",2.909090909090909,0.6411483253588517,5.0,3.0,1.9166666666666667,1.2718253968253967,-1.250317124735729,3.4166666666666665,-0.02631578947368421,4.7562317387320405
Lang,28,3,"/**
 * {@inheritDoc}
 */
@Override
public int translate(CharSequence input, int index, Writer out) throws IOException {
    // TODO: Protect from ArrayIndexOutOfBounds
    if (input.charAt(index) == '&' && input.charAt(index + 1) == '#') {
        int start = index + 2;
        boolean isHex = false;
        char firstChar = input.charAt(start);
        if (firstChar == 'x' || firstChar == 'X') {
            start++;
            isHex = true;
        }
        int end = start;
        while (input.charAt(end) != ';') {
            end++;
        }
        int entityValue;
        try {
            if (isHex) {
                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);
            } else {
                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);
            }
        } catch (NumberFormatException nfe) {
            return 0;
        }
        out.write(entityValue);
        return 2 + (end - start) + (isHex ? 1 : 0) + 1;
    }
    return 0;
}","/**
 * {@inheritDoc}
 */
","@Override
public int translate(CharSequence input, int index, Writer out) throws IOException {
        if (input.charAt(index) == '&' && input.charAt(index + 1) == '#') {
        int start = index + 2;
        boolean isHex = false;
        char firstChar = input.charAt(start);
        if (firstChar == 'x' || firstChar == 'X') {
            start++;
            isHex = true;
        }
        int end = start;
        while (input.charAt(end) != ';') {
            end++;
        }
        int entityValue;
        try {
            if (isHex) {
                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);
            } else {
                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);
            }
        } catch (NumberFormatException nfe) {
            return 0;
        }
        out.write(entityValue);
        return 2 + (end - start) + (isHex ? 1 : 0) + 1;
    }
    return 0;
}",0.6818181818181818,0.5119617224880381,0.6,0.5,0.75,1.3849206349206349,-0.5199436222692033,0.4166666666666667,0.0,1.9210940336439544
commons-math,remotes/origin/bugs-dot-jar_MATH-949_f83bbc1d,1,"/**
 * {@inheritDoc}
 */
@Override
public PointVectorValuePair doOptimize() {
    checkParameters();
    final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker();
    // Computation will be useless without a checker (see ""for-loop"").
    if (checker == null) {
        throw new NullArgumentException();
    }
    final double[] targetValues = getTarget();
    // Number of observed data.
    final int nR = targetValues.length;
    final RealMatrix weightMatrix = getWeight();
    // Diagonal of the weight matrix.
    final double[] residualsWeights = new double[nR];
    for (int i = 0; i < nR; i++) {
        residualsWeights[i] = weightMatrix.getEntry(i, i);
    }
    final double[] currentPoint = getStartPoint();
    final int nC = currentPoint.length;
    // iterate until convergence is reached
    PointVectorValuePair current = null;
    int iter = 0;
    for (boolean converged = false; !converged; ) {
        ++iter;
        // evaluate the objective function and its jacobian
        PointVectorValuePair previous = current;
        // Value of the objective function at ""currentPoint"".
        final double[] currentObjective = computeObjectiveValue(currentPoint);
        final double[] currentResiduals = computeResiduals(currentObjective);
        final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);
        current = new PointVectorValuePair(currentPoint, currentObjective);
        // build the linear problem
        final double[] b = new double[nC];
        final double[][] a = new double[nC][nC];
        for (int i = 0; i < nR; ++i) {
            final double[] grad = weightedJacobian.getRow(i);
            final double weight = residualsWeights[i];
            final double residual = currentResiduals[i];
            // compute the normal equation
            final double wr = weight * residual;
            for (int j = 0; j < nC; ++j) {
                b[j] += wr * grad[j];
            }
            // build the contribution matrix for measurement i
            for (int k = 0; k < nC; ++k) {
                double[] ak = a[k];
                double wgk = weight * grad[k];
                for (int l = 0; l < nC; ++l) {
                    ak[l] += wgk * grad[l];
                }
            }
        }
        try {
            // solve the linearized least squares problem
            RealMatrix mA = new BlockRealMatrix(a);
            DecompositionSolver solver = useLU ? new LUDecomposition(mA).getSolver() : new QRDecomposition(mA).getSolver();
            final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();
            // update the estimated parameters
            for (int i = 0; i < nC; ++i) {
                currentPoint[i] += dX[i];
            }
        } catch (SingularMatrixException e) {
            throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);
        }
        // Check convergence.
        if (previous != null) {
            converged = checker.converged(iter, previous, current);
            if (converged) {
                setCost(computeCost(currentResiduals));
                return current;
            }
        }
    }
    // Must never happen.
    throw new MathInternalError();
}","/**
 * {@inheritDoc}
 */
","@Override
public PointVectorValuePair doOptimize() {
    checkParameters();
    final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker();
        if (checker == null) {
        throw new NullArgumentException();
    }
    final double[] targetValues = getTarget();
        final int nR = targetValues.length;
    final RealMatrix weightMatrix = getWeight();
        final double[] residualsWeights = new double[nR];
    for (int i = 0; i < nR; i++) {
        residualsWeights[i] = weightMatrix.getEntry(i, i);
    }
    final double[] currentPoint = getStartPoint();
    final int nC = currentPoint.length;
        PointVectorValuePair current = null;
    int iter = 0;
    for (boolean converged = false; !converged; ) {
        ++iter;
                PointVectorValuePair previous = current;
                final double[] currentObjective = computeObjectiveValue(currentPoint);
        final double[] currentResiduals = computeResiduals(currentObjective);
        final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);
        current = new PointVectorValuePair(currentPoint, currentObjective);
                final double[] b = new double[nC];
        final double[][] a = new double[nC][nC];
        for (int i = 0; i < nR; ++i) {
            final double[] grad = weightedJacobian.getRow(i);
            final double weight = residualsWeights[i];
            final double residual = currentResiduals[i];
                        final double wr = weight * residual;
            for (int j = 0; j < nC; ++j) {
                b[j] += wr * grad[j];
            }
                        for (int k = 0; k < nC; ++k) {
                double[] ak = a[k];
                double wgk = weight * grad[k];
                for (int l = 0; l < nC; ++l) {
                    ak[l] += wgk * grad[l];
                }
            }
        }
        try {
                        RealMatrix mA = new BlockRealMatrix(a);
            DecompositionSolver solver = useLU ? new LUDecomposition(mA).getSolver() : new QRDecomposition(mA).getSolver();
            final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();
                        for (int i = 0; i < nC; ++i) {
                currentPoint[i] += dX[i];
            }
        } catch (SingularMatrixException e) {
            throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);
        }
                if (previous != null) {
            converged = checker.converged(iter, previous, current);
            if (converged) {
                setCost(computeCost(currentResiduals));
                return current;
            }
        }
    }
        throw new MathInternalError();
}",2.227272727272727,0.7846889952153109,2.4,1.0,1.3333333333333333,1.6130952380952381,-1.0794926004228327,0.9166666666666666,-0.02631578947368421,6.250604242665236
JxPath,9,1,"public Object computeValue(EvalContext context) {
    return equal(context, args[0], args[1]) ? Boolean.FALSE : Boolean.TRUE;
}",,"public Object computeValue(EvalContext context) {
    return equal(context, args[0], args[1]) ? Boolean.FALSE : Boolean.TRUE;
}",-0.5,-0.5263157894736844,-0.4,-1.0,-0.16666666666666666,-0.3650793650793651,0.8787878787878789,-0.4166666666666667,0.0,-0.16279340490885932
wicket,remotes/origin/bugs-dot-jar_WICKET-5770_cf6172bd,1,"@Override
public PageParameters decodePageParameters(final Url url) {
    PageParameters parameters = new PageParameters();
    int i = 0;
    for (String s : url.getSegments()) {
        parameters.set(i, s);
        ++i;
    }
    for (QueryParameter p : url.getQueryParameters()) {
        parameters.add(p.getName(), p.getValue(), INamedParameters.Type.QUERY_STRING);
    }
    return parameters.isEmpty() ? null : parameters;
}",,"@Override
public PageParameters decodePageParameters(final Url url) {
    PageParameters parameters = new PageParameters();
    int i = 0;
    for (String s : url.getSegments()) {
        parameters.set(i, s);
        ++i;
    }
    for (QueryParameter p : url.getQueryParameters()) {
        parameters.add(p.getName(), p.getValue(), INamedParameters.Type.QUERY_STRING);
    }
    return parameters.isEmpty() ? null : parameters;
}",-0.045454545454545456,-0.1291866028708134,0.0,-0.5,-0.25,-0.059523809523809534,0.012825933756166263,0.08333333333333333,-0.02631578947368421,-0.029158094316027266
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1254_25a70439,1,"void backgroundRead() {
    String id = Utils.getIdFromPath(""/"");
    NodeDocument doc = store.find(Collection.NODES, id, asyncDelay);
    if (doc == null) {
        return;
    }
    Map<Integer, Revision> lastRevMap = doc.getLastRev();
    Revision.RevisionComparator revisionComparator = getRevisionComparator();
    boolean hasNewRevisions = false;
    // the (old) head occurred first
    Revision headSeen = Revision.newRevision(0);
    // then we saw this new revision (from another cluster node)
    Revision otherSeen = Revision.newRevision(0);
    for (Map.Entry<Integer, Revision> e : lastRevMap.entrySet()) {
        int machineId = e.getKey();
        if (machineId == clusterId) {
            continue;
        }
        Revision r = e.getValue();
        Revision last = lastKnownRevision.get(machineId);
        if (last == null || r.compareRevisionTime(last) > 0) {
            lastKnownRevision.put(machineId, r);
            hasNewRevisions = true;
            revisionComparator.add(r, otherSeen);
        }
    }
    if (hasNewRevisions) {
        store.invalidateCache();
        // TODO only invalidate affected items
        docChildrenCache.invalidateAll();
        // add a new revision, so that changes are visible
        Revision r = Revision.newRevision(clusterId);
        // the latest revisions of the current cluster node
        // happened before the latest revisions of other cluster nodes
        revisionComparator.add(r, headSeen);
        // the head revision is after other revisions
        setHeadRevision(Revision.newRevision(clusterId));
    }
    revisionComparator.purge(Revision.getCurrentTimestamp() - REMEMBER_REVISION_ORDER_MILLIS);
}",,"void backgroundRead() {
    String id = Utils.getIdFromPath(""/"");
    NodeDocument doc = store.find(Collection.NODES, id, asyncDelay);
    if (doc == null) {
        return;
    }
    Map<Integer, Revision> lastRevMap = doc.getLastRev();
    Revision.RevisionComparator revisionComparator = getRevisionComparator();
    boolean hasNewRevisions = false;
        Revision headSeen = Revision.newRevision(0);
        Revision otherSeen = Revision.newRevision(0);
    for (Map.Entry<Integer, Revision> e : lastRevMap.entrySet()) {
        int machineId = e.getKey();
        if (machineId == clusterId) {
            continue;
        }
        Revision r = e.getValue();
        Revision last = lastKnownRevision.get(machineId);
        if (last == null || r.compareRevisionTime(last) > 0) {
            lastKnownRevision.put(machineId, r);
            hasNewRevisions = true;
            revisionComparator.add(r, otherSeen);
        }
    }
    if (hasNewRevisions) {
        store.invalidateCache();
                docChildrenCache.invalidateAll();
                Revision r = Revision.newRevision(clusterId);
                        revisionComparator.add(r, headSeen);
                setHeadRevision(Revision.newRevision(clusterId));
    }
    revisionComparator.purge(Revision.getCurrentTimestamp() - REMEMBER_REVISION_ORDER_MILLIS);
}",0.8636363636363636,0.06220095693779899,0.6,0.0,0.5,0.40476190476190477,-0.6202959830866804,1.25,-0.02631578947368421,1.0533727517389624
Lang,51,1,"// String to boolean methods
// -----------------------------------------------------------------------
/**
 * <p>Converts a String to a boolean (optimised for performance).</p>
 *
 * <p><code>'true'</code>, <code>'on'</code> or <code>'yes'</code>
 * (case insensitive) will return <code>true</code>. Otherwise,
 * <code>false</code> is returned.</p>
 *
 * <p>This method performs 4 times faster (JDK1.4) than
 * <code>Boolean.valueOf(String)</code>. However, this method accepts
 * 'on' and 'yes' as true values.
 *
 * <pre>
 *   BooleanUtils.toBoolean(null)    = false
 *   BooleanUtils.toBoolean(""true"")  = true
 *   BooleanUtils.toBoolean(""TRUE"")  = true
 *   BooleanUtils.toBoolean(""tRUe"")  = true
 *   BooleanUtils.toBoolean(""on"")    = true
 *   BooleanUtils.toBoolean(""yes"")   = true
 *   BooleanUtils.toBoolean(""false"") = false
 *   BooleanUtils.toBoolean(""x gti"") = false
 * </pre>
 *
 * @param str  the String to check
 * @return the boolean value of the string, <code>false</code> if no match
 */
public static boolean toBoolean(String str) {
    // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower.
    if (str == ""true"") {
        return true;
    }
    if (str == null) {
        return false;
    }
    switch(str.length()) {
        case 2:
            {
                char ch0 = str.charAt(0);
                char ch1 = str.charAt(1);
                return (ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N');
            }
        case 3:
            {
                char ch = str.charAt(0);
                if (ch == 'y') {
                    return (str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S');
                }
                if (ch == 'Y') {
                    return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) == 's');
                }
            }
        case 4:
            {
                char ch = str.charAt(0);
                if (ch == 't') {
                    return (str.charAt(1) == 'r' || str.charAt(1) == 'R') && (str.charAt(2) == 'u' || str.charAt(2) == 'U') && (str.charAt(3) == 'e' || str.charAt(3) == 'E');
                }
                if (ch == 'T') {
                    return (str.charAt(1) == 'R' || str.charAt(1) == 'r') && (str.charAt(2) == 'U' || str.charAt(2) == 'u') && (str.charAt(3) == 'E' || str.charAt(3) == 'e');
                }
            }
    }
    return false;
}","/**
 * <p>Converts a String to a boolean (optimised for performance).</p>
 *
 * <p><code>'true'</code>, <code>'on'</code> or <code>'yes'</code>
 * (case insensitive) will return <code>true</code>. Otherwise,
 * <code>false</code> is returned.</p>
 *
 * <p>This method performs 4 times faster (JDK1.4) than
 * <code>Boolean.valueOf(String)</code>. However, this method accepts
 * 'on' and 'yes' as true values.
 *
 * <pre>
 *   BooleanUtils.toBoolean(null)    = false
 *   BooleanUtils.toBoolean(""true"")  = true
 *   BooleanUtils.toBoolean(""TRUE"")  = true
 *   BooleanUtils.toBoolean(""tRUe"")  = true
 *   BooleanUtils.toBoolean(""on"")    = true
 *   BooleanUtils.toBoolean(""yes"")   = true
 *   BooleanUtils.toBoolean(""false"") = false
 *   BooleanUtils.toBoolean(""x gti"") = false
 * </pre>
 *
 * @param str  the String to check
 * @return the boolean value of the string, <code>false</code> if no match
 */
","public static boolean toBoolean(String str) {
        if (str == ""true"") {
        return true;
    }
    if (str == null) {
        return false;
    }
    switch(str.length()) {
        case 2:
            {
                char ch0 = str.charAt(0);
                char ch1 = str.charAt(1);
                return (ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N');
            }
        case 3:
            {
                char ch = str.charAt(0);
                if (ch == 'y') {
                    return (str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S');
                }
                if (ch == 'Y') {
                    return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) == 's');
                }
            }
        case 4:
            {
                char ch = str.charAt(0);
                if (ch == 't') {
                    return (str.charAt(1) == 'r' || str.charAt(1) == 'R') && (str.charAt(2) == 'u' || str.charAt(2) == 'U') && (str.charAt(3) == 'e' || str.charAt(3) == 'E');
                }
                if (ch == 'T') {
                    return (str.charAt(1) == 'R' || str.charAt(1) == 'r') && (str.charAt(2) == 'U' || str.charAt(2) == 'u') && (str.charAt(3) == 'E' || str.charAt(3) == 'e');
                }
            }
    }
    return false;
}",1.0454545454545454,1.3779904306220097,1.2,0.5,0.5833333333333334,1.1746031746031746,-0.7384073291050032,1.5833333333333333,-0.02631578947368421,3.1722711110342714
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1661_13eb19c2,1,"/**
 * Gets the columns to be mapped over from this job.
 *
 * @param implementingClass
 *          the class whose name will be used as a prefix for the property configuration key
 * @param conf
 *          the Hadoop configuration object to configure
 * @return a set of columns
 * @since 1.5.0
 * @see #fetchColumns(Class, Configuration, Collection)
 */
public static Set<Pair<Text, Text>> getFetchedColumns(Class<?> implementingClass, Configuration conf) {
    ArgumentChecker.notNull(conf);
    return deserializeFetchedColumns(conf.getStringCollection(enumToConfKey(implementingClass, ScanOpts.COLUMNS)));
}","/**
 * Gets the columns to be mapped over from this job.
 *
 * @param implementingClass
 *          the class whose name will be used as a prefix for the property configuration key
 * @param conf
 *          the Hadoop configuration object to configure
 * @return a set of columns
 * @since 1.5.0
 * @see #fetchColumns(Class, Configuration, Collection)
 */
","public static Set<Pair<Text, Text>> getFetchedColumns(Class<?> implementingClass, Configuration conf) {
    ArgumentChecker.notNull(conf);
    return deserializeFetchedColumns(conf.getStringCollection(enumToConfKey(implementingClass, ScanOpts.COLUMNS)));
}",-0.45454545454545453,-0.47368421052631593,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.6958421423537702,-0.16666666666666666,2.1842105263157894,-0.16279340490885932
camel,remotes/origin/bugs-dot-jar_CAMEL-8146_17475d80,3,"@Override
protected void doShutdown() throws Exception {
    if (shutdownExecutor && scheduledExecutorService != null) {
        getCamelContext().getExecutorServiceManager().shutdownNow(scheduledExecutorService);
        scheduledExecutorService = null;
        future = null;
    }
}",,"@Override
protected void doShutdown() throws Exception {
    if (shutdownExecutor && scheduledExecutorService != null) {
        getCamelContext().getExecutorServiceManager().shutdownNow(scheduledExecutorService);
        scheduledExecutorService = null;
        future = null;
    }
}",-0.2727272727272727,0.22488038277511951,-0.4,-0.5,-0.08333333333333333,-0.09523809523809523,0.3874559548978154,-0.25,0.5526315789473684,-0.11731240239046119
camel,remotes/origin/bugs-dot-jar_CAMEL-5187_8cadc344,3,"private void registerMBeanWithServer(Object obj, ObjectName name, boolean forceRegistration) throws JMException {
    // have we already registered the bean, there can be shared instances in the camel routes
    boolean exists = server.isRegistered(name);
    if (exists) {
        if (forceRegistration) {
            LOG.info(""ForceRegistration enabled, unregistering existing MBean with ObjectName: {}"", name);
            server.unregisterMBean(name);
        } else {
            // okay ignore we do not want to force it and it could be a shared instance
            LOG.debug(""MBean already registered with ObjectName: {}"", name);
        }
    }
    // register bean if by force or not exists
    ObjectInstance instance = null;
    if (forceRegistration || !exists) {
        LOG.trace(""Registering MBean with ObjectName: {}"", name);
        instance = server.registerMBean(obj, name);
    }
    // need to use the name returned from the server as some JEE servers may modify the name
    if (instance != null) {
        ObjectName registeredName = instance.getObjectName();
        LOG.debug(""Registered MBean with ObjectName: {}"", registeredName);
        mbeansRegistered.add(registeredName);
    }
}",,"private void registerMBeanWithServer(Object obj, ObjectName name, boolean forceRegistration) throws JMException {
        boolean exists = server.isRegistered(name);
    if (exists) {
        if (forceRegistration) {
            LOG.info(""ForceRegistration enabled, unregistering existing MBean with ObjectName: {}"", name);
            server.unregisterMBean(name);
        } else {
                        LOG.debug(""MBean already registered with ObjectName: {}"", name);
        }
    }
        ObjectInstance instance = null;
    if (forceRegistration || !exists) {
        LOG.trace(""Registering MBean with ObjectName: {}"", name);
        instance = server.registerMBean(obj, name);
    }
        if (instance != null) {
        ObjectName registeredName = instance.getObjectName();
        LOG.debug(""Registered MBean with ObjectName: {}"", registeredName);
        mbeansRegistered.add(registeredName);
    }
}",0.3181818181818182,0.1961722488038276,0.2,0.0,0.25,0.371031746031746,-0.278646934460888,0.25,-0.02631578947368421,0.34236614166421736
flink,remotes/origin/bugs-dot-jar_FLINK-3760_494212b3,0,"private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {
    // read the non-transient fields
    in.defaultReadObject();
    // read the default value field
    boolean hasDefaultValue = in.readBoolean();
    if (hasDefaultValue) {
        int size = in.readInt();
        byte[] buffer = new byte[size];
        int bytesRead = in.read(buffer);
        if (bytesRead != size) {
            throw new RuntimeException(""Read size does not match expected size."");
        }
        try (ByteArrayInputStream bais = new ByteArrayInputStream(buffer);
            DataInputViewStreamWrapper inView = new DataInputViewStreamWrapper(bais)) {
            defaultValue = serializer.deserialize(inView);
        } catch (Exception e) {
            throw new IOException(""Unable to deserialize default value."", e);
        }
    } else {
        defaultValue = null;
    }
}",,"private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {
        in.defaultReadObject();
        boolean hasDefaultValue = in.readBoolean();
    if (hasDefaultValue) {
        int size = in.readInt();
        byte[] buffer = new byte[size];
        int bytesRead = in.read(buffer);
        if (bytesRead != size) {
            throw new RuntimeException(""Read size does not match expected size."");
        }
        try (ByteArrayInputStream bais = new ByteArrayInputStream(buffer);
            DataInputViewStreamWrapper inView = new DataInputViewStreamWrapper(bais)) {
            defaultValue = serializer.deserialize(inView);
        } catch (Exception e) {
            throw new IOException(""Unable to deserialize default value."", e);
        }
    } else {
        defaultValue = null;
    }
}",0.2727272727272727,0.26794258373205726,0.4,0.0,0.0,-0.06746031746031747,-0.2076109936575051,-0.08333333333333333,0.05263157894736841,-0.023017121649579596
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3019_5135cf4b,1,"private boolean setVersionablePath(PropertyState after) {
    if (JcrConstants.JCR_VERSIONHISTORY.equals(after.getName()) && nodeAfter.isVersionable(versionManager)) {
        NodeBuilder vhBuilder;
        try {
            vhBuilder = versionManager.getOrCreateVersionHistory(nodeAfter.builder, Collections.EMPTY_MAP);
        } catch (CommitFailedException e) {
            exceptions.add(e);
            // stop further comparison
            return false;
        }
        if (!vhBuilder.hasProperty(JcrConstants.JCR_MIXINTYPES)) {
            vhBuilder.setProperty(JcrConstants.JCR_MIXINTYPES, ImmutableSet.of(MIX_REP_VERSIONABLE_PATHS), Type.NAMES);
        }
        String versionablePath = nodeAfter.path;
        vhBuilder.setProperty(workspaceName, versionablePath, Type.PATH);
    }
    return true;
}",,"private boolean setVersionablePath(PropertyState after) {
    if (JcrConstants.JCR_VERSIONHISTORY.equals(after.getName()) && nodeAfter.isVersionable(versionManager)) {
        NodeBuilder vhBuilder;
        try {
            vhBuilder = versionManager.getOrCreateVersionHistory(nodeAfter.builder, Collections.EMPTY_MAP);
        } catch (CommitFailedException e) {
            exceptions.add(e);
                        return false;
        }
        if (!vhBuilder.hasProperty(JcrConstants.JCR_MIXINTYPES)) {
            vhBuilder.setProperty(JcrConstants.JCR_MIXINTYPES, ImmutableSet.of(MIX_REP_VERSIONABLE_PATHS), Type.NAMES);
        }
        String versionablePath = nodeAfter.path;
        vhBuilder.setProperty(workspaceName, versionablePath, Type.PATH);
    }
    return true;
}",0.13636363636363635,0.3349282296650717,0.0,0.0,0.25,-0.08333333333333336,-0.17350246652572232,0.25,-0.02631578947368421,0.027069610368654285
commons-math,remotes/origin/bugs-dot-jar_MATH-1088_63d88c74,3,"/**
 * {@inheritDoc}
 */
public boolean hasNext() {
    for (int i = 0; i < dimension; i++) {
        if (counter[i] != size[i] - 1) {
            return true;
        }
    }
    return false;
}","/**
 * {@inheritDoc}
 */
","public boolean hasNext() {
    for (int i = 0; i < dimension; i++) {
        if (counter[i] != size[i] - 1) {
            return true;
        }
    }
    return false;
}",-0.2727272727272727,0.42105263157894735,-0.2,0.0,-0.08333333333333333,0.1904761904761904,0.37730796335447503,-0.5,2.5789473684210527,-0.06696749134120548
Closure,153,2,"void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber);",,"void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber);",-0.5909090909090909,-1.4306220095693782,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,1.4022551092318531,-0.5,-0.02631578947368421,-0.16279340490885932
commons-math,remotes/origin/bugs-dot-jar_MATH-867_bfbb156d,1,"/**
 * {@inheritDoc}
 */
@Override
protected PointValuePair doOptimize() {
    checkParameters();
    // -------------------- Initialization --------------------------------
    isMinimize = getGoalType().equals(GoalType.MINIMIZE);
    final FitnessFunction fitfun = new FitnessFunction();
    final double[] guess = fitfun.encode(getStartPoint());
    // number of objective variables/problem dimension
    dimension = guess.length;
    initializeCMA(guess);
    iterations = 0;
    double bestValue = fitfun.value(guess);
    push(fitnessHistory, bestValue);
    PointValuePair optimum = new PointValuePair(getStartPoint(), isMinimize ? bestValue : -bestValue);
    PointValuePair lastResult = null;
    generationLoop: for (iterations = 1; iterations <= maxIterations; iterations++) {
        // Generate and evaluate lambda offspring
        RealMatrix arz = randn1(dimension, lambda);
        RealMatrix arx = zeros(dimension, lambda);
        double[] fitness = new double[lambda];
        // generate random offspring
        for (int k = 0; k < lambda; k++) {
            RealMatrix arxk = null;
            for (int i = 0; i < checkFeasableCount + 1; i++) {
                if (diagonalOnly <= 0) {
                    arxk = xmean.add(BD.multiply(arz.getColumnMatrix(k)).scalarMultiply(// m + sig * Normal(0,C)
                    sigma));
                } else {
                    arxk = xmean.add(times(diagD, arz.getColumnMatrix(k)).scalarMultiply(sigma));
                }
                if (i >= checkFeasableCount || fitfun.isFeasible(arxk.getColumn(0))) {
                    break;
                }
                // regenerate random arguments for row
                arz.setColumn(k, randn(dimension));
            }
            copyColumn(arxk, 0, arx, k);
            try {
                // compute fitness
                fitness[k] = fitfun.value(arx.getColumn(k));
            } catch (TooManyEvaluationsException e) {
                break generationLoop;
            }
        }
        // Sort by fitness and compute weighted mean into xmean
        int[] arindex = sortedIndices(fitness);
        // Calculate new xmean, this is selection and recombination
        // for speed up of Eq. (2) and (3)
        RealMatrix xold = xmean;
        RealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu));
        xmean = bestArx.multiply(weights);
        RealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu));
        RealMatrix zmean = bestArz.multiply(weights);
        boolean hsig = updateEvolutionPaths(zmean, xold);
        if (diagonalOnly <= 0) {
            updateCovariance(hsig, bestArx, arz, arindex, xold);
        } else {
            updateCovarianceDiagonalOnly(hsig, bestArz, xold);
        }
        // Adapt step size sigma - Eq. (5)
        sigma *= Math.exp(Math.min(1.0, (normps / chiN - 1.) * cs / damps));
        double bestFitness = fitness[arindex[0]];
        double worstFitness = fitness[arindex[arindex.length - 1]];
        if (bestValue > bestFitness) {
            bestValue = bestFitness;
            lastResult = optimum;
            optimum = new PointValuePair(fitfun.repairAndDecode(bestArx.getColumn(0)), isMinimize ? bestFitness : -bestFitness);
            if (getConvergenceChecker() != null && lastResult != null) {
                if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {
                    break generationLoop;
                }
            }
        }
        // Break, if fitness is good enough
        if (stopFitness != 0) {
            // only if stopFitness is defined
            if (bestFitness < (isMinimize ? stopFitness : -stopFitness)) {
                break generationLoop;
            }
        }
        double[] sqrtDiagC = sqrt(diagC).getColumn(0);
        double[] pcCol = pc.getColumn(0);
        for (int i = 0; i < dimension; i++) {
            if (sigma * (Math.max(Math.abs(pcCol[i]), sqrtDiagC[i])) > stopTolX) {
                break;
            }
            if (i >= dimension - 1) {
                break generationLoop;
            }
        }
        for (int i = 0; i < dimension; i++) {
            if (sigma * sqrtDiagC[i] > stopTolUpX) {
                break generationLoop;
            }
        }
        double historyBest = min(fitnessHistory);
        double historyWorst = max(fitnessHistory);
        if (iterations > 2 && Math.max(historyWorst, worstFitness) - Math.min(historyBest, bestFitness) < stopTolFun) {
            break generationLoop;
        }
        if (iterations > fitnessHistory.length && historyWorst - historyBest < stopTolHistFun) {
            break generationLoop;
        }
        // condition number of the covariance matrix exceeds 1e14
        if (max(diagD) / min(diagD) > 1e7) {
            break generationLoop;
        }
        // user defined termination
        if (getConvergenceChecker() != null) {
            PointValuePair current = new PointValuePair(bestArx.getColumn(0), isMinimize ? bestFitness : -bestFitness);
            if (lastResult != null && getConvergenceChecker().converged(iterations, current, lastResult)) {
                break generationLoop;
            }
            lastResult = current;
        }
        // Adjust step size in case of equal function values (flat fitness)
        if (bestValue == fitness[arindex[(int) (0.1 + lambda / 4.)]]) {
            sigma = sigma * Math.exp(0.2 + cs / damps);
        }
        if (iterations > 2 && Math.max(historyWorst, bestFitness) - Math.min(historyBest, bestFitness) == 0) {
            sigma = sigma * Math.exp(0.2 + cs / damps);
        }
        // store best in history
        push(fitnessHistory, bestFitness);
        fitfun.setValueRange(worstFitness - bestFitness);
        if (generateStatistics) {
            statisticsSigmaHistory.add(sigma);
            statisticsFitnessHistory.add(bestFitness);
            statisticsMeanHistory.add(xmean.transpose());
            statisticsDHistory.add(diagD.transpose().scalarMultiply(1E5));
        }
    }
    return optimum;
}","/**
 * {@inheritDoc}
 */
","@Override
protected PointValuePair doOptimize() {
    checkParameters();
        isMinimize = getGoalType().equals(GoalType.MINIMIZE);
    final FitnessFunction fitfun = new FitnessFunction();
    final double[] guess = fitfun.encode(getStartPoint());
        dimension = guess.length;
    initializeCMA(guess);
    iterations = 0;
    double bestValue = fitfun.value(guess);
    push(fitnessHistory, bestValue);
    PointValuePair optimum = new PointValuePair(getStartPoint(), isMinimize ? bestValue : -bestValue);
    PointValuePair lastResult = null;
    generationLoop: for (iterations = 1; iterations <= maxIterations; iterations++) {
                RealMatrix arz = randn1(dimension, lambda);
        RealMatrix arx = zeros(dimension, lambda);
        double[] fitness = new double[lambda];
                for (int k = 0; k < lambda; k++) {
            RealMatrix arxk = null;
            for (int i = 0; i < checkFeasableCount + 1; i++) {
                if (diagonalOnly <= 0) {
                    arxk = xmean.add(BD.multiply(arz.getColumnMatrix(k)).scalarMultiply(                    sigma));
                } else {
                    arxk = xmean.add(times(diagD, arz.getColumnMatrix(k)).scalarMultiply(sigma));
                }
                if (i >= checkFeasableCount || fitfun.isFeasible(arxk.getColumn(0))) {
                    break;
                }
                                arz.setColumn(k, randn(dimension));
            }
            copyColumn(arxk, 0, arx, k);
            try {
                                fitness[k] = fitfun.value(arx.getColumn(k));
            } catch (TooManyEvaluationsException e) {
                break generationLoop;
            }
        }
                int[] arindex = sortedIndices(fitness);
                        RealMatrix xold = xmean;
        RealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu));
        xmean = bestArx.multiply(weights);
        RealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu));
        RealMatrix zmean = bestArz.multiply(weights);
        boolean hsig = updateEvolutionPaths(zmean, xold);
        if (diagonalOnly <= 0) {
            updateCovariance(hsig, bestArx, arz, arindex, xold);
        } else {
            updateCovarianceDiagonalOnly(hsig, bestArz, xold);
        }
                sigma *= Math.exp(Math.min(1.0, (normps / chiN - 1.) * cs / damps));
        double bestFitness = fitness[arindex[0]];
        double worstFitness = fitness[arindex[arindex.length - 1]];
        if (bestValue > bestFitness) {
            bestValue = bestFitness;
            lastResult = optimum;
            optimum = new PointValuePair(fitfun.repairAndDecode(bestArx.getColumn(0)), isMinimize ? bestFitness : -bestFitness);
            if (getConvergenceChecker() != null && lastResult != null) {
                if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {
                    break generationLoop;
                }
            }
        }
                if (stopFitness != 0) {
                        if (bestFitness < (isMinimize ? stopFitness : -stopFitness)) {
                break generationLoop;
            }
        }
        double[] sqrtDiagC = sqrt(diagC).getColumn(0);
        double[] pcCol = pc.getColumn(0);
        for (int i = 0; i < dimension; i++) {
            if (sigma * (Math.max(Math.abs(pcCol[i]), sqrtDiagC[i])) > stopTolX) {
                break;
            }
            if (i >= dimension - 1) {
                break generationLoop;
            }
        }
        for (int i = 0; i < dimension; i++) {
            if (sigma * sqrtDiagC[i] > stopTolUpX) {
                break generationLoop;
            }
        }
        double historyBest = min(fitnessHistory);
        double historyWorst = max(fitnessHistory);
        if (iterations > 2 && Math.max(historyWorst, worstFitness) - Math.min(historyBest, bestFitness) < stopTolFun) {
            break generationLoop;
        }
        if (iterations > fitnessHistory.length && historyWorst - historyBest < stopTolHistFun) {
            break generationLoop;
        }
                if (max(diagD) / min(diagD) > 1e7) {
            break generationLoop;
        }
                if (getConvergenceChecker() != null) {
            PointValuePair current = new PointValuePair(bestArx.getColumn(0), isMinimize ? bestFitness : -bestFitness);
            if (lastResult != null && getConvergenceChecker().converged(iterations, current, lastResult)) {
                break generationLoop;
            }
            lastResult = current;
        }
                if (bestValue == fitness[arindex[(int) (0.1 + lambda / 4.)]]) {
            sigma = sigma * Math.exp(0.2 + cs / damps);
        }
        if (iterations > 2 && Math.max(historyWorst, bestFitness) - Math.min(historyBest, bestFitness) == 0) {
            sigma = sigma * Math.exp(0.2 + cs / damps);
        }
                push(fitnessHistory, bestFitness);
        fitfun.setValueRange(worstFitness - bestFitness);
        if (generateStatistics) {
            statisticsSigmaHistory.add(sigma);
            statisticsFitnessHistory.add(bestFitness);
            statisticsMeanHistory.add(xmean.transpose());
            statisticsDHistory.add(diagD.transpose().scalarMultiply(1E5));
        }
    }
    return optimum;
}",4.7272727272727275,0.6220095693779903,7.4,1.0,5.583333333333333,4.091269841269842,-1.6553911205073992,5.416666666666667,-0.02631578947368421,34.23290975836056
wicket,remotes/origin/bugs-dot-jar_WICKET-4072_7d5b8645,1,"/**
 *  render full representation of url (including protocol, host and port)
 *  into string representation
 */
public String toAbsoluteString() {
    return toAbsoluteString(getCharset());
}","/**
 *  render full representation of url (including protocol, host and port)
 *  into string representation
 */
","public String toAbsoluteString() {
    return toAbsoluteString(getCharset());
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,1.1319238900634248,-0.3333333333333333,2.6052631578947367,-0.16279340490885932
camel,remotes/origin/bugs-dot-jar_CAMEL-3281_f7dd2fff,1,"/**
 * Adds a route for an interceptor that intercepts every processing step.
 *
 * @return the builder
 */
public InterceptDefinition intercept() {
    routeCollection.setCamelContext(getContext());
    return routeCollection.intercept();
}","/**
 * Adds a route for an interceptor that intercepts every processing step.
 *
 * @return the builder
 */
","public InterceptDefinition intercept() {
    routeCollection.setCamelContext(getContext());
    return routeCollection.intercept();
}",-0.45454545454545453,-0.47368421052631593,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.8940098661028892,-0.25,2.5789473684210527,-0.16279340490885932
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-258_7b38965d,1,"/**
 * Returns appropriate HTML headers.
 * @return The header as a byte array.
 */
@Override
public byte[] getHeader() {
    final StringBuilder sbuf = new StringBuilder();
    sbuf.append(""<!DOCTYPE HTML PUBLIC \""-//W3C//DTD HTML 4.01 Transitional//EN\"" "");
    sbuf.append(""\""http://www.w3.org/TR/html4/loose.dtd\"">"");
    sbuf.append(Constants.LINE_SEP);
    sbuf.append(""<html>"").append(Constants.LINE_SEP);
    sbuf.append(""<head>"").append(Constants.LINE_SEP);
    sbuf.append(""<title>"").append(title).append(""</title>"").append(Constants.LINE_SEP);
    sbuf.append(""<style type=\""text/css\"">"").append(Constants.LINE_SEP);
    sbuf.append(""<!--"").append(Constants.LINE_SEP);
    sbuf.append(""body, table {font-family:"").append(font).append(""; font-size: "");
    sbuf.append(headerSize).append("";}"").append(Constants.LINE_SEP);
    sbuf.append(""th {background: #336699; color: #FFFFFF; text-align: left;}"").append(Constants.LINE_SEP);
    sbuf.append(""-->"").append(Constants.LINE_SEP);
    sbuf.append(""</style>"").append(Constants.LINE_SEP);
    sbuf.append(""</head>"").append(Constants.LINE_SEP);
    sbuf.append(""<body bgcolor=\""#FFFFFF\"" topmargin=\""6\"" leftmargin=\""6\"">"").append(Constants.LINE_SEP);
    sbuf.append(""<hr size=\""1\"" noshade>"").append(Constants.LINE_SEP);
    sbuf.append(""Log session start time "" + new java.util.Date() + ""<br>"").append(Constants.LINE_SEP);
    sbuf.append(""<br>"").append(Constants.LINE_SEP);
    sbuf.append(""<table cellspacing=\""0\"" cellpadding=\""4\"" border=\""1\"" bordercolor=\""#224466\"" width=\""100%\"">"");
    sbuf.append(Constants.LINE_SEP);
    sbuf.append(""<tr>"").append(Constants.LINE_SEP);
    sbuf.append(""<th>Time</th>"").append(Constants.LINE_SEP);
    sbuf.append(""<th>Thread</th>"").append(Constants.LINE_SEP);
    sbuf.append(""<th>Level</th>"").append(Constants.LINE_SEP);
    sbuf.append(""<th>Logger</th>"").append(Constants.LINE_SEP);
    if (locationInfo) {
        sbuf.append(""<th>File:Line</th>"").append(Constants.LINE_SEP);
    }
    sbuf.append(""<th>Message</th>"").append(Constants.LINE_SEP);
    sbuf.append(""</tr>"").append(Constants.LINE_SEP);
    return sbuf.toString().getBytes(getCharset());
}","/**
 * Returns appropriate HTML headers.
 * @return The header as a byte array.
 */
","@Override
public byte[] getHeader() {
    final StringBuilder sbuf = new StringBuilder();
    sbuf.append(""<!DOCTYPE HTML PUBLIC \""-//W3C//DTD HTML 4.01 Transitional//EN\"" "");
    sbuf.append(""\""http://www.w3.org/TR/html4/loose.dtd\"">"");
    sbuf.append(Constants.LINE_SEP);
    sbuf.append(""<html>"").append(Constants.LINE_SEP);
    sbuf.append(""<head>"").append(Constants.LINE_SEP);
    sbuf.append(""<title>"").append(title).append(""</title>"").append(Constants.LINE_SEP);
    sbuf.append(""<style type=\""text/css\"">"").append(Constants.LINE_SEP);
    sbuf.append(""<!--"").append(Constants.LINE_SEP);
    sbuf.append(""body, table {font-family:"").append(font).append(""; font-size: "");
    sbuf.append(headerSize).append("";}"").append(Constants.LINE_SEP);
    sbuf.append(""th {background: #336699; color: #FFFFFF; text-align: left;}"").append(Constants.LINE_SEP);
    sbuf.append(""-->"").append(Constants.LINE_SEP);
    sbuf.append(""</style>"").append(Constants.LINE_SEP);
    sbuf.append(""</head>"").append(Constants.LINE_SEP);
    sbuf.append(""<body bgcolor=\""#FFFFFF\"" topmargin=\""6\"" leftmargin=\""6\"">"").append(Constants.LINE_SEP);
    sbuf.append(""<hr size=\""1\"" noshade>"").append(Constants.LINE_SEP);
    sbuf.append(""Log session start time "" + new java.util.Date() + ""<br>"").append(Constants.LINE_SEP);
    sbuf.append(""<br>"").append(Constants.LINE_SEP);
    sbuf.append(""<table cellspacing=\""0\"" cellpadding=\""4\"" border=\""1\"" bordercolor=\""#224466\"" width=\""100%\"">"");
    sbuf.append(Constants.LINE_SEP);
    sbuf.append(""<tr>"").append(Constants.LINE_SEP);
    sbuf.append(""<th>Time</th>"").append(Constants.LINE_SEP);
    sbuf.append(""<th>Thread</th>"").append(Constants.LINE_SEP);
    sbuf.append(""<th>Level</th>"").append(Constants.LINE_SEP);
    sbuf.append(""<th>Logger</th>"").append(Constants.LINE_SEP);
    if (locationInfo) {
        sbuf.append(""<th>File:Line</th>"").append(Constants.LINE_SEP);
    }
    sbuf.append(""<th>Message</th>"").append(Constants.LINE_SEP);
    sbuf.append(""</tr>"").append(Constants.LINE_SEP);
    return sbuf.toString().getBytes(getCharset());
}",0.9545454545454546,-0.7942583732057418,-0.4,-0.5,-0.25,0.3988095238095238,-0.6715997181113459,4.333333333333333,-0.02631578947368421,1.6106660212190886
commons-math,remotes/origin/bugs-dot-jar_MATH-326_ce185345,1,"/**
 * {@inheritDoc}
 */
public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","/**
 * {@inheritDoc}
 */
","public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}",-0.3181818181818182,-0.20574162679425848,-0.4,-0.5,-0.4166666666666667,-0.017857142857142873,0.49372797744890756,-0.3333333333333333,2.236842105263158,-0.11991263406003815
wicket,remotes/origin/bugs-dot-jar_WICKET-4932_f20b2d70,1,"/**
 *  Creates a {@code IRequestHandler} that processes a bookmarkable request.
 *
 *  @param pageClass
 *  @param pageParameters
 *  @return a {@code IRequestHandler} capable of processing the bookmarkable request.
 */
protected IRequestHandler processBookmarkable(Class<? extends IRequestablePage> pageClass, PageParameters pageParameters) {
    PageProvider provider = new PageProvider(pageClass, pageParameters);
    provider.setPageSource(getContext());
    return new RenderPageRequestHandler(provider);
}","/**
 *  Creates a {@code IRequestHandler} that processes a bookmarkable request.
 *
 *  @param pageClass
 *  @param pageParameters
 *  @return a {@code IRequestHandler} capable of processing the bookmarkable request.
 */
","protected IRequestHandler processBookmarkable(Class<? extends IRequestablePage> pageClass, PageParameters pageParameters) {
    PageProvider provider = new PageProvider(pageClass, pageParameters);
    provider.setPageSource(getContext());
    return new RenderPageRequestHandler(provider);
}",-0.4090909090909091,-0.49282296650717716,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.6084566596194504,-0.3333333333333333,2.3947368421052633,-0.16279340490885932
Chart,2,3,"/**
 * Iterates over the items in an {@link XYDataset} to find
 * the range of x-values.
 *
 * @param dataset  the dataset (<code>null</code> not permitted).
 * @param includeInterval  a flag that determines, for an
 *          {@link IntervalXYDataset}, whether the x-interval or just the
 *          x-value is used to determine the overall range.
 *
 * @return The range (possibly <code>null</code>).
 */
public static Range iterateDomainBounds(XYDataset dataset, boolean includeInterval) {
    if (dataset == null) {
        throw new IllegalArgumentException(""Null 'dataset' argument."");
    }
    double minimum = Double.POSITIVE_INFINITY;
    double maximum = Double.NEGATIVE_INFINITY;
    int seriesCount = dataset.getSeriesCount();
    double lvalue;
    double uvalue;
    if (includeInterval && dataset instanceof IntervalXYDataset) {
        IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset;
        for (int series = 0; series < seriesCount; series++) {
            int itemCount = dataset.getItemCount(series);
            for (int item = 0; item < itemCount; item++) {
                lvalue = intervalXYData.getStartXValue(series, item);
                uvalue = intervalXYData.getEndXValue(series, item);
                if (!Double.isNaN(lvalue)) {
                    minimum = Math.min(minimum, lvalue);
                }
                if (!Double.isNaN(uvalue)) {
                    maximum = Math.max(maximum, uvalue);
                }
            }
        }
    } else {
        for (int series = 0; series < seriesCount; series++) {
            int itemCount = dataset.getItemCount(series);
            for (int item = 0; item < itemCount; item++) {
                lvalue = dataset.getXValue(series, item);
                uvalue = lvalue;
                if (!Double.isNaN(lvalue)) {
                    minimum = Math.min(minimum, lvalue);
                    maximum = Math.max(maximum, uvalue);
                }
            }
        }
    }
    if (minimum > maximum) {
        return null;
    } else {
        return new Range(minimum, maximum);
    }
}","/**
 * Iterates over the items in an {@link XYDataset} to find
 * the range of x-values.
 *
 * @param dataset  the dataset (<code>null</code> not permitted).
 * @param includeInterval  a flag that determines, for an
 *          {@link IntervalXYDataset}, whether the x-interval or just the
 *          x-value is used to determine the overall range.
 *
 * @return The range (possibly <code>null</code>).
 */
","public static Range iterateDomainBounds(XYDataset dataset, boolean includeInterval) {
    if (dataset == null) {
        throw new IllegalArgumentException(""Null 'dataset' argument."");
    }
    double minimum = Double.POSITIVE_INFINITY;
    double maximum = Double.NEGATIVE_INFINITY;
    int seriesCount = dataset.getSeriesCount();
    double lvalue;
    double uvalue;
    if (includeInterval && dataset instanceof IntervalXYDataset) {
        IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset;
        for (int series = 0; series < seriesCount; series++) {
            int itemCount = dataset.getItemCount(series);
            for (int item = 0; item < itemCount; item++) {
                lvalue = intervalXYData.getStartXValue(series, item);
                uvalue = intervalXYData.getEndXValue(series, item);
                if (!Double.isNaN(lvalue)) {
                    minimum = Math.min(minimum, lvalue);
                }
                if (!Double.isNaN(uvalue)) {
                    maximum = Math.max(maximum, uvalue);
                }
            }
        }
    } else {
        for (int series = 0; series < seriesCount; series++) {
            int itemCount = dataset.getItemCount(series);
            for (int item = 0; item < itemCount; item++) {
                lvalue = dataset.getXValue(series, item);
                uvalue = lvalue;
                if (!Double.isNaN(lvalue)) {
                    minimum = Math.min(minimum, lvalue);
                    maximum = Math.max(maximum, uvalue);
                }
            }
        }
    }
    if (minimum > maximum) {
        return null;
    } else {
        return new Range(minimum, maximum);
    }
}",1.3181818181818181,1.3779904306220097,1.6,1.0,1.5,1.6428571428571428,-0.7863284002818883,0.5833333333333334,-0.02631578947368421,3.2913008650150117
wicket,remotes/origin/bugs-dot-jar_WICKET-5426_fb45a781,3,"/**
 *  @see org.apache.wicket.request.component.IRequestablePage#renderPage()
 */
@Override
public void renderPage() {
    // page id is frozen during the render
    final boolean frozen = setFreezePageId(true);
    try {
        ++renderCount;
        render();
    } finally {
        setFreezePageId(frozen);
    }
}","/**
 *  @see org.apache.wicket.request.component.IRequestablePage#renderPage()
 */
","@Override
public void renderPage() {
        final boolean frozen = setFreezePageId(true);
    try {
        ++renderCount;
        render();
    } finally {
        setFreezePageId(frozen);
    }
}",-0.18181818181818182,0.05263157894736836,-0.6,-0.5,-0.4166666666666667,-0.11706349206349208,0.3792811839323466,-0.25,1.9736842105263157,-0.13982008148775665
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-93_0be7e8f0,1,"@Override
public Iterator<Tree> iterator() {
    Iterator<? extends ChildNodeEntry> childEntries = getNodeState().getChildNodeEntries().iterator();
    return Iterators.map(childEntries, new Function1<ChildNodeEntry, Tree>() {

        @Override
        public Tree apply(ChildNodeEntry entry) {
            NodeStateBuilder childBuilder = builder.getChildBuilder(entry.getName());
            return new TreeImpl(store, childBuilder.getNodeState(), childBuilder, TreeImpl.this, entry.getName(), listener);
        }
    });
}",,"@Override
public Iterator<Tree> iterator() {
    Iterator<? extends ChildNodeEntry> childEntries = getNodeState().getChildNodeEntries().iterator();
    return Iterators.map(childEntries, new Function1<ChildNodeEntry, Tree>() {

        @Override
        public Tree apply(ChildNodeEntry entry) {
            NodeStateBuilder childBuilder = builder.getChildBuilder(entry.getName());
            return new TreeImpl(store, childBuilder.getNodeState(), childBuilder, TreeImpl.this, entry.getName(), listener);
        }
    });
}",-0.13636363636363635,0.6124401913875596,-0.6,-0.5,-0.4166666666666667,-0.3650793650793651,0.11797040169133197,0.16666666666666666,-0.02631578947368421,-0.16279340490885932
Closure,131,2,"public static boolean isJSIdentifier(String s) {
    int length = s.length();
    if (length == 0 || !Character.isJavaIdentifierStart(s.charAt(0))) {
        return false;
    }
    for (int i = 1; i < length; i++) {
        if (!Character.isJavaIdentifierPart(s.charAt(i))) {
            return false;
        }
    }
    return true;
}",,"public static boolean isJSIdentifier(String s) {
    int length = s.length();
    if (length == 0 || !Character.isJavaIdentifierStart(s.charAt(0))) {
        return false;
    }
    for (int i = 1; i < length; i++) {
        if (!Character.isJavaIdentifierPart(s.charAt(i))) {
            return false;
        }
    }
    return true;
}",-0.09090909090909091,0.1578947368421051,0.0,0.0,0.4166666666666667,0.7837301587301587,0.081324876673714,-0.08333333333333333,0.3684210526315789,0.24069892751969477
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-4066_9a109aa3,0,"/**
 * eventually update suggest dictionary
 * @throws IOException if suggest dictionary update fails
 * @param analyzer the analyzer used to update the suggester
 */
private void updateSuggester(Analyzer analyzer) throws IOException {
    if (definition.isSuggestEnabled()) {
        boolean updateSuggester = false;
        NodeBuilder suggesterStatus = definitionBuilder.child("":suggesterStatus"");
        if (suggesterStatus.hasProperty(""lastUpdated"")) {
            PropertyState suggesterLastUpdatedValue = suggesterStatus.getProperty(""lastUpdated"");
            Calendar suggesterLastUpdatedTime = ISO8601.parse(suggesterLastUpdatedValue.getValue(Type.DATE));
            int updateFrequency = definition.getSuggesterUpdateFrequencyMinutes();
            suggesterLastUpdatedTime.add(Calendar.MINUTE, updateFrequency);
            if (getCalendar().after(suggesterLastUpdatedTime)) {
                updateSuggester = true;
            }
        } else {
            updateSuggester = true;
        }
        if (updateSuggester) {
            DirectoryReader reader = DirectoryReader.open(writer, false);
            final OakDirectory suggestDirectory = new OakDirectory(definitionBuilder, "":suggest-data"", definition, false);
            try {
                SuggestHelper.updateSuggester(suggestDirectory, analyzer, reader);
                suggesterStatus.setProperty(""lastUpdated"", ISO8601.format(getCalendar()), Type.DATE);
            } catch (Throwable e) {
                log.warn(""could not update suggester"", e);
            } finally {
                suggestDirectory.close();
                reader.close();
            }
        }
    }
}","/**
 * eventually update suggest dictionary
 * @throws IOException if suggest dictionary update fails
 * @param analyzer the analyzer used to update the suggester
 */
","private void updateSuggester(Analyzer analyzer) throws IOException {
    if (definition.isSuggestEnabled()) {
        boolean updateSuggester = false;
        NodeBuilder suggesterStatus = definitionBuilder.child("":suggesterStatus"");
        if (suggesterStatus.hasProperty(""lastUpdated"")) {
            PropertyState suggesterLastUpdatedValue = suggesterStatus.getProperty(""lastUpdated"");
            Calendar suggesterLastUpdatedTime = ISO8601.parse(suggesterLastUpdatedValue.getValue(Type.DATE));
            int updateFrequency = definition.getSuggesterUpdateFrequencyMinutes();
            suggesterLastUpdatedTime.add(Calendar.MINUTE, updateFrequency);
            if (getCalendar().after(suggesterLastUpdatedTime)) {
                updateSuggester = true;
            }
        } else {
            updateSuggester = true;
        }
        if (updateSuggester) {
            DirectoryReader reader = DirectoryReader.open(writer, false);
            final OakDirectory suggestDirectory = new OakDirectory(definitionBuilder, "":suggest-data"", definition, false);
            try {
                SuggestHelper.updateSuggester(suggestDirectory, analyzer, reader);
                suggesterStatus.setProperty(""lastUpdated"", ISO8601.format(getCalendar()), Type.DATE);
            } catch (Throwable e) {
                log.warn(""could not update suggester"", e);
            } finally {
                suggestDirectory.close();
                reader.close();
            }
        }
    }
}",0.7272727272727273,0.6363636363636365,0.4,0.5,0.3333333333333333,-0.3650793650793651,-0.5286821705426354,1.0,-0.02631578947368421,-0.16279340490885932
Lang,5,1,"// -----------------------------------------------------------------------
/**
 * <p>Converts a String to a Locale.</p>
 *
 * <p>This method takes the string format of a locale and creates the
 * locale object from it.</p>
 *
 * <pre>
 *   LocaleUtils.toLocale(""en"")         = new Locale(""en"", """")
 *   LocaleUtils.toLocale(""en_GB"")      = new Locale(""en"", ""GB"")
 *   LocaleUtils.toLocale(""en_GB_xxx"")  = new Locale(""en"", ""GB"", ""xxx"")   (#)
 * </pre>
 *
 * <p>(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4.
 * In JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn't.
 * Thus, the result from getVariant() may vary depending on your JDK.</p>
 *
 * <p>This method validates the input strictly.
 * The language code must be lowercase.
 * The country code must be uppercase.
 * The separator must be an underscore.
 * The length must be correct.
 * </p>
 *
 * @param str  the locale String to convert, null returns null
 * @return a Locale, null if null input
 * @throws IllegalArgumentException if the string is an invalid format
 */
public static Locale toLocale(final String str) {
    if (str == null) {
        return null;
    }
    final int len = str.length();
    if (len < 2) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    final char ch0 = str.charAt(0);
    final char ch1 = str.charAt(1);
    if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    if (len == 2) {
        return new Locale(str);
    }
    if (len < 5) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    if (str.charAt(2) != '_') {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    final char ch3 = str.charAt(3);
    if (ch3 == '_') {
        return new Locale(str.substring(0, 2), """", str.substring(4));
    }
    final char ch4 = str.charAt(4);
    if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    if (len == 5) {
        return new Locale(str.substring(0, 2), str.substring(3, 5));
    }
    if (len < 7) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    if (str.charAt(5) != '_') {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
}","/**
 * <p>Converts a String to a Locale.</p>
 *
 * <p>This method takes the string format of a locale and creates the
 * locale object from it.</p>
 *
 * <pre>
 *   LocaleUtils.toLocale(""en"")         = new Locale(""en"", """")
 *   LocaleUtils.toLocale(""en_GB"")      = new Locale(""en"", ""GB"")
 *   LocaleUtils.toLocale(""en_GB_xxx"")  = new Locale(""en"", ""GB"", ""xxx"")   (#)
 * </pre>
 *
 * <p>(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4.
 * In JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn't.
 * Thus, the result from getVariant() may vary depending on your JDK.</p>
 *
 * <p>This method validates the input strictly.
 * The language code must be lowercase.
 * The country code must be uppercase.
 * The separator must be an underscore.
 * The length must be correct.
 * </p>
 *
 * @param str  the locale String to convert, null returns null
 * @return a Locale, null if null input
 * @throws IllegalArgumentException if the string is an invalid format
 */
","public static Locale toLocale(final String str) {
    if (str == null) {
        return null;
    }
    final int len = str.length();
    if (len < 2) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    final char ch0 = str.charAt(0);
    final char ch1 = str.charAt(1);
    if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    if (len == 2) {
        return new Locale(str);
    }
    if (len < 5) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    if (str.charAt(2) != '_') {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    final char ch3 = str.charAt(3);
    if (ch3 == '_') {
        return new Locale(str.substring(0, 2), """", str.substring(4));
    }
    final char ch4 = str.charAt(4);
    if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    if (len == 5) {
        return new Locale(str.substring(0, 2), str.substring(3, 5));
    }
    if (len < 7) {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    if (str.charAt(5) != '_') {
        throw new IllegalArgumentException(""Invalid locale format: "" + str);
    }
    return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
}",1.2272727272727273,-0.4401913875598088,3.0,-0.5,1.6666666666666667,1.9345238095238095,-0.8054968287526426,1.0,-0.02631578947368421,3.6758124283236224
camel,remotes/origin/bugs-dot-jar_CAMEL-3448_b345dd82,0,"public static ExceptionPolicyKey newInstance(Class exceptionClass, WhenDefinition when) {
    return new ExceptionPolicyKey(exceptionClass, when);
}",,"public static ExceptionPolicyKey newInstance(Class exceptionClass, WhenDefinition when) {
    return new ExceptionPolicyKey(exceptionClass, when);
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.9805496828752639,-0.5,0.5789473684210527,-0.16279340490885932
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-844_692efde2,0,"@Override
public boolean accept(Key k, Value v) {
    Text testVis = k.getColumnVisibility(tmpVis);
    if (testVis.getLength() == 0 && defaultVisibility.getLength() == 0)
        return true;
    else if (testVis.getLength() == 0)
        testVis = defaultVisibility;
    Boolean b = (Boolean) cache.get(testVis);
    if (b != null)
        return b;
    try {
        Boolean bb = ve.evaluate(new ColumnVisibility(testVis));
        cache.put(new Text(testVis), bb);
        return bb;
    } catch (VisibilityParseException e) {
        log.error(""Parse Error"", e);
        return false;
    }
}",,"@Override
public boolean accept(Key k, Value v) {
    Text testVis = k.getColumnVisibility(tmpVis);
    if (testVis.getLength() == 0 && defaultVisibility.getLength() == 0)
        return true;
    else if (testVis.getLength() == 0)
        testVis = defaultVisibility;
    Boolean b = (Boolean) cache.get(testVis);
    if (b != null)
        return b;
    try {
        Boolean bb = ve.evaluate(new ColumnVisibility(testVis));
        cache.put(new Text(testVis), bb);
        return bb;
    } catch (VisibilityParseException e) {
        log.error(""Parse Error"", e);
        return false;
    }
}",0.22727272727272727,-0.06220095693779921,0.2,-0.5,0.16666666666666666,0.2996031746031746,-0.24171952078928827,0.16666666666666666,0.0,0.3211447473821914
flink,remotes/origin/bugs-dot-jar_FLINK-2460_a17d4e82,1,"@Override
public boolean isReleased() {
    return isReleased;
}",,"@Override
public boolean isReleased() {
    return isReleased;
}",-0.45454545454545453,-0.6028708133971293,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,1.067371388301621,-0.5,1.8157894736842104,-0.16279340490885932
wicket,remotes/origin/bugs-dot-jar_WICKET-5720_2fc6a395,3,"/**
 *  Joins string fragments using the specified separator
 *
 *  @param separator
 *  @param fragments
 *  @return combined fragments
 */
public static String join(final String separator, final String... fragments) {
    if ((fragments == null) || (fragments.length < 1)) {
        // no elements
        return """";
    } else if (fragments.length < 2) {
        // single element
        return fragments[0];
    } else {
        // two or more elements
        StringBuilder buff = new StringBuilder(128);
        if (fragments[0] != null) {
            buff.append(fragments[0]);
        }
        for (int i = 1; i < fragments.length; i++) {
            String fragment = fragments[i];
            if ((fragments[i - 1] != null) || (fragment != null)) {
                boolean lhsClosed = fragments[i - 1].endsWith(separator);
                boolean rhsClosed = fragment.startsWith(separator);
                if (lhsClosed && rhsClosed) {
                    buff.append(fragment.substring(1));
                } else if (!lhsClosed && !rhsClosed) {
                    if (!Strings.isEmpty(fragment)) {
                        buff.append(separator);
                    }
                    buff.append(fragment);
                } else {
                    buff.append(fragment);
                }
            }
        }
        return buff.toString();
    }
}","/**
 *  Joins string fragments using the specified separator
 *
 *  @param separator
 *  @param fragments
 *  @return combined fragments
 */
","public static String join(final String separator, final String... fragments) {
    if ((fragments == null) || (fragments.length < 1)) {
                return """";
    } else if (fragments.length < 2) {
                return fragments[0];
    } else {
                StringBuilder buff = new StringBuilder(128);
        if (fragments[0] != null) {
            buff.append(fragments[0]);
        }
        for (int i = 1; i < fragments.length; i++) {
            String fragment = fragments[i];
            if ((fragments[i - 1] != null) || (fragment != null)) {
                boolean lhsClosed = fragments[i - 1].endsWith(separator);
                boolean rhsClosed = fragment.startsWith(separator);
                if (lhsClosed && rhsClosed) {
                    buff.append(fragment.substring(1));
                } else if (!lhsClosed && !rhsClosed) {
                    if (!Strings.isEmpty(fragment)) {
                        buff.append(separator);
                    }
                    buff.append(fragment);
                } else {
                    buff.append(fragment);
                }
            }
        }
        return buff.toString();
    }
}",0.7272727272727273,1.6315789473684212,1.0,2.5,1.1666666666666667,2.111111111111111,-0.5475687103594078,0.3333333333333333,-0.02631578947368421,2.7643805143986673
camel,remotes/origin/bugs-dot-jar_CAMEL-7209_5f78c646,1,"@Converter
public static ByteBuffer toByteBuffer(String value, Exchange exchange) {
    ByteBuffer buf = ByteBuffer.allocate(value.length());
    byte[] bytes = null;
    if (exchange != null) {
        String charsetName = exchange.getProperty(Exchange.CHARSET_NAME, String.class);
        if (charsetName != null) {
            try {
                bytes = value.getBytes(charsetName);
            } catch (UnsupportedEncodingException e) {
                LOG.warn(""Cannot convert the byte to String with the charset "" + charsetName, e);
            }
        }
    }
    if (bytes == null) {
        bytes = value.getBytes();
    }
    buf.put(bytes);
    return buf;
}",,"@Converter
public static ByteBuffer toByteBuffer(String value, Exchange exchange) {
    ByteBuffer buf = ByteBuffer.allocate(value.length());
    byte[] bytes = null;
    if (exchange != null) {
        String charsetName = exchange.getProperty(Exchange.CHARSET_NAME, String.class);
        if (charsetName != null) {
            try {
                bytes = value.getBytes(charsetName);
            } catch (UnsupportedEncodingException e) {
                LOG.warn(""Cannot convert the byte to String with the charset "" + charsetName, e);
            }
        }
    }
    if (bytes == null) {
        bytes = value.getBytes();
    }
    buf.put(bytes);
    return buf;
}",0.2727272727272727,0.8564593301435407,0.2,0.5,0.08333333333333333,0.44642857142857145,-0.24143763213530642,0.08333333333333333,0.05263157894736841,0.33892682814381947
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3433_b76b31f7,0,"@Override
public void acquiring() {
    if (lastRootRev == null) {
        // then we cannot and probably don't have to persist anything
        return;
    }
    // lastRootRev never null at this point
    final String id = JournalEntry.asId(lastRootRev);
    final JournalEntry existingEntry = docStore.find(Collection.JOURNAL, id);
    if (existingEntry != null) {
        // hence: nothing to be done here. return.
        return;
    }
    // otherwise store a new journal entry now
    docStore.create(JOURNAL, singletonList(changes.asUpdateOp(lastRootRev)));
}",,"@Override
public void acquiring() {
    if (lastRootRev == null) {
                return;
    }
        final String id = JournalEntry.asId(lastRootRev);
    final JournalEntry existingEntry = docStore.find(Collection.JOURNAL, id);
    if (existingEntry != null) {
                return;
    }
        docStore.create(JOURNAL, singletonList(changes.asUpdateOp(lastRootRev)));
}",-0.09090909090909091,-0.20574162679425848,-0.2,-0.5,-0.08333333333333333,-0.07936507936507939,0.1078224101479916,-0.08333333333333333,1.2894736842105263,-0.07504480674031684
commons-math,remotes/origin/bugs-dot-jar_MATH-1277_fb007815,3,"/**
 * Computes the Kendall's Tau rank correlation coefficient between the two arrays.
 *
 * @param xArray first data array
 * @param yArray second data array
 * @return Returns Kendall's Tau rank correlation coefficient for the two arrays
 * @throws DimensionMismatchException if the arrays lengths do not match
 */
public double correlation(final double[] xArray, final double[] yArray) throws DimensionMismatchException {
    if (xArray.length != yArray.length) {
        throw new DimensionMismatchException(xArray.length, yArray.length);
    }
    final int n = xArray.length;
    final long numPairs = sum(n - 1);
    @SuppressWarnings(""unchecked"")
    Pair<Double, Double>[] pairs = new Pair[n];
    for (int i = 0; i < n; i++) {
        pairs[i] = new Pair<Double, Double>(xArray[i], yArray[i]);
    }
    Arrays.sort(pairs, new Comparator<Pair<Double, Double>>() {

        @Override
        public int compare(Pair<Double, Double> pair1, Pair<Double, Double> pair2) {
            int compareFirst = pair1.getFirst().compareTo(pair2.getFirst());
            return compareFirst != 0 ? compareFirst : pair1.getSecond().compareTo(pair2.getSecond());
        }
    });
    long tiedXPairs = 0;
    long tiedXYPairs = 0;
    long consecutiveXTies = 1;
    long consecutiveXYTies = 1;
    Pair<Double, Double> prev = pairs[0];
    for (int i = 1; i < n; i++) {
        final Pair<Double, Double> curr = pairs[i];
        if (curr.getFirst().equals(prev.getFirst())) {
            consecutiveXTies++;
            if (curr.getSecond().equals(prev.getSecond())) {
                consecutiveXYTies++;
            } else {
                tiedXYPairs += sum(consecutiveXYTies - 1);
                consecutiveXYTies = 1;
            }
        } else {
            tiedXPairs += sum(consecutiveXTies - 1);
            consecutiveXTies = 1;
            tiedXYPairs += sum(consecutiveXYTies - 1);
            consecutiveXYTies = 1;
        }
        prev = curr;
    }
    tiedXPairs += sum(consecutiveXTies - 1);
    tiedXYPairs += sum(consecutiveXYTies - 1);
    int swaps = 0;
    @SuppressWarnings(""unchecked"")
    Pair<Double, Double>[] pairsDestination = new Pair[n];
    for (int segmentSize = 1; segmentSize < n; segmentSize <<= 1) {
        for (int offset = 0; offset < n; offset += 2 * segmentSize) {
            int i = offset;
            final int iEnd = FastMath.min(i + segmentSize, n);
            int j = iEnd;
            final int jEnd = FastMath.min(j + segmentSize, n);
            int copyLocation = offset;
            while (i < iEnd || j < jEnd) {
                if (i < iEnd) {
                    if (j < jEnd) {
                        if (pairs[i].getSecond().compareTo(pairs[j].getSecond()) <= 0) {
                            pairsDestination[copyLocation] = pairs[i];
                            i++;
                        } else {
                            pairsDestination[copyLocation] = pairs[j];
                            j++;
                            swaps += iEnd - i;
                        }
                    } else {
                        pairsDestination[copyLocation] = pairs[i];
                        i++;
                    }
                } else {
                    pairsDestination[copyLocation] = pairs[j];
                    j++;
                }
                copyLocation++;
            }
        }
        final Pair<Double, Double>[] pairsTemp = pairs;
        pairs = pairsDestination;
        pairsDestination = pairsTemp;
    }
    long tiedYPairs = 0;
    long consecutiveYTies = 1;
    prev = pairs[0];
    for (int i = 1; i < n; i++) {
        final Pair<Double, Double> curr = pairs[i];
        if (curr.getSecond().equals(prev.getSecond())) {
            consecutiveYTies++;
        } else {
            tiedYPairs += sum(consecutiveYTies - 1);
            consecutiveYTies = 1;
        }
        prev = curr;
    }
    tiedYPairs += sum(consecutiveYTies - 1);
    final long concordantMinusDiscordant = numPairs - tiedXPairs - tiedYPairs + tiedXYPairs - 2 * swaps;
    final double nonTiedPairsMultiplied = (numPairs - tiedXPairs) * (double) (numPairs - tiedYPairs);
    return concordantMinusDiscordant / FastMath.sqrt(nonTiedPairsMultiplied);
}","/**
 * Computes the Kendall's Tau rank correlation coefficient between the two arrays.
 *
 * @param xArray first data array
 * @param yArray second data array
 * @return Returns Kendall's Tau rank correlation coefficient for the two arrays
 * @throws DimensionMismatchException if the arrays lengths do not match
 */
","public double correlation(final double[] xArray, final double[] yArray) throws DimensionMismatchException {
    if (xArray.length != yArray.length) {
        throw new DimensionMismatchException(xArray.length, yArray.length);
    }
    final int n = xArray.length;
    final long numPairs = sum(n - 1);
    @SuppressWarnings(""unchecked"")
    Pair<Double, Double>[] pairs = new Pair[n];
    for (int i = 0; i < n; i++) {
        pairs[i] = new Pair<Double, Double>(xArray[i], yArray[i]);
    }
    Arrays.sort(pairs, new Comparator<Pair<Double, Double>>() {

        @Override
        public int compare(Pair<Double, Double> pair1, Pair<Double, Double> pair2) {
            int compareFirst = pair1.getFirst().compareTo(pair2.getFirst());
            return compareFirst != 0 ? compareFirst : pair1.getSecond().compareTo(pair2.getSecond());
        }
    });
    long tiedXPairs = 0;
    long tiedXYPairs = 0;
    long consecutiveXTies = 1;
    long consecutiveXYTies = 1;
    Pair<Double, Double> prev = pairs[0];
    for (int i = 1; i < n; i++) {
        final Pair<Double, Double> curr = pairs[i];
        if (curr.getFirst().equals(prev.getFirst())) {
            consecutiveXTies++;
            if (curr.getSecond().equals(prev.getSecond())) {
                consecutiveXYTies++;
            } else {
                tiedXYPairs += sum(consecutiveXYTies - 1);
                consecutiveXYTies = 1;
            }
        } else {
            tiedXPairs += sum(consecutiveXTies - 1);
            consecutiveXTies = 1;
            tiedXYPairs += sum(consecutiveXYTies - 1);
            consecutiveXYTies = 1;
        }
        prev = curr;
    }
    tiedXPairs += sum(consecutiveXTies - 1);
    tiedXYPairs += sum(consecutiveXYTies - 1);
    int swaps = 0;
    @SuppressWarnings(""unchecked"")
    Pair<Double, Double>[] pairsDestination = new Pair[n];
    for (int segmentSize = 1; segmentSize < n; segmentSize <<= 1) {
        for (int offset = 0; offset < n; offset += 2 * segmentSize) {
            int i = offset;
            final int iEnd = FastMath.min(i + segmentSize, n);
            int j = iEnd;
            final int jEnd = FastMath.min(j + segmentSize, n);
            int copyLocation = offset;
            while (i < iEnd || j < jEnd) {
                if (i < iEnd) {
                    if (j < jEnd) {
                        if (pairs[i].getSecond().compareTo(pairs[j].getSecond()) <= 0) {
                            pairsDestination[copyLocation] = pairs[i];
                            i++;
                        } else {
                            pairsDestination[copyLocation] = pairs[j];
                            j++;
                            swaps += iEnd - i;
                        }
                    } else {
                        pairsDestination[copyLocation] = pairs[i];
                        i++;
                    }
                } else {
                    pairsDestination[copyLocation] = pairs[j];
                    j++;
                }
                copyLocation++;
            }
        }
        final Pair<Double, Double>[] pairsTemp = pairs;
        pairs = pairsDestination;
        pairsDestination = pairsTemp;
    }
    long tiedYPairs = 0;
    long consecutiveYTies = 1;
    prev = pairs[0];
    for (int i = 1; i < n; i++) {
        final Pair<Double, Double> curr = pairs[i];
        if (curr.getSecond().equals(prev.getSecond())) {
            consecutiveYTies++;
        } else {
            tiedYPairs += sum(consecutiveYTies - 1);
            consecutiveYTies = 1;
        }
        prev = curr;
    }
    tiedYPairs += sum(consecutiveYTies - 1);
    final long concordantMinusDiscordant = numPairs - tiedXPairs - tiedYPairs + tiedXYPairs - 2 * swaps;
    final double nonTiedPairsMultiplied = (numPairs - tiedXPairs) * (double) (numPairs - tiedYPairs);
    return concordantMinusDiscordant / FastMath.sqrt(nonTiedPairsMultiplied);
}",3.772727272727273,1.9665071770334928,2.4,2.0,2.1666666666666665,6.067460317460318,-1.3475687103594076,2.0,-0.02631578947368421,33.64990001325472
commons-math,remotes/origin/bugs-dot-jar_MATH-727_d2777388,1,"/**
 * {@inheritDoc}
 */
@Override
public void integrate(final ExpandableStatefulODE equations, final double t) throws MathIllegalStateException, MathIllegalArgumentException {
    sanityChecks(equations, t);
    setEquations(equations);
    final boolean forward = t > equations.getTime();
    // create some internal working arrays
    final double[] y0 = equations.getCompleteState();
    final double[] y = y0.clone();
    final int stages = c.length + 1;
    final double[][] yDotK = new double[stages][y.length];
    final double[] yTmp = y0.clone();
    final double[] yDotTmp = new double[y.length];
    // set up an interpolator sharing the integrator arrays
    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();
    interpolator.reinitialize(this, yTmp, yDotK, forward, equations.getPrimaryMapper(), equations.getSecondaryMappers());
    interpolator.storeTime(equations.getTime());
    // set up integration control objects
    stepStart = equations.getTime();
    double hNew = 0;
    boolean firstTime = true;
    initIntegration(equations.getTime(), y0, t);
    // main integration loop
    isLastStep = false;
    do {
        interpolator.shift();
        // iterate over step size, ensuring local normalized error is smaller than 1
        double error = 10;
        while (error >= 1.0) {
            if (firstTime || !fsal) {
                // first stage
                computeDerivatives(stepStart, y, yDotK[0]);
            }
            if (firstTime) {
                final double[] scale = new double[mainSetDimension];
                if (vecAbsoluteTolerance == null) {
                    for (int i = 0; i < scale.length; ++i) {
                        scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);
                    }
                } else {
                    for (int i = 0; i < scale.length; ++i) {
                        scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);
                    }
                }
                hNew = initializeStep(forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]);
                firstTime = false;
            }
            stepSize = hNew;
            // next stages
            for (int k = 1; k < stages; ++k) {
                for (int j = 0; j < y0.length; ++j) {
                    double sum = a[k - 1][0] * yDotK[0][j];
                    for (int l = 1; l < k; ++l) {
                        sum += a[k - 1][l] * yDotK[l][j];
                    }
                    yTmp[j] = y[j] + stepSize * sum;
                }
                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);
            }
            // estimate the state at the end of the step
            for (int j = 0; j < y0.length; ++j) {
                double sum = b[0] * yDotK[0][j];
                for (int l = 1; l < stages; ++l) {
                    sum += b[l] * yDotK[l][j];
                }
                yTmp[j] = y[j] + stepSize * sum;
            }
            // estimate the error at the end of the step
            error = estimateError(yDotK, y, yTmp, stepSize);
            if (error >= 1.0) {
                // reject the step and attempt to reduce error by stepsize control
                final double factor = FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));
                hNew = filterStep(stepSize * factor, forward, false);
            }
        }
        // local error is small enough: accept the step, trigger events and step handlers
        interpolator.storeTime(stepStart + stepSize);
        System.arraycopy(yTmp, 0, y, 0, y0.length);
        System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);
        stepStart = acceptStep(interpolator, y, yDotTmp, t);
        System.arraycopy(y, 0, yTmp, 0, y.length);
        if (!isLastStep) {
            // prepare next step
            interpolator.storeTime(stepStart);
            if (fsal) {
                // save the last evaluation for the next step
                System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);
            }
            // stepsize control for next step
            final double factor = FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));
            final double scaledH = stepSize * factor;
            final double nextT = stepStart + scaledH;
            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
            hNew = filterStep(scaledH, forward, nextIsLast);
            final double filteredNextT = stepStart + hNew;
            final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);
            if (filteredNextIsLast) {
                hNew = t - stepStart;
            }
        }
    } while (!isLastStep);
    // dispatch results
    equations.setTime(stepStart);
    equations.setCompleteState(y);
    resetInternalState();
}","/**
 * {@inheritDoc}
 */
","@Override
public void integrate(final ExpandableStatefulODE equations, final double t) throws MathIllegalStateException, MathIllegalArgumentException {
    sanityChecks(equations, t);
    setEquations(equations);
    final boolean forward = t > equations.getTime();
        final double[] y0 = equations.getCompleteState();
    final double[] y = y0.clone();
    final int stages = c.length + 1;
    final double[][] yDotK = new double[stages][y.length];
    final double[] yTmp = y0.clone();
    final double[] yDotTmp = new double[y.length];
        final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();
    interpolator.reinitialize(this, yTmp, yDotK, forward, equations.getPrimaryMapper(), equations.getSecondaryMappers());
    interpolator.storeTime(equations.getTime());
        stepStart = equations.getTime();
    double hNew = 0;
    boolean firstTime = true;
    initIntegration(equations.getTime(), y0, t);
        isLastStep = false;
    do {
        interpolator.shift();
                double error = 10;
        while (error >= 1.0) {
            if (firstTime || !fsal) {
                                computeDerivatives(stepStart, y, yDotK[0]);
            }
            if (firstTime) {
                final double[] scale = new double[mainSetDimension];
                if (vecAbsoluteTolerance == null) {
                    for (int i = 0; i < scale.length; ++i) {
                        scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);
                    }
                } else {
                    for (int i = 0; i < scale.length; ++i) {
                        scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);
                    }
                }
                hNew = initializeStep(forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]);
                firstTime = false;
            }
            stepSize = hNew;
                        for (int k = 1; k < stages; ++k) {
                for (int j = 0; j < y0.length; ++j) {
                    double sum = a[k - 1][0] * yDotK[0][j];
                    for (int l = 1; l < k; ++l) {
                        sum += a[k - 1][l] * yDotK[l][j];
                    }
                    yTmp[j] = y[j] + stepSize * sum;
                }
                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);
            }
                        for (int j = 0; j < y0.length; ++j) {
                double sum = b[0] * yDotK[0][j];
                for (int l = 1; l < stages; ++l) {
                    sum += b[l] * yDotK[l][j];
                }
                yTmp[j] = y[j] + stepSize * sum;
            }
                        error = estimateError(yDotK, y, yTmp, stepSize);
            if (error >= 1.0) {
                                final double factor = FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));
                hNew = filterStep(stepSize * factor, forward, false);
            }
        }
                interpolator.storeTime(stepStart + stepSize);
        System.arraycopy(yTmp, 0, y, 0, y0.length);
        System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);
        stepStart = acceptStep(interpolator, y, yDotTmp, t);
        System.arraycopy(y, 0, yTmp, 0, y.length);
        if (!isLastStep) {
                        interpolator.storeTime(stepStart);
            if (fsal) {
                                System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);
            }
                        final double factor = FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));
            final double scaledH = stepSize * factor;
            final double nextT = stepStart + scaledH;
            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
            hNew = filterStep(scaledH, forward, nextIsLast);
            final double filteredNextT = stepStart + hNew;
            final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);
            if (filteredNextIsLast) {
                hNew = t - stepStart;
            }
        }
    } while (!isLastStep);
        equations.setTime(stepStart);
    equations.setCompleteState(y);
    resetInternalState();
}",3.4545454545454546,1.444976076555024,3.0,1.5,2.3333333333333335,4.327380952380952,-1.3670190274841434,2.9166666666666665,-0.02631578947368421,30.99054534557378
Closure,158,2,"CommandLineConfig setJscompWarning(List<String> jscompWarning) {
    this.jscompWarning.clear();
    this.jscompWarning.addAll(jscompWarning);
    return this;
}",,"CommandLineConfig setJscompWarning(List<String> jscompWarning) {
    this.jscompWarning.clear();
    this.jscompWarning.addAll(jscompWarning);
    return this;
}",-0.4090909090909091,-0.49282296650717716,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.723749119097956,-0.3333333333333333,0.07894736842105263,-0.16279340490885932
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-385_7c2ce5cf,1,"/**
 * Returns the next potential rollover time.
 * @param current The current time.
 * @param increment The increment to the next time.
 * @param modulus If true the time will be rounded to occur on a boundary aligned with the increment.
 * @return the next potential rollover time and the timestamp for the target file.
 */
public long getNextTime(final long current, final int increment, final boolean modulus) {
    prevFileTime = nextFileTime;
    long nextTime;
    if (frequency == null) {
        throw new IllegalStateException(""Pattern does not contain a date"");
    }
    final Calendar currentCal = Calendar.getInstance();
    currentCal.setTimeInMillis(current);
    final Calendar cal = Calendar.getInstance();
    cal.set(currentCal.get(Calendar.YEAR), 0, 1, 0, 0, 0);
    cal.set(Calendar.MILLISECOND, 0);
    if (frequency == RolloverFrequency.ANNUALLY) {
        increment(cal, Calendar.YEAR, increment, modulus);
        nextTime = cal.getTimeInMillis();
        cal.add(Calendar.YEAR, -1);
        nextFileTime = cal.getTimeInMillis();
        return nextTime;
    }
    if (frequency == RolloverFrequency.MONTHLY) {
        increment(cal, Calendar.MONTH, increment, modulus);
        nextTime = cal.getTimeInMillis();
        cal.add(Calendar.MONTH, -1);
        nextFileTime = cal.getTimeInMillis();
        return nextTime;
    }
    if (frequency == RolloverFrequency.WEEKLY) {
        increment(cal, Calendar.WEEK_OF_YEAR, increment, modulus);
        nextTime = cal.getTimeInMillis();
        cal.add(Calendar.WEEK_OF_YEAR, -1);
        nextFileTime = cal.getTimeInMillis();
        return nextTime;
    }
    cal.set(Calendar.DAY_OF_YEAR, currentCal.get(Calendar.DAY_OF_YEAR));
    if (frequency == RolloverFrequency.DAILY) {
        increment(cal, Calendar.DAY_OF_YEAR, increment, modulus);
        nextTime = cal.getTimeInMillis();
        cal.add(Calendar.DAY_OF_YEAR, -1);
        nextFileTime = cal.getTimeInMillis();
        return nextTime;
    }
    cal.set(Calendar.HOUR, currentCal.get(Calendar.HOUR));
    if (frequency == RolloverFrequency.HOURLY) {
        increment(cal, Calendar.HOUR, increment, modulus);
        nextTime = cal.getTimeInMillis();
        cal.add(Calendar.HOUR, -1);
        nextFileTime = cal.getTimeInMillis();
        return nextTime;
    }
    cal.set(Calendar.MINUTE, currentCal.get(Calendar.MINUTE));
    if (frequency == RolloverFrequency.EVERY_MINUTE) {
        increment(cal, Calendar.MINUTE, increment, modulus);
        nextTime = cal.getTimeInMillis();
        cal.add(Calendar.MINUTE, -1);
        nextFileTime = cal.getTimeInMillis();
        return nextTime;
    }
    cal.set(Calendar.SECOND, currentCal.get(Calendar.SECOND));
    if (frequency == RolloverFrequency.EVERY_SECOND) {
        increment(cal, Calendar.SECOND, increment, modulus);
        nextTime = cal.getTimeInMillis();
        cal.add(Calendar.SECOND, -1);
        nextFileTime = cal.getTimeInMillis();
        return nextTime;
    }
    increment(cal, Calendar.MILLISECOND, increment, modulus);
    nextTime = cal.getTimeInMillis();
    cal.add(Calendar.MILLISECOND, -1);
    nextFileTime = cal.getTimeInMillis();
    return nextTime;
}","/**
 * Returns the next potential rollover time.
 * @param current The current time.
 * @param increment The increment to the next time.
 * @param modulus If true the time will be rounded to occur on a boundary aligned with the increment.
 * @return the next potential rollover time and the timestamp for the target file.
 */
","public long getNextTime(final long current, final int increment, final boolean modulus) {
    prevFileTime = nextFileTime;
    long nextTime;
    if (frequency == null) {
        throw new IllegalStateException(""Pattern does not contain a date"");
    }
    final Calendar currentCal = Calendar.getInstance();
    currentCal.setTimeInMillis(current);
    final Calendar cal = Calendar.getInstance();
    cal.set(currentCal.get(Calendar.YEAR), 0, 1, 0, 0, 0);
    cal.set(Calendar.MILLISECOND, 0);
    if (frequency == RolloverFrequency.ANNUALLY) {
        increment(cal, Calendar.YEAR, increment, modulus);
        nextTime = cal.getTimeInMillis();
        cal.add(Calendar.YEAR, -1);
        nextFileTime = cal.getTimeInMillis();
        return nextTime;
    }
    if (frequency == RolloverFrequency.MONTHLY) {
        increment(cal, Calendar.MONTH, increment, modulus);
        nextTime = cal.getTimeInMillis();
        cal.add(Calendar.MONTH, -1);
        nextFileTime = cal.getTimeInMillis();
        return nextTime;
    }
    if (frequency == RolloverFrequency.WEEKLY) {
        increment(cal, Calendar.WEEK_OF_YEAR, increment, modulus);
        nextTime = cal.getTimeInMillis();
        cal.add(Calendar.WEEK_OF_YEAR, -1);
        nextFileTime = cal.getTimeInMillis();
        return nextTime;
    }
    cal.set(Calendar.DAY_OF_YEAR, currentCal.get(Calendar.DAY_OF_YEAR));
    if (frequency == RolloverFrequency.DAILY) {
        increment(cal, Calendar.DAY_OF_YEAR, increment, modulus);
        nextTime = cal.getTimeInMillis();
        cal.add(Calendar.DAY_OF_YEAR, -1);
        nextFileTime = cal.getTimeInMillis();
        return nextTime;
    }
    cal.set(Calendar.HOUR, currentCal.get(Calendar.HOUR));
    if (frequency == RolloverFrequency.HOURLY) {
        increment(cal, Calendar.HOUR, increment, modulus);
        nextTime = cal.getTimeInMillis();
        cal.add(Calendar.HOUR, -1);
        nextFileTime = cal.getTimeInMillis();
        return nextTime;
    }
    cal.set(Calendar.MINUTE, currentCal.get(Calendar.MINUTE));
    if (frequency == RolloverFrequency.EVERY_MINUTE) {
        increment(cal, Calendar.MINUTE, increment, modulus);
        nextTime = cal.getTimeInMillis();
        cal.add(Calendar.MINUTE, -1);
        nextFileTime = cal.getTimeInMillis();
        return nextTime;
    }
    cal.set(Calendar.SECOND, currentCal.get(Calendar.SECOND));
    if (frequency == RolloverFrequency.EVERY_SECOND) {
        increment(cal, Calendar.SECOND, increment, modulus);
        nextTime = cal.getTimeInMillis();
        cal.add(Calendar.SECOND, -1);
        nextFileTime = cal.getTimeInMillis();
        return nextTime;
    }
    increment(cal, Calendar.MILLISECOND, increment, modulus);
    nextTime = cal.getTimeInMillis();
    cal.add(Calendar.MILLISECOND, -1);
    nextFileTime = cal.getTimeInMillis();
    return nextTime;
}",2.5454545454545454,-0.368421052631579,1.2,-0.5,0.3333333333333333,0.8353174603174603,-1.0955602536997884,3.3333333333333335,-0.02631578947368421,3.9140609602185297
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-278_db19e70f,1,"private Status internalGetPropertyStatus(String name) {
    NodeState baseState = getBaseState();
    boolean exists = internalGetProperty(name) != null;
    if (baseState == null) {
        // This instance is NEW...
        if (exists) {
            // ...so all children are new
            return Status.NEW;
        } else {
            // ...unless they don't exist.
            return null;
        }
    } else {
        if (exists) {
            // We have the property...
            if (baseState.getProperty(name) == null) {
                // ...but didn't have it before. So its NEW.
                return Status.NEW;
            } else {
                // ... and did have it before. So...
                PropertyState base = baseState.getProperty(name);
                PropertyState head = getProperty(name);
                if (base == null ? head == null : base.equals(head)) {
                    // ...it's EXISTING if it hasn't changed
                    return Status.EXISTING;
                } else {
                    // ...and MODIFIED otherwise.
                    return Status.MODIFIED;
                }
            }
        } else {
            // We don't have the property
            if (baseState.getProperty(name) == null) {
                // ...and didn't have it before. So it doesn't exist.
                return null;
            } else {
                // ...but did have it before. So it's REMOVED
                return Status.REMOVED;
            }
        }
    }
}",,"private Status internalGetPropertyStatus(String name) {
    NodeState baseState = getBaseState();
    boolean exists = internalGetProperty(name) != null;
    if (baseState == null) {
                if (exists) {
                        return Status.NEW;
        } else {
                        return null;
        }
    } else {
        if (exists) {
                        if (baseState.getProperty(name) == null) {
                                return Status.NEW;
            } else {
                                PropertyState base = baseState.getProperty(name);
                PropertyState head = getProperty(name);
                if (base == null ? head == null : base.equals(head)) {
                                        return Status.EXISTING;
                } else {
                                        return Status.MODIFIED;
                }
            }
        } else {
                        if (baseState.getProperty(name) == null) {
                                return null;
            } else {
                                return Status.REMOVED;
            }
        }
    }
}",0.7727272727272727,1.1578947368421053,0.8,1.0,0.5833333333333334,0.15079365079365079,-0.4686398872445383,0.08333333333333333,-0.02631578947368421,0.17339257620027315
maven,remotes/origin/bugs-dot-jar_MNG-5075_2eb419ed,1,"public MavenProject getParent() {
    if (parent == null) {
        /*
             * TODO: This is suboptimal. Without a cache in the project builder, rebuilding the parent chain currently
             * causes O(n^2) parser invocations for an inheritance hierarchy of depth n.
             */
        if (parentFile != null) {
            checkProjectBuildingRequest();
            ProjectBuildingRequest request = new DefaultProjectBuildingRequest(projectBuilderConfiguration);
            request.setRemoteRepositories(getRemoteArtifactRepositories());
            try {
                parent = mavenProjectBuilder.build(parentFile, request).getProject();
            } catch (ProjectBuildingException e) {
                throw new IllegalStateException(""Failed to build parent project for "" + getId(), e);
            }
        } else if (model.getParent() != null) {
            checkProjectBuildingRequest();
            ProjectBuildingRequest request = new DefaultProjectBuildingRequest(projectBuilderConfiguration);
            request.setRemoteRepositories(getRemoteArtifactRepositories());
            try {
                parent = mavenProjectBuilder.build(getParentArtifact(), request).getProject();
            } catch (ProjectBuildingException e) {
                throw new IllegalStateException(""Failed to build parent project for "" + getId(), e);
            }
        }
    }
    return parent;
}",,"public MavenProject getParent() {
    if (parent == null) {
                if (parentFile != null) {
            checkProjectBuildingRequest();
            ProjectBuildingRequest request = new DefaultProjectBuildingRequest(projectBuilderConfiguration);
            request.setRemoteRepositories(getRemoteArtifactRepositories());
            try {
                parent = mavenProjectBuilder.build(parentFile, request).getProject();
            } catch (ProjectBuildingException e) {
                throw new IllegalStateException(""Failed to build parent project for "" + getId(), e);
            }
        } else if (model.getParent() != null) {
            checkProjectBuildingRequest();
            ProjectBuildingRequest request = new DefaultProjectBuildingRequest(projectBuilderConfiguration);
            request.setRemoteRepositories(getRemoteArtifactRepositories());
            try {
                parent = mavenProjectBuilder.build(getParentArtifact(), request).getProject();
            } catch (ProjectBuildingException e) {
                throw new IllegalStateException(""Failed to build parent project for "" + getId(), e);
            }
        }
    }
    return parent;
}",0.45454545454545453,0.7799043062200957,0.8,1.0,0.08333333333333333,0.5138888888888888,-0.3541930937279773,0.6666666666666666,-0.02631578947368421,0.42051140194671593
commons-math,remotes/origin/bugs-dot-jar_MATH-344_a0b4b4b7,0,"/**
 * Find a zero in the given interval with an initial guess.
 * <p>Throws <code>IllegalArgumentException</code> if the values of the
 * function at the three points have the same sign (note that it is
 * allowed to have endpoints with the same sign if the initial point has
 * opposite sign function-wise).</p>
 *
 * @param f function to solve.
 * @param min the lower bound for the interval.
 * @param max the upper bound for the interval.
 * @param initial the start value to use (must be set to min if no
 * initial point is known).
 * @return the value where the function is zero
 * @throws MaxIterationsExceededException the maximum iteration count
 * is exceeded
 * @throws FunctionEvaluationException if an error occurs evaluating
 *  the function
 * @throws IllegalArgumentException if initial is not between min and max
 * (even if it <em>is</em> a root)
 */
public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial) throws MaxIterationsExceededException, FunctionEvaluationException {
    clearResult();
    verifySequence(min, initial, max);
    // return the initial guess if it is good enough
    double yInitial = f.value(initial);
    if (Math.abs(yInitial) <= functionValueAccuracy) {
        setResult(initial, 0);
        return result;
    }
    // return the first endpoint if it is good enough
    double yMin = f.value(min);
    if (Math.abs(yMin) <= functionValueAccuracy) {
        setResult(yMin, 0);
        return result;
    }
    // reduce interval if min and initial bracket the root
    if (yInitial * yMin < 0) {
        return solve(f, min, yMin, initial, yInitial, min, yMin);
    }
    // return the second endpoint if it is good enough
    double yMax = f.value(max);
    if (Math.abs(yMax) <= functionValueAccuracy) {
        setResult(yMax, 0);
        return result;
    }
    // reduce interval if initial and max bracket the root
    if (yInitial * yMax < 0) {
        return solve(f, initial, yInitial, max, yMax, initial, yInitial);
    }
    if (yMin * yMax > 0) {
        throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE, min, max, yMin, yMax);
    }
    // full Brent algorithm starting with provided initial guess
    return solve(f, min, yMin, max, yMax, initial, yInitial);
}","/**
 * Find a zero in the given interval with an initial guess.
 * <p>Throws <code>IllegalArgumentException</code> if the values of the
 * function at the three points have the same sign (note that it is
 * allowed to have endpoints with the same sign if the initial point has
 * opposite sign function-wise).</p>
 *
 * @param f function to solve.
 * @param min the lower bound for the interval.
 * @param max the upper bound for the interval.
 * @param initial the start value to use (must be set to min if no
 * initial point is known).
 * @return the value where the function is zero
 * @throws MaxIterationsExceededException the maximum iteration count
 * is exceeded
 * @throws FunctionEvaluationException if an error occurs evaluating
 *  the function
 * @throws IllegalArgumentException if initial is not between min and max
 * (even if it <em>is</em> a root)
 */
","public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial) throws MaxIterationsExceededException, FunctionEvaluationException {
    clearResult();
    verifySequence(min, initial, max);
        double yInitial = f.value(initial);
    if (Math.abs(yInitial) <= functionValueAccuracy) {
        setResult(initial, 0);
        return result;
    }
        double yMin = f.value(min);
    if (Math.abs(yMin) <= functionValueAccuracy) {
        setResult(yMin, 0);
        return result;
    }
        if (yInitial * yMin < 0) {
        return solve(f, min, yMin, initial, yInitial, min, yMin);
    }
        double yMax = f.value(max);
    if (Math.abs(yMax) <= functionValueAccuracy) {
        setResult(yMax, 0);
        return result;
    }
        if (yInitial * yMax < 0) {
        return solve(f, initial, yInitial, max, yMax, initial, yInitial);
    }
    if (yMin * yMax > 0) {
        throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE, min, max, yMin, yMax);
    }
        return solve(f, min, yMin, max, yMax, initial, yInitial);
}",0.6818181818181818,-0.3444976076555025,0.8,-0.5,0.6666666666666666,1.123015873015873,-0.5216349541930935,0.75,-0.02631578947368421,1.5505748517487594
camel,remotes/origin/bugs-dot-jar_CAMEL-5699_6d63a502,3,"public String format(Exchange exchange) {
    Message in = exchange.getIn();
    StringBuilder sb = new StringBuilder();
    if (showAll || showExchangeId) {
        if (multiline) {
            sb.append(LS);
        }
        sb.append("", Id:"").append(exchange.getExchangeId());
    }
    if (showAll || showExchangePattern) {
        if (multiline) {
            sb.append(LS);
        }
        sb.append("", ExchangePattern:"").append(exchange.getPattern());
    }
    if (showAll || showProperties) {
        if (multiline) {
            sb.append(LS);
        }
        sb.append("", Properties:"").append(exchange.getProperties());
    }
    if (showAll || showHeaders) {
        if (multiline) {
            sb.append(LS);
        }
        sb.append("", Headers:"").append(in.getHeaders());
    }
    if (showAll || showBodyType) {
        if (multiline) {
            sb.append(LS);
        }
        sb.append("", BodyType:"").append(getBodyTypeAsString(in));
    }
    if (showAll || showBody) {
        if (multiline) {
            sb.append(LS);
        }
        sb.append("", Body:"").append(getBodyAsString(in));
    }
    if (showAll || showException || showCaughtException) {
        // try exception on exchange first
        Exception exception = exchange.getException();
        boolean caught = false;
        if ((showAll || showCaughtException) && exception == null) {
            // fallback to caught exception
            exception = exchange.getProperty(Exchange.EXCEPTION_CAUGHT, Exception.class);
            caught = true;
        }
        if (exception != null) {
            if (multiline) {
                sb.append(LS);
            }
            if (caught) {
                sb.append("", CaughtExceptionType:"").append(exception.getClass().getCanonicalName());
                sb.append("", CaughtExceptionMessage:"").append(exception.getMessage());
            } else {
                sb.append("", ExceptionType:"").append(exception.getClass().getCanonicalName());
                sb.append("", ExceptionMessage:"").append(exception.getMessage());
            }
            if (showAll || showStackTrace) {
                StringWriter sw = new StringWriter();
                exception.printStackTrace(new PrintWriter(sw));
                sb.append("", StackTrace:"").append(sw.toString());
            }
        }
    }
    if (showAll || showOut) {
        if (exchange.hasOut()) {
            Message out = exchange.getOut();
            if (showAll || showHeaders) {
                if (multiline) {
                    sb.append(LS);
                }
                sb.append("", OutHeaders:"").append(out.getHeaders());
            }
            if (showAll || showBodyType) {
                if (multiline) {
                    sb.append(LS);
                }
                sb.append("", OutBodyType:"").append(getBodyTypeAsString(out));
            }
            if (showAll || showBody) {
                if (multiline) {
                    sb.append(LS);
                }
                sb.append("", OutBody:"").append(getBodyAsString(out));
            }
        } else {
            if (multiline) {
                sb.append(LS);
            }
            sb.append("", Out: null"");
        }
    }
    if (maxChars > 0) {
        StringBuilder answer = new StringBuilder();
        for (String s : sb.toString().split(LS)) {
            if (s != null) {
                if (s.length() > maxChars) {
                    s = s.substring(0, maxChars);
                    answer.append(s).append(""..."");
                } else {
                    answer.append(s);
                }
                if (multiline) {
                    answer.append(LS);
                }
            }
        }
        // get rid of the leading space comma if needed
        return ""Exchange["" + (multiline ? answer.append(']').toString() : answer.toString().substring(2) + ""]"");
    }
    // get rid of the leading space comma if needed
    return ""Exchange["" + (multiline ? sb.append(']').toString() : sb.toString().substring(2) + ""]"");
}",,"public String format(Exchange exchange) {
    Message in = exchange.getIn();
    StringBuilder sb = new StringBuilder();
    if (showAll || showExchangeId) {
        if (multiline) {
            sb.append(LS);
        }
        sb.append("", Id:"").append(exchange.getExchangeId());
    }
    if (showAll || showExchangePattern) {
        if (multiline) {
            sb.append(LS);
        }
        sb.append("", ExchangePattern:"").append(exchange.getPattern());
    }
    if (showAll || showProperties) {
        if (multiline) {
            sb.append(LS);
        }
        sb.append("", Properties:"").append(exchange.getProperties());
    }
    if (showAll || showHeaders) {
        if (multiline) {
            sb.append(LS);
        }
        sb.append("", Headers:"").append(in.getHeaders());
    }
    if (showAll || showBodyType) {
        if (multiline) {
            sb.append(LS);
        }
        sb.append("", BodyType:"").append(getBodyTypeAsString(in));
    }
    if (showAll || showBody) {
        if (multiline) {
            sb.append(LS);
        }
        sb.append("", Body:"").append(getBodyAsString(in));
    }
    if (showAll || showException || showCaughtException) {
                Exception exception = exchange.getException();
        boolean caught = false;
        if ((showAll || showCaughtException) && exception == null) {
                        exception = exchange.getProperty(Exchange.EXCEPTION_CAUGHT, Exception.class);
            caught = true;
        }
        if (exception != null) {
            if (multiline) {
                sb.append(LS);
            }
            if (caught) {
                sb.append("", CaughtExceptionType:"").append(exception.getClass().getCanonicalName());
                sb.append("", CaughtExceptionMessage:"").append(exception.getMessage());
            } else {
                sb.append("", ExceptionType:"").append(exception.getClass().getCanonicalName());
                sb.append("", ExceptionMessage:"").append(exception.getMessage());
            }
            if (showAll || showStackTrace) {
                StringWriter sw = new StringWriter();
                exception.printStackTrace(new PrintWriter(sw));
                sb.append("", StackTrace:"").append(sw.toString());
            }
        }
    }
    if (showAll || showOut) {
        if (exchange.hasOut()) {
            Message out = exchange.getOut();
            if (showAll || showHeaders) {
                if (multiline) {
                    sb.append(LS);
                }
                sb.append("", OutHeaders:"").append(out.getHeaders());
            }
            if (showAll || showBodyType) {
                if (multiline) {
                    sb.append(LS);
                }
                sb.append("", OutBodyType:"").append(getBodyTypeAsString(out));
            }
            if (showAll || showBody) {
                if (multiline) {
                    sb.append(LS);
                }
                sb.append("", OutBody:"").append(getBodyAsString(out));
            }
        } else {
            if (multiline) {
                sb.append(LS);
            }
            sb.append("", Out: null"");
        }
    }
    if (maxChars > 0) {
        StringBuilder answer = new StringBuilder();
        for (String s : sb.toString().split(LS)) {
            if (s != null) {
                if (s.length() > maxChars) {
                    s = s.substring(0, maxChars);
                    answer.append(s).append(""..."");
                } else {
                    answer.append(s);
                }
                if (multiline) {
                    answer.append(LS);
                }
            }
        }
                return ""Exchange["" + (multiline ? answer.append(']').toString() : answer.toString().substring(2) + ""]"");
    }
        return ""Exchange["" + (multiline ? sb.append(']').toString() : sb.toString().substring(2) + ""]"");
}",4.409090909090909,0.923444976076555,6.2,1.0,5.083333333333333,1.6626984126984128,-1.5037350246652568,6.0,-0.02631578947368421,8.611379471309277
camel,remotes/origin/bugs-dot-jar_CAMEL-3394_18e1a142,3,"/**
 * Common work which must be done when we are done multicasting.
 * <p/>
 * This logic applies for both running synchronous and asynchronous as there are multiple exist points
 * when using the asynchronous routing engine. And therefore we want the logic in one method instead
 * of being scattered.
 *
 * @param original    the original exchange
 * @param subExchange the current sub exchange, can be <tt>null</tt> for the synchronous part
 * @param callback    the callback
 * @param doneSync    the <tt>doneSync</tt> parameter to call on callback
 */
protected void doDone(Exchange original, Exchange subExchange, AsyncCallback callback, boolean doneSync) {
    // cleanup any per exchange aggregation strategy
    removeAggregationStrategyFromExchange(original);
    if (original.getException() != null) {
        // multicast uses error handling on its output processors and they have tried to redeliver
        // so we shall signal back to the other error handlers that we are exhausted and they should not
        // also try to redeliver as we will then do that twice
        original.setProperty(Exchange.REDELIVERY_EXHAUSTED, Boolean.TRUE);
    }
    if (subExchange != null) {
        // and copy the current result to original so it will contain this exception
        ExchangeHelper.copyResults(original, subExchange);
    }
    callback.done(doneSync);
}","/**
 * Common work which must be done when we are done multicasting.
 * <p/>
 * This logic applies for both running synchronous and asynchronous as there are multiple exist points
 * when using the asynchronous routing engine. And therefore we want the logic in one method instead
 * of being scattered.
 *
 * @param original    the original exchange
 * @param subExchange the current sub exchange, can be <tt>null</tt> for the synchronous part
 * @param callback    the callback
 * @param doneSync    the <tt>doneSync</tt> parameter to call on callback
 */
","protected void doDone(Exchange original, Exchange subExchange, AsyncCallback callback, boolean doneSync) {
        removeAggregationStrategyFromExchange(original);
    if (original.getException() != null) {
                                original.setProperty(Exchange.REDELIVERY_EXHAUSTED, Boolean.TRUE);
    }
    if (subExchange != null) {
                ExchangeHelper.copyResults(original, subExchange);
    }
    callback.done(doneSync);
}",-0.18181818181818182,-0.2200956937799045,-0.2,-0.5,-0.08333333333333333,-0.3650793650793651,0.19126145172656786,-0.08333333333333333,0.0,-0.16279340490885932
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2642_36fe017c,0,"public void dispose() {
    runBackgroundOperations();
    if (!isDisposed.getAndSet(true)) {
        synchronized (isDisposed) {
            isDisposed.notifyAll();
        }
        try {
            backgroundThread.join();
        } catch (InterruptedException e) {
        // ignore
        }
        if (leaseUpdateThread != null) {
            try {
                leaseUpdateThread.join();
            } catch (InterruptedException e) {
            // ignore
            }
        }
        if (clusterNodeInfo != null) {
            clusterNodeInfo.dispose();
        }
        store.dispose();
        LOG.info(""Disposed DocumentNodeStore with clusterNodeId: {}"", clusterId);
        if (blobStore instanceof Closeable) {
            try {
                ((Closeable) blobStore).close();
            } catch (IOException ex) {
                LOG.debug(""Error closing blob store "" + blobStore, ex);
            }
        }
    }
    if (persistentCache != null) {
        persistentCache.close();
    }
}",,"public void dispose() {
    runBackgroundOperations();
    if (!isDisposed.getAndSet(true)) {
        synchronized (isDisposed) {
            isDisposed.notifyAll();
        }
        try {
            backgroundThread.join();
        } catch (InterruptedException e) {
                }
        if (leaseUpdateThread != null) {
            try {
                leaseUpdateThread.join();
            } catch (InterruptedException e) {
                        }
        }
        if (clusterNodeInfo != null) {
            clusterNodeInfo.dispose();
        }
        store.dispose();
        LOG.info(""Disposed DocumentNodeStore with clusterNodeId: {}"", clusterId);
        if (blobStore instanceof Closeable) {
            try {
                ((Closeable) blobStore).close();
            } catch (IOException ex) {
                LOG.debug(""Error closing blob store "" + blobStore, ex);
            }
        }
    }
    if (persistentCache != null) {
        persistentCache.close();
    }
}",0.8636363636363636,0.47846889952153115,1.0,0.5,0.4166666666666667,-0.03373015873015876,-0.4841437632135305,0.4166666666666667,0.05263157894736841,0.025728001475308748
Closure,169,2,"private boolean hasAlternate(JSType type, boolean tolerateUnknowns) {
    for (JSType alternate : alternates) {
        if (alternate.checkEquivalenceHelper(type, tolerateUnknowns)) {
            return true;
        }
    }
    return false;
}",,"private boolean hasAlternate(JSType type, boolean tolerateUnknowns) {
    for (JSType alternate : alternates) {
        if (alternate.checkEquivalenceHelper(type, tolerateUnknowns)) {
            return true;
        }
    }
    return false;
}",-0.2727272727272727,0.42105263157894735,-0.2,0.0,-0.08333333333333333,-0.3650793650793651,0.4458069062720224,-0.4166666666666667,0.2368421052631579,-0.16279340490885932
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-1008_0c20bfd8,1,"/**
 * Add the class designated by the fully qualified class name provided to the set of
 * resolved classes if and only if it is approved by the Test supplied.
 *
 * @param test the test used to determine if the class matches
 * @param fqn the fully qualified name of a class
 */
protected void addIfMatching(final Test test, final String fqn) {
    try {
        final ClassLoader loader = getClassLoader();
        if (test.doesMatchClass()) {
            final String externalName = fqn.substring(0, fqn.indexOf('.')).replace('/', '.');
            if (LOGGER.isDebugEnabled()) {
                LOGGER.debug(""Checking to see if class "" + externalName + "" matches criteria ["" + test + ']');
            }
            final Class<?> type = loader.loadClass(externalName);
            if (test.matches(type)) {
                classMatches.add(type);
            }
        }
        if (test.doesMatchResource()) {
            URL url = loader.getResource(fqn);
            if (url == null) {
                url = loader.getResource(fqn.substring(1));
            }
            if (url != null && test.matches(url.toURI())) {
                resourceMatches.add(url.toURI());
            }
        }
    } catch (final Throwable t) {
        LOGGER.warn(""Could not examine class '"" + fqn, t);
    }
}","/**
 * Add the class designated by the fully qualified class name provided to the set of
 * resolved classes if and only if it is approved by the Test supplied.
 *
 * @param test the test used to determine if the class matches
 * @param fqn the fully qualified name of a class
 */
","protected void addIfMatching(final Test test, final String fqn) {
    try {
        final ClassLoader loader = getClassLoader();
        if (test.doesMatchClass()) {
            final String externalName = fqn.substring(0, fqn.indexOf('.')).replace('/', '.');
            if (LOGGER.isDebugEnabled()) {
                LOGGER.debug(""Checking to see if class "" + externalName + "" matches criteria ["" + test + ']');
            }
            final Class<?> type = loader.loadClass(externalName);
            if (test.matches(type)) {
                classMatches.add(type);
            }
        }
        if (test.doesMatchResource()) {
            URL url = loader.getResource(fqn);
            if (url == null) {
                url = loader.getResource(fqn.substring(1));
            }
            if (url != null && test.matches(url.toURI())) {
                resourceMatches.add(url.toURI());
            }
        }
    } catch (final Throwable t) {
        LOGGER.warn(""Could not examine class '"" + fqn, t);
    }
}",0.5454545454545454,0.7081339712918658,0.8,0.5,0.8333333333333334,0.35119047619047616,-0.4621564482029596,1.0833333333333333,-0.02631578947368421,0.6093693631391802
wicket,remotes/origin/bugs-dot-jar_WICKET-3272_c86b972a,1,"/**
 *  Extracts the {@link PageComponentInfo} from the URL. The {@link PageComponentInfo} is encoded
 *  as the very first query parameter and the parameter consists of name only (no value).
 *
 *  @param url
 *
 *  @return PageComponentInfo instance if one was encoded in URL, <code>null</code> otherwise.
 */
protected PageComponentInfo getPageComponentInfo(Url url) {
    if (url == null) {
        throw new IllegalStateException(""Argument 'url' may not be null."");
    }
    if (url.getQueryParameters().size() > 0) {
        QueryParameter param = url.getQueryParameters().get(0);
        if (Strings.isEmpty(param.getValue())) {
            return PageComponentInfo.parse(param.getName());
        }
    }
    return null;
}","/**
 *  Extracts the {@link PageComponentInfo} from the URL. The {@link PageComponentInfo} is encoded
 *  as the very first query parameter and the parameter consists of name only (no value).
 *
 *  @param url
 *
 *  @return PageComponentInfo instance if one was encoded in URL, <code>null</code> otherwise.
 */
","protected PageComponentInfo getPageComponentInfo(Url url) {
    if (url == null) {
        throw new IllegalStateException(""Argument 'url' may not be null."");
    }
    if (url.getQueryParameters().size() > 0) {
        QueryParameter param = url.getQueryParameters().get(0);
        if (Strings.isEmpty(param.getValue())) {
            return PageComponentInfo.parse(param.getName());
        }
    }
    return null;
}",-0.09090909090909091,0.1961722488038276,0.2,0.0,0.16666666666666666,-0.07341269841269843,0.0878083157152923,0.16666666666666666,0.31578947368421056,-0.06886695135515176
wicket,remotes/origin/bugs-dot-jar_WICKET-3196_f1c0f263,3,"/**
 *  Returns <code>true</code> if the path is valid. A <code>null</code> value is considered
 *  invalid.
 *
 *  @param path
 *             a path value to validate.
 *  @return <code>true</code> if path is valid.
 */
protected boolean isValidPath(String path) {
    if (path == null) {
        return false;
    }
    Matcher pathMatcher = Pattern.compile(PATH_PATTERN).matcher(path);
    if (!pathMatcher.matches()) {
        return false;
    }
    int slash2Count = countToken(""//"", path);
    if (isOff(ALLOW_2_SLASHES) && (slash2Count > 0)) {
        return false;
    }
    int slashCount = countToken(""/"", path);
    int dot2Count = countToken("".."", path);
    if (dot2Count > 0) {
        if ((slashCount - slash2Count - 1) <= dot2Count) {
            return false;
        }
    }
    return true;
}","/**
 *  Returns <code>true</code> if the path is valid. A <code>null</code> value is considered
 *  invalid.
 *
 *  @param path
 *             a path value to validate.
 *  @return <code>true</code> if path is valid.
 */
","protected boolean isValidPath(String path) {
    if (path == null) {
        return false;
    }
    Matcher pathMatcher = Pattern.compile(PATH_PATTERN).matcher(path);
    if (!pathMatcher.matches()) {
        return false;
    }
    int slash2Count = countToken(""//"", path);
    if (isOff(ALLOW_2_SLASHES) && (slash2Count > 0)) {
        return false;
    }
    int slashCount = countToken(""/"", path);
    int dot2Count = countToken("".."", path);
    if (dot2Count > 0) {
        if ((slashCount - slash2Count - 1) <= dot2Count) {
            return false;
        }
    }
    return true;
}",0.3181818181818182,-0.12440191387559821,0.4,0.0,0.5833333333333334,0.634920634920635,-0.2696264975334742,0.08333333333333333,0.0,0.45296358407819126
Compress,20,1,"private CpioArchiveEntry readNewEntry(final boolean hasCrc) throws IOException {
    CpioArchiveEntry ret;
    if (hasCrc) {
        ret = new CpioArchiveEntry(FORMAT_NEW_CRC);
    } else {
        ret = new CpioArchiveEntry(FORMAT_NEW);
    }
    ret.setInode(readAsciiLong(8, 16));
    long mode = readAsciiLong(8, 16);
    if (mode != 0) {
        ret.setMode(mode);
    }
    ret.setUID(readAsciiLong(8, 16));
    ret.setGID(readAsciiLong(8, 16));
    ret.setNumberOfLinks(readAsciiLong(8, 16));
    ret.setTime(readAsciiLong(8, 16));
    ret.setSize(readAsciiLong(8, 16));
    ret.setDeviceMaj(readAsciiLong(8, 16));
    ret.setDeviceMin(readAsciiLong(8, 16));
    ret.setRemoteDeviceMaj(readAsciiLong(8, 16));
    ret.setRemoteDeviceMin(readAsciiLong(8, 16));
    long namesize = readAsciiLong(8, 16);
    ret.setChksum(readAsciiLong(8, 16));
    String name = readCString((int) namesize);
    ret.setName(name);
    if (mode == 0 && !name.equals(CPIO_TRAILER)) {
        throw new IOException(""Mode 0 only allowed in the trailer. Found entry name: "" + name + "" Occured at byte: "" + getBytesRead());
    }
    skip(ret.getHeaderPadCount());
    return ret;
}",,"private CpioArchiveEntry readNewEntry(final boolean hasCrc) throws IOException {
    CpioArchiveEntry ret;
    if (hasCrc) {
        ret = new CpioArchiveEntry(FORMAT_NEW_CRC);
    } else {
        ret = new CpioArchiveEntry(FORMAT_NEW);
    }
    ret.setInode(readAsciiLong(8, 16));
    long mode = readAsciiLong(8, 16);
    if (mode != 0) {
        ret.setMode(mode);
    }
    ret.setUID(readAsciiLong(8, 16));
    ret.setGID(readAsciiLong(8, 16));
    ret.setNumberOfLinks(readAsciiLong(8, 16));
    ret.setTime(readAsciiLong(8, 16));
    ret.setSize(readAsciiLong(8, 16));
    ret.setDeviceMaj(readAsciiLong(8, 16));
    ret.setDeviceMin(readAsciiLong(8, 16));
    ret.setRemoteDeviceMaj(readAsciiLong(8, 16));
    ret.setRemoteDeviceMin(readAsciiLong(8, 16));
    long namesize = readAsciiLong(8, 16);
    ret.setChksum(readAsciiLong(8, 16));
    String name = readCString((int) namesize);
    ret.setName(name);
    if (mode == 0 && !name.equals(CPIO_TRAILER)) {
        throw new IOException(""Mode 0 only allowed in the trailer. Found entry name: "" + name + "" Occured at byte: "" + getBytesRead());
    }
    skip(ret.getHeaderPadCount());
    return ret;
}",0.7727272727272727,-0.598086124401914,0.2,-0.5,0.16666666666666666,1.2916666666666665,-0.5639182522903451,2.0833333333333335,-0.02631578947368421,2.198060199512456
Math,92,1,"/**
 * Returns a <code>double</code> representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>double</code>. The
 * largest value of <code>n</code> for which all coefficients are <
 * Double.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE,
 * Double.POSITIVE_INFINITY is returned</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */
public static double binomialCoefficientDouble(final int n, final int k) {
    return Math.floor(Math.exp(binomialCoefficientLog(n, k)) + 0.5);
}","/**
 * Returns a <code>double</code> representation of the <a
 * href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial
 * Coefficient</a>, ""<code>n choose k</code>"", the number of
 * <code>k</code>-element subsets that can be selected from an
 * <code>n</code>-element set.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>0 <= k <= n </code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>double</code>. The
 * largest value of <code>n</code> for which all coefficients are <
 * Double.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE,
 * Double.POSITIVE_INFINITY is returned</li>
 * </ul></p>
 *
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */
","public static double binomialCoefficientDouble(final int n, final int k) {
    return Math.floor(Math.exp(binomialCoefficientLog(n, k)) + 0.5);
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.917406624383368,-0.25,-0.02631578947368421,-0.16279340490885932
commons-math,remotes/origin/bugs-dot-jar_MATH-812_607c9ec6,1,"/**
 * Compute the outer product.
 *
 * @param v Vector with which outer product should be computed.
 * @return the matrix outer product between this instance and {@code v}.
 */
public RealMatrix outerProduct(RealVector v) {
    RealMatrix product;
    if (v instanceof SparseRealVector || this instanceof SparseRealVector) {
        product = new OpenMapRealMatrix(this.getDimension(), v.getDimension());
    } else {
        product = new Array2DRowRealMatrix(this.getDimension(), v.getDimension());
    }
    Iterator<Entry> thisIt = sparseIterator();
    while (thisIt.hasNext()) {
        final Entry thisE = thisIt.next();
        Iterator<Entry> otherIt = v.sparseIterator();
        while (otherIt.hasNext()) {
            final Entry otherE = otherIt.next();
            product.setEntry(thisE.getIndex(), otherE.getIndex(), thisE.getValue() * otherE.getValue());
        }
    }
    return product;
}","/**
 * Compute the outer product.
 *
 * @param v Vector with which outer product should be computed.
 * @return the matrix outer product between this instance and {@code v}.
 */
","public RealMatrix outerProduct(RealVector v) {
    RealMatrix product;
    if (v instanceof SparseRealVector || this instanceof SparseRealVector) {
        product = new OpenMapRealMatrix(this.getDimension(), v.getDimension());
    } else {
        product = new Array2DRowRealMatrix(this.getDimension(), v.getDimension());
    }
    Iterator<Entry> thisIt = sparseIterator();
    while (thisIt.hasNext()) {
        final Entry thisE = thisIt.next();
        Iterator<Entry> otherIt = v.sparseIterator();
        while (otherIt.hasNext()) {
            final Entry otherE = otherIt.next();
            product.setEntry(thisE.getIndex(), otherE.getIndex(), thisE.getValue() * otherE.getValue());
        }
    }
    return product;
}",0.18181818181818182,0.1626794258373205,0.0,0.0,0.16666666666666666,0.10317460317460313,-0.19351656095842124,0.75,-0.02631578947368421,0.14083435625248525
camel,remotes/origin/bugs-dot-jar_CAMEL-3757_c1b2f2f8,3,"/**
 * Mock all endpoints in the route.
 *
 * @throws Exception can be thrown if error occurred
 */
public void mockEndpoints() throws Exception {
    getContext().removeEndpoints(""*"");
    getContext().addRegisterEndpointCallback(new InterceptSendToMockEndpointStrategy(null));
}","/**
 * Mock all endpoints in the route.
 *
 * @throws Exception can be thrown if error occurred
 */
","public void mockEndpoints() throws Exception {
    getContext().removeEndpoints(""*"");
    getContext().addRegisterEndpointCallback(new InterceptSendToMockEndpointStrategy(null));
}",-0.45454545454545453,-0.47368421052631593,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.8314305849189569,-0.16666666666666666,2.6052631578947367,-0.16279340490885932
Closure,144,2,"/**
 * Gets the function type from the function node and its attached
 * {@link JSDocInfo}.
 * @param name the function's name
 * @param rValue the function node. It must be a {@link Token#FUNCTION}.
 * @param info the {@link JSDocInfo} attached to the function definition
 * @param lvalueNode The node where this function is being
 *     assigned. For example, {@code A.prototype.foo = ...} would be used to
 *     determine that this function is a method of A.prototype. May be
 *     null to indicate that this is not being assigned to a qualified name.
 */
private FunctionType getFunctionType(String name, Node rValue, JSDocInfo info, @Nullable Node lvalueNode) {
    FunctionType functionType = null;
    // Handle function aliases.
    if (rValue != null && rValue.isQualifiedName()) {
        Var var = scope.getVar(rValue.getQualifiedName());
        if (var != null && var.getType() instanceof FunctionType) {
            functionType = (FunctionType) var.getType();
            if (functionType != null && functionType.isConstructor()) {
                typeRegistry.declareType(name, functionType.getInstanceType());
            }
        }
        return functionType;
    }
    Node owner = null;
    if (lvalueNode != null) {
        owner = getPrototypePropertyOwner(lvalueNode);
    }
    Node errorRoot = rValue == null ? lvalueNode : rValue;
    boolean isFnLiteral = rValue != null && rValue.getType() == Token.FUNCTION;
    Node fnRoot = isFnLiteral ? rValue : null;
    Node parametersNode = isFnLiteral ? rValue.getFirstChild().getNext() : null;
    if (functionType == null && info != null && info.hasType()) {
        JSType type = info.getType().evaluate(scope, typeRegistry);
        // Known to be not null since we have the FUNCTION token there.
        type = type.restrictByNotNullOrUndefined();
        if (type.isFunctionType()) {
            functionType = (FunctionType) type;
            functionType.setJSDocInfo(info);
        }
    }
    if (functionType == null) {
        if (info == null || !FunctionTypeBuilder.isFunctionTypeDeclaration(info)) {
            // to this function.
            if (lvalueNode != null && lvalueNode.getType() == Token.GETPROP && lvalueNode.isQualifiedName()) {
                Var var = scope.getVar(lvalueNode.getFirstChild().getQualifiedName());
                if (var != null) {
                    ObjectType ownerType = ObjectType.cast(var.getType());
                    FunctionType propType = null;
                    if (ownerType != null) {
                        String propName = lvalueNode.getLastChild().getString();
                        propType = findOverriddenFunction(ownerType, propName);
                    }
                    if (propType != null) {
                        functionType = new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setSourceNode(fnRoot).inferFromOverriddenFunction(propType, parametersNode).inferThisType(info, owner).buildAndRegister();
                    }
                }
            }
        }
    }
    if (functionType == null) {
        functionType = new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setSourceNode(fnRoot).inferTemplateTypeName(info).inferReturnType(info).inferInheritance(info).inferThisType(info, owner).inferParameterTypes(parametersNode, info).buildAndRegister();
    }
    // assigning the function type to the function node
    if (rValue != null) {
        setDeferredType(rValue, functionType);
    }
    // all done
    return functionType;
}","/**
 * Gets the function type from the function node and its attached
 * {@link JSDocInfo}.
 * @param name the function's name
 * @param rValue the function node. It must be a {@link Token#FUNCTION}.
 * @param info the {@link JSDocInfo} attached to the function definition
 * @param lvalueNode The node where this function is being
 *     assigned. For example, {@code A.prototype.foo = ...} would be used to
 *     determine that this function is a method of A.prototype. May be
 *     null to indicate that this is not being assigned to a qualified name.
 */
","private FunctionType getFunctionType(String name, Node rValue, JSDocInfo info, @Nullable Node lvalueNode) {
    FunctionType functionType = null;
        if (rValue != null && rValue.isQualifiedName()) {
        Var var = scope.getVar(rValue.getQualifiedName());
        if (var != null && var.getType() instanceof FunctionType) {
            functionType = (FunctionType) var.getType();
            if (functionType != null && functionType.isConstructor()) {
                typeRegistry.declareType(name, functionType.getInstanceType());
            }
        }
        return functionType;
    }
    Node owner = null;
    if (lvalueNode != null) {
        owner = getPrototypePropertyOwner(lvalueNode);
    }
    Node errorRoot = rValue == null ? lvalueNode : rValue;
    boolean isFnLiteral = rValue != null && rValue.getType() == Token.FUNCTION;
    Node fnRoot = isFnLiteral ? rValue : null;
    Node parametersNode = isFnLiteral ? rValue.getFirstChild().getNext() : null;
    if (functionType == null && info != null && info.hasType()) {
        JSType type = info.getType().evaluate(scope, typeRegistry);
                type = type.restrictByNotNullOrUndefined();
        if (type.isFunctionType()) {
            functionType = (FunctionType) type;
            functionType.setJSDocInfo(info);
        }
    }
    if (functionType == null) {
        if (info == null || !FunctionTypeBuilder.isFunctionTypeDeclaration(info)) {
                        if (lvalueNode != null && lvalueNode.getType() == Token.GETPROP && lvalueNode.isQualifiedName()) {
                Var var = scope.getVar(lvalueNode.getFirstChild().getQualifiedName());
                if (var != null) {
                    ObjectType ownerType = ObjectType.cast(var.getType());
                    FunctionType propType = null;
                    if (ownerType != null) {
                        String propName = lvalueNode.getLastChild().getString();
                        propType = findOverriddenFunction(ownerType, propName);
                    }
                    if (propType != null) {
                        functionType = new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setSourceNode(fnRoot).inferFromOverriddenFunction(propType, parametersNode).inferThisType(info, owner).buildAndRegister();
                    }
                }
            }
        }
    }
    if (functionType == null) {
        functionType = new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setSourceNode(fnRoot).inferTemplateTypeName(info).inferReturnType(info).inferInheritance(info).inferThisType(info, owner).inferParameterTypes(parametersNode, info).buildAndRegister();
    }
        if (rValue != null) {
        setDeferredType(rValue, functionType);
    }
        return functionType;
}",1.8181818181818181,1.6842105263157894,2.8,1.5,3.0,1.4583333333333333,-1.0293164200140943,2.9166666666666665,-0.02631578947368421,6.049021743515268
wicket,remotes/origin/bugs-dot-jar_WICKET-5853_b80f6640,3,"/**
 *  @param locale
 *             The Locale that was used for this NumberFormat
 *  @param numberFormat
 *             The numberFormat to set.
 */
public final void setNumberFormat(final Locale locale, final NumberFormat numberFormat) {
    if (numberFormat instanceof DecimalFormat) {
        ((DecimalFormat) numberFormat).setParseBigDecimal(true);
    }
    numberFormats.put(locale, numberFormat);
}","/**
 *  @param locale
 *             The Locale that was used for this NumberFormat
 *  @param numberFormat
 *             The numberFormat to set.
 */
","public final void setNumberFormat(final Locale locale, final NumberFormat numberFormat) {
    if (numberFormat instanceof DecimalFormat) {
        ((DecimalFormat) numberFormat).setParseBigDecimal(true);
    }
    numberFormats.put(locale, numberFormat);
}",-0.36363636363636365,-0.11483253588516758,-0.4,-0.5,-0.25,-0.3650793650793651,0.55799859055673,-0.3333333333333333,2.1052631578947367,-0.16279340490885932
commons-math,remotes/origin/bugs-dot-jar_MATH-757_76b7413d,1,"/**
 * <p>
 * Adds an element to the end of the array and removes the first
 * element in the array.  Returns the discarded first element.
 * The effect is similar to a push operation in a FIFO queue.
 * </p>
 * <p>
 * Example: If the array contains the elements 1, 2, 3, 4 (in that order)
 * and addElementRolling(5) is invoked, the result is an array containing
 * the entries 2, 3, 4, 5 and the value returned is 1.
 * </p>
 *
 * @param value Value to be added to the array.
 * @return the value which has been discarded or ""pushed"" out of the array
 * by this rolling insert.
 */
@Override
public synchronized double addElementRolling(double value) {
    double discarded = internalArray[startIndex];
    if ((startIndex + (numElements + 1)) > internalArray.length) {
        expand();
    }
    // Increment the start index
    startIndex += 1;
    // Add the new value
    internalArray[startIndex + (numElements - 1)] = value;
    // Check the contraction criterion.
    if (shouldContract()) {
        contract();
    }
    return discarded;
}","/**
 * <p>
 * Adds an element to the end of the array and removes the first
 * element in the array.  Returns the discarded first element.
 * The effect is similar to a push operation in a FIFO queue.
 * </p>
 * <p>
 * Example: If the array contains the elements 1, 2, 3, 4 (in that order)
 * and addElementRolling(5) is invoked, the result is an array containing
 * the entries 2, 3, 4, 5 and the value returned is 1.
 * </p>
 *
 * @param value Value to be added to the array.
 * @return the value which has been discarded or ""pushed"" out of the array
 * by this rolling insert.
 */
","@Override
public synchronized double addElementRolling(double value) {
    double discarded = internalArray[startIndex];
    if ((startIndex + (numElements + 1)) > internalArray.length) {
        expand();
    }
        startIndex += 1;
        internalArray[startIndex + (numElements - 1)] = value;
        if (shouldContract()) {
        contract();
    }
    return discarded;
}",-0.045454545454545456,-0.25358851674641164,-0.2,-0.5,0.08333333333333333,0.33730158730158727,0.07427766032417207,-0.25,-0.02631578947368421,0.04808814969773459
commons-math,remotes/origin/bugs-dot-jar_MATH-949_f83bbc1d,1,"/**
 * {@inheritDoc}
 */
@Override
protected PointValuePair doOptimize() {
    final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();
    final double[] point = getStartPoint();
    final GoalType goal = getGoalType();
    final int n = point.length;
    double[] r = computeObjectiveGradient(point);
    if (goal == GoalType.MINIMIZE) {
        for (int i = 0; i < n; i++) {
            r[i] = -r[i];
        }
    }
    // Initial search direction.
    double[] steepestDescent = preconditioner.precondition(point, r);
    double[] searchDirection = steepestDescent.clone();
    double delta = 0;
    for (int i = 0; i < n; ++i) {
        delta += r[i] * searchDirection[i];
    }
    PointValuePair current = null;
    int iter = 0;
    int maxEval = getMaxEvaluations();
    while (true) {
        ++iter;
        final double objective = computeObjectiveValue(point);
        PointValuePair previous = current;
        current = new PointValuePair(point, objective);
        if (previous != null) {
            if (checker.converged(iter, previous, current)) {
                // We have found an optimum.
                return current;
            }
        }
        // Find the optimal step in the search direction.
        final UnivariateFunction lsf = new LineSearchFunction(point, searchDirection);
        final double uB = findUpperBound(lsf, 0, initialStep);
        // XXX Last parameters is set to a value close to zero in order to
        // work around the divergence problem in the ""testCircleFitting""
        // unit test (see MATH-439).
        final double step = solver.solve(maxEval, lsf, 0, uB, 1e-15);
        // Subtract used up evaluations.
        maxEval -= solver.getEvaluations();
        // Validate new point.
        for (int i = 0; i < point.length; ++i) {
            point[i] += step * searchDirection[i];
        }
        r = computeObjectiveGradient(point);
        if (goal == GoalType.MINIMIZE) {
            for (int i = 0; i < n; ++i) {
                r[i] = -r[i];
            }
        }
        // Compute beta.
        final double deltaOld = delta;
        final double[] newSteepestDescent = preconditioner.precondition(point, r);
        delta = 0;
        for (int i = 0; i < n; ++i) {
            delta += r[i] * newSteepestDescent[i];
        }
        final double beta;
        switch(updateFormula) {
            case FLETCHER_REEVES:
                beta = delta / deltaOld;
                break;
            case POLAK_RIBIERE:
                double deltaMid = 0;
                for (int i = 0; i < r.length; ++i) {
                    deltaMid += r[i] * steepestDescent[i];
                }
                beta = (delta - deltaMid) / deltaOld;
                break;
            default:
                // Should never happen.
                throw new MathInternalError();
        }
        steepestDescent = newSteepestDescent;
        // Compute conjugate search direction.
        if (iter % n == 0 || beta < 0) {
            // Break conjugation: reset search direction.
            searchDirection = steepestDescent.clone();
        } else {
            // Compute new conjugate search direction.
            for (int i = 0; i < n; ++i) {
                searchDirection[i] = steepestDescent[i] + beta * searchDirection[i];
            }
        }
    }
}","/**
 * {@inheritDoc}
 */
","@Override
protected PointValuePair doOptimize() {
    final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();
    final double[] point = getStartPoint();
    final GoalType goal = getGoalType();
    final int n = point.length;
    double[] r = computeObjectiveGradient(point);
    if (goal == GoalType.MINIMIZE) {
        for (int i = 0; i < n; i++) {
            r[i] = -r[i];
        }
    }
        double[] steepestDescent = preconditioner.precondition(point, r);
    double[] searchDirection = steepestDescent.clone();
    double delta = 0;
    for (int i = 0; i < n; ++i) {
        delta += r[i] * searchDirection[i];
    }
    PointValuePair current = null;
    int iter = 0;
    int maxEval = getMaxEvaluations();
    while (true) {
        ++iter;
        final double objective = computeObjectiveValue(point);
        PointValuePair previous = current;
        current = new PointValuePair(point, objective);
        if (previous != null) {
            if (checker.converged(iter, previous, current)) {
                                return current;
            }
        }
                final UnivariateFunction lsf = new LineSearchFunction(point, searchDirection);
        final double uB = findUpperBound(lsf, 0, initialStep);
                                final double step = solver.solve(maxEval, lsf, 0, uB, 1e-15);
                maxEval -= solver.getEvaluations();
                for (int i = 0; i < point.length; ++i) {
            point[i] += step * searchDirection[i];
        }
        r = computeObjectiveGradient(point);
        if (goal == GoalType.MINIMIZE) {
            for (int i = 0; i < n; ++i) {
                r[i] = -r[i];
            }
        }
                final double deltaOld = delta;
        final double[] newSteepestDescent = preconditioner.precondition(point, r);
        delta = 0;
        for (int i = 0; i < n; ++i) {
            delta += r[i] * newSteepestDescent[i];
        }
        final double beta;
        switch(updateFormula) {
            case FLETCHER_REEVES:
                beta = delta / deltaOld;
                break;
            case POLAK_RIBIERE:
                double deltaMid = 0;
                for (int i = 0; i < r.length; ++i) {
                    deltaMid += r[i] * steepestDescent[i];
                }
                beta = (delta - deltaMid) / deltaOld;
                break;
            default:
                                throw new MathInternalError();
        }
        steepestDescent = newSteepestDescent;
                if (iter % n == 0 || beta < 0) {
                        searchDirection = steepestDescent.clone();
        } else {
                        for (int i = 0; i < n; ++i) {
                searchDirection[i] = steepestDescent[i] + beta * searchDirection[i];
            }
        }
    }
}",2.772727272727273,0.6889952153110046,3.2,1.0,1.8333333333333333,3.845238095238095,-1.2057787174066241,0.75,-0.02631578947368421,15.565385568483714
wicket,remotes/origin/bugs-dot-jar_WICKET-3931_8fbdc68f,1,"/**
 *  Render a placeholder tag when the component is not visible. The tag is of form:
 *  &lt;componenttag style=""display:none;"" id=""markupid""/&gt;. This method will also call
 *  <code>setOutputMarkupId(true)</code>.
 *
 *  This is useful, for example, in ajax situations where the component starts out invisible and
 *  then becomes visible through an ajax update. With a placeholder tag already in the markup you
 *  do not need to repaint this component's parent, instead you can repaint the component
 *  directly.
 *
 *  When this method is called with parameter <code>false</code> the outputmarkupid flag is not
 *  reverted to false.
 *
 *  @param outputTag
 *  @return this for chaining
 */
public final Component setOutputMarkupPlaceholderTag(final boolean outputTag) {
    if (outputTag != getFlag(FLAG_PLACEHOLDER)) {
        if (outputTag) {
            setOutputMarkupId(true);
            setFlag(FLAG_PLACEHOLDER, true);
        } else {
            setFlag(FLAG_PLACEHOLDER, false);
        // I think it's better to not setOutputMarkupId to false...
        // user can do it if we want
        }
    }
    return this;
}","/**
 *  Render a placeholder tag when the component is not visible. The tag is of form:
 *  &lt;componenttag style=""display:none;"" id=""markupid""/&gt;. This method will also call
 *  <code>setOutputMarkupId(true)</code>.
 *
 *  This is useful, for example, in ajax situations where the component starts out invisible and
 *  then becomes visible through an ajax update. With a placeholder tag already in the markup you
 *  do not need to repaint this component's parent, instead you can repaint the component
 *  directly.
 *
 *  When this method is called with parameter <code>false</code> the outputmarkupid flag is not
 *  reverted to false.
 *
 *  @param outputTag
 *  @return this for chaining
 */
","public final Component setOutputMarkupPlaceholderTag(final boolean outputTag) {
    if (outputTag != getFlag(FLAG_PLACEHOLDER)) {
        if (outputTag) {
            setOutputMarkupId(true);
            setFlag(FLAG_PLACEHOLDER, true);
        } else {
            setFlag(FLAG_PLACEHOLDER, false);
                        }
    }
    return this;
}",-0.13636363636363635,0.6124401913875596,-0.2,0.0,-0.08333333333333333,-0.3650793650793651,0.2659619450317125,-0.16666666666666666,0.868421052631579,-0.16279340490885932
Closure,155,2,"/**
 * For each node, update the block stack and reference collection
 * as appropriate.
 */
public void visit(NodeTraversal t, Node n, Node parent) {
    if (n.getType() == Token.NAME) {
        Var v = t.getScope().getVar(n.getString());
        if (v != null && varFilter.apply(v)) {
            addReference(t, v, new Reference(n, parent, t, blockStack.peek()));
        }
    }
    if (isBlockBoundary(n, parent)) {
        blockStack.pop();
    }
}","/**
 * For each node, update the block stack and reference collection
 * as appropriate.
 */
","public void visit(NodeTraversal t, Node n, Node parent) {
    if (n.getType() == Token.NAME) {
        Var v = t.getScope().getVar(n.getString());
        if (v != null && varFilter.apply(v)) {
            addReference(t, v, new Reference(n, parent, t, blockStack.peek()));
        }
    }
    if (isBlockBoundary(n, parent)) {
        blockStack.pop();
    }
}",-0.13636363636363635,0.25837320574162664,0.0,0.0,0.4166666666666667,0.26388888888888884,0.078505990133897,0.25,0.15789473684210528,0.1319825037603084
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-344_8dead3bb,1,"@Override
public void onStartup(final Set<Class<?>> classes, final ServletContext servletContext) throws ServletException {
    if (servletContext.getMajorVersion() > 2 && servletContext.getEffectiveMajorVersion() > 2) {
        servletContext.log(""Log4jServletContainerInitializer starting up Log4j in Servlet 3.0+ environment."");
        final FilterRegistration.Dynamic filter = servletContext.addFilter(""log4jServletFilter"", new Log4jServletFilter());
        if (filter == null) {
            servletContext.log(""WARNING: In a Servlet 3.0+ application, you should not define a "" + ""log4jServletFilter in web.xml. Log4j 2 normally does this for you automatically. Log4j 2 "" + ""web auto-initialization has been canceled."");
            return;
        }
        final Log4jWebInitializer initializer = Log4jWebInitializerImpl.getLog4jWebInitializer(servletContext);
        initializer.initialize();
        // the application is just now starting to start up
        initializer.setLoggerContext();
        servletContext.addListener(new Log4jServletContextListener());
        filter.addMappingForUrlPatterns(EnumSet.allOf(DispatcherType.class), false, ""/*"");
    }
}",,"@Override
public void onStartup(final Set<Class<?>> classes, final ServletContext servletContext) throws ServletException {
    if (servletContext.getMajorVersion() > 2 && servletContext.getEffectiveMajorVersion() > 2) {
        servletContext.log(""Log4jServletContainerInitializer starting up Log4j in Servlet 3.0+ environment."");
        final FilterRegistration.Dynamic filter = servletContext.addFilter(""log4jServletFilter"", new Log4jServletFilter());
        if (filter == null) {
            servletContext.log(""WARNING: In a Servlet 3.0+ application, you should not define a "" + ""log4jServletFilter in web.xml. Log4j 2 normally does this for you automatically. Log4j 2 "" + ""web auto-initialization has been canceled."");
            return;
        }
        final Log4jWebInitializer initializer = Log4jWebInitializerImpl.getLog4jWebInitializer(servletContext);
        initializer.initialize();
                initializer.setLoggerContext();
        servletContext.addListener(new Log4jServletContextListener());
        filter.addMappingForUrlPatterns(EnumSet.allOf(DispatcherType.class), false, ""/*"");
    }
}",0.09090909090909091,0.3444976076555023,-0.2,0.0,0.08333333333333333,0.16666666666666669,-0.15095137420718824,0.4166666666666667,-0.02631578947368421,0.22667888406724174
Math,58,1,"/**
 * Fits a Gaussian function to the observed points.
 *
 * @return the parameters of the Gaussian function that best fits the
 * observed points (in the same order as above).
 */
public double[] fit() {
    final double[] guess = (new ParameterGuesser(getObservations())).guess();
    return fit(new Gaussian.Parametric(), guess);
}","/**
 * Fits a Gaussian function to the observed points.
 *
 * @return the parameters of the Gaussian function that best fits the
 * observed points (in the same order as above).
 */
","public double[] fit() {
    final double[] guess = (new ParameterGuesser(getObservations())).guess();
    return fit(new Gaussian.Parametric(), guess);
}",-0.45454545454545453,-0.47368421052631593,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.8255109231853415,-0.25,2.526315789473684,-0.16279340490885932
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-520_ec961a38,1,"@Override
public void insert(NodeBuilder index, String key, boolean unique, Iterable<String> values) throws CommitFailedException {
    NodeBuilder child = index.child(key);
    for (String add : values) {
        NodeBuilder indexEntry = child;
        Iterator<String> segments = PathUtils.elements(add).iterator();
        while (segments.hasNext()) {
            String segment = segments.next();
            indexEntry = indexEntry.child(segment);
        }
        indexEntry.setProperty(""match"", true);
    }
    long matchCount = countMatchingLeaves(child.getNodeState());
    if (matchCount == 0) {
        index.removeNode(key);
    } else if (unique && matchCount > 1) {
        throw new CommitFailedException(""Uniqueness constraint violated"");
    }
}",,"@Override
public void insert(NodeBuilder index, String key, boolean unique, Iterable<String> values) throws CommitFailedException {
    NodeBuilder child = index.child(key);
    for (String add : values) {
        NodeBuilder indexEntry = child;
        Iterator<String> segments = PathUtils.elements(add).iterator();
        while (segments.hasNext()) {
            String segment = segments.next();
            indexEntry = indexEntry.child(segment);
        }
        indexEntry.setProperty(""match"", true);
    }
    long matchCount = countMatchingLeaves(child.getNodeState());
    if (matchCount == 0) {
        index.removeNode(key);
    } else if (unique && matchCount > 1) {
        throw new CommitFailedException(""Uniqueness constraint violated"");
    }
}",0.22727272727272727,0.24880382775119597,0.4,0.0,0.16666666666666666,0.3531746031746032,-0.26314305849189545,0.3333333333333333,-0.02631578947368421,0.41610391705998623
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2029_e30023ba,1,"/**
 * close writer if it's not null
 */
void closeWriter() throws IOException {
    if (writer != null) {
        writer.close();
    }
}","/**
 * close writer if it's not null
 */
","void closeWriter() throws IOException {
    if (writer != null) {
        writer.close();
    }
}",-0.4090909090909091,0.0,-0.4,-0.5,-0.25,-0.3650793650793651,0.7736434108527128,-0.4166666666666667,2.5789473684210527,-0.16279340490885932
camel,remotes/origin/bugs-dot-jar_CAMEL-7163_5f726d0b,1,"public void setMessageHeaderOnBreakpoint(String nodeId, String headerName, String value) {
    backlogDebugger.setMessageHeaderOnBreakpoint(nodeId, headerName, value);
}",,"public void setMessageHeaderOnBreakpoint(String nodeId, String headerName, String value) {
    backlogDebugger.setMessageHeaderOnBreakpoint(nodeId, headerName, value);
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.9422128259337562,-0.4166666666666667,-0.02631578947368421,-0.16279340490885932
camel,remotes/origin/bugs-dot-jar_CAMEL-8125_36e7b668,3,"public Object getInjectionPropertyValue(Class<?> type, String propertyName, String propertyDefaultValue, String injectionPointName, Object bean, String beanName) {
    try {
        String key;
        String prefix = getCamelContext().getPropertyPrefixToken();
        String suffix = getCamelContext().getPropertySuffixToken();
        if (prefix == null && suffix == null) {
            // if no custom prefix/suffix then use defaults
            prefix = PropertiesComponent.DEFAULT_PREFIX_TOKEN;
            suffix = PropertiesComponent.DEFAULT_SUFFIX_TOKEN;
        }
        if (!propertyName.startsWith(prefix)) {
            // must enclose the property name with prefix/suffix to have it resolved
            key = prefix + propertyName + suffix;
        } else {
            // key has already prefix/suffix so use it as-is as it may be a compound key
            key = propertyName;
        }
        String value = getCamelContext().resolvePropertyPlaceholders(key);
        if (value != null) {
            return getCamelContext().getTypeConverter().mandatoryConvertTo(type, value);
        } else {
            return null;
        }
    } catch (Exception e) {
        if (ObjectHelper.isNotEmpty(propertyDefaultValue)) {
            try {
                return getCamelContext().getTypeConverter().mandatoryConvertTo(type, propertyDefaultValue);
            } catch (Exception e2) {
                throw ObjectHelper.wrapRuntimeCamelException(e2);
            }
        }
        throw ObjectHelper.wrapRuntimeCamelException(e);
    }
}",,"public Object getInjectionPropertyValue(Class<?> type, String propertyName, String propertyDefaultValue, String injectionPointName, Object bean, String beanName) {
    try {
        String key;
        String prefix = getCamelContext().getPropertyPrefixToken();
        String suffix = getCamelContext().getPropertySuffixToken();
        if (prefix == null && suffix == null) {
                        prefix = PropertiesComponent.DEFAULT_PREFIX_TOKEN;
            suffix = PropertiesComponent.DEFAULT_SUFFIX_TOKEN;
        }
        if (!propertyName.startsWith(prefix)) {
                        key = prefix + propertyName + suffix;
        } else {
                        key = propertyName;
        }
        String value = getCamelContext().resolvePropertyPlaceholders(key);
        if (value != null) {
            return getCamelContext().getTypeConverter().mandatoryConvertTo(type, value);
        } else {
            return null;
        }
    } catch (Exception e) {
        if (ObjectHelper.isNotEmpty(propertyDefaultValue)) {
            try {
                return getCamelContext().getTypeConverter().mandatoryConvertTo(type, propertyDefaultValue);
            } catch (Exception e2) {
                throw ObjectHelper.wrapRuntimeCamelException(e2);
            }
        }
        throw ObjectHelper.wrapRuntimeCamelException(e);
    }
}",0.7727272727272727,0.3492822966507177,1.0,0.5,0.5,1.0297619047619049,-0.5481324876673711,0.8333333333333334,-0.02631578947368421,1.334257706471188
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2691_d2da7499,0,"/**
 * Retrieves the {# CLUSTER_ID_PROP}
 *
 * @param store the NodeStore instance
 * @return the repository id
 */
public static String getId(NodeStore store) {
    return store.getRoot().getChildNode(CLUSTER_CONFIG_NODE).getProperty(CLUSTER_ID_PROP).getValue(Type.STRING);
}","/**
 * Retrieves the {# CLUSTER_ID_PROP}
 *
 * @param store the NodeStore instance
 * @return the repository id
 */
","public static String getId(NodeStore store) {
    return store.getRoot().getChildNode(CLUSTER_CONFIG_NODE).getProperty(CLUSTER_ID_PROP).getValue(Type.STRING);
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.8909090909090904,-0.16666666666666666,2.5789473684210527,-0.16279340490885932
wicket,remotes/origin/bugs-dot-jar_WICKET-4338_9decad35,3,"/**
 *  @see org.apache.wicket.request.IRequestParameters#getParameterNames()
 */
public Set<String> getParameterNames() {
    Set<String> result = new HashSet<String>();
    for (QueryParameter parameter : url.getQueryParameters()) {
        result.add(parameter.getName());
    }
    return Collections.unmodifiableSet(result);
}","/**
 *  @see org.apache.wicket.request.IRequestParameters#getParameterNames()
 */
","public Set<String> getParameterNames() {
    Set<String> result = new HashSet<String>();
    for (QueryParameter parameter : url.getQueryParameters()) {
        result.add(parameter.getName());
    }
    return Collections.unmodifiableSet(result);
}",-0.3181818181818182,-0.20574162679425848,-0.4,-0.5,-0.4166666666666667,-0.3650793650793651,0.4300211416490484,-0.16666666666666666,0.47368421052631576,-0.16279340490885932
Closure,149,2,"@Override
protected CompilerOptions createOptions() {
    CompilerOptions options = new CompilerOptions();
    options.setCodingConvention(new ClosureCodingConvention());
    CompilationLevel level = flags.compilation_level;
    level.setOptionsForCompilationLevel(options);
    if (flags.debug) {
        level.setDebugOptionsForCompilationLevel(options);
    }
    WarningLevel wLevel = flags.warning_level;
    wLevel.setOptionsForWarningLevel(options);
    for (FormattingOption formattingOption : flags.formatting) {
        formattingOption.applyToOptions(options);
    }
    options.closurePass = flags.process_closure_primitives;
    initOptionsFromFlags(options);
    return options;
}",,"@Override
protected CompilerOptions createOptions() {
    CompilerOptions options = new CompilerOptions();
    options.setCodingConvention(new ClosureCodingConvention());
    CompilationLevel level = flags.compilation_level;
    level.setOptionsForCompilationLevel(options);
    if (flags.debug) {
        level.setDebugOptionsForCompilationLevel(options);
    }
    WarningLevel wLevel = flags.warning_level;
    wLevel.setOptionsForWarningLevel(options);
    for (FormattingOption formattingOption : flags.formatting) {
        formattingOption.applyToOptions(options);
    }
    options.closurePass = flags.process_closure_primitives;
    initOptionsFromFlags(options);
    return options;
}",0.18181818181818182,-0.4258373205741628,-0.2,-0.5,-0.25,-0.3650793650793651,-0.1529245947850598,0.0,-0.02631578947368421,-0.16279340490885932
Math,17,1,"/**
 * Multiply this by a single digit x.
 * @param x multiplicand
 * @return product of this and x
 */
public Dfp multiply(final int x) {
    return multiplyFast(x);
}","/**
 * Multiply this by a single digit x.
 * @param x multiplicand
 * @return product of this and x
 */
","public Dfp multiply(final int x) {
    return multiplyFast(x);
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,1.083157152924595,-0.4166666666666667,2.6052631578947367,-0.16279340490885932
commons-math,remotes/origin/bugs-dot-jar_MATH-373_bfe4623c,1,"/**
 * The weighted sum of the entries in the specified portion of
 * the input array, or <code>Double.NaN</code> if the designated subarray
 * is empty.
 * <p>
 * Throws <code>IllegalArgumentException</code> if any of the following are true:
 * <ul><li>the values array is null</li>
 *     <li>the weights array is null</li>
 *     <li>the weights array does not have the same length as the values array</li>
 *     <li>the weights array contains one or more infinite values</li>
 *     <li>the weights array contains one or more NaN values</li>
 *     <li>the weights array contains negative values</li>
 *     <li>the start and length arguments do not determine a valid array</li>
 * </ul></p>
 * <p>
 * Uses the formula, <pre>
 *    weighted sum = &Sigma;(values[i] * weights[i])
 * </pre></p>
 *
 * @param values the input array
 * @param weights the weights array
 * @param begin index of the first array element to include
 * @param length the number of elements to include
 * @return the sum of the values or Double.NaN if length = 0
 * @throws IllegalArgumentException if the parameters are not valid
 * @since 2.1
 */
public double evaluate(final double[] values, final double[] weights, final int begin, final int length) {
    double sum = Double.NaN;
    if (test(values, weights, begin, length)) {
        sum = 0.0;
        for (int i = begin; i < begin + length; i++) {
            sum += values[i] * weights[i];
        }
    }
    return sum;
}","/**
 * The weighted sum of the entries in the specified portion of
 * the input array, or <code>Double.NaN</code> if the designated subarray
 * is empty.
 * <p>
 * Throws <code>IllegalArgumentException</code> if any of the following are true:
 * <ul><li>the values array is null</li>
 *     <li>the weights array is null</li>
 *     <li>the weights array does not have the same length as the values array</li>
 *     <li>the weights array contains one or more infinite values</li>
 *     <li>the weights array contains one or more NaN values</li>
 *     <li>the weights array contains negative values</li>
 *     <li>the start and length arguments do not determine a valid array</li>
 * </ul></p>
 * <p>
 * Uses the formula, <pre>
 *    weighted sum = &Sigma;(values[i] * weights[i])
 * </pre></p>
 *
 * @param values the input array
 * @param weights the weights array
 * @param begin index of the first array element to include
 * @param length the number of elements to include
 * @return the sum of the values or Double.NaN if length = 0
 * @throws IllegalArgumentException if the parameters are not valid
 * @since 2.1
 */
","public double evaluate(final double[] values, final double[] weights, final int begin, final int length) {
    double sum = Double.NaN;
    if (test(values, weights, begin, length)) {
        sum = 0.0;
        for (int i = begin; i < begin + length; i++) {
            sum += values[i] * weights[i];
        }
    }
    return sum;
}",-0.18181818181818182,0.29186602870813394,-0.2,0.0,0.25,1.0238095238095237,0.17209302325581402,-0.4166666666666667,-0.02631578947368421,0.32167032612391433
flink,remotes/origin/bugs-dot-jar_FLINK-2713_63d9800e,1,"@Override
public void update(S state) throws IOException {
    if (state == null) {
        throw new RuntimeException(""Cannot set state to null."");
    }
    this.state = state;
}",,"@Override
public void update(S state) throws IOException {
    if (state == null) {
        throw new RuntimeException(""Cannot set state to null."");
    }
    this.state = state;
}",-0.3181818181818182,-0.0909090909090911,-0.2,-0.5,-0.25,-0.10119047619047619,0.5007751937984495,-0.5,0.868421052631579,-0.13301983022423539
Closure,147,2,"/**
 * Since this pass reports errors only when a global {@code this} keyword
 * is encountered, there is no reason to traverse non global contexts.
 */
public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
    if (n.getType() == Token.FUNCTION) {
        // Don't traverse functions that are constructors or have the @this
        // or @override annotation.
        JSDocInfo jsDoc = getFunctionJsDocInfo(n);
        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.isInterface() || jsDoc.hasThisType() || jsDoc.isOverride())) {
            return false;
        }
        // Don't traverse functions unless they would normally
        // be able to have a @this annotation associated with them. e.g.,
        // var a = function() { }; // or
        // function a() {} // or
        // a.x = function() {}; // or
        // var a = {x: function() {}};
        int pType = parent.getType();
        if (!(pType == Token.BLOCK || pType == Token.SCRIPT || pType == Token.NAME || pType == Token.ASSIGN)) {
            return false;
        }
    }
    if (parent != null && parent.getType() == Token.ASSIGN) {
        Node lhs = parent.getFirstChild();
        Node rhs = lhs.getNext();
        if (n == lhs) {
            // assignLhsChild should not be overridden.
            if (assignLhsChild == null) {
                assignLhsChild = lhs;
            }
        } else {
            // property or subproperty.
            if (NodeUtil.isGet(lhs)) {
                if (lhs.getType() == Token.GETPROP && lhs.getLastChild().getString().equals(""prototype"")) {
                    return false;
                }
                Node llhs = lhs.getFirstChild();
                if (llhs.getType() == Token.GETPROP && llhs.getLastChild().getString().equals(""prototype"")) {
                    return false;
                }
            }
        }
    }
    return true;
}","/**
 * Since this pass reports errors only when a global {@code this} keyword
 * is encountered, there is no reason to traverse non global contexts.
 */
","public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
    if (n.getType() == Token.FUNCTION) {
                        JSDocInfo jsDoc = getFunctionJsDocInfo(n);
        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.isInterface() || jsDoc.hasThisType() || jsDoc.isOverride())) {
            return false;
        }
                                                        int pType = parent.getType();
        if (!(pType == Token.BLOCK || pType == Token.SCRIPT || pType == Token.NAME || pType == Token.ASSIGN)) {
            return false;
        }
    }
    if (parent != null && parent.getType() == Token.ASSIGN) {
        Node lhs = parent.getFirstChild();
        Node rhs = lhs.getNext();
        if (n == lhs) {
                        if (assignLhsChild == null) {
                assignLhsChild = lhs;
            }
        } else {
                        if (NodeUtil.isGet(lhs)) {
                if (lhs.getType() == Token.GETPROP && lhs.getLastChild().getString().equals(""prototype"")) {
                    return false;
                }
                Node llhs = lhs.getFirstChild();
                if (llhs.getType() == Token.GETPROP && llhs.getLastChild().getString().equals(""prototype"")) {
                    return false;
                }
            }
        }
    }
    return true;
}",0.8181818181818182,1.0526315789473686,1.2,1.0,2.5833333333333335,1.0595238095238095,-0.6180408738548271,1.1666666666666667,-0.02631578947368421,1.9709456383303652
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-359_1df1db27,1,"@Override
public void onStartup(final Set<Class<?>> classes, final ServletContext servletContext) throws ServletException {
    servletContext.log(""Log4jServletContainerInitializer starting up Log4j in Servlet 3.0+ environment."");
    final Log4jWebInitializer initializer = Log4jWebInitializerImpl.getLog4jWebInitializer(servletContext);
    initializer.initialize();
    // the application is just now starting to start up
    initializer.setLoggerContext();
    servletContext.addListener(new Log4jServletContextListener());
    final FilterRegistration.Dynamic filter = servletContext.addFilter(""log4jServletFilter"", new Log4jServletFilter());
    filter.addMappingForUrlPatterns(EnumSet.allOf(DispatcherType.class), false, ""/*"");
}",,"@Override
public void onStartup(final Set<Class<?>> classes, final ServletContext servletContext) throws ServletException {
    servletContext.log(""Log4jServletContainerInitializer starting up Log4j in Servlet 3.0+ environment."");
    final Log4jWebInitializer initializer = Log4jWebInitializerImpl.getLog4jWebInitializer(servletContext);
    initializer.initialize();
        initializer.setLoggerContext();
    servletContext.addListener(new Log4jServletContextListener());
    final FilterRegistration.Dynamic filter = servletContext.addFilter(""log4jServletFilter"", new Log4jServletFilter());
    filter.addMappingForUrlPatterns(EnumSet.allOf(DispatcherType.class), false, ""/*"");
}",-0.18181818181818182,-0.5550239234449762,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.14305849189570125,0.16666666666666666,0.0,-0.16279340490885932
wicket,remotes/origin/bugs-dot-jar_WICKET-1619_b154d12f,1,"/**
 *  Create a new increment link. May be subclassed to make use of specialized links, e.g. Ajaxian
 *  links.
 *
 *  @param id
 *             the link id
 *  @param pageable
 *             the pageable to control
 *  @param increment
 *             the increment
 *  @return the increment link
 */
protected Link<?> newPagingNavigationIncrementLink(String id, IPageable pageable, int increment) {
    return new PagingNavigationIncrementLink<Void>(id, pageable, increment) {

        private static final long serialVersionUID = 1L;

        @Override
        public boolean isEnabled() {
            return PagingNavigator.this.isEnabled() && PagingNavigator.this.isEnableAllowed();
        }
    };
}","/**
 *  Create a new increment link. May be subclassed to make use of specialized links, e.g. Ajaxian
 *  links.
 *
 *  @param id
 *             the link id
 *  @param pageable
 *             the pageable to control
 *  @param increment
 *             the increment
 *  @return the increment link
 */
","protected Link<?> newPagingNavigationIncrementLink(String id, IPageable pageable, int increment) {
    return new PagingNavigationIncrementLink<Void>(id, pageable, increment) {

        private static final long serialVersionUID = 1L;

        @Override
        public boolean isEnabled() {
            return PagingNavigator.this.isEnabled() && PagingNavigator.this.isEnableAllowed();
        }
    };
}",-0.22727272727272727,0.39712918660287067,-0.6,-0.5,-0.4166666666666667,-0.10515873015873016,0.29894291754756874,-0.3333333333333333,1.9210526315789473,-0.104758447007025
camel,remotes/origin/bugs-dot-jar_CAMEL-7456_02da984a,3,"public void setPropertySuffix(String propertySuffix) {
    this.propertySuffix = propertySuffix;
}",,"public void setPropertySuffix(String propertySuffix) {
    this.propertySuffix = propertySuffix;
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,1.0606060606060603,-0.5,1.3421052631578947,-0.16279340490885932
wicket,remotes/origin/bugs-dot-jar_WICKET-5114_518c933b,1,"/**
 *  Stringizes this url
 *
 *  @param mode
 *             {@link StringMode} that determins how to stringize the url
 *  @param charset
 *             charset
 *  @return sringized version of this url
 */
public String toString(StringMode mode, Charset charset) {
    StringBuilder result = new StringBuilder();
    final String path = getPath(charset);
    if (StringMode.FULL == mode) {
        if (Strings.isEmpty(host)) {
            throw new IllegalStateException(""Cannot render this url in "" + StringMode.FULL.name() + "" mode because it does not have a host set."");
        }
        if (Strings.isEmpty(protocol) == false) {
            result.append(protocol);
            result.append(""://"");
        } else if (Strings.isEmpty(protocol) && Strings.isEmpty(host) == false) {
            result.append(""//"");
        }
        result.append(host);
        if (port != null && port.equals(getDefaultPortForProtocol(protocol)) == false) {
            result.append(':');
            result.append(port);
        }
        if (path.contains("".."")) {
            throw new IllegalStateException(""Cannot render this url in "" + StringMode.FULL.name() + "" mode because it has a `..` segment: "" + toString());
        }
        if (!path.startsWith(""/"")) {
            result.append('/');
        }
    }
    result.append(path);
    result.append(getQueryString(charset));
    return result.toString();
}","/**
 *  Stringizes this url
 *
 *  @param mode
 *             {@link StringMode} that determins how to stringize the url
 *  @param charset
 *             charset
 *  @return sringized version of this url
 */
","public String toString(StringMode mode, Charset charset) {
    StringBuilder result = new StringBuilder();
    final String path = getPath(charset);
    if (StringMode.FULL == mode) {
        if (Strings.isEmpty(host)) {
            throw new IllegalStateException(""Cannot render this url in "" + StringMode.FULL.name() + "" mode because it does not have a host set."");
        }
        if (Strings.isEmpty(protocol) == false) {
            result.append(protocol);
            result.append(""://"");
        } else if (Strings.isEmpty(protocol) && Strings.isEmpty(host) == false) {
            result.append(""//"");
        }
        result.append(host);
        if (port != null && port.equals(getDefaultPortForProtocol(protocol)) == false) {
            result.append(':');
            result.append(port);
        }
        if (path.contains("".."")) {
            throw new IllegalStateException(""Cannot render this url in "" + StringMode.FULL.name() + "" mode because it has a `..` segment: "" + toString());
        }
        if (!path.startsWith(""/"")) {
            result.append('/');
        }
    }
    result.append(path);
    result.append(getQueryString(charset));
    return result.toString();
}",0.6818181818181818,0.26315789473684204,1.2,0.5,1.1666666666666667,1.1150793650793651,-0.5444679351656094,1.4166666666666667,-0.02631578947368421,1.6607112601787657
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2642_36fe017c,0,"/**
 * Creates a new commit. The caller must acknowledge the commit either with
 * {@link #done(Commit, boolean, CommitInfo)} or {@link #canceled(Commit)},
 * depending on the result of the commit.
 *
 * @param base the base revision for the commit or <code>null</code> if the
 *             commit should use the current head revision as base.
 * @param branch the branch instance if this is a branch commit. The life
 *               time of this branch commit is controlled by the
 *               reachability of this parameter. Once {@code branch} is
 *               weakly reachable, the document store implementation is
 *               free to remove the commits associated with the branch.
 * @return a new commit.
 */
@Nonnull
Commit newCommit(@Nullable Revision base, @Nullable DocumentNodeStoreBranch branch) {
    if (base == null) {
        base = headRevision;
    }
    backgroundOperationLock.readLock().lock();
    boolean success = false;
    Commit c;
    try {
        c = new Commit(this, commitQueue.createRevision(), base, branch);
        success = true;
    } finally {
        if (!success) {
            backgroundOperationLock.readLock().unlock();
        }
    }
    return c;
}","/**
 * Creates a new commit. The caller must acknowledge the commit either with
 * {@link #done(Commit, boolean, CommitInfo)} or {@link #canceled(Commit)},
 * depending on the result of the commit.
 *
 * @param base the base revision for the commit or <code>null</code> if the
 *             commit should use the current head revision as base.
 * @param branch the branch instance if this is a branch commit. The life
 *               time of this branch commit is controlled by the
 *               reachability of this parameter. Once {@code branch} is
 *               weakly reachable, the document store implementation is
 *               free to remove the commits associated with the branch.
 * @return a new commit.
 */
","@Nonnull
Commit newCommit(@Nullable Revision base, @Nullable DocumentNodeStoreBranch branch) {
    if (base == null) {
        base = headRevision;
    }
    backgroundOperationLock.readLock().lock();
    boolean success = false;
    Commit c;
    try {
        c = new Commit(this, commitQueue.createRevision(), base, branch);
        success = true;
    } finally {
        if (!success) {
            backgroundOperationLock.readLock().unlock();
        }
    }
    return c;
}",0.18181818181818182,0.07177033492822962,-0.2,0.0,-0.08333333333333333,-0.04365079365079365,-0.12558139534883714,-0.08333333333333333,-0.02631578947368421,-0.02589858404937674
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1877_716e1237,0,"private static void preAsyncRunNodeStatus(NodeBuilder builder, String name) {
    String now = now();
    builder.getChildNode(INDEX_DEFINITIONS_NAME).setProperty(name + ""-status"", STATUS_RUNNING).setProperty(name + ""-start"", now, Type.DATE).removeProperty(name + ""-done"");
}",,"private static void preAsyncRunNodeStatus(NodeBuilder builder, String name) {
    String now = now();
    builder.getChildNode(INDEX_DEFINITIONS_NAME).setProperty(name + ""-status"", STATUS_RUNNING).setProperty(name + ""-start"", now, Type.DATE).removeProperty(name + ""-done"");
}",-0.45454545454545453,-0.47368421052631593,-0.6,-1.0,-0.4166666666666667,-0.07341269841269843,0.6324171952078927,-0.08333333333333333,-0.02631578947368421,-0.07927248837329921
maven,remotes/origin/bugs-dot-jar_MNG-4933_469d0096,1,"public void alignToBaseDirectory(Model model, File basedir) {
    Build build = model.getBuild();
    if (build != null) {
        build.setDirectory(alignToBaseDirectory(build.getDirectory(), basedir));
        build.setSourceDirectory(alignToBaseDirectory(build.getSourceDirectory(), basedir));
        build.setTestSourceDirectory(alignToBaseDirectory(build.getTestSourceDirectory(), basedir));
        for (Resource resource : build.getResources()) {
            resource.setDirectory(alignToBaseDirectory(resource.getDirectory(), basedir));
        }
        for (Resource resource : build.getTestResources()) {
            resource.setDirectory(alignToBaseDirectory(resource.getDirectory(), basedir));
        }
        if (build.getFilters() != null) {
            List<String> filters = new ArrayList<String>();
            for (String filter : build.getFilters()) {
                filters.add(alignToBaseDirectory(filter, basedir));
            }
            build.setFilters(filters);
        }
        build.setOutputDirectory(alignToBaseDirectory(build.getOutputDirectory(), basedir));
        build.setTestOutputDirectory(alignToBaseDirectory(build.getTestOutputDirectory(), basedir));
    }
    Reporting reporting = model.getReporting();
    if (reporting != null) {
        reporting.setOutputDirectory(alignToBaseDirectory(reporting.getOutputDirectory(), basedir));
    }
}",,"public void alignToBaseDirectory(Model model, File basedir) {
    Build build = model.getBuild();
    if (build != null) {
        build.setDirectory(alignToBaseDirectory(build.getDirectory(), basedir));
        build.setSourceDirectory(alignToBaseDirectory(build.getSourceDirectory(), basedir));
        build.setTestSourceDirectory(alignToBaseDirectory(build.getTestSourceDirectory(), basedir));
        for (Resource resource : build.getResources()) {
            resource.setDirectory(alignToBaseDirectory(resource.getDirectory(), basedir));
        }
        for (Resource resource : build.getTestResources()) {
            resource.setDirectory(alignToBaseDirectory(resource.getDirectory(), basedir));
        }
        if (build.getFilters() != null) {
            List<String> filters = new ArrayList<String>();
            for (String filter : build.getFilters()) {
                filters.add(alignToBaseDirectory(filter, basedir));
            }
            build.setFilters(filters);
        }
        build.setOutputDirectory(alignToBaseDirectory(build.getOutputDirectory(), basedir));
        build.setTestOutputDirectory(alignToBaseDirectory(build.getTestOutputDirectory(), basedir));
    }
    Reporting reporting = model.getReporting();
    if (reporting != null) {
        reporting.setOutputDirectory(alignToBaseDirectory(reporting.getOutputDirectory(), basedir));
    }
}",0.5909090909090909,0.36842105263157876,0.6,0.5,0.08333333333333333,0.16865079365079363,-0.48978153629316407,2.25,-0.02631578947368421,0.4822438523999699
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-193_8ad5a888,3,"public static String toPrintableString(byte[] ba, int offset, int len, int maxLen) {
    StringBuilder sb = new StringBuilder();
    int plen = Math.min(len, maxLen);
    for (int i = 0; i < plen; i++) {
        int c = 0xff & ba[offset + i];
        if (c >= 32 && c <= 126)
            sb.append((char) c);
        else
            sb.append(""%"" + String.format(""%02x;"", c));
    }
    if (len > maxLen) {
        sb.append(""... TRUNCATED"");
    }
    return sb.toString();
}",,"public static String toPrintableString(byte[] ba, int offset, int len, int maxLen) {
    StringBuilder sb = new StringBuilder();
    int plen = Math.min(len, maxLen);
    for (int i = 0; i < plen; i++) {
        int c = 0xff & ba[offset + i];
        if (c >= 32 && c <= 126)
            sb.append((char) c);
        else
            sb.append(""%"" + String.format(""%02x;"", c));
    }
    if (len > maxLen) {
        sb.append(""... TRUNCATED"");
    }
    return sb.toString();
}",0.045454545454545456,0.2535885167464114,0.0,-0.5,0.3333333333333333,1.1567460317460319,-0.1199436222692035,0.0,-0.02631578947368421,0.8891708880090822
Lang,39,1,"/**
 * <p>
 * Replaces all occurrences of Strings within another String.
 * </p>
 *
 * <p>
 * A <code>null</code> reference passed to this method is a no-op, or if
 * any ""search string"" or ""string to replace"" is null, that replace will be
 * ignored.
 * </p>
 *
 * <pre>
 *  StringUtils.replaceEach(null, *, *, *) = null
 *  StringUtils.replaceEach("""", *, *, *) = """"
 *  StringUtils.replaceEach(""aba"", null, null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[0], null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", null, new String[0], *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[]{""a""}, null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[]{""a""}, new String[]{""""}, *) = ""b""
 *  StringUtils.replaceEach(""aba"", new String[]{null}, new String[]{""a""}, *) = ""aba""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""w"", ""t""}, *) = ""wcte""
 *  (example of how it repeats)
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""t""}, false) = ""dcte""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""t""}, true) = ""tcte""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""ab""}, *) = IllegalArgumentException
 * </pre>
 *
 * @param text
 *            text to search and replace in, no-op if null
 * @param searchList
 *            the Strings to search for, no-op if null
 * @param replacementList
 *            the Strings to replace them with, no-op if null
 * @param repeat if true, then replace repeatedly
 *       until there are no more possible replacements or timeToLive < 0
 * @param timeToLive
 *            if less than 0 then there is a circular reference and endless
 *            loop
 * @return the text with any replacements processed, <code>null</code> if
 *         null String input
 * @throws IllegalArgumentException
 *             if the search is repeating and there is an endless loop due
 *             to outputs of one being inputs to another
 * @throws IndexOutOfBoundsException
 *             if the lengths of the arrays are not the same (null is ok,
 *             and/or size 0)
 * @since 2.4
 */
private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {
    if (text == null || text.length() == 0 || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {
        return text;
    }
    // if recursing, this shouldnt be less than 0
    if (timeToLive < 0) {
        throw new IllegalStateException(""TimeToLive of "" + timeToLive + "" is less than 0: "" + text);
    }
    int searchLength = searchList.length;
    int replacementLength = replacementList.length;
    // make sure lengths are ok, these need to be equal
    if (searchLength != replacementLength) {
        throw new IllegalArgumentException(""Search and Replace array lengths don't match: "" + searchLength + "" vs "" + replacementLength);
    }
    // keep track of which still have matches
    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];
    // index on index that the match was found
    int textIndex = -1;
    int replaceIndex = -1;
    int tempIndex = -1;
    // NOTE: logic duplicated below START
    for (int i = 0; i < searchLength; i++) {
        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {
            continue;
        }
        tempIndex = text.indexOf(searchList[i]);
        // see if we need to keep searching for this
        if (tempIndex == -1) {
            noMoreMatchesForReplIndex[i] = true;
        } else {
            if (textIndex == -1 || tempIndex < textIndex) {
                textIndex = tempIndex;
                replaceIndex = i;
            }
        }
    }
    // no search strings found, we are done
    if (textIndex == -1) {
        return text;
    }
    int start = 0;
    // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit
    int increase = 0;
    // count the replacement text elements that are larger than their corresponding text being replaced
    for (int i = 0; i < searchList.length; i++) {
        int greater = replacementList[i].length() - searchList[i].length();
        if (greater > 0) {
            // assume 3 matches
            increase += 3 * greater;
        }
    }
    // have upper-bound at 20% increase, then let Java take over
    increase = Math.min(increase, text.length() / 5);
    StringBuilder buf = new StringBuilder(text.length() + increase);
    while (textIndex != -1) {
        for (int i = start; i < textIndex; i++) {
            buf.append(text.charAt(i));
        }
        buf.append(replacementList[replaceIndex]);
        start = textIndex + searchList[replaceIndex].length();
        textIndex = -1;
        replaceIndex = -1;
        tempIndex = -1;
        // NOTE: logic mostly duplicated above START
        for (int i = 0; i < searchLength; i++) {
            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {
                continue;
            }
            tempIndex = text.indexOf(searchList[i], start);
            // see if we need to keep searching for this
            if (tempIndex == -1) {
                noMoreMatchesForReplIndex[i] = true;
            } else {
                if (textIndex == -1 || tempIndex < textIndex) {
                    textIndex = tempIndex;
                    replaceIndex = i;
                }
            }
        }
    // NOTE: logic duplicated above END
    }
    int textLength = text.length();
    for (int i = start; i < textLength; i++) {
        buf.append(text.charAt(i));
    }
    String result = buf.toString();
    if (!repeat) {
        return result;
    }
    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);
}","/**
 * <p>
 * Replaces all occurrences of Strings within another String.
 * </p>
 *
 * <p>
 * A <code>null</code> reference passed to this method is a no-op, or if
 * any ""search string"" or ""string to replace"" is null, that replace will be
 * ignored.
 * </p>
 *
 * <pre>
 *  StringUtils.replaceEach(null, *, *, *) = null
 *  StringUtils.replaceEach("""", *, *, *) = """"
 *  StringUtils.replaceEach(""aba"", null, null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[0], null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", null, new String[0], *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[]{""a""}, null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[]{""a""}, new String[]{""""}, *) = ""b""
 *  StringUtils.replaceEach(""aba"", new String[]{null}, new String[]{""a""}, *) = ""aba""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""w"", ""t""}, *) = ""wcte""
 *  (example of how it repeats)
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""t""}, false) = ""dcte""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""t""}, true) = ""tcte""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""ab""}, *) = IllegalArgumentException
 * </pre>
 *
 * @param text
 *            text to search and replace in, no-op if null
 * @param searchList
 *            the Strings to search for, no-op if null
 * @param replacementList
 *            the Strings to replace them with, no-op if null
 * @param repeat if true, then replace repeatedly
 *       until there are no more possible replacements or timeToLive < 0
 * @param timeToLive
 *            if less than 0 then there is a circular reference and endless
 *            loop
 * @return the text with any replacements processed, <code>null</code> if
 *         null String input
 * @throws IllegalArgumentException
 *             if the search is repeating and there is an endless loop due
 *             to outputs of one being inputs to another
 * @throws IndexOutOfBoundsException
 *             if the lengths of the arrays are not the same (null is ok,
 *             and/or size 0)
 * @since 2.4
 */
","private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {
    if (text == null || text.length() == 0 || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {
        return text;
    }
        if (timeToLive < 0) {
        throw new IllegalStateException(""TimeToLive of "" + timeToLive + "" is less than 0: "" + text);
    }
    int searchLength = searchList.length;
    int replacementLength = replacementList.length;
        if (searchLength != replacementLength) {
        throw new IllegalArgumentException(""Search and Replace array lengths don't match: "" + searchLength + "" vs "" + replacementLength);
    }
        boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];
        int textIndex = -1;
    int replaceIndex = -1;
    int tempIndex = -1;
        for (int i = 0; i < searchLength; i++) {
        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {
            continue;
        }
        tempIndex = text.indexOf(searchList[i]);
                if (tempIndex == -1) {
            noMoreMatchesForReplIndex[i] = true;
        } else {
            if (textIndex == -1 || tempIndex < textIndex) {
                textIndex = tempIndex;
                replaceIndex = i;
            }
        }
    }
        if (textIndex == -1) {
        return text;
    }
    int start = 0;
        int increase = 0;
        for (int i = 0; i < searchList.length; i++) {
        int greater = replacementList[i].length() - searchList[i].length();
        if (greater > 0) {
                        increase += 3 * greater;
        }
    }
        increase = Math.min(increase, text.length() / 5);
    StringBuilder buf = new StringBuilder(text.length() + increase);
    while (textIndex != -1) {
        for (int i = start; i < textIndex; i++) {
            buf.append(text.charAt(i));
        }
        buf.append(replacementList[replaceIndex]);
        start = textIndex + searchList[replaceIndex].length();
        textIndex = -1;
        replaceIndex = -1;
        tempIndex = -1;
                for (int i = 0; i < searchLength; i++) {
            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {
                continue;
            }
            tempIndex = text.indexOf(searchList[i], start);
                        if (tempIndex == -1) {
                noMoreMatchesForReplIndex[i] = true;
            } else {
                if (textIndex == -1 || tempIndex < textIndex) {
                    textIndex = tempIndex;
                    replaceIndex = i;
                }
            }
        }
        }
    int textLength = text.length();
    for (int i = start; i < textLength; i++) {
        buf.append(text.charAt(i));
    }
    String result = buf.toString();
    if (!repeat) {
        return result;
    }
    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);
}",2.8636363636363638,0.6698564593301434,3.8,1.0,3.5,5.936507936507937,-1.254827343199436,1.0833333333333333,-0.02631578947368421,26.37760527422877
maven,remotes/origin/bugs-dot-jar_MNG-3131_56cd921f,1,"private static void decomposeParameterIntoUserInstructions(MojoDescriptor mojo, Parameter param, StringBuilder messageBuffer) {
    String expression = param.getExpression();
    if (param.isEditable()) {
        messageBuffer.append(""Inside the definition for plugin \'"" + mojo.getPluginDescriptor().getArtifactId() + ""\', specify the following:\n\n<configuration>\n  ...\n  <"" + param.getName() + "">VALUE</"" + param.getName() + "">\n</configuration>"");
        String alias = param.getAlias();
        if (StringUtils.isNotEmpty(alias) && !alias.equals(param.getName())) {
            messageBuffer.append(""\n\n-OR-\n\n<configuration>\n  ...\n  <"" + alias + "">VALUE</"" + alias + "">\n</configuration>\n"");
        }
    }
    if (StringUtils.isEmpty(expression)) {
        messageBuffer.append(""."");
    } else {
        if (param.isEditable()) {
            messageBuffer.append(""\n\n-OR-\n\n"");
        }
    // addParameterUsageInfo( expression, messageBuffer );
    }
}",,"private static void decomposeParameterIntoUserInstructions(MojoDescriptor mojo, Parameter param, StringBuilder messageBuffer) {
    String expression = param.getExpression();
    if (param.isEditable()) {
        messageBuffer.append(""Inside the definition for plugin \'"" + mojo.getPluginDescriptor().getArtifactId() + ""\', specify the following:\n\n<configuration>\n  ...\n  <"" + param.getName() + "">VALUE</"" + param.getName() + "">\n</configuration>"");
        String alias = param.getAlias();
        if (StringUtils.isNotEmpty(alias) && !alias.equals(param.getName())) {
            messageBuffer.append(""\n\n-OR-\n\n<configuration>\n  ...\n  <"" + alias + "">VALUE</"" + alias + "">\n</configuration>\n"");
        }
    }
    if (StringUtils.isEmpty(expression)) {
        messageBuffer.append(""."");
    } else {
        if (param.isEditable()) {
            messageBuffer.append(""\n\n-OR-\n\n"");
        }
        }
}",0.13636363636363635,0.1913875598086124,0.2,0.0,0.5833333333333334,0.375,-0.19210711768851294,0.8333333333333334,-0.02631578947368421,0.3801109939316401
wicket,remotes/origin/bugs-dot-jar_WICKET-3906_aadaa4e9,1,"/**
 *  @see org.apache.wicket.request.mapper.parameter.INamedParameters#set(java.lang.String,
 *       java.lang.Object)
 */
public PageParameters set(final String name, final Object value) {
    set(name, value, -1);
    return this;
}","/**
 *  @see org.apache.wicket.request.mapper.parameter.INamedParameters#set(java.lang.String,
 *       java.lang.Object)
 */
","public PageParameters set(final String name, final Object value) {
    set(name, value, -1);
    return this;
}",-0.45454545454545453,-0.47368421052631593,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.8046511627906971,-0.4166666666666667,0.39473684210526316,-0.16279340490885932
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-2974_5eceb10e,0,"private void deleteTablets(MergeInfo info) throws AccumuloException {
    KeyExtent extent = info.getExtent();
    String targetSystemTable = extent.isMeta() ? RootTable.NAME : MetadataTable.NAME;
    Master.log.debug(""Deleting tablets for "" + extent);
    char timeType = '\0';
    KeyExtent followingTablet = null;
    if (extent.getEndRow() != null) {
        Key nextExtent = new Key(extent.getEndRow()).followingKey(PartialKey.ROW);
        followingTablet = getHighTablet(new KeyExtent(extent.getTableId(), nextExtent.getRow(), extent.getEndRow()));
        Master.log.debug(""Found following tablet "" + followingTablet);
    }
    try {
        Connector conn = this.master.getConnector();
        Text start = extent.getPrevEndRow();
        if (start == null) {
            start = new Text();
        }
        Master.log.debug(""Making file deletion entries for "" + extent);
        Range deleteRange = new Range(KeyExtent.getMetadataEntry(extent.getTableId(), start), false, KeyExtent.getMetadataEntry(extent.getTableId(), extent.getEndRow()), true);
        Scanner scanner = conn.createScanner(targetSystemTable, Authorizations.EMPTY);
        scanner.setRange(deleteRange);
        TabletsSection.ServerColumnFamily.DIRECTORY_COLUMN.fetch(scanner);
        TabletsSection.ServerColumnFamily.TIME_COLUMN.fetch(scanner);
        scanner.fetchColumnFamily(DataFileColumnFamily.NAME);
        scanner.fetchColumnFamily(TabletsSection.CurrentLocationColumnFamily.NAME);
        Set<FileRef> datafiles = new TreeSet<FileRef>();
        for (Entry<Key, Value> entry : scanner) {
            Key key = entry.getKey();
            if (key.compareColumnFamily(DataFileColumnFamily.NAME) == 0) {
                datafiles.add(new FileRef(this.master.fs, key));
                if (datafiles.size() > 1000) {
                    MetadataTableUtil.addDeleteEntries(extent, datafiles, SystemCredentials.get());
                    datafiles.clear();
                }
            } else if (TabletsSection.ServerColumnFamily.TIME_COLUMN.hasColumns(key)) {
                timeType = entry.getValue().toString().charAt(0);
            } else if (key.compareColumnFamily(TabletsSection.CurrentLocationColumnFamily.NAME) == 0) {
                throw new IllegalStateException(""Tablet "" + key.getRow() + "" is assigned during a merge!"");
            } else if (TabletsSection.ServerColumnFamily.DIRECTORY_COLUMN.hasColumns(key)) {
                datafiles.add(new FileRef(entry.getValue().toString(), this.master.fs.getFullPath(FileType.TABLE, entry.getValue().toString())));
                if (datafiles.size() > 1000) {
                    MetadataTableUtil.addDeleteEntries(extent, datafiles, SystemCredentials.get());
                    datafiles.clear();
                }
            }
        }
        MetadataTableUtil.addDeleteEntries(extent, datafiles, SystemCredentials.get());
        BatchWriter bw = conn.createBatchWriter(targetSystemTable, new BatchWriterConfig());
        try {
            deleteTablets(info, deleteRange, bw, conn);
        } finally {
            bw.close();
        }
        if (followingTablet != null) {
            Master.log.debug(""Updating prevRow of "" + followingTablet + "" to "" + extent.getPrevEndRow());
            bw = conn.createBatchWriter(targetSystemTable, new BatchWriterConfig());
            try {
                Mutation m = new Mutation(followingTablet.getMetadataEntry());
                TabletsSection.TabletColumnFamily.PREV_ROW_COLUMN.put(m, KeyExtent.encodePrevEndRow(extent.getPrevEndRow()));
                ChoppedColumnFamily.CHOPPED_COLUMN.putDelete(m);
                bw.addMutation(m);
                bw.flush();
            } finally {
                bw.close();
            }
        } else {
            // Recreate the default tablet to hold the end of the table
            Master.log.debug(""Recreating the last tablet to point to "" + extent.getPrevEndRow());
            String tdir = master.getFileSystem().choose(ServerConstants.getTablesDirs()) + ""/"" + extent.getTableId() + Constants.DEFAULT_TABLET_LOCATION;
            MetadataTableUtil.addTablet(new KeyExtent(extent.getTableId(), null, extent.getPrevEndRow()), tdir, SystemCredentials.get(), timeType, this.master.masterLock);
        }
    } catch (Exception ex) {
        throw new AccumuloException(ex);
    }
}",,"private void deleteTablets(MergeInfo info) throws AccumuloException {
    KeyExtent extent = info.getExtent();
    String targetSystemTable = extent.isMeta() ? RootTable.NAME : MetadataTable.NAME;
    Master.log.debug(""Deleting tablets for "" + extent);
    char timeType = '\0';
    KeyExtent followingTablet = null;
    if (extent.getEndRow() != null) {
        Key nextExtent = new Key(extent.getEndRow()).followingKey(PartialKey.ROW);
        followingTablet = getHighTablet(new KeyExtent(extent.getTableId(), nextExtent.getRow(), extent.getEndRow()));
        Master.log.debug(""Found following tablet "" + followingTablet);
    }
    try {
        Connector conn = this.master.getConnector();
        Text start = extent.getPrevEndRow();
        if (start == null) {
            start = new Text();
        }
        Master.log.debug(""Making file deletion entries for "" + extent);
        Range deleteRange = new Range(KeyExtent.getMetadataEntry(extent.getTableId(), start), false, KeyExtent.getMetadataEntry(extent.getTableId(), extent.getEndRow()), true);
        Scanner scanner = conn.createScanner(targetSystemTable, Authorizations.EMPTY);
        scanner.setRange(deleteRange);
        TabletsSection.ServerColumnFamily.DIRECTORY_COLUMN.fetch(scanner);
        TabletsSection.ServerColumnFamily.TIME_COLUMN.fetch(scanner);
        scanner.fetchColumnFamily(DataFileColumnFamily.NAME);
        scanner.fetchColumnFamily(TabletsSection.CurrentLocationColumnFamily.NAME);
        Set<FileRef> datafiles = new TreeSet<FileRef>();
        for (Entry<Key, Value> entry : scanner) {
            Key key = entry.getKey();
            if (key.compareColumnFamily(DataFileColumnFamily.NAME) == 0) {
                datafiles.add(new FileRef(this.master.fs, key));
                if (datafiles.size() > 1000) {
                    MetadataTableUtil.addDeleteEntries(extent, datafiles, SystemCredentials.get());
                    datafiles.clear();
                }
            } else if (TabletsSection.ServerColumnFamily.TIME_COLUMN.hasColumns(key)) {
                timeType = entry.getValue().toString().charAt(0);
            } else if (key.compareColumnFamily(TabletsSection.CurrentLocationColumnFamily.NAME) == 0) {
                throw new IllegalStateException(""Tablet "" + key.getRow() + "" is assigned during a merge!"");
            } else if (TabletsSection.ServerColumnFamily.DIRECTORY_COLUMN.hasColumns(key)) {
                datafiles.add(new FileRef(entry.getValue().toString(), this.master.fs.getFullPath(FileType.TABLE, entry.getValue().toString())));
                if (datafiles.size() > 1000) {
                    MetadataTableUtil.addDeleteEntries(extent, datafiles, SystemCredentials.get());
                    datafiles.clear();
                }
            }
        }
        MetadataTableUtil.addDeleteEntries(extent, datafiles, SystemCredentials.get());
        BatchWriter bw = conn.createBatchWriter(targetSystemTable, new BatchWriterConfig());
        try {
            deleteTablets(info, deleteRange, bw, conn);
        } finally {
            bw.close();
        }
        if (followingTablet != null) {
            Master.log.debug(""Updating prevRow of "" + followingTablet + "" to "" + extent.getPrevEndRow());
            bw = conn.createBatchWriter(targetSystemTable, new BatchWriterConfig());
            try {
                Mutation m = new Mutation(followingTablet.getMetadataEntry());
                TabletsSection.TabletColumnFamily.PREV_ROW_COLUMN.put(m, KeyExtent.encodePrevEndRow(extent.getPrevEndRow()));
                ChoppedColumnFamily.CHOPPED_COLUMN.putDelete(m);
                bw.addMutation(m);
                bw.flush();
            } finally {
                bw.close();
            }
        } else {
                        Master.log.debug(""Recreating the last tablet to point to "" + extent.getPrevEndRow());
            String tdir = master.getFileSystem().choose(ServerConstants.getTablesDirs()) + ""/"" + extent.getTableId() + Constants.DEFAULT_TABLET_LOCATION;
            MetadataTableUtil.addTablet(new KeyExtent(extent.getTableId(), null, extent.getPrevEndRow()), tdir, SystemCredentials.get(), timeType, this.master.masterLock);
        }
    } catch (Exception ex) {
        throw new AccumuloException(ex);
    }
}",2.727272727272727,0.8181818181818182,2.2,2.5,1.25,0.6170634920634921,-1.2193093727977444,5.75,-0.02631578947368421,5.067236043636866
wicket,remotes/origin/bugs-dot-jar_WICKET-4259_1f128536,3,"/**
 *  Gets the label component.
 *
 *  @return The label component
 */
protected final Component getLabel() {
    if (label == null) {
        initLabelAndEditor(getDelegatingParentModel());
    }
    return label;
}","/**
 *  Gets the label component.
 *
 *  @return The label component
 */
","protected final Component getLabel() {
    if (label == null) {
        initLabelAndEditor(getDelegatingParentModel());
    }
    return label;
}",-0.36363636363636365,-0.11483253588516758,-0.4,-0.5,-0.25,-0.3650793650793651,0.6634249471458771,-0.3333333333333333,2.552631578947368,-0.16279340490885932
Math,68,1,"/**
 * {@inheritDoc}
 */
@Override
protected VectorialPointValuePair doOptimize() throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {
    // arrays shared with the other private methods
    solvedCols = Math.min(rows, cols);
    diagR = new double[cols];
    jacNorm = new double[cols];
    beta = new double[cols];
    permutation = new int[cols];
    lmDir = new double[cols];
    // local point
    double delta = 0;
    double xNorm = 0;
    double[] diag = new double[cols];
    double[] oldX = new double[cols];
    double[] oldRes = new double[rows];
    double[] work1 = new double[cols];
    double[] work2 = new double[cols];
    double[] work3 = new double[cols];
    // evaluate the function at the starting point and calculate its norm
    updateResidualsAndCost();
    // outer loop
    lmPar = 0;
    boolean firstIteration = true;
    while (true) {
        incrementIterationsCounter();
        // compute the Q.R. decomposition of the jacobian matrix
        updateJacobian();
        qrDecomposition();
        // compute Qt.res
        qTy(residuals);
        // so let jacobian contain the R matrix with its diagonal elements
        for (int k = 0; k < solvedCols; ++k) {
            int pk = permutation[k];
            jacobian[k][pk] = diagR[pk];
        }
        if (firstIteration) {
            // scale the point according to the norms of the columns
            // of the initial jacobian
            xNorm = 0;
            for (int k = 0; k < cols; ++k) {
                double dk = jacNorm[k];
                if (dk == 0) {
                    dk = 1.0;
                }
                double xk = dk * point[k];
                xNorm += xk * xk;
                diag[k] = dk;
            }
            xNorm = Math.sqrt(xNorm);
            // initialize the step bound delta
            delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);
        }
        // check orthogonality between function vector and jacobian columns
        double maxCosine = 0;
        if (cost != 0) {
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                double s = jacNorm[pj];
                if (s != 0) {
                    double sum = 0;
                    for (int i = 0; i <= j; ++i) {
                        sum += jacobian[i][pj] * residuals[i];
                    }
                    maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));
                }
            }
        }
        if (maxCosine <= orthoTolerance) {
            // convergence has been reached
            return new VectorialPointValuePair(point, objective);
        }
        // rescale if necessary
        for (int j = 0; j < cols; ++j) {
            diag[j] = Math.max(diag[j], jacNorm[j]);
        }
        // inner loop
        for (double ratio = 0; ratio < 1.0e-4; ) {
            // save the state
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                oldX[pj] = point[pj];
            }
            double previousCost = cost;
            double[] tmpVec = residuals;
            residuals = oldRes;
            oldRes = tmpVec;
            // determine the Levenberg-Marquardt parameter
            determineLMParameter(oldRes, delta, diag, work1, work2, work3);
            // compute the new point and the norm of the evolution direction
            double lmNorm = 0;
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                lmDir[pj] = -lmDir[pj];
                point[pj] = oldX[pj] + lmDir[pj];
                double s = diag[pj] * lmDir[pj];
                lmNorm += s * s;
            }
            lmNorm = Math.sqrt(lmNorm);
            // on the first iteration, adjust the initial step bound.
            if (firstIteration) {
                delta = Math.min(delta, lmNorm);
            }
            // evaluate the function at x + p and calculate its norm
            updateResidualsAndCost();
            // compute the scaled actual reduction
            double actRed = -1.0;
            if (0.1 * cost < previousCost) {
                double r = cost / previousCost;
                actRed = 1.0 - r * r;
            }
            // and the scaled directional derivative
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                double dirJ = lmDir[pj];
                work1[j] = 0;
                for (int i = 0; i <= j; ++i) {
                    work1[i] += jacobian[i][pj] * dirJ;
                }
            }
            double coeff1 = 0;
            for (int j = 0; j < solvedCols; ++j) {
                coeff1 += work1[j] * work1[j];
            }
            double pc2 = previousCost * previousCost;
            coeff1 = coeff1 / pc2;
            double coeff2 = lmPar * lmNorm * lmNorm / pc2;
            double preRed = coeff1 + 2 * coeff2;
            double dirDer = -(coeff1 + coeff2);
            // ratio of the actual to the predicted reduction
            ratio = (preRed == 0) ? 0 : (actRed / preRed);
            // update the step bound
            if (ratio <= 0.25) {
                double tmp = (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;
                if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {
                    tmp = 0.1;
                }
                delta = tmp * Math.min(delta, 10.0 * lmNorm);
                lmPar /= tmp;
            } else if ((lmPar == 0) || (ratio >= 0.75)) {
                delta = 2 * lmNorm;
                lmPar *= 0.5;
            }
            // test for successful iteration.
            if (ratio >= 1.0e-4) {
                // successful iteration, update the norm
                firstIteration = false;
                xNorm = 0;
                for (int k = 0; k < cols; ++k) {
                    double xK = diag[k] * point[k];
                    xNorm += xK * xK;
                }
                xNorm = Math.sqrt(xNorm);
            } else {
                // failed iteration, reset the previous values
                cost = previousCost;
                for (int j = 0; j < solvedCols; ++j) {
                    int pj = permutation[j];
                    point[pj] = oldX[pj];
                }
                tmpVec = residuals;
                residuals = oldRes;
                oldRes = tmpVec;
            }
            // we use the Levenberg-Marquardt specific convergence parameters
            if (((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance) && (ratio <= 2.0)) || (delta <= parRelativeTolerance * xNorm)) {
                return new VectorialPointValuePair(point, objective);
            }
            // (2.2204e-16 is the machine epsilon for IEEE754)
            if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {
                throw new OptimizationException(""cost relative tolerance is too small ({0}),"" + "" no further reduction in the"" + "" sum of squares is possible"", costRelativeTolerance);
            } else if (delta <= 2.2204e-16 * xNorm) {
                throw new OptimizationException(""parameters relative tolerance is too small"" + "" ({0}), no further improvement in"" + "" the approximate solution is possible"", parRelativeTolerance);
            } else if (maxCosine <= 2.2204e-16) {
                throw new OptimizationException(""orthogonality tolerance is too small ({0}),"" + "" solution is orthogonal to the jacobian"", orthoTolerance);
            }
        }
    }
}","/**
 * {@inheritDoc}
 */
","@Override
protected VectorialPointValuePair doOptimize() throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {
        solvedCols = Math.min(rows, cols);
    diagR = new double[cols];
    jacNorm = new double[cols];
    beta = new double[cols];
    permutation = new int[cols];
    lmDir = new double[cols];
        double delta = 0;
    double xNorm = 0;
    double[] diag = new double[cols];
    double[] oldX = new double[cols];
    double[] oldRes = new double[rows];
    double[] work1 = new double[cols];
    double[] work2 = new double[cols];
    double[] work3 = new double[cols];
        updateResidualsAndCost();
        lmPar = 0;
    boolean firstIteration = true;
    while (true) {
        incrementIterationsCounter();
                updateJacobian();
        qrDecomposition();
                qTy(residuals);
                for (int k = 0; k < solvedCols; ++k) {
            int pk = permutation[k];
            jacobian[k][pk] = diagR[pk];
        }
        if (firstIteration) {
                                    xNorm = 0;
            for (int k = 0; k < cols; ++k) {
                double dk = jacNorm[k];
                if (dk == 0) {
                    dk = 1.0;
                }
                double xk = dk * point[k];
                xNorm += xk * xk;
                diag[k] = dk;
            }
            xNorm = Math.sqrt(xNorm);
                        delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);
        }
                double maxCosine = 0;
        if (cost != 0) {
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                double s = jacNorm[pj];
                if (s != 0) {
                    double sum = 0;
                    for (int i = 0; i <= j; ++i) {
                        sum += jacobian[i][pj] * residuals[i];
                    }
                    maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));
                }
            }
        }
        if (maxCosine <= orthoTolerance) {
                        return new VectorialPointValuePair(point, objective);
        }
                for (int j = 0; j < cols; ++j) {
            diag[j] = Math.max(diag[j], jacNorm[j]);
        }
                for (double ratio = 0; ratio < 1.0e-4; ) {
                        for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                oldX[pj] = point[pj];
            }
            double previousCost = cost;
            double[] tmpVec = residuals;
            residuals = oldRes;
            oldRes = tmpVec;
                        determineLMParameter(oldRes, delta, diag, work1, work2, work3);
                        double lmNorm = 0;
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                lmDir[pj] = -lmDir[pj];
                point[pj] = oldX[pj] + lmDir[pj];
                double s = diag[pj] * lmDir[pj];
                lmNorm += s * s;
            }
            lmNorm = Math.sqrt(lmNorm);
                        if (firstIteration) {
                delta = Math.min(delta, lmNorm);
            }
                        updateResidualsAndCost();
                        double actRed = -1.0;
            if (0.1 * cost < previousCost) {
                double r = cost / previousCost;
                actRed = 1.0 - r * r;
            }
                        for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                double dirJ = lmDir[pj];
                work1[j] = 0;
                for (int i = 0; i <= j; ++i) {
                    work1[i] += jacobian[i][pj] * dirJ;
                }
            }
            double coeff1 = 0;
            for (int j = 0; j < solvedCols; ++j) {
                coeff1 += work1[j] * work1[j];
            }
            double pc2 = previousCost * previousCost;
            coeff1 = coeff1 / pc2;
            double coeff2 = lmPar * lmNorm * lmNorm / pc2;
            double preRed = coeff1 + 2 * coeff2;
            double dirDer = -(coeff1 + coeff2);
                        ratio = (preRed == 0) ? 0 : (actRed / preRed);
                        if (ratio <= 0.25) {
                double tmp = (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;
                if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {
                    tmp = 0.1;
                }
                delta = tmp * Math.min(delta, 10.0 * lmNorm);
                lmPar /= tmp;
            } else if ((lmPar == 0) || (ratio >= 0.75)) {
                delta = 2 * lmNorm;
                lmPar *= 0.5;
            }
                        if (ratio >= 1.0e-4) {
                                firstIteration = false;
                xNorm = 0;
                for (int k = 0; k < cols; ++k) {
                    double xK = diag[k] * point[k];
                    xNorm += xK * xK;
                }
                xNorm = Math.sqrt(xNorm);
            } else {
                                cost = previousCost;
                for (int j = 0; j < solvedCols; ++j) {
                    int pj = permutation[j];
                    point[pj] = oldX[pj];
                }
                tmpVec = residuals;
                residuals = oldRes;
                oldRes = tmpVec;
            }
                        if (((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance) && (ratio <= 2.0)) || (delta <= parRelativeTolerance * xNorm)) {
                return new VectorialPointValuePair(point, objective);
            }
                        if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {
                throw new OptimizationException(""cost relative tolerance is too small ({0}),"" + "" no further reduction in the"" + "" sum of squares is possible"", costRelativeTolerance);
            } else if (delta <= 2.2204e-16 * xNorm) {
                throw new OptimizationException(""parameters relative tolerance is too small"" + "" ({0}), no further improvement in"" + "" the approximate solution is possible"", parRelativeTolerance);
            } else if (maxCosine <= 2.2204e-16) {
                throw new OptimizationException(""orthogonality tolerance is too small ({0}),"" + "" solution is orthogonal to the jacobian"", orthoTolerance);
            }
        }
    }
}",6.181818181818182,0.8899521531100476,6.4,1.5,4.666666666666667,6.990079365079365,-1.7616631430584915,1.0,-0.02631578947368421,69.16616010557676
Closure,169,2,"boolean checkArrowEquivalenceHelper(ArrowType that, boolean tolerateUnknowns) {
    // Please keep this method in sync with the hashCode() method below.
    if (!returnType.checkEquivalenceHelper(that.returnType, tolerateUnknowns)) {
        return false;
    }
    return hasEqualParameters(that, tolerateUnknowns);
}",,"boolean checkArrowEquivalenceHelper(ArrowType that, boolean tolerateUnknowns) {
        if (!returnType.checkEquivalenceHelper(that.returnType, tolerateUnknowns)) {
        return false;
    }
    return hasEqualParameters(that, tolerateUnknowns);
}",-0.36363636363636365,-0.11483253588516758,-0.4,-0.5,-0.08333333333333333,-0.3650793650793651,0.5735024665257221,-0.3333333333333333,0.39473684210526316,-0.16279340490885932
wicket,remotes/origin/bugs-dot-jar_WICKET-3511_4a875f46,1,"public String getReference() {
    return fileName;
}",,"public String getReference() {
    return fileName;
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,1.1646229739252991,-0.5,2.236842105263158,-0.16279340490885932
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-366_db4a291f,1,"@Override
public void flushTablet(TInfo tinfo, AuthInfo credentials, String lock, TKeyExtent textent) throws TException {
    try {
        checkPermission(credentials, lock, true, ""flushTablet"");
    } catch (ThriftSecurityException e) {
        log.error(e, e);
        throw new RuntimeException(e);
    }
    Tablet tablet = onlineTablets.get(new KeyExtent(textent));
    if (tablet != null) {
        log.info(""Flushing "" + tablet.getExtent());
        tablet.flush(tablet.getFlushID());
    }
}",,"@Override
public void flushTablet(TInfo tinfo, AuthInfo credentials, String lock, TKeyExtent textent) throws TException {
    try {
        checkPermission(credentials, lock, true, ""flushTablet"");
    } catch (ThriftSecurityException e) {
        log.error(e, e);
        throw new RuntimeException(e);
    }
    Tablet tablet = onlineTablets.get(new KeyExtent(textent));
    if (tablet != null) {
        log.info(""Flushing "" + tablet.getExtent());
        tablet.flush(tablet.getFlushID());
    }
}",0.0,-0.00956937799043063,0.0,-0.5,-0.25,-0.08730158730158734,-0.04862579281183915,0.08333333333333333,0.0,-0.016276804803974112
wicket,remotes/origin/bugs-dot-jar_WICKET-5345_3fc7234e,1,"/**
 *  Try to reduce url by eliminating '..' and '.' from the path where appropriate (this is
 *  somehow similar to {@link java.io.File#getCanonicalPath()}). Either by different / unexpected
 *  browser behavior or by malicious attacks it can happen that these kind of redundant urls are
 *  processed by wicket. These urls can cause some trouble when mapping the request.
 *  <p/>
 *  <strong>example:</strong>
 *
 *  the url
 *
 *  <pre>
 *  /example/..;jsessionid=234792?0
 *  </pre>
 *
 *  will not get normalized by the browser due to the ';jsessionid' string that gets appended by
 *  the servlet container. After wicket strips the jsessionid part the resulting internal url
 *  will be
 *
 *  <pre>
 *  /example/..
 *  </pre>
 *
 *  instead of
 *
 *  <pre>
 *  /
 *  </pre>
 *
 *  <p/>
 *
 *  This code correlates to <a
 *  href=""https://issues.apache.org/jira/browse/WICKET-4303"">WICKET-4303</a>
 *
 *  @return canonical url
 */
public Url canonical() {
    Url url = new Url(this);
    url.segments.clear();
    for (int i = 0; i < segments.size(); i++) {
        final String segment = segments.get(i);
        // drop '.' from path
        if (""."".equals(segment)) {
            continue;
        }
        // skip segment if following segment is a '..'
        if ((i + 1) < segments.size() && "".."".equals(segments.get(i + 1))) {
            i++;
            continue;
        }
        url.segments.add(segment);
    }
    return url;
}","/**
 *  Try to reduce url by eliminating '..' and '.' from the path where appropriate (this is
 *  somehow similar to {@link java.io.File#getCanonicalPath()}). Either by different / unexpected
 *  browser behavior or by malicious attacks it can happen that these kind of redundant urls are
 *  processed by wicket. These urls can cause some trouble when mapping the request.
 *  <p/>
 *  <strong>example:</strong>
 *
 *  the url
 *
 *  <pre>
 *  /example/..;jsessionid=234792?0
 *  </pre>
 *
 *  will not get normalized by the browser due to the ';jsessionid' string that gets appended by
 *  the servlet container. After wicket strips the jsessionid part the resulting internal url
 *  will be
 *
 *  <pre>
 *  /example/..
 *  </pre>
 *
 *  instead of
 *
 *  <pre>
 *  /
 *  </pre>
 *
 *  <p/>
 *
 *  This code correlates to <a
 *  href=""https://issues.apache.org/jira/browse/WICKET-4303"">WICKET-4303</a>
 *
 *  @return canonical url
 */
","public Url canonical() {
    Url url = new Url(this);
    url.segments.clear();
    for (int i = 0; i < segments.size(); i++) {
        final String segment = segments.get(i);
                if (""."".equals(segment)) {
            continue;
        }
                if ((i + 1) < segments.size() && "".."".equals(segments.get(i + 1))) {
            i++;
            continue;
        }
        url.segments.add(segment);
    }
    return url;
}",0.09090909090909091,0.3444976076555023,0.4,0.0,0.4166666666666667,0.5456349206349206,-0.11712473572938689,0.16666666666666666,0.05263157894736841,0.29943465707715977
wicket,remotes/origin/bugs-dot-jar_WICKET-2882_ebe56869,1,"/**
 *  Attempts to resolve a component using resolvers. Tries resolvers in the component hierarchy
 *  as well as application-wide.
 *  <p>
 *  This method encapsulates the contract of resolving components and should be used any time a
 *  component needs to be resolved under normal circumstances.
 *  </p>
 *
 *  @param container
 *  @param markupStream
 *  @param tag
 *  @return <code>null</code> if a component was could not be found
 */
public static Component resolve(final MarkupContainer container, final MarkupStream markupStream, final ComponentTag tag) {
    // try to resolve using component hierarchy
    Component cursor = container;
    while (cursor != null) {
        if (cursor instanceof IComponentResolver) {
            IComponentResolver resolver = (IComponentResolver) cursor;
            Component component = resolver.resolve(container, markupStream, tag);
            if (component != null) {
                return component;
            }
        }
        cursor = cursor.getParent();
    }
    for (final IComponentResolver resolver : Application.get().getPageSettings().getComponentResolvers()) {
        Component component = resolver.resolve(container, markupStream, tag);
        if (component != null) {
            return component;
        }
    }
    return null;
}","/**
 *  Attempts to resolve a component using resolvers. Tries resolvers in the component hierarchy
 *  as well as application-wide.
 *  <p>
 *  This method encapsulates the contract of resolving components and should be used any time a
 *  component needs to be resolved under normal circumstances.
 *  </p>
 *
 *  @param container
 *  @param markupStream
 *  @param tag
 *  @return <code>null</code> if a component was could not be found
 */
","public static Component resolve(final MarkupContainer container, final MarkupStream markupStream, final ComponentTag tag) {
        Component cursor = container;
    while (cursor != null) {
        if (cursor instanceof IComponentResolver) {
            IComponentResolver resolver = (IComponentResolver) cursor;
            Component component = resolver.resolve(container, markupStream, tag);
            if (component != null) {
                return component;
            }
        }
        cursor = cursor.getParent();
    }
    for (final IComponentResolver resolver : Application.get().getPageSettings().getComponentResolvers()) {
        Component component = resolver.resolve(container, markupStream, tag);
        if (component != null) {
            return component;
        }
    }
    return null;
}",0.2727272727272727,0.6028708133971291,0.4,0.5,0.08333333333333333,0.15674603174603172,-0.24143763213530642,0.0,-0.02631578947368421,0.14628838828282126
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-965_43517f15,0,"private static OutputStream getOutputStream(final boolean follow, final Target target) {
    final String enc = Charset.defaultCharset().name();
    PrintStream printStream = null;
    try {
        printStream = target == Target.SYSTEM_OUT ? follow ? new PrintStream(new CloseShieldOutputStream(System.out), true, enc) : System.out : follow ? new PrintStream(new CloseShieldOutputStream(System.err), true, enc) : System.err;
    } catch (final UnsupportedEncodingException ex) {
        // should never happen
        throw new IllegalStateException(""Unsupported default encoding "" + enc, ex);
    }
    final PropertiesUtil propsUtil = PropertiesUtil.getProperties();
    if (!propsUtil.getStringProperty(""os.name"").startsWith(""Windows"") || propsUtil.getBooleanProperty(""log4j.skipJansi"")) {
        return printStream;
    }
    try {
        // We type the parameter as a wildcard to avoid a hard reference to Jansi.
        final Class<?> clazz = Loader.loadClass(JANSI_CLASS);
        final Constructor<?> constructor = clazz.getConstructor(OutputStream.class);
        // LOG4J-965
        return new CloseShieldOutputStream((OutputStream) constructor.newInstance(printStream));
    } catch (final ClassNotFoundException cnfe) {
        LOGGER.debug(""Jansi is not installed, cannot find {}"", JANSI_CLASS);
    } catch (final NoSuchMethodException nsme) {
        LOGGER.warn(""{} is missing the proper constructor"", JANSI_CLASS);
    } catch (final Exception ex) {
        LOGGER.warn(""Unable to instantiate {}"", JANSI_CLASS);
    }
    return printStream;
}",,"private static OutputStream getOutputStream(final boolean follow, final Target target) {
    final String enc = Charset.defaultCharset().name();
    PrintStream printStream = null;
    try {
        printStream = target == Target.SYSTEM_OUT ? follow ? new PrintStream(new CloseShieldOutputStream(System.out), true, enc) : System.out : follow ? new PrintStream(new CloseShieldOutputStream(System.err), true, enc) : System.err;
    } catch (final UnsupportedEncodingException ex) {
                throw new IllegalStateException(""Unsupported default encoding "" + enc, ex);
    }
    final PropertiesUtil propsUtil = PropertiesUtil.getProperties();
    if (!propsUtil.getStringProperty(""os.name"").startsWith(""Windows"") || propsUtil.getBooleanProperty(""log4j.skipJansi"")) {
        return printStream;
    }
    try {
                final Class<?> clazz = Loader.loadClass(JANSI_CLASS);
        final Constructor<?> constructor = clazz.getConstructor(OutputStream.class);
                return new CloseShieldOutputStream((OutputStream) constructor.newInstance(printStream));
    } catch (final ClassNotFoundException cnfe) {
        LOGGER.debug(""Jansi is not installed, cannot find {}"", JANSI_CLASS);
    } catch (final NoSuchMethodException nsme) {
        LOGGER.warn(""{} is missing the proper constructor"", JANSI_CLASS);
    } catch (final Exception ex) {
        LOGGER.warn(""Unable to instantiate {}"", JANSI_CLASS);
    }
    return printStream;
}",0.5,-0.2775119617224881,1.2,-0.5,0.3333333333333333,0.30158730158730157,-0.48978153629316407,0.5,-0.02631578947368421,0.7351717063444038
camel,remotes/origin/bugs-dot-jar_CAMEL-4482_e38494f1,1,"protected Iterable<ProcessorExchangePair> createProcessorExchangePairs(Exchange exchange) throws Exception {
    List<ProcessorExchangePair> result = new ArrayList<ProcessorExchangePair>(processors.size());
    int index = 0;
    for (Processor processor : processors) {
        // copy exchange, and do not share the unit of work
        Exchange copy = ExchangeHelper.createCorrelatedCopy(exchange, false);
        // if we share unit of work, we need to prepare the child exchange
        if (isShareUnitOfWork()) {
            prepareSharedUnitOfWork(copy, exchange);
        }
        // and add the pair
        RouteContext routeContext = exchange.getUnitOfWork() != null ? exchange.getUnitOfWork().getRouteContext() : null;
        result.add(createProcessorExchangePair(index++, processor, copy, routeContext));
    }
    return result;
}",,"protected Iterable<ProcessorExchangePair> createProcessorExchangePairs(Exchange exchange) throws Exception {
    List<ProcessorExchangePair> result = new ArrayList<ProcessorExchangePair>(processors.size());
    int index = 0;
    for (Processor processor : processors) {
                Exchange copy = ExchangeHelper.createCorrelatedCopy(exchange, false);
                if (isShareUnitOfWork()) {
            prepareSharedUnitOfWork(copy, exchange);
        }
                RouteContext routeContext = exchange.getUnitOfWork() != null ? exchange.getUnitOfWork().getRouteContext() : null;
        result.add(createProcessorExchangePair(index++, processor, copy, routeContext));
    }
    return result;
}",-0.045454545454545456,0.16746411483253573,0.0,0.0,-0.08333333333333333,-0.0496031746031746,-0.034813248766737116,0.25,-0.02631578947368421,0.027341620419195148
camel,remotes/origin/bugs-dot-jar_CAMEL-9124_9da2c05a,3,"public RedeliveryPolicy createRedeliveryPolicy(CamelContext context, RedeliveryPolicy parentPolicy) {
    RedeliveryPolicy answer;
    if (parentPolicy != null) {
        answer = parentPolicy.copy();
    } else {
        answer = new RedeliveryPolicy();
    }
    try {
        // copy across the properties - if they are set
        if (maximumRedeliveries != null) {
            answer.setMaximumRedeliveries(CamelContextHelper.parseInteger(context, maximumRedeliveries));
        }
        if (redeliveryDelay != null) {
            answer.setRedeliveryDelay(CamelContextHelper.parseLong(context, redeliveryDelay));
        }
        if (asyncDelayedRedelivery != null) {
            if (CamelContextHelper.parseBoolean(context, asyncDelayedRedelivery)) {
                answer.asyncDelayedRedelivery();
            }
        }
        if (retriesExhaustedLogLevel != null) {
            answer.setRetriesExhaustedLogLevel(retriesExhaustedLogLevel);
        }
        if (retryAttemptedLogLevel != null) {
            answer.setRetryAttemptedLogLevel(retryAttemptedLogLevel);
        }
        if (backOffMultiplier != null) {
            answer.setBackOffMultiplier(CamelContextHelper.parseDouble(context, backOffMultiplier));
        }
        if (useExponentialBackOff != null) {
            answer.setUseExponentialBackOff(CamelContextHelper.parseBoolean(context, useExponentialBackOff));
        }
        if (collisionAvoidanceFactor != null) {
            answer.setCollisionAvoidanceFactor(CamelContextHelper.parseDouble(context, collisionAvoidanceFactor));
        }
        if (useCollisionAvoidance != null) {
            answer.setUseCollisionAvoidance(CamelContextHelper.parseBoolean(context, useCollisionAvoidance));
        }
        if (maximumRedeliveryDelay != null) {
            answer.setMaximumRedeliveryDelay(CamelContextHelper.parseLong(context, maximumRedeliveryDelay));
        }
        if (logStackTrace != null) {
            answer.setLogStackTrace(CamelContextHelper.parseBoolean(context, logStackTrace));
        }
        if (logRetryStackTrace != null) {
            answer.setLogRetryStackTrace(CamelContextHelper.parseBoolean(context, logRetryStackTrace));
        }
        if (logHandled != null) {
            answer.setLogHandled(CamelContextHelper.parseBoolean(context, logHandled));
        }
        if (logNewException != null) {
            answer.setLogNewException(CamelContextHelper.parseBoolean(context, logNewException));
        }
        if (logContinued != null) {
            answer.setLogContinued(CamelContextHelper.parseBoolean(context, logContinued));
        }
        if (logRetryAttempted != null) {
            answer.setLogRetryAttempted(CamelContextHelper.parseBoolean(context, logRetryAttempted));
        }
        if (logExhausted != null) {
            answer.setLogExhausted(CamelContextHelper.parseBoolean(context, logExhausted));
        }
        if (logExhaustedMessageHistory != null) {
            answer.setLogExhaustedMessageHistory(CamelContextHelper.parseBoolean(context, logExhaustedMessageHistory));
        }
        if (disableRedelivery != null) {
            if (CamelContextHelper.parseBoolean(context, disableRedelivery)) {
                answer.setMaximumRedeliveries(0);
            }
        }
        if (delayPattern != null) {
            answer.setDelayPattern(delayPattern);
        }
        if (allowRedeliveryWhileStopping != null) {
            answer.setAllowRedeliveryWhileStopping(CamelContextHelper.parseBoolean(context, allowRedeliveryWhileStopping));
        }
        if (exchangeFormatterRef != null) {
            answer.setExchangeFormatterRef(exchangeFormatterRef);
        }
    } catch (Exception e) {
        throw ObjectHelper.wrapRuntimeCamelException(e);
    }
    return answer;
}",,"public RedeliveryPolicy createRedeliveryPolicy(CamelContext context, RedeliveryPolicy parentPolicy) {
    RedeliveryPolicy answer;
    if (parentPolicy != null) {
        answer = parentPolicy.copy();
    } else {
        answer = new RedeliveryPolicy();
    }
    try {
                if (maximumRedeliveries != null) {
            answer.setMaximumRedeliveries(CamelContextHelper.parseInteger(context, maximumRedeliveries));
        }
        if (redeliveryDelay != null) {
            answer.setRedeliveryDelay(CamelContextHelper.parseLong(context, redeliveryDelay));
        }
        if (asyncDelayedRedelivery != null) {
            if (CamelContextHelper.parseBoolean(context, asyncDelayedRedelivery)) {
                answer.asyncDelayedRedelivery();
            }
        }
        if (retriesExhaustedLogLevel != null) {
            answer.setRetriesExhaustedLogLevel(retriesExhaustedLogLevel);
        }
        if (retryAttemptedLogLevel != null) {
            answer.setRetryAttemptedLogLevel(retryAttemptedLogLevel);
        }
        if (backOffMultiplier != null) {
            answer.setBackOffMultiplier(CamelContextHelper.parseDouble(context, backOffMultiplier));
        }
        if (useExponentialBackOff != null) {
            answer.setUseExponentialBackOff(CamelContextHelper.parseBoolean(context, useExponentialBackOff));
        }
        if (collisionAvoidanceFactor != null) {
            answer.setCollisionAvoidanceFactor(CamelContextHelper.parseDouble(context, collisionAvoidanceFactor));
        }
        if (useCollisionAvoidance != null) {
            answer.setUseCollisionAvoidance(CamelContextHelper.parseBoolean(context, useCollisionAvoidance));
        }
        if (maximumRedeliveryDelay != null) {
            answer.setMaximumRedeliveryDelay(CamelContextHelper.parseLong(context, maximumRedeliveryDelay));
        }
        if (logStackTrace != null) {
            answer.setLogStackTrace(CamelContextHelper.parseBoolean(context, logStackTrace));
        }
        if (logRetryStackTrace != null) {
            answer.setLogRetryStackTrace(CamelContextHelper.parseBoolean(context, logRetryStackTrace));
        }
        if (logHandled != null) {
            answer.setLogHandled(CamelContextHelper.parseBoolean(context, logHandled));
        }
        if (logNewException != null) {
            answer.setLogNewException(CamelContextHelper.parseBoolean(context, logNewException));
        }
        if (logContinued != null) {
            answer.setLogContinued(CamelContextHelper.parseBoolean(context, logContinued));
        }
        if (logRetryAttempted != null) {
            answer.setLogRetryAttempted(CamelContextHelper.parseBoolean(context, logRetryAttempted));
        }
        if (logExhausted != null) {
            answer.setLogExhausted(CamelContextHelper.parseBoolean(context, logExhausted));
        }
        if (logExhaustedMessageHistory != null) {
            answer.setLogExhaustedMessageHistory(CamelContextHelper.parseBoolean(context, logExhaustedMessageHistory));
        }
        if (disableRedelivery != null) {
            if (CamelContextHelper.parseBoolean(context, disableRedelivery)) {
                answer.setMaximumRedeliveries(0);
            }
        }
        if (delayPattern != null) {
            answer.setDelayPattern(delayPattern);
        }
        if (allowRedeliveryWhileStopping != null) {
            answer.setAllowRedeliveryWhileStopping(CamelContextHelper.parseBoolean(context, allowRedeliveryWhileStopping));
        }
        if (exchangeFormatterRef != null) {
            answer.setExchangeFormatterRef(exchangeFormatterRef);
        }
    } catch (Exception e) {
        throw ObjectHelper.wrapRuntimeCamelException(e);
    }
    return answer;
}",3.1363636363636362,-0.023923444976076683,4.8,0.5,3.8333333333333335,0.24404761904761899,-1.2692036645525013,3.0,-0.02631578947368421,1.6281576505708173
Math,31,1,"/**
 * <p>
 * Evaluates the continued fraction at the value x.
 * </p>
 *
 * <p>
 * The implementation of this method is based on the modified Lentz algorithm as described
 * on page 18 ff. in:
 * <ul>
 * <li>
 *   I. J. Thompson,  A. R. Barnett. ""Coulomb and Bessel Functions of Complex Arguments and Order.""
 *   <a target=""_blank"" href=""http://www.fresco.org.uk/papers/Thompson-JCP64p490.pdf"">
 *   http://www.fresco.org.uk/papers/Thompson-JCP64p490.pdf</a>
 * </li>
 * </ul>
 * Note: the implementation uses the terms a<sub>i</sub> and b<sub>i</sub> as defined in
 * <a href=""http://mathworld.wolfram.com/ContinuedFraction.html"">Continued Fraction / MathWorld</a>.
 * </p>
 *
 * @param x the evaluation point.
 * @param epsilon maximum error allowed.
 * @param maxIterations maximum number of convergents
 * @return the value of the continued fraction evaluated at x.
 * @throws ConvergenceException if the algorithm fails to converge.
 */
public double evaluate(double x, double epsilon, int maxIterations) {
    final double small = 1e-50;
    double hPrev = getA(0, x);
    // use the value of small as epsilon criteria for zero checks
    if (Precision.equals(hPrev, 0.0, small)) {
        hPrev = small;
    }
    int n = 1;
    double dPrev = 0.0;
    double p0 = 1.0;
    double q1 = 1.0;
    double cPrev = hPrev;
    double hN = hPrev;
    while (n < maxIterations) {
        final double a = getA(n, x);
        final double b = getB(n, x);
        double cN = a * hPrev + b * p0;
        double q2 = a * q1 + b * dPrev;
        if (Double.isInfinite(cN) || Double.isInfinite(q2)) {
            double scaleFactor = 1d;
            double lastScaleFactor = 1d;
            final int maxPower = 5;
            final double scale = FastMath.max(a, b);
            if (scale <= 0) {
                // Can't scale
                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);
            }
            for (int i = 0; i < maxPower; i++) {
                lastScaleFactor = scaleFactor;
                scaleFactor *= scale;
                if (a != 0.0 && a > b) {
                    cN = hPrev / lastScaleFactor + (b / scaleFactor * p0);
                    q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev);
                } else if (b != 0) {
                    cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor;
                    q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor;
                }
                if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) {
                    break;
                }
            }
        }
        final double deltaN = cN / q2 / cPrev;
        hN = cPrev * deltaN;
        if (Double.isInfinite(hN)) {
            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);
        }
        if (Double.isNaN(hN)) {
            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, x);
        }
        if (FastMath.abs(deltaN - 1.0) < epsilon) {
            break;
        }
        dPrev = q1;
        cPrev = cN / q2;
        p0 = hPrev;
        hPrev = cN;
        q1 = q2;
        n++;
    }
    if (n >= maxIterations) {
        throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION, maxIterations, x);
    }
    return hN;
}","/**
 * <p>
 * Evaluates the continued fraction at the value x.
 * </p>
 *
 * <p>
 * The implementation of this method is based on the modified Lentz algorithm as described
 * on page 18 ff. in:
 * <ul>
 * <li>
 *   I. J. Thompson,  A. R. Barnett. ""Coulomb and Bessel Functions of Complex Arguments and Order.""
 *   <a target=""_blank"" href=""http://www.fresco.org.uk/papers/Thompson-JCP64p490.pdf"">
 *   http://www.fresco.org.uk/papers/Thompson-JCP64p490.pdf</a>
 * </li>
 * </ul>
 * Note: the implementation uses the terms a<sub>i</sub> and b<sub>i</sub> as defined in
 * <a href=""http://mathworld.wolfram.com/ContinuedFraction.html"">Continued Fraction / MathWorld</a>.
 * </p>
 *
 * @param x the evaluation point.
 * @param epsilon maximum error allowed.
 * @param maxIterations maximum number of convergents
 * @return the value of the continued fraction evaluated at x.
 * @throws ConvergenceException if the algorithm fails to converge.
 */
","public double evaluate(double x, double epsilon, int maxIterations) {
    final double small = 1e-50;
    double hPrev = getA(0, x);
        if (Precision.equals(hPrev, 0.0, small)) {
        hPrev = small;
    }
    int n = 1;
    double dPrev = 0.0;
    double p0 = 1.0;
    double q1 = 1.0;
    double cPrev = hPrev;
    double hN = hPrev;
    while (n < maxIterations) {
        final double a = getA(n, x);
        final double b = getB(n, x);
        double cN = a * hPrev + b * p0;
        double q2 = a * q1 + b * dPrev;
        if (Double.isInfinite(cN) || Double.isInfinite(q2)) {
            double scaleFactor = 1d;
            double lastScaleFactor = 1d;
            final int maxPower = 5;
            final double scale = FastMath.max(a, b);
            if (scale <= 0) {
                                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);
            }
            for (int i = 0; i < maxPower; i++) {
                lastScaleFactor = scaleFactor;
                scaleFactor *= scale;
                if (a != 0.0 && a > b) {
                    cN = hPrev / lastScaleFactor + (b / scaleFactor * p0);
                    q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev);
                } else if (b != 0) {
                    cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor;
                    q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor;
                }
                if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) {
                    break;
                }
            }
        }
        final double deltaN = cN / q2 / cPrev;
        hN = cPrev * deltaN;
        if (Double.isInfinite(hN)) {
            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);
        }
        if (Double.isNaN(hN)) {
            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, x);
        }
        if (FastMath.abs(deltaN - 1.0) < epsilon) {
            break;
        }
        dPrev = q1;
        cPrev = cN / q2;
        p0 = hPrev;
        hPrev = cN;
        q1 = q2;
        n++;
    }
    if (n >= maxIterations) {
        throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION, maxIterations, x);
    }
    return hN;
}",2.227272727272727,1.0095693779904304,3.0,1.5,2.5,4.587301587301588,-1.0989429175475685,0.5,-0.02631578947368421,15.873116532102367
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-395_e6c31270,1,"@Override
public Property perform() throws RepositoryException {
    if (values == null) {
        Property p = getProperty(jcrName);
        p.remove();
        return p;
    } else {
        String oakName = sessionDelegate.getOakPathOrThrow(jcrName);
        PropertyDefinition definition;
        if (hasProperty(jcrName)) {
            definition = getProperty(jcrName).getDefinition();
        } else {
            definition = dlg.sessionDelegate.getDefinitionProvider().getDefinition(NodeImpl.this, oakName, true, type, exactTypeMatch);
        }
        checkProtected(definition);
        if (!definition.isMultiple()) {
            throw new ValueFormatException(""Cannot set value array to single value property"");
        }
        int targetType = getTargetType(values, definition);
        Value[] targetValues = ValueHelper.convert(values, targetType, getValueFactory());
        Iterable<Value> nonNullValues = Iterables.filter(Arrays.asList(targetValues), Predicates.notNull());
        return new PropertyImpl(dlg.setProperty(oakName, nonNullValues));
    }
}",,"@Override
public Property perform() throws RepositoryException {
    if (values == null) {
        Property p = getProperty(jcrName);
        p.remove();
        return p;
    } else {
        String oakName = sessionDelegate.getOakPathOrThrow(jcrName);
        PropertyDefinition definition;
        if (hasProperty(jcrName)) {
            definition = getProperty(jcrName).getDefinition();
        } else {
            definition = dlg.sessionDelegate.getDefinitionProvider().getDefinition(NodeImpl.this, oakName, true, type, exactTypeMatch);
        }
        checkProtected(definition);
        if (!definition.isMultiple()) {
            throw new ValueFormatException(""Cannot set value array to single value property"");
        }
        int targetType = getTargetType(values, definition);
        Value[] targetValues = ValueHelper.convert(values, targetType, getValueFactory());
        Iterable<Value> nonNullValues = Iterables.filter(Arrays.asList(targetValues), Predicates.notNull());
        return new PropertyImpl(dlg.setProperty(oakName, nonNullValues));
    }
}",0.45454545454545453,0.1578947368421051,0.2,0.0,0.16666666666666666,-0.06746031746031747,-0.39760394644115576,0.9166666666666666,-0.02631578947368421,0.1400690398390991
wicket,remotes/origin/bugs-dot-jar_WICKET-5689_2ac29d30,3,"protected BufferedWebResponse getAndRemoveBufferedResponse(Url url) {
    return WebApplication.get().getAndRemoveBufferedResponse(getSessionId(), url);
}",,"protected BufferedWebResponse getAndRemoveBufferedResponse(Url url) {
    return WebApplication.get().getAndRemoveBufferedResponse(getSessionId(), url);
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.9709654686398869,-0.25,0.39473684210526316,-0.16279340490885932
Math,81,1,"/**
 * Compute the shift increment as an estimate of the smallest eigenvalue.
 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
 * @param start start index
 * @param end end index
 * @param deflated number of realEigenvalues just deflated
 */
private void computeShiftIncrement(final int start, final int end, final int deflated) {
    final double cnst1 = 0.563;
    final double cnst2 = 1.010;
    final double cnst3 = 1.05;
    // tType records the type of shift.
    if (dMin <= 0.0) {
        tau = -dMin;
        tType = -1;
        return;
    }
    int nn = 4 * end + pingPong - 1;
    switch(deflated) {
        case // no realEigenvalues deflated.
        0:
            if (dMin == dN || dMin == dN1) {
                double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]);
                double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]);
                double a2 = work[nn - 7] + work[nn - 5];
                if (dMin == dN && dMin1 == dN1) {
                    // cases 2 and 3.
                    final double gap2 = dMin2 - a2 - dMin2 * 0.25;
                    final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2));
                    if (gap1 > 0.0 && gap1 > b1) {
                        tau = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin);
                        tType = -2;
                    } else {
                        double s = 0.0;
                        if (dN > b1) {
                            s = dN - b1;
                        }
                        if (a2 > (b1 + b2)) {
                            s = Math.min(s, a2 - (b1 + b2));
                        }
                        tau = Math.max(s, 0.333 * dMin);
                        tType = -3;
                    }
                } else {
                    // case 4.
                    tType = -4;
                    double s = 0.25 * dMin;
                    double gam;
                    int np;
                    if (dMin == dN) {
                        gam = dN;
                        a2 = 0.0;
                        if (work[nn - 5] > work[nn - 7]) {
                            return;
                        }
                        b2 = work[nn - 5] / work[nn - 7];
                        np = nn - 9;
                    } else {
                        np = nn - 2 * pingPong;
                        b2 = work[np - 2];
                        gam = dN1;
                        if (work[np - 4] > work[np - 2]) {
                            return;
                        }
                        a2 = work[np - 4] / work[np - 2];
                        if (work[nn - 9] > work[nn - 11]) {
                            return;
                        }
                        b2 = work[nn - 9] / work[nn - 11];
                        np = nn - 13;
                    }
                    // approximate contribution to norm squared from i < nn-1.
                    a2 = a2 + b2;
                    for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
                        if (b2 == 0.0) {
                            break;
                        }
                        b1 = b2;
                        if (work[i4] > work[i4 - 2]) {
                            return;
                        }
                        b2 = b2 * (work[i4] / work[i4 - 2]);
                        a2 = a2 + b2;
                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {
                            break;
                        }
                    }
                    a2 = cnst3 * a2;
                    // rayleigh quotient residual bound.
                    if (a2 < cnst1) {
                        s = gam * (1 - Math.sqrt(a2)) / (1 + a2);
                    }
                    tau = s;
                }
            } else if (dMin == dN2) {
                // case 5.
                tType = -5;
                double s = 0.25 * dMin;
                // compute contribution to norm squared from i > nn-2.
                final int np = nn - 2 * pingPong;
                double b1 = work[np - 2];
                double b2 = work[np - 6];
                final double gam = dN2;
                if (work[np - 8] > b2 || work[np - 4] > b1) {
                    return;
                }
                double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);
                // approximate contribution to norm squared from i < nn-2.
                if (end - start > 2) {
                    b2 = work[nn - 13] / work[nn - 15];
                    a2 = a2 + b2;
                    for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
                        if (b2 == 0.0) {
                            break;
                        }
                        b1 = b2;
                        if (work[i4] > work[i4 - 2]) {
                            return;
                        }
                        b2 = b2 * (work[i4] / work[i4 - 2]);
                        a2 = a2 + b2;
                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {
                            break;
                        }
                    }
                    a2 = cnst3 * a2;
                }
                if (a2 < cnst1) {
                    tau = gam * (1 - Math.sqrt(a2)) / (1 + a2);
                } else {
                    tau = s;
                }
            } else {
                // case 6, no information to guide us.
                if (tType == -6) {
                    g += 0.333 * (1 - g);
                } else if (tType == -18) {
                    g = 0.25 * 0.333;
                } else {
                    g = 0.25;
                }
                tau = g * dMin;
                tType = -6;
            }
            break;
        case // one eigenvalue just deflated. use dMin1, dN1 for dMin and dN.
        1:
            if (dMin1 == dN1 && dMin2 == dN2) {
                // cases 7 and 8.
                tType = -7;
                double s = 0.333 * dMin1;
                if (work[nn - 5] > work[nn - 7]) {
                    return;
                }
                double b1 = work[nn - 5] / work[nn - 7];
                double b2 = b1;
                if (b2 != 0.0) {
                    for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
                        final double oldB1 = b1;
                        if (work[i4] > work[i4 - 2]) {
                            return;
                        }
                        b1 = b1 * (work[i4] / work[i4 - 2]);
                        b2 = b2 + b1;
                        if (100 * Math.max(b1, oldB1) < b2) {
                            break;
                        }
                    }
                }
                b2 = Math.sqrt(cnst3 * b2);
                final double a2 = dMin1 / (1 + b2 * b2);
                final double gap2 = 0.5 * dMin2 - a2;
                if (gap2 > 0.0 && gap2 > b2 * a2) {
                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));
                } else {
                    tau = Math.max(s, a2 * (1 - cnst2 * b2));
                    tType = -8;
                }
            } else {
                // case 9.
                tau = 0.25 * dMin1;
                if (dMin1 == dN1) {
                    tau = 0.5 * dMin1;
                }
                tType = -9;
            }
            break;
        case // two realEigenvalues deflated. use dMin2, dN2 for dMin and dN.
        2:
            // cases 10 and 11.
            if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) {
                tType = -10;
                final double s = 0.333 * dMin2;
                if (work[nn - 5] > work[nn - 7]) {
                    return;
                }
                double b1 = work[nn - 5] / work[nn - 7];
                double b2 = b1;
                if (b2 != 0.0) {
                    for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
                        if (work[i4] > work[i4 - 2]) {
                            return;
                        }
                        b1 *= work[i4] / work[i4 - 2];
                        b2 += b1;
                        if (100 * b1 < b2) {
                            break;
                        }
                    }
                }
                b2 = Math.sqrt(cnst3 * b2);
                final double a2 = dMin2 / (1 + b2 * b2);
                final double gap2 = work[nn - 7] + work[nn - 9] - Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2;
                if (gap2 > 0.0 && gap2 > b2 * a2) {
                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));
                } else {
                    tau = Math.max(s, a2 * (1 - cnst2 * b2));
                }
            } else {
                tau = 0.25 * dMin2;
                tType = -11;
            }
            break;
        default:
            // case 12, more than two realEigenvalues deflated. no information.
            tau = 0.0;
            tType = -12;
    }
}","/**
 * Compute the shift increment as an estimate of the smallest eigenvalue.
 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
 * @param start start index
 * @param end end index
 * @param deflated number of realEigenvalues just deflated
 */
","private void computeShiftIncrement(final int start, final int end, final int deflated) {
    final double cnst1 = 0.563;
    final double cnst2 = 1.010;
    final double cnst3 = 1.05;
        if (dMin <= 0.0) {
        tau = -dMin;
        tType = -1;
        return;
    }
    int nn = 4 * end + pingPong - 1;
    switch(deflated) {
        case         0:
            if (dMin == dN || dMin == dN1) {
                double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]);
                double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]);
                double a2 = work[nn - 7] + work[nn - 5];
                if (dMin == dN && dMin1 == dN1) {
                                        final double gap2 = dMin2 - a2 - dMin2 * 0.25;
                    final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2));
                    if (gap1 > 0.0 && gap1 > b1) {
                        tau = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin);
                        tType = -2;
                    } else {
                        double s = 0.0;
                        if (dN > b1) {
                            s = dN - b1;
                        }
                        if (a2 > (b1 + b2)) {
                            s = Math.min(s, a2 - (b1 + b2));
                        }
                        tau = Math.max(s, 0.333 * dMin);
                        tType = -3;
                    }
                } else {
                                        tType = -4;
                    double s = 0.25 * dMin;
                    double gam;
                    int np;
                    if (dMin == dN) {
                        gam = dN;
                        a2 = 0.0;
                        if (work[nn - 5] > work[nn - 7]) {
                            return;
                        }
                        b2 = work[nn - 5] / work[nn - 7];
                        np = nn - 9;
                    } else {
                        np = nn - 2 * pingPong;
                        b2 = work[np - 2];
                        gam = dN1;
                        if (work[np - 4] > work[np - 2]) {
                            return;
                        }
                        a2 = work[np - 4] / work[np - 2];
                        if (work[nn - 9] > work[nn - 11]) {
                            return;
                        }
                        b2 = work[nn - 9] / work[nn - 11];
                        np = nn - 13;
                    }
                                        a2 = a2 + b2;
                    for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
                        if (b2 == 0.0) {
                            break;
                        }
                        b1 = b2;
                        if (work[i4] > work[i4 - 2]) {
                            return;
                        }
                        b2 = b2 * (work[i4] / work[i4 - 2]);
                        a2 = a2 + b2;
                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {
                            break;
                        }
                    }
                    a2 = cnst3 * a2;
                                        if (a2 < cnst1) {
                        s = gam * (1 - Math.sqrt(a2)) / (1 + a2);
                    }
                    tau = s;
                }
            } else if (dMin == dN2) {
                                tType = -5;
                double s = 0.25 * dMin;
                                final int np = nn - 2 * pingPong;
                double b1 = work[np - 2];
                double b2 = work[np - 6];
                final double gam = dN2;
                if (work[np - 8] > b2 || work[np - 4] > b1) {
                    return;
                }
                double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);
                                if (end - start > 2) {
                    b2 = work[nn - 13] / work[nn - 15];
                    a2 = a2 + b2;
                    for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
                        if (b2 == 0.0) {
                            break;
                        }
                        b1 = b2;
                        if (work[i4] > work[i4 - 2]) {
                            return;
                        }
                        b2 = b2 * (work[i4] / work[i4 - 2]);
                        a2 = a2 + b2;
                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {
                            break;
                        }
                    }
                    a2 = cnst3 * a2;
                }
                if (a2 < cnst1) {
                    tau = gam * (1 - Math.sqrt(a2)) / (1 + a2);
                } else {
                    tau = s;
                }
            } else {
                                if (tType == -6) {
                    g += 0.333 * (1 - g);
                } else if (tType == -18) {
                    g = 0.25 * 0.333;
                } else {
                    g = 0.25;
                }
                tau = g * dMin;
                tType = -6;
            }
            break;
        case         1:
            if (dMin1 == dN1 && dMin2 == dN2) {
                                tType = -7;
                double s = 0.333 * dMin1;
                if (work[nn - 5] > work[nn - 7]) {
                    return;
                }
                double b1 = work[nn - 5] / work[nn - 7];
                double b2 = b1;
                if (b2 != 0.0) {
                    for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
                        final double oldB1 = b1;
                        if (work[i4] > work[i4 - 2]) {
                            return;
                        }
                        b1 = b1 * (work[i4] / work[i4 - 2]);
                        b2 = b2 + b1;
                        if (100 * Math.max(b1, oldB1) < b2) {
                            break;
                        }
                    }
                }
                b2 = Math.sqrt(cnst3 * b2);
                final double a2 = dMin1 / (1 + b2 * b2);
                final double gap2 = 0.5 * dMin2 - a2;
                if (gap2 > 0.0 && gap2 > b2 * a2) {
                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));
                } else {
                    tau = Math.max(s, a2 * (1 - cnst2 * b2));
                    tType = -8;
                }
            } else {
                                tau = 0.25 * dMin1;
                if (dMin1 == dN1) {
                    tau = 0.5 * dMin1;
                }
                tType = -9;
            }
            break;
        case         2:
                        if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) {
                tType = -10;
                final double s = 0.333 * dMin2;
                if (work[nn - 5] > work[nn - 7]) {
                    return;
                }
                double b1 = work[nn - 5] / work[nn - 7];
                double b2 = b1;
                if (b2 != 0.0) {
                    for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
                        if (work[i4] > work[i4 - 2]) {
                            return;
                        }
                        b1 *= work[i4] / work[i4 - 2];
                        b2 += b1;
                        if (100 * b1 < b2) {
                            break;
                        }
                    }
                }
                b2 = Math.sqrt(cnst3 * b2);
                final double a2 = dMin2 / (1 + b2 * b2);
                final double gap2 = work[nn - 7] + work[nn - 9] - Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2;
                if (gap2 > 0.0 && gap2 > b2 * a2) {
                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));
                } else {
                    tau = Math.max(s, a2 * (1 - cnst2 * b2));
                }
            } else {
                tau = 0.25 * dMin2;
                tType = -11;
            }
            break;
        default:
                        tau = 0.0;
            tType = -12;
    }
}",8.863636363636363,1.464114832535885,10.2,2.5,5.916666666666667,15.642857142857144,-2.0906272022551087,1.1666666666666667,-0.02631578947368421,218.31397336376153
camel,remotes/origin/bugs-dot-jar_CAMEL-3448_b345dd82,0,"@Override
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    if (o == null || getClass() != o.getClass()) {
        return false;
    }
    ExceptionPolicyKey that = (ExceptionPolicyKey) o;
    if (!exceptionClass.equals(that.exceptionClass)) {
        return false;
    }
    if (when != null ? !when.equals(that.when) : that.when != null) {
        return false;
    }
    return true;
}",,"@Override
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    if (o == null || getClass() != o.getClass()) {
        return false;
    }
    ExceptionPolicyKey that = (ExceptionPolicyKey) o;
    if (!exceptionClass.equals(that.exceptionClass)) {
        return false;
    }
    if (when != null ? !when.equals(that.when) : that.when != null) {
        return false;
    }
    return true;
}",0.13636363636363635,-0.20574162679425848,0.4,-0.5,0.5833333333333334,0.6428571428571429,-0.11233262861169833,-0.16666666666666666,0.5526315789473684,0.2471395722757213
wicket,remotes/origin/bugs-dot-jar_WICKET-2882_ebe56869,1,"/**
 *  @see org.apache.wicket.application.IComponentOnBeforeRenderListener#onBeforeRender(org.apache.wicket.Component)
 */
public void onAfterRender(final Component component) {
    if (log.isWarnEnabled()) {
        if ((component instanceof FormComponent) || (component instanceof IFormSubmittingComponent) || (component instanceof Form)) {
            log.warn(""Please note that onBeforeRender() and validate() might be called on invisible components inside an Enclosure. "" + ""Please see EnclosureContainer for an alternative. Enclosure: "" + enclosure.toString());
        }
    }
}","/**
 *  @see org.apache.wicket.application.IComponentOnBeforeRenderListener#onBeforeRender(org.apache.wicket.Component)
 */
","public void onAfterRender(final Component component) {
    if (log.isWarnEnabled()) {
        if ((component instanceof FormComponent) || (component instanceof IFormSubmittingComponent) || (component instanceof Form)) {
            log.warn(""Please note that onBeforeRender() and validate() might be called on invisible components inside an Enclosure. "" + ""Please see EnclosureContainer for an alternative. Enclosure: "" + enclosure.toString());
        }
    }
}",-0.3181818181818182,0.5406698564593301,-0.2,0.0,0.08333333333333333,-0.10912698412698414,0.42720225510923177,-0.25,0.05263157894736841,-0.11537144931795783
Time,26,2,"public long addWrapField(long instant, int value) {
    if (iTimeField) {
        int offset = getOffsetToAdd(instant);
        long localInstant = iField.addWrapField(instant + offset, value);
        return localInstant - offset;
    } else {
        long localInstant = iZone.convertUTCToLocal(instant);
        localInstant = iField.addWrapField(localInstant, value);
        return iZone.convertLocalToUTC(localInstant, false);
    }
}",,"public long addWrapField(long instant, int value) {
    if (iTimeField) {
        int offset = getOffsetToAdd(instant);
        long localInstant = iField.addWrapField(instant + offset, value);
        return localInstant - offset;
    } else {
        long localInstant = iZone.convertUTCToLocal(instant);
        localInstant = iField.addWrapField(localInstant, value);
        return iZone.convertLocalToUTC(localInstant, false);
    }
}",-0.13636363636363635,0.04784688995215294,-0.4,-0.5,-0.25,0.07738095238095236,0.14531360112755462,-0.08333333333333333,0.02631578947368421,-0.018807881375955928
maven,remotes/origin/bugs-dot-jar_MNG-1999_ad38e46b,1,"private void assembleReportingInheritance(Model child, Model parent) {
    // Reports :: aggregate
    Reporting childReporting = child.getReporting();
    Reporting parentReporting = parent.getReporting();
    if (parentReporting != null) {
        if (childReporting == null) {
            childReporting = new Reporting();
            child.setReporting(childReporting);
        }
        if (StringUtils.isEmpty(childReporting.getOutputDirectory())) {
            childReporting.setOutputDirectory(parentReporting.getOutputDirectory());
        }
        ModelUtils.mergeReportPluginLists(childReporting, parentReporting, true);
    }
}",,"private void assembleReportingInheritance(Model child, Model parent) {
        Reporting childReporting = child.getReporting();
    Reporting parentReporting = parent.getReporting();
    if (parentReporting != null) {
        if (childReporting == null) {
            childReporting = new Reporting();
            child.setReporting(childReporting);
        }
        if (StringUtils.isEmpty(childReporting.getOutputDirectory())) {
            childReporting.setOutputDirectory(parentReporting.getOutputDirectory());
        }
        ModelUtils.mergeReportPluginLists(childReporting, parentReporting, true);
    }
}",0.0,0.43062200956937796,0.0,0.0,0.16666666666666666,0.03174603174603173,-0.014799154334038212,0.16666666666666666,0.0,0.003257205096730691
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-531_90c45a02,1,"@Nonnull
private NodeState read() {
    if (revision != root.revision) {
        // root never gets here since revision == root.revision
        assert (!isRoot());
        checkState(!parent.removed(name), ""This node has already been removed"");
        parent.read();
        // The builder could have been reset, need to re-get base state
        baseState = parent.getBaseState(name);
        // ... same for the write state
        writeState = parent.getWriteState(name);
        revision = root.revision;
    }
    assert classInvariants();
    if (writeState != null) {
        return writeState;
    } else {
        return baseState;
    }
}",,"@Nonnull
private NodeState read() {
    if (revision != root.revision) {
                assert (!isRoot());
        checkState(!parent.removed(name), ""This node has already been removed"");
        parent.read();
                baseState = parent.getBaseState(name);
                writeState = parent.getWriteState(name);
        revision = root.revision;
    }
    assert classInvariants();
    if (writeState != null) {
        return writeState;
    } else {
        return baseState;
    }
}",0.13636363636363635,0.0,-0.2,-0.5,0.0,-0.3650793650793651,0.35954897815362913,0.08333333333333333,0.02631578947368421,-0.16279340490885932
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-1008_0c20bfd8,1,"/**
 * Will be called repeatedly with candidate classes. Must return True if a class
 * is to be included in the results, false otherwise.
 * @param type The Class to match against.
 * @return true if the Class matches.
 */
boolean matches(Class<?> type);","/**
 * Will be called repeatedly with candidate classes. Must return True if a class
 * is to be included in the results, false otherwise.
 * @param type The Class to match against.
 * @return true if the Class matches.
 */
",boolean matches(Class<?> type);,-0.5909090909090909,-1.4306220095693782,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,1.6663847780126848,-0.5,2.5789473684210527,-0.16279340490885932
commons-math,remotes/origin/bugs-dot-jar_MATH-373_bfe4623c,1,"/**
 * The sum of the entries in the specified portion of
 * the input array, or <code>Double.NaN</code> if the designated subarray
 * is empty.
 * <p>
 * Throws <code>IllegalArgumentException</code> if the array is null.</p>
 *
 * @param values the input array
 * @param begin index of the first array element to include
 * @param length the number of elements to include
 * @return the sum of the values or Double.NaN if length = 0
 * @throws IllegalArgumentException if the array is null or the array index
 *  parameters are not valid
 */
@Override
public double evaluate(final double[] values, final int begin, final int length) {
    double sum = Double.NaN;
    if (test(values, begin, length)) {
        sum = 0.0;
        for (int i = begin; i < begin + length; i++) {
            sum += values[i];
        }
    }
    return sum;
}","/**
 * The sum of the entries in the specified portion of
 * the input array, or <code>Double.NaN</code> if the designated subarray
 * is empty.
 * <p>
 * Throws <code>IllegalArgumentException</code> if the array is null.</p>
 *
 * @param values the input array
 * @param begin index of the first array element to include
 * @param length the number of elements to include
 * @return the sum of the values or Double.NaN if length = 0
 * @throws IllegalArgumentException if the array is null or the array index
 *  parameters are not valid
 */
","@Override
public double evaluate(final double[] values, final int begin, final int length) {
    double sum = Double.NaN;
    if (test(values, begin, length)) {
        sum = 0.0;
        for (int i = begin; i < begin + length; i++) {
            sum += values[i];
        }
    }
    return sum;
}",-0.13636363636363635,0.35885167464114837,-0.2,0.0,0.16666666666666666,0.4623015873015873,0.14869626497533486,-0.4166666666666667,0.0,0.08847011635345169
flink,remotes/origin/bugs-dot-jar_FLINK-1145_22c370d9,1,"/**
 *  Checks if the given field is a valid pojo field:
 *  - it is public
 *  OR
 *   - there are getter and setter methods for the field.
 *
 *  @param f field to check
 *  @param clazz class of field
 *  @param typeHierarchy type hierarchy for materializing generic types
 *  @return
 */
private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy) {
    if (Modifier.isPublic(f.getModifiers())) {
        return true;
    } else {
        boolean hasGetter = false, hasSetter = false;
        final String fieldNameLow = f.getName().toLowerCase();
        Type fieldType = f.getGenericType();
        TypeVariable<?> fieldTypeGeneric = null;
        if (fieldType instanceof TypeVariable) {
            fieldTypeGeneric = (TypeVariable<?>) fieldType;
            fieldType = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) fieldType);
        }
        for (Method m : clazz.getMethods()) {
            if (// The name should be ""get<FieldName>"" or ""<fieldName>"" (for scala).
            (m.getName().toLowerCase().equals(""get"" + fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow)) && // no arguments for the getter
            m.getParameterTypes().length == 0 && // return type is same as field type (or the generic variant of it)
            m.getReturnType().equals(fieldType) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric))) {
                if (hasGetter) {
                    throw new IllegalStateException(""Detected more than one getters"");
                }
                hasGetter = true;
            }
            // check for setters (<FieldName>_$eq for scala)
            if ((m.getName().toLowerCase().equals(""set"" + fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow + ""_$eq"")) && // one parameter of the field's type
            m.getParameterTypes().length == 1 && (m.getParameterTypes()[0].equals(fieldType) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric))) && // return type is void.
            m.getReturnType().equals(Void.TYPE)) {
                if (hasSetter) {
                    throw new IllegalStateException(""Detected more than one getters"");
                }
                hasSetter = true;
            }
        }
        if (hasGetter && hasSetter) {
            return true;
        } else {
            if (!hasGetter) {
                LOG.warn(""Class "" + clazz + "" does not contain a getter for field "" + f.getName());
            }
            if (!hasSetter) {
                LOG.warn(""Class "" + clazz + "" does not contain a setter for field "" + f.getName());
            }
            return false;
        }
    }
}","/**
 *  Checks if the given field is a valid pojo field:
 *  - it is public
 *  OR
 *   - there are getter and setter methods for the field.
 *
 *  @param f field to check
 *  @param clazz class of field
 *  @param typeHierarchy type hierarchy for materializing generic types
 *  @return
 */
","private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy) {
    if (Modifier.isPublic(f.getModifiers())) {
        return true;
    } else {
        boolean hasGetter = false, hasSetter = false;
        final String fieldNameLow = f.getName().toLowerCase();
        Type fieldType = f.getGenericType();
        TypeVariable<?> fieldTypeGeneric = null;
        if (fieldType instanceof TypeVariable) {
            fieldTypeGeneric = (TypeVariable<?>) fieldType;
            fieldType = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) fieldType);
        }
        for (Method m : clazz.getMethods()) {
            if (            (m.getName().toLowerCase().equals(""get"" + fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow)) &&             m.getParameterTypes().length == 0 &&             m.getReturnType().equals(fieldType) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric))) {
                if (hasGetter) {
                    throw new IllegalStateException(""Detected more than one getters"");
                }
                hasGetter = true;
            }
                        if ((m.getName().toLowerCase().equals(""set"" + fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow + ""_$eq"")) &&             m.getParameterTypes().length == 1 && (m.getParameterTypes()[0].equals(fieldType) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric))) &&             m.getReturnType().equals(Void.TYPE)) {
                if (hasSetter) {
                    throw new IllegalStateException(""Detected more than one getters"");
                }
                hasSetter = true;
            }
        }
        if (hasGetter && hasSetter) {
            return true;
        } else {
            if (!hasGetter) {
                LOG.warn(""Class "" + clazz + "" does not contain a getter for field "" + f.getName());
            }
            if (!hasSetter) {
                LOG.warn(""Class "" + clazz + "" does not contain a setter for field "" + f.getName());
            }
            return false;
        }
    }
}",1.3636363636363635,0.7033492822966506,1.8,1.0,2.75,1.2380952380952381,-0.8401691331923886,2.4166666666666665,-0.02631578947368421,3.38578516968932
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1932_913c2f53,1,"public void compact() {
    long start = System.nanoTime();
    log.info(""TarMK compaction started"");
    SegmentWriter writer = new SegmentWriter(this, tracker);
    Compactor compactor = new Compactor(writer);
    SegmentNodeState before = getHead();
    SegmentNodeState after = compactor.compact(EMPTY_NODE, before);
    while (!setHead(before, after)) {
        // Some other concurrent changes have been made.
        // Rebase (and compact) those changes on top of the
        // compacted state before retrying to set the head.
        SegmentNodeState head = getHead();
        after = compactor.compact(before, head);
        before = head;
    }
    tracker.setCompactionMap(compactor.getCompactionMap());
    log.info(""TarMK compaction completed in {}ms"", MILLISECONDS.convert(System.nanoTime() - start, NANOSECONDS));
    cleanupNeeded.set(true);
}",,"public void compact() {
    long start = System.nanoTime();
    log.info(""TarMK compaction started"");
    SegmentWriter writer = new SegmentWriter(this, tracker);
    Compactor compactor = new Compactor(writer);
    SegmentNodeState before = getHead();
    SegmentNodeState after = compactor.compact(EMPTY_NODE, before);
    while (!setHead(before, after)) {
                                SegmentNodeState head = getHead();
        after = compactor.compact(before, head);
        before = head;
    }
    tracker.setCompactionMap(compactor.getCompactionMap());
    log.info(""TarMK compaction completed in {}ms"", MILLISECONDS.convert(System.nanoTime() - start, NANOSECONDS));
    cleanupNeeded.set(true);
}",0.09090909090909091,-0.368421052631579,-0.4,-0.5,-0.08333333333333333,0.0039682539682539715,-0.14700493305144474,0.5833333333333334,-0.02631578947368421,0.11191830477804093
camel,remotes/origin/bugs-dot-jar_CAMEL-6687_617eab1c,1,"protected Expression createParametersExpression() {
    final int size = parameters.size();
    LOG.trace(""Creating parameters expression for {} parameters"", size);
    final Expression[] expressions = new Expression[size];
    for (int i = 0; i < size; i++) {
        Expression parameterExpression = parameters.get(i).getExpression();
        expressions[i] = parameterExpression;
        LOG.trace(""Parameter #{} has expression: {}"", i, parameterExpression);
    }
    return new Expression() {

        @SuppressWarnings(""unchecked"")
        public <T> T evaluate(Exchange exchange, Class<T> type) {
            Object[] answer = new Object[size];
            Object body = exchange.getIn().getBody();
            boolean multiParameterArray = false;
            if (exchange.getIn().getHeader(Exchange.BEAN_MULTI_PARAMETER_ARRAY) != null) {
                multiParameterArray = exchange.getIn().getHeader(Exchange.BEAN_MULTI_PARAMETER_ARRAY, Boolean.class);
            }
            // if there was an explicit method name to invoke, then we should support using
            // any provided parameter values in the method name
            String methodName = exchange.getIn().getHeader(Exchange.BEAN_METHOD_NAME, """", String.class);
            // the parameter values is between the parenthesis
            String methodParameters = ObjectHelper.between(methodName, ""("", "")"");
            // use an iterator to walk the parameter values
            Iterator<?> it = null;
            if (methodParameters != null) {
                // split the parameters safely separated by comma, but beware that we can have
                // quoted parameters which contains comma as well, so do a safe quote split
                String[] parameters = StringQuoteHelper.splitSafeQuote(methodParameters, ',', true);
                it = ObjectHelper.createIterator(parameters, "","", true);
            }
            // remove headers as they should not be propagated
            // we need to do this before the expressions gets evaluated as it may contain
            // a @Bean expression which would by mistake read these headers. So the headers
            // must be removed at this point of time
            exchange.getIn().removeHeader(Exchange.BEAN_MULTI_PARAMETER_ARRAY);
            exchange.getIn().removeHeader(Exchange.BEAN_METHOD_NAME);
            for (int i = 0; i < size; i++) {
                // grab the parameter value for the given index
                Object parameterValue = it != null && it.hasNext() ? it.next() : null;
                // and the expected parameter type
                Class<?> parameterType = parameters.get(i).getType();
                // the value for the parameter to use
                Object value = null;
                if (multiParameterArray) {
                    // get the value from the array
                    value = ((Object[]) body)[i];
                } else {
                    // we should skip * as its a type placeholder to indicate any type
                    if (parameterValue != null && !parameterValue.equals(""*"")) {
                        // evaluate the parameter value binding
                        value = evaluateParameterValue(exchange, i, parameterValue, parameterType);
                    }
                    // use bean parameter binding, if still no value
                    Expression expression = expressions[i];
                    if (value == null && expression != null) {
                        value = evaluateParameterBinding(exchange, expression, i, parameterType);
                    }
                }
                // remember the value to use
                if (value != Void.TYPE) {
                    answer[i] = value;
                }
            }
            return (T) answer;
        }

        /**
         * Evaluate using parameter values where the values can be provided in the method name syntax.
         * <p/>
         * This methods returns accordingly:
         * <ul>
         *     <li><tt>null</tt> - if not a parameter value</li>
         *     <li><tt>Void.TYPE</tt> - if an explicit null, forcing Camel to pass in <tt>null</tt> for that given parameter</li>
         *     <li>a non <tt>null</tt> value - if the parameter was a parameter value, and to be used</li>
         * </ul>
         *
         * @since 2.9
         */
        private Object evaluateParameterValue(Exchange exchange, int index, Object parameterValue, Class<?> parameterType) {
            Object answer = null;
            // convert the parameter value to a String
            String exp = exchange.getContext().getTypeConverter().convertTo(String.class, exchange, parameterValue);
            if (exp != null) {
                // check if its a valid parameter value
                boolean valid = BeanHelper.isValidParameterValue(exp);
                if (!valid) {
                    // it may be a parameter type instead, and if so, then we should return null,
                    // as this method is only for evaluating parameter values
                    Boolean isClass = BeanHelper.isAssignableToExpectedType(exchange.getContext().getClassResolver(), exp, parameterType);
                    // the method will return a non null value if exp is a class
                    if (isClass != null) {
                        return null;
                    }
                }
                // use simple language to evaluate the expression, as it may use the simple language to refer to message body, headers etc.
                Expression expression = null;
                try {
                    expression = exchange.getContext().resolveLanguage(""simple"").createExpression(exp);
                    parameterValue = expression.evaluate(exchange, Object.class);
                } catch (Exception e) {
                    throw new ExpressionEvaluationException(expression, ""Cannot create/evaluate simple expression: "" + exp + "" to be bound to parameter at index: "" + index + "" on method: "" + getMethod(), exchange, e);
                }
                if (parameterValue != null) {
                    // see method javadoc for details
                    if (""null"".equals(parameterValue)) {
                        return Void.TYPE;
                    }
                    // the parameter value was not already valid, but since the simple language have evaluated the expression
                    // which may change the parameterValue, so we have to check it again to see if its now valid
                    exp = exchange.getContext().getTypeConverter().convertTo(String.class, parameterValue);
                    // String values from the simple language is always valid
                    if (!valid) {
                        // re validate if the parameter was not valid the first time (String values should be accepted)
                        valid = parameterValue instanceof String || BeanHelper.isValidParameterValue(exp);
                    }
                    if (valid) {
                        // we need to unquote String parameters, as the enclosing quotes is there to denote a parameter value
                        if (parameterValue instanceof String) {
                            parameterValue = StringHelper.removeLeadingAndEndingQuotes((String) parameterValue);
                        }
                        if (parameterValue != null) {
                            try {
                                // its a valid parameter value, so convert it to the expected type of the parameter
                                answer = exchange.getContext().getTypeConverter().mandatoryConvertTo(parameterType, exchange, parameterValue);
                                if (LOG.isTraceEnabled()) {
                                    LOG.trace(""Parameter #{} evaluated as: {} type: "", new Object[] { index, answer, ObjectHelper.type(answer) });
                                }
                            } catch (Exception e) {
                                if (LOG.isDebugEnabled()) {
                                    LOG.debug(""Cannot convert from type: {} to type: {} for parameter #{}"", new Object[] { ObjectHelper.type(parameterValue), parameterType, index });
                                }
                                throw new ParameterBindingException(e, method, index, parameterType, parameterValue);
                            }
                        }
                    }
                }
            }
            return answer;
        }

        /**
         * Evaluate using classic parameter binding using the pre compute expression
         */
        private Object evaluateParameterBinding(Exchange exchange, Expression expression, int index, Class<?> parameterType) {
            Object answer = null;
            // use object first to avoid type conversion so we know if there is a value or not
            Object result = expression.evaluate(exchange, Object.class);
            if (result != null) {
                // we got a value now try to convert it to the expected type
                try {
                    answer = exchange.getContext().getTypeConverter().mandatoryConvertTo(parameterType, result);
                    if (LOG.isTraceEnabled()) {
                        LOG.trace(""Parameter #{} evaluated as: {} type: "", new Object[] { index, answer, ObjectHelper.type(answer) });
                    }
                } catch (NoTypeConversionAvailableException e) {
                    if (LOG.isDebugEnabled()) {
                        LOG.debug(""Cannot convert from type: {} to type: {} for parameter #{}"", new Object[] { ObjectHelper.type(result), parameterType, index });
                    }
                    throw new ParameterBindingException(e, method, index, parameterType, result);
                }
            } else {
                LOG.trace(""Parameter #{} evaluated as null"", index);
            }
            return answer;
        }

        @Override
        public String toString() {
            return ""ParametersExpression: "" + Arrays.asList(expressions);
        }
    };
}","/**
 * Evaluate using parameter values where the values can be provided in the method name syntax.
 * <p/>
 * This methods returns accordingly:
 * <ul>
 *     <li><tt>null</tt> - if not a parameter value</li>
 *     <li><tt>Void.TYPE</tt> - if an explicit null, forcing Camel to pass in <tt>null</tt> for that given parameter</li>
 *     <li>a non <tt>null</tt> value - if the parameter was a parameter value, and to be used</li>
 * </ul>
 *
 * @since 2.9
 */
/**
 * Evaluate using classic parameter binding using the pre compute expression
 */
","protected Expression createParametersExpression() {
    final int size = parameters.size();
    LOG.trace(""Creating parameters expression for {} parameters"", size);
    final Expression[] expressions = new Expression[size];
    for (int i = 0; i < size; i++) {
        Expression parameterExpression = parameters.get(i).getExpression();
        expressions[i] = parameterExpression;
        LOG.trace(""Parameter #{} has expression: {}"", i, parameterExpression);
    }
    return new Expression() {

        @SuppressWarnings(""unchecked"")
        public <T> T evaluate(Exchange exchange, Class<T> type) {
            Object[] answer = new Object[size];
            Object body = exchange.getIn().getBody();
            boolean multiParameterArray = false;
            if (exchange.getIn().getHeader(Exchange.BEAN_MULTI_PARAMETER_ARRAY) != null) {
                multiParameterArray = exchange.getIn().getHeader(Exchange.BEAN_MULTI_PARAMETER_ARRAY, Boolean.class);
            }
                                    String methodName = exchange.getIn().getHeader(Exchange.BEAN_METHOD_NAME, """", String.class);
                        String methodParameters = ObjectHelper.between(methodName, ""("", "")"");
                        Iterator<?> it = null;
            if (methodParameters != null) {
                                                String[] parameters = StringQuoteHelper.splitSafeQuote(methodParameters, ',', true);
                it = ObjectHelper.createIterator(parameters, "","", true);
            }
                                                            exchange.getIn().removeHeader(Exchange.BEAN_MULTI_PARAMETER_ARRAY);
            exchange.getIn().removeHeader(Exchange.BEAN_METHOD_NAME);
            for (int i = 0; i < size; i++) {
                                Object parameterValue = it != null && it.hasNext() ? it.next() : null;
                                Class<?> parameterType = parameters.get(i).getType();
                                Object value = null;
                if (multiParameterArray) {
                                        value = ((Object[]) body)[i];
                } else {
                                        if (parameterValue != null && !parameterValue.equals(""*"")) {
                                                value = evaluateParameterValue(exchange, i, parameterValue, parameterType);
                    }
                                        Expression expression = expressions[i];
                    if (value == null && expression != null) {
                        value = evaluateParameterBinding(exchange, expression, i, parameterType);
                    }
                }
                                if (value != Void.TYPE) {
                    answer[i] = value;
                }
            }
            return (T) answer;
        }

        /**
         * Evaluate using parameter values where the values can be provided in the method name syntax.
         * <p/>
         * This methods returns accordingly:
         * <ul>
         *     <li><tt>null</tt> - if not a parameter value</li>
         *     <li><tt>Void.TYPE</tt> - if an explicit null, forcing Camel to pass in <tt>null</tt> for that given parameter</li>
         *     <li>a non <tt>null</tt> value - if the parameter was a parameter value, and to be used</li>
         * </ul>
         *
         * @since 2.9
         */
        private Object evaluateParameterValue(Exchange exchange, int index, Object parameterValue, Class<?> parameterType) {
            Object answer = null;
                        String exp = exchange.getContext().getTypeConverter().convertTo(String.class, exchange, parameterValue);
            if (exp != null) {
                                boolean valid = BeanHelper.isValidParameterValue(exp);
                if (!valid) {
                                                            Boolean isClass = BeanHelper.isAssignableToExpectedType(exchange.getContext().getClassResolver(), exp, parameterType);
                                        if (isClass != null) {
                        return null;
                    }
                }
                                Expression expression = null;
                try {
                    expression = exchange.getContext().resolveLanguage(""simple"").createExpression(exp);
                    parameterValue = expression.evaluate(exchange, Object.class);
                } catch (Exception e) {
                    throw new ExpressionEvaluationException(expression, ""Cannot create/evaluate simple expression: "" + exp + "" to be bound to parameter at index: "" + index + "" on method: "" + getMethod(), exchange, e);
                }
                if (parameterValue != null) {
                                        if (""null"".equals(parameterValue)) {
                        return Void.TYPE;
                    }
                                                            exp = exchange.getContext().getTypeConverter().convertTo(String.class, parameterValue);
                                        if (!valid) {
                                                valid = parameterValue instanceof String || BeanHelper.isValidParameterValue(exp);
                    }
                    if (valid) {
                                                if (parameterValue instanceof String) {
                            parameterValue = StringHelper.removeLeadingAndEndingQuotes((String) parameterValue);
                        }
                        if (parameterValue != null) {
                            try {
                                                                answer = exchange.getContext().getTypeConverter().mandatoryConvertTo(parameterType, exchange, parameterValue);
                                if (LOG.isTraceEnabled()) {
                                    LOG.trace(""Parameter #{} evaluated as: {} type: "", new Object[] { index, answer, ObjectHelper.type(answer) });
                                }
                            } catch (Exception e) {
                                if (LOG.isDebugEnabled()) {
                                    LOG.debug(""Cannot convert from type: {} to type: {} for parameter #{}"", new Object[] { ObjectHelper.type(parameterValue), parameterType, index });
                                }
                                throw new ParameterBindingException(e, method, index, parameterType, parameterValue);
                            }
                        }
                    }
                }
            }
            return answer;
        }

        /**
         * Evaluate using classic parameter binding using the pre compute expression
         */
        private Object evaluateParameterBinding(Exchange exchange, Expression expression, int index, Class<?> parameterType) {
            Object answer = null;
                        Object result = expression.evaluate(exchange, Object.class);
            if (result != null) {
                                try {
                    answer = exchange.getContext().getTypeConverter().mandatoryConvertTo(parameterType, result);
                    if (LOG.isTraceEnabled()) {
                        LOG.trace(""Parameter #{} evaluated as: {} type: "", new Object[] { index, answer, ObjectHelper.type(answer) });
                    }
                } catch (NoTypeConversionAvailableException e) {
                    if (LOG.isDebugEnabled()) {
                        LOG.debug(""Cannot convert from type: {} to type: {} for parameter #{}"", new Object[] { ObjectHelper.type(result), parameterType, index });
                    }
                    throw new ParameterBindingException(e, method, index, parameterType, result);
                }
            } else {
                LOG.trace(""Parameter #{} evaluated as null"", index);
            }
            return answer;
        }

        @Override
        public String toString() {
            return ""ParametersExpression: "" + Arrays.asList(expressions);
        }
    };
}",5.590909090909091,2.124401913875598,5.2,2.5,3.25,2.555555555555556,-1.6373502466525718,5.0,-0.02631578947368421,20.208186810970297
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1190_e29dc4f5,3,"@Override
public void onRemoval(RemovalNotification<UUID, BatchWriter> notification) {
    try {
        notification.getValue().close();
    } catch (MutationsRejectedException e) {
        logger.warn(e, e);
    }
}",,"@Override
public void onRemoval(RemovalNotification<UUID, BatchWriter> notification) {
    try {
        notification.getValue().close();
    } catch (MutationsRejectedException e) {
        logger.warn(e, e);
    }
}",-0.2727272727272727,0.06220095693779899,-0.4,-0.5,-0.4166666666666667,-0.3650793650793651,0.4167723749119096,-0.25,0.39473684210526316,-0.16279340490885932
camel,remotes/origin/bugs-dot-jar_CAMEL-3789_9319e139,1,"public void releaseExclusiveReadLock(GenericFileOperations<File> operations, GenericFile<File> file, Exchange exchange) throws Exception {
    if (lock != null) {
        LOG.trace(""Unlocking file: {}"", lockFileName);
        boolean deleted = FileUtil.deleteFile(lock);
        LOG.trace(""Lock file: {} was deleted: {}"", lockFileName, deleted);
    }
}",,"public void releaseExclusiveReadLock(GenericFileOperations<File> operations, GenericFile<File> file, Exchange exchange) throws Exception {
    if (lock != null) {
        LOG.trace(""Unlocking file: {}"", lockFileName);
        boolean deleted = FileUtil.deleteFile(lock);
        LOG.trace(""Lock file: {} was deleted: {}"", lockFileName, deleted);
    }
}",-0.3181818181818182,0.1626794258373205,-0.4,-0.5,-0.25,-0.10714285714285715,0.36828752642706114,-0.25,0.0,-0.08795836863124773
Codec,11,1,"/**
 * Decodes an array quoted-printable characters into an array of original bytes. Escaped characters are
 * converted back to their original representation.
 *
 * <p>
 * This function fully implements the quoted-printable encoding specification (rule #1 through rule #5) as
 * defined in RFC 1521.
 * </p>
 *
 * @param bytes
 *                  array of quoted-printable characters
 * @return array of original bytes
 * @throws DecoderException
 *                  Thrown if quoted-printable decoding is unsuccessful
 */
public static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {
    if (bytes == null) {
        return null;
    }
    ByteArrayOutputStream buffer = new ByteArrayOutputStream();
    for (int i = 0; i < bytes.length; i++) {
        final int b = bytes[i];
        if (b == ESCAPE_CHAR) {
            try {
                // if the next octet is a CR we have found a soft line break
                int u = Utils.digit16(bytes[++i]);
                int l = Utils.digit16(bytes[++i]);
                buffer.write((char) ((u << 4) + l));
            } catch (ArrayIndexOutOfBoundsException e) {
                throw new DecoderException(""Invalid quoted-printable encoding"", e);
            }
        } else {
            // every other octet is appended except for CR & LF
            buffer.write(b);
        }
    }
    return buffer.toByteArray();
}","/**
 * Decodes an array quoted-printable characters into an array of original bytes. Escaped characters are
 * converted back to their original representation.
 *
 * <p>
 * This function fully implements the quoted-printable encoding specification (rule #1 through rule #5) as
 * defined in RFC 1521.
 * </p>
 *
 * @param bytes
 *                  array of quoted-printable characters
 * @return array of original bytes
 * @throws DecoderException
 *                  Thrown if quoted-printable decoding is unsuccessful
 */
","public static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {
    if (bytes == null) {
        return null;
    }
    ByteArrayOutputStream buffer = new ByteArrayOutputStream();
    for (int i = 0; i < bytes.length; i++) {
        final int b = bytes[i];
        if (b == ESCAPE_CHAR) {
            try {
                                int u = Utils.digit16(bytes[++i]);
                int l = Utils.digit16(bytes[++i]);
                buffer.write((char) ((u << 4) + l));
            } catch (ArrayIndexOutOfBoundsException e) {
                throw new DecoderException(""Invalid quoted-printable encoding"", e);
            }
        } else {
                        buffer.write(b);
        }
    }
    return buffer.toByteArray();
}",0.3181818181818182,1.0,0.4,0.5,0.16666666666666666,0.878968253968254,-0.2794926004228327,-0.08333333333333333,0.05263157894736841,0.6574598180068347
Closure,3,1,"@Override
public boolean apply(Node input) {
    switch(input.getType()) {
        case Token.GETELEM:
        case Token.GETPROP:
        case Token.ARRAYLIT:
        case Token.OBJECTLIT:
        case Token.REGEXP:
        case Token.NEW:
            return true;
    }
    return false;
}",,"@Override
public boolean apply(Node input) {
    switch(input.getType()) {
        case Token.GETELEM:
        case Token.GETPROP:
        case Token.ARRAYLIT:
        case Token.OBJECTLIT:
        case Token.REGEXP:
        case Token.NEW:
            return true;
    }
    return false;
}",-0.045454545454545456,0.3349282296650717,0.6,0.0,0.16666666666666666,-0.3650793650793651,0.11486962649753353,-0.4166666666666667,0.10526315789473684,-0.16279340490885932
wicket,remotes/origin/bugs-dot-jar_WICKET-5071_6e794ad0,1,"private boolean matches(final Url url) {
    return (url.getSegments().size() >= 3 && urlStartsWith(url, getContext().getNamespace(), getContext().getBookmarkableIdentifier()));
}",,"private boolean matches(final Url url) {
    return (url.getSegments().size() >= 3 && urlStartsWith(url, getContext().getNamespace(), getContext().getBookmarkableIdentifier()));
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.11309523809523811,0.8711768851303733,0.08333333333333333,-0.02631578947368421,-0.12805449421690493
Cli,21,1,"/**
 * Tests whether the passed in trigger looks like an option. This
 * implementation first checks whether the passed in string starts with a
 * prefix that indicates an option. If this is the case, it is also checked
 * whether an option of this name is known for the current option. (This can
 * lead to reentrant invocations of this method, so care has to be taken
 * about this.)
 *
 * @param trigger the command line element to test
 * @return a flag whether this element seems to be an option
 */
public boolean looksLikeOption(final String trigger) {
    for (final Iterator i = prefixes.iterator(); i.hasNext(); ) {
        final String prefix = (String) i.next();
        if (trigger.startsWith(prefix)) {
            return true;
        }
    }
    return false;
}","/**
 * Tests whether the passed in trigger looks like an option. This
 * implementation first checks whether the passed in string starts with a
 * prefix that indicates an option. If this is the case, it is also checked
 * whether an option of this name is known for the current option. (This can
 * lead to reentrant invocations of this method, so care has to be taken
 * about this.)
 *
 * @param trigger the command line element to test
 * @return a flag whether this element seems to be an option
 */
","public boolean looksLikeOption(final String trigger) {
    for (final Iterator i = prefixes.iterator(); i.hasNext(); ) {
        final String prefix = (String) i.next();
        if (trigger.startsWith(prefix)) {
            return true;
        }
    }
    return false;
}",-0.22727272727272727,0.3732057416267942,-0.2,0.0,0.0,-0.3650793650793651,0.30204369274136716,-0.16666666666666666,1.1052631578947367,-0.16279340490885932
wicket,remotes/origin/bugs-dot-jar_WICKET-3511_4a875f46,1,"public IResourceStream locate(Class<?> scope, String path, String style, String variation, Locale locale, String extension, boolean strict) {
    Key key = new Key(scope.getName(), path, locale, style, variation);
    IResourceStream resourceStream = getCopyFromCache(key);
    if (resourceStream == null) {
        resourceStream = delegate.locate(scope, path, style, variation, locale, extension, strict);
        updateCache(key, resourceStream);
    }
    return resourceStream;
}",,"public IResourceStream locate(Class<?> scope, String path, String style, String variation, Locale locale, String extension, boolean strict) {
    Key key = new Key(scope.getName(), path, locale, style, variation);
    IResourceStream resourceStream = getCopyFromCache(key);
    if (resourceStream == null) {
        resourceStream = delegate.locate(scope, path, style, variation, locale, extension, strict);
        updateCache(key, resourceStream);
    }
    return resourceStream;
}",-0.22727272727272727,-0.15311004784689008,-0.4,-0.5,-0.25,0.059523809523809534,0.16955602536997882,-0.16666666666666666,-0.02631578947368421,0.05618390645620465
Closure,34,2,"/**
 * We could use addList recursively here, but sometimes we produce
 * very deeply nested operators and run out of stack space, so we
 * just unroll the recursion when possible.
 *
 * We assume nodes are left-recursive.
 */
private void unrollBinaryOperator(Node n, int op, String opStr, Context context, Context rhsContext, int leftPrecedence, int rightPrecedence) {
    Node firstNonOperator = n.getFirstChild();
    while (firstNonOperator.getType() == op) {
        firstNonOperator = firstNonOperator.getFirstChild();
    }
    addExpr(firstNonOperator, leftPrecedence, context);
    Node current = firstNonOperator;
    do {
        current = current.getParent();
        cc.listSeparator();
        addExpr(current.getFirstChild().getNext(), rightPrecedence, rhsContext);
    } while (current != n);
}","/**
 * We could use addList recursively here, but sometimes we produce
 * very deeply nested operators and run out of stack space, so we
 * just unroll the recursion when possible.
 *
 * We assume nodes are left-recursive.
 */
","private void unrollBinaryOperator(Node n, int op, String opStr, Context context, Context rhsContext, int leftPrecedence, int rightPrecedence) {
    Node firstNonOperator = n.getFirstChild();
    while (firstNonOperator.getType() == op) {
        firstNonOperator = firstNonOperator.getFirstChild();
    }
    addExpr(firstNonOperator, leftPrecedence, context);
    Node current = firstNonOperator;
    do {
        current = current.getParent();
        cc.listSeparator();
        addExpr(current.getFirstChild().getNext(), rightPrecedence, rhsContext);
    } while (current != n);
}",-0.045454545454545456,-0.16267942583732073,-0.2,-0.5,0.08333333333333333,0.041666666666666616,-0.0069062720225512185,0.25,0.0,0.04929144839588986
Math,62,1,"/**
 * {@inheritDoc}
 */
public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal, final double min, final double max) throws FunctionEvaluationException {
    return optimize(f, goal, min, max, 0);
}","/**
 * {@inheritDoc}
 */
","public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal, final double min, final double max) throws FunctionEvaluationException {
    return optimize(f, goal, min, max, 0);
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.8810429880197319,-0.4166666666666667,0.7368421052631579,-0.16279340490885932
commons-math,remotes/origin/bugs-dot-jar_MATH-395_962315ba,1,"/**
 * Temporary workaround.
 */
protected double doOptimize() {
    throw new UnsupportedOperationException();
}","/**
 * Temporary workaround.
 */
","protected double doOptimize() {
    throw new UnsupportedOperationException();
}",-0.5,-0.5263157894736844,-0.4,-1.0,-0.4166666666666667,-0.3650793650793651,1.2342494714587733,-0.5,2.5789473684210527,-0.16279340490885932
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1505_994df698,1,"@Override
public void addMutation(Mutation m) throws MutationsRejectedException {
    acu.addMutation(tablename, m);
}",,"@Override
public void addMutation(Mutation m) throws MutationsRejectedException {
    acu.addMutation(tablename, m);
}",-0.45454545454545453,-0.6028708133971293,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.8396053558844253,-0.4166666666666667,1.1052631578947367,-0.16279340490885932
Math,55,1,"/**
 * Compute the cross-product of two vectors.
 * @param v1 first vector
 * @param v2 second vector
 * @return the cross product v1 ^ v2 as a new Vector
 */
public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {
    // compute cross product from v3 and v2 instead of v1 and v2
    return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);
}","/**
 * Compute the cross-product of two vectors.
 * @param v1 first vector
 * @param v2 second vector
 * @return the cross product v1 ^ v2 as a new Vector
 */
","public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {
        return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,0.4285714285714286,0.7491190979563072,-0.5,0.02631578947368421,0.08837790955665815
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-210_aeb6fc9d,1,"public void asXML(final StringBuilder sb) {
    sb.append(""<Map>\n"");
    for (final Map.Entry<String, String> entry : data.entrySet()) {
        sb.append(""  <Entry key="").append(entry.getKey()).append("">"").append(entry.getValue()).append(""</Entry>\n"");
    }
    sb.append(""</Map>"");
}",,"public void asXML(final StringBuilder sb) {
    sb.append(""<Map>\n"");
    for (final Map.Entry<String, String> entry : data.entrySet()) {
        sb.append(""  <Entry key="").append(entry.getKey()).append("">"").append(entry.getValue()).append(""</Entry>\n"");
    }
    sb.append(""</Map>"");
}",-0.3181818181818182,-0.20574162679425848,-0.4,-0.5,-0.4166666666666667,-0.3650793650793651,0.36800563777307976,0.3333333333333333,-0.02631578947368421,-0.16279340490885932
commons-math,remotes/origin/bugs-dot-jar_MATH-757_76b7413d,1,"/**
 * Clear the array contents, resetting the number of elements to zero.
 */
@Override
public synchronized void clear() {
    numElements = 0;
    startIndex = 0;
}","/**
 * Clear the array contents, resetting the number of elements to zero.
 */
","@Override
public synchronized void clear() {
    numElements = 0;
    startIndex = 0;
}",-0.4090909090909091,-0.49282296650717716,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.7626497533474278,-0.5,2.552631578947368,-0.16279340490885932
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-113_fc3e9d2d,1,"/**
 * Create the StructuredDataFilter.
 * @param pairs Key and value pairs.
 * @param oper The operator to perform. If not ""or"" the operation will be an ""and"".
 * @param match The action to perform on a match.
 * @param mismatch The action to perform on a mismatch.
 * @return The StructuredDataFilter.
 */
@PluginFactory
public static StructuredDataFilter createFilter(@PluginAttr(""pairs"") KeyValuePair[] pairs, @PluginAttr(""operator"") String oper, @PluginAttr(""onmatch"") String match, @PluginAttr(""onmismatch"") String mismatch) {
    if (pairs == null || pairs.length == 0) {
        LOGGER.error(""keys and values must be specified for the StructuredDataFilter"");
        return null;
    }
    Map<String, List<String>> map = new HashMap<String, List<String>>();
    for (KeyValuePair pair : pairs) {
        String key = pair.getKey();
        if (key == null) {
            LOGGER.error(""A null key is not valid in MapFilter"");
            continue;
        }
        String value = pair.getValue();
        if (value == null) {
            LOGGER.error(""A null value for key "" + key + "" is not allowed in MapFilter"");
            continue;
        }
        List<String> list = map.get(pair.getKey());
        if (list != null) {
            list.add(value);
        } else {
            list = new ArrayList<String>();
            list.add(value);
            map.put(pair.getKey(), list);
        }
    }
    if (map.size() == 0) {
        LOGGER.error(""StructuredDataFilter is not configured with any valid key value pairs"");
        return null;
    }
    boolean isAnd = oper == null || !oper.equalsIgnoreCase(""or"");
    Result onMatch = Result.toResult(match);
    Result onMismatch = Result.toResult(mismatch);
    return new StructuredDataFilter(map, isAnd, onMatch, onMismatch);
}","/**
 * Create the StructuredDataFilter.
 * @param pairs Key and value pairs.
 * @param oper The operator to perform. If not ""or"" the operation will be an ""and"".
 * @param match The action to perform on a match.
 * @param mismatch The action to perform on a mismatch.
 * @return The StructuredDataFilter.
 */
","@PluginFactory
public static StructuredDataFilter createFilter(@PluginAttr(""pairs"") KeyValuePair[] pairs, @PluginAttr(""operator"") String oper, @PluginAttr(""onmatch"") String match, @PluginAttr(""onmismatch"") String mismatch) {
    if (pairs == null || pairs.length == 0) {
        LOGGER.error(""keys and values must be specified for the StructuredDataFilter"");
        return null;
    }
    Map<String, List<String>> map = new HashMap<String, List<String>>();
    for (KeyValuePair pair : pairs) {
        String key = pair.getKey();
        if (key == null) {
            LOGGER.error(""A null key is not valid in MapFilter"");
            continue;
        }
        String value = pair.getValue();
        if (value == null) {
            LOGGER.error(""A null value for key "" + key + "" is not allowed in MapFilter"");
            continue;
        }
        List<String> list = map.get(pair.getKey());
        if (list != null) {
            list.add(value);
        } else {
            list = new ArrayList<String>();
            list.add(value);
            map.put(pair.getKey(), list);
        }
    }
    if (map.size() == 0) {
        LOGGER.error(""StructuredDataFilter is not configured with any valid key value pairs"");
        return null;
    }
    boolean isAnd = oper == null || !oper.equalsIgnoreCase(""or"");
    Result onMatch = Result.toResult(match);
    Result onMismatch = Result.toResult(mismatch);
    return new StructuredDataFilter(map, isAnd, onMatch, onMismatch);
}",1.0,0.2775119617224879,1.0,0.0,0.5833333333333334,1.0833333333333333,-0.6868217054263562,0.8333333333333334,-0.02631578947368421,2.3519533433608224
Closure,155,2,"/**
 * For all variables in this scope, see if they are only used once.
 * If it looks safe to do so, inline them.
 */
private void doInlinesForScope(NodeTraversal t, Map<Var, ReferenceCollection> referenceMap) {
    for (Iterator<Var> it = t.getScope().getVars(); it.hasNext(); ) {
        Var v = it.next();
        ReferenceCollection referenceInfo = referenceMap.get(v);
        // and the variable is not a constant.
        if (referenceInfo == null || isVarInlineForbidden(v)) {
            // were not collected or variables that have already been inlined.
            continue;
        } else if (isInlineableDeclaredConstant(v, referenceInfo)) {
            Reference init = referenceInfo.getInitializingReferenceForConstants();
            Node value = init.getAssignedValue();
            inlineDeclaredConstant(v, value, referenceInfo.references);
            staleVars.add(v);
        } else if (mode == Mode.CONSTANTS_ONLY) {
            // inlining heuristics. See InlineConstantsTest.
            continue;
        } else {
            inlineNonConstants(v, referenceInfo);
        }
    }
}","/**
 * For all variables in this scope, see if they are only used once.
 * If it looks safe to do so, inline them.
 */
","private void doInlinesForScope(NodeTraversal t, Map<Var, ReferenceCollection> referenceMap) {
    for (Iterator<Var> it = t.getScope().getVars(); it.hasNext(); ) {
        Var v = it.next();
        ReferenceCollection referenceInfo = referenceMap.get(v);
                if (referenceInfo == null || isVarInlineForbidden(v)) {
                        continue;
        } else if (isInlineableDeclaredConstant(v, referenceInfo)) {
            Reference init = referenceInfo.getInitializingReferenceForConstants();
            Node value = init.getAssignedValue();
            inlineDeclaredConstant(v, value, referenceInfo.references);
            staleVars.add(v);
        } else if (mode == Mode.CONSTANTS_ONLY) {
                        continue;
        } else {
            inlineNonConstants(v, referenceInfo);
        }
    }
}",0.18181818181818182,0.42583732057416257,0.6,1.0,0.5,-0.0496031746031746,-0.23467230443974632,0.5,-0.02631578947368421,0.07370780818681096
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3510_01f5a26f,1,"/**
 * Creates an external identity reference from a string representation.
 * @param str the string
 * @return the reference
 */
public static ExternalIdentityRef fromString(@Nonnull String str) {
    int idx = str.indexOf(';');
    if (idx < 0) {
        return new ExternalIdentityRef(Text.unescape(str), null);
    } else {
        return new ExternalIdentityRef(Text.unescape(str.substring(0, idx)), Text.unescape(str.substring(idx + 1)));
    }
}","/**
 * Creates an external identity reference from a string representation.
 * @param str the string
 * @return the reference
 */
","public static ExternalIdentityRef fromString(@Nonnull String str) {
    int idx = str.indexOf(';');
    if (idx < 0) {
        return new ExternalIdentityRef(Text.unescape(str), null);
    } else {
        return new ExternalIdentityRef(Text.unescape(str.substring(0, idx)), Text.unescape(str.substring(idx + 1)));
    }
}",-0.2727272727272727,-0.07655502392344504,-0.4,-0.5,-0.25,0.03174603174603173,0.29330514446793515,0.0,0.3684210526315789,-0.03590763184131209
wicket,remotes/origin/bugs-dot-jar_WICKET-428_d906576c,3,"public Object get(final int index) {
    return value;
}",,"public Object get(final int index) {
    return value;
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,1.1099365750528538,-0.5,2.4473684210526314,-0.16279340490885932
Closure,24,2,"private void findAliases(NodeTraversal t) {
    Scope scope = t.getScope();
    for (Var v : scope.getVarIterable()) {
        Node n = v.getNode();
        int type = n.getType();
        Node parent = n.getParent();
        if (parent.isVar()) {
            if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {
                String name = n.getString();
                Var aliasVar = scope.getVar(name);
                aliases.put(name, aliasVar);
                String qualifiedName = aliasVar.getInitialValue().getQualifiedName();
                transformation.addAlias(name, qualifiedName);
            // Bleeding functions already get a BAD_PARAMETERS error, so just
            // do nothing.
            // Parameters of the scope function also get a BAD_PARAMETERS
            // error.
            } else {
                // TODO(robbyw): Support using locals for private variables.
                report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());
            }
        }
    }
}",,"private void findAliases(NodeTraversal t) {
    Scope scope = t.getScope();
    for (Var v : scope.getVarIterable()) {
        Node n = v.getNode();
        int type = n.getType();
        Node parent = n.getParent();
        if (parent.isVar()) {
            if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {
                String name = n.getString();
                Var aliasVar = scope.getVar(name);
                aliases.put(name, aliasVar);
                String qualifiedName = aliasVar.getInitialValue().getQualifiedName();
                transformation.addAlias(name, qualifiedName);
                                                            } else {
                                report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());
            }
        }
    }
}",0.22727272727272727,1.15311004784689,0.0,0.5,0.08333333333333333,-0.03571428571428575,-0.2490486257928116,0.9166666666666666,0.02631578947368421,0.09988992813632772
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-93_0be7e8f0,1,"@Override
public PropertyState setProperty(String name, List<CoreValue> values) {
    PropertyState property = new PropertyStateImpl(name, values);
    if (hasProperty(name)) {
        context.setProperty(property, path);
    } else {
        context.addProperty(property, path);
    }
    return property;
}",,"@Override
public PropertyState setProperty(String name, List<CoreValue> values) {
    PropertyState property = new PropertyStateImpl(name, values);
    if (hasProperty(name)) {
        context.setProperty(property, path);
    } else {
        context.addProperty(property, path);
    }
    return property;
}",-0.18181818181818182,-0.0909090909090911,-0.4,-0.5,-0.16666666666666666,-0.3650793650793651,0.23241719520789295,-0.25,0.05263157894736841,-0.16279340490885932
wicket,remotes/origin/bugs-dot-jar_WICKET-4153_2737d7c7,3,"/**
 *  Create the MarkupContainer for the <tbody> tag. Users may subclass it to provide their own
 *  (modified) implementation.
 *
 *  @param id
 *  @return A new markup container
 */
protected WebMarkupContainer newBodyContainer(final String id) {
    return new WebMarkupContainer(id);
}","/**
 *  Create the MarkupContainer for the <tbody> tag. Users may subclass it to provide their own
 *  (modified) implementation.
 *
 *  @param id
 *  @return A new markup container
 */
","protected WebMarkupContainer newBodyContainer(final String id) {
    return new WebMarkupContainer(id);
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,1.0606060606060603,-0.5,2.6052631578947367,-0.16279340490885932
Lang,30,3,"// IndexOfAny chars
// -----------------------------------------------------------------------
/**
 * <p>Search a CharSequence to find the first index of any
 * character in the given set of characters.</p>
 *
 * <p>A <code>null</code> String will return <code>-1</code>.
 * A <code>null</code> or zero length search array will return <code>-1</code>.</p>
 *
 * <pre>
 * StringUtils.indexOfAny(null, *)                = -1
 * StringUtils.indexOfAny("""", *)                  = -1
 * StringUtils.indexOfAny(*, null)                = -1
 * StringUtils.indexOfAny(*, [])                  = -1
 * StringUtils.indexOfAny(""zzabyycdxx"",['z','a']) = 0
 * StringUtils.indexOfAny(""zzabyycdxx"",['b','y']) = 3
 * StringUtils.indexOfAny(""aba"", ['z'])           = -1
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the index of any of the chars, -1 if no match or null input
 * @since 2.0
 */
public static int indexOfAny(CharSequence cs, char[] searchChars) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
        return INDEX_NOT_FOUND;
    }
    int csLen = cs.length();
    int searchLen = searchChars.length;
    for (int i = 0; i < csLen; i++) {
        char ch = cs.charAt(i);
        for (int j = 0; j < searchLen; j++) {
            if (searchChars[j] == ch) {
                // ch is a supplementary character
                return i;
            }
        }
    }
    return INDEX_NOT_FOUND;
}","/**
 * <p>Search a CharSequence to find the first index of any
 * character in the given set of characters.</p>
 *
 * <p>A <code>null</code> String will return <code>-1</code>.
 * A <code>null</code> or zero length search array will return <code>-1</code>.</p>
 *
 * <pre>
 * StringUtils.indexOfAny(null, *)                = -1
 * StringUtils.indexOfAny("""", *)                  = -1
 * StringUtils.indexOfAny(*, null)                = -1
 * StringUtils.indexOfAny(*, [])                  = -1
 * StringUtils.indexOfAny(""zzabyycdxx"",['z','a']) = 0
 * StringUtils.indexOfAny(""zzabyycdxx"",['b','y']) = 3
 * StringUtils.indexOfAny(""aba"", ['z'])           = -1
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the index of any of the chars, -1 if no match or null input
 * @since 2.0
 */
","public static int indexOfAny(CharSequence cs, char[] searchChars) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
        return INDEX_NOT_FOUND;
    }
    int csLen = cs.length();
    int searchLen = searchChars.length;
    for (int i = 0; i < csLen; i++) {
        char ch = cs.charAt(i);
        for (int j = 0; j < searchLen; j++) {
            if (searchChars[j] == ch) {
                                return i;
            }
        }
    }
    return INDEX_NOT_FOUND;
}",0.09090909090909091,0.5980861244019139,0.2,0.5,0.75,0.5277777777777778,-0.10218463706835798,-0.16666666666666666,0.15789473684210528,0.2654979455173089
Compress,18,1,"/**
 * Writes a PAX extended header with the given map as contents.
 * @since 1.4
 */
void writePaxHeaders(String entryName, Map<String, String> headers) throws IOException {
    String name = ""./PaxHeaders.X/"" + stripTo7Bits(entryName);
    // and not allow any data to be written
    if (name.length() >= TarConstants.NAMELEN) {
        name = name.substring(0, TarConstants.NAMELEN - 1);
    }
    TarArchiveEntry pex = new TarArchiveEntry(name, TarConstants.LF_PAX_EXTENDED_HEADER_LC);
    StringWriter w = new StringWriter();
    for (Map.Entry<String, String> h : headers.entrySet()) {
        String key = h.getKey();
        String value = h.getValue();
        int len = key.length() + value.length() + 3 + /* blank, equals and newline */
        2;
        String line = len + "" "" + key + ""="" + value + ""\n"";
        int actualLength = line.getBytes(CharsetNames.UTF_8).length;
        while (len != actualLength) {
            // Adjust for cases where length < 10 or > 100
            // or where UTF-8 encoding isn't a single octet
            // per character.
            // Must be in loop as size may go from 99 to 100 in
            // first pass so we'd need a second.
            len = actualLength;
            line = len + "" "" + key + ""="" + value + ""\n"";
            actualLength = line.getBytes(CharsetNames.UTF_8).length;
        }
        w.write(line);
    }
    byte[] data = w.toString().getBytes(CharsetNames.UTF_8);
    pex.setSize(data.length);
    putArchiveEntry(pex);
    write(data);
    closeArchiveEntry();
}","/**
 * Writes a PAX extended header with the given map as contents.
 * @since 1.4
 */
","void writePaxHeaders(String entryName, Map<String, String> headers) throws IOException {
    String name = ""./PaxHeaders.X/"" + stripTo7Bits(entryName);
        if (name.length() >= TarConstants.NAMELEN) {
        name = name.substring(0, TarConstants.NAMELEN - 1);
    }
    TarArchiveEntry pex = new TarArchiveEntry(name, TarConstants.LF_PAX_EXTENDED_HEADER_LC);
    StringWriter w = new StringWriter();
    for (Map.Entry<String, String> h : headers.entrySet()) {
        String key = h.getKey();
        String value = h.getValue();
        int len = key.length() + value.length() + 3 +         2;
        String line = len + "" "" + key + ""="" + value + ""\n"";
        int actualLength = line.getBytes(CharsetNames.UTF_8).length;
        while (len != actualLength) {
                                                                        len = actualLength;
            line = len + "" "" + key + ""="" + value + ""\n"";
            actualLength = line.getBytes(CharsetNames.UTF_8).length;
        }
        w.write(line);
    }
    byte[] data = w.toString().getBytes(CharsetNames.UTF_8);
    pex.setSize(data.length);
    putArchiveEntry(pex);
    write(data);
    closeArchiveEntry();
}",0.5909090909090909,0.07655502392344483,0.0,0.0,0.0,0.5615079365079365,-0.5148696264975333,0.9166666666666666,-0.02631578947368421,1.3550457288082844
Closure,163,1,"@Override
public void exitScope(NodeTraversal t) {
}",,"@Override
public void exitScope(NodeTraversal t) {
}",-0.5,-1.4306220095693782,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,1.1099365750528538,-0.5,2.3157894736842106,-0.16279340490885932
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-2899_31aea2ad,0,"@Override
public Path getFullPath(FileType fileType, String path) {
    if (path.contains("":""))
        return new Path(path);
    // normalize the path
    Path fullPath = new Path(defaultVolume.getBasePath(), fileType.getDirectory());
    if (path.startsWith(""/""))
        path = path.substring(1);
    fullPath = new Path(fullPath, path);
    FileSystem fs = getVolumeByPath(fullPath).getFileSystem();
    return fs.makeQualified(fullPath);
}",,"@Override
public Path getFullPath(FileType fileType, String path) {
    if (path.contains("":""))
        return new Path(path);
        Path fullPath = new Path(defaultVolume.getBasePath(), fileType.getDirectory());
    if (path.startsWith(""/""))
        path = path.substring(1);
    fullPath = new Path(fullPath, path);
    FileSystem fs = getVolumeByPath(fullPath).getFileSystem();
    return fs.makeQualified(fullPath);
}",-0.13636363636363635,-0.15311004784689008,-0.2,-1.0,-0.08333333333333333,-0.3650793650793651,0.08865398167723736,0.16666666666666666,0.0,-0.16279340490885932
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-782_45b110e1,1,"@Nonnull
private MutableNodeState write(long newRevision, boolean reconnect) {
    // make sure that all revision numbers up to the root gets updated
    if (!isRoot()) {
        parent.write(newRevision, reconnect);
        checkState(reconnect || exists(), ""This node has been removed"");
    }
    if (writeState == null || revision != root.revision) {
        // root never gets here since revision == root.revision
        assert (!isRoot());
        // The builder could have been reset, need to re-get base state
        baseState = parent.getBaseState(name);
        writeState = parent.getWriteState(name);
        if (writeState == null) {
            if (exists()) {
                writeState = new MutableNodeState(baseState);
            } else {
                writeState = new MutableNodeState(null);
            }
            // guaranteed by called parent.write()
            assert parent.writeState != null;
            parent.writeState.nodes.put(name, writeState);
        }
    }
    revision = newRevision;
    assert classInvariants();
    assert writeState != null;
    return writeState;
}",,"@Nonnull
private MutableNodeState write(long newRevision, boolean reconnect) {
        if (!isRoot()) {
        parent.write(newRevision, reconnect);
        checkState(reconnect || exists(), ""This node has been removed"");
    }
    if (writeState == null || revision != root.revision) {
                assert (!isRoot());
                baseState = parent.getBaseState(name);
        writeState = parent.getWriteState(name);
        if (writeState == null) {
            if (exists()) {
                writeState = new MutableNodeState(baseState);
            } else {
                writeState = new MutableNodeState(null);
            }
                        assert parent.writeState != null;
            parent.writeState.nodes.put(name, writeState);
        }
    }
    revision = newRevision;
    assert classInvariants();
    assert writeState != null;
    return writeState;
}",0.5,0.736842105263158,0.2,0.5,0.4166666666666667,-0.3650793650793651,0.07343199436222701,0.3333333333333333,-0.02631578947368421,-0.16279340490885932
Csv,14,3,"/*
     * Note: must only be called if quoting is enabled, otherwise will generate NPE
     */
// the original object is needed so can check for Number
private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException {
    boolean quote = false;
    int start = offset;
    int pos = offset;
    final int end = offset + len;
    final char delimChar = getDelimiter();
    final char quoteChar = getQuoteCharacter().charValue();
    QuoteMode quoteModePolicy = getQuoteMode();
    if (quoteModePolicy == null) {
        quoteModePolicy = QuoteMode.MINIMAL;
    }
    switch(quoteModePolicy) {
        case ALL:
            quote = true;
            break;
        case NON_NUMERIC:
            quote = !(object instanceof Number);
            break;
        case NONE:
            // Use the existing escaping code
            printAndEscape(value, offset, len, out);
            return;
        case MINIMAL:
            if (len <= 0) {
                // an empty line has no tokens.
                if (newRecord) {
                    quote = true;
                }
            } else {
                char c = value.charAt(pos);
                // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E
                if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {
                    quote = true;
                } else if (c <= COMMENT) {
                    // Some other chars at the start of a value caused the parser to fail, so for now
                    // encapsulate if we start in anything less than '#'. We are being conservative
                    // by including the default comment char too.
                    quote = true;
                } else {
                    while (pos < end) {
                        c = value.charAt(pos);
                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {
                            quote = true;
                            break;
                        }
                        pos++;
                    }
                    if (!quote) {
                        pos = end - 1;
                        c = value.charAt(pos);
                        // encapsulate if we end in anything less than ' '
                        if (c <= SP) {
                            quote = true;
                        }
                    }
                }
            }
            if (!quote) {
                // no encapsulation needed - write out the original value
                out.append(value, start, end);
                return;
            }
            break;
        default:
            throw new IllegalStateException(""Unexpected Quote value: "" + quoteModePolicy);
    }
    if (!quote) {
        // no encapsulation needed - write out the original value
        out.append(value, start, end);
        return;
    }
    // we hit something that needed encapsulation
    out.append(quoteChar);
    // the need for encapsulation.
    while (pos < end) {
        final char c = value.charAt(pos);
        if (c == quoteChar) {
            // write out the chunk up until this point
            // add 1 to the length to write out the encapsulator also
            out.append(value, start, pos + 1);
            // put the next starting position on the encapsulator so we will
            // write it out again with the next string (effectively doubling it)
            start = pos;
        }
        pos++;
    }
    // write the last segment
    out.append(value, start, pos);
    out.append(quoteChar);
}",,"private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException {
    boolean quote = false;
    int start = offset;
    int pos = offset;
    final int end = offset + len;
    final char delimChar = getDelimiter();
    final char quoteChar = getQuoteCharacter().charValue();
    QuoteMode quoteModePolicy = getQuoteMode();
    if (quoteModePolicy == null) {
        quoteModePolicy = QuoteMode.MINIMAL;
    }
    switch(quoteModePolicy) {
        case ALL:
            quote = true;
            break;
        case NON_NUMERIC:
            quote = !(object instanceof Number);
            break;
        case NONE:
                        printAndEscape(value, offset, len, out);
            return;
        case MINIMAL:
            if (len <= 0) {
                                if (newRecord) {
                    quote = true;
                }
            } else {
                char c = value.charAt(pos);
                                if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {
                    quote = true;
                } else if (c <= COMMENT) {
                                                                                quote = true;
                } else {
                    while (pos < end) {
                        c = value.charAt(pos);
                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {
                            quote = true;
                            break;
                        }
                        pos++;
                    }
                    if (!quote) {
                        pos = end - 1;
                        c = value.charAt(pos);
                                                if (c <= SP) {
                            quote = true;
                        }
                    }
                }
            }
            if (!quote) {
                                out.append(value, start, end);
                return;
            }
            break;
        default:
            throw new IllegalStateException(""Unexpected Quote value: "" + quoteModePolicy);
    }
    if (!quote) {
                out.append(value, start, end);
        return;
    }
        out.append(quoteChar);
        while (pos < end) {
        final char c = value.charAt(pos);
        if (c == quoteChar) {
                                    out.append(value, start, pos + 1);
                                    start = pos;
        }
        pos++;
    }
        out.append(value, start, pos);
    out.append(quoteChar);
}",2.727272727272727,2.148325358851675,4.0,2.5,2.5,2.6507936507936507,-1.1849189570119798,0.75,-0.02631578947368421,8.366621139560749
wicket,remotes/origin/bugs-dot-jar_WICKET-3838_97514205,1,"/**
 *  @see org.apache.wicket.request.mapper.AbstractBookmarkableMapper#buildUrl(org.apache.wicket.request.mapper.AbstractBookmarkableMapper.UrlInfo)
 */
@Override
protected Url buildUrl(UrlInfo info) {
    Class<? extends IRequestablePage> pageClass = info.getPageClass();
    if (PackageName.forClass(pageClass).equals(packageName)) {
        Url url = new Url();
        url.getSegments().add(pageClass.getSimpleName());
        encodePageComponentInfo(url, info.getPageComponentInfo());
        return encodePageParameters(url, info.getPageParameters(), pageParametersEncoder);
    }
    return null;
}","/**
 *  @see org.apache.wicket.request.mapper.AbstractBookmarkableMapper#buildUrl(org.apache.wicket.request.mapper.AbstractBookmarkableMapper.UrlInfo)
 */
","@Override
protected Url buildUrl(UrlInfo info) {
    Class<? extends IRequestablePage> pageClass = info.getPageClass();
    if (PackageName.forClass(pageClass).equals(packageName)) {
        Url url = new Url();
        url.getSegments().add(pageClass.getSimpleName());
        encodePageComponentInfo(url, info.getPageComponentInfo());
        return encodePageParameters(url, info.getPageParameters(), pageParametersEncoder);
    }
    return null;
}",-0.13636363636363635,0.08612440191387546,-0.4,-0.5,-0.16666666666666666,-0.3650793650793651,0.11909795630725845,0.3333333333333333,-0.02631578947368421,-0.16279340490885932
flink,remotes/origin/bugs-dot-jar_FLINK-2713_63d9800e,1,"@Override
public void update(S state) throws IOException {
    if (currentInput == null) {
        throw new IllegalStateException(""Need a valid input for updating a state."");
    } else {
        Serializable key;
        try {
            key = keySelector.getKey(currentInput);
        } catch (Exception e) {
            throw new RuntimeException(""User-defined key selector threw an exception."");
        }
        if (state == null) {
            // Remove state if set to null
            stateStore.removeStateForKey(key);
        } else {
            stateStore.setStateForKey(key, state);
        }
    }
}",,"@Override
public void update(S state) throws IOException {
    if (currentInput == null) {
        throw new IllegalStateException(""Need a valid input for updating a state."");
    } else {
        Serializable key;
        try {
            key = keySelector.getKey(currentInput);
        } catch (Exception e) {
            throw new RuntimeException(""User-defined key selector threw an exception."");
        }
        if (state == null) {
                        stateStore.removeStateForKey(key);
        } else {
            stateStore.setStateForKey(key, state);
        }
    }
}",0.18181818181818182,0.4641148325358851,0.4,0.0,-0.08333333333333333,-0.0912698412698413,-0.11035940803382639,-0.25,0.07894736842105263,-0.07063271151374745
maven,remotes/origin/bugs-dot-jar_MNG-1856_faa5cf27,3,"private void assembleModelInheritance(Model child, Model parent, String childPathAdjustment, boolean appendPaths) {
    // cannot inherit from null parent.
    if (parent == null) {
        return;
    }
    // Group id
    if (child.getGroupId() == null) {
        child.setGroupId(parent.getGroupId());
    }
    // version
    if (child.getVersion() == null) {
        if (child.getParent() != null) {
            child.setVersion(child.getParent().getVersion());
        }
    }
    // inceptionYear
    if (child.getInceptionYear() == null) {
        child.setInceptionYear(parent.getInceptionYear());
    }
    // url
    if (child.getUrl() == null) {
        if (parent.getUrl() != null) {
            child.setUrl(appendPath(parent.getUrl(), child.getArtifactId(), childPathAdjustment, appendPaths));
        } else {
            child.setUrl(parent.getUrl());
        }
    }
    // ----------------------------------------------------------------------
    // Distribution
    // ----------------------------------------------------------------------
    assembleDistributionInheritence(child, parent, childPathAdjustment, appendPaths);
    // issueManagement
    if (child.getIssueManagement() == null) {
        child.setIssueManagement(parent.getIssueManagement());
    }
    // description
    if (child.getDescription() == null) {
        child.setDescription(parent.getDescription());
    }
    // Organization
    if (child.getOrganization() == null) {
        child.setOrganization(parent.getOrganization());
    }
    // Scm
    assembleScmInheritance(child, parent, childPathAdjustment, appendPaths);
    // ciManagement
    if (child.getCiManagement() == null) {
        child.setCiManagement(parent.getCiManagement());
    }
    // developers
    if (child.getDevelopers().size() == 0) {
        child.setDevelopers(parent.getDevelopers());
    }
    // licenses
    if (child.getLicenses().size() == 0) {
        child.setLicenses(parent.getLicenses());
    }
    // developers
    if (child.getContributors().size() == 0) {
        child.setContributors(parent.getContributors());
    }
    // mailingLists
    if (child.getMailingLists().size() == 0) {
        child.setMailingLists(parent.getMailingLists());
    }
    // Build
    assembleBuildInheritance(child, parent);
    assembleDependencyInheritance(child, parent);
    child.setRepositories(ModelUtils.mergeRepositoryLists(child.getRepositories(), parent.getRepositories()));
    child.setPluginRepositories(ModelUtils.mergeRepositoryLists(child.getPluginRepositories(), parent.getPluginRepositories()));
    assembleReportingInheritance(child, parent);
    assembleDependencyManagementInheritance(child, parent);
    assembleDistributionManagementInheritance(child, parent);
    Properties props = new Properties();
    props.putAll(parent.getProperties());
    props.putAll(child.getProperties());
    child.setProperties(props);
}",,"private void assembleModelInheritance(Model child, Model parent, String childPathAdjustment, boolean appendPaths) {
        if (parent == null) {
        return;
    }
        if (child.getGroupId() == null) {
        child.setGroupId(parent.getGroupId());
    }
        if (child.getVersion() == null) {
        if (child.getParent() != null) {
            child.setVersion(child.getParent().getVersion());
        }
    }
        if (child.getInceptionYear() == null) {
        child.setInceptionYear(parent.getInceptionYear());
    }
        if (child.getUrl() == null) {
        if (parent.getUrl() != null) {
            child.setUrl(appendPath(parent.getUrl(), child.getArtifactId(), childPathAdjustment, appendPaths));
        } else {
            child.setUrl(parent.getUrl());
        }
    }
                assembleDistributionInheritence(child, parent, childPathAdjustment, appendPaths);
        if (child.getIssueManagement() == null) {
        child.setIssueManagement(parent.getIssueManagement());
    }
        if (child.getDescription() == null) {
        child.setDescription(parent.getDescription());
    }
        if (child.getOrganization() == null) {
        child.setOrganization(parent.getOrganization());
    }
        assembleScmInheritance(child, parent, childPathAdjustment, appendPaths);
        if (child.getCiManagement() == null) {
        child.setCiManagement(parent.getCiManagement());
    }
        if (child.getDevelopers().size() == 0) {
        child.setDevelopers(parent.getDevelopers());
    }
        if (child.getLicenses().size() == 0) {
        child.setLicenses(parent.getLicenses());
    }
        if (child.getContributors().size() == 0) {
        child.setContributors(parent.getContributors());
    }
        if (child.getMailingLists().size() == 0) {
        child.setMailingLists(parent.getMailingLists());
    }
        assembleBuildInheritance(child, parent);
    assembleDependencyInheritance(child, parent);
    child.setRepositories(ModelUtils.mergeRepositoryLists(child.getRepositories(), parent.getRepositories()));
    child.setPluginRepositories(ModelUtils.mergeRepositoryLists(child.getPluginRepositories(), parent.getPluginRepositories()));
    assembleReportingInheritance(child, parent);
    assembleDependencyManagementInheritance(child, parent);
    assembleDistributionManagementInheritance(child, parent);
    Properties props = new Properties();
    props.putAll(parent.getProperties());
    props.putAll(child.getProperties());
    child.setProperties(props);
}",2.090909090909091,-0.23923444976076558,2.4,0.0,2.0833333333333335,0.23809523809523808,-1.021705426356589,5.083333333333333,-0.02631578947368421,1.3685724658978924
camel,remotes/origin/bugs-dot-jar_CAMEL-3281_f7dd2fff,1,"/**
 * <a href=""http://camel.apache.org/exception-clause.html"">Exception clause</a>
 * for catching certain exceptions and handling them.
 *
 * @param exception exception to catch
 * @return the builder
 */
public OnExceptionDefinition onException(Class exception) {
    routeCollection.setCamelContext(getContext());
    return routeCollection.onException(exception);
}","/**
 * <a href=""http://camel.apache.org/exception-clause.html"">Exception clause</a>
 * for catching certain exceptions and handling them.
 *
 * @param exception exception to catch
 * @return the builder
 */
","public OnExceptionDefinition onException(Class exception) {
    routeCollection.setCamelContext(getContext());
    return routeCollection.onException(exception);
}",-0.45454545454545453,-0.47368421052631593,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.8255109231853415,-0.25,2.3947368421052633,-0.16279340490885932
Cli,26,3,"/**
 * Create an Option using the current settings and with
 * the specified Option <code>char</code>.
 *
 * @param opt the <code>java.lang.String</code> representation
 * of the Option
 * @return the Option instance
 * @throws IllegalArgumentException if <code>opt</code> is not
 * a valid character.  See Option.
 */
public static Option create(String opt) throws IllegalArgumentException {
    // create the option
    Option option = new Option(opt, description);
    // set the option properties
    option.setLongOpt(longopt);
    option.setRequired(required);
    option.setOptionalArg(optionalArg);
    option.setArgs(numberOfArgs);
    option.setType(type);
    option.setValueSeparator(valuesep);
    option.setArgName(argName);
    // reset the OptionBuilder properties
    OptionBuilder.reset();
    // return the Option instance
    return option;
}","/**
 * Create an Option using the current settings and with
 * the specified Option <code>char</code>.
 *
 * @param opt the <code>java.lang.String</code> representation
 * of the Option
 * @return the Option instance
 * @throws IllegalArgumentException if <code>opt</code> is not
 * a valid character.  See Option.
 */
","public static Option create(String opt) throws IllegalArgumentException {
        Option option = new Option(opt, description);
        option.setLongOpt(longopt);
    option.setRequired(required);
    option.setOptionalArg(optionalArg);
    option.setArgs(numberOfArgs);
    option.setType(type);
    option.setValueSeparator(valuesep);
    option.setArgName(argName);
        OptionBuilder.reset();
        return option;
}",-0.09090909090909091,-0.7177033492822968,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.08611698379140256,0.16666666666666666,0.02631578947368421,-0.16279340490885932
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1822_016df669,1,"/**
 * Add a new or update an existing map entry.
 * The property is a map of revisions / values.
 *
 * @param property the property
 * @param revision the revision
 * @param value the value
 */
void setMapEntry(@Nonnull String property, @Nonnull Revision revision, Object value) {
    Operation op = new Operation();
    op.type = Operation.Type.SET_MAP_ENTRY;
    op.value = value;
    changes.put(new Key(property, checkNotNull(revision)), op);
}","/**
 * Add a new or update an existing map entry.
 * The property is a map of revisions / values.
 *
 * @param property the property
 * @param revision the revision
 * @param value the value
 */
","void setMapEntry(@Nonnull String property, @Nonnull Revision revision, Object value) {
    Operation op = new Operation();
    op.type = Operation.Type.SET_MAP_ENTRY;
    op.value = value;
    changes.put(new Key(property, checkNotNull(revision)), op);
}",-0.36363636363636365,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.437632135306554,-0.3333333333333333,1.9736842105263157,-0.16279340490885932
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2389_0fa892b3,1,"/**
 * Escape a string into the target buffer.
 *
 * @param s      the string to escape
 * @param length the number of characters.
 * @param buff   the target buffer
 */
private static void escape(String s, int length, StringBuilder buff) {
    for (int i = 0; i < length; i++) {
        char c = s.charAt(i);
        int ic = (int) c;
        switch(c) {
            case '""':
                // quotation mark
                buff.append(""\\\"""");
                break;
            case '\\':
                // backslash
                buff.append(""\\\\"");
                break;
            case '\b':
                // backspace
                buff.append(""\\b"");
                break;
            case '\f':
                // formfeed
                buff.append(""\\f"");
                break;
            case '\n':
                // newline
                buff.append(""\\n"");
                break;
            case '\r':
                // carriage return
                buff.append(""\\r"");
                break;
            case '\t':
                // horizontal tab
                buff.append(""\\t"");
                break;
            default:
                if (c < ' ') {
                    buff.append(String.format(""\\u%04x"", ic));
                } else if (ic >= 0xD800 && ic <= 0xDBFF) {
                    // isSurrogate(), only available in Java 7
                    if (i < length - 1 && Character.isSurrogatePair(c, s.charAt(i + 1))) {
                        // ok surrogate
                        buff.append(c);
                        buff.append(s.charAt(i + 1));
                        i += 1;
                    } else {
                        // broken surrogate -> escape
                        buff.append(String.format(""\\u%04x"", ic));
                    }
                } else {
                    buff.append(c);
                }
        }
    }
}","/**
 * Escape a string into the target buffer.
 *
 * @param s      the string to escape
 * @param length the number of characters.
 * @param buff   the target buffer
 */
","private static void escape(String s, int length, StringBuilder buff) {
    for (int i = 0; i < length; i++) {
        char c = s.charAt(i);
        int ic = (int) c;
        switch(c) {
            case '""':
                                buff.append(""\\\"""");
                break;
            case '\\':
                                buff.append(""\\\\"");
                break;
            case '\b':
                                buff.append(""\\b"");
                break;
            case '\f':
                                buff.append(""\\f"");
                break;
            case '\n':
                                buff.append(""\\n"");
                break;
            case '\r':
                                buff.append(""\\r"");
                break;
            case '\t':
                                buff.append(""\\t"");
                break;
            default:
                if (c < ' ') {
                    buff.append(String.format(""\\u%04x"", ic));
                } else if (ic >= 0xD800 && ic <= 0xDBFF) {
                                        if (i < length - 1 && Character.isSurrogatePair(c, s.charAt(i + 1))) {
                                                buff.append(c);
                        buff.append(s.charAt(i + 1));
                        i += 1;
                    } else {
                                                buff.append(String.format(""\\u%04x"", ic));
                    }
                } else {
                    buff.append(c);
                }
        }
    }
}",1.3181818181818181,1.3110047846889954,3.2,2.0,1.1666666666666667,1.6527777777777777,-0.7992952783650458,1.0,-0.02631578947368421,2.499742397261458
Closure,113,2,"/**
 * Handles a goog.require call.
 */
private void processRequireCall(NodeTraversal t, Node n, Node parent) {
    Node left = n.getFirstChild();
    Node arg = left.getNext();
    if (verifyLastArgumentIsString(t, left, arg)) {
        String ns = arg.getString();
        ProvidedName provided = providedNames.get(ns);
        if (provided == null || !provided.isExplicitlyProvided()) {
            unrecognizedRequires.add(new UnrecognizedRequire(n, ns, t.getSourceName()));
        } else {
            JSModule providedModule = provided.explicitModule;
            // This must be non-null, because there was an explicit provide.
            Preconditions.checkNotNull(providedModule);
            JSModule module = t.getModule();
            if (moduleGraph != null && module != providedModule && !moduleGraph.dependsOn(module, providedModule)) {
                compiler.report(t.makeError(n, XMODULE_REQUIRE_ERROR, ns, providedModule.getName(), module.getName()));
            }
        }
        maybeAddToSymbolTable(left);
        maybeAddStringNodeToSymbolTable(arg);
        // let them be caught in the subsequent run.
        if (provided != null) {
            parent.detachFromParent();
            compiler.reportCodeChange();
        }
    }
}","/**
 * Handles a goog.require call.
 */
","private void processRequireCall(NodeTraversal t, Node n, Node parent) {
    Node left = n.getFirstChild();
    Node arg = left.getNext();
    if (verifyLastArgumentIsString(t, left, arg)) {
        String ns = arg.getString();
        ProvidedName provided = providedNames.get(ns);
        if (provided == null || !provided.isExplicitlyProvided()) {
            unrecognizedRequires.add(new UnrecognizedRequire(n, ns, t.getSourceName()));
        } else {
            JSModule providedModule = provided.explicitModule;
                        Preconditions.checkNotNull(providedModule);
            JSModule module = t.getModule();
            if (moduleGraph != null && module != providedModule && !moduleGraph.dependsOn(module, providedModule)) {
                compiler.report(t.makeError(n, XMODULE_REQUIRE_ERROR, ns, providedModule.getName(), module.getName()));
            }
        }
        maybeAddToSymbolTable(left);
        maybeAddStringNodeToSymbolTable(arg);
                if (provided != null) {
            parent.detachFromParent();
            compiler.reportCodeChange();
        }
    }
}",0.45454545454545453,0.47846889952153115,0.2,0.5,1.0,0.7420634920634921,-0.42663847780126857,1.0833333333333333,-0.02631578947368421,1.2097508687609133
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-738_8ed779dc,1,"@Override
@Nonnull
public Node addNode(final String relPath, final String primaryNodeTypeName) throws RepositoryException {
    return perform(new ItemWriteOperation<Node>() {

        @Override
        protected void checkPreconditions() throws RepositoryException {
            super.checkPreconditions();
            SessionImpl.checkIndexOnName(sessionContext, relPath);
        }

        @Override
        public Node perform() throws RepositoryException {
            String oakPath = sessionContext.getOakPathOrThrowNotFound(relPath);
            String oakName = PathUtils.getName(oakPath);
            String parentPath = PathUtils.getParentPath(oakPath);
            NodeDelegate parent = dlg.getChild(parentPath);
            if (parent == null) {
                // is it a property?
                String grandParentPath = PathUtils.getParentPath(parentPath);
                NodeDelegate grandParent = dlg.getChild(grandParentPath);
                if (grandParent != null) {
                    String propName = PathUtils.getName(parentPath);
                    if (grandParent.getPropertyOrNull(propName) != null) {
                        throw new ConstraintViolationException(""Can't add new node to property."");
                    }
                }
                throw new PathNotFoundException(relPath);
            }
            if (parent.getChild(oakName) != null) {
                throw new ItemExistsException(relPath);
            }
            String ntName = primaryNodeTypeName;
            if (ntName == null) {
                DefinitionProvider dp = getDefinitionProvider();
                String childName = getOakName(PathUtils.getName(relPath));
                NodeDefinition def = dp.getDefinition(parent.getTree(), childName);
                ntName = def.getDefaultPrimaryTypeName();
                if (ntName == null) {
                    throw new ConstraintViolationException(""no matching child node definition found for "" + relPath);
                }
            }
            // TODO: figure out the right place for this check
            // throws on not found
            NodeType nt = getNodeTypeManager().getNodeType(ntName);
            if (nt.isAbstract() || nt.isMixin()) {
                throw new ConstraintViolationException();
            }
            // TODO: END
            NodeDelegate added = parent.addChild(oakName);
            if (added == null) {
                throw new ItemExistsException();
            }
            if (getPrimaryNodeType().hasOrderableChildNodes()) {
                dlg.setOrderableChildren(true);
            }
            NodeImpl<?> childNode = new NodeImpl<NodeDelegate>(added, sessionContext);
            childNode.internalSetPrimaryType(ntName);
            childNode.autoCreateItems();
            return childNode;
        }
    });
}",,"@Override
@Nonnull
public Node addNode(final String relPath, final String primaryNodeTypeName) throws RepositoryException {
    return perform(new ItemWriteOperation<Node>() {

        @Override
        protected void checkPreconditions() throws RepositoryException {
            super.checkPreconditions();
            SessionImpl.checkIndexOnName(sessionContext, relPath);
        }

        @Override
        public Node perform() throws RepositoryException {
            String oakPath = sessionContext.getOakPathOrThrowNotFound(relPath);
            String oakName = PathUtils.getName(oakPath);
            String parentPath = PathUtils.getParentPath(oakPath);
            NodeDelegate parent = dlg.getChild(parentPath);
            if (parent == null) {
                                String grandParentPath = PathUtils.getParentPath(parentPath);
                NodeDelegate grandParent = dlg.getChild(grandParentPath);
                if (grandParent != null) {
                    String propName = PathUtils.getName(parentPath);
                    if (grandParent.getPropertyOrNull(propName) != null) {
                        throw new ConstraintViolationException(""Can't add new node to property."");
                    }
                }
                throw new PathNotFoundException(relPath);
            }
            if (parent.getChild(oakName) != null) {
                throw new ItemExistsException(relPath);
            }
            String ntName = primaryNodeTypeName;
            if (ntName == null) {
                DefinitionProvider dp = getDefinitionProvider();
                String childName = getOakName(PathUtils.getName(relPath));
                NodeDefinition def = dp.getDefinition(parent.getTree(), childName);
                ntName = def.getDefaultPrimaryTypeName();
                if (ntName == null) {
                    throw new ConstraintViolationException(""no matching child node definition found for "" + relPath);
                }
            }
                                    NodeType nt = getNodeTypeManager().getNodeType(ntName);
            if (nt.isAbstract() || nt.isMixin()) {
                throw new ConstraintViolationException();
            }
                        NodeDelegate added = parent.addChild(oakName);
            if (added == null) {
                throw new ItemExistsException();
            }
            if (getPrimaryNodeType().hasOrderableChildNodes()) {
                dlg.setOrderableChildren(true);
            }
            NodeImpl<?> childNode = new NodeImpl<NodeDelegate>(added, sessionContext);
            childNode.internalSetPrimaryType(ntName);
            childNode.autoCreateItems();
            return childNode;
        }
    });
}",1.9545454545454546,0.9712918660287079,2.4,1.0,1.3333333333333333,0.5297619047619048,-0.9864693446088794,1.8333333333333333,-0.02631578947368421,1.9373777539576886
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-276_1bf5c550,1,"@Override
public boolean markCommit(Id id) throws Exception {
    return touch(id, gcStart);
}",,"@Override
public boolean markCommit(Id id) throws Exception {
    return touch(id, gcStart);
}",-0.45454545454545453,-0.6028708133971293,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.8548273431994357,-0.4166666666666667,1.8157894736842104,-0.16279340490885932
wicket,remotes/origin/bugs-dot-jar_WICKET-5265_0eb596df,1,"@Override
protected List<FeedbackMessage> collectMessages(Component panel, IFeedbackMessageFilter filter) {
    if (fence == null) {
        return new FeedbackCollector(panel.getPage()) {

            @Override
            protected boolean shouldRecurseInto(Component component) {
                return component.getMetaData(FENCE_KEY) == null;
            }
        }.collect(filter);
    } else {
        return new FeedbackCollector(fence) {

            @Override
            protected boolean shouldRecurseInto(Component component) {
                return component.getMetaData(FENCE_KEY) == null;
            }
        }.setIncludeSession(false).collect(filter);
    }
}",,"@Override
protected List<FeedbackMessage> collectMessages(Component panel, IFeedbackMessageFilter filter) {
    if (fence == null) {
        return new FeedbackCollector(panel.getPage()) {

            @Override
            protected boolean shouldRecurseInto(Component component) {
                return component.getMetaData(FENCE_KEY) == null;
            }
        }.collect(filter);
    } else {
        return new FeedbackCollector(fence) {

            @Override
            protected boolean shouldRecurseInto(Component component) {
                return component.getMetaData(FENCE_KEY) == null;
            }
        }.setIncludeSession(false).collect(filter);
    }
}",0.18181818181818182,0.9952153110047848,-0.4,0.0,-0.25,-0.3650793650793651,-0.11656095842142365,0.0,0.13157894736842105,-0.16279340490885932
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-579_7d72e6ed,3,public abstract void restrict(FilterImpl f);,,public abstract void restrict(FilterImpl f);,-0.5909090909090909,-1.4306220095693782,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,1.6663847780126848,-0.5,2.552631578947368,-0.16279340490885932
wicket,remotes/origin/bugs-dot-jar_WICKET-5582_1fb66533,1,"@Override
public String encodeRedirectURL(CharSequence url) {
    Args.notNull(url, ""url"");
    /*
		  WICKET-4854 - always pass absolute url to the web container for encoding
		  because when REDIRECT_TO_BUFFER is in use Wicket may render PageB when
		  PageA is actually the requested one and the web container cannot resolve
		  the base url properly
		 */
    UrlRenderer urlRenderer = new UrlRenderer(webRequest);
    Url relativeUrl = Url.parse(url);
    String fullUrl = urlRenderer.renderFullUrl(relativeUrl);
    String encodedFullUrl = httpServletResponse.encodeRedirectURL(fullUrl);
    final String encodedRelativeUrl;
    if (fullUrl.equals(encodedFullUrl)) {
        // no encoding happened so just reuse the relative url
        encodedRelativeUrl = url.toString();
    } else {
        // get the relative url with the jsessionid encoded in it
        Url _encoded = Url.parse(encodedFullUrl);
        encodedRelativeUrl = urlRenderer.renderRelativeUrl(_encoded);
    }
    return encodedRelativeUrl;
}",,"@Override
public String encodeRedirectURL(CharSequence url) {
    Args.notNull(url, ""url"");
        UrlRenderer urlRenderer = new UrlRenderer(webRequest);
    Url relativeUrl = Url.parse(url);
    String fullUrl = urlRenderer.renderFullUrl(relativeUrl);
    String encodedFullUrl = httpServletResponse.encodeRedirectURL(fullUrl);
    final String encodedRelativeUrl;
    if (fullUrl.equals(encodedFullUrl)) {
                encodedRelativeUrl = url.toString();
    } else {
                Url _encoded = Url.parse(encodedFullUrl);
        encodedRelativeUrl = urlRenderer.renderRelativeUrl(_encoded);
    }
    return encodedRelativeUrl;
}",0.09090909090909091,-0.2583732057416268,-0.4,-0.5,-0.16666666666666666,-0.3650793650793651,-0.10951374207188172,0.16666666666666666,-0.02631578947368421,-0.16279340490885932
wicket,remotes/origin/bugs-dot-jar_WICKET-4488_e6582c52,1,"/**
 *  Looks up a page by id from the {@link IPageStore}. <br/>
 *  If {@linkplain #pageClass} is specified then compares it against the stored instance class
 *  and returns the found instance only if they match.
 *
 *  @param pageId
 *             the id of the page to look for.
 *  @return the found page instance by id.
 */
private IRequestablePage getStoredPage(final int pageId) {
    IRequestablePage storedPageInstance = getPageSource().getPageInstance(pageId);
    if (storedPageInstance != null && (pageClass == null || pageClass.equals(storedPageInstance.getClass()))) {
        pageInstance = storedPageInstance;
        pageInstanceIsFresh = false;
        if (pageInstance != null) {
            if (renderCount != null && pageInstance.getRenderCount() != renderCount) {
                throw new StalePageException(pageInstance);
            }
        }
    }
    return storedPageInstance;
}","/**
 *  Looks up a page by id from the {@link IPageStore}. <br/>
 *  If {@linkplain #pageClass} is specified then compares it against the stored instance class
 *  and returns the found instance only if they match.
 *
 *  @param pageId
 *             the id of the page to look for.
 *  @return the found page instance by id.
 */
","private IRequestablePage getStoredPage(final int pageId) {
    IRequestablePage storedPageInstance = getPageSource().getPageInstance(pageId);
    if (storedPageInstance != null && (pageClass == null || pageClass.equals(storedPageInstance.getClass()))) {
        pageInstance = storedPageInstance;
        pageInstanceIsFresh = false;
        if (pageInstance != null) {
            if (renderCount != null && pageInstance.getRenderCount() != renderCount) {
                throw new StalePageException(pageInstance);
            }
        }
    }
    return storedPageInstance;
}",-0.045454545454545456,0.7416267942583732,0.2,0.5,0.6666666666666666,0.3591269841269841,0.0069062720225512185,-0.08333333333333333,0.631578947368421,0.15212968885969005
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-3475_7651b777,1,"public int start() throws IOException {
    if (configError)
        return 1;
    String input;
    if (isVerbose())
        printInfo();
    String home = System.getProperty(""HOME"");
    if (home == null)
        home = System.getenv(""HOME"");
    String configDir = home + ""/.accumulo"";
    String historyPath = configDir + ""/shell_history.txt"";
    File accumuloDir = new File(configDir);
    if (!accumuloDir.exists() && !accumuloDir.mkdirs())
        log.warn(""Unable to make directory for history at "" + accumuloDir);
    try {
        History history = new History();
        history.setHistoryFile(new File(historyPath));
        reader.setHistory(history);
    } catch (IOException e) {
        log.warn(""Unable to load history file at "" + historyPath);
    }
    ShellCompletor userCompletor = null;
    if (execFile != null) {
        java.util.Scanner scanner = new java.util.Scanner(new File(execFile), UTF_8.name());
        try {
            while (scanner.hasNextLine() && !hasExited()) {
                execCommand(scanner.nextLine(), true, isVerbose());
            }
        } finally {
            scanner.close();
        }
    } else if (execCommand != null) {
        for (String command : execCommand.split(""\n"")) {
            execCommand(command, true, isVerbose());
        }
        return exitCode;
    }
    while (true) {
        if (hasExited())
            return exitCode;
        // If tab completion is true we need to reset
        if (tabCompletion) {
            if (userCompletor != null)
                reader.removeCompletor(userCompletor);
            userCompletor = setupCompletion();
            reader.addCompletor(userCompletor);
        }
        reader.setDefaultPrompt(getDefaultPrompt());
        input = reader.readLine();
        if (input == null) {
            reader.printNewline();
            return exitCode;
        }
        // user canceled
        execCommand(input, disableAuthTimeout, false);
    }
}",,"public int start() throws IOException {
    if (configError)
        return 1;
    String input;
    if (isVerbose())
        printInfo();
    String home = System.getProperty(""HOME"");
    if (home == null)
        home = System.getenv(""HOME"");
    String configDir = home + ""/.accumulo"";
    String historyPath = configDir + ""/shell_history.txt"";
    File accumuloDir = new File(configDir);
    if (!accumuloDir.exists() && !accumuloDir.mkdirs())
        log.warn(""Unable to make directory for history at "" + accumuloDir);
    try {
        History history = new History();
        history.setHistoryFile(new File(historyPath));
        reader.setHistory(history);
    } catch (IOException e) {
        log.warn(""Unable to load history file at "" + historyPath);
    }
    ShellCompletor userCompletor = null;
    if (execFile != null) {
        java.util.Scanner scanner = new java.util.Scanner(new File(execFile), UTF_8.name());
        try {
            while (scanner.hasNextLine() && !hasExited()) {
                execCommand(scanner.nextLine(), true, isVerbose());
            }
        } finally {
            scanner.close();
        }
    } else if (execCommand != null) {
        for (String command : execCommand.split(""\n"")) {
            execCommand(command, true, isVerbose());
        }
        return exitCode;
    }
    while (true) {
        if (hasExited())
            return exitCode;
                if (tabCompletion) {
            if (userCompletor != null)
                reader.removeCompletor(userCompletor);
            userCompletor = setupCompletion();
            reader.addCompletor(userCompletor);
        }
        reader.setDefaultPrompt(getDefaultPrompt());
        input = reader.readLine();
        if (input == null) {
            reader.printNewline();
            return exitCode;
        }
                execCommand(input, disableAuthTimeout, false);
    }
}",1.8636363636363635,0.25837320574162664,2.2,0.5,1.75,0.8154761904761906,-0.9458773784355176,1.9166666666666667,-0.02631578947368421,2.2925998282648408
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1822_016df669,1,"/**
 * Increment the value.
 *
 * @param property the key
 * @param value the increment
 */
public void increment(@Nonnull String property, long value) {
    Operation op = new Operation();
    op.type = Operation.Type.INCREMENT;
    op.value = value;
    changes.put(new Key(property, null), op);
}","/**
 * Increment the value.
 *
 * @param property the key
 * @param value the increment
 */
","public void increment(@Nonnull String property, long value) {
    Operation op = new Operation();
    op.type = Operation.Type.INCREMENT;
    op.value = value;
    changes.put(new Key(property, null), op);
}",-0.36363636363636365,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.47202255109231855,-0.4166666666666667,2.0526315789473686,-0.16279340490885932
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1178_84fb6b29,1,"@Override
public boolean isNew() {
    return !isRoot() && !parent.base().hasChildNode(name) && parent.hasChildNode(name);
}",,"@Override
public boolean isNew() {
    return !isRoot() && !parent.base().hasChildNode(name) && parent.hasChildNode(name);
}",-0.45454545454545453,-0.6028708133971293,-0.6,-1.0,-0.4166666666666667,-0.0912698412698413,0.775334742776603,-0.16666666666666666,1.2105263157894737,-0.13331028163413494
commons-math,remotes/origin/bugs-dot-jar_MATH-757_76b7413d,1,"/**
 * Discards the <code>i</code> last elements of the array.  For example,
 * if the array contains the elements 1,2,3,4, invoking
 * <code>discardMostRecentElements(2)</code> will cause the last two elements
 * to be discarded, leaving 1,2 in the array.  Throws illegalArgumentException
 * if i exceeds numElements.
 *
 * @param i  the number of elements to discard from the end of the array
 * @throws MathIllegalArgumentException if i is greater than numElements.
 * @since 2.0
 */
public synchronized void discardMostRecentElements(int i) throws MathIllegalArgumentException {
    discardExtremeElements(i, false);
}","/**
 * Discards the <code>i</code> last elements of the array.  For example,
 * if the array contains the elements 1,2,3,4, invoking
 * <code>discardMostRecentElements(2)</code> will cause the last two elements
 * to be discarded, leaving 1,2 in the array.  Throws illegalArgumentException
 * if i exceeds numElements.
 *
 * @param i  the number of elements to discard from the end of the array
 * @throws MathIllegalArgumentException if i is greater than numElements.
 * @since 2.0
 */
","public synchronized void discardMostRecentElements(int i) throws MathIllegalArgumentException {
    discardExtremeElements(i, false);
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,1.0451021846370678,-0.4166666666666667,0.02631578947368421,-0.16279340490885932
Math,74,1,"/**
 * {@inheritDoc}
 */
@Override
public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException {
    sanityChecks(equations, t0, y0, t, y);
    setEquations(equations);
    resetEvaluations();
    final boolean forward = t > t0;
    // create some internal working arrays
    final int stages = c.length + 1;
    if (y != y0) {
        System.arraycopy(y0, 0, y, 0, y0.length);
    }
    final double[][] yDotK = new double[stages][y0.length];
    final double[] yTmp = new double[y0.length];
    // set up an interpolator sharing the integrator arrays
    AbstractStepInterpolator interpolator;
    if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {
        final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();
        rki.reinitialize(this, yTmp, yDotK, forward);
        interpolator = rki;
    } else {
        interpolator = new DummyStepInterpolator(yTmp, forward);
    }
    interpolator.storeTime(t0);
    // set up integration control objects
    stepStart = t0;
    double hNew = 0;
    boolean firstTime = true;
    for (StepHandler handler : stepHandlers) {
        handler.reset();
    }
    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);
    boolean lastStep = false;
    // main integration loop
    while (!lastStep) {
        interpolator.shift();
        double error = 0;
        for (boolean loop = true; loop; ) {
            if (firstTime || !fsal) {
                // first stage
                computeDerivatives(stepStart, y, yDotK[0]);
            }
            if (firstTime) {
                final double[] scale;
                if (vecAbsoluteTolerance == null) {
                    scale = new double[y0.length];
                    java.util.Arrays.fill(scale, scalAbsoluteTolerance);
                } else {
                    scale = vecAbsoluteTolerance;
                }
                hNew = initializeStep(equations, forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]);
                firstTime = false;
            }
            stepSize = hNew;
            // next stages
            for (int k = 1; k < stages; ++k) {
                for (int j = 0; j < y0.length; ++j) {
                    double sum = a[k - 1][0] * yDotK[0][j];
                    for (int l = 1; l < k; ++l) {
                        sum += a[k - 1][l] * yDotK[l][j];
                    }
                    yTmp[j] = y[j] + stepSize * sum;
                }
                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);
            }
            // estimate the state at the end of the step
            for (int j = 0; j < y0.length; ++j) {
                double sum = b[0] * yDotK[0][j];
                for (int l = 1; l < stages; ++l) {
                    sum += b[l] * yDotK[l][j];
                }
                yTmp[j] = y[j] + stepSize * sum;
            }
            // estimate the error at the end of the step
            error = estimateError(yDotK, y, yTmp, stepSize);
            if (error <= 1.0) {
                // discrete events handling
                interpolator.storeTime(stepStart + stepSize);
                if (manager.evaluateStep(interpolator)) {
                    final double dt = manager.getEventTime() - stepStart;
                    if (Math.abs(dt) <= Math.ulp(stepStart)) {
                        // rejecting the step would lead to a too small next step, we accept it
                        loop = false;
                    } else {
                        // reject the step to match exactly the next switch time
                        hNew = dt;
                    }
                } else {
                    // accept the step
                    loop = false;
                }
            } else {
                // reject the step and attempt to reduce error by stepsize control
                final double factor = Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(error, exp)));
                hNew = filterStep(stepSize * factor, forward, false);
            }
        }
        // the step has been accepted
        final double nextStep = stepStart + stepSize;
        System.arraycopy(yTmp, 0, y, 0, y0.length);
        manager.stepAccepted(nextStep, y);
        lastStep = manager.stop();
        // provide the step data to the step handler
        interpolator.storeTime(nextStep);
        for (StepHandler handler : stepHandlers) {
            handler.handleStep(interpolator, lastStep);
        }
        stepStart = nextStep;
        if (fsal) {
            // save the last evaluation for the next step
            System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);
        }
        if (manager.reset(stepStart, y) && !lastStep) {
            // some event handler has triggered changes that
            // invalidate the derivatives, we need to recompute them
            computeDerivatives(stepStart, y, yDotK[0]);
        }
        if (!lastStep) {
            // in some rare cases we may get here with stepSize = 0, for example
            // when an event occurs at integration start, reducing the first step
            // to zero; we have to reset the step to some safe non zero value
            stepSize = filterStep(stepSize, forward, true);
            // stepsize control for next step
            final double factor = Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(error, exp)));
            final double scaledH = stepSize * factor;
            final double nextT = stepStart + scaledH;
            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
            hNew = filterStep(scaledH, forward, nextIsLast);
        }
    }
    final double stopTime = stepStart;
    resetInternalState();
    return stopTime;
}","/**
 * {@inheritDoc}
 */
","@Override
public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException {
    sanityChecks(equations, t0, y0, t, y);
    setEquations(equations);
    resetEvaluations();
    final boolean forward = t > t0;
        final int stages = c.length + 1;
    if (y != y0) {
        System.arraycopy(y0, 0, y, 0, y0.length);
    }
    final double[][] yDotK = new double[stages][y0.length];
    final double[] yTmp = new double[y0.length];
        AbstractStepInterpolator interpolator;
    if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {
        final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();
        rki.reinitialize(this, yTmp, yDotK, forward);
        interpolator = rki;
    } else {
        interpolator = new DummyStepInterpolator(yTmp, forward);
    }
    interpolator.storeTime(t0);
        stepStart = t0;
    double hNew = 0;
    boolean firstTime = true;
    for (StepHandler handler : stepHandlers) {
        handler.reset();
    }
    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);
    boolean lastStep = false;
        while (!lastStep) {
        interpolator.shift();
        double error = 0;
        for (boolean loop = true; loop; ) {
            if (firstTime || !fsal) {
                                computeDerivatives(stepStart, y, yDotK[0]);
            }
            if (firstTime) {
                final double[] scale;
                if (vecAbsoluteTolerance == null) {
                    scale = new double[y0.length];
                    java.util.Arrays.fill(scale, scalAbsoluteTolerance);
                } else {
                    scale = vecAbsoluteTolerance;
                }
                hNew = initializeStep(equations, forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]);
                firstTime = false;
            }
            stepSize = hNew;
                        for (int k = 1; k < stages; ++k) {
                for (int j = 0; j < y0.length; ++j) {
                    double sum = a[k - 1][0] * yDotK[0][j];
                    for (int l = 1; l < k; ++l) {
                        sum += a[k - 1][l] * yDotK[l][j];
                    }
                    yTmp[j] = y[j] + stepSize * sum;
                }
                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);
            }
                        for (int j = 0; j < y0.length; ++j) {
                double sum = b[0] * yDotK[0][j];
                for (int l = 1; l < stages; ++l) {
                    sum += b[l] * yDotK[l][j];
                }
                yTmp[j] = y[j] + stepSize * sum;
            }
                        error = estimateError(yDotK, y, yTmp, stepSize);
            if (error <= 1.0) {
                                interpolator.storeTime(stepStart + stepSize);
                if (manager.evaluateStep(interpolator)) {
                    final double dt = manager.getEventTime() - stepStart;
                    if (Math.abs(dt) <= Math.ulp(stepStart)) {
                                                loop = false;
                    } else {
                                                hNew = dt;
                    }
                } else {
                                        loop = false;
                }
            } else {
                                final double factor = Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(error, exp)));
                hNew = filterStep(stepSize * factor, forward, false);
            }
        }
                final double nextStep = stepStart + stepSize;
        System.arraycopy(yTmp, 0, y, 0, y0.length);
        manager.stepAccepted(nextStep, y);
        lastStep = manager.stop();
                interpolator.storeTime(nextStep);
        for (StepHandler handler : stepHandlers) {
            handler.handleStep(interpolator, lastStep);
        }
        stepStart = nextStep;
        if (fsal) {
                        System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);
        }
        if (manager.reset(stepStart, y) && !lastStep) {
                                    computeDerivatives(stepStart, y, yDotK[0]);
        }
        if (!lastStep) {
                                                stepSize = filterStep(stepSize, forward, true);
                        final double factor = Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(error, exp)));
            final double scaledH = stepSize * factor;
            final double nextT = stepStart + scaledH;
            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
            hNew = filterStep(scaledH, forward, nextIsLast);
        }
    }
    final double stopTime = stepStart;
    resetInternalState();
    return stopTime;
}",4.409090909090909,1.4162679425837321,3.6,1.5,3.3333333333333335,4.646825396825397,-1.4907681465820997,2.9166666666666665,-0.02631578947368421,35.11209695544682
JxPath,2,1,"public Iterator iteratePointers(EvalContext context) {
    Object result = compute(context);
    if (result == null) {
        return Collections.EMPTY_LIST.iterator();
    }
    if (result instanceof EvalContext) {
        return (EvalContext) result;
    }
    return new PointerIterator(ValueUtils.iterate(result), new QName(null, ""value""), context.getRootContext().getCurrentNodePointer().getLocale());
}",,"public Iterator iteratePointers(EvalContext context) {
    Object result = compute(context);
    if (result == null) {
        return Collections.EMPTY_LIST.iterator();
    }
    if (result instanceof EvalContext) {
        return (EvalContext) result;
    }
    return new PointerIterator(ValueUtils.iterate(result), new QName(null, ""value""), context.getRootContext().getCurrentNodePointer().getLocale());
}",-0.18181818181818182,-0.2200956937799045,-0.2,-0.5,-0.16666666666666666,-0.07738095238095241,0.18421423537702594,0.0,0.0,-0.07037914282256531
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3396_c83755c3,0,"@Nonnull
private ExternalUser createUser(@Nonnull Entry entry, @CheckForNull String id) throws LdapInvalidAttributeValueException {
    ExternalIdentityRef ref = new ExternalIdentityRef(entry.getDn().getName(), this.getName());
    if (id == null) {
        id = entry.get(config.getUserConfig().getIdAttribute()).getString();
    }
    String path = config.getUserConfig().makeDnPath() ? createDNPath(entry.getDn()) : null;
    LdapUser user = new LdapUser(this, ref, id, path);
    Map<String, Object> props = user.getProperties();
    applyAttributes(props, entry);
    return user;
}",,"@Nonnull
private ExternalUser createUser(@Nonnull Entry entry, @CheckForNull String id) throws LdapInvalidAttributeValueException {
    ExternalIdentityRef ref = new ExternalIdentityRef(entry.getDn().getName(), this.getName());
    if (id == null) {
        id = entry.get(config.getUserConfig().getIdAttribute()).getString();
    }
    String path = config.getUserConfig().makeDnPath() ? createDNPath(entry.getDn()) : null;
    LdapUser user = new LdapUser(this, ref, id, path);
    Map<String, Object> props = user.getProperties();
    applyAttributes(props, entry);
    return user;
}",-0.09090909090909091,-0.37320574162679443,-0.2,-0.5,-0.08333333333333333,-0.021825396825396845,-0.007751937984496283,0.5833333333333334,-0.02631578947368421,0.06895454781210558
Lang,46,0,"/**
 * <p>Escapes the characters in a <code>String</code> using JavaScript String rules.</p>
 * <p>Escapes any values it finds into their JavaScript String form.
 * Deals correctly with quotes and control-chars (tab, backslash, cr, ff, etc.) </p>
 *
 * <p>So a tab becomes the characters <code>'\\'</code> and
 * <code>'t'</code>.</p>
 *
 * <p>The only difference between Java strings and JavaScript strings
 * is that in JavaScript, a single quote must be escaped.</p>
 *
 * <p>Example:
 * <pre>
 * input string: He didn't say, ""Stop!""
 * output string: He didn\'t say, \""Stop!\""
 * </pre>
 * </p>
 *
 * @param str  String to escape values in, may be null
 * @return String with escaped values, <code>null</code> if null string input
 */
public static String escapeJavaScript(String str) {
    return escapeJavaStyleString(str, true);
}","/**
 * <p>Escapes the characters in a <code>String</code> using JavaScript String rules.</p>
 * <p>Escapes any values it finds into their JavaScript String form.
 * Deals correctly with quotes and control-chars (tab, backslash, cr, ff, etc.) </p>
 *
 * <p>So a tab becomes the characters <code>'\\'</code> and
 * <code>'t'</code>.</p>
 *
 * <p>The only difference between Java strings and JavaScript strings
 * is that in JavaScript, a single quote must be escaped.</p>
 *
 * <p>Example:
 * <pre>
 * input string: He didn't say, ""Stop!""
 * output string: He didn\'t say, \""Stop!\""
 * </pre>
 * </p>
 *
 * @param str  String to escape values in, may be null
 * @return String with escaped values, <code>null</code> if null string input
 */
","public static String escapeJavaScript(String str) {
    return escapeJavaStyleString(str, true);
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,1.0253699788583508,-0.4166666666666667,0.31578947368421056,-0.16279340490885932
Cli,22,1,"/**
 * <p>An implementation of {@link Parser}'s abstract
 * {@link Parser#flatten(Options,String[],boolean) flatten} method.</p>
 *
 * <p>The following are the rules used by this flatten method.
 * <ol>
 *  <li>if <code>stopAtNonOption</code> is <b>true</b> then do not
 *  burst anymore of <code>arguments</code> entries, just add each
 *  successive entry without further processing.  Otherwise, ignore
 *  <code>stopAtNonOption</code>.</li>
 *  <li>if the current <code>arguments</code> entry is ""<b>--</b>""
 *  just add the entry to the list of processed tokens</li>
 *  <li>if the current <code>arguments</code> entry is ""<b>-</b>""
 *  just add the entry to the list of processed tokens</li>
 *  <li>if the current <code>arguments</code> entry is two characters
 *  in length and the first character is ""<b>-</b>"" then check if this
 *  is a valid {@link Option} id.  If it is a valid id, then add the
 *  entry to the list of processed tokens and set the current {@link Option}
 *  member.  If it is not a valid id and <code>stopAtNonOption</code>
 *  is true, then the remaining entries are copied to the list of
 *  processed tokens.  Otherwise, the current entry is ignored.</li>
 *  <li>if the current <code>arguments</code> entry is more than two
 *  characters in length and the first character is ""<b>-</b>"" then
 *  we need to burst the entry to determine its constituents.  For more
 *  information on the bursting algorithm see
 *  {@link PosixParser#burstToken(String, boolean) burstToken}.</li>
 *  <li>if the current <code>arguments</code> entry is not handled
 *  by any of the previous rules, then the entry is added to the list
 *  of processed tokens.</li>
 * </ol>
 * </p>
 *
 * @param options The command line {@link Options}
 * @param arguments The command line arguments to be parsed
 * @param stopAtNonOption Specifies whether to stop flattening
 * when an non option is found.
 * @return The flattened <code>arguments</code> String array.
 */
protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption) {
    init();
    this.options = options;
    // an iterator for the command line tokens
    Iterator iter = Arrays.asList(arguments).iterator();
    // process each command line token
    while (iter.hasNext()) {
        // get the next command line token
        String token = (String) iter.next();
        // handle long option --foo or --foo=bar
        if (token.startsWith(""--"")) {
            int pos = token.indexOf('=');
            // --foo
            String opt = pos == -1 ? token : token.substring(0, pos);
            if (!options.hasOption(opt)) {
                processNonOptionToken(token);
            } else {
                tokens.add(opt);
                if (pos != -1) {
                    tokens.add(token.substring(pos + 1));
                }
            }
        } else // single hyphen
        if (""-"".equals(token)) {
            tokens.add(token);
        } else if (token.startsWith(""-"")) {
            if (token.length() == 2 || options.hasOption(token)) {
                processOptionToken(token, stopAtNonOption);
            } else // requires bursting
            {
                burstToken(token, stopAtNonOption);
            }
        } else if (stopAtNonOption) {
            processNonOptionToken(token);
        } else {
            tokens.add(token);
        }
        gobble(iter);
    }
    return (String[]) tokens.toArray(new String[tokens.size()]);
}","/**
 * <p>An implementation of {@link Parser}'s abstract
 * {@link Parser#flatten(Options,String[],boolean) flatten} method.</p>
 *
 * <p>The following are the rules used by this flatten method.
 * <ol>
 *  <li>if <code>stopAtNonOption</code> is <b>true</b> then do not
 *  burst anymore of <code>arguments</code> entries, just add each
 *  successive entry without further processing.  Otherwise, ignore
 *  <code>stopAtNonOption</code>.</li>
 *  <li>if the current <code>arguments</code> entry is ""<b>--</b>""
 *  just add the entry to the list of processed tokens</li>
 *  <li>if the current <code>arguments</code> entry is ""<b>-</b>""
 *  just add the entry to the list of processed tokens</li>
 *  <li>if the current <code>arguments</code> entry is two characters
 *  in length and the first character is ""<b>-</b>"" then check if this
 *  is a valid {@link Option} id.  If it is a valid id, then add the
 *  entry to the list of processed tokens and set the current {@link Option}
 *  member.  If it is not a valid id and <code>stopAtNonOption</code>
 *  is true, then the remaining entries are copied to the list of
 *  processed tokens.  Otherwise, the current entry is ignored.</li>
 *  <li>if the current <code>arguments</code> entry is more than two
 *  characters in length and the first character is ""<b>-</b>"" then
 *  we need to burst the entry to determine its constituents.  For more
 *  information on the bursting algorithm see
 *  {@link PosixParser#burstToken(String, boolean) burstToken}.</li>
 *  <li>if the current <code>arguments</code> entry is not handled
 *  by any of the previous rules, then the entry is added to the list
 *  of processed tokens.</li>
 * </ol>
 * </p>
 *
 * @param options The command line {@link Options}
 * @param arguments The command line arguments to be parsed
 * @param stopAtNonOption Specifies whether to stop flattening
 * when an non option is found.
 * @return The flattened <code>arguments</code> String array.
 */
","protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption) {
    init();
    this.options = options;
        Iterator iter = Arrays.asList(arguments).iterator();
        while (iter.hasNext()) {
                String token = (String) iter.next();
                if (token.startsWith(""--"")) {
            int pos = token.indexOf('=');
                        String opt = pos == -1 ? token : token.substring(0, pos);
            if (!options.hasOption(opt)) {
                processNonOptionToken(token);
            } else {
                tokens.add(opt);
                if (pos != -1) {
                    tokens.add(token.substring(pos + 1));
                }
            }
        } else         if (""-"".equals(token)) {
            tokens.add(token);
        } else if (token.startsWith(""-"")) {
            if (token.length() == 2 || options.hasOption(token)) {
                processOptionToken(token, stopAtNonOption);
            } else             {
                burstToken(token, stopAtNonOption);
            }
        } else if (stopAtNonOption) {
            processNonOptionToken(token);
        } else {
            tokens.add(token);
        }
        gobble(iter);
    }
    return (String[]) tokens.toArray(new String[tokens.size()]);
}",1.0,0.8468899521531099,1.2,1.5,1.3333333333333333,1.0595238095238095,-0.6541226215644819,1.5833333333333333,-0.02631578947368421,1.728958120825481
commons-math,remotes/origin/bugs-dot-jar_MATH-631_334c01e6,1,"/**
 * {@inheritDoc}
 */
protected final double doSolve() {
    // Get initial solution
    double x0 = getMin();
    double x1 = getMax();
    double f0 = computeObjectiveValue(x0);
    double f1 = computeObjectiveValue(x1);
    // regardless of the allowed solutions.
    if (f0 == 0.0) {
        return x0;
    }
    if (f1 == 0.0) {
        return x1;
    }
    // Verify bracketing of initial solution.
    verifyBracketing(x0, x1);
    // Get accuracies.
    final double ftol = getFunctionValueAccuracy();
    final double atol = getAbsoluteAccuracy();
    final double rtol = getRelativeAccuracy();
    // Keep track of inverted intervals, meaning that the left bound is
    // larger than the right bound.
    boolean inverted = false;
    // Keep finding better approximations.
    while (true) {
        // Calculate the next approximation.
        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
        final double fx = computeObjectiveValue(x);
        // we can return it regardless of the allowed solutions.
        if (fx == 0.0) {
            return x;
        }
        // Update the bounds with the new approximation.
        if (f1 * fx < 0) {
            // We had [x0..x1]. We update it to [x1, x]. Note that the
            // value of x1 has switched to the other bound, thus inverting
            // the interval.
            x0 = x1;
            f0 = f1;
            x1 = x;
            f1 = fx;
            inverted = !inverted;
        } else {
            // We had [x0..x1]. We update it to [x0, x].
            if (method == Method.ILLINOIS) {
                f0 *= 0.5;
            }
            if (method == Method.PEGASUS) {
                f0 *= f1 / (f1 + fx);
            }
            x1 = x;
            f1 = fx;
        }
        // the root than we already are.
        if (FastMath.abs(f1) <= ftol) {
            switch(allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
            }
        }
        // are satisfied with the current approximation.
        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {
            switch(allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
            }
        }
    }
}","/**
 * {@inheritDoc}
 */
","protected final double doSolve() {
        double x0 = getMin();
    double x1 = getMax();
    double f0 = computeObjectiveValue(x0);
    double f1 = computeObjectiveValue(x1);
        if (f0 == 0.0) {
        return x0;
    }
    if (f1 == 0.0) {
        return x1;
    }
        verifyBracketing(x0, x1);
        final double ftol = getFunctionValueAccuracy();
    final double atol = getAbsoluteAccuracy();
    final double rtol = getRelativeAccuracy();
            boolean inverted = false;
        while (true) {
                final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
        final double fx = computeObjectiveValue(x);
                if (fx == 0.0) {
            return x;
        }
                if (f1 * fx < 0) {
                                                x0 = x1;
            f0 = f1;
            x1 = x;
            f1 = fx;
            inverted = !inverted;
        } else {
                        if (method == Method.ILLINOIS) {
                f0 *= 0.5;
            }
            if (method == Method.PEGASUS) {
                f0 *= f1 / (f1 + fx);
            }
            x1 = x;
            f1 = fx;
        }
                if (FastMath.abs(f1) <= ftol) {
            switch(allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
            }
        }
                if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {
            switch(allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
            }
        }
    }
}",3.1818181818181817,1.6507177033492826,6.4,1.5,3.0833333333333335,2.9503968253968256,-1.2849894291754753,0.5833333333333334,-0.02631578947368421,7.190795456510086
wicket,remotes/origin/bugs-dot-jar_WICKET-4338_9decad35,3,"/**
 *  @see org.apache.wicket.request.mapper.parameter.IPageParametersEncoder#decodePageParameters(org.apache.wicket.request.Request)
 */
public PageParameters decodePageParameters(final Request request) {
    PageParameters parameters = new PageParameters();
    int i = 0;
    for (String s : request.getUrl().getSegments()) {
        parameters.set(i, s);
        ++i;
    }
    for (QueryParameter p : request.getUrl().getQueryParameters()) {
        parameters.add(p.getName(), p.getValue());
    }
    return parameters.isEmpty() ? null : parameters;
}","/**
 *  @see org.apache.wicket.request.mapper.parameter.IPageParametersEncoder#decodePageParameters(org.apache.wicket.request.Request)
 */
","public PageParameters decodePageParameters(final Request request) {
    PageParameters parameters = new PageParameters();
    int i = 0;
    for (String s : request.getUrl().getSegments()) {
        parameters.set(i, s);
        ++i;
    }
    for (QueryParameter p : request.getUrl().getQueryParameters()) {
        parameters.add(p.getName(), p.getValue());
    }
    return parameters.isEmpty() ? null : parameters;
}",-0.09090909090909091,-0.20574162679425848,0.0,-0.5,-0.25,-0.03373015873015876,0.06243833685694159,0.25,-0.02631578947368421,-0.03071177884199789
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-1069_e9b628ec,3,"@Override
protected int[] getEventIndices(final String text, final int beginIndex) {
    // Scan the text for the end of the next JSON object.
    final int start = text.indexOf(EVENT_START_MARKER, beginIndex);
    if (start == END) {
        return END_PAIR;
    }
    final char[] charArray = text.toCharArray();
    int stack = 0;
    boolean inStr = false;
    boolean inEsc = false;
    for (int i = start; i < charArray.length; i++) {
        final char c = charArray[i];
        if (!inEsc) {
            inEsc = false;
            switch(c) {
                case EVENT_START_MARKER:
                    if (!inStr) {
                        stack++;
                    }
                    break;
                case EVENT_END_MARKER:
                    if (!inStr) {
                        stack--;
                    }
                    break;
                case JSON_STR_DELIM:
                    inStr = !inStr;
                    break;
                case JSON_ESC:
                    inEsc = true;
                    break;
            }
            if (stack == 0) {
                return new int[] { start, i };
            }
        }
    }
    return END_PAIR;
}",,"@Override
protected int[] getEventIndices(final String text, final int beginIndex) {
        final int start = text.indexOf(EVENT_START_MARKER, beginIndex);
    if (start == END) {
        return END_PAIR;
    }
    final char[] charArray = text.toCharArray();
    int stack = 0;
    boolean inStr = false;
    boolean inEsc = false;
    for (int i = start; i < charArray.length; i++) {
        final char c = charArray[i];
        if (!inEsc) {
            inEsc = false;
            switch(c) {
                case EVENT_START_MARKER:
                    if (!inStr) {
                        stack++;
                    }
                    break;
                case EVENT_END_MARKER:
                    if (!inStr) {
                        stack--;
                    }
                    break;
                case JSON_STR_DELIM:
                    inStr = !inStr;
                    break;
                case JSON_ESC:
                    inEsc = true;
                    break;
            }
            if (stack == 0) {
                return new int[] { start, i };
            }
        }
    }
    return END_PAIR;
}",1.1363636363636365,2.1148325358851676,2.2,1.5,1.0,0.8968253968253969,-0.6560958421423537,-0.3333333333333333,0.1842105263157895,0.8976446926344057
Lang,47,1,"/**
 * Appends an object to the builder padding on the right to a fixed length.
 * The <code>toString</code> of the object is used.
 * If the object is larger than the length, the right hand side is lost.
 * If the object is null, null text value is used.
 *
 * @param obj  the object to append, null uses null text
 * @param width  the fixed field width, zero or negative has no effect
 * @param padChar  the pad character to use
 * @return this, to enable chaining
 */
public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {
    if (width > 0) {
        ensureCapacity(size + width);
        String str = (obj == null ? getNullText() : obj.toString());
        int strLen = str.length();
        if (strLen >= width) {
            str.getChars(0, width, buffer, size);
        } else {
            int padLen = width - strLen;
            str.getChars(0, strLen, buffer, size);
            for (int i = 0; i < padLen; i++) {
                buffer[size + strLen + i] = padChar;
            }
        }
        size += width;
    }
    return this;
}","/**
 * Appends an object to the builder padding on the right to a fixed length.
 * The <code>toString</code> of the object is used.
 * If the object is larger than the length, the right hand side is lost.
 * If the object is null, null text value is used.
 *
 * @param obj  the object to append, null uses null text
 * @param width  the fixed field width, zero or negative has no effect
 * @param padChar  the pad character to use
 * @return this, to enable chaining
 */
","public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {
    if (width > 0) {
        ensureCapacity(size + width);
        String str = (obj == null ? getNullText() : obj.toString());
        int strLen = str.length();
        if (strLen >= width) {
            str.getChars(0, width, buffer, size);
        } else {
            int padLen = width - strLen;
            str.getChars(0, strLen, buffer, size);
            for (int i = 0; i < padLen; i++) {
                buffer[size + strLen + i] = padChar;
            }
        }
        size += width;
    }
    return this;
}",0.18181818181818182,0.5885167464114831,0.2,0.5,0.3333333333333333,1.5615079365079367,-0.2197322057787174,0.0,-0.02631578947368421,1.2656512393169779
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-217_add180fb,1,"@Override
public void addSplits(String tableName, SortedSet<Text> partitionKeys) throws TableNotFoundException, AccumuloException, AccumuloSecurityException {
}",,"@Override
public void addSplits(String tableName, SortedSet<Text> partitionKeys) throws TableNotFoundException, AccumuloException, AccumuloSecurityException {
}",-0.5,-1.4306220095693782,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.9360112755461594,-0.5,0.10526315789473684,-0.16279340490885932
camel,remotes/origin/bugs-dot-jar_CAMEL-9444_baece126,1,"@Override
public boolean process(Exchange exchange, final AsyncCallback callback) {
    final AggregationStrategy strategy = getAggregationStrategy();
    // to ensure it supports async routing
    if (strategy == null) {
        UseOriginalAggregationStrategy original = new UseOriginalAggregationStrategy(exchange, true);
        setAggregationStrategyOnExchange(exchange, original);
    }
    return super.process(exchange, callback);
}",,"@Override
public boolean process(Exchange exchange, final AsyncCallback callback) {
    final AggregationStrategy strategy = getAggregationStrategy();
        if (strategy == null) {
        UseOriginalAggregationStrategy original = new UseOriginalAggregationStrategy(exchange, true);
        setAggregationStrategyOnExchange(exchange, original);
    }
    return super.process(exchange, callback);
}",-0.22727272727272727,-0.01913875598086126,-0.4,-0.5,-0.25,-0.06150793650793652,0.27723749119097973,-0.25,0.6578947368421053,-0.08766791722134817
flink,remotes/origin/bugs-dot-jar_FLINK-1496_0a4c7694,1,"/**
 *  Returns the total number of input channels for this reader.
 *  <p>
 *  Note: This number might be smaller the current number of input channels
 *  of the reader as channels are possibly updated during runtime.
 */
public int getNumberOfInputChannels() {
    return totalNumberOfInputChannels;
}","/**
 *  Returns the total number of input channels for this reader.
 *  <p>
 *  Note: This number might be smaller the current number of input channels
 *  of the reader as channels are possibly updated during runtime.
 */
","public int getNumberOfInputChannels() {
    return totalNumberOfInputChannels;
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,1.2407329105003524,-0.5,2.6052631578947367,-0.16279340490885932
wicket,remotes/origin/bugs-dot-jar_WICKET-5466_c1c1f794,1,"/**
 *  @see org.apache.wicket.request.IRequestHandler#respond(org.apache.wicket.request.IRequestCycle)
 */
@Override
public void respond(final IRequestCycle requestCycle) {
    final IRequestablePage page = getPage();
    final boolean freshPage = pageComponentProvider.isPageInstanceFresh();
    final boolean isAjax = ((WebRequest) requestCycle.getRequest()).isAjax();
    IRequestableComponent component;
    try {
        component = getComponent();
    } catch (ComponentNotFoundException e) {
        // either the page is stateless and the component we are looking for is not added in the
        // constructor
        // or the page is stateful+stale and a new instances was created by pageprovider
        // we denote this by setting component to null
        component = null;
    }
    if ((component == null && freshPage) || (component != null && getComponent().getPage() == page)) {
        if (page instanceof Page) {
            // initialize the page to be able to check whether it is stateless
            ((Page) page).internalInitialize();
        }
        final boolean isStateless = page.isPageStateless();
        RedirectPolicy policy = isStateless ? RedirectPolicy.NEVER_REDIRECT : RedirectPolicy.AUTO_REDIRECT;
        final IPageProvider pageProvider = new PageProvider(page);
        if (freshPage && (isStateless == false || component == null)) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""A ListenerInterface '{}' assigned to '{}' is executed on an expired stateful page. "" + ""Scheduling re-create of the page and ignoring the listener interface..."", listenerInterface, getComponentPath());
            }
            if (isAjax) {
                policy = RedirectPolicy.ALWAYS_REDIRECT;
            }
            requestCycle.scheduleRequestHandlerAfterCurrent(new RenderPageRequestHandler(pageProvider, policy));
            return;
        }
        if (isAjax == false && listenerInterface.isRenderPageAfterInvocation()) {
            // schedule page render after current request handler is done. this can be
            // overridden during invocation of listener
            // method (i.e. by calling RequestCycle#setResponsePage)
            requestCycle.scheduleRequestHandlerAfterCurrent(new RenderPageRequestHandler(pageProvider, policy));
        }
        invokeListener();
    } else {
        throw new WicketRuntimeException(""Component "" + getComponent() + "" has been removed from page."");
    }
}","/**
 *  @see org.apache.wicket.request.IRequestHandler#respond(org.apache.wicket.request.IRequestCycle)
 */
","@Override
public void respond(final IRequestCycle requestCycle) {
    final IRequestablePage page = getPage();
    final boolean freshPage = pageComponentProvider.isPageInstanceFresh();
    final boolean isAjax = ((WebRequest) requestCycle.getRequest()).isAjax();
    IRequestableComponent component;
    try {
        component = getComponent();
    } catch (ComponentNotFoundException e) {
                                        component = null;
    }
    if ((component == null && freshPage) || (component != null && getComponent().getPage() == page)) {
        if (page instanceof Page) {
                        ((Page) page).internalInitialize();
        }
        final boolean isStateless = page.isPageStateless();
        RedirectPolicy policy = isStateless ? RedirectPolicy.NEVER_REDIRECT : RedirectPolicy.AUTO_REDIRECT;
        final IPageProvider pageProvider = new PageProvider(page);
        if (freshPage && (isStateless == false || component == null)) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""A ListenerInterface '{}' assigned to '{}' is executed on an expired stateful page. "" + ""Scheduling re-create of the page and ignoring the listener interface..."", listenerInterface, getComponentPath());
            }
            if (isAjax) {
                policy = RedirectPolicy.ALWAYS_REDIRECT;
            }
            requestCycle.scheduleRequestHandlerAfterCurrent(new RenderPageRequestHandler(pageProvider, policy));
            return;
        }
        if (isAjax == false && listenerInterface.isRenderPageAfterInvocation()) {
                                                requestCycle.scheduleRequestHandlerAfterCurrent(new RenderPageRequestHandler(pageProvider, policy));
        }
        invokeListener();
    } else {
        throw new WicketRuntimeException(""Component "" + getComponent() + "" has been removed from page."");
    }
}",1.0,0.5263157894736841,1.2,0.5,1.3333333333333333,0.736111111111111,-0.6684989429175475,0.9166666666666666,-0.02631578947368421,1.450323011935017
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1977_4bfbfcdd,1,"@Override
public Iterator<String> iterator() {
    PathIterator pi = new PathIterator(filter, indexName);
    pi.setPathContainsValue(true);
    pi.enqueue(children.iterator());
    return pi;
}",,"@Override
public Iterator<String> iterator() {
    PathIterator pi = new PathIterator(filter, indexName);
    pi.setPathContainsValue(true);
    pi.enqueue(children.iterator());
    return pi;
}",-0.3181818181818182,-0.48325358851674655,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.45482734319943624,-0.25,0.2631578947368421,-0.16279340490885932
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-217_add180fb,1,"@Override
public Collection<Text> getSplits(String tableName, int maxSplits) {
    return Collections.emptyList();
}",,"@Override
public Collection<Text> getSplits(String tableName, int maxSplits) {
    return Collections.emptyList();
}",-0.45454545454545453,-0.6028708133971293,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.8246652572233965,-0.4166666666666667,0.763157894736842,-0.16279340490885932
camel,remotes/origin/bugs-dot-jar_CAMEL-5137_afa1d132,3,"@Override
public void run() {
    try {
        long count = counter.incrementAndGet();
        boolean fire = endpoint.getRepeatCount() <= 0 || count <= endpoint.getRepeatCount();
        if (fire) {
            sendTimerExchange(count);
        } else {
            // no need to fire anymore as we exceeded repeat count
            LOG.debug(""Cancelling {} timer as repeat count limit reached after {} counts."", endpoint.getTimerName(), endpoint.getRepeatCount());
            cancel();
        }
    } catch (Throwable e) {
        // catch all to avoid the JVM closing the thread and not firing again
        LOG.warn(""Error processing exchange. This exception will be ignored, to let the timer be able to trigger again."", e);
    }
}",,"@Override
public void run() {
    try {
        long count = counter.incrementAndGet();
        boolean fire = endpoint.getRepeatCount() <= 0 || count <= endpoint.getRepeatCount();
        if (fire) {
            sendTimerExchange(count);
        } else {
                        LOG.debug(""Cancelling {} timer as repeat count limit reached after {} counts."", endpoint.getTimerName(), endpoint.getRepeatCount());
            cancel();
        }
    } catch (Throwable e) {
                LOG.warn(""Error processing exchange. This exception will be ignored, to let the timer be able to trigger again."", e);
    }
}",0.045454545454545456,0.5215311004784688,-0.2,0.0,-0.25,-0.06746031746031747,-0.021000704721635077,0.25,0.0,-0.0533024440564075
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-428_916cd92f,1,"/**
 * Splits a {@code jsonString}, which is prefixed with a type code
 * at the location where the prefix ends.
 * @param jsonString  json string to split
 * @return  the location where the prefix ends or -1 if no prefix is present
 */
public static int split(String jsonString) {
    if (jsonString.length() >= 4 && jsonString.charAt(3) == ':') {
        return 3;
    } else {
        return -1;
    }
}","/**
 * Splits a {@code jsonString}, which is prefixed with a type code
 * at the location where the prefix ends.
 * @param jsonString  json string to split
 * @return  the location where the prefix ends or -1 if no prefix is present
 */
","public static int split(String jsonString) {
    if (jsonString.length() >= 4 && jsonString.charAt(3) == ':') {
        return 3;
    } else {
        return -1;
    }
}",-0.3181818181818182,0.01435406698564584,-0.4,-0.5,-0.08333333333333333,0.15079365079365079,0.4646934460887948,-0.3333333333333333,2.263157894736842,-0.0852059957469615
JxPath,21,0,"/**
 * If the property contains a collection, then the length of that
 * collection, otherwise - 1.
 * @return int length
 */
public int getLength() {
    return ValueUtils.getLength(getBaseValue());
}","/**
 * If the property contains a collection, then the length of that
 * collection, otherwise - 1.
 * @return int length
 */
","public int getLength() {
    return ValueUtils.getLength(getBaseValue());
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,1.1319238900634248,-0.3333333333333333,2.5789473684210527,-0.16279340490885932
Closure,155,2,"// Any reference that is not a read of the arguments property
// consider a escape of the arguments object.
private void inlineNonConstants(Var v, ReferenceCollection referenceInfo) {
    int refCount = referenceInfo.references.size();
    Reference declaration = referenceInfo.references.get(0);
    Reference init = referenceInfo.getInitializingReference();
    int firstRefAfterInit = (declaration == init) ? 2 : 3;
    if (refCount > 1 && isImmutableAndWellDefinedVariable(v, referenceInfo)) {
        // if the variable is referenced more than once, we can only
        // inline it if it's immutable and never defined before referenced.
        Node value;
        if (init != null) {
            value = init.getAssignedValue();
        } else {
            // Create a new node for variable that is never initialized.
            Node srcLocation = declaration.getNameNode();
            value = NodeUtil.newUndefinedNode(srcLocation);
        }
        Preconditions.checkNotNull(value);
        inlineWellDefinedVariable(v, value, referenceInfo.references);
        staleVars.add(v);
    } else if (refCount == firstRefAfterInit) {
        // The variable likely only read once, try some more
        // complex inlining heuristics.
        Reference reference = referenceInfo.references.get(firstRefAfterInit - 1);
        if (canInline(declaration, init, reference)) {
            inline(v, declaration, init, reference);
            staleVars.add(v);
        }
    } else if (declaration != init && refCount == 2) {
        if (isValidDeclaration(declaration) && isValidInitialization(init)) {
            // The only reference is the initialization, remove the assignment and
            // the variable declaration.
            Node value = init.getAssignedValue();
            Preconditions.checkNotNull(value);
            inlineWellDefinedVariable(v, value, referenceInfo.references);
            staleVars.add(v);
        }
    }
    // the next pass.)
    if (!staleVars.contains(v) && referenceInfo.isWellDefined() && referenceInfo.isAssignedOnceInLifetime()) {
        List<Reference> refs = referenceInfo.references;
        for (int i = 1; /* start from a read */
        i < refs.size(); i++) {
            Node nameNode = refs.get(i).getNameNode();
            if (aliasCandidates.containsKey(nameNode)) {
                AliasCandidate candidate = aliasCandidates.get(nameNode);
                if (!staleVars.contains(candidate.alias) && !isVarInlineForbidden(candidate.alias)) {
                    Reference aliasInit;
                    aliasInit = candidate.refInfo.getInitializingReference();
                    Node value = aliasInit.getAssignedValue();
                    Preconditions.checkNotNull(value);
                    inlineWellDefinedVariable(candidate.alias, value, candidate.refInfo.references);
                    staleVars.add(candidate.alias);
                }
            }
        }
    }
}",,"private void inlineNonConstants(Var v, ReferenceCollection referenceInfo) {
    int refCount = referenceInfo.references.size();
    Reference declaration = referenceInfo.references.get(0);
    Reference init = referenceInfo.getInitializingReference();
    int firstRefAfterInit = (declaration == init) ? 2 : 3;
    if (refCount > 1 && isImmutableAndWellDefinedVariable(v, referenceInfo)) {
                        Node value;
        if (init != null) {
            value = init.getAssignedValue();
        } else {
                        Node srcLocation = declaration.getNameNode();
            value = NodeUtil.newUndefinedNode(srcLocation);
        }
        Preconditions.checkNotNull(value);
        inlineWellDefinedVariable(v, value, referenceInfo.references);
        staleVars.add(v);
    } else if (refCount == firstRefAfterInit) {
                        Reference reference = referenceInfo.references.get(firstRefAfterInit - 1);
        if (canInline(declaration, init, reference)) {
            inline(v, declaration, init, reference);
            staleVars.add(v);
        }
    } else if (declaration != init && refCount == 2) {
        if (isValidDeclaration(declaration) && isValidInitialization(init)) {
                                    Node value = init.getAssignedValue();
            Preconditions.checkNotNull(value);
            inlineWellDefinedVariable(v, value, referenceInfo.references);
            staleVars.add(v);
        }
    }
        if (!staleVars.contains(v) && referenceInfo.isWellDefined() && referenceInfo.isAssignedOnceInLifetime()) {
        List<Reference> refs = referenceInfo.references;
        for (int i = 1;         i < refs.size(); i++) {
            Node nameNode = refs.get(i).getNameNode();
            if (aliasCandidates.containsKey(nameNode)) {
                AliasCandidate candidate = aliasCandidates.get(nameNode);
                if (!staleVars.contains(candidate.alias) && !isVarInlineForbidden(candidate.alias)) {
                    Reference aliasInit;
                    aliasInit = candidate.refInfo.getInitializingReference();
                    Node value = aliasInit.getAssignedValue();
                    Preconditions.checkNotNull(value);
                    inlineWellDefinedVariable(candidate.alias, value, candidate.refInfo.references);
                    staleVars.add(candidate.alias);
                }
            }
        }
    }
}",1.5909090909090908,1.1052631578947367,1.6,1.0,2.75,2.0753968253968256,-0.9117688513037348,2.4166666666666665,-0.02631578947368421,6.422307129314269
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3028_89317b28,0,"/**
 * Creates a deep copy of this update operation. Changes to the returned
 * {@code UpdateOp} do not affect this object.
 *
 * @return a copy of this operation.
 */
public UpdateOp copy() {
    return new UpdateOp(id, isNew, isDelete, new HashMap<Key, Operation>(changes));
}","/**
 * Creates a deep copy of this update operation. Changes to the returned
 * {@code UpdateOp} do not affect this object.
 *
 * @return a copy of this operation.
 */
","public UpdateOp copy() {
    return new UpdateOp(id, isNew, isDelete, new HashMap<Key, Operation>(changes));
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.9419309372797741,-0.5,2.4210526315789473,-0.16279340490885932
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-4432_c9765c21,3,"@Override
public boolean apply(File input) {
    return input.isFile() && !input.getParent().equals(path);
}",,"@Override
public boolean apply(File input) {
    return input.isFile() && !input.getParent().equals(path);
}",-0.45454545454545453,-0.6028708133971293,-0.6,-1.0,-0.4166666666666667,-0.12301587301587304,0.7801268498942919,-0.25,0.7894736842105263,-0.13745036681016345
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-147_17296089,1,"private Result filter() {
    boolean match = false;
    if (useMap) {
        for (final Map.Entry<String, List<String>> entry : getMap().entrySet()) {
            final String toMatch = ThreadContext.get(entry.getKey());
            if (toMatch != null) {
                match = entry.getValue().contains(toMatch);
            } else {
                match = false;
            }
            if ((!isAnd() && match) || (isAnd() && !match)) {
                break;
            }
        }
    } else {
        match = key.equals(ThreadContext.get(key));
    }
    return match ? onMatch : onMismatch;
}",,"private Result filter() {
    boolean match = false;
    if (useMap) {
        for (final Map.Entry<String, List<String>> entry : getMap().entrySet()) {
            final String toMatch = ThreadContext.get(entry.getKey());
            if (toMatch != null) {
                match = entry.getValue().contains(toMatch);
            } else {
                match = false;
            }
            if ((!isAnd() && match) || (isAnd() && !match)) {
                break;
            }
        }
    } else {
        match = key.equals(ThreadContext.get(key));
    }
    return match ? onMatch : onMismatch;
}",0.22727272727272727,0.9952153110047848,0.6,0.5,0.5,0.30158730158730157,-0.2276250880902044,0.3333333333333333,0.02631578947368421,0.24006731096165923
wicket,remotes/origin/bugs-dot-jar_WICKET-4572_dfc56674,0,"/**
 *  @param pageId
 */
private void removeWindowIndex(int pageId) {
    idToWindowIndex.remove(pageId);
}","/**
 *  @param pageId
 */
","private void removeWindowIndex(int pageId) {
    idToWindowIndex.remove(pageId);
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,1.083157152924595,-0.4166666666666667,2.5789473684210527,-0.16279340490885932
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-3383_97f16db4,3,"private static File computeTopCacheDir() {
    String procName = ManagementFactory.getRuntimeMXBean().getName();
    return new File(System.getProperty(""java.io.tmpdir""), ""accumulo-vfs-cache-"" + procName + ""-"" + System.getProperty(""user.name"", ""nouser""));
}",,"private static File computeTopCacheDir() {
    String procName = ManagementFactory.getRuntimeMXBean().getName();
    return new File(System.getProperty(""java.io.tmpdir""), ""accumulo-vfs-cache-"" + procName + ""-"" + System.getProperty(""user.name"", ""nouser""));
}",-0.45454545454545453,-0.47368421052631593,-0.6,-1.0,-0.4166666666666667,-0.11309523809523811,0.685412262156448,-0.16666666666666666,0.02631578947368421,-0.11266517983206835
Compress,27,1,"/**
 * Parse an octal string from a buffer.
 *
 * <p>Leading spaces are ignored.
 * The buffer must contain a trailing space or NUL,
 * and may contain an additional trailing space or NUL.</p>
 *
 * <p>The input buffer is allowed to contain all NULs,
 * in which case the method returns 0L
 * (this allows for missing fields).</p>
 *
 * <p>To work-around some tar implementations that insert a
 * leading NUL this method returns 0 if it detects a leading NUL
 * since Commons Compress 1.4.</p>
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse - must be at least 2 bytes.
 * @return The long value of the octal string.
 * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.
 */
public static long parseOctal(final byte[] buffer, final int offset, final int length) {
    long result = 0;
    int end = offset + length;
    int start = offset;
    if (length < 2) {
        throw new IllegalArgumentException(""Length "" + length + "" must be at least 2"");
    }
    if (buffer[start] == 0) {
        return 0L;
    }
    // Skip leading spaces
    while (start < end) {
        if (buffer[start] == ' ') {
            start++;
        } else {
            break;
        }
    }
    // Trim all trailing NULs and spaces.
    // The ustar and POSIX tar specs require a trailing NUL or
    // space but some implementations use the extra digit for big
    // sizes/uids/gids ...
    byte trailer = buffer[end - 1];
    while (start < end && (trailer == 0 || trailer == ' ')) {
        end--;
        trailer = buffer[end - 1];
    }
    if (start == end) {
        throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, trailer));
    }
    for (; start < end; start++) {
        final byte currentByte = buffer[start];
        // CheckStyle:MagicNumber OFF
        if (currentByte < '0' || currentByte > '7') {
            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));
        }
        // convert from ASCII
        result = (result << 3) + (currentByte - '0');
    // CheckStyle:MagicNumber ON
    }
    return result;
}","/**
 * Parse an octal string from a buffer.
 *
 * <p>Leading spaces are ignored.
 * The buffer must contain a trailing space or NUL,
 * and may contain an additional trailing space or NUL.</p>
 *
 * <p>The input buffer is allowed to contain all NULs,
 * in which case the method returns 0L
 * (this allows for missing fields).</p>
 *
 * <p>To work-around some tar implementations that insert a
 * leading NUL this method returns 0 if it detects a leading NUL
 * since Commons Compress 1.4.</p>
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse - must be at least 2 bytes.
 * @return The long value of the octal string.
 * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.
 */
","public static long parseOctal(final byte[] buffer, final int offset, final int length) {
    long result = 0;
    int end = offset + length;
    int start = offset;
    if (length < 2) {
        throw new IllegalArgumentException(""Length "" + length + "" must be at least 2"");
    }
    if (buffer[start] == 0) {
        return 0L;
    }
        while (start < end) {
        if (buffer[start] == ' ') {
            start++;
        } else {
            break;
        }
    }
                    byte trailer = buffer[end - 1];
    while (start < end && (trailer == 0 || trailer == ' ')) {
        end--;
        trailer = buffer[end - 1];
    }
    if (start == end) {
        throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, trailer));
    }
    for (; start < end; start++) {
        final byte currentByte = buffer[start];
                if (currentByte < '0' || currentByte > '7') {
            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));
        }
                result = (result << 3) + (currentByte - '0');
        }
    return result;
}",0.9090909090909091,-0.01913875598086126,1.8,0.0,0.9166666666666666,3.1785714285714284,-0.6366455250176177,-0.3333333333333333,-0.02631578947368421,4.20056591921532
JxPath,11,1,"private Attr getAttribute(Element element, QName name) {
    String testPrefix = name.getPrefix();
    String testNS = null;
    if (testPrefix != null) {
        testNS = parent.getNamespaceURI(testPrefix);
    }
    if (testNS != null) {
        Attr attr = element.getAttributeNodeNS(testNS, name.getName());
        if (attr != null) {
            return attr;
        }
        // This may mean that the parser does not support NS for
        // attributes, example - the version of Crimson bundled
        // with JDK 1.4.0
        NamedNodeMap nnm = element.getAttributes();
        for (int i = 0; i < nnm.getLength(); i++) {
            attr = (Attr) nnm.item(i);
            if (testAttr(attr, name)) {
                return attr;
            }
        }
        return null;
    }
    return element.getAttributeNode(name.getName());
}",,"private Attr getAttribute(Element element, QName name) {
    String testPrefix = name.getPrefix();
    String testNS = null;
    if (testPrefix != null) {
        testNS = parent.getNamespaceURI(testPrefix);
    }
    if (testNS != null) {
        Attr attr = element.getAttributeNodeNS(testNS, name.getName());
        if (attr != null) {
            return attr;
        }
                                NamedNodeMap nnm = element.getAttributes();
        for (int i = 0; i < nnm.getLength(); i++) {
            attr = (Attr) nnm.item(i);
            if (testAttr(attr, name)) {
                return attr;
            }
        }
        return null;
    }
    return element.getAttributeNode(name.getName());
}",0.36363636363636365,0.47846889952153115,0.4,0.5,0.5833333333333334,0.490079365079365,-0.3245947850599013,0.3333333333333333,-0.02631578947368421,0.4998691816070491
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-4307_f303c916,1,"private RecordId writeStream(InputStream stream) throws IOException {
    boolean threw = true;
    try {
        RecordId id = SegmentStream.getRecordIdIfAvailable(stream, store);
        if (id == null || isOldGen(id)) {
            id = internalWriteStream(stream);
        }
        threw = false;
        return id;
    } finally {
        Closeables.close(stream, threw);
    }
}",,"private RecordId writeStream(InputStream stream) throws IOException {
    boolean threw = true;
    try {
        RecordId id = SegmentStream.getRecordIdIfAvailable(stream, store);
        if (id == null || isOldGen(id)) {
            id = internalWriteStream(stream);
        }
        threw = false;
        return id;
    } finally {
        Closeables.close(stream, threw);
    }
}",-0.045454545454545456,0.18181818181818177,-0.4,0.0,-0.08333333333333333,-0.05555555555555556,0.059619450317124574,-0.16666666666666666,0.47368421052631576,-0.05569521043319905
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-579_7d72e6ed,3,"@Override
public void restrict(FilterImpl f) {
    if (f.getSelector() == ancestorSelector) {
        String d = descendantSelector.currentPath();
        if (d != null) {
            f.restrictPath(PathUtils.getParentPath(d), Filter.PathRestriction.PARENT);
        }
    }
    if (f.getSelector() == descendantSelector) {
        String a = ancestorSelector.currentPath();
        if (a != null) {
            f.restrictPath(a, Filter.PathRestriction.DIRECT_CHILDREN);
        }
    }
}",,"@Override
public void restrict(FilterImpl f) {
    if (f.getSelector() == ancestorSelector) {
        String d = descendantSelector.currentPath();
        if (d != null) {
            f.restrictPath(PathUtils.getParentPath(d), Filter.PathRestriction.PARENT);
        }
    }
    if (f.getSelector() == descendantSelector) {
        String a = ancestorSelector.currentPath();
        if (a != null) {
            f.restrictPath(a, Filter.PathRestriction.DIRECT_CHILDREN);
        }
    }
}",0.045454545454545456,0.40191387559808606,0.2,0.0,0.3333333333333333,0.0019841269841269858,-0.06412966878083172,0.08333333333333333,0.07894736842105263,0.0031096742218610805
Closure,30,2,"@Override
public void process(Node externs, Node root) {
    (new NodeTraversal(compiler, this)).traverse(root);
}",,"@Override
public void process(Node externs, Node root) {
    (new NodeTraversal(compiler, this)).traverse(root);
}",-0.45454545454545453,-0.6028708133971293,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.8173361522198731,-0.4166666666666667,0.31578947368421056,-0.16279340490885932
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2929_a2950285,3,"/**
 * Get the revision of the latest change made to this node.
 *
 * @param context the revision context
 * @param changeRev the revision of the current change
 * @param handler the conflict handler, which is called for concurrent changes
 *                preceding <code>changeRev</code>.
 * @return the revision, or null if deleted
 */
@CheckForNull
public Revision getNewestRevision(final RevisionContext context, final Revision changeRev, final CollisionHandler handler) {
    final Map<Revision, String> validRevisions = Maps.newHashMap();
    Predicate<Revision> predicate = new Predicate<Revision>() {

        @Override
        public boolean apply(Revision input) {
            if (input.equals(changeRev)) {
                return false;
            }
            if (isValidRevision(context, input, null, changeRev, validRevisions)) {
                return true;
            }
            handler.concurrentModification(input);
            return false;
        }
    };
    Revision newestRev = null;
    // check local commits first
    SortedMap<Revision, String> revisions = getLocalRevisions();
    SortedMap<Revision, String> commitRoots = getLocalCommitRoot();
    Iterator<Revision> it = filter(Iterables.mergeSorted(ImmutableList.of(revisions.keySet(), commitRoots.keySet()), revisions.comparator()), predicate).iterator();
    if (it.hasNext()) {
        newestRev = it.next();
    } else {
        // check full history (only needed in rare cases)
        if (LOG.isDebugEnabled()) {
            LOG.debug(""getNewestRevision() with changeRev {} on {}, "" + ""_revisions {}, _commitRoot {}"", changeRev, getId(), getLocalRevisions(), getLocalCommitRoot());
        }
        it = filter(getAllChanges(), predicate).iterator();
        if (it.hasNext()) {
            newestRev = it.next();
        }
    }
    if (newestRev == null) {
        return null;
    }
    // the local deleted map contains the most recent revisions
    SortedMap<Revision, String> deleted = getLocalDeleted();
    String value = deleted.get(newestRev);
    if (value == null && deleted.headMap(newestRev).isEmpty()) {
        // no need to check previous docs
        return newestRev;
    }
    if (value == null) {
        // get from complete map
        value = getDeleted().get(newestRev);
    }
    if (""true"".equals(value)) {
        // deleted in the newest revision
        return null;
    }
    return newestRev;
}","/**
 * Get the revision of the latest change made to this node.
 *
 * @param context the revision context
 * @param changeRev the revision of the current change
 * @param handler the conflict handler, which is called for concurrent changes
 *                preceding <code>changeRev</code>.
 * @return the revision, or null if deleted
 */
","@CheckForNull
public Revision getNewestRevision(final RevisionContext context, final Revision changeRev, final CollisionHandler handler) {
    final Map<Revision, String> validRevisions = Maps.newHashMap();
    Predicate<Revision> predicate = new Predicate<Revision>() {

        @Override
        public boolean apply(Revision input) {
            if (input.equals(changeRev)) {
                return false;
            }
            if (isValidRevision(context, input, null, changeRev, validRevisions)) {
                return true;
            }
            handler.concurrentModification(input);
            return false;
        }
    };
    Revision newestRev = null;
        SortedMap<Revision, String> revisions = getLocalRevisions();
    SortedMap<Revision, String> commitRoots = getLocalCommitRoot();
    Iterator<Revision> it = filter(Iterables.mergeSorted(ImmutableList.of(revisions.keySet(), commitRoots.keySet()), revisions.comparator()), predicate).iterator();
    if (it.hasNext()) {
        newestRev = it.next();
    } else {
                if (LOG.isDebugEnabled()) {
            LOG.debug(""getNewestRevision() with changeRev {} on {}, "" + ""_revisions {}, _commitRoot {}"", changeRev, getId(), getLocalRevisions(), getLocalCommitRoot());
        }
        it = filter(getAllChanges(), predicate).iterator();
        if (it.hasNext()) {
            newestRev = it.next();
        }
    }
    if (newestRev == null) {
        return null;
    }
        SortedMap<Revision, String> deleted = getLocalDeleted();
    String value = deleted.get(newestRev);
    if (value == null && deleted.headMap(newestRev).isEmpty()) {
                return newestRev;
    }
    if (value == null) {
                value = getDeleted().get(newestRev);
    }
    if (""true"".equals(value)) {
                return null;
    }
    return newestRev;
}",1.5,0.42583732057416257,1.2,0.0,1.4166666666666667,0.5059523809523809,-0.8328400281888653,2.1666666666666665,-0.02631578947368421,1.5401278216720546
flink,remotes/origin/bugs-dot-jar_FLINK-1820_39d526e6,0,"@Override
public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, IntValue reusable) {
    long val = 0;
    boolean neg = false;
    final int delimLimit = limit - delimiter.length + 1;
    this.result = reusable;
    if (bytes[startPos] == '-') {
        neg = true;
        startPos++;
        // check for empty field with only the sign
        if (startPos == limit || (startPos < delimLimit && delimiterNext(bytes, startPos, delimiter))) {
            setErrorState(ParseErrorState.NUMERIC_VALUE_ORPHAN_SIGN);
            return -1;
        }
    }
    for (int i = startPos; i < limit; i++) {
        if (i < delimLimit && delimiterNext(bytes, i, delimiter)) {
            reusable.setValue((int) (neg ? -val : val));
            return i + delimiter.length;
        }
        if (bytes[i] < 48 || bytes[i] > 57) {
            setErrorState(ParseErrorState.NUMERIC_VALUE_ILLEGAL_CHARACTER);
            return -1;
        }
        val *= 10;
        val += bytes[i] - 48;
        if (val > OVERFLOW_BOUND && (!neg || val > UNDERFLOW_BOUND)) {
            setErrorState(ParseErrorState.NUMERIC_VALUE_OVERFLOW_UNDERFLOW);
            return -1;
        }
    }
    reusable.setValue((int) (neg ? -val : val));
    return limit;
}",,"@Override
public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, IntValue reusable) {
    long val = 0;
    boolean neg = false;
    final int delimLimit = limit - delimiter.length + 1;
    this.result = reusable;
    if (bytes[startPos] == '-') {
        neg = true;
        startPos++;
                if (startPos == limit || (startPos < delimLimit && delimiterNext(bytes, startPos, delimiter))) {
            setErrorState(ParseErrorState.NUMERIC_VALUE_ORPHAN_SIGN);
            return -1;
        }
    }
    for (int i = startPos; i < limit; i++) {
        if (i < delimLimit && delimiterNext(bytes, i, delimiter)) {
            reusable.setValue((int) (neg ? -val : val));
            return i + delimiter.length;
        }
        if (bytes[i] < 48 || bytes[i] > 57) {
            setErrorState(ParseErrorState.NUMERIC_VALUE_ILLEGAL_CHARACTER);
            return -1;
        }
        val *= 10;
        val += bytes[i] - 48;
        if (val > OVERFLOW_BOUND && (!neg || val > UNDERFLOW_BOUND)) {
            setErrorState(ParseErrorState.NUMERIC_VALUE_OVERFLOW_UNDERFLOW);
            return -1;
        }
    }
    reusable.setValue((int) (neg ? -val : val));
    return limit;
}",0.8636363636363636,0.3349282296650717,1.0,0.0,1.5833333333333333,2.9087301587301586,-0.6315715292459477,0.08333333333333333,-0.02631578947368421,4.945426254732801
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2021_004db804,1,"private static void addToUnionList(Expression condition, ArrayList<Expression> unionList) {
    if (condition instanceof OrCondition) {
        OrCondition or = (OrCondition) condition;
        if (or.getCommonLeftPart() != null) {
        // @x = 1 or @x = 2
        // is automatically converted to
        // @x in (1, 2)
        // within the query engine
        } else if (or.left instanceof Contains && or.right instanceof Contains) {
        // do not optimize ""contains""
        } else {
            // conditions of type
            // @x = 1 or @y = 2
            // or similar are converted to
            // (@x = 1) union (@y = 2)
            addToUnionList(or.left, unionList);
            addToUnionList(or.right, unionList);
            return;
        }
    } else if (condition instanceof AndCondition) {
        // conditions of type
        // @a = 1 and (@x = 1 or @y = 2)
        // are automatically converted to
        // (@a = 1 and @x = 1) union (@a = 1 and @y = 2)
        AndCondition and = (AndCondition) condition;
        and = and.pullOrRight();
        if (and.right instanceof OrCondition) {
            OrCondition or = (OrCondition) and.right;
            if (or.getCommonLeftPart() != null) {
            // @x = 1 or @x = 2
            // is automatically converted to
            // @x in (1, 2)
            // within the query engine
            } else if (or.left instanceof Contains && or.right instanceof Contains) {
            // do not optimize ""contains""
            } else {
                // same as above, but with the added ""and""
                addToUnionList(new AndCondition(and.left, or.left), unionList);
                addToUnionList(new AndCondition(and.left, or.right), unionList);
                return;
            }
        }
    }
    unionList.add(condition);
}",,"private static void addToUnionList(Expression condition, ArrayList<Expression> unionList) {
    if (condition instanceof OrCondition) {
        OrCondition or = (OrCondition) condition;
        if (or.getCommonLeftPart() != null) {
                                        } else if (or.left instanceof Contains && or.right instanceof Contains) {
                } else {
                                                            addToUnionList(or.left, unionList);
            addToUnionList(or.right, unionList);
            return;
        }
    } else if (condition instanceof AndCondition) {
                                        AndCondition and = (AndCondition) condition;
        and = and.pullOrRight();
        if (and.right instanceof OrCondition) {
            OrCondition or = (OrCondition) and.right;
            if (or.getCommonLeftPart() != null) {
                                                            } else if (or.left instanceof Contains && or.right instanceof Contains) {
                        } else {
                                addToUnionList(new AndCondition(and.left, or.left), unionList);
                addToUnionList(new AndCondition(and.left, or.right), unionList);
                return;
            }
        }
    }
    unionList.add(condition);
}",0.5454545454545454,0.6459330143540669,0.8,1.5,0.75,0.48611111111111116,-0.4207188160676531,0.16666666666666666,-0.02631578947368421,0.5302651521700292
wicket,remotes/origin/bugs-dot-jar_WICKET-5853_b80f6640,3,"@Override
public BigDecimal convertToObject(final String value, final Locale locale) {
    if (Strings.isEmpty(value)) {
        return null;
    }
    final Number number = parse(value, -Double.MAX_VALUE, Double.MAX_VALUE, locale);
    if (number instanceof BigDecimal) {
        return (BigDecimal) number;
    } else if (number instanceof Double) {
        // http://java.sun.com/j2se/1.4.2/docs/api/java/math/BigDecimal.html#BigDecimal%28double%29
        return new BigDecimal(Double.toString(number.doubleValue()));
    } else if (number instanceof Long) {
        return new BigDecimal(number.longValue());
    } else if (number instanceof Float) {
        return new BigDecimal(number.floatValue());
    } else if (number instanceof Integer) {
        return new BigDecimal(number.intValue());
    } else {
        return new BigDecimal(value);
    }
}",,"@Override
public BigDecimal convertToObject(final String value, final Locale locale) {
    if (Strings.isEmpty(value)) {
        return null;
    }
    final Number number = parse(value, -Double.MAX_VALUE, Double.MAX_VALUE, locale);
    if (number instanceof BigDecimal) {
        return (BigDecimal) number;
    } else if (number instanceof Double) {
                return new BigDecimal(Double.toString(number.doubleValue()));
    } else if (number instanceof Long) {
        return new BigDecimal(number.longValue());
    } else if (number instanceof Float) {
        return new BigDecimal(number.floatValue());
    } else if (number instanceof Integer) {
        return new BigDecimal(number.intValue());
    } else {
        return new BigDecimal(value);
    }
}",0.2727272727272727,-0.13397129186602882,0.6,1.5,0.3333333333333333,0.03968253968253967,-0.23890063424947125,0.08333333333333333,-0.02631578947368421,0.0628504578643753
Math,29,1,"/**
 * {@inheritDoc}
 */
@Override
public OpenMapRealVector ebeDivide(RealVector v) {
    checkVectorDimensions(v.getDimension());
    OpenMapRealVector res = new OpenMapRealVector(this);
    /*
         * MATH-803: it is not sufficient to loop through non zero entries of
         * this only. Indeed, if this[i] = 0d and v[i] = 0d, then
         * this[i] / v[i] = NaN, and not 0d.
         */
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));
    }
    return res;
}","/**
 * {@inheritDoc}
 */
","@Override
public OpenMapRealVector ebeDivide(RealVector v) {
    checkVectorDimensions(v.getDimension());
    OpenMapRealVector res = new OpenMapRealVector(this);
        Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));
    }
    return res;
}",-0.13636363636363635,-0.15311004784689008,-0.4,-0.5,-0.25,-0.041666666666666706,0.1357293868921775,0.3333333333333333,0.5,-0.05045786437532777
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3798_2ac1dccd,1,"/**
 * Get the revision of the latest change made to this node. At the same
 * time this method collects all collisions that happened for the given
 * {@code changeRev}. The reported latest change takes branches into
 * account. This means, if {@code changeRev} is on a branch, the latest
 * change is either a change that was done by a preceding branch commit or
 * a change that happened before the base of the branch. Changes done after
 * the branch base on trunk are not considered in this case. For a trunk
 * commit the latest change is reported similarly. In this case, unmerged
 * branch commits are not considered as latest change. Only commits to trunk
 * are considered.
 *
 * Collisions include the following cases:
 * <ul>
 *     <li>The other change is not yet committed</li>
 *     <li>The other change is a branch commit and not yet merged</li>
 *     <li>The {@code changeRev} is a branch commit and the other change
 *       happened after the base revision of the branch</li>
 *     <li>The other change is from another cluster node and not yet
 *       visible</li>
 * </ul>
 *
 * @param context the revision context.
 * @param baseRev the base revision of the current change.
 * @param changeRev the revision of the current change.
 * @param branch the branch associated with the current change or
 *              {@code null} if {@code changeRev} is not a branch commit.
 * @param collisions changes that happened after {@code baseRev}.
 */
@CheckForNull
Revision getNewestRevision(final RevisionContext context, final Revision baseRev, final Revision changeRev, final Branch branch, final Set<Revision> collisions) {
    checkArgument(!baseRev.isBranch() || branch != null, ""Branch must be non-null if baseRev is a branch revision"");
    Revision head = context.getHeadRevision();
    Revision lower = branch != null ? branch.getBase() : baseRev;
    // the clusterIds to check when walking the changes
    Set<Integer> clusterIds = Collections.emptySet();
    if (!getPreviousRanges().isEmpty()) {
        clusterIds = Sets.newHashSet();
        for (Revision prevRev : getPreviousRanges().keySet()) {
            if (!isRevisionNewer(context, lower, prevRev)) {
                clusterIds.add(prevRev.getClusterId());
            }
        }
    }
    // if we don't have clusterIds, we can use the local changes only
    boolean fullScan = true;
    Iterable<Revision> changes;
    if (clusterIds.isEmpty()) {
        // baseRev is newer than all previous documents
        changes = Iterables.mergeSorted(ImmutableList.of(getLocalRevisions().keySet(), getLocalCommitRoot().keySet()), getLocalRevisions().comparator());
    } else {
        // include previous documents as well (only needed in rare cases)
        fullScan = false;
        changes = getAllChanges();
        if (LOG.isDebugEnabled()) {
            LOG.debug(""getNewestRevision() with changeRev {} on {}, "" + ""_revisions {}, _commitRoot {}"", changeRev, getId(), getLocalRevisions(), getLocalCommitRoot());
        }
    }
    Map<Integer, Revision> newestRevs = Maps.newHashMap();
    Map<Revision, String> validRevisions = Maps.newHashMap();
    for (Revision r : changes) {
        if (r.equals(changeRev)) {
            continue;
        }
        if (!fullScan) {
            // check if we can stop going through changes
            if (clusterIds.contains(r.getClusterId())) {
                if (isRevisionNewer(context, lower, r)) {
                    clusterIds.remove(r.getClusterId());
                    if (clusterIds.isEmpty()) {
                        // the lower bound
                        break;
                    }
                }
            }
        }
        if (newestRevs.containsKey(r.getClusterId())) {
            // of the branch if this is for a commit on a branch
            if (branch != null && !branch.containsCommit(r)) {
                // change does not belong to the branch
                if (isRevisionNewer(context, r, branch.getBase())) {
                    // and happened after the base of the branch
                    collisions.add(r);
                }
            }
        } else {
            // check if change is visible from baseRev
            if (isValidRevision(context, r, null, baseRev, validRevisions)) {
                // consider for newestRev
                newestRevs.put(r.getClusterId(), r);
            } else {
                // not valid means:
                // 1) 'r' is not committed -> collision
                // 2) 'r' is on a branch, but not the same as
                // changeRev -> collisions
                // 3) changeRev is on a branch and 'r' is newer than
                // the base of the branch -> collision
                // 4) 'r' is committed but not yet visible to current
                // cluster node -> collisions
                // 5) changeRev is not on a branch, 'r' is committed and
                // newer than baseRev -> newestRev
                NodeDocument commitRoot = getCommitRoot(r);
                Revision commitRevision = null;
                if (commitRoot != null) {
                    commitRevision = commitRoot.getCommitRevision(r);
                }
                if (// committed but not yet visible
                commitRevision != null && isRevisionNewer(context, commitRevision, head)) {
                    // case 4)
                    collisions.add(r);
                } else if (// committed
                commitRevision != null && // changeRev not on branch
                branch == null && isRevisionNewer(context, r, baseRev)) {
                    // case 5)
                    newestRevs.put(r.getClusterId(), r);
                } else {
                    // remaining cases 1), 2) and 3)
                    collisions.add(r);
                }
            }
        }
    }
    // select the newest committed change
    Revision newestRev = null;
    for (Revision r : newestRevs.values()) {
        newestRev = Utils.max(newestRev, r, context.getRevisionComparator());
    }
    if (newestRev == null) {
        return null;
    }
    // the local deleted map contains the most recent revisions
    SortedMap<Revision, String> deleted = getLocalDeleted();
    String value = deleted.get(newestRev);
    if (value == null && deleted.headMap(newestRev).isEmpty()) {
        // no need to check previous docs
        return newestRev;
    }
    if (value == null) {
        // get from complete map
        value = getDeleted().get(newestRev);
    }
    if (""true"".equals(value)) {
        // deleted in the newest revision
        return null;
    }
    return newestRev;
}","/**
 * Get the revision of the latest change made to this node. At the same
 * time this method collects all collisions that happened for the given
 * {@code changeRev}. The reported latest change takes branches into
 * account. This means, if {@code changeRev} is on a branch, the latest
 * change is either a change that was done by a preceding branch commit or
 * a change that happened before the base of the branch. Changes done after
 * the branch base on trunk are not considered in this case. For a trunk
 * commit the latest change is reported similarly. In this case, unmerged
 * branch commits are not considered as latest change. Only commits to trunk
 * are considered.
 *
 * Collisions include the following cases:
 * <ul>
 *     <li>The other change is not yet committed</li>
 *     <li>The other change is a branch commit and not yet merged</li>
 *     <li>The {@code changeRev} is a branch commit and the other change
 *       happened after the base revision of the branch</li>
 *     <li>The other change is from another cluster node and not yet
 *       visible</li>
 * </ul>
 *
 * @param context the revision context.
 * @param baseRev the base revision of the current change.
 * @param changeRev the revision of the current change.
 * @param branch the branch associated with the current change or
 *              {@code null} if {@code changeRev} is not a branch commit.
 * @param collisions changes that happened after {@code baseRev}.
 */
","@CheckForNull
Revision getNewestRevision(final RevisionContext context, final Revision baseRev, final Revision changeRev, final Branch branch, final Set<Revision> collisions) {
    checkArgument(!baseRev.isBranch() || branch != null, ""Branch must be non-null if baseRev is a branch revision"");
    Revision head = context.getHeadRevision();
    Revision lower = branch != null ? branch.getBase() : baseRev;
        Set<Integer> clusterIds = Collections.emptySet();
    if (!getPreviousRanges().isEmpty()) {
        clusterIds = Sets.newHashSet();
        for (Revision prevRev : getPreviousRanges().keySet()) {
            if (!isRevisionNewer(context, lower, prevRev)) {
                clusterIds.add(prevRev.getClusterId());
            }
        }
    }
        boolean fullScan = true;
    Iterable<Revision> changes;
    if (clusterIds.isEmpty()) {
                changes = Iterables.mergeSorted(ImmutableList.of(getLocalRevisions().keySet(), getLocalCommitRoot().keySet()), getLocalRevisions().comparator());
    } else {
                fullScan = false;
        changes = getAllChanges();
        if (LOG.isDebugEnabled()) {
            LOG.debug(""getNewestRevision() with changeRev {} on {}, "" + ""_revisions {}, _commitRoot {}"", changeRev, getId(), getLocalRevisions(), getLocalCommitRoot());
        }
    }
    Map<Integer, Revision> newestRevs = Maps.newHashMap();
    Map<Revision, String> validRevisions = Maps.newHashMap();
    for (Revision r : changes) {
        if (r.equals(changeRev)) {
            continue;
        }
        if (!fullScan) {
                        if (clusterIds.contains(r.getClusterId())) {
                if (isRevisionNewer(context, lower, r)) {
                    clusterIds.remove(r.getClusterId());
                    if (clusterIds.isEmpty()) {
                                                break;
                    }
                }
            }
        }
        if (newestRevs.containsKey(r.getClusterId())) {
                        if (branch != null && !branch.containsCommit(r)) {
                                if (isRevisionNewer(context, r, branch.getBase())) {
                                        collisions.add(r);
                }
            }
        } else {
                        if (isValidRevision(context, r, null, baseRev, validRevisions)) {
                                newestRevs.put(r.getClusterId(), r);
            } else {
                                                                                                                                                                                NodeDocument commitRoot = getCommitRoot(r);
                Revision commitRevision = null;
                if (commitRoot != null) {
                    commitRevision = commitRoot.getCommitRevision(r);
                }
                if (                commitRevision != null && isRevisionNewer(context, commitRevision, head)) {
                                        collisions.add(r);
                } else if (                commitRevision != null &&                 branch == null && isRevisionNewer(context, r, baseRev)) {
                                        newestRevs.put(r.getClusterId(), r);
                } else {
                                        collisions.add(r);
                }
            }
        }
    }
        Revision newestRev = null;
    for (Revision r : newestRevs.values()) {
        newestRev = Utils.max(newestRev, r, context.getRevisionComparator());
    }
    if (newestRev == null) {
        return null;
    }
        SortedMap<Revision, String> deleted = getLocalDeleted();
    String value = deleted.get(newestRev);
    if (value == null && deleted.headMap(newestRev).isEmpty()) {
                return newestRev;
    }
    if (value == null) {
                value = getDeleted().get(newestRev);
    }
    if (""true"".equals(value)) {
                return null;
    }
    return newestRev;
}",3.409090909090909,1.3779904306220097,4.6,1.5,4.333333333333333,1.2837301587301588,-1.341930937279774,4.833333333333333,-0.02631578947368421,6.555149461454676
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2147_a1556c30,1,"/**
 * seek for an element in the index given the provided Predicate. If {@code walkedLanes} won't
 * be null it will have on the way out the last elements of each lane walked through during the
 * seek.
 *
 * @param index the index content node {@code :index}
 * @param condition the predicate to evaluate
 * @param walkedLanes if not null will contain the last element of the walked lanes with each
 *            lane represented by the corresponding position in the array. <b>You have</b> to
 *            pass in an array already sized as {@link OrderedIndex#LANES} or an
 *            {@link IllegalArgumentException} will be raised
 * @return the entry or null if not found
 */
String seek(@Nonnull final NodeBuilder index, @Nonnull final Predicate<String> condition, @Nullable final String[] walkedLanes) {
    boolean keepWalked = false;
    String searchfor = condition.getSearchFor();
    if (LOG.isDebugEnabled()) {
        LOG.debug(""seek() - Searching for: {}"", condition.getSearchFor());
        LOG.debug(""seek() - condition: {}"", condition);
    }
    Predicate<String> walkingPredicate = direction.isAscending() ? new PredicateLessThan(searchfor, true) : new PredicateGreaterThan(searchfor, true);
    // we always begin with :start
    String currentKey = START;
    String found = null;
    if (walkedLanes != null) {
        if (walkedLanes.length != OrderedIndex.LANES) {
            throw new IllegalArgumentException(String.format(""Wrong size for keeping track of the Walked Lanes. Expected %d but was %d"", OrderedIndex.LANES, walkedLanes.length));
        }
        // ensuring the right data
        for (int i = 0; i < walkedLanes.length; i++) {
            walkedLanes[i] = currentKey;
        }
        keepWalked = true;
    }
    int lane;
    boolean stillLaning;
    String nextkey;
    if ((direction.isAscending() && condition instanceof PredicateLessThan) || (direction.isDescending() && condition instanceof PredicateGreaterThan)) {
        // we're asking for a <, <= query from ascending index or >, >= from descending
        // we have to walk the lanes from bottom to up rather than up to bottom.
        LOG.debug(""seek() - cross case"");
        lane = 0;
        do {
            stillLaning = lane < OrderedIndex.LANES;
            nextkey = getPropertyNext(index.getChildNode(currentKey), lane);
            if ((Strings.isNullOrEmpty(nextkey) || !walkingPredicate.apply(nextkey)) && lane < OrderedIndex.LANES) {
                // if we're currently pointing to NIL or the next element does not fit the search
                // but we still have lanes left
                lane++;
            } else {
                if (condition.apply(nextkey)) {
                    found = nextkey;
                } else {
                    currentKey = nextkey;
                    if (keepWalked && !Strings.isNullOrEmpty(currentKey)) {
                        walkedLanes[lane] = currentKey;
                    }
                }
            }
        } while (((!Strings.isNullOrEmpty(nextkey) && walkingPredicate.apply(nextkey)) || stillLaning) && (found == null));
    } else {
        LOG.debug(""seek() - plain case"");
        lane = OrderedIndex.LANES - 1;
        do {
            stillLaning = lane > 0;
            nextkey = getPropertyNext(index.getChildNode(currentKey), lane);
            if ((Strings.isNullOrEmpty(nextkey) || !walkingPredicate.apply(nextkey)) && lane > 0) {
                // if we're currently pointing to NIL or the next element does not fit the search
                // but we still have lanes left, let's lower the lane;
                lane--;
            } else {
                if (condition.apply(nextkey)) {
                    found = nextkey;
                } else {
                    currentKey = nextkey;
                    if (keepWalked && !Strings.isNullOrEmpty(currentKey)) {
                        for (int l = lane; l >= 0; l--) {
                            walkedLanes[l] = currentKey;
                        }
                    }
                }
            }
        } while (((!Strings.isNullOrEmpty(nextkey) && walkingPredicate.apply(nextkey)) || stillLaning) && (found == null));
    }
    return found;
}","/**
 * seek for an element in the index given the provided Predicate. If {@code walkedLanes} won't
 * be null it will have on the way out the last elements of each lane walked through during the
 * seek.
 *
 * @param index the index content node {@code :index}
 * @param condition the predicate to evaluate
 * @param walkedLanes if not null will contain the last element of the walked lanes with each
 *            lane represented by the corresponding position in the array. <b>You have</b> to
 *            pass in an array already sized as {@link OrderedIndex#LANES} or an
 *            {@link IllegalArgumentException} will be raised
 * @return the entry or null if not found
 */
","String seek(@Nonnull final NodeBuilder index, @Nonnull final Predicate<String> condition, @Nullable final String[] walkedLanes) {
    boolean keepWalked = false;
    String searchfor = condition.getSearchFor();
    if (LOG.isDebugEnabled()) {
        LOG.debug(""seek() - Searching for: {}"", condition.getSearchFor());
        LOG.debug(""seek() - condition: {}"", condition);
    }
    Predicate<String> walkingPredicate = direction.isAscending() ? new PredicateLessThan(searchfor, true) : new PredicateGreaterThan(searchfor, true);
        String currentKey = START;
    String found = null;
    if (walkedLanes != null) {
        if (walkedLanes.length != OrderedIndex.LANES) {
            throw new IllegalArgumentException(String.format(""Wrong size for keeping track of the Walked Lanes. Expected %d but was %d"", OrderedIndex.LANES, walkedLanes.length));
        }
                for (int i = 0; i < walkedLanes.length; i++) {
            walkedLanes[i] = currentKey;
        }
        keepWalked = true;
    }
    int lane;
    boolean stillLaning;
    String nextkey;
    if ((direction.isAscending() && condition instanceof PredicateLessThan) || (direction.isDescending() && condition instanceof PredicateGreaterThan)) {
                        LOG.debug(""seek() - cross case"");
        lane = 0;
        do {
            stillLaning = lane < OrderedIndex.LANES;
            nextkey = getPropertyNext(index.getChildNode(currentKey), lane);
            if ((Strings.isNullOrEmpty(nextkey) || !walkingPredicate.apply(nextkey)) && lane < OrderedIndex.LANES) {
                                                lane++;
            } else {
                if (condition.apply(nextkey)) {
                    found = nextkey;
                } else {
                    currentKey = nextkey;
                    if (keepWalked && !Strings.isNullOrEmpty(currentKey)) {
                        walkedLanes[lane] = currentKey;
                    }
                }
            }
        } while (((!Strings.isNullOrEmpty(nextkey) && walkingPredicate.apply(nextkey)) || stillLaning) && (found == null));
    } else {
        LOG.debug(""seek() - plain case"");
        lane = OrderedIndex.LANES - 1;
        do {
            stillLaning = lane > 0;
            nextkey = getPropertyNext(index.getChildNode(currentKey), lane);
            if ((Strings.isNullOrEmpty(nextkey) || !walkingPredicate.apply(nextkey)) && lane > 0) {
                                                lane--;
            } else {
                if (condition.apply(nextkey)) {
                    found = nextkey;
                } else {
                    currentKey = nextkey;
                    if (keepWalked && !Strings.isNullOrEmpty(currentKey)) {
                        for (int l = lane; l >= 0; l--) {
                            walkedLanes[l] = currentKey;
                        }
                    }
                }
            }
        } while (((!Strings.isNullOrEmpty(nextkey) && walkingPredicate.apply(nextkey)) || stillLaning) && (found == null));
    }
    return found;
}",2.3181818181818183,1.7177033492822966,2.6,2.0,3.5833333333333335,4.063492063492063,-1.1057082452431288,1.75,-0.02631578947368421,14.725898007756895
wicket,remotes/origin/bugs-dot-jar_WICKET-3965_6051019b,1,"/**
 *  Gets a URL for the listener interface on a behavior (e.g. IBehaviorListener on
 *  AjaxPagingNavigationBehavior).
 *
 *  @param behaviour
 *             The behavior that the URL should point to
 *  @param listener
 *             The listener interface that the URL should call
 *  @return The URL
 */
public final CharSequence urlFor(final Behavior behaviour, final RequestListenerInterface listener) {
    PageAndComponentProvider provider = new PageAndComponentProvider(getPage(), this);
    int id = getBehaviorId(behaviour);
    IRequestHandler handler;
    if (getPage().isPageStateless()) {
        handler = new BookmarkableListenerInterfaceRequestHandler(provider, listener, id);
    } else {
        handler = new ListenerInterfaceRequestHandler(provider, listener, id);
    }
    return getRequestCycle().urlFor(handler);
}","/**
 *  Gets a URL for the listener interface on a behavior (e.g. IBehaviorListener on
 *  AjaxPagingNavigationBehavior).
 *
 *  @param behaviour
 *             The behavior that the URL should point to
 *  @param listener
 *             The listener interface that the URL should call
 *  @return The URL
 */
","public final CharSequence urlFor(final Behavior behaviour, final RequestListenerInterface listener) {
    PageAndComponentProvider provider = new PageAndComponentProvider(getPage(), this);
    int id = getBehaviorId(behaviour);
    IRequestHandler handler;
    if (getPage().isPageStateless()) {
        handler = new BookmarkableListenerInterfaceRequestHandler(provider, listener, id);
    } else {
        handler = new ListenerInterfaceRequestHandler(provider, listener, id);
    }
    return getRequestCycle().urlFor(handler);
}",-0.13636363636363635,-0.2775119617224881,-0.4,-0.5,-0.25,-0.3650793650793651,0.13629316420014115,0.0,0.39473684210526316,-0.16279340490885932
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-554_3f51fb09,1,"/**
 * Create a {@code PropertyState} based on a {@link Value}. The
 * {@link Type} of the property state is determined by the
 * type of the value.
 * @param name  The name of the property state
 * @param value  The value of the property state
 * @return  The new property state
 * @throws RepositoryException forwarded from {@code value}
 */
@Nonnull
public static PropertyState createProperty(String name, Value value) throws RepositoryException {
    int type = value.getType();
    switch(type) {
        case PropertyType.STRING:
            return StringPropertyState.stringProperty(name, value.getString());
        case PropertyType.BINARY:
            return BinaryPropertyState.binaryProperty(name, value);
        case PropertyType.LONG:
            return LongPropertyState.createLongProperty(name, value.getLong());
        case PropertyType.DOUBLE:
            return DoublePropertyState.doubleProperty(name, value.getDouble());
        case PropertyType.DATE:
            return LongPropertyState.createDateProperty(name, value.getLong());
        case PropertyType.BOOLEAN:
            return BooleanPropertyState.booleanProperty(name, value.getBoolean());
        case PropertyType.DECIMAL:
            return DecimalPropertyState.decimalProperty(name, value.getDecimal());
        default:
            return new GenericPropertyState(name, value.getString(), Type.fromTag(type, false));
    }
}","/**
 * Create a {@code PropertyState} based on a {@link Value}. The
 * {@link Type} of the property state is determined by the
 * type of the value.
 * @param name  The name of the property state
 * @param value  The value of the property state
 * @return  The new property state
 * @throws RepositoryException forwarded from {@code value}
 */
","@Nonnull
public static PropertyState createProperty(String name, Value value) throws RepositoryException {
    int type = value.getType();
    switch(type) {
        case PropertyType.STRING:
            return StringPropertyState.stringProperty(name, value.getString());
        case PropertyType.BINARY:
            return BinaryPropertyState.binaryProperty(name, value);
        case PropertyType.LONG:
            return LongPropertyState.createLongProperty(name, value.getLong());
        case PropertyType.DOUBLE:
            return DoublePropertyState.doubleProperty(name, value.getDouble());
        case PropertyType.DATE:
            return LongPropertyState.createDateProperty(name, value.getLong());
        case PropertyType.BOOLEAN:
            return BooleanPropertyState.booleanProperty(name, value.getBoolean());
        case PropertyType.DECIMAL:
            return DecimalPropertyState.decimalProperty(name, value.getDecimal());
        default:
            return new GenericPropertyState(name, value.getString(), Type.fromTag(type, false));
    }
}",0.36363636363636365,0.5263157894736841,1.0,0.0,0.25,-0.3650793650793651,-0.3620859760394643,0.8333333333333334,-0.02631578947368421,-0.16279340490885932
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-217_46f62443,1,"@Override
public Set<String> listIterators(String tableName) throws AccumuloSecurityException, AccumuloException, TableNotFoundException {
    Set<String> result = new HashSet<String>();
    Set<String> lifecycles = new HashSet<String>();
    for (IteratorScope scope : IteratorScope.values()) lifecycles.add(scope.name().toLowerCase());
    for (Entry<String, String> property : this.getProperties(tableName)) {
        String name = property.getKey();
        String[] parts = name.split(""\\."");
        if (parts.length == 4) {
            if (parts[0].equals(""table"") && parts[1].equals(""iterator"") && lifecycles.contains(parts[2]))
                result.add(parts[3]);
        }
    }
    return result;
}",,"@Override
public Set<String> listIterators(String tableName) throws AccumuloSecurityException, AccumuloException, TableNotFoundException {
    Set<String> result = new HashSet<String>();
    Set<String> lifecycles = new HashSet<String>();
    for (IteratorScope scope : IteratorScope.values()) lifecycles.add(scope.name().toLowerCase());
    for (Entry<String, String> property : this.getProperties(tableName)) {
        String name = property.getKey();
        String[] parts = name.split(""\\."");
        if (parts.length == 4) {
            if (parts[0].equals(""table"") && parts[1].equals(""iterator"") && lifecycles.contains(parts[2]))
                result.add(parts[3]);
        }
    }
    return result;
}",0.045454545454545456,0.6411483253588517,0.2,0.0,0.25,-0.0019841269841269858,-0.1571529245947851,0.4166666666666667,-0.02631578947368421,0.14689695314165843
wicket,remotes/origin/bugs-dot-jar_WICKET-2506_0f8a2990,1,"@Override
protected void onDetach() {
    restoreOriginalChildVisibility();
    super.onDetach();
}",,"@Override
protected void onDetach() {
    restoreOriginalChildVisibility();
    super.onDetach();
}",-0.4090909090909091,-0.49282296650717716,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.8985200845665959,-0.3333333333333333,0.9736842105263158,-0.16279340490885932
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1655_c91bfa54,1,"@Override
public Iterator<String> getAllChunkIds(final long maxLastModifiedTime) throws Exception {
    return transform(filter(delegate.getAllIdentifiers(), new Predicate<DataIdentifier>() {

        @Override
        public boolean apply(DataIdentifier input) {
            try {
                DataRecord dr = delegate.getRecord(input);
                if (dr != null && dr.getLastModified() < maxLastModifiedTime) {
                    return true;
                }
            } catch (DataStoreException e) {
                log.warn(""Error occurred while fetching DataRecord for identifier {}"", input, e);
            }
            return false;
        }
    }), new Function<DataIdentifier, String>() {

        @Override
        public String apply(DataIdentifier input) {
            return input.toString();
        }
    });
}",,"@Override
public Iterator<String> getAllChunkIds(final long maxLastModifiedTime) throws Exception {
    return transform(filter(delegate.getAllIdentifiers(), new Predicate<DataIdentifier>() {

        @Override
        public boolean apply(DataIdentifier input) {
            try {
                DataRecord dr = delegate.getRecord(input);
                if (dr != null && dr.getLastModified() < maxLastModifiedTime) {
                    return true;
                }
            } catch (DataStoreException e) {
                log.warn(""Error occurred while fetching DataRecord for identifier {}"", input, e);
            }
            return false;
        }
    }), new Function<DataIdentifier, String>() {

        @Override
        public String apply(DataIdentifier input) {
            return input.toString();
        }
    });
}",0.36363636363636365,1.2392344497607655,-0.2,0.5,0.0,0.26388888888888884,-0.26398872445384053,0.08333333333333333,0.0,0.2061029373627703
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1822_016df669,1,"/**
 * Remove a map entry.
 * The property is a map of revisions / values.
 *
 * @param property the property
 * @param revision the revision
 */
public void removeMapEntry(@Nonnull String property, @Nonnull Revision revision) {
    Operation op = new Operation();
    op.type = Operation.Type.REMOVE_MAP_ENTRY;
    changes.put(new Key(property, checkNotNull(revision)), op);
}","/**
 * Remove a map entry.
 * The property is a map of revisions / values.
 *
 * @param property the property
 * @param revision the revision
 */
","public void removeMapEntry(@Nonnull String property, @Nonnull Revision revision) {
    Operation op = new Operation();
    op.type = Operation.Type.REMOVE_MAP_ENTRY;
    changes.put(new Key(property, checkNotNull(revision)), op);
}",-0.4090909090909091,-0.49282296650717716,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.55799859055673,-0.3333333333333333,2.289473684210526,-0.16279340490885932
Closure,3,1,"private boolean canInline() {
    // Cannot inline a parameter.
    if (getDefCfgNode().isFunction()) {
        return false;
    }
    // so we just back off for now.
    for (Var dependency : defMetadata.depends) {
        if (inlinedNewDependencies.contains(dependency)) {
            return false;
        }
    }
    getDefinition(getDefCfgNode(), null);
    getNumUseInUseCfgNode(useCfgNode, null);
    // Definition was not found.
    if (def == null) {
        return false;
    }
    // TODO(user): Certain cases we can still inline.
    if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {
        return false;
    }
    // x = readProp(b), modifyProp(b); print(x);
    if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {
        return false;
    }
    // x = readProp(b); modifyProp(b), print(x);
    if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {
        return false;
    }
    // side-effect analysis tool.
    if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {
        return false;
    }
    // correctly inlining twice increases code size.
    if (numUseWithinUseCfgNode != 1) {
        return false;
    }
    // Make sure that the name is not within a loop
    if (NodeUtil.isWithinLoop(use)) {
        return false;
    }
    Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());
    if (uses.size() != 1) {
        return false;
    }
    // need to be special cased.
    if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {

        @Override
        public boolean apply(Node input) {
            switch(input.getType()) {
                case Token.GETELEM:
                case Token.GETPROP:
                case Token.ARRAYLIT:
                case Token.OBJECTLIT:
                case Token.REGEXP:
                case Token.NEW:
                    return true;
            }
            return false;
        }
    }, new Predicate<Node>() {

        @Override
        public boolean apply(Node input) {
            // Recurse if the node is not a function.
            return !input.isFunction();
        }
    })) {
        return false;
    }
    // they are just next to each other.
    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {
        // Similar side effect check as above but this time the side effect is
        // else where along the path.
        // x = readProp(b); while(modifyProp(b)) {}; print(x);
        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);
        if (pathCheck.somePathsSatisfyPredicate()) {
            return false;
        }
    }
    return true;
}",,"private boolean canInline() {
        if (getDefCfgNode().isFunction()) {
        return false;
    }
        for (Var dependency : defMetadata.depends) {
        if (inlinedNewDependencies.contains(dependency)) {
            return false;
        }
    }
    getDefinition(getDefCfgNode(), null);
    getNumUseInUseCfgNode(useCfgNode, null);
        if (def == null) {
        return false;
    }
        if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {
        return false;
    }
        if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {
        return false;
    }
        if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {
        return false;
    }
        if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {
        return false;
    }
        if (numUseWithinUseCfgNode != 1) {
        return false;
    }
        if (NodeUtil.isWithinLoop(use)) {
        return false;
    }
    Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());
    if (uses.size() != 1) {
        return false;
    }
        if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {

        @Override
        public boolean apply(Node input) {
            switch(input.getType()) {
                case Token.GETELEM:
                case Token.GETPROP:
                case Token.ARRAYLIT:
                case Token.OBJECTLIT:
                case Token.REGEXP:
                case Token.NEW:
                    return true;
            }
            return false;
        }
    }, new Predicate<Node>() {

        @Override
        public boolean apply(Node input) {
                        return !input.isFunction();
        }
    })) {
        return false;
    }
        if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {
                                CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);
        if (pathCheck.somePathsSatisfyPredicate()) {
            return false;
        }
    }
    return true;
}",2.3636363636363638,0.6028708133971291,3.4,1.0,3.3333333333333335,0.4722222222222222,-1.0639887244538404,2.1666666666666665,-0.02631578947368421,1.5317231721443263
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1363_69b68890,0,"/**
 * Create the {@code AuthInfo} for the specified {@code tokenInfo} as well as
 * userId and principals, that have been set upon {@link #login}.
 *
 * @param tokenInfo The tokenInfo to retrieve attributes from.
 * @return The {@code AuthInfo} resulting from the successful login.
 */
@Nonnull
private AuthInfo getAuthInfo(TokenInfo tokenInfo) {
    Map<String, Object> attributes = new HashMap<String, Object>();
    if (tokenProvider != null && tokenInfo != null) {
        Map<String, String> publicAttributes = tokenInfo.getPublicAttributes();
        for (String attrName : publicAttributes.keySet()) {
            attributes.put(attrName, publicAttributes.get(attrName));
        }
    }
    return new AuthInfoImpl(userId, attributes, principals);
}","/**
 * Create the {@code AuthInfo} for the specified {@code tokenInfo} as well as
 * userId and principals, that have been set upon {@link #login}.
 *
 * @param tokenInfo The tokenInfo to retrieve attributes from.
 * @return The {@code AuthInfo} resulting from the successful login.
 */
","@Nonnull
private AuthInfo getAuthInfo(TokenInfo tokenInfo) {
    Map<String, Object> attributes = new HashMap<String, Object>();
    if (tokenProvider != null && tokenInfo != null) {
        Map<String, String> publicAttributes = tokenInfo.getPublicAttributes();
        for (String attrName : publicAttributes.keySet()) {
            attributes.put(attrName, publicAttributes.get(attrName));
        }
    }
    return new AuthInfoImpl(userId, attributes, principals);
}",-0.13636363636363635,0.35885167464114837,-0.2,0.0,-0.08333333333333333,-0.03174603174603177,0.09006342494714606,-0.16666666666666666,0.05263157894736841,-0.011560427147986165
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-217_46f62443,1,"@Override
public void addSplits(String tableName, SortedSet<Text> partitionKeys) throws TableNotFoundException, AccumuloException, AccumuloSecurityException {
}",,"@Override
public void addSplits(String tableName, SortedSet<Text> partitionKeys) throws TableNotFoundException, AccumuloException, AccumuloSecurityException {
}",-0.5,-1.4306220095693782,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.9360112755461594,-0.5,0.10526315789473684,-0.16279340490885932
camel,remotes/origin/bugs-dot-jar_CAMEL-3757_c1b2f2f8,3,"public void process(Exchange exchange) throws Exception {
    // process the detour so we do the detour routing
    if (LOG.isDebugEnabled()) {
        LOG.debug(""Sending to endpoint: "" + getEndpointUri() + "" is intercepted and detoured to: "" + detour + "" for exchange: "" + exchange);
    }
    // add header with the real endpoint uri
    exchange.getIn().setHeader(Exchange.INTERCEPTED_ENDPOINT, delegate.getEndpointUri());
    try {
        detour.process(exchange);
    } catch (Exception e) {
        exchange.setException(e);
    }
    // check for error if so we should break out
    if (!continueProcessing(exchange, ""skip sending to original intended destination: "" + getEndpointUri(), LOG)) {
        return;
    }
    if (!skip) {
        if (exchange.hasOut()) {
            // replace OUT with IN as detour changed something
            exchange.setIn(exchange.getOut());
            exchange.setOut(null);
        }
        // route to original destination
        producer.process(exchange);
    } else {
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Stop() means skip sending exchange to original intended destination: "" + getEndpointUri() + "" for exchange: "" + exchange);
        }
    }
}",,"public void process(Exchange exchange) throws Exception {
        if (LOG.isDebugEnabled()) {
        LOG.debug(""Sending to endpoint: "" + getEndpointUri() + "" is intercepted and detoured to: "" + detour + "" for exchange: "" + exchange);
    }
        exchange.getIn().setHeader(Exchange.INTERCEPTED_ENDPOINT, delegate.getEndpointUri());
    try {
        detour.process(exchange);
    } catch (Exception e) {
        exchange.setException(e);
    }
        if (!continueProcessing(exchange, ""skip sending to original intended destination: "" + getEndpointUri(), LOG)) {
        return;
    }
    if (!skip) {
        if (exchange.hasOut()) {
                        exchange.setIn(exchange.getOut());
            exchange.setOut(null);
        }
                producer.process(exchange);
    } else {
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Stop() means skip sending exchange to original intended destination: "" + getEndpointUri() + "" for exchange: "" + exchange);
        }
    }
}",0.5,0.11004784688995216,0.6,0.0,0.5,0.01785714285714283,-0.37477096546863986,1.0,-0.02631578947368421,0.10625219711507984
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-225_e33328e0,3,"private Expression parseFunction(String functionName) throws ParseException {
    if (""jcr:like"".equals(functionName)) {
        Condition c = new Condition(parseExpression(), ""like"", null);
        read("","");
        c.right = parseExpression();
        read("")"");
        return c;
    } else if (""jcr:contains"".equals(functionName)) {
        Function f = new Function(""contains"");
        if (readIf(""."")) {
            // special case: jcr:contains(., expr)
            f.params.add(new Literal(""*""));
        } else {
            f.params.add(parseExpression());
        }
        read("","");
        f.params.add(parseExpression());
        read("")"");
        return f;
    } else if (""jcr:score"".equals(functionName)) {
        Function f = new Function(""score"");
        // TODO score: support parameters?
        read("")"");
        return f;
    } else if (""xs:dateTime"".equals(functionName)) {
        Expression expr = parseExpression();
        Cast c = new Cast(expr, ""date"");
        read("")"");
        return c;
    // } else if (""jcr:deref"".equals(functionName)) {
    // TODO support jcr:deref?
    } else {
        throw getSyntaxError(""jcr:like | jcr:contains | jcr:score | jcr:deref"");
    }
}",,"private Expression parseFunction(String functionName) throws ParseException {
    if (""jcr:like"".equals(functionName)) {
        Condition c = new Condition(parseExpression(), ""like"", null);
        read("","");
        c.right = parseExpression();
        read("")"");
        return c;
    } else if (""jcr:contains"".equals(functionName)) {
        Function f = new Function(""contains"");
        if (readIf(""."")) {
                        f.params.add(new Literal(""*""));
        } else {
            f.params.add(parseExpression());
        }
        read("","");
        f.params.add(parseExpression());
        read("")"");
        return f;
    } else if (""jcr:score"".equals(functionName)) {
        Function f = new Function(""score"");
                read("")"");
        return f;
    } else if (""xs:dateTime"".equals(functionName)) {
        Expression expr = parseExpression();
        Cast c = new Cast(expr, ""date"");
        read("")"");
        return c;
            } else {
        throw getSyntaxError(""jcr:like | jcr:contains | jcr:score | jcr:deref"");
    }
}",0.7727272727272727,-0.14832535885167467,0.6,1.0,0.5,-0.3650793650793651,-0.5227625088090203,1.1666666666666667,-0.02631578947368421,-0.16279340490885932
wicket,remotes/origin/bugs-dot-jar_WICKET-5460_a3a5a40f,1,"/**
 *  @param setRenderingFlag
 *             rendering flag
 */
void internalMarkRendering(boolean setRenderingFlag) {
    if (setRenderingFlag) {
        setFlag(FLAG_PREPARED_FOR_RENDER, false);
        setFlag(FLAG_RENDERING, true);
    } else {
        setFlag(FLAG_RENDERING, false);
    }
}","/**
 *  @param setRenderingFlag
 *             rendering flag
 */
","void internalMarkRendering(boolean setRenderingFlag) {
    if (setRenderingFlag) {
        setFlag(FLAG_PREPARED_FOR_RENDER, false);
        setFlag(FLAG_RENDERING, true);
    } else {
        setFlag(FLAG_RENDERING, false);
    }
}",-0.2727272727272727,0.06220095693779899,-0.4,-0.5,-0.25,-0.3650793650793651,0.4779422128259336,-0.25,2.3421052631578947,-0.16279340490885932
Closure,158,2,"/**
 * Sets options based on the configurations set flags API.
 * Called during the run() run() method.
 * If you want to ignore the flags API, or intepret flags your own way,
 * then you should override this method.
 */
protected final void setRunOptions(CompilerOptions options) throws FlagUsageException, IOException {
    DiagnosticGroups diagnosticGroups = getDiagnosticGroups();
    diagnosticGroups.setWarningLevels(options, config.jscompError, CheckLevel.ERROR);
    diagnosticGroups.setWarningLevels(options, config.jscompWarning, CheckLevel.WARNING);
    diagnosticGroups.setWarningLevels(options, config.jscompOff, CheckLevel.OFF);
    createDefineOrTweakReplacements(config.define, options, false);
    options.setTweakProcessing(config.tweakProcessing);
    createDefineOrTweakReplacements(config.tweak, options, true);
    options.manageClosureDependencies = config.manageClosureDependencies;
    if (config.closureEntryPoints.size() > 0) {
        options.setManageClosureDependencies(config.closureEntryPoints);
    }
    options.devMode = config.jscompDevMode;
    options.setCodingConvention(config.codingConvention);
    options.setSummaryDetailLevel(config.summaryDetailLevel);
    outputCharset = options.outputCharset = getOutputCharset();
    inputCharset = getInputCharset();
    if (config.jsOutputFile.length() > 0) {
        options.jsOutputFile = config.jsOutputFile;
    }
    if (config.createSourceMap.length() > 0) {
        options.sourceMapOutputPath = config.createSourceMap;
    }
    options.sourceMapDetailLevel = config.sourceMapDetailLevel;
    options.sourceMapFormat = config.sourceMapFormat;
    if (!config.variableMapInputFile.equals("""")) {
        options.inputVariableMapSerialized = VariableMap.load(config.variableMapInputFile).toBytes();
    }
    if (!config.propertyMapInputFile.equals("""")) {
        options.inputPropertyMapSerialized = VariableMap.load(config.propertyMapInputFile).toBytes();
    }
    if (config.languageIn.length() > 0) {
        if (config.languageIn.equals(""ECMASCRIPT5_STRICT"") || config.languageIn.equals(""ES5_STRICT"")) {
            options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT5);
        } else if (config.languageIn.equals(""ECMASCRIPT5"") || config.languageIn.equals(""ES5"")) {
            options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT5);
        } else if (config.languageIn.equals(""ECMASCRIPT3"") || config.languageIn.equals(""ES3"")) {
            options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT3);
        } else {
            throw new FlagUsageException(""Unknown language `"" + config.languageIn + ""' specified."");
        }
    }
    options.acceptConstKeyword = config.acceptConstKeyword;
}","/**
 * Sets options based on the configurations set flags API.
 * Called during the run() run() method.
 * If you want to ignore the flags API, or intepret flags your own way,
 * then you should override this method.
 */
","protected final void setRunOptions(CompilerOptions options) throws FlagUsageException, IOException {
    DiagnosticGroups diagnosticGroups = getDiagnosticGroups();
    diagnosticGroups.setWarningLevels(options, config.jscompError, CheckLevel.ERROR);
    diagnosticGroups.setWarningLevels(options, config.jscompWarning, CheckLevel.WARNING);
    diagnosticGroups.setWarningLevels(options, config.jscompOff, CheckLevel.OFF);
    createDefineOrTweakReplacements(config.define, options, false);
    options.setTweakProcessing(config.tweakProcessing);
    createDefineOrTweakReplacements(config.tweak, options, true);
    options.manageClosureDependencies = config.manageClosureDependencies;
    if (config.closureEntryPoints.size() > 0) {
        options.setManageClosureDependencies(config.closureEntryPoints);
    }
    options.devMode = config.jscompDevMode;
    options.setCodingConvention(config.codingConvention);
    options.setSummaryDetailLevel(config.summaryDetailLevel);
    outputCharset = options.outputCharset = getOutputCharset();
    inputCharset = getInputCharset();
    if (config.jsOutputFile.length() > 0) {
        options.jsOutputFile = config.jsOutputFile;
    }
    if (config.createSourceMap.length() > 0) {
        options.sourceMapOutputPath = config.createSourceMap;
    }
    options.sourceMapDetailLevel = config.sourceMapDetailLevel;
    options.sourceMapFormat = config.sourceMapFormat;
    if (!config.variableMapInputFile.equals("""")) {
        options.inputVariableMapSerialized = VariableMap.load(config.variableMapInputFile).toBytes();
    }
    if (!config.propertyMapInputFile.equals("""")) {
        options.inputPropertyMapSerialized = VariableMap.load(config.propertyMapInputFile).toBytes();
    }
    if (config.languageIn.length() > 0) {
        if (config.languageIn.equals(""ECMASCRIPT5_STRICT"") || config.languageIn.equals(""ES5_STRICT"")) {
            options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT5);
        } else if (config.languageIn.equals(""ECMASCRIPT5"") || config.languageIn.equals(""ES5"")) {
            options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT5);
        } else if (config.languageIn.equals(""ECMASCRIPT3"") || config.languageIn.equals(""ES3"")) {
            options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT3);
        } else {
            throw new FlagUsageException(""Unknown language `"" + config.languageIn + ""' specified."");
        }
    }
    options.acceptConstKeyword = config.acceptConstKeyword;
}",1.3636363636363635,-0.07177033492822985,1.4,1.0,1.5833333333333333,0.6527777777777778,-0.8615926708949962,2.0833333333333335,-0.02631578947368421,2.685147213914005
wicket,remotes/origin/bugs-dot-jar_WICKET-4365_1485a856,1,"/**
 *  Process the form. Though you can override this method to provide your own algorithm, it is
 *  not recommended to do so.
 *
 *  <p>
 *  See the class documentation for further details on the form processing
 *  </p>
 *
 *  @param submittingComponent
 *             component responsible for submitting the form, or <code>null</code> if none (eg
 *             the form has been submitted via the enter key or javascript calling
 *             form.onsubmit())
 *
 *  @see #delegateSubmit(IFormSubmitter) for an easy way to process submitting component in the
 *       default manner
 */
public void process(IFormSubmitter submittingComponent) {
    // save the page in case the component is removed during submit
    final Page page = getPage();
    String hiddenFieldId = getHiddenFieldId();
    if (!isEnabledInHierarchy() || !isVisibleInHierarchy()) {
        // FIXME throw listener exception
        return;
    }
    // run validation
    validate();
    // If a validation error occurred
    if (hasError()) {
        // mark all children as invalid
        markFormComponentsInvalid();
        // let subclass handle error
        callOnError(submittingComponent);
    } else {
        // mark all children as valid
        markFormComponentsValid();
        // before updating, call the interception method for clients
        beforeUpdateFormComponentModels();
        // Update model using form data
        updateFormComponentModels();
        // validate model objects after input values have been bound
        onValidateModelObjects();
        if (hasError()) {
            callOnError(submittingComponent);
            return;
        }
        // Form has no error
        delegateSubmit(submittingComponent);
    }
}","/**
 *  Process the form. Though you can override this method to provide your own algorithm, it is
 *  not recommended to do so.
 *
 *  <p>
 *  See the class documentation for further details on the form processing
 *  </p>
 *
 *  @param submittingComponent
 *             component responsible for submitting the form, or <code>null</code> if none (eg
 *             the form has been submitted via the enter key or javascript calling
 *             form.onsubmit())
 *
 *  @see #delegateSubmit(IFormSubmitter) for an easy way to process submitting component in the
 *       default manner
 */
","public void process(IFormSubmitter submittingComponent) {
        final Page page = getPage();
    String hiddenFieldId = getHiddenFieldId();
    if (!isEnabledInHierarchy() || !isVisibleInHierarchy()) {
                return;
    }
        validate();
        if (hasError()) {
                markFormComponentsInvalid();
                callOnError(submittingComponent);
    } else {
                markFormComponentsValid();
                beforeUpdateFormComponentModels();
                updateFormComponentModels();
                onValidateModelObjects();
        if (hasError()) {
            callOnError(submittingComponent);
            return;
        }
                delegateSubmit(submittingComponent);
    }
}",0.36363636363636365,0.0669856459330142,0.0,0.0,0.16666666666666666,-0.11904761904761907,-0.18646934460887932,0.75,0.0,-0.08166064441025109
camel,remotes/origin/bugs-dot-jar_CAMEL-5515_b3bb8670,1,"/**
 * Continues processing the {@link org.apache.camel.Exchange} using asynchronous routing engine.
 *
 * @param poolSize    the core pool size
 * @param maxPoolSize the maximum pool size
 * @param threadName the thread pool name
 * @return the builder
 */
public ThreadsDefinition threads(int poolSize, int maxPoolSize, String threadName) {
    ThreadsDefinition answer = threads();
    answer.setPoolSize(poolSize);
    answer.setMaxPoolSize(maxPoolSize);
    answer.setThreadName(threadName);
    addOutput(answer);
    return answer;
}","/**
 * Continues processing the {@link org.apache.camel.Exchange} using asynchronous routing engine.
 *
 * @param poolSize    the core pool size
 * @param maxPoolSize the maximum pool size
 * @param threadName the thread pool name
 * @return the builder
 */
","public ThreadsDefinition threads(int poolSize, int maxPoolSize, String threadName) {
    ThreadsDefinition answer = threads();
    answer.setPoolSize(poolSize);
    answer.setMaxPoolSize(maxPoolSize);
    answer.setThreadName(threadName);
    addOutput(answer);
    return answer;
}",-0.2727272727272727,-0.6028708133971293,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.3699788583509513,-0.08333333333333333,1.4999999999999998,-0.16279340490885932
commons-math,remotes/origin/bugs-dot-jar_MATH-290_b01fcc31,1,"/**
 * Create the tableau by itself.
 * @param maximize if true, goal is to maximize the objective function
 * @return created tableau
 */
protected double[][] createTableau(final boolean maximize) {
    // create a matrix of the correct size
    List<LinearConstraint> constraints = getNormalizedConstraints();
    int width = numDecisionVariables + numSlackVariables + numArtificialVariables + getNumObjectiveFunctions() + // + 1 is for RHS
    1;
    int height = constraints.size() + getNumObjectiveFunctions();
    double[][] matrix = new double[height][width];
    // initialize the objective function rows
    if (getNumObjectiveFunctions() == 2) {
        matrix[0][0] = -1;
    }
    int zIndex = (getNumObjectiveFunctions() == 1) ? 0 : 1;
    matrix[zIndex][zIndex] = maximize ? 1 : -1;
    RealVector objectiveCoefficients = maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients();
    copyArray(objectiveCoefficients.getData(), matrix[zIndex], getNumObjectiveFunctions());
    matrix[zIndex][width - 1] = maximize ? f.getConstantTerm() : -1 * f.getConstantTerm();
    if (!restrictToNonNegative) {
        matrix[zIndex][getSlackVariableOffset() - 1] = getInvertedCoeffiecientSum(objectiveCoefficients);
    }
    // initialize the constraint rows
    int slackVar = 0;
    int artificialVar = 0;
    for (int i = 0; i < constraints.size(); i++) {
        LinearConstraint constraint = constraints.get(i);
        int row = getNumObjectiveFunctions() + i;
        // decision variable coefficients
        copyArray(constraint.getCoefficients().getData(), matrix[row], 1);
        // x-
        if (!restrictToNonNegative) {
            matrix[row][getSlackVariableOffset() - 1] = getInvertedCoeffiecientSum(constraint.getCoefficients());
        }
        // RHS
        matrix[row][width - 1] = constraint.getValue();
        // slack variables
        if (constraint.getRelationship() == Relationship.LEQ) {
            // slack
            matrix[row][getSlackVariableOffset() + slackVar++] = 1;
        } else if (constraint.getRelationship() == Relationship.GEQ) {
            // excess
            matrix[row][getSlackVariableOffset() + slackVar++] = -1;
        }
        // artificial variables
        if ((constraint.getRelationship() == Relationship.EQ) || (constraint.getRelationship() == Relationship.GEQ)) {
            matrix[0][getArtificialVariableOffset() + artificialVar] = 1;
            matrix[row][getArtificialVariableOffset() + artificialVar++] = 1;
        }
    }
    return matrix;
}","/**
 * Create the tableau by itself.
 * @param maximize if true, goal is to maximize the objective function
 * @return created tableau
 */
","protected double[][] createTableau(final boolean maximize) {
        List<LinearConstraint> constraints = getNormalizedConstraints();
    int width = numDecisionVariables + numSlackVariables + numArtificialVariables + getNumObjectiveFunctions() +     1;
    int height = constraints.size() + getNumObjectiveFunctions();
    double[][] matrix = new double[height][width];
        if (getNumObjectiveFunctions() == 2) {
        matrix[0][0] = -1;
    }
    int zIndex = (getNumObjectiveFunctions() == 1) ? 0 : 1;
    matrix[zIndex][zIndex] = maximize ? 1 : -1;
    RealVector objectiveCoefficients = maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients();
    copyArray(objectiveCoefficients.getData(), matrix[zIndex], getNumObjectiveFunctions());
    matrix[zIndex][width - 1] = maximize ? f.getConstantTerm() : -1 * f.getConstantTerm();
    if (!restrictToNonNegative) {
        matrix[zIndex][getSlackVariableOffset() - 1] = getInvertedCoeffiecientSum(objectiveCoefficients);
    }
        int slackVar = 0;
    int artificialVar = 0;
    for (int i = 0; i < constraints.size(); i++) {
        LinearConstraint constraint = constraints.get(i);
        int row = getNumObjectiveFunctions() + i;
                copyArray(constraint.getCoefficients().getData(), matrix[row], 1);
                if (!restrictToNonNegative) {
            matrix[row][getSlackVariableOffset() - 1] = getInvertedCoeffiecientSum(constraint.getCoefficients());
        }
                matrix[row][width - 1] = constraint.getValue();
                if (constraint.getRelationship() == Relationship.LEQ) {
                        matrix[row][getSlackVariableOffset() + slackVar++] = 1;
        } else if (constraint.getRelationship() == Relationship.GEQ) {
                        matrix[row][getSlackVariableOffset() + slackVar++] = -1;
        }
                if ((constraint.getRelationship() == Relationship.EQ) || (constraint.getRelationship() == Relationship.GEQ)) {
            matrix[0][getArtificialVariableOffset() + artificialVar] = 1;
            matrix[row][getArtificialVariableOffset() + artificialVar++] = 1;
        }
    }
    return matrix;
}",1.1363636363636365,0.06220095693779899,1.6,0.5,1.0833333333333333,2.3115079365079367,-0.8026779422128256,2.3333333333333335,-0.02631578947368421,6.820608219083348
wicket,remotes/origin/bugs-dot-jar_WICKET-172_99e22ce4,1,"/**
 *  @return iterator over item instances that exist as children of this view
 */
public Iterator<Item<T>> getItems() {
    final Iterator<Component> iterator = iterator();
    return new Iterator<Item<T>>() {

        public boolean hasNext() {
            return iterator.hasNext();
        }

        public Item<T> next() {
            return (Item<T>) iterator.next();
        }

        public void remove() {
            iterator.remove();
        }
    };
}","/**
 *  @return iterator over item instances that exist as children of this view
 */
","public Iterator<Item<T>> getItems() {
    final Iterator<Component> iterator = iterator();
    return new Iterator<Item<T>>() {

        public boolean hasNext() {
            return iterator.hasNext();
        }

        public Item<T> next() {
            return (Item<T>) iterator.next();
        }

        public void remove() {
            iterator.remove();
        }
    };
}",0.0,0.40191387559808606,-0.6,-0.5,-0.4166666666666667,-0.3650793650793651,0.1064129668780833,-0.16666666666666666,1.0526315789473684,-0.16279340490885932
Compress,45,3,"/**
 * Write an long integer into a buffer as an octal string if this
 * will fit, or as a binary number otherwise.
 *
 * Uses {@link #formatUnsignedOctalString} to format
 * the value as an octal string with leading zeros.
 * The converted number is followed by a space.
 *
 * @param value The value to write into the buffer.
 * @param buf The destination buffer.
 * @param offset The starting offset into the buffer.
 * @param length The length of the buffer.
 * @return The updated offset.
 * @throws IllegalArgumentException if the value (and trailer)
 * will not fit in the buffer.
 * @since 1.4
 */
public static int formatLongOctalOrBinaryBytes(final long value, final byte[] buf, final int offset, final int length) {
    // Check whether we are dealing with UID/GID or SIZE field
    final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;
    final boolean negative = value < 0;
    if (!negative && value <= maxAsOctalChar) {
        // OK to store as octal chars
        return formatLongOctalBytes(value, buf, offset, length);
    }
    if (length < 9) {
        formatLongBinary(value, buf, offset, length, negative);
    }
    formatBigIntegerBinary(value, buf, offset, length, negative);
    buf[offset] = (byte) (negative ? 0xff : 0x80);
    return offset + length;
}","/**
 * Write an long integer into a buffer as an octal string if this
 * will fit, or as a binary number otherwise.
 *
 * Uses {@link #formatUnsignedOctalString} to format
 * the value as an octal string with leading zeros.
 * The converted number is followed by a space.
 *
 * @param value The value to write into the buffer.
 * @param buf The destination buffer.
 * @param offset The starting offset into the buffer.
 * @param length The length of the buffer.
 * @return The updated offset.
 * @throws IllegalArgumentException if the value (and trailer)
 * will not fit in the buffer.
 * @since 1.4
 */
","public static int formatLongOctalOrBinaryBytes(final long value, final byte[] buf, final int offset, final int length) {
        final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;
    final boolean negative = value < 0;
    if (!negative && value <= maxAsOctalChar) {
                return formatLongOctalBytes(value, buf, offset, length);
    }
    if (length < 9) {
        formatLongBinary(value, buf, offset, length, negative);
    }
    formatBigIntegerBinary(value, buf, offset, length, negative);
    buf[offset] = (byte) (negative ? 0xff : 0x80);
    return offset + length;
}",-0.045454545454545456,-0.368421052631579,0.2,-0.5,0.3333333333333333,1.0753968253968254,-0.04298801973220593,-0.25,-0.02631578947368421,0.7186298069996483
Closure,148,2,"/**
 * Adds a mapping for the given node.  Mappings must be added in order.
 *
 * @param node The node that the new mapping represents.
 * @param startPosition The position on the starting line
 * @param endPosition The position on the ending line.
 */
void addMapping(Node node, Position startPosition, Position endPosition) {
    String sourceFile = (String) node.getProp(Node.SOURCEFILE_PROP);
    // information for a mapping to be useful.
    if (sourceFile == null || node.getLineno() < 0) {
        return;
    }
    String escapedSourceFile;
    if (lastSourceFile != sourceFile) {
        // yes, ""s1 != s2"" not ""!s1.equals(s2)""
        lastSourceFile = sourceFile;
        lastSourceFileEscaped = escapeString(sourceFile);
    }
    escapedSourceFile = lastSourceFileEscaped;
    // Create the new mapping.
    Mapping mapping = new Mapping();
    mapping.id = mappings.size();
    mapping.sourceFile = escapedSourceFile;
    mapping.originalPosition = new Position(node.getLineno(), node.getCharno());
    String originalName = (String) node.getProp(Node.ORIGINALNAME_PROP);
    if (originalName != null) {
        mapping.originalName = escapeString(originalName);
    }
    // If the mapping is found on the first line, we need to offset
    // its character position by the number of characters found on
    // the *last* line of the source file to which the code is
    // being generated.
    int offsetLine = offsetPosition.getLineNumber();
    int startOffsetPosition = offsetPosition.getCharacterIndex();
    int endOffsetPosition = offsetPosition.getCharacterIndex();
    if (startPosition.getLineNumber() > 0) {
        startOffsetPosition = 0;
    }
    if (endPosition.getLineNumber() > 0) {
        endOffsetPosition = 0;
    }
    mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition);
    mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition);
    mappings.add(mapping);
}","/**
 * Adds a mapping for the given node.  Mappings must be added in order.
 *
 * @param node The node that the new mapping represents.
 * @param startPosition The position on the starting line
 * @param endPosition The position on the ending line.
 */
","void addMapping(Node node, Position startPosition, Position endPosition) {
    String sourceFile = (String) node.getProp(Node.SOURCEFILE_PROP);
        if (sourceFile == null || node.getLineno() < 0) {
        return;
    }
    String escapedSourceFile;
    if (lastSourceFile != sourceFile) {
                lastSourceFile = sourceFile;
        lastSourceFileEscaped = escapeString(sourceFile);
    }
    escapedSourceFile = lastSourceFileEscaped;
        Mapping mapping = new Mapping();
    mapping.id = mappings.size();
    mapping.sourceFile = escapedSourceFile;
    mapping.originalPosition = new Position(node.getLineno(), node.getCharno());
    String originalName = (String) node.getProp(Node.ORIGINALNAME_PROP);
    if (originalName != null) {
        mapping.originalName = escapeString(originalName);
    }
                    int offsetLine = offsetPosition.getLineNumber();
    int startOffsetPosition = offsetPosition.getCharacterIndex();
    int endOffsetPosition = offsetPosition.getCharacterIndex();
    if (startPosition.getLineNumber() > 0) {
        startOffsetPosition = 0;
    }
    if (endPosition.getLineNumber() > 0) {
        endOffsetPosition = 0;
    }
    mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition);
    mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition);
    mappings.add(mapping);
}",0.8181818181818182,-0.5023923444976078,0.4,-0.5,0.5833333333333334,1.402777777777778,-0.6022551092318531,1.0,-0.02631578947368421,2.676779447104994
Csv,4,1,"/**
 * Returns a copy of the header map that iterates in column order.
 * <p>
 * The map keys are column names. The map values are 0-based indices.
 * </p>
 * @return a copy of the header map that iterates in column order.
 */
public Map<String, Integer> getHeaderMap() {
    return new LinkedHashMap<String, Integer>(this.headerMap);
}","/**
 * Returns a copy of the header map that iterates in column order.
 * <p>
 * The map keys are column names. The map values are 0-based indices.
 * </p>
 * @return a copy of the header map that iterates in column order.
 */
","public Map<String, Integer> getHeaderMap() {
    return new LinkedHashMap<String, Integer>(this.headerMap);
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.9960535588442565,-0.5,2.131578947368421,-0.16279340490885932
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1199_813109d7,3,"public void read(org.apache.thrift.protocol.TProtocol iprot, removeConstraint_result struct) throws org.apache.thrift.TException {
    org.apache.thrift.protocol.TField schemeField;
    iprot.readStructBegin();
    while (true) {
        schemeField = iprot.readFieldBegin();
        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
            break;
        }
        switch(schemeField.id) {
            case // OUCH1
            1:
                if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                    struct.ouch1 = new AccumuloException();
                    struct.ouch1.read(iprot);
                    struct.setOuch1IsSet(true);
                } else {
                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
                }
                break;
            case // OUCH2
            2:
                if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                    struct.ouch2 = new AccumuloSecurityException();
                    struct.ouch2.read(iprot);
                    struct.setOuch2IsSet(true);
                } else {
                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
                }
                break;
            default:
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
        }
        iprot.readFieldEnd();
    }
    iprot.readStructEnd();
    // check for required fields of primitive type, which can't be checked in the validate method
    struct.validate();
}",,"public void read(org.apache.thrift.protocol.TProtocol iprot, removeConstraint_result struct) throws org.apache.thrift.TException {
    org.apache.thrift.protocol.TField schemeField;
    iprot.readStructBegin();
    while (true) {
        schemeField = iprot.readFieldBegin();
        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
            break;
        }
        switch(schemeField.id) {
            case             1:
                if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                    struct.ouch1 = new AccumuloException();
                    struct.ouch1.read(iprot);
                    struct.setOuch1IsSet(true);
                } else {
                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
                }
                break;
            case             2:
                if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                    struct.ouch2 = new AccumuloSecurityException();
                    struct.ouch2.read(iprot);
                    struct.setOuch2IsSet(true);
                } else {
                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
                }
                break;
            default:
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
        }
        iprot.readFieldEnd();
    }
    iprot.readStructEnd();
        struct.validate();
}",1.0454545454545454,1.535885167464115,1.4,1.0,0.25,0.2599206349206349,-0.6763918252290345,0.5,-0.02631578947368421,0.6848267952951481
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-776_dc9f23d9,3,"@Override
public IteratorOptions describeOptions() {
    IteratorOptions io = super.describeOptions();
    io.setName(""tsfilter"");
    io.setDescription(""TimestampFilter displays entries with timestamps between specified values"");
    io.addNamedOption(""start"", ""start timestamp (yyyyMMddHHmmssz)"");
    io.addNamedOption(""end"", ""end timestamp (yyyyMMddHHmmssz)"");
    io.addNamedOption(""startInclusive"", ""true or false"");
    io.addNamedOption(""endInclusive"", ""true or false"");
    return io;
}",,"@Override
public IteratorOptions describeOptions() {
    IteratorOptions io = super.describeOptions();
    io.setName(""tsfilter"");
    io.setDescription(""TimestampFilter displays entries with timestamps between specified values"");
    io.addNamedOption(""start"", ""start timestamp (yyyyMMddHHmmssz)"");
    io.addNamedOption(""end"", ""end timestamp (yyyyMMddHHmmssz)"");
    io.addNamedOption(""startInclusive"", ""true or false"");
    io.addNamedOption(""endInclusive"", ""true or false"");
    return io;
}",-0.13636363636363635,-0.5789473684210528,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.16335447498238198,0.08333333333333333,-0.02631578947368421,-0.16279340490885932
Lang,20,1,"/**
 * <p>Joins the elements of the provided array into a single String
 * containing the provided list of elements.</p>
 *
 * <p>No delimiter is added before or after the list.
 * Null objects or empty strings within the array are represented by
 * empty strings.</p>
 *
 * <pre>
 * StringUtils.join(null, *)               = null
 * StringUtils.join([], *)                 = """"
 * StringUtils.join([null], *)             = """"
 * StringUtils.join([""a"", ""b"", ""c""], ';')  = ""a;b;c""
 * StringUtils.join([""a"", ""b"", ""c""], null) = ""abc""
 * StringUtils.join([null, """", ""a""], ';')  = "";;a""
 * </pre>
 *
 * @param array  the array of values to join together, may be null
 * @param separator  the separator character to use
 * @param startIndex the first index to start joining from.  It is
 * an error to pass in an end index past the end of the array
 * @param endIndex the index to stop joining from (exclusive). It is
 * an error to pass in an end index past the end of the array
 * @return the joined String, {@code null} if null array input
 * @since 2.0
 */
public static String join(Object[] array, char separator, int startIndex, int endIndex) {
    if (array == null) {
        return null;
    }
    int noOfItems = (endIndex - startIndex);
    if (noOfItems <= 0) {
        return EMPTY;
    }
    StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);
    for (int i = startIndex; i < endIndex; i++) {
        if (i > startIndex) {
            buf.append(separator);
        }
        if (array[i] != null) {
            buf.append(array[i]);
        }
    }
    return buf.toString();
}","/**
 * <p>Joins the elements of the provided array into a single String
 * containing the provided list of elements.</p>
 *
 * <p>No delimiter is added before or after the list.
 * Null objects or empty strings within the array are represented by
 * empty strings.</p>
 *
 * <pre>
 * StringUtils.join(null, *)               = null
 * StringUtils.join([], *)                 = """"
 * StringUtils.join([null], *)             = """"
 * StringUtils.join([""a"", ""b"", ""c""], ';')  = ""a;b;c""
 * StringUtils.join([""a"", ""b"", ""c""], null) = ""abc""
 * StringUtils.join([null, """", ""a""], ';')  = "";;a""
 * </pre>
 *
 * @param array  the array of values to join together, may be null
 * @param separator  the separator character to use
 * @param startIndex the first index to start joining from.  It is
 * an error to pass in an end index past the end of the array
 * @param endIndex the index to stop joining from (exclusive). It is
 * an error to pass in an end index past the end of the array
 * @return the joined String, {@code null} if null array input
 * @since 2.0
 */
","public static String join(Object[] array, char separator, int startIndex, int endIndex) {
    if (array == null) {
        return null;
    }
    int noOfItems = (endIndex - startIndex);
    if (noOfItems <= 0) {
        return EMPTY;
    }
    StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);
    for (int i = startIndex; i < endIndex; i++) {
        if (i > startIndex) {
            buf.append(separator);
        }
        if (array[i] != null) {
            buf.append(array[i]);
        }
    }
    return buf.toString();
}",0.22727272727272727,0.1291866028708132,0.6,0.0,0.5,1.5396825396825395,-0.24425651867512305,-0.08333333333333333,-0.02631578947368421,1.1272718890291198
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-366_db4a291f,1,"private synchronized void retry(ZooRunnable op) {
    int sleepTime = 100;
    while (true) {
        ZooKeeper zooKeeper = getZooKeeper();
        try {
            op.run(zooKeeper);
            return;
        } catch (KeeperException e) {
            if (e.code() == Code.NONODE) {
                log.error(""Looked up non existant node in cache "" + e.getPath(), e);
            }
            log.warn(""Zookeeper error, will retry"", e);
        } catch (InterruptedException e) {
            log.warn(""Zookeeper error, will retry"", e);
        } catch (ConcurrentModificationException e) {
            log.debug(""Zookeeper was modified, will retry"");
        }
        try {
            // do not hold lock while sleeping
            wait(sleepTime);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        if (sleepTime < 10000)
            sleepTime = (int) (sleepTime + sleepTime * Math.random());
    }
}",,"private synchronized void retry(ZooRunnable op) {
    int sleepTime = 100;
    while (true) {
        ZooKeeper zooKeeper = getZooKeeper();
        try {
            op.run(zooKeeper);
            return;
        } catch (KeeperException e) {
            if (e.code() == Code.NONODE) {
                log.error(""Looked up non existant node in cache "" + e.getPath(), e);
            }
            log.warn(""Zookeeper error, will retry"", e);
        } catch (InterruptedException e) {
            log.warn(""Zookeeper error, will retry"", e);
        } catch (ConcurrentModificationException e) {
            log.debug(""Zookeeper was modified, will retry"");
        }
        try {
                        wait(sleepTime);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        if (sleepTime < 10000)
            sleepTime = (int) (sleepTime + sleepTime * Math.random());
    }
}",0.5454545454545454,0.41148325358851673,0.8,0.5,0.0,0.31349206349206343,-0.40549682875264276,0.4166666666666667,-0.02631578947368421,0.3343625917025408
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-276_1bf5c550,1,"public Id readHead() throws Exception {
    Connection con = cp.getConnection();
    try {
        PreparedStatement stmt = con.prepareStatement(""select * from HEAD"");
        ResultSet rs = stmt.executeQuery();
        byte[] rawId = null;
        if (rs.next()) {
            rawId = rs.getBytes(1);
        }
        stmt.close();
        return rawId == null ? null : new Id(rawId);
    } finally {
        con.close();
    }
}",,"public Id readHead() throws Exception {
    Connection con = cp.getConnection();
    try {
        PreparedStatement stmt = con.prepareStatement(""select * from HEAD"");
        ResultSet rs = stmt.executeQuery();
        byte[] rawId = null;
        if (rs.next()) {
            rawId = rs.getBytes(1);
        }
        stmt.close();
        return rawId == null ? null : new Id(rawId);
    } finally {
        con.close();
    }
}",0.045454545454545456,0.11004784688995216,-0.2,0.0,-0.08333333333333333,-0.04365079365079365,-0.04045102184637074,0.08333333333333333,0.7105263157894737,-0.02773349930556757
Closure,169,2,"JSType getGreatestSubtypeHelper(JSType that) {
    if (that.isRecordType()) {
        RecordType thatRecord = that.toMaybeRecordType();
        RecordTypeBuilder builder = new RecordTypeBuilder(registry);
        builder.setSynthesized(true);
        // is returned.
        for (String property : properties.keySet()) {
            if (thatRecord.hasProperty(property) && !thatRecord.getPropertyType(property).isInvariant(getPropertyType(property))) {
                return registry.getNativeObjectType(JSTypeNative.NO_TYPE);
            }
            builder.addProperty(property, getPropertyType(property), getPropertyNode(property));
        }
        for (String property : thatRecord.properties.keySet()) {
            if (!hasProperty(property)) {
                builder.addProperty(property, thatRecord.getPropertyType(property), thatRecord.getPropertyNode(property));
            }
        }
        return builder.build();
    }
    JSType greatestSubtype = registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE);
    JSType thatRestrictedToObj = registry.getNativeType(JSTypeNative.OBJECT_TYPE).getGreatestSubtype(that);
    if (!thatRestrictedToObj.isEmptyType()) {
        // 2) Take the intersection of all of these unions.
        for (Map.Entry<String, JSType> entry : properties.entrySet()) {
            String propName = entry.getKey();
            JSType propType = entry.getValue();
            UnionTypeBuilder builder = new UnionTypeBuilder(registry);
            for (ObjectType alt : registry.getEachReferenceTypeWithProperty(propName)) {
                JSType altPropType = alt.getPropertyType(propName);
                if (altPropType != null && !alt.isEquivalentTo(this) && alt.isSubtype(that) && (propType.isUnknownType() || altPropType.isUnknownType() || altPropType.isEquivalentTo(propType))) {
                    builder.addAlternate(alt);
                }
            }
            greatestSubtype = greatestSubtype.getLeastSupertype(builder.build());
        }
    }
    return greatestSubtype;
}",,"JSType getGreatestSubtypeHelper(JSType that) {
    if (that.isRecordType()) {
        RecordType thatRecord = that.toMaybeRecordType();
        RecordTypeBuilder builder = new RecordTypeBuilder(registry);
        builder.setSynthesized(true);
                for (String property : properties.keySet()) {
            if (thatRecord.hasProperty(property) && !thatRecord.getPropertyType(property).isInvariant(getPropertyType(property))) {
                return registry.getNativeObjectType(JSTypeNative.NO_TYPE);
            }
            builder.addProperty(property, getPropertyType(property), getPropertyNode(property));
        }
        for (String property : thatRecord.properties.keySet()) {
            if (!hasProperty(property)) {
                builder.addProperty(property, thatRecord.getPropertyType(property), thatRecord.getPropertyNode(property));
            }
        }
        return builder.build();
    }
    JSType greatestSubtype = registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE);
    JSType thatRestrictedToObj = registry.getNativeType(JSTypeNative.OBJECT_TYPE).getGreatestSubtype(that);
    if (!thatRestrictedToObj.isEmptyType()) {
                for (Map.Entry<String, JSType> entry : properties.entrySet()) {
            String propName = entry.getKey();
            JSType propType = entry.getValue();
            UnionTypeBuilder builder = new UnionTypeBuilder(registry);
            for (ObjectType alt : registry.getEachReferenceTypeWithProperty(propName)) {
                JSType altPropType = alt.getPropertyType(propName);
                if (altPropType != null && !alt.isEquivalentTo(this) && alt.isSubtype(that) && (propType.isUnknownType() || altPropType.isUnknownType() || altPropType.isEquivalentTo(propType))) {
                    builder.addAlternate(alt);
                }
            }
            greatestSubtype = greatestSubtype.getLeastSupertype(builder.build());
        }
    }
    return greatestSubtype;
}",1.0,0.8325358851674642,1.2,1.0,1.75,0.6111111111111112,-0.7136011275546157,2.4166666666666665,-0.02631578947368421,1.7833324688946133
Closure,14,2,"/**
 * Computes the follow() node of a given node and its parent. There is a side
 * effect when calling this function. If this function computed an edge that
 * exists a FINALLY, it'll attempt to connect the fromNode to the outer
 * FINALLY according to the finallyMap.
 *
 * @param fromNode The original source node since {@code node} is changed
 *        during recursion.
 * @param node The node that follow() should compute.
 */
private static Node computeFollowNode(Node fromNode, Node node, ControlFlowAnalysis cfa) {
    /*
     * This is the case where:
     *
     * 1. Parent is null implies that we are transferring control to the end of
     * the script.
     *
     * 2. Parent is a function implies that we are transferring control back to
     * the caller of the function.
     *
     * 3. If the node is a return statement, we should also transfer control
     * back to the caller of the function.
     *
     * 4. If the node is root then we have reached the end of what we have been
     * asked to traverse.
     *
     * In all cases we should transfer control to a ""symbolic return"" node.
     * This will make life easier for DFAs.
     */
    Node parent = node.getParent();
    if (parent == null || parent.isFunction() || (cfa != null && node == cfa.root)) {
        return null;
    }
    // If we are just before a IF/WHILE/DO/FOR:
    switch(parent.getType()) {
        // The follow() of any of the path from IF would be what follows IF.
        case Token.IF:
            return computeFollowNode(fromNode, parent, cfa);
        case Token.CASE:
        case Token.DEFAULT_CASE:
            // case, without having to go to the case condition.
            if (parent.getNext() != null) {
                if (parent.getNext().isCase()) {
                    return parent.getNext().getFirstChild().getNext();
                } else if (parent.getNext().isDefaultCase()) {
                    return parent.getNext().getFirstChild();
                } else {
                    Preconditions.checkState(false, ""Not reachable"");
                }
            } else {
                return computeFollowNode(fromNode, parent, cfa);
            }
            break;
        case Token.FOR:
            if (NodeUtil.isForIn(parent)) {
                return parent;
            } else {
                return parent.getFirstChild().getNext().getNext();
            }
        case Token.WHILE:
        case Token.DO:
            return parent;
        case Token.TRY:
            // If we are coming out of the TRY block...
            if (parent.getFirstChild() == node) {
                if (NodeUtil.hasFinally(parent)) {
                    // and have FINALLY block.
                    return computeFallThrough(parent.getLastChild());
                } else {
                    // and have no FINALLY.
                    return computeFollowNode(fromNode, parent, cfa);
                }
            // CATCH block.
            } else if (NodeUtil.getCatchBlock(parent) == node) {
                if (NodeUtil.hasFinally(parent)) {
                    // and have FINALLY block.
                    return computeFallThrough(node.getNext());
                } else {
                    return computeFollowNode(fromNode, parent, cfa);
                }
            // If we are coming out of the FINALLY block...
            } else if (parent.getLastChild() == node) {
                if (cfa != null) {
                    for (Node finallyNode : cfa.finallyMap.get(parent)) {
                        cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);
                    }
                }
                return computeFollowNode(fromNode, parent, cfa);
            }
    }
    // Now that we are done with the special cases follow should be its
    // immediate sibling, unless its sibling is a function
    Node nextSibling = node.getNext();
    // Skip function declarations because control doesn't get pass into it.
    while (nextSibling != null && nextSibling.isFunction()) {
        nextSibling = nextSibling.getNext();
    }
    if (nextSibling != null) {
        return computeFallThrough(nextSibling);
    } else {
        // If there are no more siblings, control is transferred up the AST.
        return computeFollowNode(fromNode, parent, cfa);
    }
}","/**
 * Computes the follow() node of a given node and its parent. There is a side
 * effect when calling this function. If this function computed an edge that
 * exists a FINALLY, it'll attempt to connect the fromNode to the outer
 * FINALLY according to the finallyMap.
 *
 * @param fromNode The original source node since {@code node} is changed
 *        during recursion.
 * @param node The node that follow() should compute.
 */
","private static Node computeFollowNode(Node fromNode, Node node, ControlFlowAnalysis cfa) {
        Node parent = node.getParent();
    if (parent == null || parent.isFunction() || (cfa != null && node == cfa.root)) {
        return null;
    }
        switch(parent.getType()) {
                case Token.IF:
            return computeFollowNode(fromNode, parent, cfa);
        case Token.CASE:
        case Token.DEFAULT_CASE:
                        if (parent.getNext() != null) {
                if (parent.getNext().isCase()) {
                    return parent.getNext().getFirstChild().getNext();
                } else if (parent.getNext().isDefaultCase()) {
                    return parent.getNext().getFirstChild();
                } else {
                    Preconditions.checkState(false, ""Not reachable"");
                }
            } else {
                return computeFollowNode(fromNode, parent, cfa);
            }
            break;
        case Token.FOR:
            if (NodeUtil.isForIn(parent)) {
                return parent;
            } else {
                return parent.getFirstChild().getNext().getNext();
            }
        case Token.WHILE:
        case Token.DO:
            return parent;
        case Token.TRY:
                        if (parent.getFirstChild() == node) {
                if (NodeUtil.hasFinally(parent)) {
                                        return computeFallThrough(parent.getLastChild());
                } else {
                                        return computeFollowNode(fromNode, parent, cfa);
                }
                        } else if (NodeUtil.getCatchBlock(parent) == node) {
                if (NodeUtil.hasFinally(parent)) {
                                        return computeFallThrough(node.getNext());
                } else {
                    return computeFollowNode(fromNode, parent, cfa);
                }
                        } else if (parent.getLastChild() == node) {
                if (cfa != null) {
                    for (Node finallyNode : cfa.finallyMap.get(parent)) {
                        cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);
                    }
                }
                return computeFollowNode(fromNode, parent, cfa);
            }
    }
            Node nextSibling = node.getNext();
        while (nextSibling != null && nextSibling.isFunction()) {
        nextSibling = nextSibling.getNext();
    }
    if (nextSibling != null) {
        return computeFallThrough(nextSibling);
    } else {
                return computeFollowNode(fromNode, parent, cfa);
    }
}",2.227272727272727,1.3588516746411483,3.8,2.5,2.9166666666666665,0.986111111111111,-1.0589147286821703,2.75,-0.02631578947368421,2.6273197213049557
commons-math,remotes/origin/bugs-dot-jar_MATH-320_c06cc933,1,"/**
 * Solve the linear equation A &times; X = B in least square sense.
 * <p>The m&times;n matrix A may not be square, the solution X is
 * such that ||A &times; X - B|| is minimal.</p>
 * @param b right-hand side of the equation A &times; X = B
 * @return a vector X that minimizes the two norm of A &times; X - B
 * @exception IllegalArgumentException if matrices dimensions don't match
 * @exception InvalidMatrixException if decomposed matrix is singular
 */
public RealVector solve(final RealVector b) throws IllegalArgumentException, InvalidMatrixException {
    if (b.getDimension() != uT.getColumnDimension()) {
        throw MathRuntimeException.createIllegalArgumentException(""vector length mismatch: got {0} but expected {1}"", b.getDimension(), uT.getColumnDimension());
    }
    final RealVector w = uT.operate(b);
    for (int i = 0; i < singularValues.length; ++i) {
        final double si = singularValues[i];
        if (si == 0) {
            throw new SingularMatrixException();
        }
        w.setEntry(i, w.getEntry(i) / si);
    }
    return v.operate(w);
}","/**
 * Solve the linear equation A &times; X = B in least square sense.
 * <p>The m&times;n matrix A may not be square, the solution X is
 * such that ||A &times; X - B|| is minimal.</p>
 * @param b right-hand side of the equation A &times; X = B
 * @return a vector X that minimizes the two norm of A &times; X - B
 * @exception IllegalArgumentException if matrices dimensions don't match
 * @exception InvalidMatrixException if decomposed matrix is singular
 */
","public RealVector solve(final RealVector b) throws IllegalArgumentException, InvalidMatrixException {
    if (b.getDimension() != uT.getColumnDimension()) {
        throw MathRuntimeException.createIllegalArgumentException(""vector length mismatch: got {0} but expected {1}"", b.getDimension(), uT.getColumnDimension());
    }
    final RealVector w = uT.operate(b);
    for (int i = 0; i < singularValues.length; ++i) {
        final double si = singularValues[i];
        if (si == 0) {
            throw new SingularMatrixException();
        }
        w.setEntry(i, w.getEntry(i) / si);
    }
    return v.operate(w);
}",0.0,0.12440191387559799,0.4,0.0,0.25,0.7996031746031746,-0.08019732205778712,0.25,0.13157894736842105,0.5339442033620903
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-1067_4786a739,3,"@SuppressWarnings(""ThrowableResultOfMethodCallIgnored"")
private void formatCause(final StringBuilder sb, final ThrowableProxy cause, final List<String> ignorePackages) {
    if (cause == null) {
        return;
    }
    sb.append(""Caused by: "").append(cause).append(EOL);
    this.formatElements(sb, cause.commonElementCount, cause.getThrowable().getStackTrace(), cause.extendedStackTrace, ignorePackages);
    this.formatCause(sb, cause.causeProxy, ignorePackages);
}",,"@SuppressWarnings(""ThrowableResultOfMethodCallIgnored"")
private void formatCause(final StringBuilder sb, final ThrowableProxy cause, final List<String> ignorePackages) {
    if (cause == null) {
        return;
    }
    sb.append(""Caused by: "").append(cause).append(EOL);
    this.formatElements(sb, cause.commonElementCount, cause.getThrowable().getStackTrace(), cause.extendedStackTrace, ignorePackages);
    this.formatCause(sb, cause.causeProxy, ignorePackages);
}",-0.22727272727272727,-0.22966507177033516,-0.4,-0.5,-0.25,-0.3650793650793651,0.21691331923890078,0.08333333333333333,-0.02631578947368421,-0.16279340490885932
Cli,37,1,"/**
 * Tells if the token looks like a short option.
 *
 * @param token
 */
private boolean isShortOption(String token) {
    // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)
    return token.startsWith(""-"") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));
// remove leading ""-"" and ""=value""
}","/**
 * Tells if the token looks like a short option.
 *
 * @param token
 */
","private boolean isShortOption(String token) {
        return token.startsWith(""-"") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.10119047619047619,0.8418604651162791,-0.16666666666666666,2.263157894736842,-0.1183266771551898
Closure,112,2,"/**
 * For functions with function(this: T, ...) and T as parameters, type
 * inference will set the type of this on a function literal argument to the
 * the actual type of T.
 */
private boolean inferTemplatedTypesForCall(Node n, FunctionType fnType) {
    final ImmutableList<TemplateType> keys = fnType.getTemplateTypeMap().getTemplateKeys();
    if (keys.isEmpty()) {
        return false;
    }
    // Try to infer the template types
    Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(fnType, n);
    // Replace all template types. If we couldn't find a replacement, we
    // replace it with UNKNOWN.
    TemplateTypeReplacer replacer = new TemplateTypeReplacer(registry, inferred);
    Node callTarget = n.getFirstChild();
    FunctionType replacementFnType = fnType.visit(replacer).toMaybeFunctionType();
    Preconditions.checkNotNull(replacementFnType);
    callTarget.setJSType(replacementFnType);
    n.setJSType(replacementFnType.getReturnType());
    return replacer.madeChanges;
}","/**
 * For functions with function(this: T, ...) and T as parameters, type
 * inference will set the type of this on a function literal argument to the
 * the actual type of T.
 */
","private boolean inferTemplatedTypesForCall(Node n, FunctionType fnType) {
    final ImmutableList<TemplateType> keys = fnType.getTemplateTypeMap().getTemplateKeys();
    if (keys.isEmpty()) {
        return false;
    }
        Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(fnType, n);
            TemplateTypeReplacer replacer = new TemplateTypeReplacer(registry, inferred);
    Node callTarget = n.getFirstChild();
    FunctionType replacementFnType = fnType.visit(replacer).toMaybeFunctionType();
    Preconditions.checkNotNull(replacementFnType);
    callTarget.setJSType(replacementFnType);
    n.setJSType(replacementFnType.getReturnType());
    return replacer.madeChanges;
}",0.0,-0.5550239234449762,-0.4,-0.5,-0.25,-0.3650793650793651,-0.059901338971106395,0.4166666666666667,-0.02631578947368421,-0.16279340490885932
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-3474_cfb832a1,3,"private void addCellsToWriter(Map<ByteBuffer, List<ColumnUpdate>> cells, BatchWriterPlusException bwpe) {
    if (bwpe.exception != null)
        return;
    HashMap<Text, ColumnVisibility> vizMap = new HashMap<Text, ColumnVisibility>();
    for (Map.Entry<ByteBuffer, List<ColumnUpdate>> entry : cells.entrySet()) {
        Mutation m = new Mutation(ByteBufferUtil.toBytes(entry.getKey()));
        for (ColumnUpdate update : entry.getValue()) {
            ColumnVisibility viz = EMPTY_VIS;
            if (update.isSetColVisibility()) {
                Text vizText = new Text(update.getColVisibility());
                viz = vizMap.get(vizText);
                if (viz == null) {
                    vizMap.put(vizText, viz = new ColumnVisibility(vizText));
                }
            }
            byte[] value = new byte[0];
            if (update.isSetValue())
                value = update.getValue();
            if (update.isSetTimestamp()) {
                if (update.isSetDeleteCell()) {
                    m.putDelete(update.getColFamily(), update.getColQualifier(), viz, update.getTimestamp());
                } else {
                    m.put(new Text(update.getColFamily()), new Text(update.getColQualifier()), viz, update.getTimestamp(), new Value(value));
                }
            } else {
                if (update.isSetDeleteCell()) {
                    m.putDelete(new Text(update.getColFamily()), new Text(update.getColQualifier()), viz);
                } else {
                    m.put(new Text(update.getColFamily()), new Text(update.getColQualifier()), viz, new Value(value));
                }
            }
        }
        try {
            bwpe.writer.addMutation(m);
        } catch (MutationsRejectedException mre) {
            bwpe.exception = mre;
        }
    }
}",,"private void addCellsToWriter(Map<ByteBuffer, List<ColumnUpdate>> cells, BatchWriterPlusException bwpe) {
    if (bwpe.exception != null)
        return;
    HashMap<Text, ColumnVisibility> vizMap = new HashMap<Text, ColumnVisibility>();
    for (Map.Entry<ByteBuffer, List<ColumnUpdate>> entry : cells.entrySet()) {
        Mutation m = new Mutation(ByteBufferUtil.toBytes(entry.getKey()));
        for (ColumnUpdate update : entry.getValue()) {
            ColumnVisibility viz = EMPTY_VIS;
            if (update.isSetColVisibility()) {
                Text vizText = new Text(update.getColVisibility());
                viz = vizMap.get(vizText);
                if (viz == null) {
                    vizMap.put(vizText, viz = new ColumnVisibility(vizText));
                }
            }
            byte[] value = new byte[0];
            if (update.isSetValue())
                value = update.getValue();
            if (update.isSetTimestamp()) {
                if (update.isSetDeleteCell()) {
                    m.putDelete(update.getColFamily(), update.getColQualifier(), viz, update.getTimestamp());
                } else {
                    m.put(new Text(update.getColFamily()), new Text(update.getColQualifier()), viz, update.getTimestamp(), new Value(value));
                }
            } else {
                if (update.isSetDeleteCell()) {
                    m.putDelete(new Text(update.getColFamily()), new Text(update.getColQualifier()), viz);
                } else {
                    m.put(new Text(update.getColFamily()), new Text(update.getColQualifier()), viz, new Value(value));
                }
            }
        }
        try {
            bwpe.writer.addMutation(m);
        } catch (MutationsRejectedException mre) {
            bwpe.exception = mre;
        }
    }
}",1.1363636363636365,1.1674641148325358,1.4,1.0,0.6666666666666666,0.17063492063492064,-0.738689217758985,1.8333333333333333,-0.02631578947368421,0.7792235035125025
Closure,32,2,"/**
 * Extracts the text found on the current line and all subsequent
 * until either an annotation, end of comment or end of file is reached.
 * Note that if this method detects an end of line as the first token, it
 * will quit immediately (indicating that there is no text where it was
 * expected).  Note that token = info.token; should be called after this
 * method is used to update the token properly in the parser.
 *
 * @param token The start token.
 * @param option How to handle whitespace.
 *
 * @return The extraction information.
 */
@SuppressWarnings(""fallthrough"")
private ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {
    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {
        return new ExtractionInfo("""", token);
    }
    stream.update();
    int startLineno = stream.getLineno();
    int startCharno = stream.getCharno() + 1;
    // Read the content from the first line.
    String line = stream.getRemainingJSDocLine();
    if (option != WhitespaceOption.PRESERVE) {
        line = line.trim();
    }
    StringBuilder builder = new StringBuilder();
    builder.append(line);
    state = State.SEARCHING_ANNOTATION;
    token = next();
    boolean ignoreStar = false;
    do {
        switch(token) {
            case STAR:
                if (ignoreStar) {
                // Mark the position after the star as the new start of the line.
                } else {
                    // The star is part of the comment.
                    if (builder.length() > 0) {
                        builder.append(' ');
                    }
                    builder.append('*');
                }
                token = next();
                continue;
            case EOL:
                if (option != WhitespaceOption.SINGLE_LINE) {
                    builder.append(""\n"");
                }
                ignoreStar = true;
                token = next();
                continue;
            default:
                ignoreStar = false;
                state = State.SEARCHING_ANNOTATION;
                if (token == JsDocToken.EOC || token == JsDocToken.EOF || // in the block are ok.
                (token == JsDocToken.ANNOTATION && option != WhitespaceOption.PRESERVE)) {
                    String multilineText = builder.toString();
                    if (option != WhitespaceOption.PRESERVE) {
                        multilineText = multilineText.trim();
                    }
                    int endLineno = stream.getLineno();
                    int endCharno = stream.getCharno();
                    if (multilineText.length() > 0) {
                        jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);
                    }
                    return new ExtractionInfo(multilineText, token);
                }
                if (builder.length() > 0) {
                    builder.append(' ');
                }
                builder.append(toString(token));
                line = stream.getRemainingJSDocLine();
                if (option != WhitespaceOption.PRESERVE) {
                    line = trimEnd(line);
                }
                builder.append(line);
                token = next();
        }
    } while (true);
}","/**
 * Extracts the text found on the current line and all subsequent
 * until either an annotation, end of comment or end of file is reached.
 * Note that if this method detects an end of line as the first token, it
 * will quit immediately (indicating that there is no text where it was
 * expected).  Note that token = info.token; should be called after this
 * method is used to update the token properly in the parser.
 *
 * @param token The start token.
 * @param option How to handle whitespace.
 *
 * @return The extraction information.
 */
","@SuppressWarnings(""fallthrough"")
private ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {
    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {
        return new ExtractionInfo("""", token);
    }
    stream.update();
    int startLineno = stream.getLineno();
    int startCharno = stream.getCharno() + 1;
        String line = stream.getRemainingJSDocLine();
    if (option != WhitespaceOption.PRESERVE) {
        line = line.trim();
    }
    StringBuilder builder = new StringBuilder();
    builder.append(line);
    state = State.SEARCHING_ANNOTATION;
    token = next();
    boolean ignoreStar = false;
    do {
        switch(token) {
            case STAR:
                if (ignoreStar) {
                                } else {
                                        if (builder.length() > 0) {
                        builder.append(' ');
                    }
                    builder.append('*');
                }
                token = next();
                continue;
            case EOL:
                if (option != WhitespaceOption.SINGLE_LINE) {
                    builder.append(""\n"");
                }
                ignoreStar = true;
                token = next();
                continue;
            default:
                ignoreStar = false;
                state = State.SEARCHING_ANNOTATION;
                if (token == JsDocToken.EOC || token == JsDocToken.EOF ||                 (token == JsDocToken.ANNOTATION && option != WhitespaceOption.PRESERVE)) {
                    String multilineText = builder.toString();
                    if (option != WhitespaceOption.PRESERVE) {
                        multilineText = multilineText.trim();
                    }
                    int endLineno = stream.getLineno();
                    int endCharno = stream.getCharno();
                    if (multilineText.length() > 0) {
                        jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);
                    }
                    return new ExtractionInfo(multilineText, token);
                }
                if (builder.length() > 0) {
                    builder.append(' ');
                }
                builder.append(toString(token));
                line = stream.getRemainingJSDocLine();
                if (option != WhitespaceOption.PRESERVE) {
                    line = trimEnd(line);
                }
                builder.append(line);
                token = next();
        }
    } while (true);
}",2.3181818181818183,1.861244019138756,2.6,1.5,1.5,1.4087301587301586,-1.0656800563777304,1.75,-0.02631578947368421,4.380973127481659
flink,remotes/origin/bugs-dot-jar_FLINK-3260_6968a57a,0,"// --------------------------------------------------------------------------------------------
// Internal Actions
// --------------------------------------------------------------------------------------------
private boolean processFail(Throwable t, boolean isCallback) {
    // atomically switch to failed
    while (true) {
        ExecutionState current = this.state;
        if (current == FAILED) {
            // already failed. It is enough to remember once that we failed (its sad enough)
            return false;
        }
        if (current == CANCELED) {
            // we are already aborting or are already aborted
            if (LOG.isDebugEnabled()) {
                LOG.debug(String.format(""Ignoring transition of vertex %s to %s while being %s"", getVertexWithAttempt(), FAILED, CANCELED));
            }
            return false;
        }
        if (transitionState(current, FAILED, t)) {
            // success (in a manner of speaking)
            this.failureCause = t;
            try {
                if (assignedResource != null) {
                    assignedResource.releaseSlot();
                }
                vertex.getExecutionGraph().deregisterExecution(this);
            } finally {
                vertex.executionFailed(t);
            }
            if (!isCallback && (current == RUNNING || current == DEPLOYING)) {
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""Sending out cancel request, to remove task execution from TaskManager."");
                }
                try {
                    if (assignedResource != null) {
                        sendCancelRpcCall();
                    }
                } catch (Throwable tt) {
                    // no reason this should ever happen, but log it to be safe
                    LOG.error(""Error triggering cancel call while marking task as failed."", tt);
                }
            }
            // leave the loop
            return true;
        }
    }
}",,"private boolean processFail(Throwable t, boolean isCallback) {
        while (true) {
        ExecutionState current = this.state;
        if (current == FAILED) {
                        return false;
        }
        if (current == CANCELED) {
                        if (LOG.isDebugEnabled()) {
                LOG.debug(String.format(""Ignoring transition of vertex %s to %s while being %s"", getVertexWithAttempt(), FAILED, CANCELED));
            }
            return false;
        }
        if (transitionState(current, FAILED, t)) {
                        this.failureCause = t;
            try {
                if (assignedResource != null) {
                    assignedResource.releaseSlot();
                }
                vertex.getExecutionGraph().deregisterExecution(this);
            } finally {
                vertex.executionFailed(t);
            }
            if (!isCallback && (current == RUNNING || current == DEPLOYING)) {
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""Sending out cancel request, to remove task execution from TaskManager."");
                }
                try {
                    if (assignedResource != null) {
                        sendCancelRpcCall();
                    }
                } catch (Throwable tt) {
                                        LOG.error(""Error triggering cancel call while marking task as failed."", tt);
                }
            }
                        return true;
        }
    }
}",1.0909090909090908,1.1866028708133969,1.4,1.5,1.0,0.6726190476190477,-0.627906976744186,0.5833333333333334,-0.02631578947368421,0.7670614270154388
commons-math,remotes/origin/bugs-dot-jar_MATH-704_3f645310,1,"/**
 * Returns the weighted variance of the entries in the specified portion of
 * the input array, using the precomputed weighted mean value.  Returns
 * <code>Double.NaN</code> if the designated subarray is empty.
 * <p>
 * Uses the formula <pre>
 *   &Sigma;(weights[i]*(values[i] - mean)<sup>2</sup>)/(&Sigma;(weights[i]) - 1)
 * </pre></p>
 * <p>
 * The formula used assumes that the supplied mean value is the weighted arithmetic
 * mean of the sample data, not a known population parameter. This method
 * is supplied only to save computation when the mean has already been
 * computed.</p>
 * <p>
 * This formula will not return the same result as the unweighted variance when all
 * weights are equal, unless all weights are equal to 1. The formula assumes that
 * weights are to be treated as ""expansion values,"" as will be the case if for example
 * the weights represent frequency counts. To normalize weights so that the denominator
 * in the variance computation equals the length of the input vector minus one, use <pre>
 *   <code>evaluate(values, MathArrays.normalizeArray(weights, values.length), mean); </code>
 * </pre>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if any of the following are true:
 * <ul><li>the values array is null</li>
 *     <li>the weights array is null</li>
 *     <li>the weights array does not have the same length as the values array</li>
 *     <li>the weights array contains one or more infinite values</li>
 *     <li>the weights array contains one or more NaN values</li>
 *     <li>the weights array contains negative values</li>
 *     <li>the start and length arguments do not determine a valid array</li>
 * </ul></p>
 * <p>
 * Does not change the internal state of the statistic.</p>
 *
 * @param values the input array
 * @param weights the weights array
 * @param mean the precomputed weighted mean value
 * @param begin index of the first array element to include
 * @param length the number of elements to include
 * @return the variance of the values or Double.NaN if length = 0
 * @throws IllegalArgumentException if the parameters are not valid
 * @since 2.1
 */
public double evaluate(final double[] values, final double[] weights, final double mean, final int begin, final int length) {
    double var = Double.NaN;
    if (test(values, weights, begin, length)) {
        if (length == 1) {
            var = 0.0;
        } else if (length > 1) {
            double accum = 0.0;
            double dev = 0.0;
            double accum2 = 0.0;
            for (int i = begin; i < begin + length; i++) {
                dev = values[i] - mean;
                accum += weights[i] * (dev * dev);
                accum2 += weights[i] * dev;
            }
            double sumWts = 0;
            for (int i = 0; i < weights.length; i++) {
                sumWts += weights[i];
            }
            if (isBiasCorrected) {
                var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);
            } else {
                var = (accum - (accum2 * accum2 / sumWts)) / sumWts;
            }
        }
    }
    return var;
}","/**
 * Returns the weighted variance of the entries in the specified portion of
 * the input array, using the precomputed weighted mean value.  Returns
 * <code>Double.NaN</code> if the designated subarray is empty.
 * <p>
 * Uses the formula <pre>
 *   &Sigma;(weights[i]*(values[i] - mean)<sup>2</sup>)/(&Sigma;(weights[i]) - 1)
 * </pre></p>
 * <p>
 * The formula used assumes that the supplied mean value is the weighted arithmetic
 * mean of the sample data, not a known population parameter. This method
 * is supplied only to save computation when the mean has already been
 * computed.</p>
 * <p>
 * This formula will not return the same result as the unweighted variance when all
 * weights are equal, unless all weights are equal to 1. The formula assumes that
 * weights are to be treated as ""expansion values,"" as will be the case if for example
 * the weights represent frequency counts. To normalize weights so that the denominator
 * in the variance computation equals the length of the input vector minus one, use <pre>
 *   <code>evaluate(values, MathArrays.normalizeArray(weights, values.length), mean); </code>
 * </pre>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if any of the following are true:
 * <ul><li>the values array is null</li>
 *     <li>the weights array is null</li>
 *     <li>the weights array does not have the same length as the values array</li>
 *     <li>the weights array contains one or more infinite values</li>
 *     <li>the weights array contains one or more NaN values</li>
 *     <li>the weights array contains negative values</li>
 *     <li>the start and length arguments do not determine a valid array</li>
 * </ul></p>
 * <p>
 * Does not change the internal state of the statistic.</p>
 *
 * @param values the input array
 * @param weights the weights array
 * @param mean the precomputed weighted mean value
 * @param begin index of the first array element to include
 * @param length the number of elements to include
 * @return the variance of the values or Double.NaN if length = 0
 * @throws IllegalArgumentException if the parameters are not valid
 * @since 2.1
 */
","public double evaluate(final double[] values, final double[] weights, final double mean, final int begin, final int length) {
    double var = Double.NaN;
    if (test(values, weights, begin, length)) {
        if (length == 1) {
            var = 0.0;
        } else if (length > 1) {
            double accum = 0.0;
            double dev = 0.0;
            double accum2 = 0.0;
            for (int i = begin; i < begin + length; i++) {
                dev = values[i] - mean;
                accum += weights[i] * (dev * dev);
                accum2 += weights[i] * dev;
            }
            double sumWts = 0;
            for (int i = 0; i < weights.length; i++) {
                sumWts += weights[i];
            }
            if (isBiasCorrected) {
                var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);
            } else {
                var = (accum - (accum2 * accum2 / sumWts)) / sumWts;
            }
        }
    }
    return var;
}",0.5909090909090909,0.8564593301435407,0.6,1.0,0.75,3.035714285714286,-0.4909090909090906,-0.4166666666666667,-0.02631578947368421,3.9876558150792683
camel,remotes/origin/bugs-dot-jar_CAMEL-3757_c1b2f2f8,3,"/**
 * Mock all endpoints matching the given pattern.
 *
 * @param pattern the pattern.
 * @throws Exception can be thrown if error occurred
 * @see org.apache.camel.util.EndpointHelper#matchEndpoint(String, String)
 */
public void mockEndpoints(String pattern) throws Exception {
    getContext().removeEndpoints(pattern);
    getContext().addRegisterEndpointCallback(new InterceptSendToMockEndpointStrategy(pattern));
}","/**
 * Mock all endpoints matching the given pattern.
 *
 * @param pattern the pattern.
 * @throws Exception can be thrown if error occurred
 * @see org.apache.camel.util.EndpointHelper#matchEndpoint(String, String)
 */
","public void mockEndpoints(String pattern) throws Exception {
    getContext().removeEndpoints(pattern);
    getContext().addRegisterEndpointCallback(new InterceptSendToMockEndpointStrategy(pattern));
}",-0.45454545454545453,-0.47368421052631593,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.8046511627906971,-0.16666666666666666,2.2105263157894735,-0.16279340490885932
flink,remotes/origin/bugs-dot-jar_FLINK-2442_30761572,0,"/**
 *  Recursively add all fields in this tuple type. We need this in particular to get all
 *  the types.
 *  @param startKeyId
 *  @param keyFields
 */
public void addAllFields(int startKeyId, List<FlatFieldDescriptor> keyFields) {
    for (int i = 0; i < this.getArity(); i++) {
        TypeInformation<?> type = this.types[i];
        if (type instanceof AtomicType) {
            keyFields.add(new FlatFieldDescriptor(startKeyId, type));
        } else if (type instanceof TupleTypeInfoBase<?>) {
            TupleTypeInfoBase<?> ttb = (TupleTypeInfoBase<?>) type;
            ttb.addAllFields(startKeyId, keyFields);
        }
        startKeyId += type.getTotalFields();
    }
}","/**
 *  Recursively add all fields in this tuple type. We need this in particular to get all
 *  the types.
 *  @param startKeyId
 *  @param keyFields
 */
","public void addAllFields(int startKeyId, List<FlatFieldDescriptor> keyFields) {
    for (int i = 0; i < this.getArity(); i++) {
        TypeInformation<?> type = this.types[i];
        if (type instanceof AtomicType) {
            keyFields.add(new FlatFieldDescriptor(startKeyId, type));
        } else if (type instanceof TupleTypeInfoBase<?>) {
            TupleTypeInfoBase<?> ttb = (TupleTypeInfoBase<?>) type;
            ttb.addAllFields(startKeyId, keyFields);
        }
        startKeyId += type.getTotalFields();
    }
}",-0.09090909090909091,0.5023923444976076,0.0,0.5,0.08333333333333333,0.45238095238095244,0.05567300916138108,-0.16666666666666666,0.07894736842105263,0.17907712522259292
commons-math,remotes/origin/bugs-dot-jar_MATH-631_c0b49542,1,"/**
 * {@inheritDoc}
 */
protected final double doSolve() {
    // Get initial solution
    double x0 = getMin();
    double x1 = getMax();
    double f0 = computeObjectiveValue(x0);
    double f1 = computeObjectiveValue(x1);
    // regardless of the allowed solutions.
    if (f0 == 0.0) {
        return x0;
    }
    if (f1 == 0.0) {
        return x1;
    }
    // Verify bracketing of initial solution.
    verifyBracketing(x0, x1);
    // Get accuracies.
    final double ftol = getFunctionValueAccuracy();
    final double atol = getAbsoluteAccuracy();
    final double rtol = getRelativeAccuracy();
    // Keep track of inverted intervals, meaning that the left bound is
    // larger than the right bound.
    boolean inverted = false;
    // Keep finding better approximations.
    while (true) {
        // Calculate the next approximation.
        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
        final double fx = computeObjectiveValue(x);
        // we can return it regardless of the allowed solutions.
        if (fx == 0.0) {
            return x;
        }
        // Update the bounds with the new approximation.
        if (f1 * fx < 0) {
            // The value of x1 has switched to the other bound, thus inverting
            // the interval.
            x0 = x1;
            f0 = f1;
            inverted = !inverted;
        } else {
            switch(method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                    break;
                case REGULA_FALSI:
                    // Nothing.
                    break;
                default:
                    // Should never happen.
                    throw new MathInternalError();
            }
        }
        // Update from [x0, x1] to [x0, x].
        x1 = x;
        f1 = fx;
        // the root than we already are.
        if (FastMath.abs(f1) <= ftol) {
            switch(allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
            }
        }
        // are satisfied with the current approximation.
        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {
            switch(allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
            }
        }
    }
}","/**
 * {@inheritDoc}
 */
","protected final double doSolve() {
        double x0 = getMin();
    double x1 = getMax();
    double f0 = computeObjectiveValue(x0);
    double f1 = computeObjectiveValue(x1);
        if (f0 == 0.0) {
        return x0;
    }
    if (f1 == 0.0) {
        return x1;
    }
        verifyBracketing(x0, x1);
        final double ftol = getFunctionValueAccuracy();
    final double atol = getAbsoluteAccuracy();
    final double rtol = getRelativeAccuracy();
            boolean inverted = false;
        while (true) {
                final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
        final double fx = computeObjectiveValue(x);
                if (fx == 0.0) {
            return x;
        }
                if (f1 * fx < 0) {
                                    x0 = x1;
            f0 = f1;
            inverted = !inverted;
        } else {
            switch(method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                    break;
                case REGULA_FALSI:
                                        break;
                default:
                                        throw new MathInternalError();
            }
        }
                x1 = x;
        f1 = fx;
                if (FastMath.abs(f1) <= ftol) {
            switch(allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
            }
        }
                if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {
            switch(allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
            }
        }
    }
}",3.3636363636363638,1.727272727272727,7.6,1.5,3.1666666666666665,2.8194444444444446,-1.3371388301620857,0.5833333333333334,-0.02631578947368421,6.527303008823037
Math,18,1,"/**
 * @param x Normalized objective variables.
 * @return {@code true} if in bounds.
 */
public boolean isFeasible(final double[] x) {
    if (boundaries == null) {
        return true;
    }
    for (int i = 0; i < x.length; i++) {
        if (x[i] < 0) {
            return false;
        }
        if (x[i] > 1.0) {
            return false;
        }
    }
    return true;
}","/**
 * @param x Normalized objective variables.
 * @return {@code true} if in bounds.
 */
","public boolean isFeasible(final double[] x) {
    if (boundaries == null) {
        return true;
    }
    for (int i = 0; i < x.length; i++) {
        if (x[i] < 0) {
            return false;
        }
        if (x[i] > 1.0) {
            return false;
        }
    }
    return true;
}",0.0,0.3062200956937798,0.2,0.0,0.16666666666666666,0.3928571428571428,0.05369978858350953,-0.5,1.6842105263157894,0.027318568719996765
wicket,remotes/origin/bugs-dot-jar_WICKET-3076_d3dc9a50,1,"/**
 *  Checks if the url is relative or absolute
 *
 *  @param url
 *  @return <code>true</code> if url is relative, <code>false</code> otherwise
 */
public static boolean isRelative(String url) {
    if ((url != null) && (url.startsWith(""/"") == false) && (url.indexOf(""://"") < 0) && !(url.startsWith(""#""))) {
        return true;
    } else {
        return false;
    }
}","/**
 *  Checks if the url is relative or absolute
 *
 *  @param url
 *  @return <code>true</code> if url is relative, <code>false</code> otherwise
 */
","public static boolean isRelative(String url) {
    if ((url != null) && (url.startsWith(""/"") == false) && (url.indexOf(""://"") < 0) && !(url.startsWith(""#""))) {
        return true;
    } else {
        return false;
    }
}",-0.3181818181818182,0.01435406698564584,-0.4,-0.5,0.25,0.21428571428571425,0.4009866102889356,-0.25,1.6052631578947367,-0.02792252323899425
Closure,154,2,"/**
 * Given a constructor type and a property name, check that the property has
 * the JSDoc annotation @override iff the property is declared on a
 * superclass. Several checks regarding inheritance correctness are also
 * performed.
 */
private void checkDeclaredPropertyInheritance(NodeTraversal t, Node n, FunctionType ctorType, String propertyName, JSDocInfo info, JSType propertyType) {
    // already.
    if (hasUnknownOrEmptySupertype(ctorType)) {
        return;
    }
    FunctionType superClass = ctorType.getSuperClassConstructor();
    boolean superClassHasProperty = superClass != null && superClass.getPrototype().hasProperty(propertyName);
    boolean declaredOverride = info != null && info.isOverride();
    boolean foundInterfaceProperty = false;
    if (ctorType.isConstructor()) {
        for (JSType implementedInterface : ctorType.getImplementedInterfaces()) {
            if (implementedInterface.isUnknownType() || implementedInterface.isEmptyType()) {
                continue;
            }
            FunctionType interfaceType = implementedInterface.toObjectType().getConstructor();
            Preconditions.checkNotNull(interfaceType);
            boolean interfaceHasProperty = interfaceType.getPrototype().hasProperty(propertyName);
            foundInterfaceProperty = foundInterfaceProperty || interfaceHasProperty;
            if (reportMissingOverride.isOn() && !declaredOverride && interfaceHasProperty) {
                // @override not present, but the property does override an interface
                // property
                compiler.report(t.makeError(n, reportMissingOverride, HIDDEN_INTERFACE_PROPERTY, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString()));
            }
            if (interfaceHasProperty) {
                JSType interfacePropType = interfaceType.getPrototype().getPropertyType(propertyName);
                if (!propertyType.canAssignTo(interfacePropType)) {
                    compiler.report(t.makeError(n, HIDDEN_INTERFACE_PROPERTY_MISMATCH, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString(), interfacePropType.toString(), propertyType.toString()));
                }
            }
        }
    }
    if (!declaredOverride && !superClassHasProperty) {
        // nothing to do here, it's just a plain new property
        return;
    }
    JSType topInstanceType = superClassHasProperty ? superClass.getTopMostDefiningType(propertyName) : null;
    if (reportMissingOverride.isOn() && ctorType.isConstructor() && !declaredOverride && superClassHasProperty) {
        // @override not present, but the property does override a superclass
        // property
        compiler.report(t.makeError(n, reportMissingOverride, HIDDEN_SUPERCLASS_PROPERTY, propertyName, topInstanceType.toString()));
    }
    if (!declaredOverride) {
        // there's no @override to check
        return;
    }
    // @override is present and we have to check that it is ok
    if (superClassHasProperty) {
        // there is a superclass implementation
        JSType superClassPropType = superClass.getPrototype().getPropertyType(propertyName);
        if (!propertyType.canAssignTo(superClassPropType)) {
            compiler.report(t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH, propertyName, topInstanceType.toString(), superClassPropType.toString(), propertyType.toString()));
        }
    } else if (!foundInterfaceProperty) {
        // there is no superclass nor interface implementation
        compiler.report(t.makeError(n, UNKNOWN_OVERRIDE, propertyName, ctorType.getInstanceType().toString()));
    }
}","/**
 * Given a constructor type and a property name, check that the property has
 * the JSDoc annotation @override iff the property is declared on a
 * superclass. Several checks regarding inheritance correctness are also
 * performed.
 */
","private void checkDeclaredPropertyInheritance(NodeTraversal t, Node n, FunctionType ctorType, String propertyName, JSDocInfo info, JSType propertyType) {
        if (hasUnknownOrEmptySupertype(ctorType)) {
        return;
    }
    FunctionType superClass = ctorType.getSuperClassConstructor();
    boolean superClassHasProperty = superClass != null && superClass.getPrototype().hasProperty(propertyName);
    boolean declaredOverride = info != null && info.isOverride();
    boolean foundInterfaceProperty = false;
    if (ctorType.isConstructor()) {
        for (JSType implementedInterface : ctorType.getImplementedInterfaces()) {
            if (implementedInterface.isUnknownType() || implementedInterface.isEmptyType()) {
                continue;
            }
            FunctionType interfaceType = implementedInterface.toObjectType().getConstructor();
            Preconditions.checkNotNull(interfaceType);
            boolean interfaceHasProperty = interfaceType.getPrototype().hasProperty(propertyName);
            foundInterfaceProperty = foundInterfaceProperty || interfaceHasProperty;
            if (reportMissingOverride.isOn() && !declaredOverride && interfaceHasProperty) {
                                                compiler.report(t.makeError(n, reportMissingOverride, HIDDEN_INTERFACE_PROPERTY, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString()));
            }
            if (interfaceHasProperty) {
                JSType interfacePropType = interfaceType.getPrototype().getPropertyType(propertyName);
                if (!propertyType.canAssignTo(interfacePropType)) {
                    compiler.report(t.makeError(n, HIDDEN_INTERFACE_PROPERTY_MISMATCH, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString(), interfacePropType.toString(), propertyType.toString()));
                }
            }
        }
    }
    if (!declaredOverride && !superClassHasProperty) {
                return;
    }
    JSType topInstanceType = superClassHasProperty ? superClass.getTopMostDefiningType(propertyName) : null;
    if (reportMissingOverride.isOn() && ctorType.isConstructor() && !declaredOverride && superClassHasProperty) {
                        compiler.report(t.makeError(n, reportMissingOverride, HIDDEN_SUPERCLASS_PROPERTY, propertyName, topInstanceType.toString()));
    }
    if (!declaredOverride) {
                return;
    }
        if (superClassHasProperty) {
                JSType superClassPropType = superClass.getPrototype().getPropertyType(propertyName);
        if (!propertyType.canAssignTo(superClassPropType)) {
            compiler.report(t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH, propertyName, topInstanceType.toString(), superClassPropType.toString(), propertyType.toString()));
        }
    } else if (!foundInterfaceProperty) {
                compiler.report(t.makeError(n, UNKNOWN_OVERRIDE, propertyName, ctorType.getInstanceType().toString()));
    }
}",1.5,0.8373205741626795,2.4,1.0,2.4166666666666665,0.8174603174603174,-0.9117688513037348,3.3333333333333335,-0.02631578947368421,2.8775689678025387
wicket,remotes/origin/bugs-dot-jar_WICKET-4138_7c89598a,1,"/**
 *  Returns base url without context or filter mapping.
 *  <p>
 *  Example: if current url is
 *
 *  <pre>
 *  http://localhost:8080/context/filter/mapping/wicket/bookmarkable/com.foo.Page?1&id=2
 *  </pre>
 *
 *  the base url is <em>wicket/bookmarkable/com.foo.Page</em>
 *  </p>
 *
 *  @see org.apache.wicket.request.Request#getClientUrl()
 */
@Override
public Url getClientUrl() {
    if (errorAttributes != null && !Strings.isEmpty(errorAttributes.getRequestUri())) {
        String problematicURI = Url.parse(errorAttributes.getRequestUri(), getCharset()).toString();
        return getContextRelativeUrl(problematicURI, filterPrefix);
    } else if (!isAjax()) {
        return getContextRelativeUrl(httpServletRequest.getRequestURI(), filterPrefix);
    } else {
        String base = null;
        base = getHeader(HEADER_AJAX_BASE_URL);
        if (base == null) {
            base = getRequestParameters().getParameterValue(PARAM_AJAX_BASE_URL).toString(null);
        }
        Checks.notNull(base, ""Current ajax request is missing the base url header or parameter"");
        return setParameters(Url.parse(base, getCharset()));
    }
}","/**
 *  Returns base url without context or filter mapping.
 *  <p>
 *  Example: if current url is
 *
 *  <pre>
 *  http://localhost:8080/context/filter/mapping/wicket/bookmarkable/com.foo.Page?1&id=2
 *  </pre>
 *
 *  the base url is <em>wicket/bookmarkable/com.foo.Page</em>
 *  </p>
 *
 *  @see org.apache.wicket.request.Request#getClientUrl()
 */
","@Override
public Url getClientUrl() {
    if (errorAttributes != null && !Strings.isEmpty(errorAttributes.getRequestUri())) {
        String problematicURI = Url.parse(errorAttributes.getRequestUri(), getCharset()).toString();
        return getContextRelativeUrl(problematicURI, filterPrefix);
    } else if (!isAjax()) {
        return getContextRelativeUrl(httpServletRequest.getRequestURI(), filterPrefix);
    } else {
        String base = null;
        base = getHeader(HEADER_AJAX_BASE_URL);
        if (base == null) {
            base = getRequestParameters().getParameterValue(PARAM_AJAX_BASE_URL).toString(null);
        }
        Checks.notNull(base, ""Current ajax request is missing the base url header or parameter"");
        return setParameters(Url.parse(base, getCharset()));
    }
}",0.13636363636363635,0.1913875598086124,0.0,0.5,0.3333333333333333,0.3055555555555555,-0.1757575757575757,1.0,-0.02631578947368421,0.29692202186453664
wicket,remotes/origin/bugs-dot-jar_WICKET-172_99e22ce4,1,"/**
 *  @see wicket.Component#renderHead(wicket.markup.html.IHeaderResponse)
 */
@Override
public void renderHead(final IHeaderResponse response) {
    if (isVisible()) {
        super.renderHead(response);
        for (Component child : this) {
            child.renderHead(response);
        }
    }
}","/**
 *  @see wicket.Component#renderHead(wicket.markup.html.IHeaderResponse)
 */
","@Override
public void renderHead(final IHeaderResponse response) {
    if (isVisible()) {
        super.renderHead(response);
        for (Component child : this) {
            child.renderHead(response);
        }
    }
}",-0.22727272727272727,0.5406698564593301,-0.2,0.0,-0.25,-0.3650793650793651,0.4176180408738547,-0.25,0.7894736842105263,-0.16279340490885932
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-4432_c9765c21,3,"@Override
public Iterator<DataIdentifier> getAllIdentifiers() {
    final String path = FilenameUtils.normalizeNoEndSeparator(getPath());
    return Files.fileTreeTraverser().postOrderTraversal(new File(getPath())).filter(new Predicate<File>() {

        @Override
        public boolean apply(File input) {
            return input.isFile() && !input.getParent().equals(path);
        }
    }).transform(new Function<File, DataIdentifier>() {

        @Override
        public DataIdentifier apply(File input) {
            return new DataIdentifier(input.getName());
        }
    }).iterator();
}",,"@Override
public Iterator<DataIdentifier> getAllIdentifiers() {
    final String path = FilenameUtils.normalizeNoEndSeparator(getPath());
    return Files.fileTreeTraverser().postOrderTraversal(new File(getPath())).filter(new Predicate<File>() {

        @Override
        public boolean apply(File input) {
            return input.isFile() && !input.getParent().equals(path);
        }
    }).transform(new Function<File, DataIdentifier>() {

        @Override
        public DataIdentifier apply(File input) {
            return new DataIdentifier(input.getName());
        }
    }).iterator();
}",0.045454545454545456,0.40191387559808606,-0.6,-0.5,-0.4166666666666667,-0.039682539682539715,-0.05031712473572928,0.5,0.02631578947368421,-0.002860715870518624
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1874_3ae276c1,1,"private void collectIndexEditors(NodeBuilder definitions) throws CommitFailedException {
    for (String name : definitions.getChildNodeNames()) {
        NodeBuilder definition = definitions.getChildNode(name);
        if (Objects.equal(async, definition.getString(ASYNC_PROPERTY_NAME))) {
            String type = definition.getString(TYPE_PROPERTY_NAME);
            Editor editor = provider.getIndexEditor(type, definition, root, updateCallback);
            if (editor == null) {
                // trigger reindexing when an indexer becomes available
                definition.setProperty(REINDEX_PROPERTY_NAME, true);
            } else if (definition.getBoolean(REINDEX_PROPERTY_NAME)) {
                if (definition.getBoolean(REINDEX_ASYNC_PROPERTY_NAME) && definition.getString(ASYNC_PROPERTY_NAME) == null) {
                    // switch index to an async update mode
                    definition.setProperty(ASYNC_PROPERTY_NAME, ASYNC_REINDEX_VALUE);
                } else {
                    definition.setProperty(REINDEX_PROPERTY_NAME, false);
                    // beforehand, we'll remove all child nodes
                    for (String rm : definition.getChildNodeNames()) {
                        definition.getChildNode(rm).remove();
                    }
                    reindex.put(concat(getPath(), INDEX_DEFINITIONS_NAME, name), wrap(editor));
                }
            } else {
                editors.add(wrap(editor));
            }
        }
    }
}",,"private void collectIndexEditors(NodeBuilder definitions) throws CommitFailedException {
    for (String name : definitions.getChildNodeNames()) {
        NodeBuilder definition = definitions.getChildNode(name);
        if (Objects.equal(async, definition.getString(ASYNC_PROPERTY_NAME))) {
            String type = definition.getString(TYPE_PROPERTY_NAME);
            Editor editor = provider.getIndexEditor(type, definition, root, updateCallback);
            if (editor == null) {
                                definition.setProperty(REINDEX_PROPERTY_NAME, true);
            } else if (definition.getBoolean(REINDEX_PROPERTY_NAME)) {
                if (definition.getBoolean(REINDEX_ASYNC_PROPERTY_NAME) && definition.getString(ASYNC_PROPERTY_NAME) == null) {
                                        definition.setProperty(ASYNC_PROPERTY_NAME, ASYNC_REINDEX_VALUE);
                } else {
                    definition.setProperty(REINDEX_PROPERTY_NAME, false);
                                        for (String rm : definition.getChildNodeNames()) {
                        definition.getChildNode(rm).remove();
                    }
                    reindex.put(concat(getPath(), INDEX_DEFINITIONS_NAME, name), wrap(editor));
                }
            } else {
                editors.add(wrap(editor));
            }
        }
    }
}",0.45454545454545453,1.645933014354067,0.6,2.0,0.5,0.0079365079365079,-0.4156448202959831,1.25,-0.02631578947368421,0.22955112578735956
commons-math,remotes/origin/bugs-dot-jar_MATH-1127_ba62c59d,1,"/**
 * Returns true if both arguments are equal or within the range of allowed
 * error (inclusive).
 * Two float numbers are considered equal if there are {@code (maxUlps - 1)}
 * (or fewer) floating point numbers between them, i.e. two adjacent floating
 * point numbers are considered equal.
 * Adapted from <a
 * href=""http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm"">
 * Bruce Dawson</a>
 *
 * @param x first value
 * @param y second value
 * @param maxUlps {@code (maxUlps - 1)} is the number of floating point
 * values between {@code x} and {@code y}.
 * @return {@code true} if there are fewer than {@code maxUlps} floating
 * point values between {@code x} and {@code y}.
 */
public static boolean equals(double x, double y, int maxUlps) {
    long xInt = Double.doubleToLongBits(x);
    long yInt = Double.doubleToLongBits(y);
    // Make lexicographically ordered as a two's-complement integer.
    if (xInt < 0) {
        xInt = SGN_MASK - xInt;
    }
    if (yInt < 0) {
        yInt = SGN_MASK - yInt;
    }
    final boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;
    return isEqual && !Double.isNaN(x) && !Double.isNaN(y);
}","/**
 * Returns true if both arguments are equal or within the range of allowed
 * error (inclusive).
 * Two float numbers are considered equal if there are {@code (maxUlps - 1)}
 * (or fewer) floating point numbers between them, i.e. two adjacent floating
 * point numbers are considered equal.
 * Adapted from <a
 * href=""http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm"">
 * Bruce Dawson</a>
 *
 * @param x first value
 * @param y second value
 * @param maxUlps {@code (maxUlps - 1)} is the number of floating point
 * values between {@code x} and {@code y}.
 * @return {@code true} if there are fewer than {@code maxUlps} floating
 * point values between {@code x} and {@code y}.
 */
","public static boolean equals(double x, double y, int maxUlps) {
    long xInt = Double.doubleToLongBits(x);
    long yInt = Double.doubleToLongBits(y);
        if (xInt < 0) {
        xInt = SGN_MASK - xInt;
    }
    if (yInt < 0) {
        yInt = SGN_MASK - yInt;
    }
    final boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;
    return isEqual && !Double.isNaN(x) && !Double.isNaN(y);
}",-0.09090909090909091,-0.32535885167464124,-0.2,-0.5,-0.08333333333333333,1.0634920634920635,0.03312191684284699,-0.08333333333333333,0.2368421052631579,0.566207361560139
camel,remotes/origin/bugs-dot-jar_CAMEL-7586_1f92fa42,3,"@ManagedAttribute(description = ""Message History"")
Boolean getMessageHistory();",,"@ManagedAttribute(description = ""Message History"")
Boolean getMessageHistory();",-0.5454545454545454,-1.4306220095693782,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,1.252854122621564,-0.5,2.5789473684210527,-0.16279340490885932
JxPath,4,1,"protected String getLanguage() {
    Object n = node;
    while (n != null) {
        if (n instanceof Element) {
            Element e = (Element) n;
            String attr = e.getAttributeValue(""lang"", Namespace.XML_NAMESPACE);
            if (attr != null && !attr.equals("""")) {
                return attr;
            }
        }
        n = nodeParent(n);
    }
    return null;
}",,"protected String getLanguage() {
    Object n = node;
    while (n != null) {
        if (n instanceof Element) {
            Element e = (Element) n;
            String attr = e.getAttributeValue(""lang"", Namespace.XML_NAMESPACE);
            if (attr != null && !attr.equals("""")) {
                return attr;
            }
        }
        n = nodeParent(n);
    }
    return null;
}",0.0,0.8421052631578947,0.0,0.5,0.16666666666666666,0.3591269841269841,-0.007470049330514461,-0.25,1.0263157894736843,0.12523296623502359
commons-math,remotes/origin/bugs-dot-jar_MATH-1226_c44bfe00,3,"/**
 * Evaluate the impact of the proposed step on the event handler.
 * @param interpolator step interpolator for the proposed step
 * @return true if the event handler triggers an event before
 * the end of the proposed step
 * @exception MaxCountExceededException if the interpolator throws one because
 * the number of functions evaluations is exceeded
 * @exception NoBracketingException if the event cannot be bracketed
 */
public boolean evaluateStep(final StepInterpolator interpolator) throws MaxCountExceededException, NoBracketingException {
    try {
        forward = interpolator.isForward();
        final double t1 = interpolator.getCurrentTime();
        final double dt = t1 - t0;
        if (FastMath.abs(dt) < convergence) {
            // we cannot do anything on such a small step, don't trigger any events
            return false;
        }
        final int n = FastMath.max(1, (int) FastMath.ceil(FastMath.abs(dt) / maxCheckInterval));
        final double h = dt / n;
        final UnivariateFunction f = new UnivariateFunction() {

            public double value(final double t) throws LocalMaxCountExceededException {
                try {
                    interpolator.setInterpolatedTime(t);
                    return handler.g(t, getCompleteState(interpolator));
                } catch (MaxCountExceededException mcee) {
                    throw new LocalMaxCountExceededException(mcee);
                }
            }
        };
        double ta = t0;
        double ga = g0;
        for (int i = 0; i < n; ++i) {
            // evaluate handler value at the end of the substep
            final double tb = t0 + (i + 1) * h;
            interpolator.setInterpolatedTime(tb);
            final double gb = handler.g(tb, getCompleteState(interpolator));
            // check events occurrence
            if (g0Positive ^ (gb >= 0)) {
                // there is a sign change: an event is expected during this step
                // variation direction, with respect to the integration direction
                increasing = gb >= ga;
                // find the event time making sure we select a solution just at or past the exact root
                final double root;
                if (solver instanceof BracketedUnivariateSolver<?>) {
                    @SuppressWarnings(""unchecked"")
                    BracketedUnivariateSolver<UnivariateFunction> bracketing = (BracketedUnivariateSolver<UnivariateFunction>) solver;
                    root = forward ? bracketing.solve(maxIterationCount, f, ta, tb, AllowedSolution.RIGHT_SIDE) : bracketing.solve(maxIterationCount, f, tb, ta, AllowedSolution.LEFT_SIDE);
                } else {
                    final double baseRoot = forward ? solver.solve(maxIterationCount, f, ta, tb) : solver.solve(maxIterationCount, f, tb, ta);
                    final int remainingEval = maxIterationCount - solver.getEvaluations();
                    BracketedUnivariateSolver<UnivariateFunction> bracketing = new PegasusSolver(solver.getRelativeAccuracy(), solver.getAbsoluteAccuracy());
                    root = forward ? UnivariateSolverUtils.forceSide(remainingEval, f, bracketing, baseRoot, ta, tb, AllowedSolution.RIGHT_SIDE) : UnivariateSolverUtils.forceSide(remainingEval, f, bracketing, baseRoot, tb, ta, AllowedSolution.LEFT_SIDE);
                }
                if ((!Double.isNaN(previousEventTime)) && (FastMath.abs(root - ta) <= convergence) && (FastMath.abs(root - previousEventTime) <= convergence)) {
                    // crosses the axis several times
                    do {
                        ta = forward ? ta + convergence : ta - convergence;
                        ga = f.value(ta);
                    } while ((g0Positive ^ (ga >= 0)) && (forward ^ (ta >= tb)));
                    --i;
                } else if (Double.isNaN(previousEventTime) || (FastMath.abs(previousEventTime - root) > convergence)) {
                    pendingEventTime = root;
                    pendingEvent = true;
                    return true;
                } else {
                    // no sign change: there is no event for now
                    ta = tb;
                    ga = gb;
                }
            } else {
                // no sign change: there is no event for now
                ta = tb;
                ga = gb;
            }
        }
        // no event during the whole step
        pendingEvent = false;
        pendingEventTime = Double.NaN;
        return false;
    } catch (LocalMaxCountExceededException lmcee) {
        throw lmcee.getException();
    }
}","/**
 * Evaluate the impact of the proposed step on the event handler.
 * @param interpolator step interpolator for the proposed step
 * @return true if the event handler triggers an event before
 * the end of the proposed step
 * @exception MaxCountExceededException if the interpolator throws one because
 * the number of functions evaluations is exceeded
 * @exception NoBracketingException if the event cannot be bracketed
 */
","public boolean evaluateStep(final StepInterpolator interpolator) throws MaxCountExceededException, NoBracketingException {
    try {
        forward = interpolator.isForward();
        final double t1 = interpolator.getCurrentTime();
        final double dt = t1 - t0;
        if (FastMath.abs(dt) < convergence) {
                        return false;
        }
        final int n = FastMath.max(1, (int) FastMath.ceil(FastMath.abs(dt) / maxCheckInterval));
        final double h = dt / n;
        final UnivariateFunction f = new UnivariateFunction() {

            public double value(final double t) throws LocalMaxCountExceededException {
                try {
                    interpolator.setInterpolatedTime(t);
                    return handler.g(t, getCompleteState(interpolator));
                } catch (MaxCountExceededException mcee) {
                    throw new LocalMaxCountExceededException(mcee);
                }
            }
        };
        double ta = t0;
        double ga = g0;
        for (int i = 0; i < n; ++i) {
                        final double tb = t0 + (i + 1) * h;
            interpolator.setInterpolatedTime(tb);
            final double gb = handler.g(tb, getCompleteState(interpolator));
                        if (g0Positive ^ (gb >= 0)) {
                                                increasing = gb >= ga;
                                final double root;
                if (solver instanceof BracketedUnivariateSolver<?>) {
                    @SuppressWarnings(""unchecked"")
                    BracketedUnivariateSolver<UnivariateFunction> bracketing = (BracketedUnivariateSolver<UnivariateFunction>) solver;
                    root = forward ? bracketing.solve(maxIterationCount, f, ta, tb, AllowedSolution.RIGHT_SIDE) : bracketing.solve(maxIterationCount, f, tb, ta, AllowedSolution.LEFT_SIDE);
                } else {
                    final double baseRoot = forward ? solver.solve(maxIterationCount, f, ta, tb) : solver.solve(maxIterationCount, f, tb, ta);
                    final int remainingEval = maxIterationCount - solver.getEvaluations();
                    BracketedUnivariateSolver<UnivariateFunction> bracketing = new PegasusSolver(solver.getRelativeAccuracy(), solver.getAbsoluteAccuracy());
                    root = forward ? UnivariateSolverUtils.forceSide(remainingEval, f, bracketing, baseRoot, ta, tb, AllowedSolution.RIGHT_SIDE) : UnivariateSolverUtils.forceSide(remainingEval, f, bracketing, baseRoot, tb, ta, AllowedSolution.LEFT_SIDE);
                }
                if ((!Double.isNaN(previousEventTime)) && (FastMath.abs(root - ta) <= convergence) && (FastMath.abs(root - previousEventTime) <= convergence)) {
                                        do {
                        ta = forward ? ta + convergence : ta - convergence;
                        ga = f.value(ta);
                    } while ((g0Positive ^ (ga >= 0)) && (forward ^ (ta >= tb)));
                    --i;
                } else if (Double.isNaN(previousEventTime) || (FastMath.abs(previousEventTime - root) > convergence)) {
                    pendingEventTime = root;
                    pendingEvent = true;
                    return true;
                } else {
                                        ta = tb;
                    ga = gb;
                }
            } else {
                                ta = tb;
                ga = gb;
            }
        }
                pendingEvent = false;
        pendingEventTime = Double.NaN;
        return false;
    } catch (LocalMaxCountExceededException lmcee) {
        throw lmcee.getException();
    }
}",2.3181818181818183,1.3779904306220097,2.4,1.5,2.3333333333333335,4.023809523809524,-1.1282593375616627,1.8333333333333333,-0.02631578947368421,17.826157915665355
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2260_0ac7ff20,1,"// implementation of RemoteSegmentLoader
public Segment getSegment() {
    boolean interrupted = false;
    try {
        for (; ; ) {
            try {
                // log.debug(""polling segment"");
                Segment s = segment.poll(timeoutMs, TimeUnit.MILLISECONDS);
                // log.debug(""returning segment "" + s.getSegmentId());
                return s;
            } catch (InterruptedException ignore) {
                interrupted = true;
            }
        }
    } finally {
        if (interrupted) {
            Thread.currentThread().interrupt();
        }
    }
}",,"public Segment getSegment() {
    boolean interrupted = false;
    try {
        for (; ; ) {
            try {
                                Segment s = segment.poll(timeoutMs, TimeUnit.MILLISECONDS);
                                return s;
            } catch (InterruptedException ignore) {
                interrupted = true;
            }
        }
    } finally {
        if (interrupted) {
            Thread.currentThread().interrupt();
        }
    }
}",0.13636363636363635,1.0143540669856461,0.0,0.5,-0.25,-0.3650793650793651,-0.017336152219873002,-0.25,0.8421052631578947,-0.16279340490885932
camel,remotes/origin/bugs-dot-jar_CAMEL-4354_96e40c3c,1,"/**
 * Sends an exchange to an endpoint using a supplied callback supporting the asynchronous routing engine.
 * <p/>
 * If an exception was thrown during processing, it would be set on the given Exchange
 *
 * @param endpoint         the endpoint to send the exchange to
 * @param exchange         the exchange, can be <tt>null</tt> if so then create a new exchange from the producer
 * @param pattern          the exchange pattern, can be <tt>null</tt>
 * @param callback         the asynchronous callback
 * @param producerCallback the producer template callback to be executed
 * @return (doneSync) <tt>true</tt> to continue execute synchronously, <tt>false</tt> to continue being executed asynchronously
 */
public boolean doInAsyncProducer(Endpoint endpoint, Exchange exchange, ExchangePattern pattern, AsyncCallback callback, AsyncProducerCallback producerCallback) {
    boolean sync = true;
    // get the producer and we do not mind if its pooled as we can handle returning it back to the pool
    Producer producer = doGetProducer(endpoint, true);
    if (producer == null) {
        if (isStopped()) {
            LOG.warn(""Ignoring exchange sent after processor is stopped: "" + exchange);
            return false;
        } else {
            throw new IllegalStateException(""No producer, this processor has not been started: "" + this);
        }
    }
    StopWatch watch = null;
    if (exchange != null) {
        // record timing for sending the exchange using the producer
        watch = new StopWatch();
    }
    try {
        // invoke the callback
        AsyncProcessor asyncProcessor = AsyncProcessorTypeConverter.convert(producer);
        sync = producerCallback.doInAsyncProducer(producer, asyncProcessor, exchange, pattern, callback);
    } catch (Throwable e) {
        // ensure exceptions is caught and set on the exchange
        if (exchange != null) {
            exchange.setException(e);
        }
    } finally {
        if (exchange != null && exchange.getException() == null) {
            long timeTaken = watch.stop();
            // emit event that the exchange was sent to the endpoint
            EventHelper.notifyExchangeSent(exchange.getContext(), exchange, endpoint, timeTaken);
        }
        if (producer instanceof ServicePoolAware) {
            // release back to the pool
            pool.release(endpoint, producer);
        } else if (!producer.isSingleton()) {
            // stop non singleton producers as we should not leak resources
            try {
                ServiceHelper.stopService(producer);
            } catch (Exception e) {
                // ignore and continue
                LOG.warn(""Error stopping producer: "" + producer, e);
            }
        }
    }
    return sync;
}","/**
 * Sends an exchange to an endpoint using a supplied callback supporting the asynchronous routing engine.
 * <p/>
 * If an exception was thrown during processing, it would be set on the given Exchange
 *
 * @param endpoint         the endpoint to send the exchange to
 * @param exchange         the exchange, can be <tt>null</tt> if so then create a new exchange from the producer
 * @param pattern          the exchange pattern, can be <tt>null</tt>
 * @param callback         the asynchronous callback
 * @param producerCallback the producer template callback to be executed
 * @return (doneSync) <tt>true</tt> to continue execute synchronously, <tt>false</tt> to continue being executed asynchronously
 */
","public boolean doInAsyncProducer(Endpoint endpoint, Exchange exchange, ExchangePattern pattern, AsyncCallback callback, AsyncProducerCallback producerCallback) {
    boolean sync = true;
        Producer producer = doGetProducer(endpoint, true);
    if (producer == null) {
        if (isStopped()) {
            LOG.warn(""Ignoring exchange sent after processor is stopped: "" + exchange);
            return false;
        } else {
            throw new IllegalStateException(""No producer, this processor has not been started: "" + this);
        }
    }
    StopWatch watch = null;
    if (exchange != null) {
                watch = new StopWatch();
    }
    try {
                AsyncProcessor asyncProcessor = AsyncProcessorTypeConverter.convert(producer);
        sync = producerCallback.doInAsyncProducer(producer, asyncProcessor, exchange, pattern, callback);
    } catch (Throwable e) {
                if (exchange != null) {
            exchange.setException(e);
        }
    } finally {
        if (exchange != null && exchange.getException() == null) {
            long timeTaken = watch.stop();
                        EventHelper.notifyExchangeSent(exchange.getContext(), exchange, endpoint, timeTaken);
        }
        if (producer instanceof ServicePoolAware) {
                        pool.release(endpoint, producer);
        } else if (!producer.isSingleton()) {
                        try {
                ServiceHelper.stopService(producer);
            } catch (Exception e) {
                                LOG.warn(""Error stopping producer: "" + producer, e);
            }
        }
    }
    return sync;
}",1.1363636363636365,0.4545454545454545,1.4,1.0,0.6666666666666666,0.75,-0.7082452431289639,0.6666666666666666,-0.02631578947368421,1.4340992260391991
Csv,3,1,"// TODO escape handling needs more work
/**
 * Handle an escape sequence.
 * The current character must be the escape character.
 * On return, the next character is available by calling {@link ExtendedBufferedReader#getLastChar()}
 * on the input stream.
 *
 * @return the unescaped character (as an int) or {@link END_OF_STREAM} if char following the escape is invalid.
 * @throws IOException if there is a problem reading the stream or the end of stream is detected:
 * the escape character is not allowed at end of strem
 */
int readEscape() throws IOException {
    // the escape char has just been read (normally a backslash)
    final int c = in.read();
    switch(c) {
        case 'r':
            return CR;
        case 'n':
            return LF;
        case 't':
            return TAB;
        case 'b':
            return BACKSPACE;
        case 'f':
            return FF;
        case CR:
        case LF:
        // TODO is this correct?
        case FF:
        // TODO is this correct? Do tabs need to be escaped?
        case TAB:
        case // TODO is this correct?
        BACKSPACE:
            return c;
        case END_OF_STREAM:
            throw new IOException(""EOF whilst processing escape sequence"");
        default:
            // Now check for meta-characters
            return c;
    }
}","/**
 * Handle an escape sequence.
 * The current character must be the escape character.
 * On return, the next character is available by calling {@link ExtendedBufferedReader#getLastChar()}
 * on the input stream.
 *
 * @return the unescaped character (as an int) or {@link END_OF_STREAM} if char following the escape is invalid.
 * @throws IOException if there is a problem reading the stream or the end of stream is detected:
 * the escape character is not allowed at end of strem
 */
","int readEscape() throws IOException {
        final int c = in.read();
    switch(c) {
        case 'r':
            return CR;
        case 'n':
            return LF;
        case 't':
            return TAB;
        case 'b':
            return BACKSPACE;
        case 'f':
            return FF;
        case CR:
        case LF:
                case FF:
                case TAB:
        case         BACKSPACE:
            return c;
        case END_OF_STREAM:
            throw new IOException(""EOF whilst processing escape sequence"");
        default:
                        return c;
    }
}",0.5454545454545454,0.20574162679425825,2.0,0.0,0.5833333333333334,-0.3650793650793651,-0.3014799154334035,-0.4166666666666667,-0.02631578947368421,-0.16279340490885932
camel,remotes/origin/bugs-dot-jar_CAMEL-5704_708e756d,1,"/**
 * Sets the given {@link org.apache.camel.processor.aggregate.AggregationStrategy} on the {@link Exchange}.
 *
 * @param exchange            the exchange
 * @param aggregationStrategy the strategy
 */
protected void setAggregationStrategyOnExchange(Exchange exchange, AggregationStrategy aggregationStrategy) {
    Map<?, ?> property = exchange.getProperty(Exchange.AGGREGATION_STRATEGY, Map.class);
    Map<Object, AggregationStrategy> map = CastUtils.cast(property);
    if (map == null) {
        map = new HashMap<Object, AggregationStrategy>();
    }
    // store the strategy using this processor as the key
    // (so we can store multiple strategies on the same exchange)
    map.put(this, aggregationStrategy);
    exchange.setProperty(Exchange.AGGREGATION_STRATEGY, map);
}","/**
 * Sets the given {@link org.apache.camel.processor.aggregate.AggregationStrategy} on the {@link Exchange}.
 *
 * @param exchange            the exchange
 * @param aggregationStrategy the strategy
 */
","protected void setAggregationStrategyOnExchange(Exchange exchange, AggregationStrategy aggregationStrategy) {
    Map<?, ?> property = exchange.getProperty(Exchange.AGGREGATION_STRATEGY, Map.class);
    Map<Object, AggregationStrategy> map = CastUtils.cast(property);
    if (map == null) {
        map = new HashMap<Object, AggregationStrategy>();
    }
            map.put(this, aggregationStrategy);
    exchange.setProperty(Exchange.AGGREGATION_STRATEGY, map);
}",-0.22727272727272727,-0.3444976076555025,-0.4,-0.5,-0.25,0.009920634920634885,0.21353065539112054,-0.16666666666666666,0.05263157894736841,-0.019771442402448082
commons-math,remotes/origin/bugs-dot-jar_MATH-705_645d642b,1,"/**
 * Reinitialize the instance
 * <p>Some Runge-Kutta integrators need fewer functions evaluations
 * than their counterpart step interpolators. So the interpolator
 * should perform the last evaluations they need by themselves. The
 * {@link RungeKuttaIntegrator RungeKuttaIntegrator} and {@link
 * EmbeddedRungeKuttaIntegrator EmbeddedRungeKuttaIntegrator}
 * abstract classes call this method in order to let the step
 * interpolator perform the evaluations it needs. These evaluations
 * will be performed during the call to <code>doFinalize</code> if
 * any, i.e. only if the step handler either calls the {@link
 * AbstractStepInterpolator#finalizeStep finalizeStep} method or the
 * {@link AbstractStepInterpolator#getInterpolatedState
 * getInterpolatedState} method (for an interpolator which needs a
 * finalization) or if it clones the step interpolator.</p>
 * @param rkIntegrator integrator being used
 * @param y reference to the integrator array holding the state at
 * the end of the step
 * @param yDotArray reference to the integrator array holding all the
 * intermediate slopes
 * @param forward integration direction indicator
 * @param primaryMapper equations mapper for the primary equations set
 * @param secondaryMappers equations mappers for the secondary equations sets
 */
public void reinitialize(final AbstractIntegrator rkIntegrator, final double[] y, final double[][] yDotArray, final boolean forward, final EquationsMapper primaryMapper, final EquationsMapper[] secondaryMappers) {
    reinitialize(y, forward, primaryMapper, secondaryMappers);
    this.yDotK = yDotArray;
    this.integrator = rkIntegrator;
}","/**
 * Reinitialize the instance
 * <p>Some Runge-Kutta integrators need fewer functions evaluations
 * than their counterpart step interpolators. So the interpolator
 * should perform the last evaluations they need by themselves. The
 * {@link RungeKuttaIntegrator RungeKuttaIntegrator} and {@link
 * EmbeddedRungeKuttaIntegrator EmbeddedRungeKuttaIntegrator}
 * abstract classes call this method in order to let the step
 * interpolator perform the evaluations it needs. These evaluations
 * will be performed during the call to <code>doFinalize</code> if
 * any, i.e. only if the step handler either calls the {@link
 * AbstractStepInterpolator#finalizeStep finalizeStep} method or the
 * {@link AbstractStepInterpolator#getInterpolatedState
 * getInterpolatedState} method (for an interpolator which needs a
 * finalization) or if it clones the step interpolator.</p>
 * @param rkIntegrator integrator being used
 * @param y reference to the integrator array holding the state at
 * the end of the step
 * @param yDotArray reference to the integrator array holding all the
 * intermediate slopes
 * @param forward integration direction indicator
 * @param primaryMapper equations mapper for the primary equations set
 * @param secondaryMappers equations mappers for the secondary equations sets
 */
","public void reinitialize(final AbstractIntegrator rkIntegrator, final double[] y, final double[][] yDotArray, final boolean forward, final EquationsMapper primaryMapper, final EquationsMapper[] secondaryMappers) {
    reinitialize(y, forward, primaryMapper, secondaryMappers);
    this.yDotK = yDotArray;
    this.integrator = rkIntegrator;
}",-0.4090909090909091,-0.49282296650717716,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.5912614517265677,-0.4166666666666667,-0.02631578947368421,-0.16279340490885932
Closure,169,2,"/**
 * Checks if two types are equivalent.
 */
public final boolean isEquivalentTo(JSType that) {
    return checkEquivalenceHelper(that, false);
}","/**
 * Checks if two types are equivalent.
 */
","public final boolean isEquivalentTo(JSType that) {
    return checkEquivalenceHelper(that, false);
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,1.0451021846370678,-0.4166666666666667,2.5789473684210527,-0.16279340490885932
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1822_3e83a4c1,1,"/**
 * Apply the changes to the in-memory document.
 *
 * @param doc
 *            the target document.
 * @param update
 *            the changes to apply.
 * @param comparator
 *            the revision comparator.
 */
public static void applyChanges(@Nonnull Document doc, @Nonnull UpdateOp update, @Nonnull Comparator<Revision> comparator) {
    for (Entry<Key, Operation> e : checkNotNull(update).getChanges().entrySet()) {
        Key k = e.getKey();
        Operation op = e.getValue();
        switch(op.type) {
            case SET:
                {
                    doc.put(k.toString(), op.value);
                    break;
                }
            case INCREMENT:
                {
                    Object old = doc.get(k.toString());
                    Long x = (Long) op.value;
                    if (old == null) {
                        old = 0L;
                    }
                    doc.put(k.toString(), ((Long) old) + x);
                    break;
                }
            case SET_MAP_ENTRY:
                {
                    Object old = doc.get(k.getName());
                    @SuppressWarnings(""unchecked"")
                    Map<Revision, Object> m = (Map<Revision, Object>) old;
                    if (m == null) {
                        m = new TreeMap<Revision, Object>(comparator);
                        doc.put(k.getName(), m);
                    }
                    if (k.getRevision() == null) {
                        throw new IllegalArgumentException(""Cannot set map entry "" + k.getName() + "" with null revision"");
                    }
                    m.put(k.getRevision(), op.value);
                    break;
                }
            case REMOVE_MAP_ENTRY:
                {
                    Object old = doc.get(k.getName());
                    @SuppressWarnings(""unchecked"")
                    Map<Revision, Object> m = (Map<Revision, Object>) old;
                    if (m != null) {
                        m.remove(k.getRevision());
                    }
                    break;
                }
            case CONTAINS_MAP_ENTRY:
                // no effect
                break;
        }
    }
}","/**
 * Apply the changes to the in-memory document.
 *
 * @param doc
 *            the target document.
 * @param update
 *            the changes to apply.
 * @param comparator
 *            the revision comparator.
 */
","public static void applyChanges(@Nonnull Document doc, @Nonnull UpdateOp update, @Nonnull Comparator<Revision> comparator) {
    for (Entry<Key, Operation> e : checkNotNull(update).getChanges().entrySet()) {
        Key k = e.getKey();
        Operation op = e.getValue();
        switch(op.type) {
            case SET:
                {
                    doc.put(k.toString(), op.value);
                    break;
                }
            case INCREMENT:
                {
                    Object old = doc.get(k.toString());
                    Long x = (Long) op.value;
                    if (old == null) {
                        old = 0L;
                    }
                    doc.put(k.toString(), ((Long) old) + x);
                    break;
                }
            case SET_MAP_ENTRY:
                {
                    Object old = doc.get(k.getName());
                    @SuppressWarnings(""unchecked"")
                    Map<Revision, Object> m = (Map<Revision, Object>) old;
                    if (m == null) {
                        m = new TreeMap<Revision, Object>(comparator);
                        doc.put(k.getName(), m);
                    }
                    if (k.getRevision() == null) {
                        throw new IllegalArgumentException(""Cannot set map entry "" + k.getName() + "" with null revision"");
                    }
                    m.put(k.getRevision(), op.value);
                    break;
                }
            case REMOVE_MAP_ENTRY:
                {
                    Object old = doc.get(k.getName());
                    @SuppressWarnings(""unchecked"")
                    Map<Revision, Object> m = (Map<Revision, Object>) old;
                    if (m != null) {
                        m.remove(k.getRevision());
                    }
                    break;
                }
            case CONTAINS_MAP_ENTRY:
                                break;
        }
    }
}",1.6363636363636365,1.449760765550239,2.6,1.0,0.6666666666666666,0.6845238095238095,-0.9016208597603944,1.4166666666666667,-0.02631578947368421,1.8259089573140155
commons-math,remotes/origin/bugs-dot-jar_MATH-631_ebc61de9,1,"/**
 * {@inheritDoc}
 */
protected final double doSolve() {
    // Get initial solution
    double x0 = getMin();
    double x1 = getMax();
    double f0 = computeObjectiveValue(x0);
    double f1 = computeObjectiveValue(x1);
    // regardless of the allowed solutions.
    if (f0 == 0.0) {
        return x0;
    }
    if (f1 == 0.0) {
        return x1;
    }
    // Verify bracketing of initial solution.
    verifyBracketing(x0, x1);
    // Get accuracies.
    final double ftol = getFunctionValueAccuracy();
    final double atol = getAbsoluteAccuracy();
    final double rtol = getRelativeAccuracy();
    // Keep track of inverted intervals, meaning that the left bound is
    // larger than the right bound.
    boolean inverted = false;
    // Keep finding better approximations.
    while (true) {
        // Calculate the next approximation.
        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
        final double fx = computeObjectiveValue(x);
        // we can return it regardless of the allowed solutions.
        if (fx == 0.0) {
            return x;
        }
        // Update the bounds with the new approximation.
        if (f1 * fx < 0) {
            // The value of x1 has switched to the other bound, thus inverting
            // the interval.
            x0 = x1;
            f0 = f1;
            inverted = !inverted;
        } else {
            switch(method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                    break;
                case REGULA_FALSI:
                    if (x == x1) {
                        final double delta = FastMath.max(rtol * FastMath.abs(x1), atol);
                        // Update formula cannot make any progress: Update the
                        // search interval.
                        x0 = 0.5 * (x0 + x1 - delta);
                        f0 = computeObjectiveValue(x0);
                    }
                    break;
                default:
                    // Should never happen.
                    throw new MathInternalError();
            }
        }
        // Update from [x0, x1] to [x0, x].
        x1 = x;
        f1 = fx;
        // the root than we already are.
        if (FastMath.abs(f1) <= ftol) {
            switch(allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
            }
        }
        // are satisfied with the current approximation.
        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {
            switch(allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
            }
        }
    }
}","/**
 * {@inheritDoc}
 */
","protected final double doSolve() {
        double x0 = getMin();
    double x1 = getMax();
    double f0 = computeObjectiveValue(x0);
    double f1 = computeObjectiveValue(x1);
        if (f0 == 0.0) {
        return x0;
    }
    if (f1 == 0.0) {
        return x1;
    }
        verifyBracketing(x0, x1);
        final double ftol = getFunctionValueAccuracy();
    final double atol = getAbsoluteAccuracy();
    final double rtol = getRelativeAccuracy();
            boolean inverted = false;
        while (true) {
                final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
        final double fx = computeObjectiveValue(x);
                if (fx == 0.0) {
            return x;
        }
                if (f1 * fx < 0) {
                                    x0 = x1;
            f0 = f1;
            inverted = !inverted;
        } else {
            switch(method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                    break;
                case REGULA_FALSI:
                    if (x == x1) {
                        final double delta = FastMath.max(rtol * FastMath.abs(x1), atol);
                                                                        x0 = 0.5 * (x0 + x1 - delta);
                        f0 = computeObjectiveValue(x0);
                    }
                    break;
                default:
                                        throw new MathInternalError();
            }
        }
                x1 = x;
        f1 = fx;
                if (FastMath.abs(f1) <= ftol) {
            switch(allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
            }
        }
                if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {
            switch(allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
            }
        }
    }
}",3.590909090909091,1.799043062200957,7.8,1.5,3.3333333333333335,3.196428571428571,-1.3915433403805495,0.8333333333333334,-0.02631578947368421,8.570619456786707
camel,remotes/origin/bugs-dot-jar_CAMEL-9340_1cab39f6,3,"/**
 * Loads the given file store into the 1st level cache
 */
protected void loadStore() throws IOException {
    // auto create starting directory if needed
    if (!fileStore.exists()) {
        LOG.debug(""Creating filestore: {}"", fileStore);
        File parent = fileStore.getParentFile();
        parent.mkdirs();
        boolean created = FileUtil.createNewFile(fileStore);
        if (!created) {
            throw new IOException(""Cannot create filestore: "" + fileStore);
        }
    }
    LOG.trace(""Loading to 1st level cache from idempotent filestore: {}"", fileStore);
    cache.clear();
    Scanner scanner = null;
    try {
        scanner = new Scanner(fileStore);
        scanner.useDelimiter(STORE_DELIMITER);
        while (scanner.hasNextLine()) {
            String line = scanner.nextLine();
            cache.put(line, line);
        }
    } catch (IOException e) {
        throw ObjectHelper.wrapRuntimeCamelException(e);
    } finally {
        if (scanner != null) {
            scanner.close();
        }
    }
    LOG.debug(""Loaded {} to the 1st level cache from idempotent filestore: {}"", cache.size(), fileStore);
}","/**
 * Loads the given file store into the 1st level cache
 */
","protected void loadStore() throws IOException {
        if (!fileStore.exists()) {
        LOG.debug(""Creating filestore: {}"", fileStore);
        File parent = fileStore.getParentFile();
        parent.mkdirs();
        boolean created = FileUtil.createNewFile(fileStore);
        if (!created) {
            throw new IOException(""Cannot create filestore: "" + fileStore);
        }
    }
    LOG.trace(""Loading to 1st level cache from idempotent filestore: {}"", fileStore);
    cache.clear();
    Scanner scanner = null;
    try {
        scanner = new Scanner(fileStore);
        scanner.useDelimiter(STORE_DELIMITER);
        while (scanner.hasNextLine()) {
            String line = scanner.nextLine();
            cache.put(line, line);
        }
    } catch (IOException e) {
        throw ObjectHelper.wrapRuntimeCamelException(e);
    } finally {
        if (scanner != null) {
            scanner.close();
        }
    }
    LOG.debug(""Loaded {} to the 1st level cache from idempotent filestore: {}"", cache.size(), fileStore);
}",0.6818181818181818,0.10047846889952151,0.8,0.0,0.25,0.32936507936507936,-0.48386187455954865,0.75,-0.02631578947368421,0.4555131020095318
flink,remotes/origin/bugs-dot-jar_FLINK-2121_03340919,3,"/**
 *  Computes the input splits for the file. By default, one file block is one split. If more splits
 *  are requested than blocks are available, then a split may be a fraction of a block and splits may cross
 *  block boundaries.
 *
 *  @param minNumSplits The minimum desired number of file splits.
 *  @return The computed file splits.
 *
 *  @see org.apache.flink.api.common.io.InputFormat#createInputSplits(int)
 */
@Override
public FileInputSplit[] createInputSplits(int minNumSplits) throws IOException {
    if (minNumSplits < 1) {
        throw new IllegalArgumentException(""Number of input splits has to be at least 1."");
    }
    // take the desired number of splits into account
    minNumSplits = Math.max(minNumSplits, this.numSplits);
    final Path path = this.filePath;
    final List<FileInputSplit> inputSplits = new ArrayList<FileInputSplit>(minNumSplits);
    // get all the files that are involved in the splits
    List<FileStatus> files = new ArrayList<FileStatus>();
    long totalLength = 0;
    final FileSystem fs = path.getFileSystem();
    final FileStatus pathFile = fs.getFileStatus(path);
    if (pathFile.isDir()) {
        totalLength += addFilesInDir(path, files, totalLength, true);
    } else {
        testForUnsplittable(pathFile);
        files.add(pathFile);
        totalLength += pathFile.getLen();
    }
    // returns if unsplittable
    if (unsplittable) {
        int splitNum = 0;
        for (final FileStatus file : files) {
            final BlockLocation[] blocks = fs.getFileBlockLocations(file, 0, file.getLen());
            Set<String> hosts = new HashSet<String>();
            for (BlockLocation block : blocks) {
                hosts.addAll(Arrays.asList(block.getHosts()));
            }
            long len = file.getLen();
            if (testForUnsplittable(file)) {
                len = READ_WHOLE_SPLIT_FLAG;
            }
            FileInputSplit fis = new FileInputSplit(splitNum++, file.getPath(), 0, len, hosts.toArray(new String[hosts.size()]));
            inputSplits.add(fis);
        }
        return inputSplits.toArray(new FileInputSplit[inputSplits.size()]);
    }
    final long maxSplitSize = (minNumSplits < 1) ? Long.MAX_VALUE : (totalLength / minNumSplits + (totalLength % minNumSplits == 0 ? 0 : 1));
    // now that we have the files, generate the splits
    int splitNum = 0;
    for (final FileStatus file : files) {
        final long len = file.getLen();
        final long blockSize = file.getBlockSize();
        final long minSplitSize;
        if (this.minSplitSize <= blockSize) {
            minSplitSize = this.minSplitSize;
        } else {
            if (LOG.isWarnEnabled()) {
                LOG.warn(""Minimal split size of "" + this.minSplitSize + "" is larger than the block size of "" + blockSize + "". Decreasing minimal split size to block size."");
            }
            minSplitSize = blockSize;
        }
        final long splitSize = Math.max(minSplitSize, Math.min(maxSplitSize, blockSize));
        final long halfSplit = splitSize >>> 1;
        final long maxBytesForLastSplit = (long) (splitSize * MAX_SPLIT_SIZE_DISCREPANCY);
        if (len > 0) {
            // get the block locations and make sure they are in order with respect to their offset
            final BlockLocation[] blocks = fs.getFileBlockLocations(file, 0, len);
            Arrays.sort(blocks);
            long bytesUnassigned = len;
            long position = 0;
            int blockIndex = 0;
            while (bytesUnassigned > maxBytesForLastSplit) {
                // get the block containing the majority of the data
                blockIndex = getBlockIndexForPosition(blocks, position, halfSplit, blockIndex);
                // create a new split
                FileInputSplit fis = new FileInputSplit(splitNum++, file.getPath(), position, splitSize, blocks[blockIndex].getHosts());
                inputSplits.add(fis);
                // adjust the positions
                position += splitSize;
                bytesUnassigned -= splitSize;
            }
            // assign the last split
            if (bytesUnassigned > 0) {
                blockIndex = getBlockIndexForPosition(blocks, position, halfSplit, blockIndex);
                final FileInputSplit fis = new FileInputSplit(splitNum++, file.getPath(), position, bytesUnassigned, blocks[blockIndex].getHosts());
                inputSplits.add(fis);
            }
        } else {
            // special case with a file of zero bytes size
            final BlockLocation[] blocks = fs.getFileBlockLocations(file, 0, 0);
            String[] hosts;
            if (blocks.length > 0) {
                hosts = blocks[0].getHosts();
            } else {
                hosts = new String[0];
            }
            final FileInputSplit fis = new FileInputSplit(splitNum++, file.getPath(), 0, 0, hosts);
            inputSplits.add(fis);
        }
    }
    return inputSplits.toArray(new FileInputSplit[inputSplits.size()]);
}","/**
 *  Computes the input splits for the file. By default, one file block is one split. If more splits
 *  are requested than blocks are available, then a split may be a fraction of a block and splits may cross
 *  block boundaries.
 *
 *  @param minNumSplits The minimum desired number of file splits.
 *  @return The computed file splits.
 *
 *  @see org.apache.flink.api.common.io.InputFormat#createInputSplits(int)
 */
","@Override
public FileInputSplit[] createInputSplits(int minNumSplits) throws IOException {
    if (minNumSplits < 1) {
        throw new IllegalArgumentException(""Number of input splits has to be at least 1."");
    }
        minNumSplits = Math.max(minNumSplits, this.numSplits);
    final Path path = this.filePath;
    final List<FileInputSplit> inputSplits = new ArrayList<FileInputSplit>(minNumSplits);
        List<FileStatus> files = new ArrayList<FileStatus>();
    long totalLength = 0;
    final FileSystem fs = path.getFileSystem();
    final FileStatus pathFile = fs.getFileStatus(path);
    if (pathFile.isDir()) {
        totalLength += addFilesInDir(path, files, totalLength, true);
    } else {
        testForUnsplittable(pathFile);
        files.add(pathFile);
        totalLength += pathFile.getLen();
    }
        if (unsplittable) {
        int splitNum = 0;
        for (final FileStatus file : files) {
            final BlockLocation[] blocks = fs.getFileBlockLocations(file, 0, file.getLen());
            Set<String> hosts = new HashSet<String>();
            for (BlockLocation block : blocks) {
                hosts.addAll(Arrays.asList(block.getHosts()));
            }
            long len = file.getLen();
            if (testForUnsplittable(file)) {
                len = READ_WHOLE_SPLIT_FLAG;
            }
            FileInputSplit fis = new FileInputSplit(splitNum++, file.getPath(), 0, len, hosts.toArray(new String[hosts.size()]));
            inputSplits.add(fis);
        }
        return inputSplits.toArray(new FileInputSplit[inputSplits.size()]);
    }
    final long maxSplitSize = (minNumSplits < 1) ? Long.MAX_VALUE : (totalLength / minNumSplits + (totalLength % minNumSplits == 0 ? 0 : 1));
        int splitNum = 0;
    for (final FileStatus file : files) {
        final long len = file.getLen();
        final long blockSize = file.getBlockSize();
        final long minSplitSize;
        if (this.minSplitSize <= blockSize) {
            minSplitSize = this.minSplitSize;
        } else {
            if (LOG.isWarnEnabled()) {
                LOG.warn(""Minimal split size of "" + this.minSplitSize + "" is larger than the block size of "" + blockSize + "". Decreasing minimal split size to block size."");
            }
            minSplitSize = blockSize;
        }
        final long splitSize = Math.max(minSplitSize, Math.min(maxSplitSize, blockSize));
        final long halfSplit = splitSize >>> 1;
        final long maxBytesForLastSplit = (long) (splitSize * MAX_SPLIT_SIZE_DISCREPANCY);
        if (len > 0) {
                        final BlockLocation[] blocks = fs.getFileBlockLocations(file, 0, len);
            Arrays.sort(blocks);
            long bytesUnassigned = len;
            long position = 0;
            int blockIndex = 0;
            while (bytesUnassigned > maxBytesForLastSplit) {
                                blockIndex = getBlockIndexForPosition(blocks, position, halfSplit, blockIndex);
                                FileInputSplit fis = new FileInputSplit(splitNum++, file.getPath(), position, splitSize, blocks[blockIndex].getHosts());
                inputSplits.add(fis);
                                position += splitSize;
                bytesUnassigned -= splitSize;
            }
                        if (bytesUnassigned > 0) {
                blockIndex = getBlockIndexForPosition(blocks, position, halfSplit, blockIndex);
                final FileInputSplit fis = new FileInputSplit(splitNum++, file.getPath(), position, bytesUnassigned, blocks[blockIndex].getHosts());
                inputSplits.add(fis);
            }
        } else {
                        final BlockLocation[] blocks = fs.getFileBlockLocations(file, 0, 0);
            String[] hosts;
            if (blocks.length > 0) {
                hosts = blocks[0].getHosts();
            } else {
                hosts = new String[0];
            }
            final FileInputSplit fis = new FileInputSplit(splitNum++, file.getPath(), 0, 0, hosts);
            inputSplits.add(fis);
        }
    }
    return inputSplits.toArray(new FileInputSplit[inputSplits.size()]);
}",3.227272727272727,0.6602870813397129,2.6,0.5,1.6666666666666667,3.763888888888889,-1.2824524312896401,3.0833333333333335,-0.02631578947368421,19.950164531503024
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-914_f8a42197,3,"/**
 * Format the stack trace including packaging information.
 *
 * @param ignorePackages
 *        List of packages to be ignored in the trace.
 * @return The formatted stack trace including packaging information.
 */
public String getExtendedStackTraceAsString(final List<String> ignorePackages) {
    final StringBuilder sb = new StringBuilder(this.name);
    final String msg = this.message;
    if (msg != null) {
        sb.append("": "").append(msg);
    }
    sb.append(EOL);
    this.formatElements(sb, 0, this.throwable.getStackTrace(), this.extendedStackTrace, ignorePackages);
    this.formatCause(sb, this.causeProxy, ignorePackages);
    return sb.toString();
}","/**
 * Format the stack trace including packaging information.
 *
 * @param ignorePackages
 *        List of packages to be ignored in the trace.
 * @return The formatted stack trace including packaging information.
 */
","public String getExtendedStackTraceAsString(final List<String> ignorePackages) {
    final StringBuilder sb = new StringBuilder(this.name);
    final String msg = this.message;
    if (msg != null) {
        sb.append("": "").append(msg);
    }
    sb.append(EOL);
    this.formatElements(sb, 0, this.throwable.getStackTrace(), this.extendedStackTrace, ignorePackages);
    this.formatCause(sb, this.causeProxy, ignorePackages);
    return sb.toString();
}",-0.13636363636363635,-0.444976076555024,-0.4,-0.5,-0.25,-0.039682539682539715,0.10951374207188172,0.08333333333333333,0.0,-0.027894861199956194
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-276_1bf5c550,1,"public Id readHead() {
    return head;
}",,"public Id readHead() {
    return head;
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,1.1646229739252991,-0.5,2.4736842105263155,-0.16279340490885932
Compress,35,1,"/**
 * Wikipedia <a href=""http://en.wikipedia.org/wiki/Tar_(file_format)#File_header"">says</a>:
 * <blockquote>
 * The checksum is calculated by taking the sum of the unsigned byte values
 * of the header block with the eight checksum bytes taken to be ascii
 * spaces (decimal value 32). It is stored as a six digit octal number with
 * leading zeroes followed by a NUL and then a space. Various
 * implementations do not adhere to this format. For better compatibility,
 * ignore leading and trailing whitespace, and get the first six digits. In
 * addition, some historic tar implementations treated bytes as signed.
 * Implementations typically calculate the checksum both ways, and treat it
 * as good if either the signed or unsigned sum matches the included
 * checksum.
 * </blockquote>
 * <p>
 * The return value of this method should be treated as a best-effort
 * heuristic rather than an absolute and final truth. The checksum
 * verification logic may well evolve over time as more special cases
 * are encountered.
 *
 * @param header tar header
 * @return whether the checksum is reasonably good
 * @see <a href=""https://issues.apache.org/jira/browse/COMPRESS-191"">COMPRESS-191</a>
 * @since 1.5
 */
public static boolean verifyCheckSum(byte[] header) {
    long storedSum = 0;
    long unsignedSum = 0;
    long signedSum = 0;
    int digits = 0;
    for (int i = 0; i < header.length; i++) {
        byte b = header[i];
        if (CHKSUM_OFFSET <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {
            if ('0' <= b && b <= '7' && digits++ < 6) {
                storedSum = storedSum * 8 + b - '0';
            } else if (digits > 0) {
                digits = 6;
            }
            b = ' ';
        }
        unsignedSum += 0xff & b;
        signedSum += b;
    }
    return storedSum == unsignedSum || storedSum == signedSum;
}","/**
 * Wikipedia <a href=""http://en.wikipedia.org/wiki/Tar_(file_format)#File_header"">says</a>:
 * <blockquote>
 * The checksum is calculated by taking the sum of the unsigned byte values
 * of the header block with the eight checksum bytes taken to be ascii
 * spaces (decimal value 32). It is stored as a six digit octal number with
 * leading zeroes followed by a NUL and then a space. Various
 * implementations do not adhere to this format. For better compatibility,
 * ignore leading and trailing whitespace, and get the first six digits. In
 * addition, some historic tar implementations treated bytes as signed.
 * Implementations typically calculate the checksum both ways, and treat it
 * as good if either the signed or unsigned sum matches the included
 * checksum.
 * </blockquote>
 * <p>
 * The return value of this method should be treated as a best-effort
 * heuristic rather than an absolute and final truth. The checksum
 * verification logic may well evolve over time as more special cases
 * are encountered.
 *
 * @param header tar header
 * @return whether the checksum is reasonably good
 * @see <a href=""https://issues.apache.org/jira/browse/COMPRESS-191"">COMPRESS-191</a>
 * @since 1.5
 */
","public static boolean verifyCheckSum(byte[] header) {
    long storedSum = 0;
    long unsignedSum = 0;
    long signedSum = 0;
    int digits = 0;
    for (int i = 0; i < header.length; i++) {
        byte b = header[i];
        if (CHKSUM_OFFSET <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {
            if ('0' <= b && b <= '7' && digits++ < 6) {
                storedSum = storedSum * 8 + b - '0';
            } else if (digits > 0) {
                digits = 6;
            }
            b = ' ';
        }
        unsignedSum += 0xff & b;
        signedSum += b;
    }
    return storedSum == unsignedSum || storedSum == signedSum;
}",0.2727272727272727,0.7751196172248805,0.2,1.0,0.5,3.007936507936508,-0.3034531360112755,-0.5,-0.02631578947368421,3.0211764434685886
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-334_9d8cc45d,1,"@Override
public SortedKeyValueIterator<Key, Value> deepCopy(IteratorEnvironment env) {
    return new TimestampFilter(getSource(), hasStart, start, startInclusive, hasEnd, end, endInclusive);
}",,"@Override
public SortedKeyValueIterator<Key, Value> deepCopy(IteratorEnvironment env) {
    return new TimestampFilter(getSource(), hasStart, start, startInclusive, hasEnd, end, endInclusive);
}",-0.45454545454545453,-0.6028708133971293,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.7285412262156447,-0.4166666666666667,-0.02631578947368421,-0.16279340490885932
camel,remotes/origin/bugs-dot-jar_CAMEL-3395_8433e6db,3,"public Iterator iterator() {
    return new Iterator() {

        private int index;

        private boolean closed;

        public boolean hasNext() {
            if (closed) {
                return false;
            }
            boolean answer = iterator.hasNext();
            if (!answer) {
                // we are now closed
                closed = true;
                // nothing more so we need to close the expression value in case it needs to be
                if (value instanceof Closeable) {
                    IOHelper.close((Closeable) value, value.getClass().getName(), LOG);
                } else if (value instanceof Scanner) {
                    // special for Scanner as it does not implement Closeable
                    ((Scanner) value).close();
                }
            }
            return answer;
        }

        public Object next() {
            Object part = iterator.next();
            Exchange newExchange = exchange.copy();
            if (part instanceof Message) {
                newExchange.setIn((Message) part);
            } else {
                Message in = newExchange.getIn();
                in.setBody(part);
            }
            return createProcessorExchangePair(index++, getProcessors().iterator().next(), newExchange);
        }

        public void remove() {
            throw new UnsupportedOperationException(""Remove is not supported by this iterator"");
        }
    };
}",,"public Iterator iterator() {
    return new Iterator() {

        private int index;

        private boolean closed;

        public boolean hasNext() {
            if (closed) {
                return false;
            }
            boolean answer = iterator.hasNext();
            if (!answer) {
                                closed = true;
                                if (value instanceof Closeable) {
                    IOHelper.close((Closeable) value, value.getClass().getName(), LOG);
                } else if (value instanceof Scanner) {
                                        ((Scanner) value).close();
                }
            }
            return answer;
        }

        public Object next() {
            Object part = iterator.next();
            Exchange newExchange = exchange.copy();
            if (part instanceof Message) {
                newExchange.setIn((Message) part);
            } else {
                Message in = newExchange.getIn();
                in.setBody(part);
            }
            return createProcessorExchangePair(index++, getProcessors().iterator().next(), newExchange);
        }

        public void remove() {
            throw new UnsupportedOperationException(""Remove is not supported by this iterator"");
        }
    };
}",0.9545454545454546,0.8325358851674642,0.6,1.0,0.3333333333333333,0.0019841269841269858,-0.5560253699788581,0.6666666666666666,-0.02631578947368421,0.1487272580580096
flink,remotes/origin/bugs-dot-jar_FLINK-2713_63d9800e,1,"@Override
public StateHandle<Serializable> snapshotState(long checkpointId, long checkpointTimestamp) throws Exception {
    return stateStore.snapshotStates(checkpointId, checkpointTimestamp);
}",,"@Override
public StateHandle<Serializable> snapshotState(long checkpointId, long checkpointTimestamp) throws Exception {
    return stateStore.snapshotStates(checkpointId, checkpointTimestamp);
}",-0.45454545454545453,-0.6028708133971293,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.7978858350951374,-0.4166666666666667,0.1842105263157895,-0.16279340490885932
commons-math,remotes/origin/bugs-dot-jar_MATH-294_2c8a114f,1,"/**
 * {@inheritDoc}
 * <p>
 * <strong>Algorithm Description</strong>: For small means, uses simulation
 * of a Poisson process using Uniform deviates, as described <a
 * href=""http://irmi.epfl.ch/cmos/Pmmi/interactive/rng7.htm""> here.</a>
 * </p>
 * <p>
 * The Poisson process (and hence value returned) is bounded by 1000 * mean.
 * </p>
 *
 * <p>
 * For large means, uses a reject method as described in <a
 * href=""http://cg.scs.carleton.ca/~luc/rnbookindex.html"">Non-Uniform Random
 * Variate Generation</a>
 * </p>
 *
 * <p>
 * References:
 * <ul>
 * <li>Devroye, Luc. (1986). <i>Non-Uniform Random Variate Generation</i>.
 * New York, NY. Springer-Verlag</li>
 * </ul>
 * </p>
 *
 * @param mean
 *            mean of the Poisson distribution.
 * @return the random Poisson value.
 */
public long nextPoisson(double mean) {
    if (mean <= 0) {
        throw MathRuntimeException.createIllegalArgumentException(""the Poisson mean must be positive ({0})"", mean);
    }
    final RandomGenerator generator = getRan();
    double pivot = 6.0;
    if (mean < pivot) {
        double p = Math.exp(-mean);
        long n = 0;
        double r = 1.0d;
        double rnd = 1.0d;
        while (n < 1000 * mean) {
            rnd = generator.nextDouble();
            r = r * rnd;
            if (r >= p) {
                n++;
            } else {
                return n;
            }
        }
        return n;
    } else {
        double mu = Math.floor(mean);
        // integer
        double delta = Math.floor(pivot + (mu - pivot) / 2.0);
        // between 6
        // and mean
        double mu2delta = 2.0 * mu + delta;
        double muDeltaHalf = mu + delta / 2.0;
        double logMeanMu = Math.log(mean / mu);
        double muFactorialLog = MathUtils.factorialLog((int) mu);
        double c1 = Math.sqrt(Math.PI * mu / 2.0);
        double c2 = c1 + Math.sqrt(Math.PI * muDeltaHalf / (2.0 * Math.exp(1.0 / mu2delta)));
        double c3 = c2 + 2.0;
        double c4 = c3 + Math.exp(1.0 / 78.0);
        double c = c4 + 2.0 / delta * mu2delta * Math.exp(-delta / mu2delta * (1.0 + delta / 2.0));
        double y = 0.0;
        double x = 0.0;
        double w = Double.POSITIVE_INFINITY;
        boolean accept = false;
        while (!accept) {
            double u = nextUniform(0.0, c);
            double e = nextExponential(mean);
            if (u <= c1) {
                double z = nextGaussian(0.0, 1.0);
                y = -Math.abs(z) * Math.sqrt(mu) - 1.0;
                x = Math.floor(y);
                w = -z * z / 2.0 - e - x * logMeanMu;
                if (x < -mu) {
                    w = Double.POSITIVE_INFINITY;
                }
            } else if (c1 < u && u <= c2) {
                double z = nextGaussian(0.0, 1.0);
                y = 1.0 + Math.abs(z) * Math.sqrt(muDeltaHalf);
                x = Math.ceil(y);
                w = (-y * y + 2.0 * y) / mu2delta - e - x * logMeanMu;
                if (x > delta) {
                    w = Double.POSITIVE_INFINITY;
                }
            } else if (c2 < u && u <= c3) {
                x = 0.0;
                w = -e;
            } else if (c3 < u && u <= c4) {
                x = 1.0;
                w = -e - logMeanMu;
            } else if (c4 < u) {
                double v = nextExponential(mean);
                y = delta + v * 2.0 / delta * mu2delta;
                x = Math.ceil(y);
                w = -delta / mu2delta * (1.0 + y / 2.0) - e - x * logMeanMu;
            }
            accept = w <= x * Math.log(mu) - MathUtils.factorialLog((int) (mu + x)) / muFactorialLog;
        }
        // numbers.
        return (long) (x + mu);
    }
}","/**
 * {@inheritDoc}
 * <p>
 * <strong>Algorithm Description</strong>: For small means, uses simulation
 * of a Poisson process using Uniform deviates, as described <a
 * href=""http://irmi.epfl.ch/cmos/Pmmi/interactive/rng7.htm""> here.</a>
 * </p>
 * <p>
 * The Poisson process (and hence value returned) is bounded by 1000 * mean.
 * </p>
 *
 * <p>
 * For large means, uses a reject method as described in <a
 * href=""http://cg.scs.carleton.ca/~luc/rnbookindex.html"">Non-Uniform Random
 * Variate Generation</a>
 * </p>
 *
 * <p>
 * References:
 * <ul>
 * <li>Devroye, Luc. (1986). <i>Non-Uniform Random Variate Generation</i>.
 * New York, NY. Springer-Verlag</li>
 * </ul>
 * </p>
 *
 * @param mean
 *            mean of the Poisson distribution.
 * @return the random Poisson value.
 */
","public long nextPoisson(double mean) {
    if (mean <= 0) {
        throw MathRuntimeException.createIllegalArgumentException(""the Poisson mean must be positive ({0})"", mean);
    }
    final RandomGenerator generator = getRan();
    double pivot = 6.0;
    if (mean < pivot) {
        double p = Math.exp(-mean);
        long n = 0;
        double r = 1.0d;
        double rnd = 1.0d;
        while (n < 1000 * mean) {
            rnd = generator.nextDouble();
            r = r * rnd;
            if (r >= p) {
                n++;
            } else {
                return n;
            }
        }
        return n;
    } else {
        double mu = Math.floor(mean);
                double delta = Math.floor(pivot + (mu - pivot) / 2.0);
                        double mu2delta = 2.0 * mu + delta;
        double muDeltaHalf = mu + delta / 2.0;
        double logMeanMu = Math.log(mean / mu);
        double muFactorialLog = MathUtils.factorialLog((int) mu);
        double c1 = Math.sqrt(Math.PI * mu / 2.0);
        double c2 = c1 + Math.sqrt(Math.PI * muDeltaHalf / (2.0 * Math.exp(1.0 / mu2delta)));
        double c3 = c2 + 2.0;
        double c4 = c3 + Math.exp(1.0 / 78.0);
        double c = c4 + 2.0 / delta * mu2delta * Math.exp(-delta / mu2delta * (1.0 + delta / 2.0));
        double y = 0.0;
        double x = 0.0;
        double w = Double.POSITIVE_INFINITY;
        boolean accept = false;
        while (!accept) {
            double u = nextUniform(0.0, c);
            double e = nextExponential(mean);
            if (u <= c1) {
                double z = nextGaussian(0.0, 1.0);
                y = -Math.abs(z) * Math.sqrt(mu) - 1.0;
                x = Math.floor(y);
                w = -z * z / 2.0 - e - x * logMeanMu;
                if (x < -mu) {
                    w = Double.POSITIVE_INFINITY;
                }
            } else if (c1 < u && u <= c2) {
                double z = nextGaussian(0.0, 1.0);
                y = 1.0 + Math.abs(z) * Math.sqrt(muDeltaHalf);
                x = Math.ceil(y);
                w = (-y * y + 2.0 * y) / mu2delta - e - x * logMeanMu;
                if (x > delta) {
                    w = Double.POSITIVE_INFINITY;
                }
            } else if (c2 < u && u <= c3) {
                x = 0.0;
                w = -e;
            } else if (c3 < u && u <= c4) {
                x = 1.0;
                w = -e - logMeanMu;
            } else if (c4 < u) {
                double v = nextExponential(mean);
                y = delta + v * 2.0 / delta * mu2delta;
                x = Math.ceil(y);
                w = -delta / mu2delta * (1.0 + y / 2.0) - e - x * logMeanMu;
            }
            accept = w <= x * Math.log(mu) - MathUtils.factorialLog((int) (mu + x)) / muFactorialLog;
        }
                return (long) (x + mu);
    }
}",2.6818181818181817,0.7703349282296649,2.0,2.5,2.0,4.6230158730158735,-1.2077519379844959,1.75,-0.02631578947368421,26.617389049290292
wicket,remotes/origin/bugs-dot-jar_WICKET-428_4a6a573b,3,"/**
 *  @see java.util.Map#values()
 */
public Collection values() {
    return new AbstractList() {

        public Object get(final int index) {
            int keyIndex = nextKey(0);
            for (int i = 0; i < index; i++) {
                keyIndex = nextKey(keyIndex + 1);
            }
            return values[keyIndex];
        }

        public int size() {
            return size;
        }
    };
}","/**
 *  @see java.util.Map#values()
 */
","public Collection values() {
    return new AbstractList() {

        public Object get(final int index) {
            int keyIndex = nextKey(0);
            for (int i = 0; i < index; i++) {
                keyIndex = nextKey(keyIndex + 1);
            }
            return values[keyIndex];
        }

        public int size() {
            return size;
        }
    };
}",0.0,0.7942583732057418,-0.4,0.0,-0.16666666666666666,0.33730158730158727,0.059619450317124574,-0.3333333333333333,2.236842105263158,0.030582689326486966
commons-math,remotes/origin/bugs-dot-jar_MATH-1297_56434517,1,"/**
 * Start the integration.
 * <p>This method computes one step using the underlying starter integrator,
 * and initializes the Nordsieck vector at step start. The starter integrator
 * purpose is only to establish initial conditions, it does not really change
 * time by itself. The top level multistep integrator remains in charge of
 * handling time propagation and events handling as it will starts its own
 * computation right from the beginning. In a sense, the starter integrator
 * can be seen as a dummy one and so it will never trigger any user event nor
 * call any user step handler.</p>
 * @param t0 initial time
 * @param y0 initial value of the state vector at t0
 * @param t target time for the integration
 * (can be set to a value smaller than <code>t0</code> for backward integration)
 * @exception DimensionMismatchException if arrays dimension do not match equations settings
 * @exception NumberIsTooSmallException if integration step is too small
 * @exception MaxCountExceededException if the number of functions evaluations is exceeded
 * @exception NoBracketingException if the location of an event cannot be bracketed
 */
protected void start(final double t0, final double[] y0, final double t) throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException {
    // make sure NO user event nor user step handler is triggered,
    // this is the task of the top level integrator, not the task
    // of the starter integrator
    starter.clearEventHandlers();
    starter.clearStepHandlers();
    // set up one specific step handler to extract initial Nordsieck vector
    starter.addStepHandler(new NordsieckInitializer((nSteps + 3) / 2, y0.length));
    // start integration, expecting a InitializationCompletedMarkerException
    try {
        if (starter instanceof AbstractIntegrator) {
            ((AbstractIntegrator) starter).integrate(getExpandable(), t);
        } else {
            starter.integrate(new FirstOrderDifferentialEquations() {

                /**
                 * {@inheritDoc}
                 */
                @Override
                public int getDimension() {
                    return getExpandable().getTotalDimension();
                }

                /**
                 * {@inheritDoc}
                 */
                @Override
                public void computeDerivatives(double t, double[] y, double[] yDot) {
                    getExpandable().computeDerivatives(t, y, yDot);
                }
            }, t0, y0, t, new double[y0.length]);
        }
    } catch (InitializationCompletedMarkerException icme) {
        // NOPMD
        // this is the expected nominal interruption of the start integrator
        // count the evaluations used by the starter
        getCounter().increment(starter.getEvaluations());
    }
    // remove the specific step handler
    starter.clearStepHandlers();
}","/**
 * Start the integration.
 * <p>This method computes one step using the underlying starter integrator,
 * and initializes the Nordsieck vector at step start. The starter integrator
 * purpose is only to establish initial conditions, it does not really change
 * time by itself. The top level multistep integrator remains in charge of
 * handling time propagation and events handling as it will starts its own
 * computation right from the beginning. In a sense, the starter integrator
 * can be seen as a dummy one and so it will never trigger any user event nor
 * call any user step handler.</p>
 * @param t0 initial time
 * @param y0 initial value of the state vector at t0
 * @param t target time for the integration
 * (can be set to a value smaller than <code>t0</code> for backward integration)
 * @exception DimensionMismatchException if arrays dimension do not match equations settings
 * @exception NumberIsTooSmallException if integration step is too small
 * @exception MaxCountExceededException if the number of functions evaluations is exceeded
 * @exception NoBracketingException if the location of an event cannot be bracketed
 */
/**
 * {@inheritDoc}
 */
/**
 * {@inheritDoc}
 */
","protected void start(final double t0, final double[] y0, final double t) throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException {
                starter.clearEventHandlers();
    starter.clearStepHandlers();
        starter.addStepHandler(new NordsieckInitializer((nSteps + 3) / 2, y0.length));
        try {
        if (starter instanceof AbstractIntegrator) {
            ((AbstractIntegrator) starter).integrate(getExpandable(), t);
        } else {
            starter.integrate(new FirstOrderDifferentialEquations() {

                /**
                 * {@inheritDoc}
                 */
                @Override
                public int getDimension() {
                    return getExpandable().getTotalDimension();
                }

                /**
                 * {@inheritDoc}
                 */
                @Override
                public void computeDerivatives(double t, double[] y, double[] yDot) {
                    getExpandable().computeDerivatives(t, y, yDot);
                }
            }, t0, y0, t, new double[y0.length]);
        }
    } catch (InitializationCompletedMarkerException icme) {
                                getCounter().increment(starter.getEvaluations());
    }
        starter.clearStepHandlers();
}",0.7272727272727273,1.5071770334928227,-0.2,0.5,-0.25,-0.015873015873015886,-0.43481324876673694,0.6666666666666666,-0.02631578947368421,0.08658448735902441
Closure,167,2,"private FlowScope caseNameOrGetProp(Node name, FlowScope blindScope, boolean outcome) {
    JSType type = getTypeIfRefinable(name, blindScope);
    if (type != null) {
        JSType restrictedType = type.getRestrictedTypeGivenToBooleanOutcome(outcome);
        FlowScope informed = blindScope.createChildFlowScope();
        declareNameInScope(informed, name, restrictedType);
        return informed;
    }
    return blindScope;
}",,"private FlowScope caseNameOrGetProp(Node name, FlowScope blindScope, boolean outcome) {
    JSType type = getTypeIfRefinable(name, blindScope);
    if (type != null) {
        JSType restrictedType = type.getRestrictedTypeGivenToBooleanOutcome(outcome);
        FlowScope informed = blindScope.createChildFlowScope();
        declareNameInScope(informed, name, restrictedType);
        return informed;
    }
    return blindScope;
}",-0.18181818181818182,0.0,-0.4,-0.5,-0.25,0.0079365079365079,0.18703312191684296,-0.16666666666666666,0.0,-0.04023674095076734
Closure,78,2,"/**
 * Try to fold arithmetic binary operators
 */
private Node performArithmeticOp(int opType, Node left, Node right) {
    // to Number.
    if (opType == Token.ADD && (NodeUtil.mayBeString(left, false) || NodeUtil.mayBeString(right, false))) {
        return null;
    }
    double result;
    // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN
    // to zero so this is a little akward here.
    Double lValObj = NodeUtil.getNumberValue(left);
    if (lValObj == null) {
        return null;
    }
    Double rValObj = NodeUtil.getNumberValue(right);
    if (rValObj == null) {
        return null;
    }
    double lval = lValObj;
    double rval = rValObj;
    switch(opType) {
        case Token.BITAND:
            result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);
            break;
        case Token.BITOR:
            result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);
            break;
        case Token.BITXOR:
            result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);
            break;
        case Token.ADD:
            result = lval + rval;
            break;
        case Token.SUB:
            result = lval - rval;
            break;
        case Token.MUL:
            result = lval * rval;
            break;
        case Token.MOD:
            if (rval == 0) {
                error(DiagnosticType.error(""JSC_DIVIDE_BY_0_ERROR"", ""Divide by 0""), right);
                return null;
            }
            result = lval % rval;
            break;
        case Token.DIV:
            if (rval == 0) {
                error(DiagnosticType.error(""JSC_DIVIDE_BY_0_ERROR"", ""Divide by 0""), right);
                return null;
            }
            result = lval / rval;
            break;
        default:
            throw new Error(""Unexpected arithmetic operator"");
    }
    // length of the left and right value plus 1 byte for the operator.
    if (String.valueOf(result).length() <= String.valueOf(lval).length() + String.valueOf(rval).length() + 1 && // point, fixed-point math starts to break down and become inaccurate.
    Math.abs(result) <= MAX_FOLD_NUMBER) {
        Node newNumber = Node.newNumber(result);
        return newNumber;
    } else if (Double.isNaN(result)) {
        return Node.newString(Token.NAME, ""NaN"");
    } else if (result == Double.POSITIVE_INFINITY) {
        return Node.newString(Token.NAME, ""Infinity"");
    } else if (result == Double.NEGATIVE_INFINITY) {
        return new Node(Token.NEG, Node.newString(Token.NAME, ""Infinity""));
    }
    return null;
}","/**
 * Try to fold arithmetic binary operators
 */
","private Node performArithmeticOp(int opType, Node left, Node right) {
        if (opType == Token.ADD && (NodeUtil.mayBeString(left, false) || NodeUtil.mayBeString(right, false))) {
        return null;
    }
    double result;
            Double lValObj = NodeUtil.getNumberValue(left);
    if (lValObj == null) {
        return null;
    }
    Double rValObj = NodeUtil.getNumberValue(right);
    if (rValObj == null) {
        return null;
    }
    double lval = lValObj;
    double rval = rValObj;
    switch(opType) {
        case Token.BITAND:
            result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);
            break;
        case Token.BITOR:
            result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);
            break;
        case Token.BITXOR:
            result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);
            break;
        case Token.ADD:
            result = lval + rval;
            break;
        case Token.SUB:
            result = lval - rval;
            break;
        case Token.MUL:
            result = lval * rval;
            break;
        case Token.MOD:
            if (rval == 0) {
                error(DiagnosticType.error(""JSC_DIVIDE_BY_0_ERROR"", ""Divide by 0""), right);
                return null;
            }
            result = lval % rval;
            break;
        case Token.DIV:
            if (rval == 0) {
                error(DiagnosticType.error(""JSC_DIVIDE_BY_0_ERROR"", ""Divide by 0""), right);
                return null;
            }
            result = lval / rval;
            break;
        default:
            throw new Error(""Unexpected arithmetic operator"");
    }
        if (String.valueOf(result).length() <= String.valueOf(lval).length() + String.valueOf(rval).length() + 1 &&     Math.abs(result) <= MAX_FOLD_NUMBER) {
        Node newNumber = Node.newNumber(result);
        return newNumber;
    } else if (Double.isNaN(result)) {
        return Node.newString(Token.NAME, ""NaN"");
    } else if (result == Double.POSITIVE_INFINITY) {
        return Node.newString(Token.NAME, ""Infinity"");
    } else if (result == Double.NEGATIVE_INFINITY) {
        return new Node(Token.NEG, Node.newString(Token.NAME, ""Infinity""));
    }
    return null;
}",2.272727272727273,0.4928229665071768,4.8,1.0,2.4166666666666665,3.486111111111111,-1.1417899929527833,1.6666666666666667,-0.02631578947368421,10.522890913596468
wicket,remotes/origin/bugs-dot-jar_WICKET-5259_a9e56e1e,1,"/**
 *  Parses the given URL string.
 *
 *  @param _url
 *             absolute or relative url with query string
 *  @param charset
 *  @return Url object
 */
public static Url parse(CharSequence _url, Charset charset) {
    Args.notNull(_url, ""_url"");
    final Url result = new Url(charset);
    // the url object resolved the charset, use that
    charset = result.getCharset();
    String url = _url.toString();
    // extract query string part
    final String queryString;
    final String absoluteUrl;
    final int queryAt = url.indexOf('?');
    if (queryAt == -1) {
        queryString = """";
        absoluteUrl = url;
    } else {
        absoluteUrl = url.substring(0, queryAt);
        queryString = url.substring(queryAt + 1);
    }
    // get absolute / relative part of url
    String relativeUrl;
    final int idxOfFirstSlash = absoluteUrl.indexOf('/');
    final int protocolAt = absoluteUrl.indexOf(""://"");
    // full urls start either with a ""scheme://"" or with ""//""
    boolean protocolLess = absoluteUrl.startsWith(""//"");
    final boolean isFull = (protocolAt > 1 && (protocolAt < idxOfFirstSlash)) || protocolLess;
    if (isFull) {
        if (protocolLess == false) {
            result.protocol = absoluteUrl.substring(0, protocolAt).toLowerCase(Locale.US);
        }
        final String afterProto = absoluteUrl.substring(protocolAt + 3);
        final String hostAndPort;
        int relativeAt = afterProto.indexOf('/');
        if (relativeAt == -1) {
            relativeAt = afterProto.indexOf(';');
        }
        if (relativeAt == -1) {
            relativeUrl = """";
            hostAndPort = afterProto;
        } else {
            relativeUrl = afterProto.substring(relativeAt);
            hostAndPort = afterProto.substring(0, relativeAt);
        }
        final int portAt = hostAndPort.lastIndexOf(':');
        if (portAt == -1) {
            result.host = hostAndPort;
            result.port = getDefaultPortForProtocol(result.protocol);
        } else {
            result.host = hostAndPort.substring(0, portAt);
            result.port = Integer.parseInt(hostAndPort.substring(portAt + 1));
        }
        if (relativeAt < 0) {
            relativeUrl = ""/"";
        }
    } else {
        relativeUrl = absoluteUrl;
    }
    if (relativeUrl.length() > 0) {
        boolean removeLast = false;
        if (relativeUrl.endsWith(""/"")) {
            // we need to append something and remove it after splitting
            // because otherwise the
            // trailing slashes will be lost
            relativeUrl += ""/x"";
            removeLast = true;
        }
        String[] segmentArray = Strings.split(relativeUrl, '/');
        if (removeLast) {
            segmentArray[segmentArray.length - 1] = null;
        }
        for (String s : segmentArray) {
            if (s != null) {
                result.segments.add(decodeSegment(s, charset));
            }
        }
    }
    if (queryString.length() > 0) {
        String[] queryArray = Strings.split(queryString, '&');
        for (String s : queryArray) {
            if (Strings.isEmpty(s) == false) {
                result.parameters.add(parseQueryParameter(s, charset));
            }
        }
    }
    return result;
}","/**
 *  Parses the given URL string.
 *
 *  @param _url
 *             absolute or relative url with query string
 *  @param charset
 *  @return Url object
 */
","public static Url parse(CharSequence _url, Charset charset) {
    Args.notNull(_url, ""_url"");
    final Url result = new Url(charset);
        charset = result.getCharset();
    String url = _url.toString();
        final String queryString;
    final String absoluteUrl;
    final int queryAt = url.indexOf('?');
    if (queryAt == -1) {
        queryString = """";
        absoluteUrl = url;
    } else {
        absoluteUrl = url.substring(0, queryAt);
        queryString = url.substring(queryAt + 1);
    }
        String relativeUrl;
    final int idxOfFirstSlash = absoluteUrl.indexOf('/');
    final int protocolAt = absoluteUrl.indexOf(""://"");
        boolean protocolLess = absoluteUrl.startsWith(""//"");
    final boolean isFull = (protocolAt > 1 && (protocolAt < idxOfFirstSlash)) || protocolLess;
    if (isFull) {
        if (protocolLess == false) {
            result.protocol = absoluteUrl.substring(0, protocolAt).toLowerCase(Locale.US);
        }
        final String afterProto = absoluteUrl.substring(protocolAt + 3);
        final String hostAndPort;
        int relativeAt = afterProto.indexOf('/');
        if (relativeAt == -1) {
            relativeAt = afterProto.indexOf(';');
        }
        if (relativeAt == -1) {
            relativeUrl = """";
            hostAndPort = afterProto;
        } else {
            relativeUrl = afterProto.substring(relativeAt);
            hostAndPort = afterProto.substring(0, relativeAt);
        }
        final int portAt = hostAndPort.lastIndexOf(':');
        if (portAt == -1) {
            result.host = hostAndPort;
            result.port = getDefaultPortForProtocol(result.protocol);
        } else {
            result.host = hostAndPort.substring(0, portAt);
            result.port = Integer.parseInt(hostAndPort.substring(portAt + 1));
        }
        if (relativeAt < 0) {
            relativeUrl = ""/"";
        }
    } else {
        relativeUrl = absoluteUrl;
    }
    if (relativeUrl.length() > 0) {
        boolean removeLast = false;
        if (relativeUrl.endsWith(""/"")) {
                                                relativeUrl += ""/x"";
            removeLast = true;
        }
        String[] segmentArray = Strings.split(relativeUrl, '/');
        if (removeLast) {
            segmentArray[segmentArray.length - 1] = null;
        }
        for (String s : segmentArray) {
            if (s != null) {
                result.segments.add(decodeSegment(s, charset));
            }
        }
    }
    if (queryString.length() > 0) {
        String[] queryArray = Strings.split(queryString, '&');
        for (String s : queryArray) {
            if (Strings.isEmpty(s) == false) {
                result.parameters.add(parseQueryParameter(s, charset));
            }
        }
    }
    return result;
}",2.8636363636363638,0.21052631578947367,2.4,0.5,1.5833333333333333,2.5972222222222223,-1.1930937279774485,2.0833333333333335,-0.02631578947368421,10.996658656201193
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-2962_2fd7633f,0,"@Override
public void write(DataOutput out) throws IOException {
    range.write(out);
    out.writeInt(locations.length);
    for (int i = 0; i < locations.length; ++i) out.writeUTF(locations[i]);
    out.writeBoolean(null != isolatedScan);
    if (null != isolatedScan) {
        out.writeBoolean(isolatedScan);
    }
    out.writeBoolean(null != offline);
    if (null != offline) {
        out.writeBoolean(offline);
    }
    out.writeBoolean(null != localIterators);
    if (null != localIterators) {
        out.writeBoolean(localIterators);
    }
    out.writeBoolean(null != mockInstance);
    if (null != mockInstance) {
        out.writeBoolean(mockInstance);
    }
    out.writeBoolean(null != fetchedColumns);
    if (null != fetchedColumns) {
        String[] cols = InputConfigurator.serializeColumns(fetchedColumns);
        out.writeInt(cols.length);
        for (String col : cols) {
            out.writeUTF(col);
        }
    }
    out.writeBoolean(null != auths);
    if (null != auths) {
        out.writeUTF(auths.serialize());
    }
    out.writeBoolean(null != principal);
    if (null != principal) {
        out.writeUTF(principal);
    }
    out.writeBoolean(null != token);
    if (null != token) {
        out.writeUTF(token.getClass().getCanonicalName());
        try {
            out.writeUTF(CredentialHelper.tokenAsBase64(token));
        } catch (AccumuloSecurityException e) {
            throw new IOException(e);
        }
    }
    out.writeBoolean(null != instanceName);
    if (null != instanceName) {
        out.writeUTF(instanceName);
    }
    out.writeBoolean(null != zooKeepers);
    if (null != zooKeepers) {
        out.writeUTF(zooKeepers);
    }
    out.writeBoolean(null != level);
    if (null != level) {
        out.writeInt(level.toInt());
    }
}",,"@Override
public void write(DataOutput out) throws IOException {
    range.write(out);
    out.writeInt(locations.length);
    for (int i = 0; i < locations.length; ++i) out.writeUTF(locations[i]);
    out.writeBoolean(null != isolatedScan);
    if (null != isolatedScan) {
        out.writeBoolean(isolatedScan);
    }
    out.writeBoolean(null != offline);
    if (null != offline) {
        out.writeBoolean(offline);
    }
    out.writeBoolean(null != localIterators);
    if (null != localIterators) {
        out.writeBoolean(localIterators);
    }
    out.writeBoolean(null != mockInstance);
    if (null != mockInstance) {
        out.writeBoolean(mockInstance);
    }
    out.writeBoolean(null != fetchedColumns);
    if (null != fetchedColumns) {
        String[] cols = InputConfigurator.serializeColumns(fetchedColumns);
        out.writeInt(cols.length);
        for (String col : cols) {
            out.writeUTF(col);
        }
    }
    out.writeBoolean(null != auths);
    if (null != auths) {
        out.writeUTF(auths.serialize());
    }
    out.writeBoolean(null != principal);
    if (null != principal) {
        out.writeUTF(principal);
    }
    out.writeBoolean(null != token);
    if (null != token) {
        out.writeUTF(token.getClass().getCanonicalName());
        try {
            out.writeUTF(CredentialHelper.tokenAsBase64(token));
        } catch (AccumuloSecurityException e) {
            throw new IOException(e);
        }
    }
    out.writeBoolean(null != instanceName);
    if (null != instanceName) {
        out.writeUTF(instanceName);
    }
    out.writeBoolean(null != zooKeepers);
    if (null != zooKeepers) {
        out.writeUTF(zooKeepers);
    }
    out.writeBoolean(null != level);
    if (null != level) {
        out.writeInt(level.toInt());
    }
}",2.0454545454545454,-0.17703349282296657,2.4,0.0,1.6666666666666667,1.130952380952381,-0.9915433403805494,2.25,-0.02631578947368421,3.099796568754574
camel,remotes/origin/bugs-dot-jar_CAMEL-7018_3244c1e5,1,"public ModelMBean assemble(MBeanServer mBeanServer, Object obj, ObjectName name) throws JMException {
    ModelMBeanInfo mbi = null;
    // prefer to use the managed instance if it has been annotated with JMX annotations
    if (obj instanceof ManagedInstance) {
        // there may be a custom embedded instance which have additional methods
        Object custom = ((ManagedInstance) obj).getInstance();
        if (custom != null && ObjectHelper.hasAnnotation(custom.getClass().getAnnotations(), ManagedResource.class)) {
            LOG.trace(""Assembling MBeanInfo for: {} from custom @ManagedResource object: {}"", name, custom);
            // get the mbean info from the custom managed object
            mbi = assembler.getMBeanInfo(obj, custom, name.toString());
            // and let the custom object be registered in JMX
            obj = custom;
        }
    }
    if (mbi == null) {
        // use the default provided mbean which has been annotated with JMX annotations
        LOG.trace(""Assembling MBeanInfo for: {} from @ManagedResource object: {}"", name, obj);
        mbi = assembler.getMBeanInfo(obj, null, name.toString());
    }
    if (mbi == null) {
        return null;
    }
    RequiredModelMBean mbean;
    boolean sanitize = camelContext.getManagementStrategy().getManagementAgent().getMask() != null && camelContext.getManagementStrategy().getManagementAgent().getMask();
    if (sanitize) {
        mbean = new MaskRequiredModelMBean(mbi, sanitize);
    } else {
        mbean = (RequiredModelMBean) mBeanServer.instantiate(RequiredModelMBean.class.getName());
        mbean.setModelMBeanInfo(mbi);
    }
    try {
        mbean.setManagedResource(obj, ""ObjectReference"");
    } catch (InvalidTargetObjectTypeException e) {
        throw new JMException(e.getMessage());
    }
    // Allows the managed object to send notifications
    if (obj instanceof NotificationSenderAware) {
        ((NotificationSenderAware) obj).setNotificationSender(new NotificationSenderAdapter(mbean));
    }
    return mbean;
}",,"public ModelMBean assemble(MBeanServer mBeanServer, Object obj, ObjectName name) throws JMException {
    ModelMBeanInfo mbi = null;
        if (obj instanceof ManagedInstance) {
                Object custom = ((ManagedInstance) obj).getInstance();
        if (custom != null && ObjectHelper.hasAnnotation(custom.getClass().getAnnotations(), ManagedResource.class)) {
            LOG.trace(""Assembling MBeanInfo for: {} from custom @ManagedResource object: {}"", name, custom);
                        mbi = assembler.getMBeanInfo(obj, custom, name.toString());
                        obj = custom;
        }
    }
    if (mbi == null) {
                LOG.trace(""Assembling MBeanInfo for: {} from @ManagedResource object: {}"", name, obj);
        mbi = assembler.getMBeanInfo(obj, null, name.toString());
    }
    if (mbi == null) {
        return null;
    }
    RequiredModelMBean mbean;
    boolean sanitize = camelContext.getManagementStrategy().getManagementAgent().getMask() != null && camelContext.getManagementStrategy().getManagementAgent().getMask();
    if (sanitize) {
        mbean = new MaskRequiredModelMBean(mbi, sanitize);
    } else {
        mbean = (RequiredModelMBean) mBeanServer.instantiate(RequiredModelMBean.class.getName());
        mbean.setModelMBeanInfo(mbi);
    }
    try {
        mbean.setManagedResource(obj, ""ObjectReference"");
    } catch (InvalidTargetObjectTypeException e) {
        throw new JMException(e.getMessage());
    }
        if (obj instanceof NotificationSenderAware) {
        ((NotificationSenderAware) obj).setNotificationSender(new NotificationSenderAdapter(mbean));
    }
    return mbean;
}",0.9545454545454546,-0.03349282296650732,1.0,0.0,0.6666666666666666,0.49603174603174605,-0.6555320648343901,1.3333333333333333,-0.02631578947368421,1.1539242636422837
commons-math,remotes/origin/bugs-dot-jar_MATH-867_bfbb156d,1,"/**
 * @param x Normalized objective variables.
 * @return {@code true} if in bounds.
 */
public boolean isFeasible(final double[] x) {
    if (boundaries == null) {
        return true;
    }
    final double[] bLoEnc = encode(boundaries[0]);
    final double[] bHiEnc = encode(boundaries[1]);
    for (int i = 0; i < x.length; i++) {
        if (x[i] < bLoEnc[i]) {
            return false;
        }
        if (x[i] > bHiEnc[i]) {
            return false;
        }
    }
    return true;
}","/**
 * @param x Normalized objective variables.
 * @return {@code true} if in bounds.
 */
","public boolean isFeasible(final double[] x) {
    if (boundaries == null) {
        return true;
    }
    final double[] bLoEnc = encode(boundaries[0]);
    final double[] bHiEnc = encode(boundaries[1]);
    for (int i = 0; i < x.length; i++) {
        if (x[i] < bLoEnc[i]) {
            return false;
        }
        if (x[i] > bHiEnc[i]) {
            return false;
        }
    }
    return true;
}",0.09090909090909091,0.22488038277511951,0.2,0.0,0.16666666666666666,0.5138888888888888,-0.07004933051444676,-0.3333333333333333,1.6052631578947367,0.1754580084484477
camel,remotes/origin/bugs-dot-jar_CAMEL-6667_1fc7bd7a,1,"/**
 * Prepares the exchange for the next iteration
 *
 * @param exchange the exchange
 * @param index the index of the next iteration
 * @return the exchange to use
 */
protected Exchange prepareExchange(Exchange exchange, int index) {
    if (copy) {
        // use a copy but let it reuse the same exchange id so it appear as one exchange
        return ExchangeHelper.createCopy(exchange, true);
    } else {
        ExchangeHelper.prepareOutToIn(exchange);
        return exchange;
    }
}","/**
 * Prepares the exchange for the next iteration
 *
 * @param exchange the exchange
 * @param index the index of the next iteration
 * @return the exchange to use
 */
","protected Exchange prepareExchange(Exchange exchange, int index) {
    if (copy) {
                return ExchangeHelper.createCopy(exchange, true);
    } else {
        ExchangeHelper.prepareOutToIn(exchange);
        return exchange;
    }
}",-0.2727272727272727,0.06220095693779899,-0.4,-0.5,-0.25,-0.3650793650793651,0.44214235377026073,-0.3333333333333333,0.1842105263157895,-0.16279340490885932
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-612_df9e6913,1,"@Override
@Nonnull
public Node addNode(final String relPath, final String primaryNodeTypeName) throws RepositoryException {
    checkStatus();
    checkProtected();
    return sessionDelegate.perform(new SessionOperation<Node>() {

        @Override
        public Node perform() throws RepositoryException {
            String oakPath = sessionDelegate.getOakPathKeepIndexOrThrowNotFound(relPath);
            String oakName = PathUtils.getName(oakPath);
            String parentPath = sessionDelegate.getOakPath(PathUtils.getParentPath(oakPath));
            // handle index
            if (oakName.contains(""["")) {
                throw new RepositoryException(""Cannot create a new node using a name including an index"");
            }
            NodeDelegate parent = dlg.getChild(parentPath);
            if (parent == null) {
                // is it a property?
                String grandParentPath = PathUtils.getParentPath(parentPath);
                NodeDelegate grandParent = dlg.getChild(grandParentPath);
                if (grandParent != null) {
                    String propName = PathUtils.getName(parentPath);
                    if (grandParent.getProperty(propName) != null) {
                        throw new ConstraintViolationException(""Can't add new node to property."");
                    }
                }
                throw new PathNotFoundException(relPath);
            }
            if (parent.getChild(oakName) != null) {
                throw new ItemExistsException(relPath);
            }
            String ntName = primaryNodeTypeName;
            if (ntName == null) {
                DefinitionProvider dp = sessionDelegate.getDefinitionProvider();
                try {
                    String childName = sessionDelegate.getOakName(PathUtils.getName(relPath));
                    NodeDefinition def = dp.getDefinition(new NodeImpl<NodeDelegate>(parent), childName);
                    ntName = def.getDefaultPrimaryTypeName();
                } catch (RepositoryException e) {
                    throw new ConstraintViolationException(""no matching child node definition found for "" + relPath);
                }
            }
            // TODO: figure out the right place for this check
            NodeTypeManager ntm = sessionDelegate.getNodeTypeManager();
            // throws on not found
            NodeType nt = ntm.getNodeType(ntName);
            if (nt.isAbstract() || nt.isMixin()) {
                throw new ConstraintViolationException();
            }
            // TODO: END
            NodeDelegate added = parent.addChild(oakName);
            if (added == null) {
                throw new ItemExistsException();
            }
            NodeImpl<?> childNode = new NodeImpl<NodeDelegate>(added);
            childNode.internalSetPrimaryType(ntName);
            childNode.autoCreateItems();
            return childNode;
        }
    });
}",,"@Override
@Nonnull
public Node addNode(final String relPath, final String primaryNodeTypeName) throws RepositoryException {
    checkStatus();
    checkProtected();
    return sessionDelegate.perform(new SessionOperation<Node>() {

        @Override
        public Node perform() throws RepositoryException {
            String oakPath = sessionDelegate.getOakPathKeepIndexOrThrowNotFound(relPath);
            String oakName = PathUtils.getName(oakPath);
            String parentPath = sessionDelegate.getOakPath(PathUtils.getParentPath(oakPath));
                        if (oakName.contains(""["")) {
                throw new RepositoryException(""Cannot create a new node using a name including an index"");
            }
            NodeDelegate parent = dlg.getChild(parentPath);
            if (parent == null) {
                                String grandParentPath = PathUtils.getParentPath(parentPath);
                NodeDelegate grandParent = dlg.getChild(grandParentPath);
                if (grandParent != null) {
                    String propName = PathUtils.getName(parentPath);
                    if (grandParent.getProperty(propName) != null) {
                        throw new ConstraintViolationException(""Can't add new node to property."");
                    }
                }
                throw new PathNotFoundException(relPath);
            }
            if (parent.getChild(oakName) != null) {
                throw new ItemExistsException(relPath);
            }
            String ntName = primaryNodeTypeName;
            if (ntName == null) {
                DefinitionProvider dp = sessionDelegate.getDefinitionProvider();
                try {
                    String childName = sessionDelegate.getOakName(PathUtils.getName(relPath));
                    NodeDefinition def = dp.getDefinition(new NodeImpl<NodeDelegate>(parent), childName);
                    ntName = def.getDefaultPrimaryTypeName();
                } catch (RepositoryException e) {
                    throw new ConstraintViolationException(""no matching child node definition found for "" + relPath);
                }
            }
                        NodeTypeManager ntm = sessionDelegate.getNodeTypeManager();
                        NodeType nt = ntm.getNodeType(ntName);
            if (nt.isAbstract() || nt.isMixin()) {
                throw new ConstraintViolationException();
            }
                        NodeDelegate added = parent.addChild(oakName);
            if (added == null) {
                throw new ItemExistsException();
            }
            NodeImpl<?> childNode = new NodeImpl<NodeDelegate>(added);
            childNode.internalSetPrimaryType(ntName);
            childNode.autoCreateItems();
            return childNode;
        }
    });
}",1.9090909090909092,1.1770334928229667,2.6,1.0,1.25,0.5337301587301588,-0.9881606765327691,1.6666666666666667,-0.02631578947368421,1.993826754954674
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1199_813109d7,3,"@Override
public void read(org.apache.thrift.protocol.TProtocol prot, setTableProperty_result struct) throws org.apache.thrift.TException {
    TTupleProtocol iprot = (TTupleProtocol) prot;
    BitSet incoming = iprot.readBitSet(2);
    if (incoming.get(0)) {
        struct.ouch1 = new AccumuloException();
        struct.ouch1.read(iprot);
        struct.setOuch1IsSet(true);
    }
    if (incoming.get(1)) {
        struct.ouch2 = new AccumuloSecurityException();
        struct.ouch2.read(iprot);
        struct.setOuch2IsSet(true);
    }
}",,"@Override
public void read(org.apache.thrift.protocol.TProtocol prot, setTableProperty_result struct) throws org.apache.thrift.TException {
    TTupleProtocol iprot = (TTupleProtocol) prot;
    BitSet incoming = iprot.readBitSet(2);
    if (incoming.get(0)) {
        struct.ouch1 = new AccumuloException();
        struct.ouch1.read(iprot);
        struct.setOuch1IsSet(true);
    }
    if (incoming.get(1)) {
        struct.ouch2 = new AccumuloSecurityException();
        struct.ouch2.read(iprot);
        struct.setOuch2IsSet(true);
    }
}",0.045454545454545456,0.0,-0.2,-0.5,-0.08333333333333333,-0.3650793650793651,-0.09485553206483423,0.08333333333333333,-0.02631578947368421,-0.16279340490885932
commons-math,remotes/origin/bugs-dot-jar_MATH-393_d4b02f6a,3,"/**
 * Find an optimum in the given interval.
 * <p>
 * An optimizer may require that the interval brackets a single optimum.
 * </p>
 * @param f the function to optimize.
 * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}
 * or {@link GoalType#MINIMIZE}
 * @param min the lower bound for the interval.
 * @param max the upper bound for the interval.
 * @return a value where the function is optimum
 * @throws ConvergenceException if the maximum iteration count is exceeded
 * or the optimizer detects convergence problems otherwise.
 * @throws FunctionEvaluationException if an error occurs evaluating the
 * function
 * @throws IllegalArgumentException if min > max or the endpoints do not
 * satisfy the requirements specified by the optimizer
 */
double optimize(UnivariateRealFunction f, GoalType goalType, double min, double max) throws ConvergenceException, FunctionEvaluationException;","/**
 * Find an optimum in the given interval.
 * <p>
 * An optimizer may require that the interval brackets a single optimum.
 * </p>
 * @param f the function to optimize.
 * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}
 * or {@link GoalType#MINIMIZE}
 * @param min the lower bound for the interval.
 * @param max the upper bound for the interval.
 * @return a value where the function is optimum
 * @throws ConvergenceException if the maximum iteration count is exceeded
 * or the optimizer detects convergence problems otherwise.
 * @throws FunctionEvaluationException if an error occurs evaluating the
 * function
 * @throws IllegalArgumentException if min > max or the endpoints do not
 * satisfy the requirements specified by the optimizer
 */
","double optimize(UnivariateRealFunction f, GoalType goalType, double min, double max) throws ConvergenceException, FunctionEvaluationException;",-0.5909090909090909,-1.4306220095693782,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,1.457505285412262,-0.5,0.1842105263157895,-0.16279340490885932
wicket,remotes/origin/bugs-dot-jar_WICKET-4030_5f69685d,3,"/**
 *  @param location
 *  @return relative path
 */
private String relative(final String location) {
    Args.notEmpty(location, ""location"");
    if (location.startsWith(""http://"") || location.startsWith(""https://"") || location.startsWith(""/"")) {
        return location;
    }
    RequestCycle rc = RequestCycle.get();
    return rc.getUrlRenderer().renderUrl(Url.parse(location, rc.getRequest().getCharset()));
}","/**
 *  @param location
 *  @return relative path
 */
","private String relative(final String location) {
    Args.notEmpty(location, ""location"");
    if (location.startsWith(""http://"") || location.startsWith(""https://"") || location.startsWith(""/"")) {
        return location;
    }
    RequestCycle rc = RequestCycle.get();
    return rc.getUrlRenderer().renderUrl(Url.parse(location, rc.getRequest().getCharset()));
}",-0.2727272727272727,-0.2822966507177035,-0.4,-0.5,0.08333333333333333,-0.03174603174603177,0.28118393234672284,0.3333333333333333,0.05263157894736841,-0.046834137261342876
commons-math,remotes/origin/bugs-dot-jar_MATH-373_bfe4623c,1,"/**
 * {@inheritDoc}
 */
@Override
public void increment(final double d) {
    if (n == 0) {
        value = d * d;
    } else {
        value += d * d;
    }
    n++;
}","/**
 * {@inheritDoc}
 */
","@Override
public void increment(final double d) {
    if (n == 0) {
        value = d * d;
    } else {
        value += d * d;
    }
    n++;
}",-0.22727272727272727,-0.01913875598086126,-0.4,-0.5,-0.25,0.371031746031746,0.3423537702607468,-0.5,2.5789473684210527,-0.046151806965070916
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-43_668f08f2,1,"public void addNode(String parentNodePath, String nodeName, Map<String, String> properties) throws Exception {
    MutableNode modParent = getOrCreateStagedNode(parentNodePath);
    if (modParent.getChildNodeEntry(nodeName) != null) {
        throw new Exception(""there's already a child node with name '"" + nodeName + ""'"");
    }
    String newPath = PathUtils.concat(parentNodePath, nodeName);
    MutableNode newChild = new MutableNode(store, newPath);
    newChild.getProperties().putAll(properties);
    // id will be computed on commit
    modParent.add(new ChildNode(nodeName, null));
    staged.put(newPath, newChild);
    // update change log
    changeLog.add(new AddNode(parentNodePath, nodeName, properties));
}",,"public void addNode(String parentNodePath, String nodeName, Map<String, String> properties) throws Exception {
    MutableNode modParent = getOrCreateStagedNode(parentNodePath);
    if (modParent.getChildNodeEntry(nodeName) != null) {
        throw new Exception(""there's already a child node with name '"" + nodeName + ""'"");
    }
    String newPath = PathUtils.concat(parentNodePath, nodeName);
    MutableNode newChild = new MutableNode(store, newPath);
    newChild.getProperties().putAll(properties);
        modParent.add(new ChildNode(nodeName, null));
    staged.put(newPath, newChild);
        changeLog.add(new AddNode(parentNodePath, nodeName, properties));
}",-0.09090909090909091,-0.4880382775119619,-0.2,-0.5,-0.16666666666666666,0.009920634920634885,-0.006342494714587576,0.16666666666666666,-0.02631578947368421,0.08796297897108737
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1174_342809f7,3,"/**
 * Parse the specified jcr name and inform the specified {@code listener}
 * about the result or any error that may occur during parsing.
 *
 * @param jcrName The jcr name to be parsed.
 * @param listener The listener to be informed about success or failure.
 * @param index index, or {@code 0} when not specified
 * @return whether parsing was successful
 */
public static boolean parse(String jcrName, Listener listener, int index) {
    // trivial check
    int len = jcrName == null ? 0 : jcrName.length();
    if (len == 0) {
        listener.error(""Empty name"");
        return false;
    }
    if (""."".equals(jcrName) || "".."".equals(jcrName)) {
        listener.error(""Illegal name:"" + jcrName);
        return false;
    }
    // parse the name
    String prefix;
    int nameStart = 0;
    int state = STATE_PREFIX_START;
    boolean trailingSpaces = false;
    for (int i = 0; i < len; i++) {
        char c = jcrName.charAt(i);
        if (c == ':') {
            if (state == STATE_PREFIX_START) {
                listener.error(""Prefix must not be empty"");
                return false;
            } else if (state == STATE_PREFIX) {
                if (trailingSpaces) {
                    listener.error(""Trailing spaces not allowed"");
                    return false;
                }
                prefix = jcrName.substring(0, i);
                if (!XMLChar.isValidNCName(prefix)) {
                    listener.error(""Invalid name prefix: "" + prefix);
                    return false;
                }
                state = STATE_NAME_START;
            } else if (state == STATE_URI) {
            // ignore -> validation of uri later on.
            } else {
                listener.error(""'"" + c + ""' not allowed in name"");
                return false;
            }
            trailingSpaces = false;
        } else if (c == ' ') {
            if (state == STATE_PREFIX_START || state == STATE_NAME_START) {
                listener.error(""'"" + c + ""' not valid name start"");
                return false;
            }
            trailingSpaces = true;
        } else if (Character.isWhitespace(c) || c == '[' || c == ']' || c == '*' || c == '|') {
            listener.error(""'"" + c + ""' not allowed in name"");
            return false;
        } else if (c == '/') {
            if (state == STATE_URI_START) {
                state = STATE_URI;
            } else if (state != STATE_URI) {
                listener.error(""'"" + c + ""' not allowed in name"");
                return false;
            }
            trailingSpaces = false;
        } else if (c == '{') {
            if (state == STATE_PREFIX_START) {
                state = STATE_URI_START;
            } else if (state == STATE_URI_START || state == STATE_URI) {
                // second '{' in the uri-part -> no valid expanded jcr-name.
                // therefore reset the nameStart and change state.
                state = STATE_NAME;
                nameStart = 0;
            } else if (state == STATE_NAME_START) {
                state = STATE_NAME;
                nameStart = i;
            }
            trailingSpaces = false;
        } else if (c == '}') {
            if (state == STATE_URI_START || state == STATE_URI) {
                String tmp = jcrName.substring(1, i);
                if (tmp.isEmpty() || tmp.indexOf(':') != -1) {
                    // The leading ""{...}"" part is empty or contains
                    // a colon, so we treat it as a valid namespace URI.
                    // More detailed validity checks (is it well formed,
                    // registered, etc.) are not needed here.
                    state = STATE_NAME_START;
                } else if (tmp.equals(""internal"")) {
                    // As a special Jackrabbit backwards compatibility
                    // feature, support {internal} as a valid URI prefix
                    state = STATE_NAME_START;
                } else if (tmp.indexOf('/') == -1) {
                    // The leading ""{...}"" contains neither a colon nor
                    // a slash, so we can interpret it as a a part of a
                    // normal local name.
                    state = STATE_NAME;
                    nameStart = 0;
                } else {
                    listener.error(""The URI prefix of the name "" + jcrName + "" is "" + ""neither a valid URI nor a valid part of a local name."");
                    return false;
                }
            } else if (state == STATE_PREFIX_START) {
                // prefix start -> validation later on will fail.
                state = STATE_PREFIX;
            } else if (state == STATE_NAME_START) {
                state = STATE_NAME;
                nameStart = i;
            }
            trailingSpaces = false;
        } else {
            if (state == STATE_PREFIX_START) {
                // prefix start
                state = STATE_PREFIX;
            } else if (state == STATE_NAME_START) {
                state = STATE_NAME;
                nameStart = i;
            } else if (state == STATE_URI_START) {
                state = STATE_URI;
            }
            trailingSpaces = false;
        }
    }
    // a terminating '}' -> make sure there are no illegal characters present.
    if (state == STATE_URI && (jcrName.indexOf(':') > -1 || jcrName.indexOf('/') > -1)) {
        listener.error(""Local name may not contain ':' nor '/'"");
        return false;
    }
    if (nameStart == len || state == STATE_NAME_START) {
        listener.error(""Local name must not be empty"");
        return false;
    }
    if (trailingSpaces) {
        listener.error(""Trailing spaces not allowed"");
        return false;
    }
    return listener.name(jcrName, index);
}","/**
 * Parse the specified jcr name and inform the specified {@code listener}
 * about the result or any error that may occur during parsing.
 *
 * @param jcrName The jcr name to be parsed.
 * @param listener The listener to be informed about success or failure.
 * @param index index, or {@code 0} when not specified
 * @return whether parsing was successful
 */
","public static boolean parse(String jcrName, Listener listener, int index) {
        int len = jcrName == null ? 0 : jcrName.length();
    if (len == 0) {
        listener.error(""Empty name"");
        return false;
    }
    if (""."".equals(jcrName) || "".."".equals(jcrName)) {
        listener.error(""Illegal name:"" + jcrName);
        return false;
    }
        String prefix;
    int nameStart = 0;
    int state = STATE_PREFIX_START;
    boolean trailingSpaces = false;
    for (int i = 0; i < len; i++) {
        char c = jcrName.charAt(i);
        if (c == ':') {
            if (state == STATE_PREFIX_START) {
                listener.error(""Prefix must not be empty"");
                return false;
            } else if (state == STATE_PREFIX) {
                if (trailingSpaces) {
                    listener.error(""Trailing spaces not allowed"");
                    return false;
                }
                prefix = jcrName.substring(0, i);
                if (!XMLChar.isValidNCName(prefix)) {
                    listener.error(""Invalid name prefix: "" + prefix);
                    return false;
                }
                state = STATE_NAME_START;
            } else if (state == STATE_URI) {
                        } else {
                listener.error(""'"" + c + ""' not allowed in name"");
                return false;
            }
            trailingSpaces = false;
        } else if (c == ' ') {
            if (state == STATE_PREFIX_START || state == STATE_NAME_START) {
                listener.error(""'"" + c + ""' not valid name start"");
                return false;
            }
            trailingSpaces = true;
        } else if (Character.isWhitespace(c) || c == '[' || c == ']' || c == '*' || c == '|') {
            listener.error(""'"" + c + ""' not allowed in name"");
            return false;
        } else if (c == '/') {
            if (state == STATE_URI_START) {
                state = STATE_URI;
            } else if (state != STATE_URI) {
                listener.error(""'"" + c + ""' not allowed in name"");
                return false;
            }
            trailingSpaces = false;
        } else if (c == '{') {
            if (state == STATE_PREFIX_START) {
                state = STATE_URI_START;
            } else if (state == STATE_URI_START || state == STATE_URI) {
                                                state = STATE_NAME;
                nameStart = 0;
            } else if (state == STATE_NAME_START) {
                state = STATE_NAME;
                nameStart = i;
            }
            trailingSpaces = false;
        } else if (c == '}') {
            if (state == STATE_URI_START || state == STATE_URI) {
                String tmp = jcrName.substring(1, i);
                if (tmp.isEmpty() || tmp.indexOf(':') != -1) {
                                                                                                    state = STATE_NAME_START;
                } else if (tmp.equals(""internal"")) {
                                                            state = STATE_NAME_START;
                } else if (tmp.indexOf('/') == -1) {
                                                                                state = STATE_NAME;
                    nameStart = 0;
                } else {
                    listener.error(""The URI prefix of the name "" + jcrName + "" is "" + ""neither a valid URI nor a valid part of a local name."");
                    return false;
                }
            } else if (state == STATE_PREFIX_START) {
                                state = STATE_PREFIX;
            } else if (state == STATE_NAME_START) {
                state = STATE_NAME;
                nameStart = i;
            }
            trailingSpaces = false;
        } else {
            if (state == STATE_PREFIX_START) {
                                state = STATE_PREFIX;
            } else if (state == STATE_NAME_START) {
                state = STATE_NAME;
                nameStart = i;
            } else if (state == STATE_URI_START) {
                state = STATE_URI;
            }
            trailingSpaces = false;
        }
    }
        if (state == STATE_URI && (jcrName.indexOf(':') > -1 || jcrName.indexOf('/') > -1)) {
        listener.error(""Local name may not contain ':' nor '/'"");
        return false;
    }
    if (nameStart == len || state == STATE_NAME_START) {
        listener.error(""Local name must not be empty"");
        return false;
    }
    if (trailingSpaces) {
        listener.error(""Trailing spaces not allowed"");
        return false;
    }
    return listener.name(jcrName, index);
}",4.454545454545454,1.0047846889952152,6.0,4.5,4.833333333333333,3.6507936507936507,-1.5234672304439743,1.8333333333333333,-0.02631578947368421,20.057216622580288
Closure,136,2,"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    if (n.getType() != Token.NAME) {
        return;
    }
    String name = n.getString();
    // Ignore anonymous functions
    if (name.length() == 0) {
        return;
    }
    // Is this local or Global?
    Scope.Var var = t.getScope().getVar(name);
    boolean local = (var != null) && var.isLocal();
    // Are we renaming global variables?
    if (!local && localRenamingOnly) {
        reservedNames.add(name);
        return;
    }
    // Are we renaming anonymous function names?
    if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunction(var.getParentNode())) {
        reservedNames.add(name);
        return;
    }
    // Check if we can rename this.
    if (!okToRenameVar(name, local)) {
        // Blindly de-uniquify for the Prototype library for issue 103.
        return;
    }
    if (isExternsPass_) {
        // Keep track of extern globals.
        if (!local) {
            externNames.add(name);
        }
        return;
    }
    if (local) {
        // Local var: assign a new name
        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();
        incCount(tempName, null);
        localNameNodes.add(n);
        localTempNames.add(tempName);
    } else if (var != null) {
        // Not an extern
        // If it's global, increment global count
        incCount(name, var.input);
        globalNameNodes.add(n);
    }
}",,"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    if (n.getType() != Token.NAME) {
        return;
    }
    String name = n.getString();
        if (name.length() == 0) {
        return;
    }
        Scope.Var var = t.getScope().getVar(name);
    boolean local = (var != null) && var.isLocal();
        if (!local && localRenamingOnly) {
        reservedNames.add(name);
        return;
    }
        if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunction(var.getParentNode())) {
        reservedNames.add(name);
        return;
    }
        if (!okToRenameVar(name, local)) {
                return;
    }
    if (isExternsPass_) {
                if (!local) {
            externNames.add(name);
        }
        return;
    }
    if (local) {
                String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();
        incCount(tempName, null);
        localNameNodes.add(n);
        localTempNames.add(tempName);
    } else if (var != null) {
                        incCount(name, var.input);
        globalNameNodes.add(n);
    }
}",1.0909090909090908,-0.14832535885167467,1.2,0.0,1.5,0.753968253968254,-0.669626497533474,1.0,-0.02631578947368421,1.232041861885744
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2330_408a566e,3,"private boolean indexProperty(String path, List<Field> fields, NodeState state, PropertyState property, String pname, boolean aggregateMode, PropertyDefinition pd) throws CommitFailedException {
    boolean includeTypeForFullText = indexingRule.includePropertyType(property.getType().tag());
    if (Type.BINARY.tag() == property.getType().tag() && includeTypeForFullText) {
        this.context.indexUpdate();
        fields.addAll(newBinary(property, state, null, path + ""@"" + pname));
        return true;
    } else {
        boolean dirty = false;
        if (pd.propertyIndex && pd.includePropertyType(property.getType().tag())) {
            dirty |= addTypedFields(fields, property, pname);
        }
        if (pd.fulltextEnabled() && includeTypeForFullText) {
            for (String value : property.getValue(Type.STRINGS)) {
                this.context.indexUpdate();
                if (pd.analyzed && pd.includePropertyType(property.getType().tag())) {
                    String analyzedPropName = constructAnalyzedPropertyName(pname);
                    fields.add(newPropertyField(analyzedPropName, value, !pd.skipTokenization(pname), pd.stored));
                }
                if (pd.nodeScopeIndex && !aggregateMode) {
                    Field field = newFulltextField(value);
                    field.setBoost(pd.boost);
                    fields.add(field);
                }
                dirty = true;
            }
        }
        return dirty;
    }
}",,"private boolean indexProperty(String path, List<Field> fields, NodeState state, PropertyState property, String pname, boolean aggregateMode, PropertyDefinition pd) throws CommitFailedException {
    boolean includeTypeForFullText = indexingRule.includePropertyType(property.getType().tag());
    if (Type.BINARY.tag() == property.getType().tag() && includeTypeForFullText) {
        this.context.indexUpdate();
        fields.addAll(newBinary(property, state, null, path + ""@"" + pname));
        return true;
    } else {
        boolean dirty = false;
        if (pd.propertyIndex && pd.includePropertyType(property.getType().tag())) {
            dirty |= addTypedFields(fields, property, pname);
        }
        if (pd.fulltextEnabled() && includeTypeForFullText) {
            for (String value : property.getValue(Type.STRINGS)) {
                this.context.indexUpdate();
                if (pd.analyzed && pd.includePropertyType(property.getType().tag())) {
                    String analyzedPropName = constructAnalyzedPropertyName(pname);
                    fields.add(newPropertyField(analyzedPropName, value, !pd.skipTokenization(pname), pd.stored));
                }
                if (pd.nodeScopeIndex && !aggregateMode) {
                    Field field = newFulltextField(value);
                    field.setBoost(pd.boost);
                    fields.add(field);
                }
                dirty = true;
            }
        }
        return dirty;
    }
}",0.6818181818181818,1.4832535885167464,0.6,1.0,1.1666666666666667,0.8849206349206349,-0.5650458069062719,1.6666666666666667,-0.02631578947368421,1.8613117569428832
commons-math,remotes/origin/bugs-dot-jar_MATH-757_76b7413d,1,"/**
 * Sets the contraction criteria.
 *
 * @param contractionCriteria contraction criteria
 * @throws MathIllegalArgumentException if the contractionCriteria is less than
 *         the expansionCriteria.
 * @deprecated As of 3.1 (to be removed in 4.0 as field will become ""final"").
 */
@Deprecated
public void setContractionCriteria(float contractionCriteria) throws MathIllegalArgumentException {
    checkContractExpand(contractionCriteria, getExpansionFactor());
    synchronized (this) {
        this.contractionCriterion = contractionCriteria;
    }
}","/**
 * Sets the contraction criteria.
 *
 * @param contractionCriteria contraction criteria
 * @throws MathIllegalArgumentException if the contractionCriteria is less than
 *         the expansionCriteria.
 * @deprecated As of 3.1 (to be removed in 4.0 as field will become ""final"").
 */
","@Deprecated
public void setContractionCriteria(float contractionCriteria) throws MathIllegalArgumentException {
    checkContractExpand(contractionCriteria, getExpansionFactor());
    synchronized (this) {
        this.contractionCriterion = contractionCriteria;
    }
}",-0.3181818181818182,-0.0909090909090911,-0.6,-0.5,-0.4166666666666667,-0.3650793650793651,0.5619450317124735,-0.3333333333333333,2.026315789473684,-0.16279340490885932
camel,remotes/origin/bugs-dot-jar_CAMEL-7167_1e33fcbc,3,"/**
 * Common work which must be done when we are done multicasting.
 * <p/>
 * This logic applies for both running synchronous and asynchronous as there are multiple exist points
 * when using the asynchronous routing engine. And therefore we want the logic in one method instead
 * of being scattered.
 *
 * @param original     the original exchange
 * @param subExchange  the current sub exchange, can be <tt>null</tt> for the synchronous part
 * @param pairs        the pairs with the exchanges to process
 * @param callback     the callback
 * @param doneSync     the <tt>doneSync</tt> parameter to call on callback
 * @param forceExhaust whether or not error handling is exhausted
 */
protected void doDone(Exchange original, Exchange subExchange, final Iterable<ProcessorExchangePair> pairs, AsyncCallback callback, boolean doneSync, boolean forceExhaust) {
    // we are done so close the pairs iterator
    if (pairs != null && pairs instanceof Closeable) {
        IOHelper.close((Closeable) pairs, ""pairs"", LOG);
    }
    // cleanup any per exchange aggregation strategy
    removeAggregationStrategyFromExchange(original);
    // we need to know if there was an exception, and if the stopOnException option was enabled
    // also we would need to know if any error handler has attempted redelivery and exhausted
    boolean stoppedOnException = false;
    boolean exception = false;
    boolean exhaust = forceExhaust || subExchange != null && (subExchange.getException() != null || ExchangeHelper.isRedeliveryExhausted(subExchange));
    if (original.getException() != null || subExchange != null && subExchange.getException() != null) {
        // there was an exception and we stopped
        stoppedOnException = isStopOnException();
        exception = true;
    }
    // must copy results at this point
    if (subExchange != null) {
        if (stoppedOnException) {
            // if we stopped due an exception then only propagte the exception
            original.setException(subExchange.getException());
        } else {
            // copy the current result to original so it will contain this result of this eip
            ExchangeHelper.copyResults(original, subExchange);
        }
    }
    // handled has been in use, then the exhaust would be false (if not forced)
    if (exception) {
        // multicast uses error handling on its output processors and they have tried to redeliver
        // so we shall signal back to the other error handlers that we are exhausted and they should not
        // also try to redeliver as we will then do that twice
        original.setProperty(Exchange.REDELIVERY_EXHAUSTED, exhaust);
    }
    callback.done(doneSync);
}","/**
 * Common work which must be done when we are done multicasting.
 * <p/>
 * This logic applies for both running synchronous and asynchronous as there are multiple exist points
 * when using the asynchronous routing engine. And therefore we want the logic in one method instead
 * of being scattered.
 *
 * @param original     the original exchange
 * @param subExchange  the current sub exchange, can be <tt>null</tt> for the synchronous part
 * @param pairs        the pairs with the exchanges to process
 * @param callback     the callback
 * @param doneSync     the <tt>doneSync</tt> parameter to call on callback
 * @param forceExhaust whether or not error handling is exhausted
 */
","protected void doDone(Exchange original, Exchange subExchange, final Iterable<ProcessorExchangePair> pairs, AsyncCallback callback, boolean doneSync, boolean forceExhaust) {
        if (pairs != null && pairs instanceof Closeable) {
        IOHelper.close((Closeable) pairs, ""pairs"", LOG);
    }
        removeAggregationStrategyFromExchange(original);
            boolean stoppedOnException = false;
    boolean exception = false;
    boolean exhaust = forceExhaust || subExchange != null && (subExchange.getException() != null || ExchangeHelper.isRedeliveryExhausted(subExchange));
    if (original.getException() != null || subExchange != null && subExchange.getException() != null) {
                stoppedOnException = isStopOnException();
        exception = true;
    }
        if (subExchange != null) {
        if (stoppedOnException) {
                        original.setException(subExchange.getException());
        } else {
                        ExchangeHelper.copyResults(original, subExchange);
        }
    }
        if (exception) {
                                original.setProperty(Exchange.REDELIVERY_EXHAUSTED, exhaust);
    }
    callback.done(doneSync);
}",0.45454545454545453,0.009569377990430419,0.4,0.0,0.75,0.5158730158730159,-0.4114164904862578,0.5,-0.02631578947368421,0.7785457835560702
camel,remotes/origin/bugs-dot-jar_CAMEL-8592_57f72cd9,3,"@SuppressWarnings(""unchecked"")
public void onCompletion(Exchange exchange) {
    if (isStoreAsBodyOnCompletion()) {
        List<V> list = (List<V>) exchange.removeProperty(Exchange.GROUPED_EXCHANGE);
        if (list != null) {
            exchange.getIn().setBody(list);
        }
    }
}",,"@SuppressWarnings(""unchecked"")
public void onCompletion(Exchange exchange) {
    if (isStoreAsBodyOnCompletion()) {
        List<V> list = (List<V>) exchange.removeProperty(Exchange.GROUPED_EXCHANGE);
        if (list != null) {
            exchange.getIn().setBody(list);
        }
    }
}",-0.22727272727272727,0.5406698564593301,-0.2,0.0,-0.08333333333333333,-0.07341269841269843,0.2825933756166315,-0.16666666666666666,0.8157894736842105,-0.09645983529560923
flink,remotes/origin/bugs-dot-jar_FLINK-1820_39d526e6,0,"/**
 *  Static utility to parse a field of type double from a byte sequence that represents text characters
 *  (such as when read from a file stream).
 *
 *  @param bytes The bytes containing the text data that should be parsed.
 *  @param startPos The offset to start the parsing.
 *  @param length The length of the byte sequence (counting from the offset).
 *  @param delimiter The delimiter that terminates the field.
 *
 *  @return The parsed value.
 *
 *  @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.
 */
public static final double parseField(byte[] bytes, int startPos, int length, char delimiter) {
    if (length <= 0) {
        throw new NumberFormatException(""Invalid input: Empty string"");
    }
    int i = 0;
    final byte delByte = (byte) delimiter;
    while (i < length && bytes[i] != delByte) {
        i++;
    }
    String str = new String(bytes, startPos, i);
    return Double.parseDouble(str);
}","/**
 *  Static utility to parse a field of type double from a byte sequence that represents text characters
 *  (such as when read from a file stream).
 *
 *  @param bytes The bytes containing the text data that should be parsed.
 *  @param startPos The offset to start the parsing.
 *  @param length The length of the byte sequence (counting from the offset).
 *  @param delimiter The delimiter that terminates the field.
 *
 *  @return The parsed value.
 *
 *  @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.
 */
","public static final double parseField(byte[] bytes, int startPos, int length, char delimiter) {
    if (length <= 0) {
        throw new NumberFormatException(""Invalid input: Empty string"");
    }
    int i = 0;
    final byte delByte = (byte) delimiter;
    while (i < length && bytes[i] != delByte) {
        i++;
    }
    String str = new String(bytes, startPos, i);
    return Double.parseDouble(str);
}",-0.09090909090909091,-0.32535885167464124,0.0,-0.5,0.08333333333333333,0.7857142857142857,0.07061310782241001,-0.4166666666666667,0.13157894736842105,0.2717726180391072
Compress,17,1,"/**
 * Parse an octal string from a buffer.
 *
 * <p>Leading spaces are ignored.
 * The buffer must contain a trailing space or NUL,
 * and may contain an additional trailing space or NUL.</p>
 *
 * <p>The input buffer is allowed to contain all NULs,
 * in which case the method returns 0L
 * (this allows for missing fields).</p>
 *
 * <p>To work-around some tar implementations that insert a
 * leading NUL this method returns 0 if it detects a leading NUL
 * since Commons Compress 1.4.</p>
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse - must be at least 2 bytes.
 * @return The long value of the octal string.
 * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.
 */
public static long parseOctal(final byte[] buffer, final int offset, final int length) {
    long result = 0;
    int end = offset + length;
    int start = offset;
    if (length < 2) {
        throw new IllegalArgumentException(""Length "" + length + "" must be at least 2"");
    }
    if (buffer[start] == 0) {
        return 0L;
    }
    // Skip leading spaces
    while (start < end) {
        if (buffer[start] == ' ') {
            start++;
        } else {
            break;
        }
    }
    // Must have trailing NUL or space
    byte trailer;
    trailer = buffer[end - 1];
    if (trailer == 0 || trailer == ' ') {
        end--;
    } else {
        throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, end - 1, trailer));
    }
    // May have additional NULs or spaces
    trailer = buffer[end - 1];
    if (trailer == 0 || trailer == ' ') {
        end--;
    }
    for (; start < end; start++) {
        final byte currentByte = buffer[start];
        // CheckStyle:MagicNumber OFF
        if (currentByte < '0' || currentByte > '7') {
            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));
        }
        // convert from ASCII
        result = (result << 3) + (currentByte - '0');
    // CheckStyle:MagicNumber ON
    }
    return result;
}","/**
 * Parse an octal string from a buffer.
 *
 * <p>Leading spaces are ignored.
 * The buffer must contain a trailing space or NUL,
 * and may contain an additional trailing space or NUL.</p>
 *
 * <p>The input buffer is allowed to contain all NULs,
 * in which case the method returns 0L
 * (this allows for missing fields).</p>
 *
 * <p>To work-around some tar implementations that insert a
 * leading NUL this method returns 0 if it detects a leading NUL
 * since Commons Compress 1.4.</p>
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse - must be at least 2 bytes.
 * @return The long value of the octal string.
 * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.
 */
","public static long parseOctal(final byte[] buffer, final int offset, final int length) {
    long result = 0;
    int end = offset + length;
    int start = offset;
    if (length < 2) {
        throw new IllegalArgumentException(""Length "" + length + "" must be at least 2"");
    }
    if (buffer[start] == 0) {
        return 0L;
    }
        while (start < end) {
        if (buffer[start] == ' ') {
            start++;
        } else {
            break;
        }
    }
        byte trailer;
    trailer = buffer[end - 1];
    if (trailer == 0 || trailer == ' ') {
        end--;
    } else {
        throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, end - 1, trailer));
    }
        trailer = buffer[end - 1];
    if (trailer == 0 || trailer == ' ') {
        end--;
    }
    for (; start < end; start++) {
        final byte currentByte = buffer[start];
                if (currentByte < '0' || currentByte > '7') {
            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));
        }
                result = (result << 3) + (currentByte - '0');
        }
    return result;
}",1.0454545454545454,-0.05741626794258379,1.8,0.0,0.9166666666666666,3.3194444444444446,-0.6806201550387594,-0.3333333333333333,-0.02631578947368421,4.5456175838361474
flink,remotes/origin/bugs-dot-jar_FLINK-1496_0a4c7694,1,"// ------------------------------------------------------------------------
// Task events
// ------------------------------------------------------------------------
@Override
public void sendTaskEvent(TaskEvent event) throws IOException, InterruptedException {
    // remote input channels.
    synchronized (requestLock) {
        for (InputChannel inputChannel : inputChannels.values()) {
            inputChannel.sendTaskEvent(event);
        }
    }
}",,"@Override
public void sendTaskEvent(TaskEvent event) throws IOException, InterruptedException {
        synchronized (requestLock) {
        for (InputChannel inputChannel : inputChannels.values()) {
            inputChannel.sendTaskEvent(event);
        }
    }
}",-0.2727272727272727,0.5837320574162679,-0.4,0.0,-0.4166666666666667,-0.3650793650793651,0.43086680761099344,-0.3333333333333333,2.3157894736842106,-0.16279340490885932
camel,remotes/origin/bugs-dot-jar_CAMEL-6987_37e0e6bb,3,"/**
 * Extracts the body for logging purpose.
 * <p/>
 * Will clip the body if its too big for logging.
 *
 * @see org.apache.camel.Exchange#LOG_DEBUG_BODY_MAX_CHARS
 * @param message the message
 * @param prepend a message to prepend
 * @param allowStreams whether or not streams is allowed
 * @param allowFiles whether or not files is allowed (currently not in use)
 * @param maxChars limit to maximum number of chars. Use 0 for not limit, and -1 for turning logging message body off.
 * @return the logging message
 */
public static String extractBodyForLogging(Message message, String prepend, boolean allowStreams, boolean allowFiles, int maxChars) {
    if (maxChars < 0) {
        return prepend + ""[Body is not logged]"";
    }
    Object obj = message.getBody();
    if (obj == null) {
        return prepend + ""[Body is null]"";
    }
    if (!allowStreams) {
        if (obj instanceof Source && !(obj instanceof StringSource || obj instanceof BytesSource)) {
            // all other kinds we should not touch the body
            return prepend + ""[Body is instance of java.xml.transform.Source]"";
        } else if (obj instanceof StreamCache) {
            return prepend + ""[Body is instance of org.apache.camel.StreamCache]"";
        } else if (obj instanceof InputStream) {
            return prepend + ""[Body is instance of java.io.InputStream]"";
        } else if (obj instanceof OutputStream) {
            return prepend + ""[Body is instance of java.io.OutputStream]"";
        } else if (obj instanceof Reader) {
            return prepend + ""[Body is instance of java.io.Reader]"";
        } else if (obj instanceof Writer) {
            return prepend + ""[Body is instance of java.io.Writer]"";
        } else if (obj instanceof WrappedFile || obj instanceof File) {
            return prepend + ""[Body is file based: "" + obj + ""]"";
        }
    }
    if (!allowFiles) {
        if (obj instanceof WrappedFile || obj instanceof File) {
            return prepend + ""[Body is file based: "" + obj + ""]"";
        }
    }
    // is the body a stream cache
    StreamCache cache;
    if (obj instanceof StreamCache) {
        cache = (StreamCache) obj;
    } else {
        cache = null;
    }
    // grab the message body as a string
    String body = null;
    if (message.getExchange() != null) {
        try {
            body = message.getExchange().getContext().getTypeConverter().convertTo(String.class, message.getExchange(), obj);
        } catch (Exception e) {
        // ignore as the body is for logging purpose
        }
    }
    if (body == null) {
        body = obj.toString();
    }
    // reset stream cache after use
    if (cache != null) {
        cache.reset();
    }
    if (body == null) {
        return prepend + ""[Body is null]"";
    }
    // clip body if length enabled and the body is too big
    if (maxChars > 0 && body.length() > maxChars) {
        body = body.substring(0, maxChars) + ""... [Body clipped after "" + maxChars + "" chars, total length is "" + body.length() + ""]"";
    }
    return prepend + body;
}","/**
 * Extracts the body for logging purpose.
 * <p/>
 * Will clip the body if its too big for logging.
 *
 * @see org.apache.camel.Exchange#LOG_DEBUG_BODY_MAX_CHARS
 * @param message the message
 * @param prepend a message to prepend
 * @param allowStreams whether or not streams is allowed
 * @param allowFiles whether or not files is allowed (currently not in use)
 * @param maxChars limit to maximum number of chars. Use 0 for not limit, and -1 for turning logging message body off.
 * @return the logging message
 */
","public static String extractBodyForLogging(Message message, String prepend, boolean allowStreams, boolean allowFiles, int maxChars) {
    if (maxChars < 0) {
        return prepend + ""[Body is not logged]"";
    }
    Object obj = message.getBody();
    if (obj == null) {
        return prepend + ""[Body is null]"";
    }
    if (!allowStreams) {
        if (obj instanceof Source && !(obj instanceof StringSource || obj instanceof BytesSource)) {
                        return prepend + ""[Body is instance of java.xml.transform.Source]"";
        } else if (obj instanceof StreamCache) {
            return prepend + ""[Body is instance of org.apache.camel.StreamCache]"";
        } else if (obj instanceof InputStream) {
            return prepend + ""[Body is instance of java.io.InputStream]"";
        } else if (obj instanceof OutputStream) {
            return prepend + ""[Body is instance of java.io.OutputStream]"";
        } else if (obj instanceof Reader) {
            return prepend + ""[Body is instance of java.io.Reader]"";
        } else if (obj instanceof Writer) {
            return prepend + ""[Body is instance of java.io.Writer]"";
        } else if (obj instanceof WrappedFile || obj instanceof File) {
            return prepend + ""[Body is file based: "" + obj + ""]"";
        }
    }
    if (!allowFiles) {
        if (obj instanceof WrappedFile || obj instanceof File) {
            return prepend + ""[Body is file based: "" + obj + ""]"";
        }
    }
        StreamCache cache;
    if (obj instanceof StreamCache) {
        cache = (StreamCache) obj;
    } else {
        cache = null;
    }
        String body = null;
    if (message.getExchange() != null) {
        try {
            body = message.getExchange().getContext().getTypeConverter().convertTo(String.class, message.getExchange(), obj);
        } catch (Exception e) {
                }
    }
    if (body == null) {
        body = obj.toString();
    }
        if (cache != null) {
        cache.reset();
    }
    if (body == null) {
        return prepend + ""[Body is null]"";
    }
        if (maxChars > 0 && body.length() > maxChars) {
        body = body.substring(0, maxChars) + ""... [Body clipped after "" + maxChars + "" chars, total length is "" + body.length() + ""]"";
    }
    return prepend + body;
}",1.9545454545454546,0.0669856459330142,3.2,3.0,2.1666666666666665,1.7182539682539684,-1.0025369978858347,0.5,-0.02631578947368421,4.4114705255211115
Closure,134,2,"/**
 * Adds the node to the sub graph, adding all of its types to the set of
 * types in the sub graph and all of its related types to the related types
 * for the sub graph.
 */
public void addNode(Property prop) {
    typesInSet.or(prop.typesSet);
    typesRelatedToSet.or(getRelated(prop.type));
}","/**
 * Adds the node to the sub graph, adding all of its types to the set of
 * types in the sub graph and all of its related types to the related types
 * for the sub graph.
 */
","public void addNode(Property prop) {
    typesInSet.or(prop.typesSet);
    typesRelatedToSet.or(getRelated(prop.type));
}",-0.45454545454545453,-0.47368421052631593,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.7860465116279065,-0.25,1.368421052631579,-0.16279340490885932
maven,remotes/origin/bugs-dot-jar_MNG-4695_bb39b480,1,"private void validateRawPlugins(ModelProblemCollector problems, List<Plugin> plugins, boolean managed, ModelBuildingRequest request) {
    Severity errOn31 = getSeverity(request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_1);
    String prefix = (managed ? ""build.pluginManagement."" : ""build."") + ""plugins.plugin."";
    Map<String, Plugin> index = new HashMap<String, Plugin>();
    for (Plugin plugin : plugins) {
        String key = plugin.getKey();
        Plugin existing = index.get(key);
        if (existing != null) {
            addViolation(problems, errOn31, prefix + ""(groupId:artifactId)"", null, ""must be unique but found duplicate declaration of plugin "" + key, plugin);
        } else {
            index.put(key, plugin);
        }
        Set<String> executionIds = new HashSet<String>();
        for (PluginExecution exec : plugin.getExecutions()) {
            if (!executionIds.add(exec.getId())) {
                addViolation(problems, Severity.ERROR, ""build.plugins.plugin["" + plugin.getKey() + ""].executions.execution.id"", null, ""must be unique but found duplicate execution with id "" + exec.getId(), exec);
            }
        }
    }
}",,"private void validateRawPlugins(ModelProblemCollector problems, List<Plugin> plugins, boolean managed, ModelBuildingRequest request) {
    Severity errOn31 = getSeverity(request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_1);
    String prefix = (managed ? ""build.pluginManagement."" : ""build."") + ""plugins.plugin."";
    Map<String, Plugin> index = new HashMap<String, Plugin>();
    for (Plugin plugin : plugins) {
        String key = plugin.getKey();
        Plugin existing = index.get(key);
        if (existing != null) {
            addViolation(problems, errOn31, prefix + ""(groupId:artifactId)"", null, ""must be unique but found duplicate declaration of plugin "" + key, plugin);
        } else {
            index.put(key, plugin);
        }
        Set<String> executionIds = new HashSet<String>();
        for (PluginExecution exec : plugin.getExecutions()) {
            if (!executionIds.add(exec.getId())) {
                addViolation(problems, Severity.ERROR, ""build.plugins.plugin["" + plugin.getKey() + ""].executions.execution.id"", null, ""must be unique but found duplicate execution with id "" + exec.getId(), exec);
            }
        }
    }
}",0.2727272727272727,0.5071770334928228,0.4,0.5,0.16666666666666666,0.375,-0.3491190979563073,0.4166666666666667,-0.02631578947368421,0.7489381811056746
flink,remotes/origin/bugs-dot-jar_FLINK-1382_9cd96df7,3,"@SuppressWarnings({ ""rawtypes"", ""unchecked"" })
private static TypeInformation<?> parse(StringBuilder sb) throws ClassNotFoundException {
    String infoString = sb.toString();
    final Matcher tupleMatcher = tuplePattern.matcher(infoString);
    final Matcher writableMatcher = writablePattern.matcher(infoString);
    final Matcher enumMatcher = enumPattern.matcher(infoString);
    final Matcher basicTypeMatcher = basicTypePattern.matcher(infoString);
    final Matcher basicType2Matcher = basicType2Pattern.matcher(infoString);
    final Matcher valueTypeMatcher = valueTypePattern.matcher(infoString);
    final Matcher basicArrayTypeMatcher = basicArrayTypePattern.matcher(infoString);
    final Matcher basicArrayType2Matcher = basicArrayType2Pattern.matcher(infoString);
    final Matcher pojoGenericMatcher = pojoGenericObjectPattern.matcher(infoString);
    if (infoString.length() == 0) {
        return null;
    }
    TypeInformation<?> returnType = null;
    // tuples
    if (tupleMatcher.find()) {
        String className = tupleMatcher.group(1);
        sb.delete(0, className.length() + 1);
        int arity = Integer.parseInt(className.replaceAll(""\\D"", """"));
        Class<?> clazz;
        // check if fully qualified
        if (className.startsWith(TUPLE_PACKAGE)) {
            clazz = Class.forName(className);
        } else {
            clazz = Class.forName(TUPLE_PACKAGE + ""."" + className);
        }
        TypeInformation<?>[] types = new TypeInformation<?>[arity];
        for (int i = 0; i < arity; i++) {
            types[i] = parse(sb);
            if (types[i] == null) {
                throw new IllegalArgumentException(""Tuple arity does not match given parameters."");
            }
        }
        if (sb.charAt(0) != '>') {
            throw new IllegalArgumentException(""Tuple arity does not match given parameters."");
        }
        // remove '>'
        sb.deleteCharAt(0);
        // tuple arrays
        if (sb.length() > 0) {
            if (sb.length() >= 2 && sb.charAt(0) == '[' && sb.charAt(1) == ']') {
                Class<?> arrayClazz;
                // check if fully qualified
                if (className.startsWith(TUPLE_PACKAGE)) {
                    arrayClazz = Class.forName(""[L"" + className + "";"");
                } else {
                    arrayClazz = Class.forName(""[L"" + TUPLE_PACKAGE + ""."" + className + "";"");
                }
                returnType = ObjectArrayTypeInfo.getInfoFor(arrayClazz, new TupleTypeInfo(clazz, types));
            } else if (sb.length() < 1 || sb.charAt(0) != '[') {
                returnType = new TupleTypeInfo(clazz, types);
            }
        } else {
            returnType = new TupleTypeInfo(clazz, types);
        }
    } else // writable types
    if (writableMatcher.find()) {
        String className = writableMatcher.group(1);
        String fullyQualifiedName = writableMatcher.group(3);
        sb.delete(0, className.length() + 1 + fullyQualifiedName.length() + 1);
        Class<?> clazz = loadClass(fullyQualifiedName);
        returnType = WritableTypeInfo.getWritableTypeInfo((Class) clazz);
    } else // enum types
    if (enumMatcher.find()) {
        String className = enumMatcher.group(1);
        String fullyQualifiedName = enumMatcher.group(3);
        sb.delete(0, className.length() + 1 + fullyQualifiedName.length() + 1);
        Class<?> clazz = loadClass(fullyQualifiedName);
        returnType = new EnumTypeInfo(clazz);
    } else // basic types of classes
    if (basicTypeMatcher.find()) {
        String className = basicTypeMatcher.group(1);
        sb.delete(0, className.length());
        Class<?> clazz;
        // check if fully qualified
        if (className.startsWith(""java.lang"")) {
            clazz = Class.forName(className);
        } else {
            clazz = Class.forName(""java.lang."" + className);
        }
        returnType = BasicTypeInfo.getInfoFor(clazz);
    } else // basic type of primitives
    if (basicType2Matcher.find()) {
        String className = basicType2Matcher.group(1);
        sb.delete(0, className.length());
        Class<?> clazz = null;
        if (className.equals(""int"")) {
            clazz = Integer.class;
        } else if (className.equals(""byte"")) {
            clazz = Byte.class;
        } else if (className.equals(""short"")) {
            clazz = Short.class;
        } else if (className.equals(""char"")) {
            clazz = Character.class;
        } else if (className.equals(""double"")) {
            clazz = Double.class;
        } else if (className.equals(""float"")) {
            clazz = Float.class;
        } else if (className.equals(""long"")) {
            clazz = Long.class;
        } else if (className.equals(""boolean"")) {
            clazz = Boolean.class;
        }
        returnType = BasicTypeInfo.getInfoFor(clazz);
    } else // values
    if (valueTypeMatcher.find()) {
        String className = valueTypeMatcher.group(1);
        sb.delete(0, className.length() + 5);
        Class<?> clazz;
        // check if fully qualified
        if (className.startsWith(VALUE_PACKAGE)) {
            clazz = Class.forName(className + ""Value"");
        } else {
            clazz = Class.forName(VALUE_PACKAGE + ""."" + className + ""Value"");
        }
        returnType = ValueTypeInfo.getValueTypeInfo((Class<Value>) clazz);
    } else // array of basic classes
    if (basicArrayTypeMatcher.find()) {
        String className = basicArrayTypeMatcher.group(1);
        sb.delete(0, className.length() + 2);
        Class<?> clazz;
        if (className.startsWith(""java.lang"")) {
            clazz = Class.forName(""[L"" + className + "";"");
        } else {
            clazz = Class.forName(""[Ljava.lang."" + className + "";"");
        }
        returnType = BasicArrayTypeInfo.getInfoFor(clazz);
    } else // array of primitives
    if (basicArrayType2Matcher.find()) {
        String className = basicArrayType2Matcher.group(1);
        sb.delete(0, className.length() + 2);
        Class<?> clazz = null;
        if (className.equals(""int"")) {
            clazz = int[].class;
        } else if (className.equals(""byte"")) {
            clazz = byte[].class;
        } else if (className.equals(""short"")) {
            clazz = short[].class;
        } else if (className.equals(""char"")) {
            clazz = char[].class;
        } else if (className.equals(""double"")) {
            clazz = double[].class;
        } else if (className.equals(""float"")) {
            clazz = float[].class;
        } else if (className.equals(""long"")) {
            clazz = long[].class;
        } else if (className.equals(""boolean"")) {
            clazz = boolean[].class;
        }
        returnType = PrimitiveArrayTypeInfo.getInfoFor(clazz);
    } else // pojo objects or generic types
    if (pojoGenericMatcher.find()) {
        String fullyQualifiedName = pojoGenericMatcher.group(1);
        sb.delete(0, fullyQualifiedName.length());
        boolean isPojo = pojoGenericMatcher.group(2) != null;
        if (isPojo) {
            sb.deleteCharAt(0);
            Class<?> clazz = loadClass(fullyQualifiedName);
            ArrayList<PojoField> fields = new ArrayList<PojoField>();
            while (sb.charAt(0) != '>') {
                final Matcher fieldMatcher = fieldPattern.matcher(sb);
                if (!fieldMatcher.find()) {
                    throw new IllegalArgumentException(""Field name missing."");
                }
                String fieldName = fieldMatcher.group(1);
                sb.delete(0, fieldName.length() + 1);
                Field field = null;
                try {
                    field = clazz.getDeclaredField(fieldName);
                } catch (Exception e) {
                    throw new IllegalArgumentException(""Field '"" + fieldName + ""'could not be accessed."");
                }
                fields.add(new PojoField(field, parse(sb)));
            }
            returnType = new PojoTypeInfo(clazz, fields);
        } else {
            // custom object array
            if (fullyQualifiedName.endsWith(""[]"")) {
                fullyQualifiedName = fullyQualifiedName.substring(0, fullyQualifiedName.length() - 2);
                returnType = ObjectArrayTypeInfo.getInfoFor(loadClass(""[L"" + fullyQualifiedName + "";""));
            } else {
                returnType = new GenericTypeInfo(loadClass(fullyQualifiedName));
            }
        }
    }
    if (returnType == null) {
        throw new IllegalArgumentException(""Error at '"" + infoString + ""'"");
    } else {
        // remove possible ','
        if (sb.length() > 0 && sb.charAt(0) == ',') {
            sb.deleteCharAt(0);
        }
        return returnType;
    }
}",,"@SuppressWarnings({ ""rawtypes"", ""unchecked"" })
private static TypeInformation<?> parse(StringBuilder sb) throws ClassNotFoundException {
    String infoString = sb.toString();
    final Matcher tupleMatcher = tuplePattern.matcher(infoString);
    final Matcher writableMatcher = writablePattern.matcher(infoString);
    final Matcher enumMatcher = enumPattern.matcher(infoString);
    final Matcher basicTypeMatcher = basicTypePattern.matcher(infoString);
    final Matcher basicType2Matcher = basicType2Pattern.matcher(infoString);
    final Matcher valueTypeMatcher = valueTypePattern.matcher(infoString);
    final Matcher basicArrayTypeMatcher = basicArrayTypePattern.matcher(infoString);
    final Matcher basicArrayType2Matcher = basicArrayType2Pattern.matcher(infoString);
    final Matcher pojoGenericMatcher = pojoGenericObjectPattern.matcher(infoString);
    if (infoString.length() == 0) {
        return null;
    }
    TypeInformation<?> returnType = null;
        if (tupleMatcher.find()) {
        String className = tupleMatcher.group(1);
        sb.delete(0, className.length() + 1);
        int arity = Integer.parseInt(className.replaceAll(""\\D"", """"));
        Class<?> clazz;
                if (className.startsWith(TUPLE_PACKAGE)) {
            clazz = Class.forName(className);
        } else {
            clazz = Class.forName(TUPLE_PACKAGE + ""."" + className);
        }
        TypeInformation<?>[] types = new TypeInformation<?>[arity];
        for (int i = 0; i < arity; i++) {
            types[i] = parse(sb);
            if (types[i] == null) {
                throw new IllegalArgumentException(""Tuple arity does not match given parameters."");
            }
        }
        if (sb.charAt(0) != '>') {
            throw new IllegalArgumentException(""Tuple arity does not match given parameters."");
        }
                sb.deleteCharAt(0);
                if (sb.length() > 0) {
            if (sb.length() >= 2 && sb.charAt(0) == '[' && sb.charAt(1) == ']') {
                Class<?> arrayClazz;
                                if (className.startsWith(TUPLE_PACKAGE)) {
                    arrayClazz = Class.forName(""[L"" + className + "";"");
                } else {
                    arrayClazz = Class.forName(""[L"" + TUPLE_PACKAGE + ""."" + className + "";"");
                }
                returnType = ObjectArrayTypeInfo.getInfoFor(arrayClazz, new TupleTypeInfo(clazz, types));
            } else if (sb.length() < 1 || sb.charAt(0) != '[') {
                returnType = new TupleTypeInfo(clazz, types);
            }
        } else {
            returnType = new TupleTypeInfo(clazz, types);
        }
    } else     if (writableMatcher.find()) {
        String className = writableMatcher.group(1);
        String fullyQualifiedName = writableMatcher.group(3);
        sb.delete(0, className.length() + 1 + fullyQualifiedName.length() + 1);
        Class<?> clazz = loadClass(fullyQualifiedName);
        returnType = WritableTypeInfo.getWritableTypeInfo((Class) clazz);
    } else     if (enumMatcher.find()) {
        String className = enumMatcher.group(1);
        String fullyQualifiedName = enumMatcher.group(3);
        sb.delete(0, className.length() + 1 + fullyQualifiedName.length() + 1);
        Class<?> clazz = loadClass(fullyQualifiedName);
        returnType = new EnumTypeInfo(clazz);
    } else     if (basicTypeMatcher.find()) {
        String className = basicTypeMatcher.group(1);
        sb.delete(0, className.length());
        Class<?> clazz;
                if (className.startsWith(""java.lang"")) {
            clazz = Class.forName(className);
        } else {
            clazz = Class.forName(""java.lang."" + className);
        }
        returnType = BasicTypeInfo.getInfoFor(clazz);
    } else     if (basicType2Matcher.find()) {
        String className = basicType2Matcher.group(1);
        sb.delete(0, className.length());
        Class<?> clazz = null;
        if (className.equals(""int"")) {
            clazz = Integer.class;
        } else if (className.equals(""byte"")) {
            clazz = Byte.class;
        } else if (className.equals(""short"")) {
            clazz = Short.class;
        } else if (className.equals(""char"")) {
            clazz = Character.class;
        } else if (className.equals(""double"")) {
            clazz = Double.class;
        } else if (className.equals(""float"")) {
            clazz = Float.class;
        } else if (className.equals(""long"")) {
            clazz = Long.class;
        } else if (className.equals(""boolean"")) {
            clazz = Boolean.class;
        }
        returnType = BasicTypeInfo.getInfoFor(clazz);
    } else     if (valueTypeMatcher.find()) {
        String className = valueTypeMatcher.group(1);
        sb.delete(0, className.length() + 5);
        Class<?> clazz;
                if (className.startsWith(VALUE_PACKAGE)) {
            clazz = Class.forName(className + ""Value"");
        } else {
            clazz = Class.forName(VALUE_PACKAGE + ""."" + className + ""Value"");
        }
        returnType = ValueTypeInfo.getValueTypeInfo((Class<Value>) clazz);
    } else     if (basicArrayTypeMatcher.find()) {
        String className = basicArrayTypeMatcher.group(1);
        sb.delete(0, className.length() + 2);
        Class<?> clazz;
        if (className.startsWith(""java.lang"")) {
            clazz = Class.forName(""[L"" + className + "";"");
        } else {
            clazz = Class.forName(""[Ljava.lang."" + className + "";"");
        }
        returnType = BasicArrayTypeInfo.getInfoFor(clazz);
    } else     if (basicArrayType2Matcher.find()) {
        String className = basicArrayType2Matcher.group(1);
        sb.delete(0, className.length() + 2);
        Class<?> clazz = null;
        if (className.equals(""int"")) {
            clazz = int[].class;
        } else if (className.equals(""byte"")) {
            clazz = byte[].class;
        } else if (className.equals(""short"")) {
            clazz = short[].class;
        } else if (className.equals(""char"")) {
            clazz = char[].class;
        } else if (className.equals(""double"")) {
            clazz = double[].class;
        } else if (className.equals(""float"")) {
            clazz = float[].class;
        } else if (className.equals(""long"")) {
            clazz = long[].class;
        } else if (className.equals(""boolean"")) {
            clazz = boolean[].class;
        }
        returnType = PrimitiveArrayTypeInfo.getInfoFor(clazz);
    } else     if (pojoGenericMatcher.find()) {
        String fullyQualifiedName = pojoGenericMatcher.group(1);
        sb.delete(0, fullyQualifiedName.length());
        boolean isPojo = pojoGenericMatcher.group(2) != null;
        if (isPojo) {
            sb.deleteCharAt(0);
            Class<?> clazz = loadClass(fullyQualifiedName);
            ArrayList<PojoField> fields = new ArrayList<PojoField>();
            while (sb.charAt(0) != '>') {
                final Matcher fieldMatcher = fieldPattern.matcher(sb);
                if (!fieldMatcher.find()) {
                    throw new IllegalArgumentException(""Field name missing."");
                }
                String fieldName = fieldMatcher.group(1);
                sb.delete(0, fieldName.length() + 1);
                Field field = null;
                try {
                    field = clazz.getDeclaredField(fieldName);
                } catch (Exception e) {
                    throw new IllegalArgumentException(""Field '"" + fieldName + ""'could not be accessed."");
                }
                fields.add(new PojoField(field, parse(sb)));
            }
            returnType = new PojoTypeInfo(clazz, fields);
        } else {
                        if (fullyQualifiedName.endsWith(""[]"")) {
                fullyQualifiedName = fullyQualifiedName.substring(0, fullyQualifiedName.length() - 2);
                returnType = ObjectArrayTypeInfo.getInfoFor(loadClass(""[L"" + fullyQualifiedName + "";""));
            } else {
                returnType = new GenericTypeInfo(loadClass(fullyQualifiedName));
            }
        }
    }
    if (returnType == null) {
        throw new IllegalArgumentException(""Error at '"" + infoString + ""'"");
    } else {
                if (sb.length() > 0 && sb.charAt(0) == ',') {
            sb.deleteCharAt(0);
        }
        return returnType;
    }
}",7.909090909090909,0.5215311004784688,9.2,7.0,6.0,4.982142857142857,-1.982100070472163,9.75,-0.02631578947368421,60.16677673853033
Lang,38,1,"/**
 * <p>Formats a <code>Calendar</code> object into the
 * supplied <code>StringBuffer</code>.</p>
 *
 * @param calendar  the calendar to format
 * @param buf  the buffer to format into
 * @return the specified string buffer
 */
public StringBuffer format(Calendar calendar, StringBuffer buf) {
    if (mTimeZoneForced) {
        calendar = (Calendar) calendar.clone();
        calendar.setTimeZone(mTimeZone);
    }
    return applyRules(calendar, buf);
}","/**
 * <p>Formats a <code>Calendar</code> object into the
 * supplied <code>StringBuffer</code>.</p>
 *
 * @param calendar  the calendar to format
 * @param buf  the buffer to format into
 * @return the specified string buffer
 */
","public StringBuffer format(Calendar calendar, StringBuffer buf) {
    if (mTimeZoneForced) {
        calendar = (Calendar) calendar.clone();
        calendar.setTimeZone(mTimeZone);
    }
    return applyRules(calendar, buf);
}",-0.3181818181818182,0.01435406698564584,-0.4,-0.5,-0.25,-0.3650793650793651,0.457364341085271,-0.25,0.631578947368421,-0.16279340490885932
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1674_073b814c,1,"@Override
public Status getStatus() {
    if (nodeBuilder.isNew()) {
        return NEW;
    } else if (nodeBuilder.isModified()) {
        return MODIFIED;
    } else {
        return UNCHANGED;
    }
}",,"@Override
public Status getStatus() {
    if (nodeBuilder.isNew()) {
        return NEW;
    } else if (nodeBuilder.isModified()) {
        return MODIFIED;
    } else {
        return UNCHANGED;
    }
}",-0.18181818181818182,0.05263157894736836,-0.2,0.0,-0.08333333333333333,-0.3650793650793651,0.3792811839323466,-0.3333333333333333,1.0526315789473684,-0.16279340490885932
Math,75,3,"// -------------------------------------------------------------
/**
 * Returns the percentage of values that are equal to v
 * (as a proportion between 0 and 1).
 * <p>
 * Returns <code>Double.NaN</code> if no values have been added.</p>
 *
 * @param v the value to lookup
 * @return the proportion of values equal to v
 * @deprecated replaced by {@link #getPct(Comparable)} as of 2.0
 */
@Deprecated
public double getPct(Object v) {
    return getCumPct((Comparable<?>) v);
}","/**
 * Returns the percentage of values that are equal to v
 * (as a proportion between 0 and 1).
 * <p>
 * Returns <code>Double.NaN</code> if no values have been added.</p>
 *
 * @param v the value to lookup
 * @return the proportion of values equal to v
 * @deprecated replaced by {@link #getPct(Comparable)} as of 2.0
 */
","@Deprecated
public double getPct(Object v) {
    return getCumPct((Comparable<?>) v);
}",-0.45454545454545453,-0.6028708133971293,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.8818886539816769,-0.4166666666666667,2.5789473684210527,-0.16279340490885932
Math,38,1,"// altmov
// ----------------------------------------------------------------------------------------
/**
 *     SUBROUTINE PRELIM sets the elements of XBASE, XPT, FVAL, GOPT, HQ, PQ,
 *     BMAT and ZMAT for the first iteration, and it maintains the values of
 *     NF and KOPT. The vector X is also changed by PRELIM.
 *
 *     The arguments N, NPT, X, XL, XU, RHOBEG, IPRINT and MAXFUN are the
 *       same as the corresponding arguments in SUBROUTINE BOBYQA.
 *     The arguments XBASE, XPT, FVAL, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU
 *       are the same as the corresponding arguments in BOBYQB, the elements
 *       of SL and SU being set in BOBYQA.
 *     GOPT is usually the gradient of the quadratic model at XOPT+XBASE, but
 *       it is set by PRELIM to the gradient of the quadratic model at XBASE.
 *       If XOPT is nonzero, BOBYQB will change it to its usual value later.
 *     NF is maintaned as the number of calls of CALFUN so far.
 *     KOPT will be such that the least calculated value of F so far is at
 *       the point XPT(KOPT,.)+XBASE in the space of the variables.
 *
 * @param lowerBound Lower bounds.
 * @param upperBound Upper bounds.
 */
private void prelim(double[] lowerBound, double[] upperBound) {
    // XXX
    printMethod();
    final int n = currentBest.getDimension();
    final int npt = numberOfInterpolationPoints;
    final int ndim = bMatrix.getRowDimension();
    final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;
    final double recip = 1d / rhosq;
    final int np = n + 1;
    for (int j = 0; j < n; j++) {
        originShift.setEntry(j, currentBest.getEntry(j));
        for (int k = 0; k < npt; k++) {
            interpolationPoints.setEntry(k, j, ZERO);
        }
        for (int i = 0; i < ndim; i++) {
            bMatrix.setEntry(i, j, ZERO);
        }
    }
    for (int i = 0, max = n * np / 2; i < max; i++) {
        modelSecondDerivativesValues.setEntry(i, ZERO);
    }
    for (int k = 0; k < npt; k++) {
        modelSecondDerivativesParameters.setEntry(k, ZERO);
        for (int j = 0, max = npt - np; j < max; j++) {
            zMatrix.setEntry(k, j, ZERO);
        }
    }
    // Begin the initialization procedure. NF becomes one more than the number
    // of function values so far. The coordinates of the displacement of the
    // next initial interpolation point from XBASE are set in XPT(NF+1,.).
    int ipt = 0;
    int jpt = 0;
    double fbeg = Double.NaN;
    do {
        final int nfm = getEvaluations();
        final int nfx = nfm - n;
        final int nfmm = nfm - 1;
        final int nfxm = nfx - 1;
        double stepa = 0;
        double stepb = 0;
        if (nfm <= 2 * n) {
            if (nfm >= 1 && nfm <= n) {
                stepa = initialTrustRegionRadius;
                if (upperDifference.getEntry(nfmm) == ZERO) {
                    stepa = -stepa;
                    // XXX
                    throw new PathIsExploredException();
                }
                interpolationPoints.setEntry(nfm, nfmm, stepa);
            } else if (nfm > n) {
                stepa = interpolationPoints.getEntry(nfx, nfxm);
                stepb = -initialTrustRegionRadius;
                if (lowerDifference.getEntry(nfxm) == ZERO) {
                    stepb = Math.min(TWO * initialTrustRegionRadius, upperDifference.getEntry(nfxm));
                    // XXX
                    throw new PathIsExploredException();
                }
                if (upperDifference.getEntry(nfxm) == ZERO) {
                    stepb = Math.max(-TWO * initialTrustRegionRadius, lowerDifference.getEntry(nfxm));
                    // XXX
                    throw new PathIsExploredException();
                }
                interpolationPoints.setEntry(nfm, nfxm, stepb);
            }
        } else {
            final int tmp1 = (nfm - np) / n;
            jpt = nfm - tmp1 * n - n;
            ipt = jpt + tmp1;
            if (ipt > n) {
                final int tmp2 = jpt;
                jpt = ipt - n;
                ipt = tmp2;
                // XXX
                throw new PathIsExploredException();
            }
            final int iptMinus1 = ipt;
            final int jptMinus1 = jpt;
            interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));
            interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));
        }
        for (int j = 0; j < n; j++) {
            currentBest.setEntry(j, Math.min(Math.max(lowerBound[j], originShift.getEntry(j) + interpolationPoints.getEntry(nfm, j)), upperBound[j]));
            if (interpolationPoints.getEntry(nfm, j) == lowerDifference.getEntry(j)) {
                currentBest.setEntry(j, lowerBound[j]);
            }
            if (interpolationPoints.getEntry(nfm, j) == upperDifference.getEntry(j)) {
                currentBest.setEntry(j, upperBound[j]);
            }
        }
        final double objectiveValue = computeObjectiveValue(currentBest.toArray());
        final double f = isMinimize ? objectiveValue : -objectiveValue;
        // nfm + 1
        final int numEval = getEvaluations();
        fAtInterpolationPoints.setEntry(nfm, f);
        if (numEval == 1) {
            fbeg = f;
            trustRegionCenterInterpolationPointIndex = 0;
        } else if (f < fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex)) {
            trustRegionCenterInterpolationPointIndex = nfm;
        }
        if (numEval <= 2 * n + 1) {
            if (numEval >= 2 && numEval <= n + 1) {
                gradientAtTrustRegionCenter.setEntry(nfmm, (f - fbeg) / stepa);
                if (npt < numEval + n) {
                    final double oneOverStepA = ONE / stepa;
                    bMatrix.setEntry(0, nfmm, -oneOverStepA);
                    bMatrix.setEntry(nfm, nfmm, oneOverStepA);
                    bMatrix.setEntry(npt + nfmm, nfmm, -HALF * rhosq);
                    // XXX
                    throw new PathIsExploredException();
                }
            } else if (numEval >= n + 2) {
                final int ih = nfx * (nfx + 1) / 2 - 1;
                final double tmp = (f - fbeg) / stepb;
                final double diff = stepb - stepa;
                modelSecondDerivativesValues.setEntry(ih, TWO * (tmp - gradientAtTrustRegionCenter.getEntry(nfxm)) / diff);
                gradientAtTrustRegionCenter.setEntry(nfxm, (gradientAtTrustRegionCenter.getEntry(nfxm) * stepb - tmp * stepa) / diff);
                if (stepa * stepb < ZERO) {
                    if (f < fAtInterpolationPoints.getEntry(nfm - n)) {
                        fAtInterpolationPoints.setEntry(nfm, fAtInterpolationPoints.getEntry(nfm - n));
                        fAtInterpolationPoints.setEntry(nfm - n, f);
                        if (trustRegionCenterInterpolationPointIndex == nfm) {
                            trustRegionCenterInterpolationPointIndex = nfm - n;
                        }
                        interpolationPoints.setEntry(nfm - n, nfxm, stepb);
                        interpolationPoints.setEntry(nfm, nfxm, stepa);
                    }
                }
                bMatrix.setEntry(0, nfxm, -(stepa + stepb) / (stepa * stepb));
                bMatrix.setEntry(nfm, nfxm, -HALF / interpolationPoints.getEntry(nfm - n, nfxm));
                bMatrix.setEntry(nfm - n, nfxm, -bMatrix.getEntry(0, nfxm) - bMatrix.getEntry(nfm, nfxm));
                zMatrix.setEntry(0, nfxm, Math.sqrt(TWO) / (stepa * stepb));
                zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) / rhosq);
                // zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) * recip); // XXX ""testAckley"" and ""testDiffPow"" fail.
                zMatrix.setEntry(nfm - n, nfxm, -zMatrix.getEntry(0, nfxm) - zMatrix.getEntry(nfm, nfxm));
            }
        // Set the off-diagonal second derivatives of the Lagrange functions and
        // the initial quadratic model.
        } else {
            zMatrix.setEntry(0, nfxm, recip);
            zMatrix.setEntry(nfm, nfxm, recip);
            zMatrix.setEntry(ipt, nfxm, -recip);
            zMatrix.setEntry(jpt, nfxm, -recip);
            final int ih = ipt * (ipt - 1) / 2 + jpt - 1;
            final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);
            modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);
            // XXX
            throw new PathIsExploredException();
        }
    } while (getEvaluations() < npt);
}","/**
 *     SUBROUTINE PRELIM sets the elements of XBASE, XPT, FVAL, GOPT, HQ, PQ,
 *     BMAT and ZMAT for the first iteration, and it maintains the values of
 *     NF and KOPT. The vector X is also changed by PRELIM.
 *
 *     The arguments N, NPT, X, XL, XU, RHOBEG, IPRINT and MAXFUN are the
 *       same as the corresponding arguments in SUBROUTINE BOBYQA.
 *     The arguments XBASE, XPT, FVAL, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU
 *       are the same as the corresponding arguments in BOBYQB, the elements
 *       of SL and SU being set in BOBYQA.
 *     GOPT is usually the gradient of the quadratic model at XOPT+XBASE, but
 *       it is set by PRELIM to the gradient of the quadratic model at XBASE.
 *       If XOPT is nonzero, BOBYQB will change it to its usual value later.
 *     NF is maintaned as the number of calls of CALFUN so far.
 *     KOPT will be such that the least calculated value of F so far is at
 *       the point XPT(KOPT,.)+XBASE in the space of the variables.
 *
 * @param lowerBound Lower bounds.
 * @param upperBound Upper bounds.
 */
","private void prelim(double[] lowerBound, double[] upperBound) {
        printMethod();
    final int n = currentBest.getDimension();
    final int npt = numberOfInterpolationPoints;
    final int ndim = bMatrix.getRowDimension();
    final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;
    final double recip = 1d / rhosq;
    final int np = n + 1;
    for (int j = 0; j < n; j++) {
        originShift.setEntry(j, currentBest.getEntry(j));
        for (int k = 0; k < npt; k++) {
            interpolationPoints.setEntry(k, j, ZERO);
        }
        for (int i = 0; i < ndim; i++) {
            bMatrix.setEntry(i, j, ZERO);
        }
    }
    for (int i = 0, max = n * np / 2; i < max; i++) {
        modelSecondDerivativesValues.setEntry(i, ZERO);
    }
    for (int k = 0; k < npt; k++) {
        modelSecondDerivativesParameters.setEntry(k, ZERO);
        for (int j = 0, max = npt - np; j < max; j++) {
            zMatrix.setEntry(k, j, ZERO);
        }
    }
                int ipt = 0;
    int jpt = 0;
    double fbeg = Double.NaN;
    do {
        final int nfm = getEvaluations();
        final int nfx = nfm - n;
        final int nfmm = nfm - 1;
        final int nfxm = nfx - 1;
        double stepa = 0;
        double stepb = 0;
        if (nfm <= 2 * n) {
            if (nfm >= 1 && nfm <= n) {
                stepa = initialTrustRegionRadius;
                if (upperDifference.getEntry(nfmm) == ZERO) {
                    stepa = -stepa;
                                        throw new PathIsExploredException();
                }
                interpolationPoints.setEntry(nfm, nfmm, stepa);
            } else if (nfm > n) {
                stepa = interpolationPoints.getEntry(nfx, nfxm);
                stepb = -initialTrustRegionRadius;
                if (lowerDifference.getEntry(nfxm) == ZERO) {
                    stepb = Math.min(TWO * initialTrustRegionRadius, upperDifference.getEntry(nfxm));
                                        throw new PathIsExploredException();
                }
                if (upperDifference.getEntry(nfxm) == ZERO) {
                    stepb = Math.max(-TWO * initialTrustRegionRadius, lowerDifference.getEntry(nfxm));
                                        throw new PathIsExploredException();
                }
                interpolationPoints.setEntry(nfm, nfxm, stepb);
            }
        } else {
            final int tmp1 = (nfm - np) / n;
            jpt = nfm - tmp1 * n - n;
            ipt = jpt + tmp1;
            if (ipt > n) {
                final int tmp2 = jpt;
                jpt = ipt - n;
                ipt = tmp2;
                                throw new PathIsExploredException();
            }
            final int iptMinus1 = ipt;
            final int jptMinus1 = jpt;
            interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));
            interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));
        }
        for (int j = 0; j < n; j++) {
            currentBest.setEntry(j, Math.min(Math.max(lowerBound[j], originShift.getEntry(j) + interpolationPoints.getEntry(nfm, j)), upperBound[j]));
            if (interpolationPoints.getEntry(nfm, j) == lowerDifference.getEntry(j)) {
                currentBest.setEntry(j, lowerBound[j]);
            }
            if (interpolationPoints.getEntry(nfm, j) == upperDifference.getEntry(j)) {
                currentBest.setEntry(j, upperBound[j]);
            }
        }
        final double objectiveValue = computeObjectiveValue(currentBest.toArray());
        final double f = isMinimize ? objectiveValue : -objectiveValue;
                final int numEval = getEvaluations();
        fAtInterpolationPoints.setEntry(nfm, f);
        if (numEval == 1) {
            fbeg = f;
            trustRegionCenterInterpolationPointIndex = 0;
        } else if (f < fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex)) {
            trustRegionCenterInterpolationPointIndex = nfm;
        }
        if (numEval <= 2 * n + 1) {
            if (numEval >= 2 && numEval <= n + 1) {
                gradientAtTrustRegionCenter.setEntry(nfmm, (f - fbeg) / stepa);
                if (npt < numEval + n) {
                    final double oneOverStepA = ONE / stepa;
                    bMatrix.setEntry(0, nfmm, -oneOverStepA);
                    bMatrix.setEntry(nfm, nfmm, oneOverStepA);
                    bMatrix.setEntry(npt + nfmm, nfmm, -HALF * rhosq);
                                        throw new PathIsExploredException();
                }
            } else if (numEval >= n + 2) {
                final int ih = nfx * (nfx + 1) / 2 - 1;
                final double tmp = (f - fbeg) / stepb;
                final double diff = stepb - stepa;
                modelSecondDerivativesValues.setEntry(ih, TWO * (tmp - gradientAtTrustRegionCenter.getEntry(nfxm)) / diff);
                gradientAtTrustRegionCenter.setEntry(nfxm, (gradientAtTrustRegionCenter.getEntry(nfxm) * stepb - tmp * stepa) / diff);
                if (stepa * stepb < ZERO) {
                    if (f < fAtInterpolationPoints.getEntry(nfm - n)) {
                        fAtInterpolationPoints.setEntry(nfm, fAtInterpolationPoints.getEntry(nfm - n));
                        fAtInterpolationPoints.setEntry(nfm - n, f);
                        if (trustRegionCenterInterpolationPointIndex == nfm) {
                            trustRegionCenterInterpolationPointIndex = nfm - n;
                        }
                        interpolationPoints.setEntry(nfm - n, nfxm, stepb);
                        interpolationPoints.setEntry(nfm, nfxm, stepa);
                    }
                }
                bMatrix.setEntry(0, nfxm, -(stepa + stepb) / (stepa * stepb));
                bMatrix.setEntry(nfm, nfxm, -HALF / interpolationPoints.getEntry(nfm - n, nfxm));
                bMatrix.setEntry(nfm - n, nfxm, -bMatrix.getEntry(0, nfxm) - bMatrix.getEntry(nfm, nfxm));
                zMatrix.setEntry(0, nfxm, Math.sqrt(TWO) / (stepa * stepb));
                zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) / rhosq);
                                zMatrix.setEntry(nfm - n, nfxm, -zMatrix.getEntry(0, nfxm) - zMatrix.getEntry(nfm, nfxm));
            }
                        } else {
            zMatrix.setEntry(0, nfxm, recip);
            zMatrix.setEntry(nfm, nfxm, recip);
            zMatrix.setEntry(ipt, nfxm, -recip);
            zMatrix.setEntry(jpt, nfxm, -recip);
            final int ih = ipt * (ipt - 1) / 2 + jpt - 1;
            final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);
            modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);
                        throw new PathIsExploredException();
        }
    } while (getEvaluations() < npt);
}",5.590909090909091,1.2775119617224882,6.0,2.5,4.166666666666667,8.186507936507937,-1.7176885130373498,6.0,-0.02631578947368421,86.35383897235523
wicket,remotes/origin/bugs-dot-jar_WICKET-4520_b91154ea,1,"/**
 *  Initialize Wicket's MarkupParser with all necessary markup filters. You may subclass this
 *  method, to add your own filters to the list.
 *
 *  @param markup
 *  @return The list of markup filter
 */
@Override
protected MarkupFilterList initializeMarkupFilters(final Markup markup) {
    // MarkupFilterList is a simple extension of ArrayList providing few additional helpers
    final MarkupFilterList filters = new MarkupFilterList();
    MarkupResourceStream markupResourceStream = markup.getMarkupResourceStream();
    filters.add(new WicketTagIdentifier(markupResourceStream));
    filters.add(new HtmlHandler());
    filters.add(new WicketRemoveTagHandler());
    filters.add(new WicketLinkTagHandler());
    filters.add(new AutoLabelTagHandler());
    filters.add(new WicketNamespaceHandler(markupResourceStream));
    // Provided the wicket component requesting the markup is known ...
    if ((markupResourceStream != null) && (markupResourceStream.getResource() != null)) {
        final ContainerInfo containerInfo = markupResourceStream.getContainerInfo();
        if (containerInfo != null) {
            filters.add(new WicketMessageTagHandler(markupResourceStream));
            // Pages require additional handlers
            if (Page.class.isAssignableFrom(containerInfo.getContainerClass())) {
                filters.add(new HtmlHeaderSectionHandler(markup));
            }
            filters.add(new HeadForceTagIdHandler(containerInfo.getContainerClass()));
        }
    }
    filters.add(new OpenCloseTagExpander());
    filters.add(new RelativePathPrefixHandler(markupResourceStream));
    filters.add(new EnclosureHandler());
    filters.add(new InlineEnclosureHandler());
    // Append it. See WICKET-4390
    filters.add(new StyleAndScriptIdentifier(), StyleAndScriptIdentifier.class);
    filters.add(new ConditionalCommentFilter());
    return filters;
}","/**
 *  Initialize Wicket's MarkupParser with all necessary markup filters. You may subclass this
 *  method, to add your own filters to the list.
 *
 *  @param markup
 *  @return The list of markup filter
 */
","@Override
protected MarkupFilterList initializeMarkupFilters(final Markup markup) {
        final MarkupFilterList filters = new MarkupFilterList();
    MarkupResourceStream markupResourceStream = markup.getMarkupResourceStream();
    filters.add(new WicketTagIdentifier(markupResourceStream));
    filters.add(new HtmlHandler());
    filters.add(new WicketRemoveTagHandler());
    filters.add(new WicketLinkTagHandler());
    filters.add(new AutoLabelTagHandler());
    filters.add(new WicketNamespaceHandler(markupResourceStream));
        if ((markupResourceStream != null) && (markupResourceStream.getResource() != null)) {
        final ContainerInfo containerInfo = markupResourceStream.getContainerInfo();
        if (containerInfo != null) {
            filters.add(new WicketMessageTagHandler(markupResourceStream));
                        if (Page.class.isAssignableFrom(containerInfo.getContainerClass())) {
                filters.add(new HtmlHeaderSectionHandler(markup));
            }
            filters.add(new HeadForceTagIdHandler(containerInfo.getContainerClass()));
        }
    }
    filters.add(new OpenCloseTagExpander());
    filters.add(new RelativePathPrefixHandler(markupResourceStream));
    filters.add(new EnclosureHandler());
    filters.add(new InlineEnclosureHandler());
        filters.add(new StyleAndScriptIdentifier(), StyleAndScriptIdentifier.class);
    filters.add(new ConditionalCommentFilter());
    return filters;
}",0.6363636363636364,0.4354066985645932,0.0,0.5,0.3333333333333333,0.11309523809523811,-0.4700493305144466,1.25,-0.02631578947368421,0.35273018562380776
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-412_be2fdba7,1,"public AssignmentStats importFiles(List<String> files, Path failureDir) throws IOException, AccumuloException, AccumuloSecurityException, ThriftTableOperationException {
    int numThreads = acuConf.getCount(Property.TSERV_BULK_PROCESS_THREADS);
    int numAssignThreads = acuConf.getCount(Property.TSERV_BULK_ASSIGNMENT_THREADS);
    timer = new StopWatch<Timers>(Timers.class);
    timer.start(Timers.TOTAL);
    Configuration conf = CachedConfiguration.getInstance();
    final FileSystem fs = FileSystem.get(conf);
    Set<Path> paths = new HashSet<Path>();
    for (String file : files) {
        paths.add(new Path(file));
    }
    AssignmentStats assignmentStats = new AssignmentStats(paths.size());
    final Map<Path, List<KeyExtent>> completeFailures = Collections.synchronizedSortedMap(new TreeMap<Path, List<KeyExtent>>());
    if (!fs.exists(failureDir)) {
        log.error(failureDir + "" does not exist"");
        throw new RuntimeException(""Directory does not exist "" + failureDir);
    }
    ClientService.Iface client = null;
    final TabletLocator locator = TabletLocator.getInstance(instance, credentials, new Text(tableId));
    try {
        final Map<Path, List<TabletLocation>> assignments = Collections.synchronizedSortedMap(new TreeMap<Path, List<TabletLocation>>());
        timer.start(Timers.EXAMINE_MAP_FILES);
        ExecutorService threadPool = Executors.newFixedThreadPool(numThreads);
        for (Path path : paths) {
            final Path mapFile = path;
            Runnable getAssignments = new Runnable() {

                public void run() {
                    List<TabletLocation> tabletsToAssignMapFileTo = Collections.emptyList();
                    try {
                        tabletsToAssignMapFileTo = findOverlappingTablets(instance.getConfiguration(), fs, locator, mapFile);
                    } catch (Exception ex) {
                        log.warn(""Unable to find tablets that overlap file "" + mapFile.toString());
                    }
                    if (tabletsToAssignMapFileTo.size() == 0) {
                        List<KeyExtent> empty = Collections.emptyList();
                        completeFailures.put(mapFile, empty);
                    } else
                        assignments.put(mapFile, tabletsToAssignMapFileTo);
                }
            };
            threadPool.submit(new TraceRunnable(new LoggingRunnable(log, getAssignments)));
        }
        threadPool.shutdown();
        while (!threadPool.isTerminated()) {
            try {
                threadPool.awaitTermination(60, TimeUnit.SECONDS);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
        timer.stop(Timers.EXAMINE_MAP_FILES);
        assignmentStats.attemptingAssignments(assignments);
        Map<Path, List<KeyExtent>> assignmentFailures = assignMapFiles(acuConf, instance, conf, credentials, fs, tableId, assignments, paths, numAssignThreads, numThreads);
        assignmentStats.assignmentsFailed(assignmentFailures);
        Map<Path, Integer> failureCount = new TreeMap<Path, Integer>();
        for (Entry<Path, List<KeyExtent>> entry : assignmentFailures.entrySet()) failureCount.put(entry.getKey(), 1);
        while (assignmentFailures.size() > 0) {
            locator.invalidateCache();
            // assumption about assignment failures is that it caused by a split
            // happening or a missing location
            // 
            // for splits we need to find children key extents that cover the
            // same key range and are contiguous (no holes, no overlap)
            timer.start(Timers.SLEEP);
            UtilWaitThread.sleep(4000);
            timer.stop(Timers.SLEEP);
            log.debug(""Trying to assign "" + assignmentFailures.size() + "" map files that previously failed on some key extents"");
            assignments.clear();
            // assign to
            for (Entry<Path, List<KeyExtent>> entry : assignmentFailures.entrySet()) {
                Iterator<KeyExtent> keListIter = entry.getValue().iterator();
                List<TabletLocation> tabletsToAssignMapFileTo = new ArrayList<TabletLocation>();
                while (keListIter.hasNext()) {
                    KeyExtent ke = keListIter.next();
                    try {
                        timer.start(Timers.QUERY_METADATA);
                        tabletsToAssignMapFileTo.addAll(findOverlappingTablets(instance.getConfiguration(), fs, locator, entry.getKey(), ke));
                        timer.stop(Timers.QUERY_METADATA);
                        keListIter.remove();
                    } catch (Exception ex) {
                        log.warn(""Exception finding overlapping tablets, will retry tablet "" + ke);
                    }
                }
                if (tabletsToAssignMapFileTo.size() > 0)
                    assignments.put(entry.getKey(), tabletsToAssignMapFileTo);
            }
            assignmentStats.attemptingAssignments(assignments);
            Map<Path, List<KeyExtent>> assignmentFailures2 = assignMapFiles(acuConf, instance, conf, credentials, fs, tableId, assignments, paths, numAssignThreads, numThreads);
            assignmentStats.assignmentsFailed(assignmentFailures2);
            // merge assignmentFailures2 into assignmentFailures
            for (Entry<Path, List<KeyExtent>> entry : assignmentFailures2.entrySet()) {
                assignmentFailures.get(entry.getKey()).addAll(entry.getValue());
                Integer fc = failureCount.get(entry.getKey());
                if (fc == null)
                    fc = 0;
                failureCount.put(entry.getKey(), fc + 1);
            }
            // remove map files that have no more key extents to assign
            Iterator<Entry<Path, List<KeyExtent>>> afIter = assignmentFailures.entrySet().iterator();
            while (afIter.hasNext()) {
                Entry<Path, List<KeyExtent>> entry = afIter.next();
                if (entry.getValue().size() == 0)
                    afIter.remove();
            }
            Set<Entry<Path, Integer>> failureIter = failureCount.entrySet();
            for (Entry<Path, Integer> entry : failureIter) {
                if (entry.getValue() > acuConf.getCount(Property.TSERV_BULK_RETRY) && assignmentFailures.get(entry.getKey()) != null) {
                    log.error(""Map file "" + entry.getKey() + "" failed more than three times, giving up."");
                    completeFailures.put(entry.getKey(), assignmentFailures.get(entry.getKey()));
                    assignmentFailures.remove(entry.getKey());
                }
            }
        }
        assignmentStats.assignmentsAbandoned(completeFailures);
        Set<Path> failedFailures = processFailures(conf, fs, failureDir, completeFailures);
        assignmentStats.unrecoveredMapFiles(failedFailures);
        timer.stop(Timers.TOTAL);
        printReport();
        return assignmentStats;
    } finally {
        if (client != null)
            ServerClient.close(client);
        locator.invalidateCache();
    }
}",,"public AssignmentStats importFiles(List<String> files, Path failureDir) throws IOException, AccumuloException, AccumuloSecurityException, ThriftTableOperationException {
    int numThreads = acuConf.getCount(Property.TSERV_BULK_PROCESS_THREADS);
    int numAssignThreads = acuConf.getCount(Property.TSERV_BULK_ASSIGNMENT_THREADS);
    timer = new StopWatch<Timers>(Timers.class);
    timer.start(Timers.TOTAL);
    Configuration conf = CachedConfiguration.getInstance();
    final FileSystem fs = FileSystem.get(conf);
    Set<Path> paths = new HashSet<Path>();
    for (String file : files) {
        paths.add(new Path(file));
    }
    AssignmentStats assignmentStats = new AssignmentStats(paths.size());
    final Map<Path, List<KeyExtent>> completeFailures = Collections.synchronizedSortedMap(new TreeMap<Path, List<KeyExtent>>());
    if (!fs.exists(failureDir)) {
        log.error(failureDir + "" does not exist"");
        throw new RuntimeException(""Directory does not exist "" + failureDir);
    }
    ClientService.Iface client = null;
    final TabletLocator locator = TabletLocator.getInstance(instance, credentials, new Text(tableId));
    try {
        final Map<Path, List<TabletLocation>> assignments = Collections.synchronizedSortedMap(new TreeMap<Path, List<TabletLocation>>());
        timer.start(Timers.EXAMINE_MAP_FILES);
        ExecutorService threadPool = Executors.newFixedThreadPool(numThreads);
        for (Path path : paths) {
            final Path mapFile = path;
            Runnable getAssignments = new Runnable() {

                public void run() {
                    List<TabletLocation> tabletsToAssignMapFileTo = Collections.emptyList();
                    try {
                        tabletsToAssignMapFileTo = findOverlappingTablets(instance.getConfiguration(), fs, locator, mapFile);
                    } catch (Exception ex) {
                        log.warn(""Unable to find tablets that overlap file "" + mapFile.toString());
                    }
                    if (tabletsToAssignMapFileTo.size() == 0) {
                        List<KeyExtent> empty = Collections.emptyList();
                        completeFailures.put(mapFile, empty);
                    } else
                        assignments.put(mapFile, tabletsToAssignMapFileTo);
                }
            };
            threadPool.submit(new TraceRunnable(new LoggingRunnable(log, getAssignments)));
        }
        threadPool.shutdown();
        while (!threadPool.isTerminated()) {
            try {
                threadPool.awaitTermination(60, TimeUnit.SECONDS);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
        timer.stop(Timers.EXAMINE_MAP_FILES);
        assignmentStats.attemptingAssignments(assignments);
        Map<Path, List<KeyExtent>> assignmentFailures = assignMapFiles(acuConf, instance, conf, credentials, fs, tableId, assignments, paths, numAssignThreads, numThreads);
        assignmentStats.assignmentsFailed(assignmentFailures);
        Map<Path, Integer> failureCount = new TreeMap<Path, Integer>();
        for (Entry<Path, List<KeyExtent>> entry : assignmentFailures.entrySet()) failureCount.put(entry.getKey(), 1);
        while (assignmentFailures.size() > 0) {
            locator.invalidateCache();
                                                                        timer.start(Timers.SLEEP);
            UtilWaitThread.sleep(4000);
            timer.stop(Timers.SLEEP);
            log.debug(""Trying to assign "" + assignmentFailures.size() + "" map files that previously failed on some key extents"");
            assignments.clear();
                        for (Entry<Path, List<KeyExtent>> entry : assignmentFailures.entrySet()) {
                Iterator<KeyExtent> keListIter = entry.getValue().iterator();
                List<TabletLocation> tabletsToAssignMapFileTo = new ArrayList<TabletLocation>();
                while (keListIter.hasNext()) {
                    KeyExtent ke = keListIter.next();
                    try {
                        timer.start(Timers.QUERY_METADATA);
                        tabletsToAssignMapFileTo.addAll(findOverlappingTablets(instance.getConfiguration(), fs, locator, entry.getKey(), ke));
                        timer.stop(Timers.QUERY_METADATA);
                        keListIter.remove();
                    } catch (Exception ex) {
                        log.warn(""Exception finding overlapping tablets, will retry tablet "" + ke);
                    }
                }
                if (tabletsToAssignMapFileTo.size() > 0)
                    assignments.put(entry.getKey(), tabletsToAssignMapFileTo);
            }
            assignmentStats.attemptingAssignments(assignments);
            Map<Path, List<KeyExtent>> assignmentFailures2 = assignMapFiles(acuConf, instance, conf, credentials, fs, tableId, assignments, paths, numAssignThreads, numThreads);
            assignmentStats.assignmentsFailed(assignmentFailures2);
                        for (Entry<Path, List<KeyExtent>> entry : assignmentFailures2.entrySet()) {
                assignmentFailures.get(entry.getKey()).addAll(entry.getValue());
                Integer fc = failureCount.get(entry.getKey());
                if (fc == null)
                    fc = 0;
                failureCount.put(entry.getKey(), fc + 1);
            }
                        Iterator<Entry<Path, List<KeyExtent>>> afIter = assignmentFailures.entrySet().iterator();
            while (afIter.hasNext()) {
                Entry<Path, List<KeyExtent>> entry = afIter.next();
                if (entry.getValue().size() == 0)
                    afIter.remove();
            }
            Set<Entry<Path, Integer>> failureIter = failureCount.entrySet();
            for (Entry<Path, Integer> entry : failureIter) {
                if (entry.getValue() > acuConf.getCount(Property.TSERV_BULK_RETRY) && assignmentFailures.get(entry.getKey()) != null) {
                    log.error(""Map file "" + entry.getKey() + "" failed more than three times, giving up."");
                    completeFailures.put(entry.getKey(), assignmentFailures.get(entry.getKey()));
                    assignmentFailures.remove(entry.getKey());
                }
            }
        }
        assignmentStats.assignmentsAbandoned(completeFailures);
        Set<Path> failedFailures = processFailures(conf, fs, failureDir, completeFailures);
        assignmentStats.unrecoveredMapFiles(failedFailures);
        timer.stop(Timers.TOTAL);
        printReport();
        return assignmentStats;
    } finally {
        if (client != null)
            ServerClient.close(client);
        locator.invalidateCache();
    }
}",4.681818181818182,1.5693779904306218,3.8,1.5,1.75,1.4960317460317463,-1.5443269908386184,7.583333333333333,-0.02631578947368421,15.166337603660605
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1199_813109d7,3,"public void removeConstraint(ByteBuffer login, String tableName, int constraint) throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException;",,"public void removeConstraint(ByteBuffer login, String tableName, int constraint) throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException;",-0.5909090909090909,-1.4306220095693782,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,1.4033826638477798,-0.5,-0.02631578947368421,-0.16279340490885932
wicket,remotes/origin/bugs-dot-jar_WICKET-172_99e22ce4,1,"/**
 *  Ensure that there is space in childForId map for a new entry before
 *  adding it.
 *
 *  @param child
 *             The child to put into the map
 *  @return Any component that was replaced
 */
private final Component put(final Component<?> child) {
    int index = children_indexOf(child);
    if (index == -1) {
        children_add(child);
        return null;
    } else {
        return children_set(index, child);
    }
}","/**
 *  Ensure that there is space in childForId map for a new entry before
 *  adding it.
 *
 *  @param child
 *             The child to put into the map
 *  @return Any component that was replaced
 */
","private final Component put(final Component<?> child) {
    int index = children_indexOf(child);
    if (index == -1) {
        children_add(child);
        return null;
    } else {
        return children_set(index, child);
    }
}",-0.22727272727272727,-0.01913875598086126,-0.4,-0.5,-0.25,-0.047619047619047616,0.33784355179704006,-0.25,2.236842105263158,-0.1109316920523504
Closure,125,2,"/**
 * Visits a NEW node.
 */
private void visitNew(NodeTraversal t, Node n) {
    Node constructor = n.getFirstChild();
    JSType type = getJSType(constructor).restrictByNotNullOrUndefined();
    if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {
        FunctionType fnType = type.toMaybeFunctionType();
        if (fnType != null) {
            visitParameterList(t, n, fnType);
            ensureTyped(t, n, fnType.getInstanceType());
        } else {
            ensureTyped(t, n);
        }
    } else {
        report(t, n, NOT_A_CONSTRUCTOR);
        ensureTyped(t, n);
    }
}","/**
 * Visits a NEW node.
 */
","private void visitNew(NodeTraversal t, Node n) {
    Node constructor = n.getFirstChild();
    JSType type = getJSType(constructor).restrictByNotNullOrUndefined();
    if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {
        FunctionType fnType = type.toMaybeFunctionType();
        if (fnType != null) {
            visitParameterList(t, n, fnType);
            ensureTyped(t, n, fnType.getInstanceType());
        } else {
            ensureTyped(t, n);
        }
    } else {
        report(t, n, NOT_A_CONSTRUCTOR);
        ensureTyped(t, n);
    }
}",0.09090909090909091,0.3444976076555023,-0.2,0.0,0.25,0.015873015873015844,-0.11289640591966157,0.5833333333333334,0.05263157894736841,0.05149058049941506
Math,96,3,"/**
 * Test for the equality of two Complex objects.
 * <p>
 * If both the real and imaginary parts of two Complex numbers
 * are exactly the same, and neither is <code>Double.NaN</code>, the two
 * Complex objects are considered to be equal.</p>
 * <p>
 * All <code>NaN</code> values are considered to be equal - i.e, if either
 * (or both) real and imaginary parts of the complex number are equal
 * to <code>Double.NaN</code>, the complex number is equal to
 * <code>Complex.NaN</code>.</p>
 *
 * @param other Object to test for equality to this
 * @return true if two Complex objects are equal, false if
 *         object is null, not an instance of Complex, or
 *         not equal to this Complex instance
 */
public boolean equals(Object other) {
    boolean ret;
    if (this == other) {
        ret = true;
    } else if (other == null) {
        ret = false;
    } else {
        try {
            Complex rhs = (Complex) other;
            if (rhs.isNaN()) {
                ret = this.isNaN();
            } else {
                ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));
            }
        } catch (ClassCastException ex) {
            // ignore exception
            ret = false;
        }
    }
    return ret;
}","/**
 * Test for the equality of two Complex objects.
 * <p>
 * If both the real and imaginary parts of two Complex numbers
 * are exactly the same, and neither is <code>Double.NaN</code>, the two
 * Complex objects are considered to be equal.</p>
 * <p>
 * All <code>NaN</code> values are considered to be equal - i.e, if either
 * (or both) real and imaginary parts of the complex number are equal
 * to <code>Double.NaN</code>, the complex number is equal to
 * <code>Complex.NaN</code>.</p>
 *
 * @param other Object to test for equality to this
 * @return true if two Complex objects are equal, false if
 *         object is null, not an instance of Complex, or
 *         not equal to this Complex instance
 */
","public boolean equals(Object other) {
    boolean ret;
    if (this == other) {
        ret = true;
    } else if (other == null) {
        ret = false;
    } else {
        try {
            Complex rhs = (Complex) other;
            if (rhs.isNaN()) {
                ret = this.isNaN();
            } else {
                ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));
            }
        } catch (ClassCastException ex) {
                        ret = false;
        }
    }
    return ret;
}",0.2727272727272727,0.7894736842105261,0.2,1.0,0.0,0.053571428571428534,-0.2183227625088091,0.16666666666666666,-0.02631578947368421,0.05794966661480033
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3310_4416a9f8,1,"private void internalSetValue(@Nonnull final Value[] values) throws RepositoryException {
    if (values.length > MV_PROPERTY_WARN_THRESHOLD) {
        LOG.warn(""Large multi valued property [{}] detected ({} values)."", dlg.getPath(), values.length);
    }
    sessionDelegate.performVoid(new ItemWriteOperation(""internalSetValue"") {

        @Override
        public void performVoid() throws RepositoryException {
            Type<?> type = dlg.getPropertyState().getType();
            if (!type.isArray()) {
                throw new ValueFormatException(""This is a single-valued property"");
            }
            List<Value> converted = newArrayListWithCapacity(values.length);
            ValueFactory factory = getValueFactory();
            for (Value value : values) {
                if (value != null) {
                    converted.add(ValueHelper.convert(value, type.tag(), factory));
                }
            }
            dlg.setState(createMultiState(dlg.getName(), converted, type));
        }

        @Override
        public String toString() {
            return String.format(""Setting property [%s/%s]"", dlg.getPath(), dlg.getName());
        }
    });
}",,"private void internalSetValue(@Nonnull final Value[] values) throws RepositoryException {
    if (values.length > MV_PROPERTY_WARN_THRESHOLD) {
        LOG.warn(""Large multi valued property [{}] detected ({} values)."", dlg.getPath(), values.length);
    }
    sessionDelegate.performVoid(new ItemWriteOperation(""internalSetValue"") {

        @Override
        public void performVoid() throws RepositoryException {
            Type<?> type = dlg.getPropertyState().getType();
            if (!type.isArray()) {
                throw new ValueFormatException(""This is a single-valued property"");
            }
            List<Value> converted = newArrayListWithCapacity(values.length);
            ValueFactory factory = getValueFactory();
            for (Value value : values) {
                if (value != null) {
                    converted.add(ValueHelper.convert(value, type.tag(), factory));
                }
            }
            dlg.setState(createMultiState(dlg.getName(), converted, type));
        }

        @Override
        public String toString() {
            return String.format(""Setting property [%s/%s]"", dlg.getPath(), dlg.getName());
        }
    });
}",0.5454545454545454,0.8899521531100476,0.4,0.5,0.08333333333333333,0.28968253968253965,-0.43735024665257216,0.9166666666666666,-0.02631578947368421,0.488380214726578
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1697_1552be04,3,"/**
 * Create a separate token node underneath a dedicated token store within
 * the user home node. That token node contains the hashed token, the
 * expiration time and additional mandatory attributes that will be verified
 * during login.
 *
 * @param userId     The identifier of the user for which a new token should
 *                   be created.
 * @param attributes The attributes associated with the new token.
 * @return A new {@code TokenInfo} or {@code null} if the token could not
 *         be created.
 */
@Override
public TokenInfo createToken(String userId, Map<String, ?> attributes) {
    String error = ""Failed to create login token. "";
    NodeUtil tokenParent = getTokenParent(userId);
    if (tokenParent != null) {
        try {
            long creationTime = new Date().getTime();
            Calendar creation = GregorianCalendar.getInstance();
            creation.setTimeInMillis(creationTime);
            String tokenName = Text.replace(ISO8601.format(creation), "":"", ""."");
            NodeUtil tokenNode = tokenParent.addChild(tokenName, TOKEN_NT_NAME);
            tokenNode.setString(JcrConstants.JCR_UUID, IdentifierManager.generateUUID());
            String key = generateKey(options.getConfigValue(PARAM_TOKEN_LENGTH, DEFAULT_KEY_SIZE));
            String nodeId = getIdentifier(tokenNode.getTree());
            String token = new StringBuilder(nodeId).append(DELIM).append(key).toString();
            String keyHash = PasswordUtil.buildPasswordHash(getKeyValue(key, userId));
            tokenNode.setString(TOKEN_ATTRIBUTE_KEY, keyHash);
            long exp;
            if (attributes.containsKey(PARAM_TOKEN_EXPIRATION)) {
                exp = Long.parseLong(attributes.get(PARAM_TOKEN_EXPIRATION).toString());
            } else {
                exp = tokenExpiration;
            }
            long expTime = createExpirationTime(creationTime, exp);
            tokenNode.setDate(TOKEN_ATTRIBUTE_EXPIRY, expTime);
            for (String name : attributes.keySet()) {
                if (!RESERVED_ATTRIBUTES.contains(name)) {
                    String attr = attributes.get(name).toString();
                    tokenNode.setString(name, attr);
                }
            }
            root.commit();
            return new TokenInfoImpl(tokenNode, token, userId);
        } catch (NoSuchAlgorithmException e) {
            // error while generating login token
            log.error(error, e.getMessage());
        } catch (UnsupportedEncodingException e) {
            // error while generating login token
            log.error(error, e.getMessage());
        } catch (CommitFailedException e) {
            // conflict while committing changes
            log.warn(error, e.getMessage());
        } catch (AccessDeniedException e) {
            log.warn(error, e.getMessage());
        }
    } else {
        log.warn(""Unable to get/create token store for user "" + userId);
    }
    return null;
}","/**
 * Create a separate token node underneath a dedicated token store within
 * the user home node. That token node contains the hashed token, the
 * expiration time and additional mandatory attributes that will be verified
 * during login.
 *
 * @param userId     The identifier of the user for which a new token should
 *                   be created.
 * @param attributes The attributes associated with the new token.
 * @return A new {@code TokenInfo} or {@code null} if the token could not
 *         be created.
 */
","@Override
public TokenInfo createToken(String userId, Map<String, ?> attributes) {
    String error = ""Failed to create login token. "";
    NodeUtil tokenParent = getTokenParent(userId);
    if (tokenParent != null) {
        try {
            long creationTime = new Date().getTime();
            Calendar creation = GregorianCalendar.getInstance();
            creation.setTimeInMillis(creationTime);
            String tokenName = Text.replace(ISO8601.format(creation), "":"", ""."");
            NodeUtil tokenNode = tokenParent.addChild(tokenName, TOKEN_NT_NAME);
            tokenNode.setString(JcrConstants.JCR_UUID, IdentifierManager.generateUUID());
            String key = generateKey(options.getConfigValue(PARAM_TOKEN_LENGTH, DEFAULT_KEY_SIZE));
            String nodeId = getIdentifier(tokenNode.getTree());
            String token = new StringBuilder(nodeId).append(DELIM).append(key).toString();
            String keyHash = PasswordUtil.buildPasswordHash(getKeyValue(key, userId));
            tokenNode.setString(TOKEN_ATTRIBUTE_KEY, keyHash);
            long exp;
            if (attributes.containsKey(PARAM_TOKEN_EXPIRATION)) {
                exp = Long.parseLong(attributes.get(PARAM_TOKEN_EXPIRATION).toString());
            } else {
                exp = tokenExpiration;
            }
            long expTime = createExpirationTime(creationTime, exp);
            tokenNode.setDate(TOKEN_ATTRIBUTE_EXPIRY, expTime);
            for (String name : attributes.keySet()) {
                if (!RESERVED_ATTRIBUTES.contains(name)) {
                    String attr = attributes.get(name).toString();
                    tokenNode.setString(name, attr);
                }
            }
            root.commit();
            return new TokenInfoImpl(tokenNode, token, userId);
        } catch (NoSuchAlgorithmException e) {
                        log.error(error, e.getMessage());
        } catch (UnsupportedEncodingException e) {
                        log.error(error, e.getMessage());
        } catch (CommitFailedException e) {
                        log.warn(error, e.getMessage());
        } catch (AccessDeniedException e) {
            log.warn(error, e.getMessage());
        }
    } else {
        log.warn(""Unable to get/create token store for user "" + userId);
    }
    return null;
}",1.5,0.7607655502392344,1.0,1.0,0.16666666666666666,0.3809523809523809,-0.8694855532064832,2.8333333333333335,-0.02631578947368421,1.7977351705537592
wicket,remotes/origin/bugs-dot-jar_WICKET-5853_b80f6640,3,"/**
 *  Parses a value as a String and returns a Number.
 *
 *  @param value
 *             The object to parse (after converting with toString())
 *  @param min
 *             The minimum allowed value
 *  @param max
 *             The maximum allowed value
 *  @param locale
 *  @return The number
 *  @throws ConversionException
 *              if value is unparsable or out of range
 */
protected N parse(Object value, final double min, final double max, Locale locale) {
    if (locale == null) {
        locale = Locale.getDefault();
    }
    if (value == null) {
        return null;
    } else if (value instanceof String) {
        // Convert spaces to no-break space (U+00A0) as required by Java formats:
        // http://bugs.sun.com/view_bug.do?bug_id=4510618
        value = ((String) value).replaceAll(""(\\d+)\\s(?=\\d)"", ""$1\u00A0"");
    }
    final NumberFormat numberFormat = getNumberFormat(locale);
    final N number = parse(numberFormat, value, locale);
    if (number == null) {
        return null;
    }
    if (number.doubleValue() < min) {
        throw newConversionException(""Value cannot be less than "" + min, value, locale).setFormat(numberFormat);
    }
    if (number.doubleValue() > max) {
        throw newConversionException(""Value cannot be greater than "" + max, value, locale).setFormat(numberFormat);
    }
    return number;
}","/**
 *  Parses a value as a String and returns a Number.
 *
 *  @param value
 *             The object to parse (after converting with toString())
 *  @param min
 *             The minimum allowed value
 *  @param max
 *             The maximum allowed value
 *  @param locale
 *  @return The number
 *  @throws ConversionException
 *              if value is unparsable or out of range
 */
","protected N parse(Object value, final double min, final double max, Locale locale) {
    if (locale == null) {
        locale = Locale.getDefault();
    }
    if (value == null) {
        return null;
    } else if (value instanceof String) {
                        value = ((String) value).replaceAll(""(\\d+)\\s(?=\\d)"", ""$1\u00A0"");
    }
    final NumberFormat numberFormat = getNumberFormat(locale);
    final N number = parse(numberFormat, value, locale);
    if (number == null) {
        return null;
    }
    if (number.doubleValue() < min) {
        throw newConversionException(""Value cannot be less than "" + min, value, locale).setFormat(numberFormat);
    }
    if (number.doubleValue() > max) {
        throw newConversionException(""Value cannot be greater than "" + max, value, locale).setFormat(numberFormat);
    }
    return number;
}",0.36363636363636365,-0.3301435406698567,1.0,0.0,0.5833333333333334,0.6111111111111112,-0.34686398872445356,0.3333333333333333,-0.02631578947368421,0.6080369749255141
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-793_73400bfb,3,"/**
 * Return a Log4j Marker that is compatible with SLF4J.
 * @param name The name of the Marker.
 * @return A Marker.
 */
@Override
public Marker getMarker(final String name) {
    if (name == null) {
        throw new IllegalArgumentException(""Marker name must not be null"");
    }
    Marker marker = markerMap.get(name);
    if (marker != null) {
        return marker;
    }
    final org.apache.logging.log4j.Marker log4jMarker = MarkerManager.getMarker(name);
    marker = new Log4jMarker(log4jMarker);
    final Marker existing = markerMap.putIfAbsent(name, marker);
    return existing == null ? marker : existing;
}","/**
 * Return a Log4j Marker that is compatible with SLF4J.
 * @param name The name of the Marker.
 * @return A Marker.
 */
","@Override
public Marker getMarker(final String name) {
    if (name == null) {
        throw new IllegalArgumentException(""Marker name must not be null"");
    }
    Marker marker = markerMap.get(name);
    if (marker != null) {
        return marker;
    }
    final org.apache.logging.log4j.Marker log4jMarker = MarkerManager.getMarker(name);
    marker = new Log4jMarker(log4jMarker);
    final Marker existing = markerMap.putIfAbsent(name, marker);
    return existing == null ? marker : existing;
}",0.0,-0.29665071770334933,0.2,-0.5,0.08333333333333333,0.011904761904761871,-0.047498238195912666,-0.25,0.15789473684210528,0.026442604150458418
Closure,146,2,"/**
 * Computes the subset of {@code this} and {@code that} types if inequality
 * is observed. If a value {@code v1} of type {@code number} is not equal to a
 * value {@code v2} of type {@code (undefined,number)}, we can infer that the
 * type of {@code v1} is {@code number} and the type of {@code v2} is
 * {@code number} as well.
 *
 * @return a pair containing the restricted type of {@code this} as the first
 *         component and the restricted type of {@code that} as the second
 *         element. The returned pair is never {@code null} even though its
 *         components may be {@code null}
 */
public TypePair getTypesUnderInequality(JSType that) {
    // unions types
    if (that instanceof UnionType) {
        TypePair p = that.getTypesUnderInequality(this);
        return new TypePair(p.typeB, p.typeA);
    }
    // other types
    switch(this.testForEquality(that)) {
        case TRUE:
            return new TypePair(null, null);
        case FALSE:
        case UNKNOWN:
            return new TypePair(this, that);
    }
    // switch case is exhaustive
    throw new IllegalStateException();
}","/**
 * Computes the subset of {@code this} and {@code that} types if inequality
 * is observed. If a value {@code v1} of type {@code number} is not equal to a
 * value {@code v2} of type {@code (undefined,number)}, we can infer that the
 * type of {@code v1} is {@code number} and the type of {@code v2} is
 * {@code number} as well.
 *
 * @return a pair containing the restricted type of {@code this} as the first
 *         component and the restricted type of {@code that} as the second
 *         element. The returned pair is never {@code null} even though its
 *         components may be {@code null}
 */
","public TypePair getTypesUnderInequality(JSType that) {
        if (that instanceof UnionType) {
        TypePair p = that.getTypesUnderInequality(this);
        return new TypePair(p.typeB, p.typeA);
    }
        switch(this.testForEquality(that)) {
        case TRUE:
            return new TypePair(null, null);
        case FALSE:
        case UNKNOWN:
            return new TypePair(this, that);
    }
        throw new IllegalStateException();
}",0.0,0.3062200956937798,0.4,0.0,0.08333333333333333,-0.3650793650793651,0.04186046511627904,-0.3333333333333333,-0.02631578947368421,-0.16279340490885932
wicket,remotes/origin/bugs-dot-jar_WICKET-2172_ea4a3f8a,3,"/**
 *  @see IValueMap#getAsDuration(String, Duration)
 */
public Duration getAsDuration(String key, Duration defaultValue) {
    if (!containsKey(key))
        return defaultValue;
    try {
        return getDuration(key);
    } catch (StringValueConversionException ignored) {
        return defaultValue;
    }
}","/**
 *  @see IValueMap#getAsDuration(String, Duration)
 */
","public Duration getAsDuration(String key, Duration defaultValue) {
    if (!containsKey(key))
        return defaultValue;
    try {
        return getDuration(key);
    } catch (StringValueConversionException ignored) {
        return defaultValue;
    }
}",-0.22727272727272727,-0.01913875598086126,-0.2,-0.5,-0.16666666666666666,-0.3650793650793651,0.3663143058491896,-0.3333333333333333,2.263157894736842,-0.16279340490885932
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2435_7e250001,3,"@Override
public boolean equals(Object obj) {
    if (obj instanceof Key) {
        Key other = (Key) obj;
        return name.equals(other.name) && revision != null ? revision.equals(other.revision) : other.revision == null;
    }
    return false;
}",,"@Override
public boolean equals(Object obj) {
    if (obj instanceof Key) {
        Key other = (Key) obj;
        return name.equals(other.name) && revision != null ? revision.equals(other.revision) : other.revision == null;
    }
    return false;
}",-0.2727272727272727,0.06220095693779899,-0.2,-0.5,0.16666666666666666,0.5376984126984127,0.315292459478506,-0.3333333333333333,0.6578947368421053,0.07463909683442539
camel,remotes/origin/bugs-dot-jar_CAMEL-4513_9e05f77f,3,"public void process(Exchange exchange) throws Exception {
    // copy the original exchange to avoid side effects on it
    Exchange resultExchange = exchange.copy();
    // force to use InOut to retrieve the result on the OUT message
    resultExchange.setPattern(ExchangePattern.InOut);
    // do not propagate any method name when using OGNL, as with OGNL we
    // compute and provide the method name to explicit to invoke
    resultExchange.getIn().removeHeader(Exchange.BEAN_METHOD_NAME);
    // current ognl path as we go along
    String ognlPath = """";
    // loop and invoke each method
    Object beanToCall = beanHolder.getBean();
    // there must be a bean to call with, we currently does not support OGNL expressions on using purely static methods
    if (beanToCall == null) {
        throw new IllegalArgumentException(""Bean instance is null. OGNL bean expressions requires bean instances."");
    }
    // Split ognl except when this is not a Map, Array
    // and we would like to keep the dots within the key name
    List<String> methods = OgnlHelper.splitOgnl(ognl);
    for (String methodName : methods) {
        BeanHolder holder = new ConstantBeanHolder(beanToCall, exchange.getContext());
        // support the null safe operator
        boolean nullSafe = OgnlHelper.isNullSafeOperator(methodName);
        // keep up with how far are we doing
        ognlPath += methodName;
        // get rid of leading ?. or . as we only needed that to determine if null safe was enabled or not
        methodName = OgnlHelper.removeLeadingOperators(methodName);
        // are we doing an index lookup (eg in Map/List/array etc)?
        String key = null;
        KeyValueHolder<String, String> index = OgnlHelper.isOgnlIndex(methodName);
        if (index != null) {
            methodName = index.getKey();
            key = index.getValue();
        }
        // only invoke if we have a method name to use to invoke
        if (methodName != null) {
            InvokeProcessor invoke = new InvokeProcessor(holder, methodName);
            invoke.process(resultExchange);
            // check for exception and rethrow if we failed
            if (resultExchange.getException() != null) {
                throw new RuntimeBeanExpressionException(exchange, beanName, methodName, resultExchange.getException());
            }
            result = invoke.getResult();
        }
        // if there was a key then we need to lookup using the key
        if (key != null) {
            result = lookupResult(resultExchange, key, result, nullSafe, ognlPath, holder.getBean());
        }
        // check null safe for null results
        if (result == null && nullSafe) {
            return;
        }
        // prepare for next bean to invoke
        beanToCall = result;
    }
}",,"public void process(Exchange exchange) throws Exception {
        Exchange resultExchange = exchange.copy();
        resultExchange.setPattern(ExchangePattern.InOut);
            resultExchange.getIn().removeHeader(Exchange.BEAN_METHOD_NAME);
        String ognlPath = """";
        Object beanToCall = beanHolder.getBean();
        if (beanToCall == null) {
        throw new IllegalArgumentException(""Bean instance is null. OGNL bean expressions requires bean instances."");
    }
            List<String> methods = OgnlHelper.splitOgnl(ognl);
    for (String methodName : methods) {
        BeanHolder holder = new ConstantBeanHolder(beanToCall, exchange.getContext());
                boolean nullSafe = OgnlHelper.isNullSafeOperator(methodName);
                ognlPath += methodName;
                methodName = OgnlHelper.removeLeadingOperators(methodName);
                String key = null;
        KeyValueHolder<String, String> index = OgnlHelper.isOgnlIndex(methodName);
        if (index != null) {
            methodName = index.getKey();
            key = index.getValue();
        }
                if (methodName != null) {
            InvokeProcessor invoke = new InvokeProcessor(holder, methodName);
            invoke.process(resultExchange);
                        if (resultExchange.getException() != null) {
                throw new RuntimeBeanExpressionException(exchange, beanName, methodName, resultExchange.getException());
            }
            result = invoke.getResult();
        }
                if (key != null) {
            result = lookupResult(resultExchange, key, result, nullSafe, ognlPath, holder.getBean());
        }
                if (result == null && nullSafe) {
            return;
        }
                beanToCall = result;
    }
}",1.0909090909090908,0.29186602870813394,1.2,0.5,0.75,0.507936507936508,-0.7223396758280477,1.0,-0.02631578947368421,1.3969998213493309
Math,93,3,"/**
 * Returns n!. Shorthand for <code>n</code> <a
 * href=""http://mathworld.wolfram.com/Factorial.html""> Factorial</a>, the
 * product of the numbers <code>1,...,n</code> as a <code>double</code>.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>n >= 0</code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>double</code>. The
 * largest value of <code>n</code> for which <code>n!</code> <
 * Double.MAX_VALUE</code> is 170. If the computed value exceeds
 * Double.MAX_VALUE, Double.POSITIVE_INFINITY is returned</li>
 * </ul>
 * </p>
 *
 * @param n argument
 * @return <code>n!</code>
 * @throws IllegalArgumentException if n < 0
 */
public static double factorialDouble(final int n) {
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for n!"");
    }
    return Math.floor(Math.exp(factorialLog(n)) + 0.5);
}","/**
 * Returns n!. Shorthand for <code>n</code> <a
 * href=""http://mathworld.wolfram.com/Factorial.html""> Factorial</a>, the
 * product of the numbers <code>1,...,n</code> as a <code>double</code>.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>n >= 0</code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>double</code>. The
 * largest value of <code>n</code> for which <code>n!</code> <
 * Double.MAX_VALUE</code> is 170. If the computed value exceeds
 * Double.MAX_VALUE, Double.POSITIVE_INFINITY is returned</li>
 * </ul>
 * </p>
 *
 * @param n argument
 * @return <code>n!</code>
 * @throws IllegalArgumentException if n < 0
 */
","public static double factorialDouble(final int n) {
    if (n < 0) {
        throw new IllegalArgumentException(""must have n >= 0 for n!"");
    }
    return Math.floor(Math.exp(factorialLog(n)) + 0.5);
}",-0.36363636363636365,-0.11483253588516758,-0.2,-0.5,-0.25,-0.11309523809523811,0.5416490486257928,-0.25,-0.02631578947368421,-0.12805449421690493
flink,remotes/origin/bugs-dot-jar_FLINK-2437_a41bc8cc,3,"/**
 *  recursively determine all declared fields
 *  This is required because class.getFields() is not returning fields defined
 *  in parent classes.
 */
public static List<Field> getAllDeclaredFields(Class<?> clazz) {
    List<Field> result = new ArrayList<Field>();
    while (clazz != null) {
        Field[] fields = clazz.getDeclaredFields();
        for (Field field : fields) {
            if (Modifier.isTransient(field.getModifiers()) || Modifier.isStatic(field.getModifiers())) {
                // we have no use for transient or static fields
                continue;
            }
            if (hasFieldWithSameName(field.getName(), result)) {
                throw new RuntimeException(""The field "" + field + "" is already contained in the hierarchy of the class "" + clazz + ""."" + ""Please use unique field names through your classes hierarchy"");
            }
            result.add(field);
        }
        clazz = clazz.getSuperclass();
    }
    return result;
}","/**
 *  recursively determine all declared fields
 *  This is required because class.getFields() is not returning fields defined
 *  in parent classes.
 */
","public static List<Field> getAllDeclaredFields(Class<?> clazz) {
    List<Field> result = new ArrayList<Field>();
    while (clazz != null) {
        Field[] fields = clazz.getDeclaredFields();
        for (Field field : fields) {
            if (Modifier.isTransient(field.getModifiers()) || Modifier.isStatic(field.getModifiers())) {
                                continue;
            }
            if (hasFieldWithSameName(field.getName(), result)) {
                throw new RuntimeException(""The field "" + field + "" is already contained in the hierarchy of the class "" + clazz + ""."" + ""Please use unique field names through your classes hierarchy"");
            }
            result.add(field);
        }
        clazz = clazz.getSuperclass();
    }
    return result;
}",0.13636363636363635,0.8899521531100476,0.6,0.5,0.5,0.3650793650793651,-0.17237491190979545,0.25,-0.02631578947368421,0.26579300726704813
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-43_668f08f2,1,"void apply() throws Exception {
    moveNode(srcPath, destPath);
}",,"void apply() throws Exception {
    moveNode(srcPath, destPath);
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,1.0676532769556022,-0.4166666666666667,1.6578947368421053,-0.16279340490885932
Closure,67,2,"private boolean isPrototypePropertyAssign(Node assign) {
    Node n = assign.getFirstChild();
    if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.getType() == Token.GETPROP) {
        // We want to exclude the assignment itself from the usage list
        boolean isChainedProperty = n.getFirstChild().getType() == Token.GETPROP;
        if (isChainedProperty) {
            Node child = n.getFirstChild().getFirstChild().getNext();
            if (child.getType() == Token.STRING && child.getString().equals(""prototype"")) {
                return true;
            }
        }
    }
    return false;
}",,"private boolean isPrototypePropertyAssign(Node assign) {
    Node n = assign.getFirstChild();
    if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.getType() == Token.GETPROP) {
                boolean isChainedProperty = n.getFirstChild().getType() == Token.GETPROP;
        if (isChainedProperty) {
            Node child = n.getFirstChild().getFirstChild().getNext();
            if (child.getType() == Token.STRING && child.getString().equals(""prototype"")) {
                return true;
            }
        }
    }
    return false;
}",-0.045454545454545456,0.8421052631578947,0.0,0.5,0.6666666666666666,0.40873015873015867,-0.021000704721635077,0.4166666666666667,0.21052631578947367,0.26356621312448486
Lang,57,1,"// -----------------------------------------------------------------------
/**
 * <p>Checks if the locale specified is in the list of available locales.</p>
 *
 * @param locale the Locale object to check if it is available
 * @return true if the locale is a known locale
 */
public static boolean isAvailableLocale(Locale locale) {
    return cAvailableLocaleSet.contains(locale);
}","/**
 * <p>Checks if the locale specified is in the list of available locales.</p>
 *
 * @param locale the Locale object to check if it is available
 * @return true if the locale is a known locale
 */
","public static boolean isAvailableLocale(Locale locale) {
    return cAvailableLocaleSet.contains(locale);
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,1.0451021846370678,-0.4166666666666667,2.6052631578947367,-0.16279340490885932
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-4351_59a83d23,3,"@Override
public IndexRow next() {
    final IndexRow pathRow = pathCursor.next();
    return new IndexRow() {

        @Override
        public boolean isVirtualRow() {
            return currentRow.isVirutal;
        }

        @Override
        public String getPath() {
            String sub = pathRow.getPath();
            if (isVirtualRow()) {
                return sub;
            } else if (PathUtils.isAbsolute(sub)) {
                return pathPrefix + sub;
            } else {
                return PathUtils.concat(pathPrefix, sub);
            }
        }

        @Override
        public PropertyValue getValue(String columnName) {
            // overlay the score
            if (QueryImpl.JCR_SCORE.equals(columnName)) {
                return PropertyValues.newDouble(currentRow.score);
            }
            if (QueryImpl.REP_SPELLCHECK.equals(columnName) || QueryImpl.REP_SUGGEST.equals(columnName)) {
                return PropertyValues.newString(currentRow.suggestion);
            }
            if (QueryImpl.OAK_SCORE_EXPLANATION.equals(columnName)) {
                return PropertyValues.newString(currentRow.explanation);
            }
            if (QueryImpl.REP_EXCERPT.equals(columnName)) {
                return PropertyValues.newString(currentRow.excerpt);
            }
            if (columnName.startsWith(QueryImpl.REP_FACET)) {
                String facetFieldName = FacetHelper.parseFacetField(columnName);
                Facets facets = currentRow.facets;
                try {
                    if (facets != null) {
                        FacetResult topChildren = facets.getTopChildren(10, facetFieldName);
                        if (topChildren != null) {
                            JsopWriter writer = new JsopBuilder();
                            writer.object();
                            for (LabelAndValue lav : topChildren.labelValues) {
                                writer.key(lav.label).value(lav.value.intValue());
                            }
                            writer.endObject();
                            return PropertyValues.newString(writer.toString());
                        } else {
                            return null;
                        }
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            }
            return pathRow.getValue(columnName);
        }
    };
}",,"@Override
public IndexRow next() {
    final IndexRow pathRow = pathCursor.next();
    return new IndexRow() {

        @Override
        public boolean isVirtualRow() {
            return currentRow.isVirutal;
        }

        @Override
        public String getPath() {
            String sub = pathRow.getPath();
            if (isVirtualRow()) {
                return sub;
            } else if (PathUtils.isAbsolute(sub)) {
                return pathPrefix + sub;
            } else {
                return PathUtils.concat(pathPrefix, sub);
            }
        }

        @Override
        public PropertyValue getValue(String columnName) {
                        if (QueryImpl.JCR_SCORE.equals(columnName)) {
                return PropertyValues.newDouble(currentRow.score);
            }
            if (QueryImpl.REP_SPELLCHECK.equals(columnName) || QueryImpl.REP_SUGGEST.equals(columnName)) {
                return PropertyValues.newString(currentRow.suggestion);
            }
            if (QueryImpl.OAK_SCORE_EXPLANATION.equals(columnName)) {
                return PropertyValues.newString(currentRow.explanation);
            }
            if (QueryImpl.REP_EXCERPT.equals(columnName)) {
                return PropertyValues.newString(currentRow.excerpt);
            }
            if (columnName.startsWith(QueryImpl.REP_FACET)) {
                String facetFieldName = FacetHelper.parseFacetField(columnName);
                Facets facets = currentRow.facets;
                try {
                    if (facets != null) {
                        FacetResult topChildren = facets.getTopChildren(10, facetFieldName);
                        if (topChildren != null) {
                            JsopWriter writer = new JsopBuilder();
                            writer.object();
                            for (LabelAndValue lav : topChildren.labelValues) {
                                writer.key(lav.label).value(lav.value.intValue());
                            }
                            writer.endObject();
                            return PropertyValues.newString(writer.toString());
                        } else {
                            return null;
                        }
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            }
            return pathRow.getValue(columnName);
        }
    };
}",2.0454545454545454,2.258373205741627,1.8,2.0,1.4166666666666667,0.45436507936507936,-0.9520789288231148,1.5833333333333333,-0.02631578947368421,1.3971519625640403
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-293_25cb587a,1,"/**
 * Load the configuration from a URI.
 * @param configLocation A URI representing the location of the configuration.
 * @return The ConfigurationSource for the configuration.
 */
protected ConfigurationSource getInputFromURI(final URI configLocation) {
    final File configFile = FileUtils.fileFromURI(configLocation);
    if (configFile != null && configFile.exists() && configFile.canRead()) {
        try {
            return new ConfigurationSource(new FileInputStream(configFile), configFile);
        } catch (final FileNotFoundException ex) {
            LOGGER.error(""Cannot locate file "" + configLocation.getPath(), ex);
        }
    }
    final String scheme = configLocation.getScheme();
    if (scheme == null || scheme.equals(""classloader"")) {
        final ClassLoader loader = this.getClass().getClassLoader();
        final ConfigurationSource source = getInputFromResource(configLocation.getPath(), loader);
        if (source != null) {
            return source;
        }
    }
    try {
        return new ConfigurationSource(configLocation.toURL().openStream(), configLocation.getPath());
    } catch (final MalformedURLException ex) {
        LOGGER.error(""Invalid URL "" + configLocation.toString(), ex);
    } catch (final IOException ex) {
        LOGGER.error(""Unable to access "" + configLocation.toString(), ex);
    } catch (final Exception ex) {
        LOGGER.error(""Unable to access "" + configLocation.toString(), ex);
    }
    return null;
}","/**
 * Load the configuration from a URI.
 * @param configLocation A URI representing the location of the configuration.
 * @return The ConfigurationSource for the configuration.
 */
","protected ConfigurationSource getInputFromURI(final URI configLocation) {
    final File configFile = FileUtils.fileFromURI(configLocation);
    if (configFile != null && configFile.exists() && configFile.canRead()) {
        try {
            return new ConfigurationSource(new FileInputStream(configFile), configFile);
        } catch (final FileNotFoundException ex) {
            LOGGER.error(""Cannot locate file "" + configLocation.getPath(), ex);
        }
    }
    final String scheme = configLocation.getScheme();
    if (scheme == null || scheme.equals(""classloader"")) {
        final ClassLoader loader = this.getClass().getClassLoader();
        final ConfigurationSource source = getInputFromResource(configLocation.getPath(), loader);
        if (source != null) {
            return source;
        }
    }
    try {
        return new ConfigurationSource(configLocation.toURL().openStream(), configLocation.getPath());
    } catch (final MalformedURLException ex) {
        LOGGER.error(""Invalid URL "" + configLocation.toString(), ex);
    } catch (final IOException ex) {
        LOGGER.error(""Unable to access "" + configLocation.toString(), ex);
    } catch (final Exception ex) {
        LOGGER.error(""Unable to access "" + configLocation.toString(), ex);
    }
    return null;
}",0.6363636363636364,0.057416267942583574,0.8,0.0,0.5833333333333334,0.9027777777777778,-0.5123326286116981,1.1666666666666667,-0.02631578947368421,1.366271906317894
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-209_76d727f0,1,"@Override
public boolean validateOptions(Map<String, String> options) {
    super.validateOptions(options);
    if (options.containsKey(ROW_REGEX))
        Pattern.compile(options.get(ROW_REGEX)).matcher("""");
    if (options.containsKey(COLF_REGEX))
        Pattern.compile(options.get(COLF_REGEX)).matcher("""");
    if (options.containsKey(COLQ_REGEX))
        Pattern.compile(options.get(COLQ_REGEX)).matcher("""");
    if (options.containsKey(VALUE_REGEX))
        Pattern.compile(options.get(VALUE_REGEX)).matcher("""");
    return true;
}",,"@Override
public boolean validateOptions(Map<String, String> options) {
    super.validateOptions(options);
    if (options.containsKey(ROW_REGEX))
        Pattern.compile(options.get(ROW_REGEX)).matcher("""");
    if (options.containsKey(COLF_REGEX))
        Pattern.compile(options.get(COLF_REGEX)).matcher("""");
    if (options.containsKey(COLQ_REGEX))
        Pattern.compile(options.get(COLQ_REGEX)).matcher("""");
    if (options.containsKey(VALUE_REGEX))
        Pattern.compile(options.get(VALUE_REGEX)).matcher("""");
    return true;
}",-0.045454545454545456,-0.03349282296650732,0.2,-1.0,0.25,-0.3650793650793651,-0.006060606060606155,0.9166666666666666,-0.02631578947368421,-0.16279340490885932
wicket,remotes/origin/bugs-dot-jar_WICKET-5147_184e51e9,1,"/**
 *  Servlets and Filters are treated essentially the same with Wicket. This is the entry point
 *  for both of them.
 *
 *  @see #init(FilterConfig)
 *
 *  @param isServlet
 *             True if Servlet, false if Filter
 *  @param filterConfig
 *  @throws ServletException
 */
public void init(final boolean isServlet, final FilterConfig filterConfig) throws ServletException {
    this.filterConfig = filterConfig;
    this.isServlet = isServlet;
    initIgnorePaths(filterConfig);
    final ClassLoader previousClassLoader = Thread.currentThread().getContextClassLoader();
    final ClassLoader newClassLoader = getClassLoader();
    try {
        if (previousClassLoader != newClassLoader) {
            Thread.currentThread().setContextClassLoader(newClassLoader);
        }
        // locate application instance unless it was already specified during construction
        if (application == null) {
            applicationFactory = getApplicationFactory();
            application = applicationFactory.createApplication(this);
        }
        application.setName(filterConfig.getFilterName());
        application.setWicketFilter(this);
        // Allow the filterPath to be preset via setFilterPath()
        String configureFilterPath = getFilterPath();
        if (configureFilterPath == null) {
            configureFilterPath = getFilterPathFromConfig(filterConfig);
            if (configureFilterPath == null) {
                configureFilterPath = getFilterPathFromWebXml(isServlet, filterConfig);
                if (configureFilterPath == null) {
                    configureFilterPath = getFilterPathFromAnnotation(isServlet);
                }
            }
            if (configureFilterPath != null) {
                setFilterPath(configureFilterPath);
            }
        }
        if (getFilterPath() == null) {
            log.warn(""Unable to determine filter path from filter init-param, web.xml, "" + ""or servlet 3.0 annotations. Assuming user will set filter path "" + ""manually by calling setFilterPath(String)"");
        }
        ThreadContext.setApplication(application);
        try {
            application.initApplication();
            // Give the application the option to log that it is started
            application.logStarted();
        } finally {
            ThreadContext.detach();
        }
    } finally {
        if (newClassLoader != previousClassLoader) {
            Thread.currentThread().setContextClassLoader(previousClassLoader);
        }
    }
}","/**
 *  Servlets and Filters are treated essentially the same with Wicket. This is the entry point
 *  for both of them.
 *
 *  @see #init(FilterConfig)
 *
 *  @param isServlet
 *             True if Servlet, false if Filter
 *  @param filterConfig
 *  @throws ServletException
 */
","public void init(final boolean isServlet, final FilterConfig filterConfig) throws ServletException {
    this.filterConfig = filterConfig;
    this.isServlet = isServlet;
    initIgnorePaths(filterConfig);
    final ClassLoader previousClassLoader = Thread.currentThread().getContextClassLoader();
    final ClassLoader newClassLoader = getClassLoader();
    try {
        if (previousClassLoader != newClassLoader) {
            Thread.currentThread().setContextClassLoader(newClassLoader);
        }
                if (application == null) {
            applicationFactory = getApplicationFactory();
            application = applicationFactory.createApplication(this);
        }
        application.setName(filterConfig.getFilterName());
        application.setWicketFilter(this);
                String configureFilterPath = getFilterPath();
        if (configureFilterPath == null) {
            configureFilterPath = getFilterPathFromConfig(filterConfig);
            if (configureFilterPath == null) {
                configureFilterPath = getFilterPathFromWebXml(isServlet, filterConfig);
                if (configureFilterPath == null) {
                    configureFilterPath = getFilterPathFromAnnotation(isServlet);
                }
            }
            if (configureFilterPath != null) {
                setFilterPath(configureFilterPath);
            }
        }
        if (getFilterPath() == null) {
            log.warn(""Unable to determine filter path from filter init-param, web.xml, "" + ""or servlet 3.0 annotations. Assuming user will set filter path "" + ""manually by calling setFilterPath(String)"");
        }
        ThreadContext.setApplication(application);
        try {
            application.initApplication();
                        application.logStarted();
        } finally {
            ThreadContext.detach();
        }
    } finally {
        if (newClassLoader != previousClassLoader) {
            Thread.currentThread().setContextClassLoader(previousClassLoader);
        }
    }
}",1.4090909090909092,0.6028708133971291,1.0,1.0,0.6666666666666666,0.4682539682539683,-0.7471458773784352,1.5,-0.02631578947368421,0.9260536067264856
Closure,128,2,"static boolean isSimpleNumber(String s) {
    int len = s.length();
    for (int index = 0; index < len; index++) {
        char c = s.charAt(index);
        if (c < '0' || c > '9') {
            return false;
        }
    }
    return len > 0 && s.charAt(0) != '0';
}",,"static boolean isSimpleNumber(String s) {
    int len = s.length();
    for (int index = 0; index < len; index++) {
        char c = s.charAt(index);
        if (c < '0' || c > '9') {
            return false;
        }
    }
    return len > 0 && s.charAt(0) != '0';
}",-0.18181818181818182,0.29186602870813394,-0.2,0.0,0.08333333333333333,0.9742063492063492,0.16138125440451,-0.25,0.47368421052631576,0.33954461368233596
wicket,remotes/origin/bugs-dot-jar_WICKET-4016_f1c9cef2,1,"/**
 *  @param detailed
 *             True if a detailed string is desired
 *  @return String representation of this container
 */
@Override
public String toString(final boolean detailed) {
    final StringBuilder buffer = new StringBuilder();
    buffer.append(""["").append(this.getClass().getSimpleName()).append("" "");
    buffer.append(super.toString(detailed));
    if (detailed) {
        if (getMarkup() != null) {
            buffer.append("", markup = "").append(new MarkupStream(getMarkup()).toString());
        }
        if (children_size() != 0) {
            buffer.append("", children = "");
            // Loop through child components
            final int size = children_size();
            for (int i = 0; i < size; i++) {
                // Get next child
                final Component child = children_get(i);
                if (i != 0) {
                    buffer.append(' ');
                }
                buffer.append(child.toString());
            }
        }
    }
    buffer.append(']');
    return buffer.toString();
}","/**
 *  @param detailed
 *             True if a detailed string is desired
 *  @return String representation of this container
 */
","@Override
public String toString(final boolean detailed) {
    final StringBuilder buffer = new StringBuilder();
    buffer.append(""["").append(this.getClass().getSimpleName()).append("" "");
    buffer.append(super.toString(detailed));
    if (detailed) {
        if (getMarkup() != null) {
            buffer.append("", markup = "").append(new MarkupStream(getMarkup()).toString());
        }
        if (children_size() != 0) {
            buffer.append("", children = "");
                        final int size = children_size();
            for (int i = 0; i < size; i++) {
                                final Component child = children_get(i);
                if (i != 0) {
                    buffer.append(' ');
                }
                buffer.append(child.toString());
            }
        }
    }
    buffer.append(']');
    return buffer.toString();
}",0.45454545454545453,1.291866028708134,0.4,1.0,0.4166666666666667,0.5873015873015873,-0.3649048625792809,1.25,0.0,0.5789918339355589
Lang,30,3,"/**
 * <p>
 * Checks if the CharSequence contains any character in the given set of characters.
 * </p>
 *
 * <p>
 * A <code>null</code> CharSequence will return <code>false</code>. A <code>null</code> search CharSequence will return
 * <code>false</code>.
 * </p>
 *
 * <pre>
 * StringUtils.containsAny(null, *)            = false
 * StringUtils.containsAny("""", *)              = false
 * StringUtils.containsAny(*, null)            = false
 * StringUtils.containsAny(*, """")              = false
 * StringUtils.containsAny(""zzabyycdxx"", ""za"") = true
 * StringUtils.containsAny(""zzabyycdxx"", ""by"") = true
 * StringUtils.containsAny(""aba"",""z"")          = false
 * </pre>
 *
 * @param cs
 *            the CharSequence to check, may be null
 * @param searchChars
 *            the chars to search for, may be null
 * @return the <code>true</code> if any of the chars are found, <code>false</code> if no match or null input
 * @since 2.4
 */
public static boolean containsAny(CharSequence cs, String searchChars) {
    if (searchChars == null) {
        return false;
    }
    return containsAny(cs, searchChars.toCharArray());
}","/**
 * <p>
 * Checks if the CharSequence contains any character in the given set of characters.
 * </p>
 *
 * <p>
 * A <code>null</code> CharSequence will return <code>false</code>. A <code>null</code> search CharSequence will return
 * <code>false</code>.
 * </p>
 *
 * <pre>
 * StringUtils.containsAny(null, *)            = false
 * StringUtils.containsAny("""", *)              = false
 * StringUtils.containsAny(*, null)            = false
 * StringUtils.containsAny(*, """")              = false
 * StringUtils.containsAny(""zzabyycdxx"", ""za"") = true
 * StringUtils.containsAny(""zzabyycdxx"", ""by"") = true
 * StringUtils.containsAny(""aba"",""z"")          = false
 * </pre>
 *
 * @param cs
 *            the CharSequence to check, may be null
 * @param searchChars
 *            the chars to search for, may be null
 * @return the <code>true</code> if any of the chars are found, <code>false</code> if no match or null input
 * @since 2.4
 */
","public static boolean containsAny(CharSequence cs, String searchChars) {
    if (searchChars == null) {
        return false;
    }
    return containsAny(cs, searchChars.toCharArray());
}",-0.36363636363636365,-0.11483253588516758,-0.4,-0.5,-0.25,-0.3650793650793651,0.5836504580690626,-0.3333333333333333,0.05263157894736841,-0.16279340490885932
wicket,remotes/origin/bugs-dot-jar_WICKET-3510_292a2582,1,"/**
 *  create a new {@link DateTextField} instance to be added to this panel.
 *
 *  @param id
 *             the component id
 *  @param dateFieldModel
 *             model that should be used by the {@link DateTextField}
 *  @return a new date text field instance
 */
protected DateTextField newDateTextField(String id, PropertyModel<Date> dateFieldModel) {
    return DateTextField.forShortStyle(id, dateFieldModel);
}","/**
 *  create a new {@link DateTextField} instance to be added to this panel.
 *
 *  @param id
 *             the component id
 *  @param dateFieldModel
 *             model that should be used by the {@link DateTextField}
 *  @return a new date text field instance
 */
","protected DateTextField newDateTextField(String id, PropertyModel<Date> dateFieldModel) {
    return DateTextField.forShortStyle(id, dateFieldModel);
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.9360112755461594,-0.4166666666666667,2.552631578947368,-0.16279340490885932
maven,remotes/origin/bugs-dot-jar_MNG-5742_6ab41ee8,1,"public ExtensionRealmCache.CacheRecord setupExtensionsRealm(MavenProject project, Plugin plugin, RepositorySystemSession session) throws PluginManagerException {
    @SuppressWarnings(""unchecked"")
    Map<String, ExtensionRealmCache.CacheRecord> pluginRealms = (Map<String, ExtensionRealmCache.CacheRecord>) project.getContextValue(KEY_EXTENSIONS_REALMS);
    if (pluginRealms == null) {
        pluginRealms = new HashMap<String, ExtensionRealmCache.CacheRecord>();
        project.setContextValue(KEY_EXTENSIONS_REALMS, pluginRealms);
    }
    final String pluginKey = plugin.getId();
    ExtensionRealmCache.CacheRecord extensionRecord = pluginRealms.get(pluginKey);
    if (extensionRecord != null) {
        return extensionRecord;
    }
    final List<RemoteRepository> repositories = project.getRemotePluginRepositories();
    // resolve plugin version as necessary
    if (plugin.getVersion() == null) {
        PluginVersionRequest versionRequest = new DefaultPluginVersionRequest(plugin, session, repositories);
        try {
            plugin.setVersion(pluginVersionResolver.resolve(versionRequest).getVersion());
        } catch (PluginVersionResolutionException e) {
            throw new PluginManagerException(plugin, e.getMessage(), e);
        }
    }
    // resolve plugin artifacts
    List<Artifact> artifacts;
    PluginArtifactsCache.Key cacheKey = pluginArtifactsCache.createKey(plugin, null, repositories, session);
    PluginArtifactsCache.CacheRecord recordArtifacts;
    try {
        recordArtifacts = pluginArtifactsCache.get(cacheKey);
    } catch (PluginResolutionException e) {
        throw new PluginManagerException(plugin, e.getMessage(), e);
    }
    if (recordArtifacts != null) {
        artifacts = recordArtifacts.artifacts;
    } else {
        try {
            artifacts = resolveExtensionArtifacts(plugin, repositories, session);
            recordArtifacts = pluginArtifactsCache.put(cacheKey, artifacts);
        } catch (PluginResolutionException e) {
            pluginArtifactsCache.put(cacheKey, e);
            pluginArtifactsCache.register(project, cacheKey, recordArtifacts);
            throw new PluginManagerException(plugin, e.getMessage(), e);
        }
    }
    pluginArtifactsCache.register(project, cacheKey, recordArtifacts);
    // create and cache extensions realms
    final ExtensionRealmCache.Key extensionKey = extensionRealmCache.createKey(artifacts);
    extensionRecord = extensionRealmCache.get(extensionKey);
    if (extensionRecord == null) {
        ClassRealm extensionRealm = classRealmManager.createExtensionRealm(plugin, toAetherArtifacts(artifacts));
        PluginDescriptor pluginDescriptor = null;
        if (plugin.isExtensions() && !artifacts.isEmpty()) {
            // these errors will reported during calculation of project build execution plan
            try {
                pluginDescriptor = extractPluginDescriptor(artifacts.get(0), plugin);
            } catch (PluginDescriptorParsingException e) {
            // ignore, see above
            } catch (InvalidPluginDescriptorException e) {
            // ignore, see above
            }
        }
        discoverPluginComponents(extensionRealm, plugin, pluginDescriptor);
        ExtensionDescriptor extensionDescriptor = null;
        Artifact extensionArtifact = artifacts.get(0);
        try {
            extensionDescriptor = extensionDescriptorBuilder.build(extensionArtifact.getFile());
        } catch (IOException e) {
            String message = ""Invalid extension descriptor for "" + plugin.getId() + "": "" + e.getMessage();
            if (logger.isDebugEnabled()) {
                logger.error(message, e);
            } else {
                logger.error(message);
            }
        }
        extensionRecord = extensionRealmCache.put(extensionKey, extensionRealm, extensionDescriptor, artifacts);
    }
    extensionRealmCache.register(project, extensionKey, extensionRecord);
    pluginRealms.put(pluginKey, extensionRecord);
    return extensionRecord;
}",,"public ExtensionRealmCache.CacheRecord setupExtensionsRealm(MavenProject project, Plugin plugin, RepositorySystemSession session) throws PluginManagerException {
    @SuppressWarnings(""unchecked"")
    Map<String, ExtensionRealmCache.CacheRecord> pluginRealms = (Map<String, ExtensionRealmCache.CacheRecord>) project.getContextValue(KEY_EXTENSIONS_REALMS);
    if (pluginRealms == null) {
        pluginRealms = new HashMap<String, ExtensionRealmCache.CacheRecord>();
        project.setContextValue(KEY_EXTENSIONS_REALMS, pluginRealms);
    }
    final String pluginKey = plugin.getId();
    ExtensionRealmCache.CacheRecord extensionRecord = pluginRealms.get(pluginKey);
    if (extensionRecord != null) {
        return extensionRecord;
    }
    final List<RemoteRepository> repositories = project.getRemotePluginRepositories();
        if (plugin.getVersion() == null) {
        PluginVersionRequest versionRequest = new DefaultPluginVersionRequest(plugin, session, repositories);
        try {
            plugin.setVersion(pluginVersionResolver.resolve(versionRequest).getVersion());
        } catch (PluginVersionResolutionException e) {
            throw new PluginManagerException(plugin, e.getMessage(), e);
        }
    }
        List<Artifact> artifacts;
    PluginArtifactsCache.Key cacheKey = pluginArtifactsCache.createKey(plugin, null, repositories, session);
    PluginArtifactsCache.CacheRecord recordArtifacts;
    try {
        recordArtifacts = pluginArtifactsCache.get(cacheKey);
    } catch (PluginResolutionException e) {
        throw new PluginManagerException(plugin, e.getMessage(), e);
    }
    if (recordArtifacts != null) {
        artifacts = recordArtifacts.artifacts;
    } else {
        try {
            artifacts = resolveExtensionArtifacts(plugin, repositories, session);
            recordArtifacts = pluginArtifactsCache.put(cacheKey, artifacts);
        } catch (PluginResolutionException e) {
            pluginArtifactsCache.put(cacheKey, e);
            pluginArtifactsCache.register(project, cacheKey, recordArtifacts);
            throw new PluginManagerException(plugin, e.getMessage(), e);
        }
    }
    pluginArtifactsCache.register(project, cacheKey, recordArtifacts);
        final ExtensionRealmCache.Key extensionKey = extensionRealmCache.createKey(artifacts);
    extensionRecord = extensionRealmCache.get(extensionKey);
    if (extensionRecord == null) {
        ClassRealm extensionRealm = classRealmManager.createExtensionRealm(plugin, toAetherArtifacts(artifacts));
        PluginDescriptor pluginDescriptor = null;
        if (plugin.isExtensions() && !artifacts.isEmpty()) {
                        try {
                pluginDescriptor = extractPluginDescriptor(artifacts.get(0), plugin);
            } catch (PluginDescriptorParsingException e) {
                        } catch (InvalidPluginDescriptorException e) {
                        }
        }
        discoverPluginComponents(extensionRealm, plugin, pluginDescriptor);
        ExtensionDescriptor extensionDescriptor = null;
        Artifact extensionArtifact = artifacts.get(0);
        try {
            extensionDescriptor = extensionDescriptorBuilder.build(extensionArtifact.getFile());
        } catch (IOException e) {
            String message = ""Invalid extension descriptor for "" + plugin.getId() + "": "" + e.getMessage();
            if (logger.isDebugEnabled()) {
                logger.error(message, e);
            } else {
                logger.error(message);
            }
        }
        extensionRecord = extensionRealmCache.put(extensionKey, extensionRealm, extensionDescriptor, artifacts);
    }
    extensionRealmCache.register(project, extensionKey, extensionRecord);
    pluginRealms.put(pluginKey, extensionRecord);
    return extensionRecord;
}",2.6818181818181817,0.3444976076555023,2.6,0.5,0.8333333333333334,1.3234126984126984,-1.1773079633544747,2.75,-0.02631578947368421,6.293581830650691
wicket,remotes/origin/bugs-dot-jar_WICKET-4755_87ae870f,1,"/**
 *  @see org.apache.wicket.util.convert.IConverter#convertToObject(java.lang.String,
 *       java.util.Locale)
 */
@Override
public C convertToObject(String value, Locale locale) {
    if (value == null) {
        return null;
    }
    Class<C> theType = type.get();
    if ("""".equals(value)) {
        if (String.class.equals(theType)) {
            return theType.cast("""");
        }
        return null;
    }
    try {
        C converted = Objects.convertValue(value, theType);
        if (converted != null) {
            return converted;
        } else {
            throw new ConversionException(""Could not convert value: "" + value + "" to type: "" + theType.getName() + "". Could not find compatible converter."").setSourceValue(value);
        }
    } catch (Exception e) {
        throw new ConversionException(e.getMessage(), e).setSourceValue(value);
    }
}","/**
 *  @see org.apache.wicket.util.convert.IConverter#convertToObject(java.lang.String,
 *       java.util.Locale)
 */
","@Override
public C convertToObject(String value, Locale locale) {
    if (value == null) {
        return null;
    }
    Class<C> theType = type.get();
    if ("""".equals(value)) {
        if (String.class.equals(theType)) {
            return theType.cast("""");
        }
        return null;
    }
    try {
        C converted = Objects.convertValue(value, theType);
        if (converted != null) {
            return converted;
        } else {
            throw new ConversionException(""Could not convert value: "" + value + "" to type: "" + theType.getName() + "". Could not find compatible converter."").setSourceValue(value);
        }
    } catch (Exception e) {
        throw new ConversionException(e.getMessage(), e).setSourceValue(value);
    }
}",0.4090909090909091,0.24880382775119597,0.8,0.0,0.3333333333333333,0.371031746031746,-0.33474277660324164,0.25,-0.02631578947368421,0.3252433394996628
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-843_65390f8c,3,"@Override
public void offline(String tableName) throws AccumuloSecurityException, AccumuloException {
    throw new NotImplementedException();
}",,"@Override
public void offline(String tableName) throws AccumuloSecurityException, AccumuloException {
    throw new NotImplementedException();
}",-0.45454545454545453,-0.6028708133971293,-0.4,-1.0,-0.4166666666666667,-0.3650793650793651,0.8658210007047216,-0.5,1.4736842105263157,-0.16279340490885932
wicket,remotes/origin/bugs-dot-jar_WICKET-1886_5226978a,1,"/**
 *  Reset the request and the response back to a starting state and recreate the necessary wicket
 *  request, response and session objects. The request and response objects can be accessed and
 *  Initialized at this point.
 *
 *  @param isAjax
 *             indicates whether the request should be initialized as an ajax request (ajax
 *             header ""Wicket-Ajax"" is set)
 *  @return the constructed {@link WebRequestCycle}
 */
public WebRequestCycle setupRequestAndResponse(boolean isAjax) {
    servletRequest.initialize();
    servletResponse.initialize();
    servletRequest.setParameters(parametersForNextRequest);
    if (isAjax) {
        servletRequest.addHeader(""Wicket-Ajax"", ""Yes"");
    }
    parametersForNextRequest.clear();
    wicketRequest = application.newWebRequest(servletRequest);
    wicketResponse = application.newWebResponse(servletResponse);
    WebRequestCycle requestCycle = createRequestCycle();
    if (!initializeHttpSessionAsTemporary())
        application.getSessionStore().bind(wicketRequest, wicketSession);
    wicketResponse.setAjax(wicketRequest.isAjax());
    return requestCycle;
}","/**
 *  Reset the request and the response back to a starting state and recreate the necessary wicket
 *  request, response and session objects. The request and response objects can be accessed and
 *  Initialized at this point.
 *
 *  @param isAjax
 *             indicates whether the request should be initialized as an ajax request (ajax
 *             header ""Wicket-Ajax"" is set)
 *  @return the constructed {@link WebRequestCycle}
 */
","public WebRequestCycle setupRequestAndResponse(boolean isAjax) {
    servletRequest.initialize();
    servletResponse.initialize();
    servletRequest.setParameters(parametersForNextRequest);
    if (isAjax) {
        servletRequest.addHeader(""Wicket-Ajax"", ""Yes"");
    }
    parametersForNextRequest.clear();
    wicketRequest = application.newWebRequest(servletRequest);
    wicketResponse = application.newWebResponse(servletResponse);
    WebRequestCycle requestCycle = createRequestCycle();
    if (!initializeHttpSessionAsTemporary())
        application.getSessionStore().bind(wicketRequest, wicketSession);
    wicketResponse.setAjax(wicketRequest.isAjax());
    return requestCycle;
}",0.09090909090909091,-0.47368421052631593,-0.2,-0.5,-0.08333333333333333,-0.047619047619047616,-0.09119097956307255,0.5833333333333334,-0.02631578947368421,-0.008466889115563933
Closure,115,2,"/**
 * Determines whether a function can be inlined at a particular call site.
 * There are several criteria that the function and reference must hold in
 * order for the functions to be inlined:
 * 1) If a call's arguments have side effects,
 * the corresponding argument in the function must only be referenced once.
 * For instance, this will not be inlined:
 * <pre>
 *     function foo(a) { return a + a }
 *     x = foo(i++);
 * </pre>
 */
private CanInlineResult canInlineReferenceDirectly(Node callNode, Node fnNode) {
    if (!isDirectCallNodeReplacementPossible(fnNode)) {
        return CanInlineResult.NO;
    }
    Node block = fnNode.getLastChild();
    boolean hasSideEffects = false;
    if (block.hasChildren()) {
        Preconditions.checkState(block.hasOneChild());
        Node stmt = block.getFirstChild();
        if (stmt.isReturn()) {
            hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler);
        }
    }
    // CALL NODE: [ NAME, ARG1, ARG2, ... ]
    Node cArg = callNode.getFirstChild().getNext();
    // parameter list.
    if (!callNode.getFirstChild().isName()) {
        if (NodeUtil.isFunctionObjectCall(callNode)) {
            // TODO(johnlenz): Support replace this with a value.
            if (cArg == null || !cArg.isThis()) {
                return CanInlineResult.NO;
            }
            cArg = cArg.getNext();
        } else {
            // "".apply"" call should be filtered before this.
            Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));
        }
    }
    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]
    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();
    while (cArg != null || fnParam != null) {
        // For each named parameter check if a mutable argument use more than one.
        if (fnParam != null) {
            if (cArg != null) {
                if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {
                    return CanInlineResult.NO;
                }
                // parameter reference will be in a loop.
                if (NodeUtil.mayEffectMutableState(cArg, compiler) && NodeUtil.getNameReferenceCount(block, fnParam.getString()) > 1) {
                    return CanInlineResult.NO;
                }
            }
            // Move to the next name.
            fnParam = fnParam.getNext();
        }
        // isn't a named parameter to match.
        if (cArg != null) {
            if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {
                return CanInlineResult.NO;
            }
            cArg = cArg.getNext();
        }
    }
    return CanInlineResult.YES;
}","/**
 * Determines whether a function can be inlined at a particular call site.
 * There are several criteria that the function and reference must hold in
 * order for the functions to be inlined:
 * 1) If a call's arguments have side effects,
 * the corresponding argument in the function must only be referenced once.
 * For instance, this will not be inlined:
 * <pre>
 *     function foo(a) { return a + a }
 *     x = foo(i++);
 * </pre>
 */
","private CanInlineResult canInlineReferenceDirectly(Node callNode, Node fnNode) {
    if (!isDirectCallNodeReplacementPossible(fnNode)) {
        return CanInlineResult.NO;
    }
    Node block = fnNode.getLastChild();
    boolean hasSideEffects = false;
    if (block.hasChildren()) {
        Preconditions.checkState(block.hasOneChild());
        Node stmt = block.getFirstChild();
        if (stmt.isReturn()) {
            hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler);
        }
    }
        Node cArg = callNode.getFirstChild().getNext();
        if (!callNode.getFirstChild().isName()) {
        if (NodeUtil.isFunctionObjectCall(callNode)) {
                        if (cArg == null || !cArg.isThis()) {
                return CanInlineResult.NO;
            }
            cArg = cArg.getNext();
        } else {
                        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));
        }
    }
        Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();
    while (cArg != null || fnParam != null) {
                if (fnParam != null) {
            if (cArg != null) {
                if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {
                    return CanInlineResult.NO;
                }
                                if (NodeUtil.mayEffectMutableState(cArg, compiler) && NodeUtil.getNameReferenceCount(block, fnParam.getString()) > 1) {
                    return CanInlineResult.NO;
                }
            }
                        fnParam = fnParam.getNext();
        }
                if (cArg != null) {
            if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {
                return CanInlineResult.NO;
            }
            cArg = cArg.getNext();
        }
    }
    return CanInlineResult.YES;
}",1.4545454545454546,0.9425837320574162,2.0,1.0,2.5,1.373015873015873,-0.8260747004933048,1.75,-0.02631578947368421,2.7465661612581616
Lang,46,0,"// Java and JavaScript
// --------------------------------------------------------------------------
/**
 * <p>Escapes the characters in a <code>String</code> using Java String rules.</p>
 *
 * <p>Deals correctly with quotes and control-chars (tab, backslash, cr, ff, etc.) </p>
 *
 * <p>So a tab becomes the characters <code>'\\'</code> and
 * <code>'t'</code>.</p>
 *
 * <p>The only difference between Java strings and JavaScript strings
 * is that in JavaScript, a single quote must be escaped.</p>
 *
 * <p>Example:
 * <pre>
 * input string: He didn't say, ""Stop!""
 * output string: He didn't say, \""Stop!\""
 * </pre>
 * </p>
 *
 * @param str  String to escape values in, may be null
 * @return String with escaped values, <code>null</code> if null string input
 */
public static String escapeJava(String str) {
    return escapeJavaStyleString(str, false);
}","/**
 * <p>Escapes the characters in a <code>String</code> using Java String rules.</p>
 *
 * <p>Deals correctly with quotes and control-chars (tab, backslash, cr, ff, etc.) </p>
 *
 * <p>So a tab becomes the characters <code>'\\'</code> and
 * <code>'t'</code>.</p>
 *
 * <p>The only difference between Java strings and JavaScript strings
 * is that in JavaScript, a single quote must be escaped.</p>
 *
 * <p>Example:
 * <pre>
 * input string: He didn't say, ""Stop!""
 * output string: He didn't say, \""Stop!\""
 * </pre>
 * </p>
 *
 * @param str  String to escape values in, may be null
 * @return String with escaped values, <code>null</code> if null string input
 */
","public static String escapeJava(String str) {
    return escapeJavaStyleString(str, false);
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,1.0253699788583508,-0.4166666666666667,1.0789473684210527,-0.16279340490885932
wicket,remotes/origin/bugs-dot-jar_WICKET-4686_89184b79,1,"/**
 *  Creates a {@code IRequestHandler} that processes a listener request.
 *
 *  @param pageComponentInfo
 *  @param pageClass
 *  @param pageParameters
 *  @return a {@code IRequestHandler} that invokes the listener interface
 */
protected IRequestHandler processListener(PageComponentInfo pageComponentInfo, Class<? extends IRequestablePage> pageClass, PageParameters pageParameters) {
    PageInfo pageInfo = pageComponentInfo.getPageInfo();
    ComponentInfo componentInfo = pageComponentInfo.getComponentInfo();
    Integer renderCount = null;
    RequestListenerInterface listenerInterface = null;
    if (componentInfo != null) {
        renderCount = componentInfo.getRenderCount();
        listenerInterface = requestListenerInterfaceFromString(componentInfo.getListenerInterface());
    }
    if (listenerInterface != null) {
        // if (pageInfo.getPageId() != null)
        // {
        // // WICKET-4594 - ignore the parsed parameters for stateful pages
        // pageParameters = null;
        // }
        PageAndComponentProvider provider = new PageAndComponentProvider(pageInfo.getPageId(), pageClass, pageParameters, renderCount, componentInfo.getComponentPath());
        provider.setPageSource(getContext());
        return new ListenerInterfaceRequestHandler(provider, listenerInterface, componentInfo.getBehaviorId());
    } else {
        if (logger.isWarnEnabled()) {
            if (componentInfo != null) {
                logger.warn(""Unknown listener interface '{}'"", componentInfo.getListenerInterface());
            } else {
                logger.warn(""Cannot extract the listener interface for PageComponentInfo: '{}'"" + pageComponentInfo);
            }
        }
        return null;
    }
}","/**
 *  Creates a {@code IRequestHandler} that processes a listener request.
 *
 *  @param pageComponentInfo
 *  @param pageClass
 *  @param pageParameters
 *  @return a {@code IRequestHandler} that invokes the listener interface
 */
","protected IRequestHandler processListener(PageComponentInfo pageComponentInfo, Class<? extends IRequestablePage> pageClass, PageParameters pageParameters) {
    PageInfo pageInfo = pageComponentInfo.getPageInfo();
    ComponentInfo componentInfo = pageComponentInfo.getComponentInfo();
    Integer renderCount = null;
    RequestListenerInterface listenerInterface = null;
    if (componentInfo != null) {
        renderCount = componentInfo.getRenderCount();
        listenerInterface = requestListenerInterfaceFromString(componentInfo.getListenerInterface());
    }
    if (listenerInterface != null) {
                                                PageAndComponentProvider provider = new PageAndComponentProvider(pageInfo.getPageId(), pageClass, pageParameters, renderCount, componentInfo.getComponentPath());
        provider.setPageSource(getContext());
        return new ListenerInterfaceRequestHandler(provider, listenerInterface, componentInfo.getBehaviorId());
    } else {
        if (logger.isWarnEnabled()) {
            if (componentInfo != null) {
                logger.warn(""Unknown listener interface '{}'"", componentInfo.getListenerInterface());
            } else {
                logger.warn(""Cannot extract the listener interface for PageComponentInfo: '{}'"" + pageComponentInfo);
            }
        }
        return null;
    }
}",0.45454545454545453,0.5789473684210527,0.2,0.5,0.16666666666666666,-0.005952380952380957,-0.38971106412966877,0.6666666666666666,-0.02631578947368421,0.1837612304997032
Codec,8,1,"/**
 * Attempts to read <code>len</code> bytes into the specified <code>b</code> array starting at <code>offset</code>
 * from this InputStream.
 *
 * @param b
 *            destination byte array
 * @param offset
 *            where to start writing the bytes
 * @param len
 *            maximum number of bytes to read
 *
 * @return number of bytes read
 * @throws IOException
 *             if an I/O error occurs.
 * @throws NullPointerException
 *             if the byte array parameter is null
 * @throws IndexOutOfBoundsException
 *             if offset, len or buffer size are invalid
 */
public int read(byte[] b, int offset, int len) throws IOException {
    if (b == null) {
        throw new NullPointerException();
    } else if (offset < 0 || len < 0) {
        throw new IndexOutOfBoundsException();
    } else if (offset > b.length || offset + len > b.length) {
        throw new IndexOutOfBoundsException();
    } else if (len == 0) {
        return 0;
    } else {
        int readLen = 0;
        /*
             Rationale for while-loop on (readLen == 0):
             -----
             Base64.readResults() usually returns > 0 or EOF (-1).  In the
             rare case where it returns 0, we just keep trying.

             This is essentially an undocumented contract for InputStream
             implementors that want their code to work properly with
             java.io.InputStreamReader, since the latter hates it when
             InputStream.read(byte[]) returns a zero.  Unfortunately our
             readResults() call must return 0 if a large amount of the data
             being decoded was non-base64, so this while-loop enables proper
             interop with InputStreamReader for that scenario.
             -----
             This is a fix for CODEC-101
            */
        while (readLen == 0) {
            if (!base64.hasData()) {
                byte[] buf = new byte[doEncode ? 4096 : 8192];
                int c = in.read(buf);
                if (c > 0 && b.length == len) {
                    base64.setInitialBuffer(b, offset, len);
                }
                if (doEncode) {
                    base64.encode(buf, 0, c);
                } else {
                    base64.decode(buf, 0, c);
                }
            }
            readLen = base64.readResults(b, offset, len);
        }
        return readLen;
    }
}","/**
 * Attempts to read <code>len</code> bytes into the specified <code>b</code> array starting at <code>offset</code>
 * from this InputStream.
 *
 * @param b
 *            destination byte array
 * @param offset
 *            where to start writing the bytes
 * @param len
 *            maximum number of bytes to read
 *
 * @return number of bytes read
 * @throws IOException
 *             if an I/O error occurs.
 * @throws NullPointerException
 *             if the byte array parameter is null
 * @throws IndexOutOfBoundsException
 *             if offset, len or buffer size are invalid
 */
","public int read(byte[] b, int offset, int len) throws IOException {
    if (b == null) {
        throw new NullPointerException();
    } else if (offset < 0 || len < 0) {
        throw new IndexOutOfBoundsException();
    } else if (offset > b.length || offset + len > b.length) {
        throw new IndexOutOfBoundsException();
    } else if (len == 0) {
        return 0;
    } else {
        int readLen = 0;
                while (readLen == 0) {
            if (!base64.hasData()) {
                byte[] buf = new byte[doEncode ? 4096 : 8192];
                int c = in.read(buf);
                if (c > 0 && b.length == len) {
                    base64.setInitialBuffer(b, offset, len);
                }
                if (doEncode) {
                    base64.encode(buf, 0, c);
                } else {
                    base64.decode(buf, 0, c);
                }
            }
            readLen = base64.readResults(b, offset, len);
        }
        return readLen;
    }
}",0.6818181818181818,1.3923444976076558,1.8,2.5,1.25,1.8511904761904763,-0.5315010570824524,0.0,-0.02631578947368421,2.025195507223826
Closure,172,2,"/**
 * Determines whether a qualified name is inferred.
 * NOTE(nicksantos): Determining whether a property is declared or not
 * is really really obnoxious.
 *
 * The problem is that there are two (equally valid) coding styles:
 *
 * (function() {
 *   /* The authoritative definition of goog.bar. /
 *   goog.bar = function() {};
 * })();
 *
 * function f() {
 *   goog.bar();
 *   /* Reset goog.bar to a no-op. /
 *   goog.bar = function() {};
 * }
 *
 * In a dynamic language with first-class functions, it's very difficult
 * to know which one the user intended without looking at lots of
 * contextual information (the second example demonstrates a small case
 * of this, but there are some really pathological cases as well).
 *
 * The current algorithm checks if either the declaration has
 * JsDoc type information, or @const with a known type,
 * or a function literal with a name we haven't seen before.
 */
private boolean isQualifiedNameInferred(String qName, Node n, JSDocInfo info, Node rhsValue, JSType valueType) {
    if (valueType == null) {
        return true;
    }
    // Prototypes of constructors and interfaces are always declared.
    if (qName != null && qName.endsWith("".prototype"")) {
        return false;
    }
    boolean inferred = true;
    if (info != null) {
        inferred = !(info.hasType() || info.hasEnumParameterType() || (isConstantSymbol(info, n) && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));
    }
    if (inferred && rhsValue != null && rhsValue.isFunction()) {
        if (info != null) {
            return false;
        } else if (!scope.isDeclared(qName, false) && n.isUnscopedQualifiedName()) {
            // Functions assigned in conditional blocks are inferred.
            for (Node current = n.getParent(); !(current.isScript() || current.isFunction()); current = current.getParent()) {
                if (NodeUtil.isControlStructure(current)) {
                    return true;
                }
            }
            // Check if this is assigned in an inner scope.
            // Functions assigned in inner scopes are inferred.
            AstFunctionContents contents = getFunctionAnalysisResults(scope.getRootNode());
            if (contents == null || !contents.getEscapedQualifiedNames().contains(qName)) {
                return false;
            }
        }
    }
    return inferred;
}","/**
 * Determines whether a qualified name is inferred.
 * NOTE(nicksantos): Determining whether a property is declared or not
 * is really really obnoxious.
 *
 * The problem is that there are two (equally valid) coding styles:
 *
 * (function() {
 *   /* The authoritative definition of goog.bar. /
 *   goog.bar = function() {};
 * })();
 *
 * function f() {
 *   goog.bar();
 *   /* Reset goog.bar to a no-op. /
 *   goog.bar = function() {};
 * }
 *
 * In a dynamic language with first-class functions, it's very difficult
 * to know which one the user intended without looking at lots of
 * contextual information (the second example demonstrates a small case
 * of this, but there are some really pathological cases as well).
 *
 * The current algorithm checks if either the declaration has
 * JsDoc type information, or @const with a known type,
 * or a function literal with a name we haven't seen before.
 */
","private boolean isQualifiedNameInferred(String qName, Node n, JSDocInfo info, Node rhsValue, JSType valueType) {
    if (valueType == null) {
        return true;
    }
        if (qName != null && qName.endsWith("".prototype"")) {
        return false;
    }
    boolean inferred = true;
    if (info != null) {
        inferred = !(info.hasType() || info.hasEnumParameterType() || (isConstantSymbol(info, n) && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));
    }
    if (inferred && rhsValue != null && rhsValue.isFunction()) {
        if (info != null) {
            return false;
        } else if (!scope.isDeclared(qName, false) && n.isUnscopedQualifiedName()) {
                        for (Node current = n.getParent(); !(current.isScript() || current.isFunction()); current = current.getParent()) {
                if (NodeUtil.isControlStructure(current)) {
                    return true;
                }
            }
                                    AstFunctionContents contents = getFunctionAnalysisResults(scope.getRootNode());
            if (contents == null || !contents.getEscapedQualifiedNames().contains(qName)) {
                return false;
            }
        }
    }
    return inferred;
}",0.6363636363636364,0.9952153110047848,1.2,1.5,2.0833333333333335,0.9186507936507936,-0.5439041578576461,1.0,-0.02631578947368421,1.5969733118952527
wicket,remotes/origin/bugs-dot-jar_WICKET-5398_19e7c1cd,3,"@Override
public final String getEncoding() {
    return xmlReader.getEncoding();
}",,"@Override
public final String getEncoding() {
    return xmlReader.getEncoding();
}",-0.45454545454545453,-0.6028708133971293,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.9517970401691334,-0.4166666666666667,1.6578947368421053,-0.16279340490885932
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3903_690fb9f4,1,"/**
 * Apply the changes to the document store.
 *
 * @param baseBranchRevision the base revision of this commit. Currently only
 *                     used for branch commits.
 */
private void applyToDocumentStore(RevisionVector baseBranchRevision) {
    // the value in _revisions.<revision> property of the commit root node
    // regular commits use ""c"", which makes the commit visible to
    // other readers. branch commits use the base revision to indicate
    // the visibility of the commit
    String commitValue = baseBranchRevision != null ? baseBranchRevision.toString() : ""c"";
    DocumentStore store = nodeStore.getDocumentStore();
    String commitRootPath = null;
    if (baseBranchRevision != null) {
        // branch commits always use root node as commit root
        commitRootPath = ""/"";
    }
    ArrayList<UpdateOp> newNodes = new ArrayList<UpdateOp>();
    ArrayList<UpdateOp> changedNodes = new ArrayList<UpdateOp>();
    // operations are added to this list before they are executed,
    // so that all operations can be rolled back if there is a conflict
    ArrayList<UpdateOp> opLog = new ArrayList<UpdateOp>();
    // Compute the commit root
    for (String p : operations.keySet()) {
        markChanged(p);
        if (commitRootPath == null) {
            commitRootPath = p;
        } else {
            while (!PathUtils.isAncestor(commitRootPath, p)) {
                commitRootPath = PathUtils.getParentPath(commitRootPath);
                if (denotesRoot(commitRootPath)) {
                    break;
                }
            }
        }
    }
    // push branch changes to journal
    if (baseBranchRevision != null) {
        // store as external change
        JournalEntry doc = JOURNAL.newDocument(store);
        doc.modified(modifiedNodes);
        Revision r = revision.asBranchRevision();
        store.create(JOURNAL, singletonList(doc.asUpdateOp(r)));
    }
    int commitRootDepth = PathUtils.getDepth(commitRootPath);
    // check if there are real changes on the commit root
    boolean commitRootHasChanges = operations.containsKey(commitRootPath);
    // create a ""root of the commit"" if there is none
    UpdateOp commitRoot = getUpdateOperationForNode(commitRootPath);
    for (String p : operations.keySet()) {
        UpdateOp op = operations.get(p);
        if (op.isNew()) {
            NodeDocument.setDeleted(op, revision, false);
        }
        if (op == commitRoot) {
            if (!op.isNew() && commitRootHasChanges) {
                // commit root already exists and this is an update
                changedNodes.add(op);
            }
        } else {
            NodeDocument.setCommitRoot(op, revision, commitRootDepth);
            if (op.isNew()) {
                newNodes.add(op);
            } else {
                changedNodes.add(op);
            }
        }
    }
    if (changedNodes.size() == 0 && commitRoot.isNew()) {
        // no updates and root of commit is also new. that is,
        // it is the root of a subtree added in a commit.
        // so we try to add the root like all other nodes
        NodeDocument.setRevision(commitRoot, revision, commitValue);
        newNodes.add(commitRoot);
    }
    boolean success = false;
    try {
        if (newNodes.size() > 0) {
            // set commit root on new nodes
            if (!store.create(NODES, newNodes)) {
                // try to apply all changes one by one
                for (UpdateOp op : newNodes) {
                    if (op == commitRoot) {
                        // don't write the commit root just yet
                        // (because there might be a conflict)
                        NodeDocument.unsetRevision(commitRoot, revision);
                    }
                    changedNodes.add(op);
                }
                newNodes.clear();
            }
        }
        for (UpdateOp op : changedNodes) {
            // set commit root on changed nodes. this may even apply
            // to the commit root. the _commitRoot entry is removed
            // again when the _revisions entry is set at the end
            NodeDocument.setCommitRoot(op, revision, commitRootDepth);
            opLog.add(op);
            createOrUpdateNode(store, op);
        }
        // the revision, with the revision property set)
        if (changedNodes.size() > 0 || !commitRoot.isNew()) {
            // set revision to committed
            NodeDocument.setRevision(commitRoot, revision, commitValue);
            if (commitRootHasChanges) {
                // remove previously added commit root
                NodeDocument.removeCommitRoot(commitRoot, revision);
            }
            opLog.add(commitRoot);
            if (baseBranchRevision == null) {
                // create a clone of the commitRoot in order
                // to set isNew to false. If we get here the
                // commitRoot document already exists and
                // only needs an update
                UpdateOp commit = commitRoot.copy();
                commit.setNew(false);
                // only set revision on commit root when there is
                // no collision for this commit revision
                commit.containsMapEntry(COLLISIONS, revision, false);
                NodeDocument before = nodeStore.updateCommitRoot(commit);
                if (before == null) {
                    String msg = ""Conflicting concurrent change. "" + ""Update operation failed: "" + commitRoot;
                    NodeDocument commitRootDoc = store.find(NODES, commitRoot.getId());
                    DocumentStoreException dse;
                    if (commitRootDoc == null) {
                        dse = new DocumentStoreException(msg);
                    } else {
                        dse = new ConflictException(msg, commitRootDoc.getConflictsFor(Collections.singleton(revision)));
                    }
                    throw dse;
                } else {
                    success = true;
                    // if we get here the commit was successful and
                    // the commit revision is set on the commitRoot
                    // document for this commit.
                    // now check for conflicts/collisions by other commits.
                    // use original commitRoot operation with
                    // correct isNew flag.
                    checkConflicts(commitRoot, before);
                    checkSplitCandidate(before);
                }
            } else {
                // this is a branch commit, do not fail on collisions now
                // trying to merge the branch will fail later
                createOrUpdateNode(store, commitRoot);
            }
            operations.put(commitRootPath, commitRoot);
        }
    } catch (DocumentStoreException e) {
        // OAK-3084 do not roll back if already committed
        if (success) {
            LOG.error(""Exception occurred after commit. Rollback will be suppressed."", e);
        } else {
            rollback(newNodes, opLog, commitRoot);
            throw e;
        }
    }
}","/**
 * Apply the changes to the document store.
 *
 * @param baseBranchRevision the base revision of this commit. Currently only
 *                     used for branch commits.
 */
","private void applyToDocumentStore(RevisionVector baseBranchRevision) {
                    String commitValue = baseBranchRevision != null ? baseBranchRevision.toString() : ""c"";
    DocumentStore store = nodeStore.getDocumentStore();
    String commitRootPath = null;
    if (baseBranchRevision != null) {
                commitRootPath = ""/"";
    }
    ArrayList<UpdateOp> newNodes = new ArrayList<UpdateOp>();
    ArrayList<UpdateOp> changedNodes = new ArrayList<UpdateOp>();
            ArrayList<UpdateOp> opLog = new ArrayList<UpdateOp>();
        for (String p : operations.keySet()) {
        markChanged(p);
        if (commitRootPath == null) {
            commitRootPath = p;
        } else {
            while (!PathUtils.isAncestor(commitRootPath, p)) {
                commitRootPath = PathUtils.getParentPath(commitRootPath);
                if (denotesRoot(commitRootPath)) {
                    break;
                }
            }
        }
    }
        if (baseBranchRevision != null) {
                JournalEntry doc = JOURNAL.newDocument(store);
        doc.modified(modifiedNodes);
        Revision r = revision.asBranchRevision();
        store.create(JOURNAL, singletonList(doc.asUpdateOp(r)));
    }
    int commitRootDepth = PathUtils.getDepth(commitRootPath);
        boolean commitRootHasChanges = operations.containsKey(commitRootPath);
        UpdateOp commitRoot = getUpdateOperationForNode(commitRootPath);
    for (String p : operations.keySet()) {
        UpdateOp op = operations.get(p);
        if (op.isNew()) {
            NodeDocument.setDeleted(op, revision, false);
        }
        if (op == commitRoot) {
            if (!op.isNew() && commitRootHasChanges) {
                                changedNodes.add(op);
            }
        } else {
            NodeDocument.setCommitRoot(op, revision, commitRootDepth);
            if (op.isNew()) {
                newNodes.add(op);
            } else {
                changedNodes.add(op);
            }
        }
    }
    if (changedNodes.size() == 0 && commitRoot.isNew()) {
                                NodeDocument.setRevision(commitRoot, revision, commitValue);
        newNodes.add(commitRoot);
    }
    boolean success = false;
    try {
        if (newNodes.size() > 0) {
                        if (!store.create(NODES, newNodes)) {
                                for (UpdateOp op : newNodes) {
                    if (op == commitRoot) {
                                                                        NodeDocument.unsetRevision(commitRoot, revision);
                    }
                    changedNodes.add(op);
                }
                newNodes.clear();
            }
        }
        for (UpdateOp op : changedNodes) {
                                                NodeDocument.setCommitRoot(op, revision, commitRootDepth);
            opLog.add(op);
            createOrUpdateNode(store, op);
        }
                if (changedNodes.size() > 0 || !commitRoot.isNew()) {
                        NodeDocument.setRevision(commitRoot, revision, commitValue);
            if (commitRootHasChanges) {
                                NodeDocument.removeCommitRoot(commitRoot, revision);
            }
            opLog.add(commitRoot);
            if (baseBranchRevision == null) {
                                                                                UpdateOp commit = commitRoot.copy();
                commit.setNew(false);
                                                commit.containsMapEntry(COLLISIONS, revision, false);
                NodeDocument before = nodeStore.updateCommitRoot(commit);
                if (before == null) {
                    String msg = ""Conflicting concurrent change. "" + ""Update operation failed: "" + commitRoot;
                    NodeDocument commitRootDoc = store.find(NODES, commitRoot.getId());
                    DocumentStoreException dse;
                    if (commitRootDoc == null) {
                        dse = new DocumentStoreException(msg);
                    } else {
                        dse = new ConflictException(msg, commitRootDoc.getConflictsFor(Collections.singleton(revision)));
                    }
                    throw dse;
                } else {
                    success = true;
                                                                                                                                            checkConflicts(commitRoot, before);
                    checkSplitCandidate(before);
                }
            } else {
                                                createOrUpdateNode(store, commitRoot);
            }
            operations.put(commitRootPath, commitRoot);
        }
    } catch (DocumentStoreException e) {
                if (success) {
            LOG.error(""Exception occurred after commit. Rollback will be suppressed."", e);
        } else {
            rollback(newNodes, opLog, commitRoot);
            throw e;
        }
    }
}",4.454545454545454,1.325358851674641,5.0,1.5,2.9166666666666665,1.9642857142857144,-1.4851303735024661,4.25,-0.02631578947368421,11.09189444626937
Closure,154,2,"/**
 * Expect that the peroperty in an interface that this type implements is
 * implemented and correctly typed.
 */
private void expectInterfaceProperty(NodeTraversal t, Node n, ObjectType instance, ObjectType implementedInterface, String prop) {
    if (!instance.hasProperty(prop)) {
        // Not implemented
        String sourceName = (String) n.getProp(Node.SOURCENAME_PROP);
        sourceName = sourceName == null ? """" : sourceName;
        if (shouldReport) {
            compiler.report(JSError.make(sourceName, n, INTERFACE_METHOD_NOT_IMPLEMENTED, prop, implementedInterface.toString(), instance.toString()));
        }
        registerMismatch(instance, implementedInterface);
    // Implemented, but not correctly typed
    }
}","/**
 * Expect that the peroperty in an interface that this type implements is
 * implemented and correctly typed.
 */
","private void expectInterfaceProperty(NodeTraversal t, Node n, ObjectType instance, ObjectType implementedInterface, String prop) {
    if (!instance.hasProperty(prop)) {
                String sourceName = (String) n.getProp(Node.SOURCENAME_PROP);
        sourceName = sourceName == null ? """" : sourceName;
        if (shouldReport) {
            compiler.report(JSError.make(sourceName, n, INTERFACE_METHOD_NOT_IMPLEMENTED, prop, implementedInterface.toString(), instance.toString()));
        }
        registerMismatch(instance, implementedInterface);
        }
}",-0.18181818181818182,0.3349282296650717,0.0,0.0,0.16666666666666666,-0.02380952380952383,0.10556730091613822,0.08333333333333333,0.02631578947368421,0.01637823228044696
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-766_6fc5ea9d,1,"@Override
public TreeImpl getChild(@Nonnull String name) {
    checkNotNull(name);
    enter();
    TreeImpl child = internalGetChild(name);
    if (child != null && canRead(child)) {
        return child;
    } else {
        return null;
    }
}",,"@Override
public TreeImpl getChild(@Nonnull String name) {
    checkNotNull(name);
    enter();
    TreeImpl child = internalGetChild(name);
    if (child != null && canRead(child)) {
        return child;
    } else {
        return null;
    }
}",-0.13636363636363635,-0.15311004784689008,-0.4,-0.5,-0.08333333333333333,-0.059523809523809534,0.20676532769556044,-0.16666666666666666,1.6052631578947367,-0.09753865481809328
Cli,1,1,"/**
 * Returns an array of the processed {@link Option}s.
 *
 * @return an array of the processed {@link Option}s.
 */
public Option[] getOptions() {
    Collection processed = options.values();
    // reinitialise array
    Option[] optionsArray = new Option[processed.size()];
    // return the array
    return (Option[]) processed.toArray(optionsArray);
}","/**
 * Returns an array of the processed {@link Option}s.
 *
 * @return an array of the processed {@link Option}s.
 */
","public Option[] getOptions() {
    Collection processed = options.values();
        Option[] optionsArray = new Option[processed.size()];
        return (Option[]) processed.toArray(optionsArray);
}",-0.4090909090909091,-0.49282296650717716,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.6304439746300209,-0.25,2.526315789473684,-0.16279340490885932
wicket,remotes/origin/bugs-dot-jar_WICKET-4777_eccb3b11,3,"/**
 *  @param response
 *  @param id
 */
public static void writeOpenTag(final Response response, String id) {
    response.write(""<script type=\""text/javascript\"" "");
    if (id != null) {
        response.write(""id=\"""" + id + ""\"""");
    }
    response.write("">"");
    response.write(SCRIPT_CONTENT_PREFIX);
}","/**
 *  @param response
 *  @param id
 */
","public static void writeOpenTag(final Response response, String id) {
    response.write(""<script type=\""text/javascript\"" "");
    if (id != null) {
        response.write(""id=\"""" + id + ""\"""");
    }
    response.write("">"");
    response.write(SCRIPT_CONTENT_PREFIX);
}",-0.2727272727272727,-0.2822966507177035,-0.4,-0.5,-0.25,-0.029761904761904788,0.34940098661028873,-0.16666666666666666,2.0,-0.08963653233288958
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2389_7c320b1e,1,"/**
 * Escape a string into the target buffer.
 *
 * @param s      the string to escape
 * @param length the number of characters.
 * @param buff   the target buffer
 */
public static void escape(String s, int length, StringBuilder buff) {
    // needs more time, memory, and storage space
    for (int i = 0; i < length; i++) {
        char c = s.charAt(i);
        switch(c) {
            case '""':
                // quotation mark
                buff.append(""\\\"""");
                break;
            case '\\':
                // backslash
                buff.append(""\\\\"");
                break;
            case '\b':
                // backspace
                buff.append(""\\b"");
                break;
            case '\f':
                // formfeed
                buff.append(""\\f"");
                break;
            case '\n':
                // newline
                buff.append(""\\n"");
                break;
            case '\r':
                // carriage return
                buff.append(""\\r"");
                break;
            case '\t':
                // horizontal tab
                buff.append(""\\t"");
                break;
            default:
                if (c < ' ') {
                    // guaranteed to be 1 or 2 hex digits only
                    buff.append(""\\u00"");
                    String hex = Integer.toHexString(c);
                    if (hex.length() == 1) {
                        buff.append('0');
                    }
                    buff.append(hex);
                } else if (c >= 127) {
                    // ascii only mode
                    buff.append(""\\u"");
                    String hex = Integer.toHexString(c);
                    for (int len = hex.length(); len < 4; len++) {
                        buff.append('0');
                    }
                    buff.append(hex);
                } else {
                    buff.append(c);
                }
        }
    }
}","/**
 * Escape a string into the target buffer.
 *
 * @param s      the string to escape
 * @param length the number of characters.
 * @param buff   the target buffer
 */
","public static void escape(String s, int length, StringBuilder buff) {
        for (int i = 0; i < length; i++) {
        char c = s.charAt(i);
        switch(c) {
            case '""':
                                buff.append(""\\\"""");
                break;
            case '\\':
                                buff.append(""\\\\"");
                break;
            case '\b':
                                buff.append(""\\b"");
                break;
            case '\f':
                                buff.append(""\\f"");
                break;
            case '\n':
                                buff.append(""\\n"");
                break;
            case '\r':
                                buff.append(""\\r"");
                break;
            case '\t':
                                buff.append(""\\t"");
                break;
            default:
                if (c < ' ') {
                                        buff.append(""\\u00"");
                    String hex = Integer.toHexString(c);
                    if (hex.length() == 1) {
                        buff.append('0');
                    }
                    buff.append(hex);
                } else if (c >= 127) {
                                        buff.append(""\\u"");
                    String hex = Integer.toHexString(c);
                    for (int len = hex.length(); len < 4; len++) {
                        buff.append('0');
                    }
                    buff.append(hex);
                } else {
                    buff.append(c);
                }
        }
    }
}",1.4545454545454546,1.1770334928229667,3.4,2.0,1.0,0.6150793650793652,-0.829457364341085,1.0833333333333333,-0.02631578947368421,1.0707030191963023
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-821_a450ac2f,1,"@SuppressWarnings(""unchecked"")
@Override
public Iterator<Entry<Key, Value>> iterator() {
    if (ranges == null) {
        throw new IllegalStateException(""ranges not set"");
    }
    IteratorChain chain = new IteratorChain();
    for (Range range : ranges) {
        SortedKeyValueIterator<Key, Value> i = new SortedMapIterator(table.table);
        try {
            i = new RangesFilter(createFilter(i), ranges);
            i.seek(range, createColumnBSS(fetchedColumns), !fetchedColumns.isEmpty());
            chain.addIterator(new IteratorAdapter(i));
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
    return chain;
}",,"@SuppressWarnings(""unchecked"")
@Override
public Iterator<Entry<Key, Value>> iterator() {
    if (ranges == null) {
        throw new IllegalStateException(""ranges not set"");
    }
    IteratorChain chain = new IteratorChain();
    for (Range range : ranges) {
        SortedKeyValueIterator<Key, Value> i = new SortedMapIterator(table.table);
        try {
            i = new RangesFilter(createFilter(i), ranges);
            i.seek(range, createColumnBSS(fetchedColumns), !fetchedColumns.isEmpty());
            chain.addIterator(new IteratorAdapter(i));
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
    return chain;
}",0.22727272727272727,0.5693779904306218,0.4,0.0,-0.25,-0.07341269841269843,-0.22480620155038739,-0.08333333333333333,-0.02631578947368421,0.017816658310425695
Closure,44,2,"void add(String newcode) {
    maybeEndStatement();
    if (newcode.length() == 0) {
        return;
    }
    char c = newcode.charAt(0);
    if ((isWordChar(c) || c == '\\') && isWordChar(getLastChar())) {
        // need space to separate. This is not pretty printing.
        // For example: ""return foo;""
        append("" "");
    // Do not allow a forward slash to appear after a DIV.
    // For example,
    // REGEXP DIV REGEXP
    // is valid and should print like
    // / // / /
    }
    append(newcode);
}",,"void add(String newcode) {
    maybeEndStatement();
    if (newcode.length() == 0) {
        return;
    }
    char c = newcode.charAt(0);
    if ((isWordChar(c) || c == '\\') && isWordChar(getLastChar())) {
                        append("" "");
                        }
    append(newcode);
}",-0.13636363636363635,-0.2775119617224881,-0.2,-0.5,0.3333333333333333,0.25793650793650796,0.17068357998590572,0.16666666666666666,2.3947368421052633,0.0003434703180558217
wicket,remotes/origin/bugs-dot-jar_WICKET-4616_dd1df04b,1,"/**
 *  Calls onError on this {@link Form} and any enabled and visible nested form, if the respective
 *  {@link Form} actually has errors.
 *
 *  @param submitter
 */
protected void callOnError(IFormSubmitter submitter) {
    if (submitter != null) {
        submitter.onError();
    }
    onError();
    // call onError on nested forms
    visitChildren(Form.class, new IVisitor<Component, Void>() {

        @Override
        public void component(final Component component, final IVisit<Void> visit) {
            final Form<?> form = (Form<?>) component;
            if (!form.isEnabledInHierarchy() || !form.isVisibleInHierarchy()) {
                visit.dontGoDeeper();
                return;
            }
            if (form.hasError()) {
                form.onError();
            }
        }
    });
}","/**
 *  Calls onError on this {@link Form} and any enabled and visible nested form, if the respective
 *  {@link Form} actually has errors.
 *
 *  @param submitter
 */
","protected void callOnError(IFormSubmitter submitter) {
    if (submitter != null) {
        submitter.onError();
    }
    onError();
        visitChildren(Form.class, new IVisitor<Component, Void>() {

        @Override
        public void component(final Component component, final IVisit<Void> visit) {
            final Form<?> form = (Form<?>) component;
            if (!form.isEnabledInHierarchy() || !form.isVisibleInHierarchy()) {
                visit.dontGoDeeper();
                return;
            }
            if (form.hasError()) {
                form.onError();
            }
        }
    });
}",0.22727272727272727,0.9665071770334926,0.0,0.0,0.25,0.32936507936507936,-0.1568710359408033,0.16666666666666666,0.05263157894736841,0.13313969906006692
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-492_61ccbb95,3,"/**
 * Unregisters all MBeans associated with the specified logger context
 * (including MBeans for {@code LoggerConfig}s and {@code Appender}s from
 * the platform MBean server.
 *
 * @param loggerContextName name of the logger context to unregister
 * @param mbs the MBean Server to unregister the instrumented objects from
 */
public static void unregisterContext(String contextName, MBeanServer mbs) {
    final String pattern = LoggerContextAdminMBean.PATTERN;
    final String search = String.format(pattern, contextName, ""*"");
    // unregister context mbean
    unregisterAllMatching(search, mbs);
    unregisterLoggerConfigs(contextName, mbs);
    unregisterAppenders(contextName, mbs);
    unregisterAsyncAppenders(contextName, mbs);
    unregisterAsyncLoggerRingBufferAdmins(contextName, mbs);
    unregisterAsyncLoggerConfigRingBufferAdmins(contextName, mbs);
}","/**
 * Unregisters all MBeans associated with the specified logger context
 * (including MBeans for {@code LoggerConfig}s and {@code Appender}s from
 * the platform MBean server.
 *
 * @param loggerContextName name of the logger context to unregister
 * @param mbs the MBean Server to unregister the instrumented objects from
 */
","public static void unregisterContext(String contextName, MBeanServer mbs) {
    final String pattern = LoggerContextAdminMBean.PATTERN;
    final String search = String.format(pattern, contextName, ""*"");
        unregisterAllMatching(search, mbs);
    unregisterLoggerConfigs(contextName, mbs);
    unregisterAppenders(contextName, mbs);
    unregisterAsyncAppenders(contextName, mbs);
    unregisterAsyncLoggerRingBufferAdmins(contextName, mbs);
    unregisterAsyncLoggerConfigRingBufferAdmins(contextName, mbs);
}",-0.18181818181818182,-0.6650717703349284,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.1782945736434109,0.08333333333333333,0.02631578947368421,-0.16279340490885932
wicket,remotes/origin/bugs-dot-jar_WICKET-2281_6e0b40bc,1,"/**
 *  Initialize the request parameters to point to the given component.
 *
 *  @param component
 *             The component
 */
public void setRequestToComponent(final Component component) {
    final IPageMap pageMap = component.getPage().getPageMap();
    final String pageMapName = pageMap.isDefault() ? """" : pageMap.getName();
    if (component instanceof BookmarkablePageLink) {
        final Class<? extends Page> clazz = ((BookmarkablePageLink<?>) component).getPageClass();
        parameters.put(WebRequestCodingStrategy.BOOKMARKABLE_PAGE_PARAMETER_NAME, pageMapName + ':' + clazz.getName());
    } else {
        int version = component.getPage().getCurrentVersionNumber();
        Class<?> clazz = null;
        if (component instanceof IRedirectListener) {
            clazz = IRedirectListener.class;
        } else if (component instanceof IResourceListener) {
            clazz = IResourceListener.class;
        } else if (component instanceof IFormSubmitListener) {
            clazz = IFormSubmitListener.class;
        } else if (component instanceof ILinkListener) {
            clazz = ILinkListener.class;
        } else if (component instanceof IOnChangeListener) {
            clazz = IOnChangeListener.class;
        } else {
            throw new IllegalArgumentException(""The component class doesn't seem to implement any of the known *Listener interfaces: "" + component.getClass());
        }
        // manually create the url using default strategy and format
        parameters.put(WebRequestCodingStrategy.INTERFACE_PARAMETER_NAME, pageMapName + ':' + component.getPath() + ':' + (version == 0 ? """" : """" + version) + ':' + Classes.simpleName(clazz) + ""::"");
        try {
            RequestListenerInterface rli = (RequestListenerInterface) clazz.getField(""INTERFACE"").get(clazz);
            String auto = component.getRequestCycle().urlFor(component, rli).toString();
            int idx = auto.indexOf(WebRequestCodingStrategy.INTERFACE_PARAMETER_NAME);
            if (idx >= 0) {
                auto = auto.substring(idx + WebRequestCodingStrategy.INTERFACE_PARAMETER_NAME.length() + 1);
            } else {
                // additional check for crypted strategy
                idx = auto.indexOf(""x=6*"");
                if (idx >= 0) {
                    auto = auto.substring(idx + 4);
                }
            }
            idx = auto.indexOf(""&"");
            if (idx >= 0) {
                auto = auto.substring(0, idx);
            }
            parameters.put(WebRequestCodingStrategy.INTERFACE_PARAMETER_NAME, auto);
        } catch (Exception e) {
        // noop
        }
        if (component.isStateless() && component.getPage().isBookmarkable()) {
            parameters.put(WebRequestCodingStrategy.BOOKMARKABLE_PAGE_PARAMETER_NAME, pageMapName + ':' + component.getPage().getClass().getName());
        }
    }
}","/**
 *  Initialize the request parameters to point to the given component.
 *
 *  @param component
 *             The component
 */
","public void setRequestToComponent(final Component component) {
    final IPageMap pageMap = component.getPage().getPageMap();
    final String pageMapName = pageMap.isDefault() ? """" : pageMap.getName();
    if (component instanceof BookmarkablePageLink) {
        final Class<? extends Page> clazz = ((BookmarkablePageLink<?>) component).getPageClass();
        parameters.put(WebRequestCodingStrategy.BOOKMARKABLE_PAGE_PARAMETER_NAME, pageMapName + ':' + clazz.getName());
    } else {
        int version = component.getPage().getCurrentVersionNumber();
        Class<?> clazz = null;
        if (component instanceof IRedirectListener) {
            clazz = IRedirectListener.class;
        } else if (component instanceof IResourceListener) {
            clazz = IResourceListener.class;
        } else if (component instanceof IFormSubmitListener) {
            clazz = IFormSubmitListener.class;
        } else if (component instanceof ILinkListener) {
            clazz = ILinkListener.class;
        } else if (component instanceof IOnChangeListener) {
            clazz = IOnChangeListener.class;
        } else {
            throw new IllegalArgumentException(""The component class doesn't seem to implement any of the known *Listener interfaces: "" + component.getClass());
        }
                parameters.put(WebRequestCodingStrategy.INTERFACE_PARAMETER_NAME, pageMapName + ':' + component.getPath() + ':' + (version == 0 ? """" : """" + version) + ':' + Classes.simpleName(clazz) + ""::"");
        try {
            RequestListenerInterface rli = (RequestListenerInterface) clazz.getField(""INTERFACE"").get(clazz);
            String auto = component.getRequestCycle().urlFor(component, rli).toString();
            int idx = auto.indexOf(WebRequestCodingStrategy.INTERFACE_PARAMETER_NAME);
            if (idx >= 0) {
                auto = auto.substring(idx + WebRequestCodingStrategy.INTERFACE_PARAMETER_NAME.length() + 1);
            } else {
                                idx = auto.indexOf(""x=6*"");
                if (idx >= 0) {
                    auto = auto.substring(idx + 4);
                }
            }
            idx = auto.indexOf(""&"");
            if (idx >= 0) {
                auto = auto.substring(0, idx);
            }
            parameters.put(WebRequestCodingStrategy.INTERFACE_PARAMETER_NAME, auto);
        } catch (Exception e) {
                }
        if (component.isStateless() && component.getPage().isBookmarkable()) {
            parameters.put(WebRequestCodingStrategy.BOOKMARKABLE_PAGE_PARAMETER_NAME, pageMapName + ':' + component.getPage().getClass().getName());
        }
    }
}",1.5,0.535885167464115,2.2,2.0,1.1666666666666667,0.6567460317460319,-0.9083861874559546,2.25,-0.02631578947368421,2.5196267929899783
wicket,remotes/origin/bugs-dot-jar_WICKET-2337_36a41358,1,"/**
 *  @see org.apache.wicket.util.lang.PropertyResolver.IGetAndSet#getValue(java.lang.Object)
 */
public Object getValue(Object object) {
    return ((List<?>) object).get(index);
}","/**
 *  @see org.apache.wicket.util.lang.PropertyResolver.IGetAndSet#getValue(java.lang.Object)
 */
","public Object getValue(Object object) {
    return ((List<?>) object).get(index);
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.9960535588442565,-0.4166666666666667,1.4210526315789473,-0.16279340490885932
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-143_1461f1f6,1,"/**
 * {@inheritDoc}
 */
@Override
public void format(final LogEvent event, final StringBuilder toAppendTo) {
    final Message msg = event.getMessage();
    if (msg != null) {
        String result;
        if (msg instanceof MultiformatMessage) {
            result = ((MultiformatMessage) msg).getFormattedMessage(formats);
        } else {
            result = msg.getFormattedMessage();
        }
        toAppendTo.append(config != null && result.contains(""${"") ? config.getSubst().replace(event, result) : result);
    }
}","/**
 * {@inheritDoc}
 */
","@Override
public void format(final LogEvent event, final StringBuilder toAppendTo) {
    final Message msg = event.getMessage();
    if (msg != null) {
        String result;
        if (msg instanceof MultiformatMessage) {
            result = ((MultiformatMessage) msg).getFormattedMessage(formats);
        } else {
            result = msg.getFormattedMessage();
        }
        toAppendTo.append(config != null && result.contains(""${"") ? config.getSubst().replace(event, result) : result);
    }
}",-0.045454545454545456,0.5023923444976076,0.0,0.0,0.16666666666666666,-0.021825396825396845,0.0007047216349543532,0.08333333333333333,0.07894736842105263,-8.068094719432529e-05
wicket,remotes/origin/bugs-dot-jar_WICKET-3998_b76f9c44,3,"/**
 *  Check if the credit card is a Visa. A Visa number has to start with a 4 and has to have a
 *  length of 13 or 16 digits. The number has to be validated with the Luhn algorithm.
 *
 *  @param creditCardNumber
 *             the credit card number as a string
 *  @return The credit card id of the issuer
 */
private CreditCard isVisa(String creditCardNumber) {
    if (creditCardNumber.length() == 13 || creditCardNumber.length() == 16) {
        if (creditCardNumber.startsWith(""4"")) {
            return CreditCard.SWITCH;
        }
    }
    return CreditCard.INVALID;
}","/**
 *  Check if the credit card is a Visa. A Visa number has to start with a 4 and has to have a
 *  length of 13 or 16 digits. The number has to be validated with the Luhn algorithm.
 *
 *  @param creditCardNumber
 *             the credit card number as a string
 *  @return The credit card id of the issuer
 */
","private CreditCard isVisa(String creditCardNumber) {
    if (creditCardNumber.length() == 13 || creditCardNumber.length() == 16) {
        if (creditCardNumber.startsWith(""4"")) {
            return CreditCard.SWITCH;
        }
    }
    return CreditCard.INVALID;
}",-0.2727272727272727,0.42105263157894735,-0.2,0.0,0.0,-0.06746031746031747,0.3663143058491896,-0.25,1.894736842105263,-0.10750159921163187
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1250_0c3b3306,1,"@Override
@Nonnull
public synchronized String checkpoint(long lifetime) {
    checkArgument(lifetime > 0);
    // TODO: Guard the checkpoint from garbage collection
    return head.getRecordId().toString();
}",,"@Override
@Nonnull
public synchronized String checkpoint(long lifetime) {
    checkArgument(lifetime > 0);
        return head.getRecordId().toString();
}",-0.36363636363636365,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.5898520084566594,-0.25,2.1052631578947367,-0.16279340490885932
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2336_d0f6715d,1,"/**
 * Returns a {@link DocumentNodeState} as seen at the given
 * <code>readRevision</code>.
 *
 * @param nodeStore    the node store.
 * @param readRevision the read revision.
 * @param lastModified the revision when this node was last modified, but
 *                     the value is potentially not yet reflected in this
 *                     document.
 *                     See {@link RevisionContext#getPendingModifications()}.
 * @return the node or <code>null</code> if the node doesn't exist at the
 *         given read revision.
 */
@CheckForNull
public DocumentNodeState getNodeAtRevision(@Nonnull DocumentNodeStore nodeStore, @Nonnull Revision readRevision, @Nullable Revision lastModified) {
    Map<Revision, String> validRevisions = Maps.newHashMap();
    Branch branch = nodeStore.getBranches().getBranch(readRevision);
    LastRevs lastRevs = new LastRevs(getLastRev(), readRevision, branch);
    // overlay with unsaved last modified from this instance
    lastRevs.update(lastModified);
    Revision min = getLiveRevision(nodeStore, readRevision, validRevisions, lastRevs);
    if (min == null) {
        // deleted
        return null;
    }
    String path = getPath();
    DocumentNodeState n = new DocumentNodeState(nodeStore, path, readRevision, hasChildren());
    Revision lastRevision = min;
    for (String key : keySet()) {
        if (!Utils.isPropertyName(key)) {
            continue;
        }
        // first check local map, which contains most recent values
        Value value = getLatestValue(nodeStore, getLocalMap(key), min, readRevision, validRevisions, lastRevs);
        // check if there may be more recent values in a previous document
        if (value != null && !getPreviousRanges().isEmpty()) {
            Revision newest = getLocalMap(key).firstKey();
            if (!value.revision.equals(newest)) {
                // not reading the most recent value, we may need to
                // consider previous documents as well
                Revision newestPrev = getPreviousRanges().firstKey();
                if (isRevisionNewer(nodeStore, newestPrev, value.revision)) {
                    // a previous document has more recent changes
                    // than value.revision
                    value = null;
                }
            }
        }
        if (value == null && !getPreviousRanges().isEmpty()) {
            // check complete revision history
            value = getLatestValue(nodeStore, getValueMap(key), min, readRevision, validRevisions, lastRevs);
        }
        String propertyName = Utils.unescapePropertyName(key);
        String v = value != null ? value.value : null;
        n.setProperty(propertyName, v);
        // keep track of when this node was last modified
        if (value != null && isRevisionNewer(nodeStore, value.revision, lastRevision)) {
            lastRevision = value.revision;
        }
    }
    // lastRevision now points to the revision when this node was
    // last modified directly. but it may also have been 'modified'
    // by an operation on a descendant node, which is tracked in
    // _lastRev.
    // when was this node last modified?
    Revision branchBase = null;
    if (branch != null) {
        branchBase = branch.getBase(readRevision);
    }
    for (Revision r : lastRevs.get().values()) {
        // ignore if newer than readRevision
        if (isRevisionNewer(nodeStore, r, readRevision)) {
            // the node has a _lastRev which is newer than readRevision
            // this means we don't know when this node was
            // modified by an operation on a descendant node between
            // current lastRevision and readRevision. therefore we have
            // to stay on the safe side and use readRevision
            lastRevision = readRevision;
            continue;
        } else if (branchBase != null && isRevisionNewer(nodeStore, r, branchBase)) {
            // readRevision is on a branch and the node has a
            // _lastRev which is newer than the base of the branch
            // we cannot use this _lastRev because it is not visible
            // from this branch. highest possible revision of visible
            // changes is the base of the branch
            r = branchBase;
        }
        if (revisionAreAmbiguous(nodeStore, r, lastRevision)) {
            // _lastRev entries from multiple cluster nodes are ambiguous
            // use readRevision to make sure read is consistent
            lastRevision = readRevision;
        } else if (isRevisionNewer(nodeStore, r, lastRevision)) {
            lastRevision = r;
        }
    }
    if (branch != null) {
        // read from a branch
        // -> possibly overlay with unsaved last revs from branch
        lastRevs.updateBranch(branch.getUnsavedLastRevision(path, readRevision));
        Revision r = lastRevs.getBranchRevision();
        if (r != null) {
            lastRevision = r;
        }
    }
    n.setLastRevision(lastRevision);
    return n;
}","/**
 * Returns a {@link DocumentNodeState} as seen at the given
 * <code>readRevision</code>.
 *
 * @param nodeStore    the node store.
 * @param readRevision the read revision.
 * @param lastModified the revision when this node was last modified, but
 *                     the value is potentially not yet reflected in this
 *                     document.
 *                     See {@link RevisionContext#getPendingModifications()}.
 * @return the node or <code>null</code> if the node doesn't exist at the
 *         given read revision.
 */
","@CheckForNull
public DocumentNodeState getNodeAtRevision(@Nonnull DocumentNodeStore nodeStore, @Nonnull Revision readRevision, @Nullable Revision lastModified) {
    Map<Revision, String> validRevisions = Maps.newHashMap();
    Branch branch = nodeStore.getBranches().getBranch(readRevision);
    LastRevs lastRevs = new LastRevs(getLastRev(), readRevision, branch);
        lastRevs.update(lastModified);
    Revision min = getLiveRevision(nodeStore, readRevision, validRevisions, lastRevs);
    if (min == null) {
                return null;
    }
    String path = getPath();
    DocumentNodeState n = new DocumentNodeState(nodeStore, path, readRevision, hasChildren());
    Revision lastRevision = min;
    for (String key : keySet()) {
        if (!Utils.isPropertyName(key)) {
            continue;
        }
                Value value = getLatestValue(nodeStore, getLocalMap(key), min, readRevision, validRevisions, lastRevs);
                if (value != null && !getPreviousRanges().isEmpty()) {
            Revision newest = getLocalMap(key).firstKey();
            if (!value.revision.equals(newest)) {
                                                Revision newestPrev = getPreviousRanges().firstKey();
                if (isRevisionNewer(nodeStore, newestPrev, value.revision)) {
                                                            value = null;
                }
            }
        }
        if (value == null && !getPreviousRanges().isEmpty()) {
                        value = getLatestValue(nodeStore, getValueMap(key), min, readRevision, validRevisions, lastRevs);
        }
        String propertyName = Utils.unescapePropertyName(key);
        String v = value != null ? value.value : null;
        n.setProperty(propertyName, v);
                if (value != null && isRevisionNewer(nodeStore, value.revision, lastRevision)) {
            lastRevision = value.revision;
        }
    }
                        Revision branchBase = null;
    if (branch != null) {
        branchBase = branch.getBase(readRevision);
    }
    for (Revision r : lastRevs.get().values()) {
                if (isRevisionNewer(nodeStore, r, readRevision)) {
                                                                        lastRevision = readRevision;
            continue;
        } else if (branchBase != null && isRevisionNewer(nodeStore, r, branchBase)) {
                                                                        r = branchBase;
        }
        if (revisionAreAmbiguous(nodeStore, r, lastRevision)) {
                                    lastRevision = readRevision;
        } else if (isRevisionNewer(nodeStore, r, lastRevision)) {
            lastRevision = r;
        }
    }
    if (branch != null) {
                        lastRevs.updateBranch(branch.getUnsavedLastRevision(path, readRevision));
        Revision r = lastRevs.getBranchRevision();
        if (r != null) {
            lastRevision = r;
        }
    }
    n.setLastRevision(lastRevision);
    return n;
}",2.272727272727273,0.5023923444976076,3.2,1.0,2.9166666666666665,0.8690476190476191,-1.1169837914023957,2.6666666666666665,-0.02631578947368421,3.958435481175406
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2049_4af0d4ee,0,"/**
 * Before writing a record (which are written backwards, from the end of the
 * file to the beginning), this method is called, to ensure there is enough
 * space. A new segment is also created if there is not enough space in the
 * segment lookup table or elsewhere.
 * <p>
 * This method does not actually write into the segment, just allocates the
 * space (flushing the segment if needed and starting a new one), and sets
 * the write position (records are written from the end to the beginning,
 * but within a record from left to right).
 *
 * @param type the record type (only used for root records)
 * @param size the size of the record, excluding the size used for the
 *            record ids
 * @param ids the record ids
 * @return a new record id
 */
private RecordId prepare(RecordType type, int size, Collection<RecordId> ids) {
    checkArgument(size >= 0);
    checkNotNull(ids);
    int idcount = ids.size();
    int recordSize = align(size + idcount * RECORD_ID_BYTES);
    // First compute the header and segment sizes based on the assumption
    // that *all* identifiers stored in this record point to previously
    // unreferenced segments.
    int refcount = segment.getRefCount() + idcount;
    int blobrefcount = blobrefs.size() + 1;
    int rootcount = roots.size() + 1;
    int headerSize = refcount * 16 + rootcount * 3 + blobrefcount * 2;
    int segmentSize = align(headerSize + recordSize + length, 16);
    // avoid the somewhat expensive list and set traversals.
    if (segmentSize > buffer.length - 1 || refcount > Segment.SEGMENT_REFERENCE_LIMIT) {
        refcount -= idcount;
        Set<SegmentId> segmentIds = newIdentityHashSet();
        for (RecordId recordId : ids) {
            SegmentId segmentId = recordId.getSegmentId();
            if (segmentId != segment.getSegmentId()) {
                segmentIds.add(segmentId);
            } else if (roots.containsKey(recordId)) {
                rootcount--;
            }
        }
        if (!segmentIds.isEmpty()) {
            for (int refid = 1; refid < refcount; refid++) {
                segmentIds.remove(segment.getRefId(refid));
            }
            refcount += segmentIds.size();
        }
        headerSize = refcount * 16 + rootcount * 3 + blobrefcount * 2;
        segmentSize = align(headerSize + recordSize + length, 16);
    }
    if (segmentSize > buffer.length - 1 || blobrefcount > 0xffff || rootcount > 0xffff || refcount > Segment.SEGMENT_REFERENCE_LIMIT) {
        flush();
    }
    length += recordSize;
    position = buffer.length - length;
    checkState(position >= 0);
    RecordId id = new RecordId(segment.getSegmentId(), position);
    roots.put(id, type);
    return id;
}","/**
 * Before writing a record (which are written backwards, from the end of the
 * file to the beginning), this method is called, to ensure there is enough
 * space. A new segment is also created if there is not enough space in the
 * segment lookup table or elsewhere.
 * <p>
 * This method does not actually write into the segment, just allocates the
 * space (flushing the segment if needed and starting a new one), and sets
 * the write position (records are written from the end to the beginning,
 * but within a record from left to right).
 *
 * @param type the record type (only used for root records)
 * @param size the size of the record, excluding the size used for the
 *            record ids
 * @param ids the record ids
 * @return a new record id
 */
","private RecordId prepare(RecordType type, int size, Collection<RecordId> ids) {
    checkArgument(size >= 0);
    checkNotNull(ids);
    int idcount = ids.size();
    int recordSize = align(size + idcount * RECORD_ID_BYTES);
                int refcount = segment.getRefCount() + idcount;
    int blobrefcount = blobrefs.size() + 1;
    int rootcount = roots.size() + 1;
    int headerSize = refcount * 16 + rootcount * 3 + blobrefcount * 2;
    int segmentSize = align(headerSize + recordSize + length, 16);
        if (segmentSize > buffer.length - 1 || refcount > Segment.SEGMENT_REFERENCE_LIMIT) {
        refcount -= idcount;
        Set<SegmentId> segmentIds = newIdentityHashSet();
        for (RecordId recordId : ids) {
            SegmentId segmentId = recordId.getSegmentId();
            if (segmentId != segment.getSegmentId()) {
                segmentIds.add(segmentId);
            } else if (roots.containsKey(recordId)) {
                rootcount--;
            }
        }
        if (!segmentIds.isEmpty()) {
            for (int refid = 1; refid < refcount; refid++) {
                segmentIds.remove(segment.getRefId(refid));
            }
            refcount += segmentIds.size();
        }
        headerSize = refcount * 16 + rootcount * 3 + blobrefcount * 2;
        segmentSize = align(headerSize + recordSize + length, 16);
    }
    if (segmentSize > buffer.length - 1 || blobrefcount > 0xffff || rootcount > 0xffff || refcount > Segment.SEGMENT_REFERENCE_LIMIT) {
        flush();
    }
    length += recordSize;
    position = buffer.length - length;
    checkState(position >= 0);
    RecordId id = new RecordId(segment.getSegmentId(), position);
    roots.put(id, type);
    return id;
}",1.1818181818181819,0.5645933014354066,0.8,1.0,1.3333333333333333,3.365079365079365,-0.791966173361522,1.3333333333333333,-0.02631578947368421,9.809201085735031
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-4420_d645112f,1,"@Override
public NodeStore create(BlobStore blobStore, Closer closer) throws IOException {
    FileStoreBuilder builder = fileStoreBuilder(new File(dir, ""segmentstore""));
    if (blobStore != null) {
        builder.withBlobStore(blobStore);
    }
    builder.withMaxFileSize(256).withMemoryMapping(mmap);
    FileStore fs = builder.build();
    closer.register(asCloseable(fs));
    return SegmentNodeStoreBuilders.builder(fs).build();
}",,"@Override
public NodeStore create(BlobStore blobStore, Closer closer) throws IOException {
    FileStoreBuilder builder = fileStoreBuilder(new File(dir, ""segmentstore""));
    if (blobStore != null) {
        builder.withBlobStore(blobStore);
    }
    builder.withMaxFileSize(256).withMemoryMapping(mmap);
    FileStore fs = builder.build();
    closer.register(asCloseable(fs));
    return SegmentNodeStoreBuilders.builder(fs).build();
}",-0.13636363636363635,-0.3301435406698567,-0.4,-0.5,-0.25,-0.09325396825396824,0.09711064129668799,0.25,0.02631578947368421,-0.04002466531814226
camel,remotes/origin/bugs-dot-jar_CAMEL-8954_7b1253db,3,"@Override
public boolean acquireExclusiveReadLock(GenericFileOperations<File> operations, GenericFile<File> file, Exchange exchange) throws Exception {
    // must call super
    if (!super.acquireExclusiveReadLock(operations, file, exchange)) {
        return false;
    }
    File target = new File(file.getAbsoluteFilePath());
    LOG.trace(""Waiting for exclusive read lock to file: {}"", target);
    FileChannel channel = null;
    RandomAccessFile randomAccessFile = null;
    boolean exclusive = false;
    FileLock lock = null;
    try {
        randomAccessFile = new RandomAccessFile(target, ""rw"");
        // try to acquire rw lock on the file before we can consume it
        channel = randomAccessFile.getChannel();
        StopWatch watch = new StopWatch();
        while (!exclusive) {
            // timeout check
            if (timeout > 0) {
                long delta = watch.taken();
                if (delta > timeout) {
                    CamelLogger.log(LOG, readLockLoggingLevel, ""Cannot acquire read lock within "" + timeout + "" millis. Will skip the file: "" + target);
                    // we could not get the lock within the timeout period, so return false
                    return false;
                }
            }
            // get the lock using either try lock or not depending on if we are using timeout or not
            try {
                lock = timeout > 0 ? channel.tryLock() : channel.lock();
            } catch (IllegalStateException ex) {
            // Also catch the OverlappingFileLockException here. Do nothing here
            }
            if (lock != null) {
                LOG.trace(""Acquired exclusive read lock: {} to file: {}"", lock, target);
                exclusive = true;
            } else {
                boolean interrupted = sleep();
                if (interrupted) {
                    // we were interrupted while sleeping, we are likely being shutdown so return false
                    return false;
                }
            }
        }
    } catch (IOException e) {
        // such as AntiVirus or MS Office that has special locks for it's supported files
        if (timeout == 0) {
            // if not using timeout, then we cant retry, so return false
            return false;
        }
        LOG.debug(""Cannot acquire read lock. Will try again."", e);
        boolean interrupted = sleep();
        if (interrupted) {
            // we were interrupted while sleeping, we are likely being shutdown so return false
            return false;
        }
    } finally {
        // close channels if we did not grab the lock
        if (!exclusive) {
            IOHelper.close(channel, ""while acquiring exclusive read lock for file: "" + target, LOG);
            IOHelper.close(randomAccessFile, ""while acquiring exclusive read lock for file: "" + target, LOG);
            // and also must release super lock
            super.releaseExclusiveReadLockOnAbort(operations, file, exchange);
        }
    }
    // we grabbed the lock
    exchange.setProperty(Exchange.FILE_LOCK_EXCLUSIVE_LOCK, lock);
    exchange.setProperty(Exchange.FILE_LOCK_RANDOM_ACCESS_FILE, randomAccessFile);
    return true;
}",,"@Override
public boolean acquireExclusiveReadLock(GenericFileOperations<File> operations, GenericFile<File> file, Exchange exchange) throws Exception {
        if (!super.acquireExclusiveReadLock(operations, file, exchange)) {
        return false;
    }
    File target = new File(file.getAbsoluteFilePath());
    LOG.trace(""Waiting for exclusive read lock to file: {}"", target);
    FileChannel channel = null;
    RandomAccessFile randomAccessFile = null;
    boolean exclusive = false;
    FileLock lock = null;
    try {
        randomAccessFile = new RandomAccessFile(target, ""rw"");
                channel = randomAccessFile.getChannel();
        StopWatch watch = new StopWatch();
        while (!exclusive) {
                        if (timeout > 0) {
                long delta = watch.taken();
                if (delta > timeout) {
                    CamelLogger.log(LOG, readLockLoggingLevel, ""Cannot acquire read lock within "" + timeout + "" millis. Will skip the file: "" + target);
                                        return false;
                }
            }
                        try {
                lock = timeout > 0 ? channel.tryLock() : channel.lock();
            } catch (IllegalStateException ex) {
                        }
            if (lock != null) {
                LOG.trace(""Acquired exclusive read lock: {} to file: {}"", lock, target);
                exclusive = true;
            } else {
                boolean interrupted = sleep();
                if (interrupted) {
                                        return false;
                }
            }
        }
    } catch (IOException e) {
                if (timeout == 0) {
                        return false;
        }
        LOG.debug(""Cannot acquire read lock. Will try again."", e);
        boolean interrupted = sleep();
        if (interrupted) {
                        return false;
        }
    } finally {
                if (!exclusive) {
            IOHelper.close(channel, ""while acquiring exclusive read lock for file: "" + target, LOG);
            IOHelper.close(randomAccessFile, ""while acquiring exclusive read lock for file: "" + target, LOG);
                        super.releaseExclusiveReadLockOnAbort(operations, file, exchange);
        }
    }
        exchange.setProperty(Exchange.FILE_LOCK_EXCLUSIVE_LOCK, lock);
    exchange.setProperty(Exchange.FILE_LOCK_RANDOM_ACCESS_FILE, randomAccessFile);
    return true;
}",1.9545454545454546,1.062200956937799,1.8,1.0,1.1666666666666667,0.9841269841269841,-0.949823819591261,0.9166666666666666,-0.02631578947368421,2.657342254340923
camel,remotes/origin/bugs-dot-jar_CAMEL-8146_17475d80,3,"@Override
protected void doStop() throws Exception {
    ServiceHelper.stopService(scheduler);
    // clear counters
    backoffCounter = 0;
    idleCounter = 0;
    errorCounter = 0;
    super.doStop();
}",,"@Override
protected void doStop() throws Exception {
    ServiceHelper.stopService(scheduler);
        backoffCounter = 0;
    idleCounter = 0;
    errorCounter = 0;
    super.doStop();
}",-0.2727272727272727,-0.5023923444976078,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.41902748414376295,-0.3333333333333333,1.8421052631578947,-0.16279340490885932
camel,remotes/origin/bugs-dot-jar_CAMEL-7478_69b00a31,1,"private MethodInvocation createInvocation(Object pojo, Exchange exchange, Method explicitMethod) throws AmbiguousMethodCallException, MethodNotFoundException {
    MethodInfo methodInfo = null;
    // find the explicit method to invoke
    if (explicitMethod != null) {
        Iterator<List<MethodInfo>> it = operations.values().iterator();
        while (it.hasNext()) {
            List<MethodInfo> infos = it.next();
            for (MethodInfo info : infos) {
                if (explicitMethod.equals(info.getMethod())) {
                    return info.createMethodInvocation(pojo, exchange);
                }
            }
        }
        throw new MethodNotFoundException(exchange, pojo, explicitMethod.getName());
    }
    String methodName = exchange.getIn().getHeader(Exchange.BEAN_METHOD_NAME, String.class);
    if (methodName != null) {
        // do not use qualifier for name
        String name = methodName;
        if (methodName.contains(""("")) {
            name = ObjectHelper.before(methodName, ""("");
        }
        boolean emptyParameters = methodName.endsWith(""()"");
        // for example to log the class type or the likes
        if (""class"".equals(name) || ""getClass"".equals(name)) {
            try {
                Method method = pojo.getClass().getMethod(""getClass"");
                methodInfo = new MethodInfo(exchange.getContext(), pojo.getClass(), method, Collections.<ParameterInfo>emptyList(), Collections.<ParameterInfo>emptyList(), false, false);
            } catch (NoSuchMethodException e) {
                throw new MethodNotFoundException(exchange, pojo, ""getClass"");
            }
        // special for length on an array type
        } else if (""length"".equals(name) && pojo.getClass().isArray()) {
            try {
                // need to use arrayLength method from ObjectHelper as Camel's bean OGNL support is method invocation based
                // and not for accessing fields. And hence we need to create a MethodInfo instance with a method to call
                // and therefore use arrayLength from ObjectHelper to return the array length field.
                Method method = ObjectHelper.class.getMethod(""arrayLength"", Object[].class);
                ParameterInfo pi = new ParameterInfo(0, Object[].class, null, ExpressionBuilder.mandatoryBodyExpression(Object[].class, true));
                List<ParameterInfo> lpi = new ArrayList<ParameterInfo>(1);
                lpi.add(pi);
                methodInfo = new MethodInfo(exchange.getContext(), pojo.getClass(), method, lpi, lpi, false, false);
            } catch (NoSuchMethodException e) {
                throw new MethodNotFoundException(exchange, pojo, ""getClass"");
            }
        } else {
            List<MethodInfo> methods = getOperations(name);
            if (methods != null && methods.size() == 1) {
                // only one method then choose it
                methodInfo = methods.get(0);
                // validate that if we want an explict no-arg method, then that's what we get
                if (emptyParameters && methodInfo.hasParameters()) {
                    throw new MethodNotFoundException(exchange, pojo, methodName, ""(with no parameters)"");
                }
            } else if (methods != null) {
                // there are more methods with that name so we cannot decide which to use
                // but first let's try to choose a method and see if that complies with the name
                // must use the method name which may have qualifiers
                methodInfo = chooseMethod(pojo, exchange, methodName);
                // validate that if we want an explicit no-arg method, then that's what we get
                if (emptyParameters) {
                    if (methodInfo == null || methodInfo.hasParameters()) {
                        // we could not find a no-arg method with that name
                        throw new MethodNotFoundException(exchange, pojo, methodName, ""(with no parameters)"");
                    }
                }
                if (methodInfo == null || !name.equals(methodInfo.getMethod().getName())) {
                    throw new AmbiguousMethodCallException(exchange, methods);
                }
            } else {
                // a specific method was given to invoke but not found
                throw new MethodNotFoundException(exchange, pojo, methodName);
            }
        }
    }
    if (methodInfo == null) {
        // no name or type
        methodInfo = chooseMethod(pojo, exchange, null);
    }
    if (methodInfo == null) {
        methodInfo = defaultMethod;
    }
    if (methodInfo != null) {
        LOG.trace(""Chosen method to invoke: {} on bean: {}"", methodInfo, pojo);
        return methodInfo.createMethodInvocation(pojo, exchange);
    }
    LOG.debug(""Cannot find suitable method to invoke on bean: {}"", pojo);
    return null;
}",,"private MethodInvocation createInvocation(Object pojo, Exchange exchange, Method explicitMethod) throws AmbiguousMethodCallException, MethodNotFoundException {
    MethodInfo methodInfo = null;
        if (explicitMethod != null) {
        Iterator<List<MethodInfo>> it = operations.values().iterator();
        while (it.hasNext()) {
            List<MethodInfo> infos = it.next();
            for (MethodInfo info : infos) {
                if (explicitMethod.equals(info.getMethod())) {
                    return info.createMethodInvocation(pojo, exchange);
                }
            }
        }
        throw new MethodNotFoundException(exchange, pojo, explicitMethod.getName());
    }
    String methodName = exchange.getIn().getHeader(Exchange.BEAN_METHOD_NAME, String.class);
    if (methodName != null) {
                String name = methodName;
        if (methodName.contains(""("")) {
            name = ObjectHelper.before(methodName, ""("");
        }
        boolean emptyParameters = methodName.endsWith(""()"");
                if (""class"".equals(name) || ""getClass"".equals(name)) {
            try {
                Method method = pojo.getClass().getMethod(""getClass"");
                methodInfo = new MethodInfo(exchange.getContext(), pojo.getClass(), method, Collections.<ParameterInfo>emptyList(), Collections.<ParameterInfo>emptyList(), false, false);
            } catch (NoSuchMethodException e) {
                throw new MethodNotFoundException(exchange, pojo, ""getClass"");
            }
                } else if (""length"".equals(name) && pojo.getClass().isArray()) {
            try {
                                                                Method method = ObjectHelper.class.getMethod(""arrayLength"", Object[].class);
                ParameterInfo pi = new ParameterInfo(0, Object[].class, null, ExpressionBuilder.mandatoryBodyExpression(Object[].class, true));
                List<ParameterInfo> lpi = new ArrayList<ParameterInfo>(1);
                lpi.add(pi);
                methodInfo = new MethodInfo(exchange.getContext(), pojo.getClass(), method, lpi, lpi, false, false);
            } catch (NoSuchMethodException e) {
                throw new MethodNotFoundException(exchange, pojo, ""getClass"");
            }
        } else {
            List<MethodInfo> methods = getOperations(name);
            if (methods != null && methods.size() == 1) {
                                methodInfo = methods.get(0);
                                if (emptyParameters && methodInfo.hasParameters()) {
                    throw new MethodNotFoundException(exchange, pojo, methodName, ""(with no parameters)"");
                }
            } else if (methods != null) {
                                                                methodInfo = chooseMethod(pojo, exchange, methodName);
                                if (emptyParameters) {
                    if (methodInfo == null || methodInfo.hasParameters()) {
                                                throw new MethodNotFoundException(exchange, pojo, methodName, ""(with no parameters)"");
                    }
                }
                if (methodInfo == null || !name.equals(methodInfo.getMethod().getName())) {
                    throw new AmbiguousMethodCallException(exchange, methods);
                }
            } else {
                                throw new MethodNotFoundException(exchange, pojo, methodName);
            }
        }
    }
    if (methodInfo == null) {
                methodInfo = chooseMethod(pojo, exchange, null);
    }
    if (methodInfo == null) {
        methodInfo = defaultMethod;
    }
    if (methodInfo != null) {
        LOG.trace(""Chosen method to invoke: {} on bean: {}"", methodInfo, pojo);
        return methodInfo.createMethodInvocation(pojo, exchange);
    }
    LOG.debug(""Cannot find suitable method to invoke on bean: {}"", pojo);
    return null;
}",2.6818181818181817,1.1722488038277514,4.6,2.5,2.9166666666666665,1.4523809523809523,-1.246934460887949,3.0,-0.02631578947368421,7.004081303343072
Lang,45,3,"// -----------------------------------------------------------------------
/**
 * Abbreviates a string nicely.
 *
 * This method searches for the first space after the lower limit and abbreviates
 * the String there. It will also append any String passed as a parameter
 * to the end of the String. The upper limit can be specified to forcibly
 * abbreviate a String.
 *
 * @param str         the string to be abbreviated. If null is passed, null is returned.
 *                    If the empty String is passed, the empty string is returned.
 * @param lower       the lower limit.
 * @param upper       the upper limit; specify -1 if no limit is desired.
 *                    If the upper limit is lower than the lower limit, it will be
 *                    adjusted to be the same as the lower limit.
 * @param appendToEnd String to be appended to the end of the abbreviated string.
 *                    This is appended ONLY if the string was indeed abbreviated.
 *                    The append does not count towards the lower or upper limits.
 * @return the abbreviated String.
 * @since 2.4
 */
public static String abbreviate(String str, int lower, int upper, String appendToEnd) {
    // initial parameter checks
    if (str == null) {
        return null;
    }
    if (str.length() == 0) {
        return StringUtils.EMPTY;
    }
    // than the length of the string, set to the length of the string
    if (upper == -1 || upper > str.length()) {
        upper = str.length();
    }
    // if upper is less than lower, raise it to lower
    if (upper < lower) {
        upper = lower;
    }
    StringBuffer result = new StringBuffer();
    int index = StringUtils.indexOf(str, "" "", lower);
    if (index == -1) {
        result.append(str.substring(0, upper));
        // only if abbreviation has occured do we append the appendToEnd value
        if (upper != str.length()) {
            result.append(StringUtils.defaultString(appendToEnd));
        }
    } else if (index > upper) {
        result.append(str.substring(0, upper));
        result.append(StringUtils.defaultString(appendToEnd));
    } else {
        result.append(str.substring(0, index));
        result.append(StringUtils.defaultString(appendToEnd));
    }
    return result.toString();
}","/**
 * Abbreviates a string nicely.
 *
 * This method searches for the first space after the lower limit and abbreviates
 * the String there. It will also append any String passed as a parameter
 * to the end of the String. The upper limit can be specified to forcibly
 * abbreviate a String.
 *
 * @param str         the string to be abbreviated. If null is passed, null is returned.
 *                    If the empty String is passed, the empty string is returned.
 * @param lower       the lower limit.
 * @param upper       the upper limit; specify -1 if no limit is desired.
 *                    If the upper limit is lower than the lower limit, it will be
 *                    adjusted to be the same as the lower limit.
 * @param appendToEnd String to be appended to the end of the abbreviated string.
 *                    This is appended ONLY if the string was indeed abbreviated.
 *                    The append does not count towards the lower or upper limits.
 * @return the abbreviated String.
 * @since 2.4
 */
","public static String abbreviate(String str, int lower, int upper, String appendToEnd) {
        if (str == null) {
        return null;
    }
    if (str.length() == 0) {
        return StringUtils.EMPTY;
    }
        if (upper == -1 || upper > str.length()) {
        upper = str.length();
    }
        if (upper < lower) {
        upper = lower;
    }
    StringBuffer result = new StringBuffer();
    int index = StringUtils.indexOf(str, "" "", lower);
    if (index == -1) {
        result.append(str.substring(0, upper));
                if (upper != str.length()) {
            result.append(StringUtils.defaultString(appendToEnd));
        }
    } else if (index > upper) {
        result.append(str.substring(0, upper));
        result.append(StringUtils.defaultString(appendToEnd));
    } else {
        result.append(str.substring(0, index));
        result.append(StringUtils.defaultString(appendToEnd));
    }
    return result.toString();
}",0.6818181818181818,-0.1578947368421053,0.8,0.0,0.6666666666666666,1.7996031746031746,-0.5112050739957716,1.0,-0.02631578947368421,2.1583421217936523
camel,remotes/origin/bugs-dot-jar_CAMEL-7239_ae419224,1,"protected Schema createSchema() throws SAXException, IOException {
    SchemaFactory factory = getSchemaFactory();
    URL url = getSchemaUrl();
    if (url != null) {
        return factory.newSchema(url);
    }
    File file = getSchemaFile();
    if (file != null) {
        return factory.newSchema(file);
    }
    byte[] bytes = getSchemaAsByteArray();
    if (bytes != null) {
        return factory.newSchema(new StreamSource(new ByteArrayInputStream(schemaAsByteArray)));
    }
    Source source = getSchemaSource();
    return factory.newSchema(source);
}",,"protected Schema createSchema() throws SAXException, IOException {
    SchemaFactory factory = getSchemaFactory();
    URL url = getSchemaUrl();
    if (url != null) {
        return factory.newSchema(url);
    }
    File file = getSchemaFile();
    if (file != null) {
        return factory.newSchema(file);
    }
    byte[] bytes = getSchemaAsByteArray();
    if (bytes != null) {
        return factory.newSchema(new StreamSource(new ByteArrayInputStream(schemaAsByteArray)));
    }
    Source source = getSchemaSource();
    return factory.newSchema(source);
}",0.13636363636363635,-0.3971291866028709,0.0,-0.5,0.08333333333333333,-0.04365079365079365,-0.13347427766032413,0.25,0.21052631578947367,0.0027177953354886584
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3411_978c77ff,0,"/**
 * Get the revision of the latest change made to this node.
 *
 * @param context the revision context
 * @param changeRev the revision of the current change
 * @param handler the conflict handler, which is called for concurrent changes
 *                preceding <code>changeRev</code>.
 * @return the revision, or null if deleted
 */
@CheckForNull
public Revision getNewestRevision(final RevisionContext context, final Revision changeRev, final CollisionHandler handler) {
    final Map<Revision, String> validRevisions = Maps.newHashMap();
    Predicate<Revision> predicate = new Predicate<Revision>() {

        @Override
        public boolean apply(Revision input) {
            if (input.equals(changeRev)) {
                return false;
            }
            if (isValidRevision(context, input, null, changeRev, validRevisions)) {
                return true;
            }
            handler.concurrentModification(input);
            return false;
        }
    };
    Revision newestRev = null;
    // check local commits first
    Comparator<Revision> comp = reverseOrder(context.getRevisionComparator());
    SortedSet<Revision> revisions = Sets.newTreeSet(comp);
    revisions.addAll(getLocalRevisions().keySet());
    revisions.addAll(getLocalCommitRoot().keySet());
    Iterator<Revision> it = filter(revisions, predicate).iterator();
    if (it.hasNext()) {
        newestRev = it.next();
    } else {
        // check full history (only needed in rare cases)
        if (LOG.isDebugEnabled()) {
            LOG.debug(""getNewestRevision() with changeRev {} on {}, "" + ""_revisions {}, _commitRoot {}"", changeRev, getId(), getLocalRevisions(), getLocalCommitRoot());
        }
        it = filter(getAllChanges(), predicate).iterator();
        if (it.hasNext()) {
            newestRev = it.next();
        }
    }
    if (newestRev == null) {
        return null;
    }
    // the local deleted map contains the most recent revisions
    SortedMap<Revision, String> deleted = getLocalDeleted();
    String value = deleted.get(newestRev);
    if (value == null && deleted.headMap(newestRev).isEmpty()) {
        // no need to check previous docs
        return newestRev;
    }
    if (value == null) {
        // get from complete map
        value = getDeleted().get(newestRev);
    }
    if (""true"".equals(value)) {
        // deleted in the newest revision
        return null;
    }
    return newestRev;
}","/**
 * Get the revision of the latest change made to this node.
 *
 * @param context the revision context
 * @param changeRev the revision of the current change
 * @param handler the conflict handler, which is called for concurrent changes
 *                preceding <code>changeRev</code>.
 * @return the revision, or null if deleted
 */
","@CheckForNull
public Revision getNewestRevision(final RevisionContext context, final Revision changeRev, final CollisionHandler handler) {
    final Map<Revision, String> validRevisions = Maps.newHashMap();
    Predicate<Revision> predicate = new Predicate<Revision>() {

        @Override
        public boolean apply(Revision input) {
            if (input.equals(changeRev)) {
                return false;
            }
            if (isValidRevision(context, input, null, changeRev, validRevisions)) {
                return true;
            }
            handler.concurrentModification(input);
            return false;
        }
    };
    Revision newestRev = null;
        Comparator<Revision> comp = reverseOrder(context.getRevisionComparator());
    SortedSet<Revision> revisions = Sets.newTreeSet(comp);
    revisions.addAll(getLocalRevisions().keySet());
    revisions.addAll(getLocalCommitRoot().keySet());
    Iterator<Revision> it = filter(revisions, predicate).iterator();
    if (it.hasNext()) {
        newestRev = it.next();
    } else {
                if (LOG.isDebugEnabled()) {
            LOG.debug(""getNewestRevision() with changeRev {} on {}, "" + ""_revisions {}, _commitRoot {}"", changeRev, getId(), getLocalRevisions(), getLocalCommitRoot());
        }
        it = filter(getAllChanges(), predicate).iterator();
        if (it.hasNext()) {
            newestRev = it.next();
        }
    }
    if (newestRev == null) {
        return null;
    }
        SortedMap<Revision, String> deleted = getLocalDeleted();
    String value = deleted.get(newestRev);
    if (value == null && deleted.headMap(newestRev).isEmpty()) {
                return newestRev;
    }
    if (value == null) {
                value = getDeleted().get(newestRev);
    }
    if (""true"".equals(value)) {
                return null;
    }
    return newestRev;
}",1.5909090909090908,0.4066985645933013,1.2,0.0,1.4166666666666667,0.4821428571428571,-0.8539816772374911,2.3333333333333335,-0.02631578947368421,1.5203494637598471
wicket,remotes/origin/bugs-dot-jar_WICKET-5853_b80f6640,3,"/**
 *  @see org.apache.wicket.util.convert.IConverter#convertToObject(java.lang.String,Locale)
 */
@Override
public Short convertToObject(final String value, final Locale locale) {
    final Number number = parse(value, Short.MIN_VALUE, Short.MAX_VALUE, locale);
    if (number == null) {
        return null;
    }
    return number.shortValue();
}","/**
 *  @see org.apache.wicket.util.convert.IConverter#convertToObject(java.lang.String,Locale)
 */
","@Override
public Short convertToObject(final String value, final Locale locale) {
    final Number number = parse(value, Short.MIN_VALUE, Short.MAX_VALUE, locale);
    if (number == null) {
        return null;
    }
    return number.shortValue();
}",-0.2727272727272727,-0.16267942583732073,-0.4,-0.5,-0.25,-0.07341269841269843,0.34291754756871046,-0.3333333333333333,0.2631578947368421,-0.09645983529560923
maven,remotes/origin/bugs-dot-jar_MNG-4648_83389c34,1,"private void validateEffectiveDependencies(ModelProblemCollector problems, List<Dependency> dependencies, boolean managed, ModelBuildingRequest request) {
    Severity errOn30 = getSeverity(request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0);
    String prefix = managed ? ""dependencyManagement.dependencies.dependency."" : ""dependencies.dependency."";
    for (Dependency d : dependencies) {
        validateId(prefix + ""artifactId"", problems, d.getArtifactId(), d.getManagementKey());
        validateId(prefix + ""groupId"", problems, d.getGroupId(), d.getManagementKey());
        if (!managed) {
            validateStringNotEmpty(prefix + ""type"", problems, Severity.ERROR, d.getType(), d.getManagementKey());
            validateStringNotEmpty(prefix + ""version"", problems, Severity.ERROR, d.getVersion(), d.getManagementKey());
        }
        if (""system"".equals(d.getScope())) {
            String systemPath = d.getSystemPath();
            if (StringUtils.isEmpty(systemPath)) {
                addViolation(problems, Severity.ERROR, prefix + ""systemPath"", d.getManagementKey(), ""is missing."");
            } else {
                File sysFile = new File(systemPath);
                if (!sysFile.isAbsolute()) {
                    addViolation(problems, Severity.ERROR, prefix + ""systemPath"", d.getManagementKey(), ""must specify an absolute path but is "" + systemPath);
                } else if (!sysFile.isFile()) {
                    String msg = ""refers to a non-existing file "" + sysFile.getAbsolutePath();
                    systemPath = systemPath.replace('/', File.separatorChar).replace('\\', File.separatorChar);
                    String jdkHome = request.getSystemProperties().getProperty(""java.home"", """") + File.separator + "".."";
                    if (systemPath.startsWith(jdkHome)) {
                        msg += "". Please verify that you run Maven using a JDK and not just a JRE."";
                    }
                    addViolation(problems, Severity.WARNING, prefix + ""systemPath"", d.getManagementKey(), msg);
                }
            }
        } else if (StringUtils.isNotEmpty(d.getSystemPath())) {
            addViolation(problems, Severity.ERROR, prefix + ""systemPath"", d.getManagementKey(), ""must be omitted."" + "" This field may only be specified for a dependency with system scope."");
        }
        if (request.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0) {
            validateBoolean(prefix + ""optional"", problems, errOn30, d.getOptional(), d.getManagementKey());
            if (!managed) {
                validateVersion(prefix + ""version"", problems, errOn30, d.getVersion(), d.getManagementKey());
                /*
                     * TODO: Extensions like Flex Mojos use custom scopes like ""merged"", ""internal"", ""external"", etc. In
                     * order to don't break backward-compat with those, only warn but don't error out.
                     */
                validateEnum(prefix + ""scope"", problems, Severity.WARNING, d.getScope(), d.getManagementKey(), ""provided"", ""compile"", ""runtime"", ""test"", ""system"");
            }
        }
    }
}",,"private void validateEffectiveDependencies(ModelProblemCollector problems, List<Dependency> dependencies, boolean managed, ModelBuildingRequest request) {
    Severity errOn30 = getSeverity(request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0);
    String prefix = managed ? ""dependencyManagement.dependencies.dependency."" : ""dependencies.dependency."";
    for (Dependency d : dependencies) {
        validateId(prefix + ""artifactId"", problems, d.getArtifactId(), d.getManagementKey());
        validateId(prefix + ""groupId"", problems, d.getGroupId(), d.getManagementKey());
        if (!managed) {
            validateStringNotEmpty(prefix + ""type"", problems, Severity.ERROR, d.getType(), d.getManagementKey());
            validateStringNotEmpty(prefix + ""version"", problems, Severity.ERROR, d.getVersion(), d.getManagementKey());
        }
        if (""system"".equals(d.getScope())) {
            String systemPath = d.getSystemPath();
            if (StringUtils.isEmpty(systemPath)) {
                addViolation(problems, Severity.ERROR, prefix + ""systemPath"", d.getManagementKey(), ""is missing."");
            } else {
                File sysFile = new File(systemPath);
                if (!sysFile.isAbsolute()) {
                    addViolation(problems, Severity.ERROR, prefix + ""systemPath"", d.getManagementKey(), ""must specify an absolute path but is "" + systemPath);
                } else if (!sysFile.isFile()) {
                    String msg = ""refers to a non-existing file "" + sysFile.getAbsolutePath();
                    systemPath = systemPath.replace('/', File.separatorChar).replace('\\', File.separatorChar);
                    String jdkHome = request.getSystemProperties().getProperty(""java.home"", """") + File.separator + "".."";
                    if (systemPath.startsWith(jdkHome)) {
                        msg += "". Please verify that you run Maven using a JDK and not just a JRE."";
                    }
                    addViolation(problems, Severity.WARNING, prefix + ""systemPath"", d.getManagementKey(), msg);
                }
            }
        } else if (StringUtils.isNotEmpty(d.getSystemPath())) {
            addViolation(problems, Severity.ERROR, prefix + ""systemPath"", d.getManagementKey(), ""must be omitted."" + "" This field may only be specified for a dependency with system scope."");
        }
        if (request.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0) {
            validateBoolean(prefix + ""optional"", problems, errOn30, d.getOptional(), d.getManagementKey());
            if (!managed) {
                validateVersion(prefix + ""version"", problems, errOn30, d.getVersion(), d.getManagementKey());
                                validateEnum(prefix + ""scope"", problems, Severity.WARNING, d.getScope(), d.getManagementKey(), ""provided"", ""compile"", ""runtime"", ""test"", ""system"");
            }
        }
    }
}",1.1818181818181819,1.3923444976076558,1.6,2.0,1.4166666666666667,0.6150793650793652,-0.845243128964059,3.25,-0.02631578947368421,2.990559176593304
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3433_b76b31f7,0,"/**
 * Recover the correct _lastRev updates for the given candidate nodes.
 *
 * @param suspects the potential suspects
 * @param clusterId the cluster id for which _lastRev recovery needed
 * @param dryRun if {@code true}, this method will only perform a check
 *               but not apply the changes to the _lastRev fields.
 * @return the number of documents that required recovery. This method
 *          returns the number of the affected documents even if
 *          {@code dryRun} is set true and no document was changed.
 */
public int recover(Iterator<NodeDocument> suspects, int clusterId, boolean dryRun) {
    UnsavedModifications unsaved = new UnsavedModifications();
    UnsavedModifications unsavedParents = new UnsavedModifications();
    // Map of known last rev of checked paths
    Map<String, Revision> knownLastRevOrModification = MapFactory.getInstance().create();
    final DocumentStore docStore = nodeStore.getDocumentStore();
    final JournalEntry changes = JOURNAL.newDocument(docStore);
    long count = 0;
    while (suspects.hasNext()) {
        NodeDocument doc = suspects.next();
        count++;
        if (count % 100000 == 0) {
            log.info(""Scanned {} suspects so far..."", count);
        }
        Revision currentLastRev = doc.getLastRev().get(clusterId);
        // 1. determine last committed modification on document
        Revision lastModifiedRev = determineLastModification(doc, clusterId);
        Revision lastRevForParents = Utils.max(lastModifiedRev, currentLastRev);
        // _lastRev entry or an explicit modification on the document
        if (lastRevForParents != null) {
            knownLastRevOrModification.put(doc.getPath(), lastRevForParents);
        }
        // 2. Update lastRev for parent paths aka rollup
        if (lastRevForParents != null) {
            String path = doc.getPath();
            // track all changes
            changes.modified(path);
            while (true) {
                if (PathUtils.denotesRoot(path)) {
                    break;
                }
                path = PathUtils.getParentPath(path);
                unsavedParents.put(path, lastRevForParents);
            }
        }
    }
    for (String parentPath : unsavedParents.getPaths()) {
        Revision calcLastRev = unsavedParents.get(parentPath);
        Revision knownLastRev = knownLastRevOrModification.get(parentPath);
        if (knownLastRev == null) {
            // we don't know when the document was last modified with
            // the given clusterId. need to read from store
            String id = Utils.getIdFromPath(parentPath);
            NodeDocument doc = docStore.find(NODES, id);
            if (doc != null) {
                Revision lastRev = doc.getLastRev().get(clusterId);
                Revision lastMod = determineLastModification(doc, clusterId);
                knownLastRev = Utils.max(lastRev, lastMod);
            } else {
                log.warn(""Unable to find document: {}"", id);
                continue;
            }
        }
        // This check ensures that unnecessary updates are not made
        if (knownLastRev == null || calcLastRev.compareRevisionTime(knownLastRev) > 0) {
            unsaved.put(parentPath, calcLastRev);
        }
    }
    // take the root's lastRev
    final Revision lastRootRev = unsaved.get(""/"");
    // Note the size before persist as persist operation
    // would empty the internal state
    int size = unsaved.getPaths().size();
    String updates = unsaved.toString();
    if (dryRun) {
        log.info(""Dry run of lastRev recovery identified [{}] documents for "" + ""cluster node [{}]: {}"", size, clusterId, updates);
    } else {
        // UnsavedModifications is designed to be used in concurrent
        // access mode. For recovery case there is no concurrent access
        // involve so just pass a new lock instance
        // the lock uses to do the persisting is a plain reentrant lock
        // thus it doesn't matter, where exactly the check is done
        // as to whether the recovered lastRev has already been
        // written to the journal.
        unsaved.persist(nodeStore, new UnsavedModifications.Snapshot() {

            @Override
            public void acquiring() {
                if (lastRootRev == null) {
                    // then we cannot and probably don't have to persist anything
                    return;
                }
                // lastRootRev never null at this point
                final String id = JournalEntry.asId(lastRootRev);
                final JournalEntry existingEntry = docStore.find(Collection.JOURNAL, id);
                if (existingEntry != null) {
                    // hence: nothing to be done here. return.
                    return;
                }
                // otherwise store a new journal entry now
                docStore.create(JOURNAL, singletonList(changes.asUpdateOp(lastRootRev)));
            }
        }, new ReentrantLock());
        log.info(""Updated lastRev of [{}] documents while performing lastRev recovery for "" + ""cluster node [{}]: {}"", size, clusterId, updates);
    }
    return size;
}","/**
 * Recover the correct _lastRev updates for the given candidate nodes.
 *
 * @param suspects the potential suspects
 * @param clusterId the cluster id for which _lastRev recovery needed
 * @param dryRun if {@code true}, this method will only perform a check
 *               but not apply the changes to the _lastRev fields.
 * @return the number of documents that required recovery. This method
 *          returns the number of the affected documents even if
 *          {@code dryRun} is set true and no document was changed.
 */
","public int recover(Iterator<NodeDocument> suspects, int clusterId, boolean dryRun) {
    UnsavedModifications unsaved = new UnsavedModifications();
    UnsavedModifications unsavedParents = new UnsavedModifications();
        Map<String, Revision> knownLastRevOrModification = MapFactory.getInstance().create();
    final DocumentStore docStore = nodeStore.getDocumentStore();
    final JournalEntry changes = JOURNAL.newDocument(docStore);
    long count = 0;
    while (suspects.hasNext()) {
        NodeDocument doc = suspects.next();
        count++;
        if (count % 100000 == 0) {
            log.info(""Scanned {} suspects so far..."", count);
        }
        Revision currentLastRev = doc.getLastRev().get(clusterId);
                Revision lastModifiedRev = determineLastModification(doc, clusterId);
        Revision lastRevForParents = Utils.max(lastModifiedRev, currentLastRev);
                if (lastRevForParents != null) {
            knownLastRevOrModification.put(doc.getPath(), lastRevForParents);
        }
                if (lastRevForParents != null) {
            String path = doc.getPath();
                        changes.modified(path);
            while (true) {
                if (PathUtils.denotesRoot(path)) {
                    break;
                }
                path = PathUtils.getParentPath(path);
                unsavedParents.put(path, lastRevForParents);
            }
        }
    }
    for (String parentPath : unsavedParents.getPaths()) {
        Revision calcLastRev = unsavedParents.get(parentPath);
        Revision knownLastRev = knownLastRevOrModification.get(parentPath);
        if (knownLastRev == null) {
                                    String id = Utils.getIdFromPath(parentPath);
            NodeDocument doc = docStore.find(NODES, id);
            if (doc != null) {
                Revision lastRev = doc.getLastRev().get(clusterId);
                Revision lastMod = determineLastModification(doc, clusterId);
                knownLastRev = Utils.max(lastRev, lastMod);
            } else {
                log.warn(""Unable to find document: {}"", id);
                continue;
            }
        }
                if (knownLastRev == null || calcLastRev.compareRevisionTime(knownLastRev) > 0) {
            unsaved.put(parentPath, calcLastRev);
        }
    }
        final Revision lastRootRev = unsaved.get(""/"");
            int size = unsaved.getPaths().size();
    String updates = unsaved.toString();
    if (dryRun) {
        log.info(""Dry run of lastRev recovery identified [{}] documents for "" + ""cluster node [{}]: {}"", size, clusterId, updates);
    } else {
                                                                unsaved.persist(nodeStore, new UnsavedModifications.Snapshot() {

            @Override
            public void acquiring() {
                if (lastRootRev == null) {
                                        return;
                }
                                final String id = JournalEntry.asId(lastRootRev);
                final JournalEntry existingEntry = docStore.find(Collection.JOURNAL, id);
                if (existingEntry != null) {
                                        return;
                }
                                docStore.create(JOURNAL, singletonList(changes.asUpdateOp(lastRootRev)));
            }
        }, new ReentrantLock());
        log.info(""Updated lastRev of [{}] documents while performing lastRev recovery for "" + ""cluster node [{}]: {}"", size, clusterId, updates);
    }
    return size;
}",2.727272727272727,0.9473684210526314,2.4,1.0,1.5833333333333333,1.6587301587301586,-1.1733615221987312,3.0,-0.02631578947368421,7.374074906496544
Closure,174,2,"/**
 * Creates a node representing a qualified name.
 *
 * @param name A qualified name (e.g. ""foo"" or ""foo.bar.baz"")
 * @return A NAME or GETPROP node
 */
public static Node newQualifiedNameNodeDeclaration(CodingConvention convention, String name, Node value, JSDocInfo info) {
    Node result;
    Node nameNode = newQualifiedNameNode(convention, name);
    if (nameNode.isName()) {
        result = IR.var(nameNode, value);
        result.setJSDocInfo(info);
    } else {
        result = IR.exprResult(IR.assign(nameNode, value));
        result.getFirstChild().setJSDocInfo(info);
    }
    return result;
}","/**
 * Creates a node representing a qualified name.
 *
 * @param name A qualified name (e.g. ""foo"" or ""foo.bar.baz"")
 * @return A NAME or GETPROP node
 */
","public static Node newQualifiedNameNodeDeclaration(CodingConvention convention, String name, Node value, JSDocInfo info) {
    Node result;
    Node nameNode = newQualifiedNameNode(convention, name);
    if (nameNode.isName()) {
        result = IR.var(nameNode, value);
        result.setJSDocInfo(info);
    } else {
        result = IR.exprResult(IR.assign(nameNode, value));
        result.getFirstChild().setJSDocInfo(info);
    }
    return result;
}",-0.09090909090909091,-0.11483253588516758,-0.4,-0.5,-0.25,-0.3650793650793651,0.061592670894996523,0.16666666666666666,0.07894736842105263,-0.16279340490885932
Closure,153,2,"/**
 * Declares a variable.
 *
 * @param n The node corresponding to the variable name.
 * @param declaredType The variable's type, according to JSDoc
 */
private void declareVar(String name, Node n, Node parent, Node gramps, JSType declaredType, Node nodeWithLineNumber) {
    if (scope.isDeclared(name, false) || (scope.isLocal() && name.equals(ARGUMENTS))) {
        redeclarationHandler.onRedeclaration(scope, name, n, parent, gramps, nodeWithLineNumber);
    } else {
        scope.declare(name, n, declaredType, compiler.getInput(sourceName));
    }
}","/**
 * Declares a variable.
 *
 * @param n The node corresponding to the variable name.
 * @param declaredType The variable's type, according to JSDoc
 */
","private void declareVar(String name, Node n, Node parent, Node gramps, JSType declaredType, Node nodeWithLineNumber) {
    if (scope.isDeclared(name, false) || (scope.isLocal() && name.equals(ARGUMENTS))) {
        redeclarationHandler.onRedeclaration(scope, name, n, parent, gramps, nodeWithLineNumber);
    } else {
        scope.declare(name, n, declaredType, compiler.getInput(sourceName));
    }
}",-0.3181818181818182,0.01435406698564584,-0.4,-0.5,0.16666666666666666,-0.0277777777777778,0.3065539112050739,0.0,-0.02631578947368421,-0.013948583184938015
wicket,remotes/origin/bugs-dot-jar_WICKET-3304_7e7ab76c,3,"/**
 *  @see org.apache.wicket.markup.html.form.FormComponent#convertValue(String[])
 */
@Override
protected T convertValue(String[] value) throws ConversionException {
    String tmp = value != null && value.length > 0 ? value[0] : null;
    if (getConvertEmptyInputStringToNull() && Strings.isEmpty(tmp)) {
        return null;
    }
    return super.convertValue(value);
}","/**
 *  @see org.apache.wicket.markup.html.form.FormComponent#convertValue(String[])
 */
","@Override
protected T convertValue(String[] value) throws ConversionException {
    String tmp = value != null && value.length > 0 ? value[0] : null;
    if (getConvertEmptyInputStringToNull() && Strings.isEmpty(tmp)) {
        return null;
    }
    return super.convertValue(value);
}",-0.2727272727272727,-0.16267942583732073,-0.2,-0.5,0.3333333333333333,0.31547619047619047,0.30570824524312884,-0.25,0.763157894736842,0.02835589518392374
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-2494_0dc92ca1,1,"public String toString() {
    return String.format(""%,d %,d %,.2f %,d"", getMin(), getMax(), getAverage(), count);
}",,"public String toString() {
    return String.format(""%,d %,d %,.2f %,d"", getMin(), getMax(), getAverage(), count);
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.9627906976744184,-0.16666666666666666,-0.02631578947368421,-0.16279340490885932
Cli,28,3,"/**
 * Sets the values of Options using the values in <code>properties</code>.
 *
 * @param properties The value properties to be processed.
 */
protected void processProperties(Properties properties) {
    if (properties == null) {
        return;
    }
    for (Enumeration e = properties.propertyNames(); e.hasMoreElements(); ) {
        String option = e.nextElement().toString();
        if (!cmd.hasOption(option)) {
            Option opt = getOptions().getOption(option);
            // get the value from the properties instance
            String value = properties.getProperty(option);
            if (opt.hasArg()) {
                if (opt.getValues() == null || opt.getValues().length == 0) {
                    try {
                        opt.addValueForProcessing(value);
                    } catch (RuntimeException exp) {
                    // if we cannot add the value don't worry about it
                    }
                }
            } else if (!(""yes"".equalsIgnoreCase(value) || ""true"".equalsIgnoreCase(value) || ""1"".equalsIgnoreCase(value))) {
                // option to the CommandLine
                break;
            }
            cmd.addOption(opt);
        }
    }
}","/**
 * Sets the values of Options using the values in <code>properties</code>.
 *
 * @param properties The value properties to be processed.
 */
","protected void processProperties(Properties properties) {
    if (properties == null) {
        return;
    }
    for (Enumeration e = properties.propertyNames(); e.hasMoreElements(); ) {
        String option = e.nextElement().toString();
        if (!cmd.hasOption(option)) {
            Option opt = getOptions().getOption(option);
                        String value = properties.getProperty(option);
            if (opt.hasArg()) {
                if (opt.getValues() == null || opt.getValues().length == 0) {
                    try {
                        opt.addValueForProcessing(value);
                    } catch (RuntimeException exp) {
                                        }
                }
            } else if (!(""yes"".equalsIgnoreCase(value) || ""true"".equalsIgnoreCase(value) || ""1"".equalsIgnoreCase(value))) {
                                break;
            }
            cmd.addOption(opt);
        }
    }
}",0.4090909090909091,1.6698564593301437,1.0,1.5,1.25,0.30753968253968256,-0.37082452431289636,0.8333333333333334,0.0,0.38334745249909224
wicket,remotes/origin/bugs-dot-jar_WICKET-5853_b80f6640,3,"/**
 *  @param locale
 *             The locale
 *  @return Returns the numberFormat.
 */
@Override
public NumberFormat getNumberFormat(final Locale locale) {
    NumberFormat numberFormat = numberFormats.get(locale);
    if (numberFormat == null) {
        numberFormat = NumberFormat.getIntegerInstance(locale);
        numberFormat.setParseIntegerOnly(true);
        numberFormat.setGroupingUsed(false);
        NumberFormat tmpNumberFormat = numberFormats.putIfAbsent(locale, numberFormat);
        if (tmpNumberFormat != null) {
            numberFormat = tmpNumberFormat;
        }
    }
    return (NumberFormat) numberFormat.clone();
}","/**
 *  @param locale
 *             The locale
 *  @return Returns the numberFormat.
 */
","@Override
public NumberFormat getNumberFormat(final Locale locale) {
    NumberFormat numberFormat = numberFormats.get(locale);
    if (numberFormat == null) {
        numberFormat = NumberFormat.getIntegerInstance(locale);
        numberFormat.setParseIntegerOnly(true);
        numberFormat.setGroupingUsed(false);
        NumberFormat tmpNumberFormat = numberFormats.putIfAbsent(locale, numberFormat);
        if (tmpNumberFormat != null) {
            numberFormat = tmpNumberFormat;
        }
    }
    return (NumberFormat) numberFormat.clone();
}",0.0,0.2822966507177033,-0.2,0.0,-0.08333333333333333,0.03174603174603173,-0.011698379140239377,0.0,0.10526315789473684,0.007305083475965707
Closure,30,2,"boolean dependsOnOuterScopeVars(String name, Node useNode) {
    Preconditions.checkArgument(getCfg().hasNode(useNode));
    GraphNode<Node, Branch> n = getCfg().getNode(useNode);
    FlowState<MustDef> state = n.getAnnotation();
    Definition def = state.getIn().reachingDef.get(jsScope.getVar(name));
    for (Var s : def.depends) {
        if (s.scope != jsScope) {
            return true;
        }
    }
    return false;
}",,"boolean dependsOnOuterScopeVars(String name, Node useNode) {
    Preconditions.checkArgument(getCfg().hasNode(useNode));
    GraphNode<Node, Branch> n = getCfg().getNode(useNode);
    FlowState<MustDef> state = n.getAnnotation();
    Definition def = state.getIn().reachingDef.get(jsScope.getVar(name));
    for (Var s : def.depends) {
        if (s.scope != jsScope) {
            return true;
        }
    }
    return false;
}",-0.09090909090909091,0.10047846889952151,-0.2,0.0,-0.16666666666666666,-0.10317460317460318,0.028047921071177005,0.25,0.0,-0.024381782242123513
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2442_ea7a6199,1,"/**
 * Returns a {@link DocumentNodeState} as seen at the given
 * <code>readRevision</code>.
 *
 * @param nodeStore    the node store.
 * @param readRevision the read revision.
 * @param lastModified the revision when this node was last modified, but
 *                     the value is potentially not yet reflected in this
 *                     document.
 *                     See {@link RevisionContext#getPendingModifications()}.
 * @return the node or <code>null</code> if the node doesn't exist at the
 *         given read revision.
 */
@CheckForNull
public DocumentNodeState getNodeAtRevision(@Nonnull DocumentNodeStore nodeStore, @Nonnull Revision readRevision, @Nullable Revision lastModified) {
    Map<Revision, String> validRevisions = Maps.newHashMap();
    Branch branch = nodeStore.getBranches().getBranch(readRevision);
    LastRevs lastRevs = new LastRevs(getLastRev(), readRevision, branch);
    // overlay with unsaved last modified from this instance
    lastRevs.update(lastModified);
    Revision min = getLiveRevision(nodeStore, readRevision, validRevisions, lastRevs);
    if (min == null) {
        // deleted
        return null;
    }
    String path = getPath();
    DocumentNodeState n = new DocumentNodeState(nodeStore, path, readRevision, hasChildren());
    Revision lastRevision = min;
    for (String key : keySet()) {
        if (!Utils.isPropertyName(key)) {
            continue;
        }
        // first check local map, which contains most recent values
        Value value = getLatestValue(nodeStore, getLocalMap(key), min, readRevision, validRevisions, lastRevs);
        // check if there may be more recent values in a previous document
        if (!getPreviousRanges().isEmpty()) {
            Revision newest = getLocalMap(key).firstKey();
            if (isRevisionNewer(nodeStore, newest, value.revision)) {
                // not reading the most recent value, we may need to
                // consider previous documents as well
                Revision newestPrev = getPreviousRanges().firstKey();
                if (isRevisionNewer(nodeStore, newestPrev, value.revision)) {
                    // a previous document has more recent changes
                    // than value.revision
                    value = null;
                }
            }
        }
        if (value == null && !getPreviousRanges().isEmpty()) {
            // check complete revision history
            value = getLatestValue(nodeStore, getValueMap(key), min, readRevision, validRevisions, lastRevs);
        }
        String propertyName = Utils.unescapePropertyName(key);
        String v = value != null ? value.value : null;
        n.setProperty(propertyName, v);
        // keep track of when this node was last modified
        if (value != null && isRevisionNewer(nodeStore, value.revision, lastRevision)) {
            lastRevision = value.revision;
        }
    }
    // lastRevision now points to the revision when this node was
    // last modified directly. but it may also have been 'modified'
    // by an operation on a descendant node, which is tracked in
    // _lastRev.
    // when was this node last modified?
    Revision branchBase = null;
    if (branch != null) {
        branchBase = branch.getBase(readRevision);
    }
    for (Revision r : lastRevs.get().values()) {
        // ignore if newer than readRevision
        if (isRevisionNewer(nodeStore, r, readRevision)) {
            // the node has a _lastRev which is newer than readRevision
            // this means we don't know when this node was
            // modified by an operation on a descendant node between
            // current lastRevision and readRevision. therefore we have
            // to stay on the safe side and use readRevision
            lastRevision = readRevision;
            continue;
        } else if (branchBase != null && isRevisionNewer(nodeStore, r, branchBase)) {
            // readRevision is on a branch and the node has a
            // _lastRev which is newer than the base of the branch
            // we cannot use this _lastRev because it is not visible
            // from this branch. highest possible revision of visible
            // changes is the base of the branch
            r = branchBase;
        }
        if (revisionAreAmbiguous(nodeStore, r, lastRevision)) {
            // _lastRev entries from multiple cluster nodes are ambiguous
            // use readRevision to make sure read is consistent
            lastRevision = readRevision;
        } else if (isRevisionNewer(nodeStore, r, lastRevision)) {
            lastRevision = r;
        }
    }
    if (branch != null) {
        // read from a branch
        // -> possibly overlay with unsaved last revs from branch
        lastRevs.updateBranch(branch.getUnsavedLastRevision(path, readRevision));
        Revision r = lastRevs.getBranchRevision();
        if (r != null) {
            lastRevision = r;
        }
    }
    n.setLastRevision(lastRevision);
    return n;
}","/**
 * Returns a {@link DocumentNodeState} as seen at the given
 * <code>readRevision</code>.
 *
 * @param nodeStore    the node store.
 * @param readRevision the read revision.
 * @param lastModified the revision when this node was last modified, but
 *                     the value is potentially not yet reflected in this
 *                     document.
 *                     See {@link RevisionContext#getPendingModifications()}.
 * @return the node or <code>null</code> if the node doesn't exist at the
 *         given read revision.
 */
","@CheckForNull
public DocumentNodeState getNodeAtRevision(@Nonnull DocumentNodeStore nodeStore, @Nonnull Revision readRevision, @Nullable Revision lastModified) {
    Map<Revision, String> validRevisions = Maps.newHashMap();
    Branch branch = nodeStore.getBranches().getBranch(readRevision);
    LastRevs lastRevs = new LastRevs(getLastRev(), readRevision, branch);
        lastRevs.update(lastModified);
    Revision min = getLiveRevision(nodeStore, readRevision, validRevisions, lastRevs);
    if (min == null) {
                return null;
    }
    String path = getPath();
    DocumentNodeState n = new DocumentNodeState(nodeStore, path, readRevision, hasChildren());
    Revision lastRevision = min;
    for (String key : keySet()) {
        if (!Utils.isPropertyName(key)) {
            continue;
        }
                Value value = getLatestValue(nodeStore, getLocalMap(key), min, readRevision, validRevisions, lastRevs);
                if (!getPreviousRanges().isEmpty()) {
            Revision newest = getLocalMap(key).firstKey();
            if (isRevisionNewer(nodeStore, newest, value.revision)) {
                                                Revision newestPrev = getPreviousRanges().firstKey();
                if (isRevisionNewer(nodeStore, newestPrev, value.revision)) {
                                                            value = null;
                }
            }
        }
        if (value == null && !getPreviousRanges().isEmpty()) {
                        value = getLatestValue(nodeStore, getValueMap(key), min, readRevision, validRevisions, lastRevs);
        }
        String propertyName = Utils.unescapePropertyName(key);
        String v = value != null ? value.value : null;
        n.setProperty(propertyName, v);
                if (value != null && isRevisionNewer(nodeStore, value.revision, lastRevision)) {
            lastRevision = value.revision;
        }
    }
                        Revision branchBase = null;
    if (branch != null) {
        branchBase = branch.getBase(readRevision);
    }
    for (Revision r : lastRevs.get().values()) {
                if (isRevisionNewer(nodeStore, r, readRevision)) {
                                                                        lastRevision = readRevision;
            continue;
        } else if (branchBase != null && isRevisionNewer(nodeStore, r, branchBase)) {
                                                                        r = branchBase;
        }
        if (revisionAreAmbiguous(nodeStore, r, lastRevision)) {
                                    lastRevision = readRevision;
        } else if (isRevisionNewer(nodeStore, r, lastRevision)) {
            lastRevision = r;
        }
    }
    if (branch != null) {
                        lastRevs.updateBranch(branch.getUnsavedLastRevision(path, readRevision));
        Revision r = lastRevs.getBranchRevision();
        if (r != null) {
            lastRevision = r;
        }
    }
    n.setLastRevision(lastRevision);
    return n;
}",2.272727272727273,0.5023923444976076,3.2,1.0,2.8333333333333335,0.882936507936508,-1.1138830162085973,2.6666666666666665,-0.02631578947368421,3.918546820882534
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1614_86edbffb,1,"@Override
protected TokenStreamComponents createComponents(final String fieldName, final Reader reader) {
    WhitespaceTokenizer src = new WhitespaceTokenizer(matchVersion, reader);
    TokenStream tok = new LowerCaseFilter(matchVersion, src);
    tok = new WordDelimiterFilter(tok, WordDelimiterFilter.GENERATE_WORD_PARTS | WordDelimiterFilter.STEM_ENGLISH_POSSESSIVE | WordDelimiterFilter.GENERATE_NUMBER_PARTS, null);
    return new TokenStreamComponents(src, tok);
}",,"@Override
protected TokenStreamComponents createComponents(final String fieldName, final Reader reader) {
    WhitespaceTokenizer src = new WhitespaceTokenizer(matchVersion, reader);
    TokenStream tok = new LowerCaseFilter(matchVersion, src);
    tok = new WordDelimiterFilter(tok, WordDelimiterFilter.GENERATE_WORD_PARTS | WordDelimiterFilter.STEM_ENGLISH_POSSESSIVE | WordDelimiterFilter.GENERATE_NUMBER_PARTS, null);
    return new TokenStreamComponents(src, tok);
}",-0.3181818181818182,-0.48325358851674655,-0.6,-1.0,-0.4166666666666667,-0.041666666666666706,0.3443269908386188,-0.5,0.0,-0.04715686105012016
Closure,64,2,"public Void call() throws Exception {
    if (options.printInputDelimiter) {
        if ((cb.getLength() > 0) && !cb.endsWith(""\n"")) {
            // Make sure that the label starts on a new line
            cb.append(""\n"");
        }
        Preconditions.checkState(root.getType() == Token.SCRIPT);
        String delimiter = options.inputDelimiter;
        String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);
        Preconditions.checkState(sourceName != null);
        Preconditions.checkState(!sourceName.isEmpty());
        delimiter = delimiter.replaceAll(""%name%"", sourceName).replaceAll(""%num%"", String.valueOf(inputSeqNum));
        cb.append(delimiter).append(""\n"");
    }
    if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {
        cb.append(""/*\n"").append(root.getJSDocInfo().getLicense()).append(""*/\n"");
    }
    // root node's mappings are offset by the given string builder buffer.
    if (options.sourceMapOutputPath != null) {
        sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());
    }
    // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'
    // for the first input file
    String code = toSource(root, sourceMap);
    if (!code.isEmpty()) {
        cb.append(code);
        // In order to avoid parse ambiguity when files are concatenated
        // together, all files should end in a semi-colon. Do a quick
        // heuristic check if there's an obvious semi-colon already there.
        int length = code.length();
        char lastChar = code.charAt(length - 1);
        char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\0';
        boolean hasSemiColon = lastChar == ';' || (lastChar == '\n' && secondLastChar == ';');
        if (!hasSemiColon) {
            cb.append("";"");
        }
    }
    return null;
}",,"public Void call() throws Exception {
    if (options.printInputDelimiter) {
        if ((cb.getLength() > 0) && !cb.endsWith(""\n"")) {
                        cb.append(""\n"");
        }
        Preconditions.checkState(root.getType() == Token.SCRIPT);
        String delimiter = options.inputDelimiter;
        String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);
        Preconditions.checkState(sourceName != null);
        Preconditions.checkState(!sourceName.isEmpty());
        delimiter = delimiter.replaceAll(""%name%"", sourceName).replaceAll(""%num%"", String.valueOf(inputSeqNum));
        cb.append(delimiter).append(""\n"");
    }
    if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {
        cb.append(""/*\n"").append(root.getJSDocInfo().getLicense()).append(""*/\n"");
    }
        if (options.sourceMapOutputPath != null) {
        sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());
    }
            String code = toSource(root, sourceMap);
    if (!code.isEmpty()) {
        cb.append(code);
                                int length = code.length();
        char lastChar = code.charAt(length - 1);
        char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\0';
        boolean hasSemiColon = lastChar == ';' || (lastChar == '\n' && secondLastChar == ';');
        if (!hasSemiColon) {
            cb.append("";"");
        }
    }
    return null;
}",0.8181818181818182,-0.10047846889952174,0.8,0.0,1.0833333333333333,1.4365079365079365,-0.6484848484848482,2.1666666666666665,-0.02631578947368421,3.4607492954824433
maven,remotes/origin/bugs-dot-jar_MNG-4518_f5ebc72d,1,"private static int getRelationOrder(String value, RangeValue rangeValue, boolean isLeft) {
    if (rangeValue.value.length() <= 0) {
        return isLeft ? 1 : -1;
    }
    value = value.replaceAll(""[^0-9\\.\\-\\_]"", """");
    List<String> valueTokens = new ArrayList<String>(Arrays.asList(value.split(""[\\.\\-\\_]"")));
    List<String> rangeValueTokens = new ArrayList<String>(Arrays.asList(rangeValue.value.split(""\\."")));
    int max = Math.max(valueTokens.size(), rangeValueTokens.size());
    addZeroTokens(valueTokens, max);
    addZeroTokens(rangeValueTokens, max);
    if (value.equals(rangeValue.getValue())) {
        if (!rangeValue.isClosed()) {
            return isLeft ? -1 : 1;
        }
        return 0;
    }
    for (int i = 0; i < valueTokens.size() && i < rangeValueTokens.size(); i++) {
        int x = Integer.parseInt(valueTokens.get(i));
        int y = Integer.parseInt(rangeValueTokens.get(i));
        if (x < y) {
            return -1;
        } else if (x > y) {
            return 1;
        }
    }
    if (!rangeValue.isClosed()) {
        return isLeft ? -1 : 1;
    }
    return 0;
}",,"private static int getRelationOrder(String value, RangeValue rangeValue, boolean isLeft) {
    if (rangeValue.value.length() <= 0) {
        return isLeft ? 1 : -1;
    }
    value = value.replaceAll(""[^0-9\\.\\-\\_]"", """");
    List<String> valueTokens = new ArrayList<String>(Arrays.asList(value.split(""[\\.\\-\\_]"")));
    List<String> rangeValueTokens = new ArrayList<String>(Arrays.asList(rangeValue.value.split(""\\."")));
    int max = Math.max(valueTokens.size(), rangeValueTokens.size());
    addZeroTokens(valueTokens, max);
    addZeroTokens(rangeValueTokens, max);
    if (value.equals(rangeValue.getValue())) {
        if (!rangeValue.isClosed()) {
            return isLeft ? -1 : 1;
        }
        return 0;
    }
    for (int i = 0; i < valueTokens.size() && i < rangeValueTokens.size(); i++) {
        int x = Integer.parseInt(valueTokens.get(i));
        int y = Integer.parseInt(rangeValueTokens.get(i));
        if (x < y) {
            return -1;
        } else if (x > y) {
            return 1;
        }
    }
    if (!rangeValue.isClosed()) {
        return isLeft ? -1 : 1;
    }
    return 0;
}",0.7272727272727273,0.02870813397129168,1.4,0.5,1.3333333333333333,1.8115079365079367,-0.5915433403805496,1.25,-0.02631578947368421,3.0210750159921163
flink,remotes/origin/bugs-dot-jar_FLINK-2567_948b6e05,3,"protected int skipFields(byte[] bytes, int startPos, int limit, byte[] delim) {
    int i = startPos;
    final int delimLimit = limit - delim.length + 1;
    if (quotedStringParsing == true && bytes[i] == quoteCharacter) {
        // quoted string parsing enabled and field is quoted
        // search for ending quote character
        i++;
        while (i < limit && bytes[i] != quoteCharacter) {
            i++;
        }
        i++;
        if (i == limit) {
            // we are at the end of the record
            return limit;
        } else if (i < delimLimit && FieldParser.delimiterNext(bytes, i, delim)) {
            // we are not at the end, check if delimiter comes next
            return i + delim.length;
        } else {
            // delimiter did not follow end quote. Error...
            return -1;
        }
    } else {
        // field is not quoted
        while (i < delimLimit && !FieldParser.delimiterNext(bytes, i, delim)) {
            i++;
        }
        if (i >= delimLimit) {
            // no delimiter found. We are at the end of the record
            return limit;
        } else {
            // delimiter found.
            return i + delim.length;
        }
    }
}",,"protected int skipFields(byte[] bytes, int startPos, int limit, byte[] delim) {
    int i = startPos;
    final int delimLimit = limit - delim.length + 1;
    if (quotedStringParsing == true && bytes[i] == quoteCharacter) {
                        i++;
        while (i < limit && bytes[i] != quoteCharacter) {
            i++;
        }
        i++;
        if (i == limit) {
                        return limit;
        } else if (i < delimLimit && FieldParser.delimiterNext(bytes, i, delim)) {
                        return i + delim.length;
        } else {
                        return -1;
        }
    } else {
                while (i < delimLimit && !FieldParser.delimiterNext(bytes, i, delim)) {
            i++;
        }
        if (i >= delimLimit) {
                        return limit;
        } else {
                        return i + delim.length;
        }
    }
}",0.5909090909090909,0.21052631578947367,0.6,0.5,1.0833333333333333,3.2063492063492065,-0.4365045806906271,-0.3333333333333333,0.0,2.843134339540003
commons-math,remotes/origin/bugs-dot-jar_MATH-413_51aa6e6c,1,"/**
 * {@inheritDoc}
 */
public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal, final double min, final double max) throws FunctionEvaluationException {
    optima = new UnivariateRealPointValuePair[starts];
    totalEvaluations = 0;
    // Multi-start loop.
    for (int i = 0; i < starts; ++i) {
        try {
            final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);
            final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min);
            optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2));
        } catch (FunctionEvaluationException fee) {
            optima[i] = null;
        } catch (ConvergenceException ce) {
            optima[i] = null;
        }
        final int usedEvaluations = optimizer.getEvaluations();
        optimizer.setMaxEvaluations(optimizer.getMaxEvaluations() - usedEvaluations);
        totalEvaluations += usedEvaluations;
    }
    sortPairs(goal);
    if (optima[0] == null) {
        throw new ConvergenceException(LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT, starts);
    }
    // Return the point with the best objective function value.
    return optima[0];
}","/**
 * {@inheritDoc}
 */
","public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal, final double min, final double max) throws FunctionEvaluationException {
    optima = new UnivariateRealPointValuePair[starts];
    totalEvaluations = 0;
        for (int i = 0; i < starts; ++i) {
        try {
            final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);
            final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min);
            optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2));
        } catch (FunctionEvaluationException fee) {
            optima[i] = null;
        } catch (ConvergenceException ce) {
            optima[i] = null;
        }
        final int usedEvaluations = optimizer.getEvaluations();
        optimizer.setMaxEvaluations(optimizer.getMaxEvaluations() - usedEvaluations);
        totalEvaluations += usedEvaluations;
    }
    sortPairs(goal);
    if (optima[0] == null) {
        throw new ConvergenceException(LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT, starts);
    }
        return optima[0];
}",0.4090909090909091,0.30143540669856456,0.8,0.0,0.08333333333333333,1.6944444444444446,-0.43340380549682866,0.25,0.0,2.5100879998616894
commons-math,remotes/origin/bugs-dot-jar_MATH-288_38983e82,1,"/**
 * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).
 * @param tableau simple tableau for the problem
 * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}
 * @return row with the minimum ratio
 */
private Integer getPivotRow(final int col, final SimplexTableau tableau) {
    double minRatio = Double.MAX_VALUE;
    Integer minRatioPos = null;
    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {
        double rhs = tableau.getEntry(i, tableau.getWidth() - 1);
        if (MathUtils.compareTo(tableau.getEntry(i, col), 0, epsilon) >= 0) {
            double ratio = rhs / tableau.getEntry(i, col);
            if (ratio < minRatio) {
                minRatio = ratio;
                minRatioPos = i;
            }
        }
    }
    return minRatioPos;
}","/**
 * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).
 * @param tableau simple tableau for the problem
 * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}
 * @return row with the minimum ratio
 */
","private Integer getPivotRow(final int col, final SimplexTableau tableau) {
    double minRatio = Double.MAX_VALUE;
    Integer minRatioPos = null;
    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {
        double rhs = tableau.getEntry(i, tableau.getWidth() - 1);
        if (MathUtils.compareTo(tableau.getEntry(i, col), 0, epsilon) >= 0) {
            double ratio = rhs / tableau.getEntry(i, col);
            if (ratio < minRatio) {
                minRatio = ratio;
                minRatioPos = i;
            }
        }
    }
    return minRatioPos;
}",0.045454545454545456,0.9760765550239235,0.0,0.5,0.5,0.876984126984127,-0.11937984496124027,0.08333333333333333,0.0,0.6925767765656424
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3433_b76b31f7,0,"/**
 * Persist the pending changes to _lastRev to the given store. This method
 * will persist a snapshot of the pending revisions by acquiring the passed
 * lock for a short period of time.
 *
 * @param store the document node store.
 * @param snapshot callback when the snapshot of the pending changes is
 *                 acquired.
 * @param lock the lock to acquire to get a consistent snapshot of the
 *             revisions to write back.
 * @return stats about the write operation.
 */
public BackgroundWriteStats persist(@Nonnull DocumentNodeStore store, @Nonnull Snapshot snapshot, @Nonnull Lock lock) {
    BackgroundWriteStats stats = new BackgroundWriteStats();
    if (map.size() == 0) {
        return stats;
    }
    checkNotNull(store);
    checkNotNull(lock);
    Clock clock = store.getClock();
    long time = clock.getTime();
    // get a copy of the map while holding the lock
    lock.lock();
    stats.lock = clock.getTime() - time;
    time = clock.getTime();
    Map<String, Revision> pending;
    try {
        snapshot.acquiring();
        pending = Maps.newTreeMap(PathComparator.INSTANCE);
        pending.putAll(map);
    } finally {
        lock.unlock();
    }
    stats.num = pending.size();
    UpdateOp updateOp = null;
    Revision lastRev = null;
    PeekingIterator<String> paths = Iterators.peekingIterator(pending.keySet().iterator());
    int i = 0;
    ArrayList<String> pathList = new ArrayList<String>();
    while (paths.hasNext()) {
        String p = paths.peek();
        Revision r = pending.get(p);
        int size = pathList.size();
        if (updateOp == null) {
            // create UpdateOp
            Commit commit = new Commit(store, r, null, null);
            updateOp = commit.getUpdateOperationForNode(p);
            NodeDocument.setLastRev(updateOp, r);
            lastRev = r;
            pathList.add(p);
            paths.next();
            i++;
        } else if (r.equals(lastRev)) {
            // use multi update when possible
            pathList.add(p);
            paths.next();
            i++;
        }
        // - the update limit is reached
        if (i + 2 > pending.size() || size == pathList.size() || pathList.size() >= BACKGROUND_MULTI_UPDATE_LIMIT) {
            List<String> ids = new ArrayList<String>();
            for (String path : pathList) {
                ids.add(Utils.getIdFromPath(path));
            }
            store.getDocumentStore().update(NODES, ids, updateOp);
            LOG.debug(""Updated _lastRev to {} on {}"", lastRev, ids);
            for (String path : pathList) {
                map.remove(path, lastRev);
            }
            pathList.clear();
            updateOp = null;
            lastRev = null;
        }
    }
    Revision writtenRootRev = pending.get(""/"");
    if (writtenRootRev != null) {
        int cid = writtenRootRev.getClusterId();
        if (store.getDocumentStore().find(org.apache.jackrabbit.oak.plugins.document.Collection.CLUSTER_NODES, String.valueOf(cid)) != null) {
            UpdateOp update = new UpdateOp(String.valueOf(cid), false);
            update.equals(Document.ID, null, String.valueOf(cid));
            update.set(ClusterNodeInfo.LAST_WRITTEN_ROOT_REV_KEY, writtenRootRev.toString());
            store.getDocumentStore().findAndUpdate(org.apache.jackrabbit.oak.plugins.document.Collection.CLUSTER_NODES, update);
        }
    }
    stats.write = clock.getTime() - time;
    return stats;
}","/**
 * Persist the pending changes to _lastRev to the given store. This method
 * will persist a snapshot of the pending revisions by acquiring the passed
 * lock for a short period of time.
 *
 * @param store the document node store.
 * @param snapshot callback when the snapshot of the pending changes is
 *                 acquired.
 * @param lock the lock to acquire to get a consistent snapshot of the
 *             revisions to write back.
 * @return stats about the write operation.
 */
","public BackgroundWriteStats persist(@Nonnull DocumentNodeStore store, @Nonnull Snapshot snapshot, @Nonnull Lock lock) {
    BackgroundWriteStats stats = new BackgroundWriteStats();
    if (map.size() == 0) {
        return stats;
    }
    checkNotNull(store);
    checkNotNull(lock);
    Clock clock = store.getClock();
    long time = clock.getTime();
        lock.lock();
    stats.lock = clock.getTime() - time;
    time = clock.getTime();
    Map<String, Revision> pending;
    try {
        snapshot.acquiring();
        pending = Maps.newTreeMap(PathComparator.INSTANCE);
        pending.putAll(map);
    } finally {
        lock.unlock();
    }
    stats.num = pending.size();
    UpdateOp updateOp = null;
    Revision lastRev = null;
    PeekingIterator<String> paths = Iterators.peekingIterator(pending.keySet().iterator());
    int i = 0;
    ArrayList<String> pathList = new ArrayList<String>();
    while (paths.hasNext()) {
        String p = paths.peek();
        Revision r = pending.get(p);
        int size = pathList.size();
        if (updateOp == null) {
                        Commit commit = new Commit(store, r, null, null);
            updateOp = commit.getUpdateOperationForNode(p);
            NodeDocument.setLastRev(updateOp, r);
            lastRev = r;
            pathList.add(p);
            paths.next();
            i++;
        } else if (r.equals(lastRev)) {
                        pathList.add(p);
            paths.next();
            i++;
        }
                if (i + 2 > pending.size() || size == pathList.size() || pathList.size() >= BACKGROUND_MULTI_UPDATE_LIMIT) {
            List<String> ids = new ArrayList<String>();
            for (String path : pathList) {
                ids.add(Utils.getIdFromPath(path));
            }
            store.getDocumentStore().update(NODES, ids, updateOp);
            LOG.debug(""Updated _lastRev to {} on {}"", lastRev, ids);
            for (String path : pathList) {
                map.remove(path, lastRev);
            }
            pathList.clear();
            updateOp = null;
            lastRev = null;
        }
    }
    Revision writtenRootRev = pending.get(""/"");
    if (writtenRootRev != null) {
        int cid = writtenRootRev.getClusterId();
        if (store.getDocumentStore().find(org.apache.jackrabbit.oak.plugins.document.Collection.CLUSTER_NODES, String.valueOf(cid)) != null) {
            UpdateOp update = new UpdateOp(String.valueOf(cid), false);
            update.equals(Document.ID, null, String.valueOf(cid));
            update.set(ClusterNodeInfo.LAST_WRITTEN_ROOT_REV_KEY, writtenRootRev.toString());
            store.getDocumentStore().findAndUpdate(org.apache.jackrabbit.oak.plugins.document.Collection.CLUSTER_NODES, update);
        }
    }
    stats.write = clock.getTime() - time;
    return stats;
}",2.590909090909091,0.42583732057416257,1.2,0.5,1.4166666666666667,1.619047619047619,-1.1384073291050032,3.6666666666666665,-0.02631578947368421,8.473636347919296
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1848_093b9128,1,"/**
 * Syncs the properties specified in the {@code mapping} from the external identity to the given authorizable.
 * Note that this method does not check for value equality and just blindly copies or deletes the properties.
 *
 * @param ext external identity
 * @param auth the authorizable
 * @param mapping the property mapping
 * @throws RepositoryException if an error occurs
 */
private void syncProperties(ExternalIdentity ext, Authorizable auth, Map<String, String> mapping) throws RepositoryException {
    Map<String, ?> properties = ext.getProperties();
    for (Map.Entry<String, String> entry : mapping.entrySet()) {
        String relPath = entry.getKey();
        String name = entry.getValue();
        Object obj = properties.get(name);
        if (obj == null) {
            auth.removeProperty(relPath);
        } else {
            if (obj instanceof Collection) {
                auth.setProperty(relPath, createValues((Collection) obj));
            } else if (obj instanceof byte[] || obj instanceof char[]) {
                auth.setProperty(relPath, createValue(obj));
            } else if (obj instanceof Object[]) {
                auth.setProperty(relPath, createValues(Arrays.asList((Object[]) obj)));
            } else {
                auth.setProperty(relPath, createValue(obj));
            }
        }
    }
}","/**
 * Syncs the properties specified in the {@code mapping} from the external identity to the given authorizable.
 * Note that this method does not check for value equality and just blindly copies or deletes the properties.
 *
 * @param ext external identity
 * @param auth the authorizable
 * @param mapping the property mapping
 * @throws RepositoryException if an error occurs
 */
","private void syncProperties(ExternalIdentity ext, Authorizable auth, Map<String, String> mapping) throws RepositoryException {
    Map<String, ?> properties = ext.getProperties();
    for (Map.Entry<String, String> entry : mapping.entrySet()) {
        String relPath = entry.getKey();
        String name = entry.getValue();
        Object obj = properties.get(name);
        if (obj == null) {
            auth.removeProperty(relPath);
        } else {
            if (obj instanceof Collection) {
                auth.setProperty(relPath, createValues((Collection) obj));
            } else if (obj instanceof byte[] || obj instanceof char[]) {
                auth.setProperty(relPath, createValue(obj));
            } else if (obj instanceof Object[]) {
                auth.setProperty(relPath, createValues(Arrays.asList((Object[]) obj)));
            } else {
                auth.setProperty(relPath, createValue(obj));
            }
        }
    }
}",0.3181818181818182,0.8803827751196173,0.4,1.5,0.08333333333333333,0.10515873015873016,-0.3254404510218463,0.75,-0.02631578947368421,0.26101669519314435
Math,103,3,"/**
 * For this disbution, X, this method returns P(X &lt; <code>x</code>).
 * @param x the value at which the CDF is evaluated.
 * @return CDF evaluted at <code>x</code>.
 * @throws MathException if the algorithm fails to converge; unless
 * x is more than 20 standard deviations from the mean, in which case the
 * convergence exception is caught and 0 or 1 is returned.
 */
public double cumulativeProbability(double x) throws MathException {
    return 0.5 * (1.0 + Erf.erf((x - mean) / (standardDeviation * Math.sqrt(2.0))));
}","/**
 * For this disbution, X, this method returns P(X &lt; <code>x</code>).
 * @param x the value at which the CDF is evaluated.
 * @return CDF evaluted at <code>x</code>.
 * @throws MathException if the algorithm fails to converge; unless
 * x is more than 20 standard deviations from the mean, in which case the
 * convergence exception is caught and 0 or 1 is returned.
 */
","public double cumulativeProbability(double x) throws MathException {
    return 0.5 * (1.0 + Erf.erf((x - mean) / (standardDeviation * Math.sqrt(2.0))));
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,0.06150793650793648,0.8314305849189569,-0.3333333333333333,0.5526315789473684,-0.08567625041060838
commons-math,remotes/origin/bugs-dot-jar_MATH-781_3c4cb189,1,"/**
 * Removes the phase 1 objective function, positive cost non-artificial variables,
 * and the non-basic artificial variables from this tableau.
 */
protected void dropPhase1Objective() {
    if (getNumObjectiveFunctions() == 1) {
        return;
    }
    List<Integer> columnsToDrop = new ArrayList<Integer>();
    columnsToDrop.add(0);
    // positive cost non-artificial variables
    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {
        final double entry = tableau.getEntry(0, i);
        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {
            columnsToDrop.add(i);
        }
    }
    // non-basic artificial variables
    for (int i = 0; i < getNumArtificialVariables(); i++) {
        int col = i + getArtificialVariableOffset();
        if (getBasicRow(col) == null) {
            columnsToDrop.add(col);
        }
    }
    double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];
    for (int i = 1; i < getHeight(); i++) {
        int col = 0;
        for (int j = 0; j < getWidth(); j++) {
            if (!columnsToDrop.contains(j)) {
                matrix[i - 1][col++] = tableau.getEntry(i, j);
            }
        }
    }
    for (int i = columnsToDrop.size() - 1; i >= 0; i--) {
        columnLabels.remove((int) columnsToDrop.get(i));
    }
    this.tableau = new Array2DRowRealMatrix(matrix);
    this.numArtificialVariables = 0;
}","/**
 * Removes the phase 1 objective function, positive cost non-artificial variables,
 * and the non-basic artificial variables from this tableau.
 */
","protected void dropPhase1Objective() {
    if (getNumObjectiveFunctions() == 1) {
        return;
    }
    List<Integer> columnsToDrop = new ArrayList<Integer>();
    columnsToDrop.add(0);
        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {
        final double entry = tableau.getEntry(0, i);
        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {
            columnsToDrop.add(i);
        }
    }
        for (int i = 0; i < getNumArtificialVariables(); i++) {
        int col = i + getArtificialVariableOffset();
        if (getBasicRow(col) == null) {
            columnsToDrop.add(col);
        }
    }
    double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];
    for (int i = 1; i < getHeight(); i++) {
        int col = 0;
        for (int j = 0; j < getWidth(); j++) {
            if (!columnsToDrop.contains(j)) {
                matrix[i - 1][col++] = tableau.getEntry(i, j);
            }
        }
    }
    for (int i = columnsToDrop.size() - 1; i >= 0; i--) {
        columnLabels.remove((int) columnsToDrop.get(i));
    }
    this.tableau = new Array2DRowRealMatrix(matrix);
    this.numArtificialVariables = 0;
}",0.8636363636363636,0.26315789473684204,1.2,0.5,1.4166666666666667,2.28968253968254,-0.6394644115574347,1.25,-0.02631578947368421,4.0139209211459
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1348_6ff92b12,1,"public int start() throws IOException {
    if (configError)
        return 1;
    String input;
    if (isVerbose())
        printInfo();
    String home = System.getProperty(""HOME"");
    if (home == null)
        home = System.getenv(""HOME"");
    String configDir = home + ""/"" + HISTORY_DIR_NAME;
    String historyPath = configDir + ""/"" + HISTORY_FILE_NAME;
    File accumuloDir = new File(configDir);
    if (!accumuloDir.exists() && !accumuloDir.mkdirs())
        log.warn(""Unable to make directory for history at "" + accumuloDir);
    try {
        History history = new History();
        history.setHistoryFile(new File(historyPath));
        reader.setHistory(history);
    } catch (IOException e) {
        log.warn(""Unable to load history file at "" + historyPath);
    }
    ShellCompletor userCompletor = null;
    if (execFile != null) {
        java.util.Scanner scanner = new java.util.Scanner(new File(execFile));
        try {
            while (scanner.hasNextLine()) execCommand(scanner.nextLine(), true, isVerbose());
        } finally {
            scanner.close();
        }
    } else if (execCommand != null) {
        for (String command : execCommand.split(""\n"")) {
            execCommand(command, true, isVerbose());
        }
        return exitCode;
    }
    while (true) {
        if (hasExited())
            return exitCode;
        // If tab completion is true we need to reset
        if (tabCompletion) {
            if (userCompletor != null)
                reader.removeCompletor(userCompletor);
            userCompletor = setupCompletion();
            reader.addCompletor(userCompletor);
        }
        reader.setDefaultPrompt(getDefaultPrompt());
        input = reader.readLine();
        if (input == null) {
            reader.printNewline();
            return exitCode;
        }
        // user canceled
        execCommand(input, disableAuthTimeout, false);
    }
}",,"public int start() throws IOException {
    if (configError)
        return 1;
    String input;
    if (isVerbose())
        printInfo();
    String home = System.getProperty(""HOME"");
    if (home == null)
        home = System.getenv(""HOME"");
    String configDir = home + ""/"" + HISTORY_DIR_NAME;
    String historyPath = configDir + ""/"" + HISTORY_FILE_NAME;
    File accumuloDir = new File(configDir);
    if (!accumuloDir.exists() && !accumuloDir.mkdirs())
        log.warn(""Unable to make directory for history at "" + accumuloDir);
    try {
        History history = new History();
        history.setHistoryFile(new File(historyPath));
        reader.setHistory(history);
    } catch (IOException e) {
        log.warn(""Unable to load history file at "" + historyPath);
    }
    ShellCompletor userCompletor = null;
    if (execFile != null) {
        java.util.Scanner scanner = new java.util.Scanner(new File(execFile));
        try {
            while (scanner.hasNextLine()) execCommand(scanner.nextLine(), true, isVerbose());
        } finally {
            scanner.close();
        }
    } else if (execCommand != null) {
        for (String command : execCommand.split(""\n"")) {
            execCommand(command, true, isVerbose());
        }
        return exitCode;
    }
    while (true) {
        if (hasExited())
            return exitCode;
                if (tabCompletion) {
            if (userCompletor != null)
                reader.removeCompletor(userCompletor);
            userCompletor = setupCompletion();
            reader.addCompletor(userCompletor);
        }
        reader.setDefaultPrompt(getDefaultPrompt());
        input = reader.readLine();
        if (input == null) {
            reader.printNewline();
            return exitCode;
        }
                execCommand(input, disableAuthTimeout, false);
    }
}",1.7727272727272727,0.1626794258373205,2.2,0.5,1.6666666666666667,0.8253968253968255,-0.9255813953488368,1.75,-0.02631578947368421,2.2535318084634315
camel,remotes/origin/bugs-dot-jar_CAMEL-9032_108d94f7,1,"/**
 * Choose one of the available methods to invoke if we can match
 * the message body to the body parameter
 *
 * @param pojo the bean to invoke a method on
 * @param exchange the message exchange
 * @param name an optional name of the method that must match, use <tt>null</tt> to indicate all methods
 * @return the method to invoke or null if no definitive method could be matched
 * @throws AmbiguousMethodCallException is thrown if cannot choose method due to ambiguity
 */
protected MethodInfo chooseMethod(Object pojo, Exchange exchange, String name) throws AmbiguousMethodCallException {
    // @Handler should be select first
    // then any single method that has a custom @annotation
    // or any single method that has a match parameter type that matches the Exchange payload
    // and last then try to select the best among the rest
    // must use defensive copy, to avoid altering the shared lists
    // and we want to remove unwanted operations from these local lists
    final List<MethodInfo> localOperationsWithBody = new ArrayList<MethodInfo>(operationsWithBody);
    final List<MethodInfo> localOperationsWithNoBody = new ArrayList<MethodInfo>(operationsWithNoBody);
    final List<MethodInfo> localOperationsWithCustomAnnotation = new ArrayList<MethodInfo>(operationsWithCustomAnnotation);
    final List<MethodInfo> localOperationsWithHandlerAnnotation = new ArrayList<MethodInfo>(operationsWithHandlerAnnotation);
    if (name != null) {
        // filter all lists to only include methods with this name
        removeNonMatchingMethods(localOperationsWithHandlerAnnotation, name);
        removeNonMatchingMethods(localOperationsWithCustomAnnotation, name);
        removeNonMatchingMethods(localOperationsWithBody, name);
        removeNonMatchingMethods(localOperationsWithNoBody, name);
    } else {
        // remove all getter/setter as we do not want to consider these methods
        removeAllSetterOrGetterMethods(localOperationsWithHandlerAnnotation);
        removeAllSetterOrGetterMethods(localOperationsWithCustomAnnotation);
        removeAllSetterOrGetterMethods(localOperationsWithBody);
        removeAllSetterOrGetterMethods(localOperationsWithNoBody);
    }
    if (localOperationsWithHandlerAnnotation.size() > 1) {
        // if we have more than 1 @Handler then its ambiguous
        throw new AmbiguousMethodCallException(exchange, localOperationsWithHandlerAnnotation);
    }
    if (localOperationsWithHandlerAnnotation.size() == 1) {
        // methods with handler should be preferred
        return localOperationsWithHandlerAnnotation.get(0);
    } else if (localOperationsWithCustomAnnotation.size() == 1) {
        // if there is one method with an annotation then use that one
        return localOperationsWithCustomAnnotation.get(0);
    }
    // named method and with no parameters
    boolean noParameters = name != null && name.endsWith(""()"");
    if (noParameters && localOperationsWithNoBody.size() == 1) {
        // if there was a method name configured and it has no parameters, then use the method with no body (eg no parameters)
        return localOperationsWithNoBody.get(0);
    } else if (!noParameters && localOperationsWithBody.size() == 1 && localOperationsWithCustomAnnotation.isEmpty()) {
        // if there is one method with body then use that one
        return localOperationsWithBody.get(0);
    }
    Collection<MethodInfo> possibleOperations = new ArrayList<MethodInfo>();
    possibleOperations.addAll(localOperationsWithBody);
    possibleOperations.addAll(localOperationsWithCustomAnnotation);
    if (!possibleOperations.isEmpty()) {
        // multiple possible operations so find the best suited if possible
        MethodInfo answer = chooseMethodWithMatchingBody(exchange, possibleOperations, localOperationsWithCustomAnnotation);
        if (answer == null && name != null) {
            // do we have hardcoded parameters values provided from the method name then fallback and try that
            String parameters = ObjectHelper.between(name, ""("", "")"");
            if (parameters != null) {
                // special as we have hardcoded parameters, so we need to choose method that matches those parameters the best
                answer = chooseMethodWithMatchingParameters(exchange, parameters, possibleOperations);
            }
        }
        if (answer == null && possibleOperations.size() > 1) {
            answer = getSingleCovariantMethod(possibleOperations);
        }
        if (answer == null) {
            throw new AmbiguousMethodCallException(exchange, possibleOperations);
        } else {
            return answer;
        }
    }
    // not possible to determine
    return null;
}","/**
 * Choose one of the available methods to invoke if we can match
 * the message body to the body parameter
 *
 * @param pojo the bean to invoke a method on
 * @param exchange the message exchange
 * @param name an optional name of the method that must match, use <tt>null</tt> to indicate all methods
 * @return the method to invoke or null if no definitive method could be matched
 * @throws AmbiguousMethodCallException is thrown if cannot choose method due to ambiguity
 */
","protected MethodInfo chooseMethod(Object pojo, Exchange exchange, String name) throws AmbiguousMethodCallException {
                            final List<MethodInfo> localOperationsWithBody = new ArrayList<MethodInfo>(operationsWithBody);
    final List<MethodInfo> localOperationsWithNoBody = new ArrayList<MethodInfo>(operationsWithNoBody);
    final List<MethodInfo> localOperationsWithCustomAnnotation = new ArrayList<MethodInfo>(operationsWithCustomAnnotation);
    final List<MethodInfo> localOperationsWithHandlerAnnotation = new ArrayList<MethodInfo>(operationsWithHandlerAnnotation);
    if (name != null) {
                removeNonMatchingMethods(localOperationsWithHandlerAnnotation, name);
        removeNonMatchingMethods(localOperationsWithCustomAnnotation, name);
        removeNonMatchingMethods(localOperationsWithBody, name);
        removeNonMatchingMethods(localOperationsWithNoBody, name);
    } else {
                removeAllSetterOrGetterMethods(localOperationsWithHandlerAnnotation);
        removeAllSetterOrGetterMethods(localOperationsWithCustomAnnotation);
        removeAllSetterOrGetterMethods(localOperationsWithBody);
        removeAllSetterOrGetterMethods(localOperationsWithNoBody);
    }
    if (localOperationsWithHandlerAnnotation.size() > 1) {
                throw new AmbiguousMethodCallException(exchange, localOperationsWithHandlerAnnotation);
    }
    if (localOperationsWithHandlerAnnotation.size() == 1) {
                return localOperationsWithHandlerAnnotation.get(0);
    } else if (localOperationsWithCustomAnnotation.size() == 1) {
                return localOperationsWithCustomAnnotation.get(0);
    }
        boolean noParameters = name != null && name.endsWith(""()"");
    if (noParameters && localOperationsWithNoBody.size() == 1) {
                return localOperationsWithNoBody.get(0);
    } else if (!noParameters && localOperationsWithBody.size() == 1 && localOperationsWithCustomAnnotation.isEmpty()) {
                return localOperationsWithBody.get(0);
    }
    Collection<MethodInfo> possibleOperations = new ArrayList<MethodInfo>();
    possibleOperations.addAll(localOperationsWithBody);
    possibleOperations.addAll(localOperationsWithCustomAnnotation);
    if (!possibleOperations.isEmpty()) {
                MethodInfo answer = chooseMethodWithMatchingBody(exchange, possibleOperations, localOperationsWithCustomAnnotation);
        if (answer == null && name != null) {
                        String parameters = ObjectHelper.between(name, ""("", "")"");
            if (parameters != null) {
                                answer = chooseMethodWithMatchingParameters(exchange, parameters, possibleOperations);
            }
        }
        if (answer == null && possibleOperations.size() > 1) {
            answer = getSingleCovariantMethod(possibleOperations);
        }
        if (answer == null) {
            throw new AmbiguousMethodCallException(exchange, possibleOperations);
        } else {
            return answer;
        }
    }
        return null;
}",1.7272727272727273,0.11004784688995216,2.0,0.5,1.8333333333333333,1.6845238095238095,-0.930937279774489,1.75,-0.02631578947368421,4.6216098154135175
JxPath,19,1,"/**
 * Get relative position of this among like-named siblings.
 * @return 1..n
 */
private int getRelativePositionByQName() {
    if (node instanceof Element) {
        Object parent = ((Element) node).getParent();
        if (!(parent instanceof Element)) {
            return 1;
        }
        List children = ((Element) parent).getContent();
        int count = 0;
        String name = ((Element) node).getQualifiedName();
        for (int i = 0; i < children.size(); i++) {
            Object child = children.get(i);
            if ((child instanceof Element) && ((Element) child).getQualifiedName().equals(name)) {
                count++;
            }
            if (child == node) {
                break;
            }
        }
        return count;
    }
    return 1;
}","/**
 * Get relative position of this among like-named siblings.
 * @return 1..n
 */
","private int getRelativePositionByQName() {
    if (node instanceof Element) {
        Object parent = ((Element) node).getParent();
        if (!(parent instanceof Element)) {
            return 1;
        }
        List children = ((Element) parent).getContent();
        int count = 0;
        String name = ((Element) node).getQualifiedName();
        for (int i = 0; i < children.size(); i++) {
            Object child = children.get(i);
            if ((child instanceof Element) && ((Element) child).getQualifiedName().equals(name)) {
                count++;
            }
            if (child == node) {
                break;
            }
        }
        return count;
    }
    return 1;
}",0.36363636363636365,0.5933014354066987,0.6,0.5,0.6666666666666666,0.9662698412698413,-0.30570824524312884,0.08333333333333333,0.07894736842105263,0.7056148176322445
wicket,remotes/origin/bugs-dot-jar_WICKET-2621_c849f986,1,"@Override
public void onFormComponent(FormComponent<?> formComponent) {
    if (formComponent.isVisible() && formComponent.isMultiPart()) {
        setMultiPart(true);
    }
}",,"@Override
public void onFormComponent(FormComponent<?> formComponent) {
    if (formComponent.isVisible() && formComponent.isMultiPart()) {
        setMultiPart(true);
    }
}",-0.36363636363636365,-0.004784688995215422,-0.4,-0.5,-0.08333333333333333,-0.3650793650793651,0.6062015503875966,-0.25,0.0,-0.16279340490885932
camel,remotes/origin/bugs-dot-jar_CAMEL-8106_39ccf5d6,1,"@Override
public Object next() {
    Object o = nextToken;
    try {
        nextToken = getNextToken();
    } catch (XMLStreamException e) {
    // 
    }
    return o;
}",,"@Override
public Object next() {
    Object o = nextToken;
    try {
        nextToken = getNextToken();
    } catch (XMLStreamException e) {
        }
    return o;
}",-0.22727272727272727,-0.22966507177033516,-0.4,-0.5,-0.4166666666666667,-0.3650793650793651,0.39844961240310084,-0.4166666666666667,2.4473684210526314,-0.16279340490885932
wicket,remotes/origin/bugs-dot-jar_WICKET-442_246d53c5,1,"/**
 *  Registers an error feedback message for this component
 *
 *  @param message
 *             The feedback message
 */
public final void error(final Serializable message) {
    getPage().getFeedbackMessages().error(this, message);
}","/**
 *  Registers an error feedback message for this component
 *
 *  @param message
 *             The feedback message
 */
","public final void error(final Serializable message) {
    getPage().getFeedbackMessages().error(this, message);
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,1.0253699788583508,-0.25,2.526315789473684,-0.16279340490885932
commons-math,remotes/origin/bugs-dot-jar_MATH-757_76b7413d,1,"/**
 * Sets the {@link ExpansionMode expansion mode}.
 *
 * @param expansionMode Expansion mode to use for resizing the array.
 * @deprecated As of 3.1 (to be removed in 4.0 as field will become ""final"").
 */
@Deprecated
public void setExpansionMode(ExpansionMode expansionMode) {
    this.expansionMode = expansionMode;
}","/**
 * Sets the {@link ExpansionMode expansion mode}.
 *
 * @param expansionMode Expansion mode to use for resizing the array.
 * @deprecated As of 3.1 (to be removed in 4.0 as field will become ""final"").
 */
","@Deprecated
public void setExpansionMode(ExpansionMode expansionMode) {
    this.expansionMode = expansionMode;
}",-0.45454545454545453,-0.6028708133971293,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.8940098661028892,-0.5,2.3421052631578947,-0.16279340490885932
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1190_e29dc4f5,3,"private void addCellsToWriter(Map<ByteBuffer, List<ColumnUpdate>> cells, BatchWriter writer) throws MutationsRejectedException {
    HashMap<Text, ColumnVisibility> vizMap = new HashMap<Text, ColumnVisibility>();
    for (Entry<ByteBuffer, List<ColumnUpdate>> entry : cells.entrySet()) {
        Mutation m = new Mutation(ByteBufferUtil.toBytes(entry.getKey()));
        for (ColumnUpdate update : entry.getValue()) {
            ColumnVisibility viz = EMPTY_VIS;
            if (update.isSetColVisibility()) {
                Text vizText = new Text(update.getColVisibility());
                viz = vizMap.get(vizText);
                if (viz == null) {
                    vizMap.put(vizText, viz = new ColumnVisibility(vizText));
                }
            }
            byte[] value = new byte[0];
            if (update.isSetValue())
                value = update.getValue();
            if (update.isSetTimestamp()) {
                if (update.isSetDeleteCell()) {
                    m.putDelete(update.getColFamily(), update.getColQualifier(), viz, update.getTimestamp());
                } else {
                    if (update.isSetDeleteCell()) {
                        m.putDelete(update.getColFamily(), update.getColQualifier(), viz, update.getTimestamp());
                    } else {
                        m.put(update.getColFamily(), update.getColQualifier(), viz, update.getTimestamp(), value);
                    }
                }
            } else {
                m.put(update.getColFamily(), update.getColQualifier(), viz, value);
            }
        }
        writer.addMutation(m);
    }
}",,"private void addCellsToWriter(Map<ByteBuffer, List<ColumnUpdate>> cells, BatchWriter writer) throws MutationsRejectedException {
    HashMap<Text, ColumnVisibility> vizMap = new HashMap<Text, ColumnVisibility>();
    for (Entry<ByteBuffer, List<ColumnUpdate>> entry : cells.entrySet()) {
        Mutation m = new Mutation(ByteBufferUtil.toBytes(entry.getKey()));
        for (ColumnUpdate update : entry.getValue()) {
            ColumnVisibility viz = EMPTY_VIS;
            if (update.isSetColVisibility()) {
                Text vizText = new Text(update.getColVisibility());
                viz = vizMap.get(vizText);
                if (viz == null) {
                    vizMap.put(vizText, viz = new ColumnVisibility(vizText));
                }
            }
            byte[] value = new byte[0];
            if (update.isSetValue())
                value = update.getValue();
            if (update.isSetTimestamp()) {
                if (update.isSetDeleteCell()) {
                    m.putDelete(update.getColFamily(), update.getColQualifier(), viz, update.getTimestamp());
                } else {
                    if (update.isSetDeleteCell()) {
                        m.putDelete(update.getColFamily(), update.getColQualifier(), viz, update.getTimestamp());
                    } else {
                        m.put(update.getColFamily(), update.getColQualifier(), viz, update.getTimestamp(), value);
                    }
                }
            } else {
                m.put(update.getColFamily(), update.getColQualifier(), viz, value);
            }
        }
        writer.addMutation(m);
    }
}",0.8636363636363636,1.5215311004784688,1.0,1.5,0.5,0.15079365079365079,-0.6256518675123323,1.9166666666666667,-0.02631578947368421,0.6080047025466364
wicket,remotes/origin/bugs-dot-jar_WICKET-3834_747bccb5,1,"/**
 *  Parses the given URL string.
 *
 *  @param url
 *            full absolute or relative url with query string
 *  @param charset
 *  @return Url object
 */
public static Url parse(String url, Charset charset) {
    Args.notNull(url, ""url"");
    Url result = new Url(charset);
    // the url object resolved the charset, use that
    charset = result.getCharset();
    // extract query string part
    final String queryString;
    final String absoluteUrl;
    int queryAt = url.indexOf('?');
    if (queryAt == -1) {
        queryString = """";
        absoluteUrl = url;
    } else {
        absoluteUrl = url.substring(0, queryAt);
        queryString = url.substring(queryAt + 1);
    }
    // get absolute / relative part of url
    String relativeUrl;
    // absolute urls contain a scheme://
    final int protocolAt = absoluteUrl.indexOf(""://"");
    if (protocolAt != -1) {
        result.protocol = absoluteUrl.substring(0, protocolAt);
        final String afterProto = absoluteUrl.substring(protocolAt + 3);
        final String hostAndPort;
        int relativeAt = afterProto.indexOf('/');
        if (relativeAt == -1) {
            relativeUrl = """";
            hostAndPort = afterProto;
        } else {
            relativeUrl = afterProto.substring(relativeAt);
            hostAndPort = afterProto.substring(0, relativeAt);
        }
        int portAt = hostAndPort.indexOf(':');
        if (portAt == -1) {
            result.host = hostAndPort;
            result.port = null;
        } else {
            result.host = hostAndPort.substring(0, portAt);
            result.port = Integer.parseInt(hostAndPort.substring(portAt + 1));
        }
    } else {
        relativeUrl = absoluteUrl;
    }
    if (relativeUrl.length() > 0) {
        boolean removeLast = false;
        if (relativeUrl.endsWith(""/"")) {
            // we need to append something and remove it after splitting
            // because otherwise the
            // trailing slashes will be lost
            relativeUrl += ""/x"";
            removeLast = true;
        }
        String[] segmentArray = Strings.split(relativeUrl, '/');
        if (removeLast) {
            segmentArray[segmentArray.length - 1] = null;
        }
        for (String s : segmentArray) {
            if (s != null) {
                result.segments.add(decodeSegment(s, charset));
            }
        }
    }
    if (queryString.length() > 0) {
        String[] queryArray = Strings.split(queryString, '&');
        for (String s : queryArray) {
            result.parameters.add(parseQueryParameter(s, charset));
        }
    }
    return result;
}","/**
 *  Parses the given URL string.
 *
 *  @param url
 *            full absolute or relative url with query string
 *  @param charset
 *  @return Url object
 */
","public static Url parse(String url, Charset charset) {
    Args.notNull(url, ""url"");
    Url result = new Url(charset);
        charset = result.getCharset();
        final String queryString;
    final String absoluteUrl;
    int queryAt = url.indexOf('?');
    if (queryAt == -1) {
        queryString = """";
        absoluteUrl = url;
    } else {
        absoluteUrl = url.substring(0, queryAt);
        queryString = url.substring(queryAt + 1);
    }
        String relativeUrl;
        final int protocolAt = absoluteUrl.indexOf(""://"");
    if (protocolAt != -1) {
        result.protocol = absoluteUrl.substring(0, protocolAt);
        final String afterProto = absoluteUrl.substring(protocolAt + 3);
        final String hostAndPort;
        int relativeAt = afterProto.indexOf('/');
        if (relativeAt == -1) {
            relativeUrl = """";
            hostAndPort = afterProto;
        } else {
            relativeUrl = afterProto.substring(relativeAt);
            hostAndPort = afterProto.substring(0, relativeAt);
        }
        int portAt = hostAndPort.indexOf(':');
        if (portAt == -1) {
            result.host = hostAndPort;
            result.port = null;
        } else {
            result.host = hostAndPort.substring(0, portAt);
            result.port = Integer.parseInt(hostAndPort.substring(portAt + 1));
        }
    } else {
        relativeUrl = absoluteUrl;
    }
    if (relativeUrl.length() > 0) {
        boolean removeLast = false;
        if (relativeUrl.endsWith(""/"")) {
                                                relativeUrl += ""/x"";
            removeLast = true;
        }
        String[] segmentArray = Strings.split(relativeUrl, '/');
        if (removeLast) {
            segmentArray[segmentArray.length - 1] = null;
        }
        for (String s : segmentArray) {
            if (s != null) {
                result.segments.add(decodeSegment(s, charset));
            }
        }
    }
    if (queryString.length() > 0) {
        String[] queryArray = Strings.split(queryString, '&');
        for (String s : queryArray) {
            result.parameters.add(parseQueryParameter(s, charset));
        }
    }
    return result;
}",2.227272727272727,0.17224880382775115,1.6,0.5,1.0833333333333333,1.4880952380952381,-1.0341085271317827,1.5,-0.02631578947368421,5.102122485203689
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1829_ca36450e,1,"@Override
public PropertyValue currentProperty() {
    PropertyValue p = operand.currentProperty();
    if (p == null) {
        return null;
    }
    // TODO what is the expected result of LOWER(x) for an array property?
    // currently throws an exception
    String value = p.getValue(STRING);
    // TODO toLowerCase(): document the Turkish locale problem
    return PropertyValues.newString(value.toLowerCase());
}",,"@Override
public PropertyValue currentProperty() {
    PropertyValue p = operand.currentProperty();
    if (p == null) {
        return null;
    }
            String value = p.getValue(STRING);
        return PropertyValues.newString(value.toLowerCase());
}",-0.22727272727272727,-0.22966507177033516,-0.4,-0.5,-0.25,-0.08134920634920638,0.2983791402396055,-0.16666666666666666,2.263157894736842,-0.10219970839600513
flink,remotes/origin/bugs-dot-jar_FLINK-1705_5308ac83,1,"public String getHostname() {
    if (hostName == null) {
        String fqdn = getFQDNHostname();
        if (this.fqdnHostNameIsIP) {
            // fqdn to hostname translation is pointless if FQDN is an ip address.
            hostName = fqdn;
        } else {
            hostName = NetUtils.getHostnameFromFQDN(fqdn);
        }
    }
    return hostName;
}",,"public String getHostname() {
    if (hostName == null) {
        String fqdn = getFQDNHostname();
        if (this.fqdnHostNameIsIP) {
                        hostName = fqdn;
        } else {
            hostName = NetUtils.getHostnameFromFQDN(fqdn);
        }
    }
    return hostName;
}",-0.13636363636363635,0.45933014354066987,-0.2,0.0,-0.08333333333333333,-0.047619047619047616,0.2369274136715997,-0.3333333333333333,1.736842105263158,-0.10990358626810277
camel,remotes/origin/bugs-dot-jar_CAMEL-3448_b345dd82,0,"@Override
public String toString() {
    return ""ExceptionPolicyKey["" + exceptionClass + (when != null ? "" "" + when : """") + ""]"";
}",,"@Override
public String toString() {
    return ""ExceptionPolicyKey["" + exceptionClass + (when != null ? "" "" + when : """") + ""]"";
}",-0.45454545454545453,-0.6028708133971293,-0.4,-1.0,-0.25,-0.1488095238095238,0.7429175475687103,-0.5,2.552631578947368,-0.1348777971796246
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-127_029e79da,1,"/**
 * Logs a message with the specific Marker at the {@link Level#ERROR ERROR} level.
 *
 * @param marker the marker data specific to this log statement
 * @param msg    the message string to be logged
 */
public void error(Marker marker, Message msg) {
    if (isEnabled(Level.ERROR, marker, msg, null)) {
        log(null, FQCN, Level.ERROR, msg, null);
    }
}","/**
 * Logs a message with the specific Marker at the {@link Level#ERROR ERROR} level.
 *
 * @param marker the marker data specific to this log statement
 * @param msg    the message string to be logged
 */
","public void error(Marker marker, Message msg) {
    if (isEnabled(Level.ERROR, marker, msg, null)) {
        log(null, FQCN, Level.ERROR, msg, null);
    }
}",-0.4090909090909091,0.0,-0.4,-0.5,-0.08333333333333333,-0.3650793650793651,0.6109936575052852,-0.3333333333333333,0.894736842105263,-0.16279340490885932
flink,remotes/origin/bugs-dot-jar_FLINK-2442_30761572,0,"private static int countNestedElementsBefore(CompositeType<?> compositeType, int pos) {
    if (pos == 0) {
        return 0;
    }
    int ret = 0;
    for (int i = 0; i < pos; i++) {
        TypeInformation<?> fieldType = compositeType.getTypeAt(i);
        ret += fieldType.getTotalFields() - 1;
    }
    return ret;
}",,"private static int countNestedElementsBefore(CompositeType<?> compositeType, int pos) {
    if (pos == 0) {
        return 0;
    }
    int ret = 0;
    for (int i = 0; i < pos; i++) {
        TypeInformation<?> fieldType = compositeType.getTypeAt(i);
        ret += fieldType.getTotalFields() - 1;
    }
    return ret;
}",-0.13636363636363635,-0.15311004784689008,-0.2,-0.5,-0.08333333333333333,0.7797619047619047,0.1385482734319945,-0.3333333333333333,0.05263157894736841,0.2100632192850515
commons-math,remotes/origin/bugs-dot-jar_MATH-867_bfbb156d,1,"/**
 * @param point Normalized objective variables.
 * @return the objective value + penalty for violated bounds.
 */
public double value(final double[] point) {
    double value;
    if (boundaries != null && isRepairMode) {
        double[] repaired = repair(point);
        value = CMAESOptimizer.this.computeObjectiveValue(decode(repaired)) + penalty(point, repaired);
    } else {
        value = CMAESOptimizer.this.computeObjectiveValue(decode(point));
    }
    return isMinimize ? value : -value;
}","/**
 * @param point Normalized objective variables.
 * @return the objective value + penalty for violated bounds.
 */
","public double value(final double[] point) {
    double value;
    if (boundaries != null && isRepairMode) {
        double[] repaired = repair(point);
        value = CMAESOptimizer.this.computeObjectiveValue(decode(repaired)) + penalty(point, repaired);
    } else {
        value = CMAESOptimizer.this.computeObjectiveValue(decode(point));
    }
    return isMinimize ? value : -value;
}",-0.18181818181818182,-0.0909090909090911,-0.2,-0.5,0.08333333333333333,0.4285714285714286,0.18477801268498958,0.0,0.47368421052631576,0.09097353088639541
Compress,2,1,"public void close() throws IOException {
    if (!closed) {
        closed = true;
        input.close();
    }
}",,"public void close() throws IOException {
    if (!closed) {
        closed = true;
        input.close();
    }
}",-0.36363636363636365,0.13397129186602863,-0.4,-0.5,-0.25,-0.10119047619047619,0.6479210711768849,-0.4166666666666667,2.1578947368421053,-0.1443520455501576
Lang,32,1,"/**
 * <p>
 * Returns <code>true</code> if the registry contains the given object. Used by the reflection methods to avoid
 * infinite loops.
 * </p>
 *
 * @param value
 *            The object to lookup in the registry.
 * @return boolean <code>true</code> if the registry contains the given object.
 * @since 2.3
 */
static boolean isRegistered(Object value) {
    return getRegistry().contains(new IDKey(value));
}","/**
 * <p>
 * Returns <code>true</code> if the registry contains the given object. Used by the reflection methods to avoid
 * infinite loops.
 * </p>
 *
 * @param value
 *            The object to lookup in the registry.
 * @return boolean <code>true</code> if the registry contains the given object.
 * @since 2.3
 */
","static boolean isRegistered(Object value) {
    return getRegistry().contains(new IDKey(value));
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,1.0132487667371384,-0.3333333333333333,2.3421052631578947,-0.16279340490885932
commons-math,remotes/origin/bugs-dot-jar_MATH-865_b55e0206,1,"/**
 * Checks dimensions and values of boundaries and inputSigma if defined.
 */
private void checkParameters() {
    final double[] init = getStartPoint();
    final double[] lB = getLowerBound();
    final double[] uB = getUpperBound();
    // Checks whether there is at least one finite bound value.
    boolean hasFiniteBounds = false;
    for (int i = 0; i < lB.length; i++) {
        if (!Double.isInfinite(lB[i]) || !Double.isInfinite(uB[i])) {
            hasFiniteBounds = true;
            break;
        }
    }
    // Checks whether there is at least one infinite bound value.
    boolean hasInfiniteBounds = false;
    if (hasFiniteBounds) {
        for (int i = 0; i < lB.length; i++) {
            if (Double.isInfinite(lB[i]) || Double.isInfinite(uB[i])) {
                hasInfiniteBounds = true;
                break;
            }
        }
        if (hasInfiniteBounds) {
            // because mixed cases are not supported by the current code.
            throw new MathUnsupportedOperationException();
        } else {
            // Convert API to internal handling of boundaries.
            boundaries = new double[2][];
            boundaries[0] = lB;
            boundaries[1] = uB;
        }
    } else {
        // Convert API to internal handling of boundaries.
        boundaries = null;
    }
    if (inputSigma != null) {
        if (inputSigma.length != init.length) {
            throw new DimensionMismatchException(inputSigma.length, init.length);
        }
        for (int i = 0; i < init.length; i++) {
            if (inputSigma[i] < 0) {
                throw new NotPositiveException(inputSigma[i]);
            }
            if (boundaries != null) {
                if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {
                    throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);
                }
            }
        }
    }
}","/**
 * Checks dimensions and values of boundaries and inputSigma if defined.
 */
","private void checkParameters() {
    final double[] init = getStartPoint();
    final double[] lB = getLowerBound();
    final double[] uB = getUpperBound();
        boolean hasFiniteBounds = false;
    for (int i = 0; i < lB.length; i++) {
        if (!Double.isInfinite(lB[i]) || !Double.isInfinite(uB[i])) {
            hasFiniteBounds = true;
            break;
        }
    }
        boolean hasInfiniteBounds = false;
    if (hasFiniteBounds) {
        for (int i = 0; i < lB.length; i++) {
            if (Double.isInfinite(lB[i]) || Double.isInfinite(uB[i])) {
                hasInfiniteBounds = true;
                break;
            }
        }
        if (hasInfiniteBounds) {
                        throw new MathUnsupportedOperationException();
        } else {
                        boundaries = new double[2][];
            boundaries[0] = lB;
            boundaries[1] = uB;
        }
    } else {
                boundaries = null;
    }
    if (inputSigma != null) {
        if (inputSigma.length != init.length) {
            throw new DimensionMismatchException(inputSigma.length, init.length);
        }
        for (int i = 0; i < init.length; i++) {
            if (inputSigma[i] < 0) {
                throw new NotPositiveException(inputSigma[i]);
            }
            if (boundaries != null) {
                if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {
                    throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);
                }
            }
        }
    }
}",1.4090909090909092,0.7751196172248805,3.0,1.0,1.5833333333333333,2.6865079365079367,-0.8370683579985901,0.08333333333333333,-0.02631578947368421,4.564275629167315
camel,remotes/origin/bugs-dot-jar_CAMEL-5224_2db5570f,1,"/**
 * Strategy when the file was processed and a commit should be executed.
 *
 * @param processStrategy the strategy to perform the commit
 * @param exchange        the exchange
 * @param file            the file processed
 */
protected void processStrategyCommit(GenericFileProcessStrategy<T> processStrategy, Exchange exchange, GenericFile<T> file) {
    if (endpoint.isIdempotent()) {
        // only add to idempotent repository if we could process the file
        endpoint.getIdempotentRepository().add(absoluteFileName);
    }
    // delete done file if used
    if (endpoint.getDoneFileName() != null) {
        // done file must be in same path as the original input file
        String doneFileName = endpoint.createDoneFileName(absoluteFileName);
        ObjectHelper.notEmpty(doneFileName, ""doneFileName"", endpoint);
        try {
            // delete done file
            boolean deleted = operations.deleteFile(doneFileName);
            log.trace(""Done file: {} was deleted: {}"", doneFileName, deleted);
            if (!deleted) {
                log.warn(""Done file: "" + doneFileName + "" could not be deleted"");
            }
        } catch (Exception e) {
            handleException(e);
        }
    }
    try {
        log.trace(""Commit file strategy: {} for file: {}"", processStrategy, file);
        processStrategy.commit(operations, endpoint, exchange, file);
    } catch (Exception e) {
        handleException(e);
    }
}","/**
 * Strategy when the file was processed and a commit should be executed.
 *
 * @param processStrategy the strategy to perform the commit
 * @param exchange        the exchange
 * @param file            the file processed
 */
","protected void processStrategyCommit(GenericFileProcessStrategy<T> processStrategy, Exchange exchange, GenericFile<T> file) {
    if (endpoint.isIdempotent()) {
                endpoint.getIdempotentRepository().add(absoluteFileName);
    }
        if (endpoint.getDoneFileName() != null) {
                String doneFileName = endpoint.createDoneFileName(absoluteFileName);
        ObjectHelper.notEmpty(doneFileName, ""doneFileName"", endpoint);
        try {
                        boolean deleted = operations.deleteFile(doneFileName);
            log.trace(""Done file: {} was deleted: {}"", doneFileName, deleted);
            if (!deleted) {
                log.warn(""Done file: "" + doneFileName + "" could not be deleted"");
            }
        } catch (Exception e) {
            handleException(e);
        }
    }
    try {
        log.trace(""Commit file strategy: {} for file: {}"", processStrategy, file);
        processStrategy.commit(operations, endpoint, exchange, file);
    } catch (Exception e) {
        handleException(e);
    }
}",0.45454545454545453,0.4545454545454545,0.4,0.5,0.08333333333333333,0.3492063492063492,-0.3750528541226213,0.5833333333333334,-0.02631578947368421,0.43372463592722565
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-135_438e31a7,1,"@Override
@Nonnull
public PropertyIterator getProperties() throws RepositoryException {
    checkStatus();
    Iterator<PropertyDelegate> properties = dlg.getProperties();
    return new PropertyIteratorAdapter(propertyIterator(properties));
}",,"@Override
@Nonnull
public PropertyIterator getProperties() throws RepositoryException {
    checkStatus();
    Iterator<PropertyDelegate> properties = dlg.getProperties();
    return new PropertyIteratorAdapter(propertyIterator(properties));
}",-0.3181818181818182,-0.48325358851674655,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.480197322057787,-0.25,1.131578947368421,-0.16279340490885932
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-539_ffa818f3,1,"@Override
public int compareTo(Id o) {
    byte[] other = o.getBytes();
    int len = Math.min(raw.length, other.length);
    for (int i = 0; i < len; i++) {
        if (raw[i] != other[i]) {
            return raw[i] - other[i];
        }
    }
    return raw.length - other.length;
}",,"@Override
public int compareTo(Id o) {
    byte[] other = o.getBytes();
    int len = Math.min(raw.length, other.length);
    for (int i = 0; i < len; i++) {
        if (raw[i] != other[i]) {
            return raw[i] - other[i];
        }
    }
    return raw.length - other.length;
}",-0.13636363636363635,0.29186602870813394,-0.2,0.0,-0.08333333333333333,0.5416666666666667,0.1103594080338268,-0.3333333333333333,0.15789473684210528,0.19531935247776946
camel,remotes/origin/bugs-dot-jar_CAMEL-8125_36e7b668,3,"protected Component lookupPropertiesComponent() {
    // no existing properties component so lookup and add as component if possible
    PropertiesComponent answer = (PropertiesComponent) hasComponent(""properties"");
    if (answer == null) {
        answer = getRegistry().lookupByNameAndType(""properties"", PropertiesComponent.class);
        if (answer != null) {
            addComponent(""properties"", answer);
        }
    }
    return answer;
}",,"protected Component lookupPropertiesComponent() {
        PropertiesComponent answer = (PropertiesComponent) hasComponent(""properties"");
    if (answer == null) {
        answer = getRegistry().lookupByNameAndType(""properties"", PropertiesComponent.class);
        if (answer != null) {
            addComponent(""properties"", answer);
        }
    }
    return answer;
}",-0.18181818181818182,0.29186602870813394,-0.2,0.0,-0.16666666666666666,0.013888888888888857,0.23890063424947125,-0.16666666666666666,0.4473684210526315,-0.07901891968211706
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-1025_a96b455c,1,"@Override
public Level toLevel(final java.util.logging.Level javaLevel) {
    return julToLog4j.get(javaLevel);
}",,"@Override
public Level toLevel(final java.util.logging.Level javaLevel) {
    return julToLog4j.get(javaLevel);
}",-0.45454545454545453,-0.6028708133971293,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,0.7978858350951374,-0.4166666666666667,0.3684210526315789,-0.16279340490885932
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-43_668f08f2,1,"void apply() throws Exception {
    removeNode(nodePath);
}",,"void apply() throws Exception {
    removeNode(nodePath);
}",-0.5,-0.5263157894736844,-0.6,-1.0,-0.4166666666666667,-0.3650793650793651,1.1099365750528538,-0.4166666666666667,2.3157894736842106,-0.16279340490885932
Math,49,1,"/**
 * {@inheritDoc}
 */
@Override
public OpenMapRealVector ebeMultiply(double[] v) {
    checkVectorDimensions(v.length);
    OpenMapRealVector res = new OpenMapRealVector(this);
    Iterator iter = res.entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        res.setEntry(iter.key(), iter.value() * v[iter.key()]);
    }
    return res;
}","/**
 * {@inheritDoc}
 */
","@Override
public OpenMapRealVector ebeMultiply(double[] v) {
    checkVectorDimensions(v.length);
    OpenMapRealVector res = new OpenMapRealVector(this);
    Iterator iter = res.entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        res.setEntry(iter.key(), iter.value() * v[iter.key()]);
    }
    return res;
}",-0.13636363636363635,-0.15311004784689008,-0.4,-0.5,-0.25,-0.015873015873015886,0.1450317124735728,0.16666666666666666,0.1842105263157895,-0.04874281795496851
Closure,148,2,"private int findLastLine() {
    int maxLine = 0;
    for (Mapping mapping : mappings) {
        int endPositionLine = mapping.endPosition.getLineNumber();
        maxLine = Math.max(maxLine, endPositionLine);
    }
    return maxLine + prefixPosition.getLineNumber();
}",,"private int findLastLine() {
    int maxLine = 0;
    for (Mapping mapping : mappings) {
        int endPositionLine = mapping.endPosition.getLineNumber();
        maxLine = Math.max(maxLine, endPositionLine);
    }
    return maxLine + prefixPosition.getLineNumber();
}",-0.2727272727272727,-0.07655502392344504,-0.4,-0.5,-0.4166666666666667,-0.07539682539682542,0.35560253699788563,-0.25,0.13157894736842105,-0.10224581179440188
flink,remotes/origin/bugs-dot-jar_FLINK-1686_1f726e48,0,"@Override
public void setInputsOutputs() {
    try {
        inputHandler = new InputHandler<IN>(this);
        iterationId = configuration.getIterationId();
        iterationWaitTime = configuration.getIterationWaitTime();
        shouldWait = iterationWaitTime > 0;
        BlockingQueueBroker.instance().get(iterationId.toString() + ""-"" + getEnvironment().getIndexInSubtaskGroup());
    } catch (Exception e) {
        throw new StreamVertexException(String.format(""Cannot register inputs of StreamIterationSink %s"", iterationId), e);
    }
}",,"@Override
public void setInputsOutputs() {
    try {
        inputHandler = new InputHandler<IN>(this);
        iterationId = configuration.getIterationId();
        iterationWaitTime = configuration.getIterationWaitTime();
        shouldWait = iterationWaitTime > 0;
        BlockingQueueBroker.instance().get(iterationId.toString() + ""-"" + getEnvironment().getIndexInSubtaskGroup());
    } catch (Exception e) {
        throw new StreamVertexException(String.format(""Cannot register inputs of StreamIterationSink %s"", iterationId), e);
    }
}",-0.09090909090909091,0.1578947368421051,-0.2,-0.5,-0.4166666666666667,-0.12896825396825398,0.06243833685694159,0.16666666666666666,0.05263157894736841,-0.06398921180477515
